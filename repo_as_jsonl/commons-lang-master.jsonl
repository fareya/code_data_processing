{"callee_method_names": ["CountDownLatch.await", "CloseableCounter.increment"], "method_name": "AbstractBackgroundInitializerTestImpl.initializeInternal", "method_implementation": "{\n    if (ex != null) {\n        throw ex;\n    }\n    if (shouldSleep) {\n        ThreadUtils.sleep(Duration.ofMinutes(1));\n    }\n    if (waitForLatch) {\n        latch.await();\n    }\n    return counter.increment();\n}", "repo_id": "8", "comment": "/**\n * Records this invocation. Optionally throws an exception or sleeps a\n * while.\n *\n * @throws Exception in case of an error\n */\n", "repo_name": "commons-lang-master/", "id": 1549, "method_signature": "CloseableCounter initializeInternal()", "filename": "AbstractBackgroundInitializerTestImpl.initializeInternal.json"}
{"callee_method_names": ["CountDownLatch.await", "CloseableCounter.increment"], "method_name": "AbstractChildBackgroundInitializer.initializeInternal", "method_implementation": "{\n    initializeCalls++;\n    currentExecutor = getActiveExecutor();\n    if (waitForLatch) {\n        latch.await();\n    }\n    if (ex != null) {\n        throw ex;\n    }\n    return counter.increment();\n}", "repo_id": "8", "comment": "/**\n * Records this invocation. Optionally throws an exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1574, "method_signature": "CloseableCounter initializeInternal()", "filename": "AbstractChildBackgroundInitializer.initializeInternal.json"}
{"callee_method_names": ["AtomicReference.compareAndSet", "State.oppositeState", "PropertyChangeSupport.firePropertyChange"], "method_name": "AbstractCircuitBreaker.changeState", "method_implementation": "{\n    if (state.compareAndSet(newState.oppositeState(), newState)) {\n        changeSupport.firePropertyChange(PROPERTY_NAME, !isOpen(newState), isOpen(newState));\n    }\n}", "repo_id": "8", "comment": "/**\n * Changes the internal state of this circuit breaker. If there is actually a change\n * of the state value, all registered change listeners are notified.\n *\n * @param newState the new state to be set\n */\n", "repo_name": "commons-lang-master/", "id": 151, "method_signature": "void changeState(State)", "filename": "AbstractCircuitBreaker.changeState.json"}
{"callee_method_names": ["FailableConsumer<? super T, ? extends Exception>.accept"], "method_name": "AbstractConcurrentInitializer.close", "method_implementation": "{\n    if (isInitialized()) {\n        try {\n            closer.accept(get());\n        } catch (final Exception e) {\n            // This intentionally does not duplicate the logic in initialize\n            // or care about the generic type E.\n            //\n            // initialize may run inside a Future and it does not make sense\n            // to wrap an exception stored inside a Future. However close()\n            // always runs on the current thread so it always wraps in a\n            // ConcurrentException\n            throw new ConcurrentException(ExceptionUtils.throwUnchecked(e));\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Calls the closer with the manager object.\n *\n * @throws ConcurrentException Thrown by the closer.\n * @since 3.14.0\n */\n", "repo_name": "commons-lang-master/", "id": 91, "method_signature": "void close()", "filename": "AbstractConcurrentInitializer.close.json"}
{"callee_method_names": ["FailableSupplier<? extends T, ? extends Exception>.get", "E.getClass", "Exception.getClass"], "method_name": "AbstractConcurrentInitializer.initialize", "method_implementation": "{\n    try {\n        return initializer.get();\n    } catch (final Exception e) {\n        // Do this first so we don't pass a RuntimeException or Error into an exception constructor\n        ExceptionUtils.throwUnchecked(e);\n        // Depending on the subclass of AbstractConcurrentInitializer E can be Exception or ConcurrentException\n        // if E is Exception the if statement below will always be true, and the new Exception object created\n        // in getTypedException will never be thrown. If E is ConcurrentException and the if statement is false\n        // we throw the ConcurrentException returned from getTypedException, which wraps the original exception.\n        final E typedException = getTypedException(e);\n        if (typedException.getClass().isAssignableFrom(e.getClass())) {\n            throw (E) e;\n        }\n        throw typedException;\n    }\n}", "repo_id": "8", "comment": "/**\n * Creates and initializes the object managed by this {@code\n * ConcurrentInitializer}. This method is called by {@link #get()} when the object is accessed for the first time. An implementation can focus on the\n * creation of the object. No synchronization is needed, as this is already handled by {@code get()}.\n * <p>\n * Subclasses and clients that do not provide an initializer are expected to implement this method.\n * </p>\n *\n * @return the managed data object\n * @throws E if an error occurs during object creation\n */\n", "repo_name": "commons-lang-master/", "id": 92, "method_signature": "T initialize()", "filename": "AbstractConcurrentInitializer.initialize.json"}
{"callee_method_names": [], "method_name": "AbstractConcurrentInitializerCloseAndExceptionsTest.methodThatThrowsException", "method_implementation": "{\n    switch(input) {\n        case IOException:\n            throw new IOException();\n        case SQLException:\n            throw new SQLException();\n        case NullPointerException:\n            throw new NullPointerException();\n        default:\n            fail();\n            return new CloseableObject();\n    }\n}", "repo_id": "8", "comment": "// multiple exception types on the method signature.\n", "repo_name": "commons-lang-master/", "id": 1494, "method_signature": "CloseableObject methodThatThrowsException(ExceptionToThrow)", "filename": "AbstractConcurrentInitializerCloseAndExceptionsTest.methodThatThrowsException.json"}
{"callee_method_names": ["ConcurrentInitializer<CloseableObject>.get", "Error.getCause"], "method_name": "AbstractConcurrentInitializerCloseAndExceptionsTest.testCloserThrowsCheckedException", "method_implementation": "{\n    final ConcurrentInitializer<CloseableObject> initializer = createInitializerThatThrowsException(CloseableObject::new, (CloseableObject) -> methodThatThrowsException(ExceptionToThrow.IOException));\n    try {\n        initializer.get();\n        ((AbstractConcurrentInitializer) initializer).close();\n        fail();\n    } catch (Exception e) {\n        assertThat(e, instanceOf(ConcurrentException.class));\n        assertThat(e.getCause(), instanceOf(IOException.class));\n    }\n}", "repo_id": "8", "comment": "/**\n * This method tests that if AbstractConcurrentInitializer.close catches a\n * ConcurrentException it will rethrow it wrapped in a ConcurrentException\n */\n", "repo_name": "commons-lang-master/", "id": 1495, "method_signature": "void testCloserThrowsCheckedException()", "filename": "AbstractConcurrentInitializerCloseAndExceptionsTest.testCloserThrowsCheckedException.json"}
{"callee_method_names": ["ConcurrentInitializer<CloseableObject>.get"], "method_name": "AbstractConcurrentInitializerCloseAndExceptionsTest.testCloserThrowsRuntimeException", "method_implementation": "{\n    final ConcurrentInitializer<CloseableObject> initializer = createInitializerThatThrowsException(CloseableObject::new, (CloseableObject) -> methodThatThrowsException(ExceptionToThrow.NullPointerException));\n    initializer.get();\n    assertThrows(NullPointerException.class, () -> {\n        ((AbstractConcurrentInitializer) initializer).close();\n    });\n}", "repo_id": "8", "comment": "/**\n * This method tests that if AbstractConcurrentInitializer.close catches a\n * RuntimeException it will throw it without wrapping it in a ConcurrentException\n */\n", "repo_name": "commons-lang-master/", "id": 1496, "method_signature": "void testCloserThrowsRuntimeException()", "filename": "AbstractConcurrentInitializerCloseAndExceptionsTest.testCloserThrowsRuntimeException.json"}
{"callee_method_names": ["ConcurrentInitializer<CloseableObject>.get"], "method_name": "AbstractConcurrentInitializerCloseAndExceptionsTest.testSupplierThrowsCheckedException", "method_implementation": "{\n    final ConcurrentInitializer<CloseableObject> initializer = createInitializerThatThrowsException(() -> methodThatThrowsException(ExceptionToThrow.IOException), FailableConsumer.NOP);\n    assertThrows(ConcurrentException.class, () -> initializer.get());\n}", "repo_id": "8", "comment": "/**\n * This method tests that if AbstractConcurrentInitializer.initialize catches a checked\n * exception it will rethrow it wrapped in a ConcurrentException\n */\n", "repo_name": "commons-lang-master/", "id": 1497, "method_signature": "void testSupplierThrowsCheckedException()", "filename": "AbstractConcurrentInitializerCloseAndExceptionsTest.testSupplierThrowsCheckedException.json"}
{"callee_method_names": ["ConcurrentInitializer<CloseableObject>.get"], "method_name": "AbstractConcurrentInitializerCloseAndExceptionsTest.testSupplierThrowsConcurrentException", "method_implementation": "{\n    final ConcurrentException concurrentException = new ConcurrentException();\n    @SuppressWarnings(\"unchecked\")\n    final ConcurrentInitializer<CloseableObject> initializer = createInitializerThatThrowsException(() -> {\n        if (\"test\".equals(\"test\")) {\n            throw concurrentException;\n        }\n        return new CloseableObject();\n    }, FailableConsumer.NOP);\n    try {\n        initializer.get();\n        fail();\n    } catch (ConcurrentException e) {\n        assertEquals(concurrentException, e);\n    }\n}", "repo_id": "8", "comment": "/**\n * This method tests that if a AbstractConcurrentInitializer.initialize method catches a\n * ConcurrentException it will rethrow it without wrapping it.\n */\n", "repo_name": "commons-lang-master/", "id": 1498, "method_signature": "void testSupplierThrowsConcurrentException()", "filename": "AbstractConcurrentInitializerCloseAndExceptionsTest.testSupplierThrowsConcurrentException.json"}
{"callee_method_names": ["ConcurrentInitializer<CloseableObject>.get"], "method_name": "AbstractConcurrentInitializerCloseAndExceptionsTest.testSupplierThrowsRuntimeException", "method_implementation": "{\n    final ConcurrentInitializer<CloseableObject> initializer = createInitializerThatThrowsException(() -> methodThatThrowsException(ExceptionToThrow.NullPointerException), FailableConsumer.NOP);\n    assertThrows(NullPointerException.class, () -> initializer.get());\n}", "repo_id": "8", "comment": "/**\n * This method tests that if AbstractConcurrentInitializer.initialize catches a runtime exception\n * it will not be wrapped in a ConcurrentException\n */\n", "repo_name": "commons-lang-master/", "id": 1499, "method_signature": "void testSupplierThrowsRuntimeException()", "filename": "AbstractConcurrentInitializerCloseAndExceptionsTest.testSupplierThrowsRuntimeException.json"}
{"callee_method_names": ["ConcurrentInitializer<CloseableObject>.get", "CloseableObject.isClosed", "CloseableObject.isClosed"], "method_name": "AbstractConcurrentInitializerCloseAndExceptionsTest.testWorkingCloser", "method_implementation": "{\n    final ConcurrentInitializer<CloseableObject> initializer = createInitializerThatThrowsException(CloseableObject::new, CloseableObject::close);\n    CloseableObject closeableObject = initializer.get();\n    assertFalse(closeableObject.isClosed());\n    ((AbstractConcurrentInitializer) initializer).close();\n    assertTrue(closeableObject.isClosed());\n}", "repo_id": "8", "comment": "/**\n * This method tests that if AbstractConcurrentInitializer.close actually closes the wrapped object\n */\n", "repo_name": "commons-lang-master/", "id": 1500, "method_signature": "void testWorkingCloser()", "filename": "AbstractConcurrentInitializerCloseAndExceptionsTest.testWorkingCloser.json"}
{"callee_method_names": ["CountDownLatch.await", "ConcurrentInitializer<Object>.get", "GetThread[].start", "CountDownLatch.countDown", "CharSequence.join", "ConcurrentInitializer<Object>.get"], "method_name": "AbstractConcurrentInitializerTest.testGetConcurrent", "method_implementation": "{\n    final ConcurrentInitializer<Object> initializer = createInitializer();\n    final int threadCount = 20;\n    final CountDownLatch startLatch = new CountDownLatch(1);\n    final class GetThread extends Thread {\n\n        Object object;\n\n        @Override\n        public void run() {\n            try {\n                // wait until all threads are ready for maximum parallelism\n                startLatch.await();\n                // access the initializer\n                object = initializer.get();\n            } catch (final InterruptedException iex) {\n                // ignore\n            } catch (final ConcurrentException cex) {\n                object = cex;\n            }\n        }\n    }\n    final GetThread[] threads = new GetThread[threadCount];\n    for (int i = 0; i < threadCount; i++) {\n        threads[i] = new GetThread();\n        threads[i].start();\n    }\n    // fire all threads and wait until they are ready\n    startLatch.countDown();\n    for (final Thread t : threads) {\n        t.join();\n    }\n    // check results\n    final Object managedObject = initializer.get();\n    for (final GetThread t : threads) {\n        assertEquals(managedObject, t.object, \"Wrong object\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests whether get() can be invoked from multiple threads concurrently.\n * Always the same object should be returned.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the object under test may throw it.\n * @throws InterruptedException because the threading API my throw it.\n */\n", "repo_name": "commons-lang-master/", "id": 1430, "method_signature": "void testGetConcurrent()", "filename": "AbstractConcurrentInitializerTest.testGetConcurrent.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.get", "ConcurrentInitializer<Object>.get"], "method_name": "AbstractConcurrentInitializerTest.testGetMultipleTimes", "method_implementation": "{\n    final ConcurrentInitializer<Object> initializer = createInitializer();\n    final Object obj = initializer.get();\n    for (int i = 0; i < 10; i++) {\n        assertEquals(obj, initializer.get(), \"Got different object at \" + i);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests whether sequential get() invocations always return the same\n * instance.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the object under test may throw it.\n */\n", "repo_name": "commons-lang-master/", "id": 1431, "method_signature": "void testGetMultipleTimes()", "filename": "AbstractConcurrentInitializerTest.testGetMultipleTimes.json"}
{"callee_method_names": ["AbstractConcurrentInitializer.isInitialized", "AbstractConcurrentInitializer.get", "AbstractConcurrentInitializer.isInitialized"], "method_name": "AbstractConcurrentInitializerTest.testisInitialized", "method_implementation": "{\n    final ConcurrentInitializer<Object> initializer = createInitializer();\n    if (initializer instanceof AbstractConcurrentInitializer) {\n        AbstractConcurrentInitializer castedInitializer = (AbstractConcurrentInitializer) initializer;\n        assertFalse(castedInitializer.isInitialized(), \"was initialized before get()\");\n        assertNotNull(castedInitializer.get(), \"No managed object\");\n        assertTrue(castedInitializer.isInitialized(), \"was not initialized after get()\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests a simple invocation of the isInitialized() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1432, "method_signature": "void testisInitialized()", "filename": "AbstractConcurrentInitializerTest.testisInitialized.json"}
{"callee_method_names": [], "method_name": "AbstractFormatCache.getDateTimeInstance", "method_implementation": "{\n    locale = LocaleUtils.toLocale(locale);\n    final String pattern = getPatternForStyle(dateStyle, timeStyle, locale);\n    return getInstance(pattern, timeZone, locale);\n}", "repo_id": "8", "comment": "// This must remain private, see LANG-884\n", "repo_name": "commons-lang-master/", "id": 714, "method_signature": "F getDateTimeInstance(Integer, Integer, TimeZone, Locale)", "filename": "AbstractFormatCache.getDateTimeInstance.json"}
{"callee_method_names": ["ConcurrentHashMap.computeIfAbsent"], "method_name": "AbstractFormatCache.getInstance", "method_implementation": "{\n    Objects.requireNonNull(pattern, \"pattern\");\n    final TimeZone actualTimeZone = TimeZones.toTimeZone(timeZone);\n    final Locale actualLocale = LocaleUtils.toLocale(locale);\n    final ArrayKey key = new ArrayKey(pattern, actualTimeZone, actualLocale);\n    return cInstanceCache.computeIfAbsent(key, k -> createInstance(pattern, actualTimeZone, actualLocale));\n}", "repo_id": "8", "comment": "/**\n * Gets a formatter instance using the specified pattern, time zone\n * and locale.\n *\n * @param pattern  {@link java.text.SimpleDateFormat} compatible\n *  pattern, non-null\n * @param timeZone  the time zone, null means use the default TimeZone\n * @param locale  the locale, null means use the default Locale\n * @return a pattern based date/time formatter\n * @throws NullPointerException if pattern is {@code null}\n * @throws IllegalArgumentException if pattern is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 715, "method_signature": "F getInstance(String, TimeZone, Locale)", "filename": "AbstractFormatCache.getInstance.json"}
{"callee_method_names": ["ConcurrentHashMap.computeIfAbsent", "Integer.intValue", "Integer.intValue", "Integer.intValue", "Integer.intValue"], "method_name": "AbstractFormatCache.getPatternForStyle", "method_implementation": "{\n    final Locale safeLocale = LocaleUtils.toLocale(locale);\n    final ArrayKey key = new ArrayKey(dateStyle, timeStyle, safeLocale);\n    return cDateTimeInstanceCache.computeIfAbsent(key, k -> {\n        try {\n            final DateFormat formatter;\n            if (dateStyle == null) {\n                formatter = DateFormat.getTimeInstance(timeStyle.intValue(), safeLocale);\n            } else if (timeStyle == null) {\n                formatter = DateFormat.getDateInstance(dateStyle.intValue(), safeLocale);\n            } else {\n                formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), safeLocale);\n            }\n            return ((SimpleDateFormat) formatter).toPattern();\n        } catch (final ClassCastException ex) {\n            throw new IllegalArgumentException(\"No date time pattern for locale: \" + safeLocale);\n        }\n    });\n}", "repo_id": "8", "comment": "// package protected, for access from test code; do not make public or protected\n", "repo_name": "commons-lang-master/", "id": 713, "method_signature": "String getPatternForStyle(Integer, Integer, Locale)", "filename": "AbstractFormatCache.getPatternForStyle.json"}
{"callee_method_names": [], "method_name": "AggregateTranslator.translate", "method_implementation": "{\n    for (final CharSequenceTranslator translator : translators) {\n        final int consumed = translator.translate(input, index, out);\n        if (consumed != 0) {\n            return consumed;\n        }\n    }\n    return 0;\n}", "repo_id": "8", "comment": "/**\n * The first translator to consume code points from the input is the 'winner'.\n * Execution stops with the number of consumed code points being returned.\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 435, "method_signature": "int translate(CharSequence, int, Writer)", "filename": "AggregateTranslator.translate.json"}
{"callee_method_names": [], "method_name": "AnnotationUtils.annotationArrayMemberEquals", "method_implementation": "{\n    if (a1.length != a2.length) {\n        return false;\n    }\n    for (int i = 0; i < a1.length; i++) {\n        if (!equals(a1[i], a2[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Helper method for comparing two arrays of annotations.\n *\n * @param a1 the first array\n * @param a2 the second array\n * @return a flag whether these arrays are equal\n */\n", "repo_name": "commons-lang-master/", "id": 770, "method_signature": "boolean annotationArrayMemberEquals(Annotation[], Annotation[])", "filename": "AnnotationUtils.annotationArrayMemberEquals.json"}
{"callee_method_names": [], "method_name": "AnnotationUtils.appendDetail", "method_implementation": "{\n    if (value instanceof Annotation) {\n        value = AnnotationUtils.toString((Annotation) value);\n    }\n    super.appendDetail(buffer, fieldName, value);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 768, "method_signature": "void appendDetail(StringBuffer, String, Object)", "filename": "AnnotationUtils.appendDetail.json"}
{"callee_method_names": ["Class<?>.isAnnotation", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals"], "method_name": "AnnotationUtils.arrayMemberEquals", "method_implementation": "{\n    if (componentType.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (componentType.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (componentType.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (componentType.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (componentType.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (componentType.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (componentType.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (componentType.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (componentType.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}", "repo_id": "8", "comment": "/**\n * Helper method for comparing two objects of an array type.\n *\n * @param componentType the component type of the array\n * @param o1 the first object\n * @param o2 the second object\n * @return a flag whether these objects are equal\n */\n", "repo_name": "commons-lang-master/", "id": 771, "method_signature": "boolean arrayMemberEquals(Class, Object, Object)", "filename": "AnnotationUtils.arrayMemberEquals.json"}
{"callee_method_names": ["Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals", "Class<?>.equals"], "method_name": "AnnotationUtils.arrayMemberHash", "method_implementation": "{\n    if (componentType.equals(Byte.TYPE)) {\n        return Arrays.hashCode((byte[]) o);\n    }\n    if (componentType.equals(Short.TYPE)) {\n        return Arrays.hashCode((short[]) o);\n    }\n    if (componentType.equals(Integer.TYPE)) {\n        return Arrays.hashCode((int[]) o);\n    }\n    if (componentType.equals(Character.TYPE)) {\n        return Arrays.hashCode((char[]) o);\n    }\n    if (componentType.equals(Long.TYPE)) {\n        return Arrays.hashCode((long[]) o);\n    }\n    if (componentType.equals(Float.TYPE)) {\n        return Arrays.hashCode((float[]) o);\n    }\n    if (componentType.equals(Double.TYPE)) {\n        return Arrays.hashCode((double[]) o);\n    }\n    if (componentType.equals(Boolean.TYPE)) {\n        return Arrays.hashCode((boolean[]) o);\n    }\n    return Arrays.hashCode((Object[]) o);\n}", "repo_id": "8", "comment": "/**\n * Helper method for generating a hash code for an array.\n *\n * @param componentType the component type of the array\n * @param o the array\n * @return a hash code for the specified array\n */\n", "repo_name": "commons-lang-master/", "id": 772, "method_signature": "int arrayMemberHash(Class, Object)", "filename": "AnnotationUtils.arrayMemberHash.json"}
{"callee_method_names": ["Annotation.annotationType", "Annotation.annotationType", "Class<? extends Annotation>.equals", "Class<? extends Annotation>.getDeclaredMethods", "Matcher.getParameterTypes", "Matcher.getReturnType", "Matcher.invoke", "Matcher.invoke", "Matcher.getReturnType"], "method_name": "AnnotationUtils.equals", "method_implementation": "{\n    if (a1 == a2) {\n        return true;\n    }\n    if (a1 == null || a2 == null) {\n        return false;\n    }\n    final Class<? extends Annotation> type1 = a1.annotationType();\n    final Class<? extends Annotation> type2 = a2.annotationType();\n    Validate.notNull(type1, \"Annotation %s with null annotationType()\", a1);\n    Validate.notNull(type2, \"Annotation %s with null annotationType()\", a2);\n    if (!type1.equals(type2)) {\n        return false;\n    }\n    try {\n        for (final Method m : type1.getDeclaredMethods()) {\n            if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) {\n                final Object v1 = m.invoke(a1);\n                final Object v2 = m.invoke(a2);\n                if (!memberEquals(m.getReturnType(), v1, v2)) {\n                    return false;\n                }\n            }\n        }\n    } catch (final ReflectiveOperationException ex) {\n        return false;\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if two annotations are equal using the criteria for equality\n * presented in the {@link Annotation#equals(Object)} API docs.\n *\n * @param a1 the first Annotation to compare, {@code null} returns\n * {@code false} unless both are {@code null}\n * @param a2 the second Annotation to compare, {@code null} returns\n * {@code false} unless both are {@code null}\n * @return {@code true} if the two annotations are {@code equal} or both\n * {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 773, "method_signature": "boolean equals(Annotation, Annotation)", "filename": "AnnotationUtils.equals.json"}
{"callee_method_names": [], "method_name": "AnnotationUtils.getShortClassName", "method_implementation": "{\n    // formatter:off\n    return ClassUtils.getAllInterfaces(cls).stream().filter(Annotation.class::isAssignableFrom).findFirst().map(iface -> \"@\" + iface.getName()).orElse(StringUtils.EMPTY);\n    // formatter:on\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 769, "method_signature": "String getShortClassName(Class)", "filename": "AnnotationUtils.getShortClassName.json"}
{"callee_method_names": ["Annotation.annotationType", "Class<? extends Annotation>.getDeclaredMethods", "Matcher.invoke", "Matcher.getName"], "method_name": "AnnotationUtils.hashCode", "method_implementation": "{\n    int result = 0;\n    final Class<? extends Annotation> type = a.annotationType();\n    for (final Method m : type.getDeclaredMethods()) {\n        try {\n            final Object value = m.invoke(a);\n            if (value == null) {\n                throw new IllegalStateException(String.format(\"Annotation method %s returned null\", m));\n            }\n            result += hashMember(m.getName(), value);\n        } catch (final ReflectiveOperationException ex) {\n            throw new UncheckedException(ex);\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Generate a hash code for the given annotation using the algorithm\n * presented in the {@link Annotation#hashCode()} API docs.\n *\n * @param a the Annotation for a hash code calculation is desired, not\n * {@code null}\n * @return the calculated hash code\n * @throws RuntimeException if an {@link Exception} is encountered during\n * annotation member access\n * @throws IllegalStateException if an annotation method invocation returns\n * {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 774, "method_signature": "int hashCode(Annotation)", "filename": "AnnotationUtils.hashCode.json"}
{"callee_method_names": ["String.hashCode", "Object.getClass", "Object.hashCode"], "method_name": "AnnotationUtils.hashMember", "method_implementation": "{\n    final int part1 = name.hashCode() * 127;\n    if (ObjectUtils.isArray(value)) {\n        return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);\n    }\n    if (value instanceof Annotation) {\n        return part1 ^ hashCode((Annotation) value);\n    }\n    return part1 ^ value.hashCode();\n}", "repo_id": "8", "comment": "/**\n * Helper method for generating a hash code for a member of an annotation.\n *\n * @param name the name of the member\n * @param value the value of the member\n * @return a hash code for this member\n */\n", "repo_name": "commons-lang-master/", "id": 775, "method_signature": "int hashMember(String, Object)", "filename": "AnnotationUtils.hashMember.json"}
{"callee_method_names": ["Class<?>.isArray", "Class<?>.getComponentType", "Class<?>.isPrimitive", "Class<?>.isEnum", "Class<?>.isAnnotation"], "method_name": "AnnotationUtils.isValidAnnotationMemberType", "method_implementation": "{\n    if (type == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        type = type.getComponentType();\n    }\n    return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type);\n}", "repo_id": "8", "comment": "/**\n * Checks if the specified type is permitted as an annotation member.\n *\n * <p>The Java language specification only permits certain types to be used\n * in annotations. These include {@link String}, {@link Class}, primitive\n * types, {@link Annotation}, {@link Enum}, and single-dimensional arrays of\n * these types.</p>\n *\n * @param type the type to check, {@code null}\n * @return {@code true} if the type is a valid type to use in an annotation\n */\n", "repo_name": "commons-lang-master/", "id": 776, "method_signature": "boolean isValidAnnotationMemberType(Class)", "filename": "AnnotationUtils.isValidAnnotationMemberType.json"}
{"callee_method_names": ["Class<?>.isArray", "Class<?>.getComponentType", "Class<?>.isAnnotation", "Object.equals"], "method_name": "AnnotationUtils.memberEquals", "method_implementation": "{\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}", "repo_id": "8", "comment": "/**\n * Helper method for checking whether two objects of the given type are\n * equal. This method is used to compare the parameters of two annotation\n * instances.\n *\n * @param type the type of the objects to be compared\n * @param o1 the first object\n * @param o2 the second object\n * @return a flag whether these objects are equal\n */\n", "repo_name": "commons-lang-master/", "id": 777, "method_signature": "boolean memberEquals(Class, Object, Object)", "filename": "AnnotationUtils.memberEquals.json"}
{"callee_method_names": ["Annotation.annotationType", "Matcher.getParameterTypes", "ToStringBuilder.append", "Matcher.getName", "Matcher.invoke", "ToStringBuilder.build"], "method_name": "AnnotationUtils.toString", "method_implementation": "{\n    final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n    for (final Method m : a.annotationType().getDeclaredMethods()) {\n        if (m.getParameterTypes().length > 0) {\n            // wtf?\n            continue;\n        }\n        try {\n            builder.append(m.getName(), m.invoke(a));\n        } catch (final ReflectiveOperationException ex) {\n            throw new UncheckedException(ex);\n        }\n    }\n    return builder.build();\n}", "repo_id": "8", "comment": "/**\n * Generate a string representation of an Annotation, as suggested by\n * {@link Annotation#toString()}.\n *\n * @param a the annotation of which a string representation is desired\n * @return the standard string representation of an annotation, not\n * {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 778, "method_signature": "String toString(Annotation)", "filename": "AnnotationUtils.toString.json"}
{"callee_method_names": ["Map<String, Processor>.containsKey", "Map<String, Processor>.put"], "method_name": "ArchUtils.addProcessor", "method_implementation": "{\n    if (ARCH_TO_PROCESSOR.containsKey(key)) {\n        throw new IllegalStateException(\"Key \" + key + \" already exists in processor map\");\n    }\n    ARCH_TO_PROCESSOR.put(key, processor);\n}", "repo_id": "8", "comment": "/**\n * Adds the given {@link Processor} with the given key {@link String} to the map.\n *\n * @param key       The key as {@link String}.\n * @param processor The {@link Processor} to add.\n * @throws IllegalStateException If the key already exists.\n */\n", "repo_name": "commons-lang-master/", "id": 85, "method_signature": "void addProcessor(String, Processor)", "filename": "ArchUtils.addProcessor.json"}
{"callee_method_names": ["T[].getClass", "T.getClass"], "method_name": "ArrayUtils.add", "method_implementation": "{\n    final Class<?> type;\n    if (array != null) {\n        type = array.getClass().getComponentType();\n    } else if (element != null) {\n        type = element.getClass();\n    } else {\n        throw new IllegalArgumentException(\"Arguments cannot both be null\");\n    }\n    // type must be T\n    @SuppressWarnings(\"unchecked\")\n    final T[] newArray = (T[]) copyArrayGrow1(array, type);\n    newArray[newArray.length - 1] = element;\n    return newArray;\n}", "repo_id": "8", "comment": "/**\n * Copies the given array and adds the given element at the end of the new array.\n * <p>\n * The new array contains the same elements of the input\n * array plus the given element in the last position. The component type of\n * the new array is the same as that of the input array.\n * </p>\n * <p>\n * If the input array is {@code null}, a new one element array is returned\n * whose component type is the same as the element, unless the element itself is null,\n * in which case the return type is Object[]\n * </p>\n * <pre>\n * ArrayUtils.add(null, null)      = IllegalArgumentException\n * ArrayUtils.add(null, \"a\")       = [\"a\"]\n * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n * </pre>\n *\n * @param <T> the component type of the array\n * @param array  the array to \"add\" the element to, may be {@code null}\n * @param element  the object to add, may be {@code null}\n * @return A new array containing the existing elements plus the new element\n * The returned array type will be that of the input array (unless null),\n * in which case it will have the same type as the element.\n * If both are null, an IllegalArgumentException is thrown\n * @since 2.1\n * @throws IllegalArgumentException if both arguments are null\n */\n", "repo_name": "commons-lang-master/", "id": 1150, "method_signature": "T[] add(T[], T)", "filename": "ArrayUtils.add.json"}
{"callee_method_names": ["T.getClass", "Class<T>.isAssignableFrom", "Class<?>.getName", "Class<T>.getName"], "method_name": "ArrayUtils.addAll", "method_implementation": "{\n    if (array1 == null) {\n        return clone(array2);\n    }\n    if (array2 == null) {\n        return clone(array1);\n    }\n    final Class<T> type1 = getComponentType(array1);\n    final T[] joinedArray = newInstance(type1, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n    try {\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n    } catch (final ArrayStoreException ase) {\n        // Check if problem was due to incompatible types\n        /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n        final Class<?> type2 = array2.getClass().getComponentType();\n        if (!type1.isAssignableFrom(type2)) {\n            throw new IllegalArgumentException(\"Cannot store \" + type2.getName() + \" in an array of \" + type1.getName(), ase);\n        }\n        // No, so rethrow original\n        throw ase;\n    }\n    return joinedArray;\n}", "repo_id": "8", "comment": "/**\n * Adds all the elements of the given arrays into a new array.\n * <p>\n * The new array contains all of the element of {@code array1} followed\n * by all of the elements {@code array2}. When an array is returned, it is always\n * a new array.\n * </p>\n * <pre>\n * ArrayUtils.addAll(null, null)     = null\n * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n * ArrayUtils.addAll([], [])         = []\n * ArrayUtils.addAll(null, null)     = null\n * ArrayUtils.addAll([null], [null]) = [null, null]\n * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n * </pre>\n *\n * @param <T> the component type of the array\n * @param array1  the first array whose elements are added to the new array, may be {@code null}\n * @param array2  the second array whose elements are added to the new array, may be {@code null}\n * @return The new array, {@code null} if both arrays are {@code null}.\n *      The type of the new array is the type of the first array,\n *      unless the first array is null, in which case the type is the same as the second array.\n * @since 2.1\n * @throws IllegalArgumentException if the array types are incompatible\n */\n", "repo_name": "commons-lang-master/", "id": 1159, "method_signature": "T[] addAll(T[], T[])", "filename": "ArrayUtils.addAll.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "ArrayUtils.copyArrayGrow1", "method_implementation": "{\n    if (array != null) {\n        final int arrayLength = Array.getLength(array);\n        final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n        System.arraycopy(array, 0, newArray, 0, arrayLength);\n        return newArray;\n    }\n    return Array.newInstance(newArrayComponentType, 1);\n}", "repo_id": "8", "comment": "/**\n * Returns a copy of the given array of size 1 greater than the argument.\n * The last value of the array is left to the default value.\n *\n * @param array The array to copy, must not be {@code null}.\n * @param newArrayComponentType If {@code array} is {@code null}, create a\n * size 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n", "repo_name": "commons-lang-master/", "id": 1160, "method_signature": "Object copyArrayGrow1(Object, Class)", "filename": "ArrayUtils.copyArrayGrow1.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.indexOf", "method_implementation": "{\n    if (array == null) {\n        return INDEX_NOT_FOUND;\n    }\n    if (startIndex < 0) {\n        startIndex = 0;\n    }\n    for (int i = startIndex; i < array.length; i++) {\n        if (valueToFind == array[i]) {\n            return i;\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Finds the index of the given value in the array starting at the given index.\n * <p>\n * This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n * </p>\n * <p>\n * A negative startIndex is treated as zero. A startIndex larger than the array\n * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).\n * </p>\n *\n * @param array  the array to search through for the object, may be {@code null}\n * @param valueToFind  the value to find\n * @param startIndex  the index to start searching at\n * @return the index of the value within the array,\n *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n */\n", "repo_name": "commons-lang-master/", "id": 1180, "method_signature": "int indexOf(short[], short, int)", "filename": "ArrayUtils.indexOf.json"}
{"callee_method_names": ["BitSet.set"], "method_name": "ArrayUtils.indexesOf", "method_implementation": "{\n    final BitSet bitSet = new BitSet();\n    if (array == null) {\n        return bitSet;\n    }\n    while (startIndex < array.length) {\n        startIndex = indexOf(array, valueToFind, startIndex);\n        if (startIndex == INDEX_NOT_FOUND) {\n            break;\n        }\n        bitSet.set(startIndex);\n        ++startIndex;\n    }\n    return bitSet;\n}", "repo_id": "8", "comment": "/**\n * Finds the indices of the given value in the array starting at the given index.\n *\n * <p>This method returns an empty BitSet for a {@code null} input array.</p>\n *\n * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n * length will return an empty BitSet.</p>\n *\n * @param array  the array to search through for the object, may be {@code null}\n * @param valueToFind  the value to find\n * @param startIndex  the index to start searching at\n * @return a BitSet of all the indices of the value within the array,\n *  an empty BitSet if not found or {@code null} array input\n * @since 3.10\n */\n", "repo_name": "commons-lang-master/", "id": 1170, "method_signature": "BitSet indexesOf(short[], short, int)", "filename": "ArrayUtils.indexesOf.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.insert", "method_implementation": "{\n    /*\n         * Note on use of @SafeVarargs:\n         *\n         * By returning null when 'array' is null, we avoid returning the vararg\n         * array to the caller. We also avoid relying on the type of the vararg\n         * array, by inspecting the component type of 'array'.\n         */\n    if (array == null) {\n        return null;\n    }\n    if (ArrayUtils.isEmpty(values)) {\n        return clone(array);\n    }\n    if (index < 0 || index > array.length) {\n        throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n    }\n    final Class<T> type = getComponentType(array);\n    final int length = array.length + values.length;\n    final T[] result = newInstance(type, length);\n    System.arraycopy(values, 0, result, index, values.length);\n    if (index > 0) {\n        System.arraycopy(array, 0, result, 0, index);\n    }\n    if (index < array.length) {\n        System.arraycopy(array, index, result, index + values.length, array.length - index);\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Inserts elements into an array at the given index (starting from zero).\n *\n * <p>When an array is returned, it is always a new array.</p>\n *\n * <pre>\n * ArrayUtils.insert(index, null, null)      = null\n * ArrayUtils.insert(index, array, null)     = cloned copy of 'array'\n * ArrayUtils.insert(index, null, values)    = null\n * </pre>\n *\n * @param <T> The type of elements in {@code array} and {@code values}\n * @param index the position within {@code array} to insert the new values\n * @param array the array to insert the values into, may be {@code null}\n * @param values the new values to insert, may be {@code null}\n * @return The new array or {@code null} if the given array is {@code null}.\n * @throws IndexOutOfBoundsException if {@code array} is provided\n * and either {@code index < 0} or {@code index > array.length}\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1189, "method_signature": "T[] insert(int, T[], T[])", "filename": "ArrayUtils.insert.json"}
{"callee_method_names": ["Object.getClass", "Object.getClass"], "method_name": "ArrayUtils.isSameType", "method_implementation": "{\n    if (array1 == null || array2 == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    return array1.getClass().getName().equals(array2.getClass().getName());\n}", "repo_id": "8", "comment": "/**\n * Checks whether two arrays are the same type taking into account\n * multidimensional arrays.\n *\n * @param array1 the first array, must not be {@code null}\n * @param array2 the second array, must not be {@code null}\n * @return {@code true} if type of arrays matches\n * @throws IllegalArgumentException if either array is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 1190, "method_signature": "boolean isSameType(Object, Object)", "filename": "ArrayUtils.isSameType.json"}
{"callee_method_names": ["Comparator<T>.compare"], "method_name": "ArrayUtils.isSorted", "method_implementation": "{\n    Objects.requireNonNull(comparator, \"comparator\");\n    if (getLength(array) < 2) {\n        return true;\n    }\n    T previous = array[0];\n    final int n = array.length;\n    for (int i = 1; i < n; i++) {\n        final T current = array[i];\n        if (comparator.compare(previous, current) > 0) {\n            return false;\n        }\n        previous = current;\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * This method checks whether the provided array is sorted according to the provided {@link Comparator}.\n *\n * @param array the array to check\n * @param comparator the {@link Comparator} to compare over\n * @param <T> the datatype of the array\n * @return whether the array is sorted\n * @throws NullPointerException if {@code comparator} is {@code null}\n * @since 3.4\n */\n", "repo_name": "commons-lang-master/", "id": 1199, "method_signature": "boolean isSorted(T[], Comparator)", "filename": "ArrayUtils.isSorted.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.lastIndexOf", "method_implementation": "{\n    if (array == null || startIndex < 0) {\n        return INDEX_NOT_FOUND;\n    }\n    if (startIndex >= array.length) {\n        startIndex = array.length - 1;\n    }\n    for (int i = startIndex; i >= 0; i--) {\n        if (valueToFind == array[i]) {\n            return i;\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Finds the last index of the given value in the array starting at the given index.\n * <p>\n * This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n * </p>\n * <p>\n * A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the\n * array length will search from the end of the array.\n * </p>\n *\n * @param array  the array to traverse for looking for the object, may be {@code null}\n * @param valueToFind  the value to find\n * @param startIndex  the start index to traverse backwards from\n * @return the last index of the value within the array,\n *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n */\n", "repo_name": "commons-lang-master/", "id": 1209, "method_signature": "int lastIndexOf(short[], short, int)", "filename": "ArrayUtils.lastIndexOf.json"}
{"callee_method_names": ["Class<T[]>.cast", "Class<T[]>.getComponentType"], "method_name": "ArrayUtils.nullToEmpty", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"The type must not be null\");\n    }\n    if (array == null) {\n        return type.cast(Array.newInstance(type.getComponentType(), 0));\n    }\n    return array;\n}", "repo_id": "8", "comment": "/**\n * Defensive programming technique to change a {@code null}\n * reference to an empty one.\n * <p>\n * This method returns an empty array for a {@code null} input array.\n * </p>\n *\n * @param array  the array to check for {@code null} or empty\n * @param type   the class representation of the desired array\n * @param <T>  the class type\n * @return the same array, {@code public static} empty array if {@code null}\n * @throws IllegalArgumentException if the type argument is null\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1210, "method_signature": "T[] nullToEmpty(T[], Class)", "filename": "ArrayUtils.nullToEmpty.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "ArrayUtils.remove", "method_implementation": "{\n    final int length = getLength(array);\n    if (index < 0 || index >= length) {\n        throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n    }\n    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n    System.arraycopy(array, 0, result, 0, index);\n    if (index < length - 1) {\n        System.arraycopy(array, index + 1, result, index, length - index - 1);\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Removes the element at the specified position from the specified array.\n * All subsequent elements are shifted to the left (subtracts one from\n * their indices).\n * <p>\n * This method returns a new array with the same elements of the input\n * array except the element on the specified position. The component\n * type of the returned array is always the same as that of the input\n * array.\n * </p>\n * <p>\n * If the input array is {@code null}, an IndexOutOfBoundsException\n * will be thrown, because in that case no valid index can be specified.\n * </p>\n *\n * @param array  the array to remove the element from, may not be {@code null}\n * @param index  the position of the element to be removed\n * @return A new array containing the existing elements except the element\n *         at the specified position.\n * @throws IndexOutOfBoundsException if the index is out of range\n * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 1211, "method_signature": "Object remove(Object, int)", "filename": "ArrayUtils.remove.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "ArrayUtils.removeAll", "method_implementation": "{\n    final int length = getLength(array);\n    // number of distinct indexes, i.e. number of entries that will be removed\n    int diff = 0;\n    final int[] clonedIndices = ArraySorter.sort(clone(indices));\n    // identify length of result array\n    if (isNotEmpty(clonedIndices)) {\n        int i = clonedIndices.length;\n        int prevIndex = length;\n        while (--i >= 0) {\n            final int index = clonedIndices[i];\n            if (index < 0 || index >= length) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n            }\n            if (index >= prevIndex) {\n                continue;\n            }\n            diff++;\n            prevIndex = index;\n        }\n    }\n    // create result array\n    final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff);\n    if (diff < length) {\n        // index just after last copy\n        int end = length;\n        // number of entries so far not copied\n        int dest = length - diff;\n        for (int i = clonedIndices.length - 1; i >= 0; i--) {\n            final int index = clonedIndices[i];\n            if (end - index > 1) {\n                // same as (cp > 0)\n                final int cp = end - index - 1;\n                dest -= cp;\n                System.arraycopy(array, index + 1, result, dest, cp);\n                // After this copy, we still have room for dest items.\n            }\n            end = index;\n        }\n        if (end > 0) {\n            System.arraycopy(array, 0, result, 0, end);\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "// package protected for access by unit tests\n", "repo_name": "commons-lang-master/", "id": 1213, "method_signature": "Object removeAll(Object, int[])", "filename": "ArrayUtils.removeAll.json"}
{"callee_method_names": ["HashMap<T, MutableInt>.get", "HashMap<T, MutableInt>.put", "MutableInt.increment", "HashMap<T, MutableInt>.get", "MutableInt.decrementAndGet", "HashMap<T, MutableInt>.remove", "BitSet.set"], "method_name": "ArrayUtils.removeElements", "method_implementation": "{\n    if (isEmpty(array) || isEmpty(values)) {\n        return clone(array);\n    }\n    final HashMap<T, MutableInt> occurrences = new HashMap<>(values.length);\n    for (final T v : values) {\n        final MutableInt count = occurrences.get(v);\n        if (count == null) {\n            occurrences.put(v, new MutableInt(1));\n        } else {\n            count.increment();\n        }\n    }\n    final BitSet toRemove = new BitSet();\n    for (int i = 0; i < array.length; i++) {\n        final T key = array[i];\n        final MutableInt count = occurrences.get(key);\n        if (count != null) {\n            if (count.decrementAndGet() == 0) {\n                occurrences.remove(key);\n            }\n            toRemove.set(i);\n        }\n    }\n    // removeAll() always creates an array of the same type as its input\n    @SuppressWarnings(\"unchecked\")\n    final T[] result = (T[]) removeAll(array, toRemove);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Removes occurrences of specified elements, in specified quantities,\n * from the specified array. All subsequent elements are shifted left.\n * For any element-to-be-removed specified in greater quantities than\n * contained in the original array, no change occurs beyond the\n * removal of the existing matching items.\n * <p>\n * This method returns a new array with the same elements of the input\n * array except for the earliest-encountered occurrences of the specified\n * elements. The component type of the returned array is always the same\n * as that of the input array.\n * </p>\n * <pre>\n * ArrayUtils.removeElements(null, \"a\", \"b\")            = null\n * ArrayUtils.removeElements([], \"a\", \"b\")              = []\n * ArrayUtils.removeElements([\"a\"], \"b\", \"c\")           = [\"a\"]\n * ArrayUtils.removeElements([\"a\", \"b\"], \"a\", \"c\")      = [\"b\"]\n * ArrayUtils.removeElements([\"a\", \"b\", \"a\"], \"a\")      = [\"b\", \"a\"]\n * ArrayUtils.removeElements([\"a\", \"b\", \"a\"], \"a\", \"a\") = [\"b\"]\n * </pre>\n *\n * @param <T> the component type of the array\n * @param array  the array to remove the element from, may be {@code null}\n * @param values the elements to be removed\n * @return A new array containing the existing elements except the\n *         earliest-encountered occurrences of the specified elements.\n * @since 3.0.1\n */\n", "repo_name": "commons-lang-master/", "id": 1222, "method_signature": "T[] removeElements(T[], T[])", "filename": "ArrayUtils.removeElements.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.reverse", "method_implementation": "{\n    if (array == null) {\n        return;\n    }\n    int i = Math.max(startIndexInclusive, 0);\n    int j = Math.min(array.length, endIndexExclusive) - 1;\n    short tmp;\n    while (j > i) {\n        tmp = array[j];\n        array[j] = array[i];\n        array[i] = tmp;\n        j--;\n        i++;\n    }\n}", "repo_id": "8", "comment": "/**\n * Reverses the order of the given array in the given range.\n * <p>\n * This method does nothing for a {@code null} input array.\n * </p>\n *\n * @param array\n *            the array to reverse, may be {@code null}\n * @param startIndexInclusive\n *            the starting index. Undervalue (&lt;0) is promoted to 0, overvalue (&gt;array.length) results in no\n *            change.\n * @param endIndexExclusive\n *            elements up to endIndex-1 are reversed in the array. Undervalue (&lt; start index) results in no\n *            change. Overvalue (&gt;array.length) is demoted to array length.\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 1240, "method_signature": "void reverse(short[], int, int)", "filename": "ArrayUtils.reverse.json"}
{"callee_method_names": ["Supplier<? extends T>.get"], "method_name": "ArrayUtils.setAll", "method_implementation": "{\n    if (array != null && generator != null) {\n        for (int i = 0; i < array.length; i++) {\n            array[i] = generator.get();\n        }\n    }\n    return array;\n}", "repo_id": "8", "comment": "/**\n * Sets all elements of the specified array, using the provided generator supplier to compute each element.\n * <p>\n * If the generator supplier throws an exception, it is relayed to the caller and the array is left in an indeterminate\n * state.\n * </p>\n *\n * @param <T> type of elements of the array.\n * @param array array to be initialized.\n * @param generator a function accepting an index and producing the desired value for that position.\n * @return the input array\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 1242, "method_signature": "T[] setAll(T[], Supplier)", "filename": "ArrayUtils.setAll.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.shift", "method_implementation": "{\n    if (array == null || startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n        return;\n    }\n    if (startIndexInclusive < 0) {\n        startIndexInclusive = 0;\n    }\n    if (endIndexExclusive >= array.length) {\n        endIndexExclusive = array.length;\n    }\n    int n = endIndexExclusive - startIndexInclusive;\n    if (n <= 1) {\n        return;\n    }\n    offset %= n;\n    if (offset < 0) {\n        offset += n;\n    }\n    // For algorithm explanations and proof of O(n) time complexity and O(1) space complexity\n    // see https://beradrian.wordpress.com/2015/04/07/shift-an-array-in-on-in-place/\n    while (n > 1 && offset > 0) {\n        final int nOffset = n - offset;\n        if (offset > nOffset) {\n            swap(array, startIndexInclusive, startIndexInclusive + n - nOffset, nOffset);\n            n = offset;\n            offset -= nOffset;\n        } else if (offset < nOffset) {\n            swap(array, startIndexInclusive, startIndexInclusive + nOffset, offset);\n            startIndexInclusive += offset;\n            n = nOffset;\n        } else {\n            swap(array, startIndexInclusive, startIndexInclusive + nOffset, offset);\n            break;\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Shifts the order of a series of elements in the given short array.\n *\n * <p>There is no special handling for multi-dimensional arrays. This method\n * does nothing for {@code null} or empty input arrays.</p>\n *\n * @param array\n *            the array to shift, may be {@code null}\n * @param startIndexInclusive\n *            the starting index. Undervalue (&lt;0) is promoted to 0, overvalue (&gt;array.length) results in no\n *            change.\n * @param endIndexExclusive\n *            elements up to endIndex-1 are shifted in the array. Undervalue (&lt; start index) results in no\n *            change. Overvalue (&gt;array.length) is demoted to array length.\n * @param offset\n *          The number of positions to rotate the elements.  If the offset is larger than the number of elements to\n *          rotate, than the effective offset is modulo the number of elements to rotate.\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1260, "method_signature": "void shift(short[], int, int, int)", "filename": "ArrayUtils.shift.json"}
{"callee_method_names": ["Random.nextInt"], "method_name": "ArrayUtils.shuffle", "method_implementation": "{\n    for (int i = array.length; i > 1; i--) {\n        swap(array, i - 1, random.nextInt(i), 1);\n    }\n}", "repo_id": "8", "comment": "/**\n * Randomly permutes the elements of the specified array using the Fisher-Yates algorithm.\n *\n * @param array   the array to shuffle\n * @param random  the source of randomness used to permute the elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\">Fisher-Yates shuffle algorithm</a>\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1269, "method_signature": "void shuffle(short[], Random)", "filename": "ArrayUtils.shuffle.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.subarray", "method_implementation": "{\n    if (array == null) {\n        return null;\n    }\n    if (startIndexInclusive < 0) {\n        startIndexInclusive = 0;\n    }\n    if (endIndexExclusive > array.length) {\n        endIndexExclusive = array.length;\n    }\n    final int newSize = endIndexExclusive - startIndexInclusive;\n    final Class<T> type = getComponentType(array);\n    if (newSize <= 0) {\n        return newInstance(type, 0);\n    }\n    final T[] subarray = newInstance(type, newSize);\n    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n    return subarray;\n}", "repo_id": "8", "comment": "/**\n * Produces a new array containing the elements between\n * the start and end indices.\n * <p>\n * The start index is inclusive, the end index exclusive.\n * Null array input produces null output.\n * </p>\n * <p>\n * The component type of the subarray is always the same as\n * that of the input array. Thus, if the input is an array of type\n * {@link Date}, the following usage is envisaged:\n * </p>\n * <pre>\n * Date[] someDates = (Date[]) ArrayUtils.subarray(allDates, 2, 5);\n * </pre>\n *\n * @param <T> the component type of the array\n * @param array  the array\n * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n *      is promoted to 0, overvalue (&gt;array.length) results\n *      in an empty array.\n * @param endIndexExclusive  elements up to endIndex-1 are present in the\n *      returned subarray. Undervalue (&lt; startIndex) produces\n *      empty array, overvalue (&gt;array.length) is demoted to\n *      array length.\n * @return a new array containing the elements between\n *      the start and end indices.\n * @since 2.1\n * @see Arrays#copyOfRange(Object[], int, int)\n */\n", "repo_name": "commons-lang-master/", "id": 1278, "method_signature": "T[] subarray(T[], int, int)", "filename": "ArrayUtils.subarray.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.swap", "method_implementation": "{\n    if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n        return;\n    }\n    if (offset1 < 0) {\n        offset1 = 0;\n    }\n    if (offset2 < 0) {\n        offset2 = 0;\n    }\n    if (offset1 == offset2) {\n        return;\n    }\n    len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n    for (int i = 0; i < len; i++, offset1++, offset2++) {\n        final short aux = array[offset1];\n        array[offset1] = array[offset2];\n        array[offset2] = aux;\n    }\n}", "repo_id": "8", "comment": "/**\n * Swaps a series of elements in the given short array.\n *\n * <p>This method does nothing for a {@code null} or empty input array or\n * for overflow indices. Negative indices are promoted to 0(zero). If any\n * of the sub-arrays to swap falls outside of the given array, then the\n * swap is stopped at the end of the array and as many as possible elements\n * are swapped.</p>\n *\n * Examples:\n * <ul>\n *     <li>ArrayUtils.swap([1, 2, 3, 4], 0, 2, 1) -&gt; [3, 2, 1, 4]</li>\n *     <li>ArrayUtils.swap([1, 2, 3, 4], 0, 0, 1) -&gt; [1, 2, 3, 4]</li>\n *     <li>ArrayUtils.swap([1, 2, 3, 4], 2, 0, 2) -&gt; [3, 4, 1, 2]</li>\n *     <li>ArrayUtils.swap([1, 2, 3, 4], -3, 2, 2) -&gt; [3, 4, 1, 2]</li>\n *     <li>ArrayUtils.swap([1, 2, 3, 4], 0, 3, 3) -&gt; [4, 2, 3, 1]</li>\n * </ul>\n *\n * @param array the array to swap, may be {@code null}\n * @param offset1 the index of the first element in the series to swap\n * @param offset2 the index of the second element in the series to swap\n * @param len the number of elements to swap starting with the given indices\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1287, "method_signature": "void swap(short[], int, int, int)", "filename": "ArrayUtils.swap.json"}
{"callee_method_names": ["Map<Object, Object>.put", "Object[].getKey", "Object[].getValue", "Map<Object, Object>.put"], "method_name": "ArrayUtils.toMap", "method_implementation": "{\n    if (array == null) {\n        return null;\n    }\n    final Map<Object, Object> map = new HashMap<>((int) (array.length * 1.5));\n    for (int i = 0; i < array.length; i++) {\n        final Object object = array[i];\n        if (object instanceof Map.Entry<?, ?>) {\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object;\n            map.put(entry.getKey(), entry.getValue());\n        } else if (object instanceof Object[]) {\n            final Object[] entry = (Object[]) object;\n            if (entry.length < 2) {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n            }\n            map.put(entry[0], entry[1]);\n        } else {\n            throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n        }\n    }\n    return map;\n}", "repo_id": "8", "comment": "/**\n * Converts the given array into a {@link java.util.Map}. Each element of the array\n * must be either a {@link java.util.Map.Entry} or an Array, containing at least two\n * elements, where the first element is used as key and the second as\n * value.\n * <p>\n * This method can be used to initialize:\n * </p>\n * <pre>\n * // Create a Map mapping colors.\n * Map colorMap = ArrayUtils.toMap(new String[][] {\n *     {\"RED\", \"#FF0000\"},\n *     {\"GREEN\", \"#00FF00\"},\n *     {\"BLUE\", \"#0000FF\"}});\n * </pre>\n * <p>\n * This method returns {@code null} for a {@code null} input array.\n * </p>\n *\n * @param array  an array whose elements are either a {@link java.util.Map.Entry} or\n *  an Array containing at least two elements, may be {@code null}\n * @return a {@link Map} that was created from the array\n * @throws IllegalArgumentException  if one element of this Array is\n *  itself an Array containing less than two elements\n * @throws IllegalArgumentException  if the array contains elements other\n *  than {@link java.util.Map.Entry} and an Array\n */\n", "repo_name": "commons-lang-master/", "id": 1288, "method_signature": "Map<Object,Object> toMap(Object[])", "filename": "ArrayUtils.toMap.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.toObject", "method_implementation": "{\n    if (array == null) {\n        return null;\n    }\n    if (array.length == 0) {\n        return EMPTY_SHORT_OBJECT_ARRAY;\n    }\n    return setAll(new Short[array.length], i -> Short.valueOf(array[i]));\n}", "repo_id": "8", "comment": "/**\n * Converts an array of primitive shorts to objects.\n *\n * <p>This method returns {@code null} for a {@code null} input array.</p>\n *\n * @param array  a {@code short} array\n * @return a {@link Short} array, {@code null} if null array input\n */\n", "repo_name": "commons-lang-master/", "id": 1296, "method_signature": "Short[] toObject(short[])", "filename": "ArrayUtils.toObject.json"}
{"callee_method_names": ["Short.shortValue"], "method_name": "ArrayUtils.toPrimitive", "method_implementation": "{\n    if (array == null) {\n        return null;\n    }\n    if (array.length == 0) {\n        return EMPTY_SHORT_ARRAY;\n    }\n    final short[] result = new short[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Short b = array[i];\n        result[i] = b == null ? valueForNull : b.shortValue();\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of object Short to primitives handling {@code null}.\n * <p>\n * This method returns {@code null} for a {@code null} input array.\n * </p>\n *\n * @param array  a {@link Short} array, may be {@code null}\n * @param valueForNull  the value to insert if {@code null} found\n * @return a {@code byte} array, {@code null} if null array input\n */\n", "repo_name": "commons-lang-master/", "id": 1312, "method_signature": "short[] toPrimitive(Short[], short)", "filename": "ArrayUtils.toPrimitive.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.toString", "method_implementation": "{\n    if (array == null) {\n        return stringIfNull;\n    }\n    return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n}", "repo_id": "8", "comment": "/**\n * Outputs an array as a String handling {@code null}s.\n * <p>\n * Multi-dimensional arrays are handled correctly, including\n * multi-dimensional primitive arrays.\n * </p>\n * <p>\n * The format is that of Java source code, for example {@code {a,b}}.\n * </p>\n *\n * @param array  the array to get a toString for, may be {@code null}\n * @param stringIfNull  the String to return if the array is {@code null}\n * @return a String representation of the array\n */\n", "repo_name": "commons-lang-master/", "id": 1313, "method_signature": "String toString(Object, String)", "filename": "ArrayUtils.toString.json"}
{"callee_method_names": [], "method_name": "ArrayUtils.toStringArray", "method_implementation": "{\n    if (null == array) {\n        return null;\n    }\n    if (array.length == 0) {\n        return EMPTY_STRING_ARRAY;\n    }\n    final String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = Objects.toString(array[i], valueForNullElements);\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Returns an array containing the string representation of each element in the argument\n * array handling {@code null} elements.\n * <p>\n * This method returns {@code null} for a {@code null} input array.\n * </p>\n *\n * @param array the Object[] to be processed, may be null\n * @param valueForNullElements the value to insert if {@code null} is found\n * @return a {@link String} array, {@code null} if null array input\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1315, "method_signature": "String[] toStringArray(Object[], String)", "filename": "ArrayUtils.toStringArray.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testArrayCreation", "method_implementation": "{\n    final String[] array = ArrayUtils.toArray(\"foo\", \"bar\");\n    assertEquals(2, array.length);\n    assertEquals(\"foo\", array[0]);\n    assertEquals(\"bar\", array[1]);\n}", "repo_id": "8", "comment": "/**\n * Tests generic array creation with parameters of same type.\n */\n", "repo_name": "commons-lang-master/", "id": 1999, "method_signature": "void testArrayCreation()", "filename": "ArrayUtilsTest.testArrayCreation.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testArrayCreationWithDifferentTypes", "method_implementation": "{\n    final Number[] array = ArrayUtils.<Number>toArray(Integer.valueOf(42), Double.valueOf(Math.PI));\n    assertEquals(2, array.length);\n    assertEquals(Integer.valueOf(42), array[0]);\n    assertEquals(Double.valueOf(Math.PI), array[1]);\n}", "repo_id": "8", "comment": "/**\n * Tests generic array creation with parameters of common base type.\n */\n", "repo_name": "commons-lang-master/", "id": 2000, "method_signature": "void testArrayCreationWithDifferentTypes()", "filename": "ArrayUtilsTest.testArrayCreationWithDifferentTypes.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testArrayCreationWithGeneralReturnType", "method_implementation": "{\n    final Object obj = ArrayUtils.toArray(\"foo\", \"bar\");\n    assertTrue(obj instanceof String[]);\n}", "repo_id": "8", "comment": "/**\n * Tests generic array creation with general return type.\n */\n", "repo_name": "commons-lang-master/", "id": 2001, "method_signature": "void testArrayCreationWithGeneralReturnType()", "filename": "ArrayUtilsTest.testArrayCreationWithGeneralReturnType.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testEmptyArrayCreation", "method_implementation": "{\n    final String[] array = ArrayUtils.<String>toArray();\n    assertEquals(0, array.length);\n}", "repo_id": "8", "comment": "/**\n * Tests generic empty array creation with generic type.\n */\n", "repo_name": "commons-lang-master/", "id": 2002, "method_signature": "void testEmptyArrayCreation()", "filename": "ArrayUtilsTest.testEmptyArrayCreation.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testIndirectArrayCreation", "method_implementation": "{\n    final String[] array = toArrayPropagatingType(\"foo\", \"bar\");\n    assertEquals(2, array.length);\n    assertEquals(\"foo\", array[0]);\n    assertEquals(\"bar\", array[1]);\n}", "repo_id": "8", "comment": "/**\n * Tests generic array creation with generic type.\n */\n", "repo_name": "commons-lang-master/", "id": 2003, "method_signature": "void testIndirectArrayCreation()", "filename": "ArrayUtilsTest.testIndirectArrayCreation.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testIndirectEmptyArrayCreation", "method_implementation": "{\n    final String[] array = ArrayUtilsTest.<String>toArrayPropagatingType();\n    assertEquals(0, array.length);\n}", "repo_id": "8", "comment": "/**\n * Tests indirect generic empty array creation with generic type.\n */\n", "repo_name": "commons-lang-master/", "id": 2004, "method_signature": "void testIndirectEmptyArrayCreation()", "filename": "ArrayUtilsTest.testIndirectEmptyArrayCreation.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testIsEmptyObject", "method_implementation": "{\n    final Object[] emptyArray = {};\n    final Object[] notEmptyArray = { \"Value\" };\n    assertTrue(ArrayUtils.isEmpty((Object[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyArray));\n}", "repo_id": "8", "comment": "/**\n * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 2005, "method_signature": "void testIsEmptyObject()", "filename": "ArrayUtilsTest.testIsEmptyObject.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testIsEmptyPrimitives", "method_implementation": "{\n    final long[] emptyLongArray = {};\n    final long[] notEmptyLongArray = { 1L };\n    assertTrue(ArrayUtils.isEmpty((long[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyLongArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyLongArray));\n    final int[] emptyIntArray = {};\n    final int[] notEmptyIntArray = { 1 };\n    assertTrue(ArrayUtils.isEmpty((int[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyIntArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyIntArray));\n    final short[] emptyShortArray = {};\n    final short[] notEmptyShortArray = { 1 };\n    assertTrue(ArrayUtils.isEmpty((short[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyShortArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyShortArray));\n    final char[] emptyCharArray = {};\n    final char[] notEmptyCharArray = { 1 };\n    assertTrue(ArrayUtils.isEmpty((char[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyCharArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyCharArray));\n    final byte[] emptyByteArray = {};\n    final byte[] notEmptyByteArray = { 1 };\n    assertTrue(ArrayUtils.isEmpty((byte[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyByteArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyByteArray));\n    final double[] emptyDoubleArray = {};\n    final double[] notEmptyDoubleArray = { 1.0 };\n    assertTrue(ArrayUtils.isEmpty((double[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyDoubleArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyDoubleArray));\n    final float[] emptyFloatArray = {};\n    final float[] notEmptyFloatArray = { 1.0F };\n    assertTrue(ArrayUtils.isEmpty((float[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyFloatArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyFloatArray));\n    final boolean[] emptyBooleanArray = {};\n    final boolean[] notEmptyBooleanArray = { true };\n    assertTrue(ArrayUtils.isEmpty((boolean[]) null));\n    assertTrue(ArrayUtils.isEmpty(emptyBooleanArray));\n    assertFalse(ArrayUtils.isEmpty(notEmptyBooleanArray));\n}", "repo_id": "8", "comment": "/**\n * Tests for {@link ArrayUtils#isEmpty(long[])},\n * {@link ArrayUtils#isEmpty(int[])},\n * {@link ArrayUtils#isEmpty(short[])},\n * {@link ArrayUtils#isEmpty(char[])},\n * {@link ArrayUtils#isEmpty(byte[])},\n * {@link ArrayUtils#isEmpty(double[])},\n * {@link ArrayUtils#isEmpty(float[])} and\n * {@link ArrayUtils#isEmpty(boolean[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 2006, "method_signature": "void testIsEmptyPrimitives()", "filename": "ArrayUtilsTest.testIsEmptyPrimitives.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testIsNotEmptyObject", "method_implementation": "{\n    final Object[] emptyArray = {};\n    final Object[] notEmptyArray = { \"Value\" };\n    assertFalse(ArrayUtils.isNotEmpty((Object[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyArray));\n}", "repo_id": "8", "comment": "/**\n * Test for {@link ArrayUtils#isNotEmpty(java.lang.Object[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 2007, "method_signature": "void testIsNotEmptyObject()", "filename": "ArrayUtilsTest.testIsNotEmptyObject.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testIsNotEmptyPrimitives", "method_implementation": "{\n    final long[] emptyLongArray = {};\n    final long[] notEmptyLongArray = { 1L };\n    assertFalse(ArrayUtils.isNotEmpty((long[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyLongArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyLongArray));\n    final int[] emptyIntArray = {};\n    final int[] notEmptyIntArray = { 1 };\n    assertFalse(ArrayUtils.isNotEmpty((int[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyIntArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyIntArray));\n    final short[] emptyShortArray = {};\n    final short[] notEmptyShortArray = { 1 };\n    assertFalse(ArrayUtils.isNotEmpty((short[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyShortArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyShortArray));\n    final char[] emptyCharArray = {};\n    final char[] notEmptyCharArray = { 1 };\n    assertFalse(ArrayUtils.isNotEmpty((char[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyCharArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyCharArray));\n    final byte[] emptyByteArray = {};\n    final byte[] notEmptyByteArray = { 1 };\n    assertFalse(ArrayUtils.isNotEmpty((byte[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyByteArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyByteArray));\n    final double[] emptyDoubleArray = {};\n    final double[] notEmptyDoubleArray = { 1.0 };\n    assertFalse(ArrayUtils.isNotEmpty((double[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyDoubleArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyDoubleArray));\n    final float[] emptyFloatArray = {};\n    final float[] notEmptyFloatArray = { 1.0F };\n    assertFalse(ArrayUtils.isNotEmpty((float[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyFloatArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyFloatArray));\n    final boolean[] emptyBooleanArray = {};\n    final boolean[] notEmptyBooleanArray = { true };\n    assertFalse(ArrayUtils.isNotEmpty((boolean[]) null));\n    assertFalse(ArrayUtils.isNotEmpty(emptyBooleanArray));\n    assertTrue(ArrayUtils.isNotEmpty(notEmptyBooleanArray));\n}", "repo_id": "8", "comment": "/**\n * Tests for {@link ArrayUtils#isNotEmpty(long[])},\n * {@link ArrayUtils#isNotEmpty(int[])},\n * {@link ArrayUtils#isNotEmpty(short[])},\n * {@link ArrayUtils#isNotEmpty(char[])},\n * {@link ArrayUtils#isNotEmpty(byte[])},\n * {@link ArrayUtils#isNotEmpty(double[])},\n * {@link ArrayUtils#isNotEmpty(float[])} and\n * {@link ArrayUtils#isNotEmpty(boolean[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 2008, "method_signature": "void testIsNotEmptyPrimitives()", "filename": "ArrayUtilsTest.testIsNotEmptyPrimitives.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_boolean", "method_implementation": "{\n    final Boolean[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0]));\n    assertArrayEquals(new boolean[] { true, false, true }, ArrayUtils.toPrimitive(new Boolean[] { Boolean.TRUE, Boolean.FALSE, Boolean.TRUE }));\n    assertArrayEquals(new boolean[] { true, false }, ArrayUtils.toPrimitive(new Boolean[] { Boolean.TRUE, null }));\n}", "repo_id": "8", "comment": "/**\n * testToPrimitive/Object for boolean\n */\n", "repo_name": "commons-lang-master/", "id": 2009, "method_signature": "void testToPrimitive_boolean()", "filename": "ArrayUtilsTest.testToPrimitive_boolean.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_byte", "method_implementation": "{\n    final Byte[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0]));\n    assertArrayEquals(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }, ArrayUtils.toPrimitive(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }));\n    assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), null }));\n}", "repo_id": "8", "comment": "/**\n * testToPrimitive/Object for byte\n */\n", "repo_name": "commons-lang-master/", "id": 2010, "method_signature": "void testToPrimitive_byte()", "filename": "ArrayUtilsTest.testToPrimitive_byte.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_char", "method_implementation": "{\n    final Character[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0]));\n    assertArrayEquals(new char[] { Character.MIN_VALUE, Character.MAX_VALUE, '0' }, ArrayUtils.toPrimitive(new Character[] { Character.valueOf(Character.MIN_VALUE), Character.valueOf(Character.MAX_VALUE), Character.valueOf('0') }));\n    assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Character[] { Character.valueOf(Character.MIN_VALUE), null }));\n}", "repo_id": "8", "comment": "/**\n * testToPrimitive/Object for byte\n */\n", "repo_name": "commons-lang-master/", "id": 2011, "method_signature": "void testToPrimitive_char()", "filename": "ArrayUtilsTest.testToPrimitive_char.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_double", "method_implementation": "{\n    final Double[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0]));\n    assertArrayEquals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }));\n    assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Float[] { Float.valueOf(Float.MIN_VALUE), null }));\n}", "repo_id": "8", "comment": "/**\n *  testToPrimitive/Object for double\n */\n", "repo_name": "commons-lang-master/", "id": 2012, "method_signature": "void testToPrimitive_double()", "filename": "ArrayUtilsTest.testToPrimitive_double.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_float", "method_implementation": "{\n    final Float[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.toPrimitive(new Float[0]));\n    assertArrayEquals(new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Float[] { Float.valueOf(Float.MIN_VALUE), Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999) }));\n    assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Float[] { Float.valueOf(Float.MIN_VALUE), null }));\n}", "repo_id": "8", "comment": "/**\n *  testToPrimitive/Object for float\n */\n", "repo_name": "commons-lang-master/", "id": 2013, "method_signature": "void testToPrimitive_float()", "filename": "ArrayUtilsTest.testToPrimitive_float.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_int", "method_implementation": "{\n    final Integer[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0]));\n    assertArrayEquals(new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Integer[] { Integer.valueOf(Integer.MIN_VALUE), Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999) }));\n    assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Integer[] { Integer.valueOf(Integer.MIN_VALUE), null }));\n}", "repo_id": "8", "comment": "/**\n * testToPrimitive/Object for int\n */\n", "repo_name": "commons-lang-master/", "id": 2014, "method_signature": "void testToPrimitive_int()", "filename": "ArrayUtilsTest.testToPrimitive_int.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_long", "method_implementation": "{\n    final Long[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0]));\n    assertArrayEquals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }));\n    assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null }));\n}", "repo_id": "8", "comment": "/**\n * testToPrimitive/Object for long\n */\n", "repo_name": "commons-lang-master/", "id": 2015, "method_signature": "void testToPrimitive_long()", "filename": "ArrayUtilsTest.testToPrimitive_long.json"}
{"callee_method_names": [], "method_name": "ArrayUtilsTest.testToPrimitive_short", "method_implementation": "{\n    final Short[] b = null;\n    assertNull(ArrayUtils.toPrimitive(b));\n    assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0]));\n    assertArrayEquals(new short[] { Short.MIN_VALUE, Short.MAX_VALUE, (short) 9999999 }, ArrayUtils.toPrimitive(new Short[] { Short.valueOf(Short.MIN_VALUE), Short.valueOf(Short.MAX_VALUE), Short.valueOf((short) 9999999) }));\n    assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Short[] { Short.valueOf(Short.MIN_VALUE), null }));\n}", "repo_id": "8", "comment": "/**\n * testToPrimitive/Object for short\n */\n", "repo_name": "commons-lang-master/", "id": 2016, "method_signature": "void testToPrimitive_short()", "filename": "ArrayUtilsTest.testToPrimitive_short.json"}
{"callee_method_names": ["AtomicReference.get", "AtomicReference.compareAndSet", "AtomicReference.get"], "method_name": "AtomicInitializer.get", "method_implementation": "{\n    T result = reference.get();\n    if (result == getNoInit()) {\n        result = initialize();\n        if (!reference.compareAndSet(getNoInit(), result)) {\n            // another thread has initialized the reference\n            result = reference.get();\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Returns the object managed by this initializer. The object is created if\n * it is not available yet and stored internally. This method always returns\n * the same object.\n *\n * @return the object created by this {@link AtomicInitializer}\n * @throws ConcurrentException if an error occurred during initialization of\n * the object\n */\n", "repo_name": "commons-lang-master/", "id": 109, "method_signature": "T get()", "filename": "AtomicInitializer.get.json"}
{"callee_method_names": [], "method_name": "AtomicInitializerTest.createInitializer", "method_implementation": "{\n    return new AtomicInitializer<Object>() {\n\n        @Override\n        protected Object initialize() {\n            return new Object();\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns the initializer to be tested.\n *\n * @return the {@code AtomicInitializer}\n */\n", "repo_name": "commons-lang-master/", "id": 1555, "method_signature": "ConcurrentInitializer<Object> createInitializer()", "filename": "AtomicInitializerTest.createInitializer.json"}
{"callee_method_names": ["AtomicReference.get", "AtomicReference.compareAndSet", "AtomicReference.set"], "method_name": "AtomicSafeInitializer.get", "method_implementation": "{\n    T result;\n    while ((result = reference.get()) == getNoInit()) {\n        if (factory.compareAndSet(null, this)) {\n            reference.set(initialize());\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Gets (and initialize, if not initialized yet) the required object\n *\n * @return lazily initialized object\n * @throws ConcurrentException if the initialization of the object causes an\n * exception\n */\n", "repo_name": "commons-lang-master/", "id": 86, "method_signature": "T get()", "filename": "AtomicSafeInitializer.get.json"}
{"callee_method_names": ["AtomicInteger.get"], "method_name": "AtomicSafeInitializerSupplierTest.testNumberOfInitializeInvocations", "method_implementation": "{\n    testGetConcurrent();\n    assertEquals(1, initCounter.get(), \"Wrong number of invocations\");\n}", "repo_id": "8", "comment": "/**\n * Tests that initialize() is called only once.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException because {@link #testGetConcurrent()} may throw it\n * @throws InterruptedException because {@link #testGetConcurrent()} may throw it\n */\n", "repo_name": "commons-lang-master/", "id": 1433, "method_signature": "void testNumberOfInitializeInvocations()", "filename": "AtomicSafeInitializerSupplierTest.testNumberOfInitializeInvocations.json"}
{"callee_method_names": ["AtomicSafeInitializerTestImpl.get"], "method_name": "AtomicSafeInitializerTest.testNumberOfInitializeInvocations", "method_implementation": "{\n    testGetConcurrent();\n    assertEquals(1, initializer.initCounter.get(), \"Wrong number of invocations\");\n}", "repo_id": "8", "comment": "/**\n * Tests that initialize() is called only once.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException because {@link #testGetConcurrent()} may throw it\n * @throws InterruptedException because {@link #testGetConcurrent()} may throw it\n */\n", "repo_name": "commons-lang-master/", "id": 1493, "method_signature": "void testNumberOfInitializeInvocations()", "filename": "AtomicSafeInitializerTest.testNumberOfInitializeInvocations.json"}
{"callee_method_names": ["ExecutorService.shutdown"], "method_name": "BackgroundInitializer.call", "method_implementation": "{\n    try {\n        return initialize();\n    } finally {\n        if (execFinally != null) {\n            execFinally.shutdown();\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Initiates initialization and returns the result.\n *\n * @return the result object\n * @throws Exception if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 101, "method_signature": "T call()", "filename": "BackgroundInitializer.call.json"}
{"callee_method_names": [], "method_name": "BackgroundInitializer.get", "method_implementation": "{\n    try {\n        return getFuture().get();\n    } catch (final ExecutionException execex) {\n        ConcurrentUtils.handleCause(execex);\n        // should not be reached\n        return null;\n    } catch (final InterruptedException iex) {\n        // reset interrupted state\n        Thread.currentThread().interrupt();\n        throw new ConcurrentException(iex);\n    }\n}", "repo_id": "8", "comment": "/**\n * Returns the result of the background initialization. This method blocks\n * until initialization is complete. If the background processing caused a\n * runtime exception, it is directly thrown by this method. Checked\n * exceptions, including {@link InterruptedException} are wrapped in a\n * {@link ConcurrentException}. Calling this method before {@link #start()}\n * was called causes an {@link IllegalStateException} exception to be\n * thrown.\n *\n * @return the object produced by this initializer\n * @throws ConcurrentException if a checked exception occurred during\n * background processing\n * @throws IllegalStateException if {@link #start()} has not been called\n */\n", "repo_name": "commons-lang-master/", "id": 102, "method_signature": "T get()", "filename": "BackgroundInitializer.get.json"}
{"callee_method_names": [], "method_name": "BackgroundInitializer.getFuture", "method_implementation": "{\n    if (future == null) {\n        throw new IllegalStateException(\"start() must be called first!\");\n    }\n    return future;\n}", "repo_id": "8", "comment": "/**\n * Returns the {@link Future} object that was created when {@link #start()}\n * was called. Therefore this method can only be called after {@code\n * start()}.\n *\n * @return the {@link Future} object wrapped by this initializer\n * @throws IllegalStateException if {@link #start()} has not been called\n */\n", "repo_name": "commons-lang-master/", "id": 103, "method_signature": "Future<T> getFuture()", "filename": "BackgroundInitializer.getFuture.json"}
{"callee_method_names": [], "method_name": "BackgroundInitializer.getTypedException", "method_implementation": "{\n    //This Exception object will be used for type comparison in AbstractConcurrentInitializer.initialize but not thrown\n    return new Exception(e);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 104, "method_signature": "Exception getTypedException(Exception)", "filename": "BackgroundInitializer.getTypedException.json"}
{"callee_method_names": ["Future<T>.isDone", "Future<T>.get"], "method_name": "BackgroundInitializer.isInitialized", "method_implementation": "{\n    if (future == null || !future.isDone()) {\n        return false;\n    }\n    try {\n        future.get();\n        return true;\n    } catch (CancellationException | ExecutionException | InterruptedException e) {\n        return false;\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests whether this instance is initialized. Once initialized, always returns true.\n * If initialization failed then the failure will be cached and this will never return\n * true.\n *\n * @return true if initialization completed successfully, otherwise false\n * @since 3.14.0\n */\n", "repo_name": "commons-lang-master/", "id": 105, "method_signature": "boolean isInitialized()", "filename": "BackgroundInitializer.isInitialized.json"}
{"callee_method_names": [], "method_name": "BackgroundInitializer.setExternalExecutor", "method_implementation": "{\n    if (isStarted()) {\n        throw new IllegalStateException(\"Cannot set ExecutorService after start()!\");\n    }\n    this.externalExecutor = externalExecutor;\n}", "repo_id": "8", "comment": "/**\n * Sets an {@link ExecutorService} to be used by this class. The {@code\n * ExecutorService} passed to this method is used for executing the\n * background task. Thus it is possible to re-use an already existing\n * {@link ExecutorService} or to use a specially configured one. If no\n * {@link ExecutorService} is set, this instance creates a temporary one and\n * destroys it after background initialization is complete. Note that this\n * method must be called before {@link #start()}; otherwise an exception is\n * thrown.\n *\n * @param externalExecutor the {@link ExecutorService} to be used\n * @throws IllegalStateException if this initializer has already been\n * started\n */\n", "repo_name": "commons-lang-master/", "id": 106, "method_signature": "void setExternalExecutor(ExecutorService)", "filename": "BackgroundInitializer.setExternalExecutor.json"}
{"callee_method_names": ["ExecutorService.submit"], "method_name": "BackgroundInitializer.start", "method_implementation": "{\n    // Not yet started?\n    if (!isStarted()) {\n        // Determine the executor to use and whether a temporary one has to\n        // be created\n        final ExecutorService tempExec;\n        executor = getExternalExecutor();\n        if (executor == null) {\n            executor = tempExec = createExecutor();\n        } else {\n            tempExec = null;\n        }\n        future = executor.submit(createTask(tempExec));\n        return true;\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Starts the background initialization. With this method the initializer\n * becomes active and invokes the {@link #initialize()} method in a\n * background task. A {@link BackgroundInitializer} can be started exactly\n * once. The return value of this method determines whether the start was\n * successful: only the first invocation of this method returns <b>true</b>,\n * following invocations will return <b>false</b>.\n *\n * @return a flag whether the initializer could be started successfully\n */\n", "repo_name": "commons-lang-master/", "id": 107, "method_signature": "boolean start()", "filename": "BackgroundInitializer.start.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.getCloseableCounter", "AbstractBackgroundInitializerTestImpl.close", "AbstractBackgroundInitializerTestImpl.getCloseableCounter", "AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.get", "AbstractBackgroundInitializerTestImpl.getCloseableCounter", "AbstractBackgroundInitializerTestImpl.close", "AbstractBackgroundInitializerTestImpl.getCloseableCounter"], "method_name": "BackgroundInitializerSupplierTest.testClose", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    assertFalse(init.getCloseableCounter().isClosed(), \"closed without close() call\");\n    init.close();\n    assertFalse(init.getCloseableCounter().isClosed(), \"closed() succeeded before start()\");\n    init.start();\n    //ensure the Future has completed.\n    init.get();\n    assertFalse(init.getCloseableCounter().isClosed(), \"closed() succeeded after start() but before close()\");\n    init.close();\n    assertTrue(init.getCloseableCounter().isClosed(), \"closed() did not succeed\");\n}", "repo_id": "8", "comment": "/**\n * Tests that close() method closes the wrapped object\n *\n * @throws Exception\n */\n", "repo_name": "commons-lang-master/", "id": 1490, "method_signature": "void testClose()", "filename": "BackgroundInitializerSupplierTest.testClose.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.get", "AbstractBackgroundInitializerTestImpl.close", "Error.getCause"], "method_name": "BackgroundInitializerSupplierTest.testCloseWithCheckedException", "method_implementation": "{\n    final IOException ioException = new IOException();\n    final FailableConsumer<?, ?> IOExceptionConsumer = (CloseableCounter cc) -> {\n        throw ioException;\n    };\n    final AbstractBackgroundInitializerTestImpl init = new SupplierBackgroundInitializerTestImpl(IOExceptionConsumer);\n    init.start();\n    //ensure the Future has completed.\n    init.get();\n    try {\n        init.close();\n        fail();\n    } catch (Exception e) {\n        assertThat(e, instanceOf(ConcurrentException.class));\n        assertSame(ioException, e.getCause());\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that close() wraps a checked exception in a ConcurrentException\n *\n * @throws Exception\n */\n", "repo_name": "commons-lang-master/", "id": 1491, "method_signature": "void testCloseWithCheckedException()", "filename": "BackgroundInitializerSupplierTest.testCloseWithCheckedException.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.get", "AbstractBackgroundInitializerTestImpl.close"], "method_name": "BackgroundInitializerSupplierTest.testCloseWithRuntimeException", "method_implementation": "{\n    final NullPointerException npe = new NullPointerException();\n    final FailableConsumer<?, ?> NullPointerExceptionConsumer = (CloseableCounter cc) -> {\n        throw npe;\n    };\n    final AbstractBackgroundInitializerTestImpl init = new SupplierBackgroundInitializerTestImpl(NullPointerExceptionConsumer);\n    init.start();\n    //ensure the Future has completed.\n    init.get();\n    try {\n        init.close();\n        fail();\n    } catch (Exception e) {\n        assertSame(npe, e);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that close() throws a runtime exception\n *\n * @throws Exception\n */\n", "repo_name": "commons-lang-master/", "id": 1492, "method_signature": "void testCloseWithRuntimeException()", "filename": "BackgroundInitializerSupplierTest.testCloseWithRuntimeException.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.get", "Integer.intValue", "AbstractBackgroundInitializerTestImpl.getCloseableCounter", "AbstractBackgroundInitializerTestImpl.getFuture"], "method_name": "BackgroundInitializerTest.checkInitialize", "method_implementation": "{\n    final Integer result = init.get().getInitializeCalls();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}", "repo_id": "8", "comment": "/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\n", "repo_name": "commons-lang-master/", "id": 1532, "method_signature": "void checkInitialize(AbstractBackgroundInitializerTestImpl)", "filename": "BackgroundInitializerTest.checkInitialize.json"}
{"callee_method_names": ["CountDownLatch.await", "CloseableCounter.increment"], "method_name": "BackgroundInitializerTest.initializeInternal", "method_implementation": "{\n    if (ex != null) {\n        throw ex;\n    }\n    if (shouldSleep) {\n        ThreadUtils.sleep(Duration.ofMinutes(1));\n    }\n    if (waitForLatch) {\n        latch.await();\n    }\n    return counter.increment();\n}", "repo_id": "8", "comment": "/**\n * Records this invocation. Optionally throws an exception or sleeps a\n * while.\n *\n * @throws Exception in case of an error\n */\n", "repo_name": "commons-lang-master/", "id": 1531, "method_signature": "CloseableCounter initializeInternal()", "filename": "BackgroundInitializerTest.initializeInternal.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.getActiveExecutor"], "method_name": "BackgroundInitializerTest.testGetActiveExecutorBeforeStart", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    assertNull(init.getActiveExecutor(), \"Got an executor\");\n}", "repo_id": "8", "comment": "/**\n * Tries to obtain the executor before start(). It should not have been\n * initialized yet.\n */\n", "repo_name": "commons-lang-master/", "id": 1533, "method_signature": "void testGetActiveExecutorBeforeStart()", "filename": "BackgroundInitializerTest.testGetActiveExecutorBeforeStart.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.getActiveExecutor", "ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "BackgroundInitializerTest.testGetActiveExecutorExternal", "method_implementation": "{\n    final ExecutorService exec = Executors.newSingleThreadExecutor();\n    try {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(exec);\n        init.start();\n        assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n        checkInitialize(init);\n    } finally {\n        exec.shutdown();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests whether an external executor is correctly detected.\n */\n", "repo_name": "commons-lang-master/", "id": 1534, "method_signature": "void testGetActiveExecutorExternal()", "filename": "BackgroundInitializerTest.testGetActiveExecutorExternal.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.getActiveExecutor"], "method_name": "BackgroundInitializerTest.testGetActiveExecutorTemp", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    init.start();\n    assertNotNull(init.getActiveExecutor(), \"No active executor\");\n    checkInitialize(init);\n}", "repo_id": "8", "comment": "/**\n * Tests getActiveExecutor() for a temporary executor.\n */\n", "repo_name": "commons-lang-master/", "id": 1535, "method_signature": "void testGetActiveExecutorTemp()", "filename": "BackgroundInitializerTest.testGetActiveExecutorTemp.json"}
{"callee_method_names": [], "method_name": "BackgroundInitializerTest.testGetBeforeStart", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    assertThrows(IllegalStateException.class, init::get);\n}", "repo_id": "8", "comment": "/**\n * Tests calling get() before start(). This should cause an exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1536, "method_signature": "void testGetBeforeStart()", "filename": "BackgroundInitializerTest.testGetBeforeStart.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "ConcurrentException.getCause"], "method_name": "BackgroundInitializerTest.testGetCheckedException", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    final Exception ex = new Exception();\n    init.ex = ex;\n    init.start();\n    final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n    assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n}", "repo_id": "8", "comment": "/**\n * Tests the get() method if background processing causes a checked\n * exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1537, "method_signature": "void testGetCheckedException()", "filename": "BackgroundInitializerTest.testGetCheckedException.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.get", "ConcurrentException.getCause", "AtomicReference<InterruptedException>.set", "ConcurrentException.getCause", "CountDownLatch.countDown", "Thread.start", "Thread.interrupt", "CountDownLatch.await", "ExecutorService.shutdownNow", "ExecutorService.awaitTermination", "AtomicReference<InterruptedException>.get"], "method_name": "BackgroundInitializerTest.testGetInterruptedException", "method_implementation": "{\n    final ExecutorService exec = Executors.newSingleThreadExecutor();\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(exec);\n    final CountDownLatch latch1 = new CountDownLatch(1);\n    init.shouldSleep = true;\n    init.start();\n    final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n    final Thread getThread = new Thread() {\n\n        @Override\n        public void run() {\n            try {\n                init.get();\n            } catch (final ConcurrentException cex) {\n                if (cex.getCause() instanceof InterruptedException) {\n                    iex.set((InterruptedException) cex.getCause());\n                }\n            } finally {\n                assertTrue(isInterrupted(), \"Thread not interrupted\");\n                latch1.countDown();\n            }\n        }\n    };\n    getThread.start();\n    getThread.interrupt();\n    latch1.await();\n    exec.shutdownNow();\n    exec.awaitTermination(1, TimeUnit.SECONDS);\n    assertNotNull(iex.get(), \"No interrupted exception\");\n}", "repo_id": "8", "comment": "/**\n * Tests the get() method if waiting for the initialization is interrupted.\n *\n * @throws InterruptedException because we're making use of Java's concurrent API\n */\n", "repo_name": "commons-lang-master/", "id": 1538, "method_signature": "void testGetInterruptedException()", "filename": "BackgroundInitializerTest.testGetInterruptedException.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start"], "method_name": "BackgroundInitializerTest.testGetRuntimeException", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    final RuntimeException rex = new RuntimeException();\n    init.ex = rex;\n    init.start();\n    final Exception ex = assertThrows(Exception.class, init::get);\n    assertEquals(rex, ex, \"Runtime exception not thrown\");\n}", "repo_id": "8", "comment": "/**\n * Tests the get() method if background processing causes a runtime\n * exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1539, "method_signature": "void testGetRuntimeException()", "filename": "BackgroundInitializerTest.testGetRuntimeException.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start"], "method_name": "BackgroundInitializerTest.testInitialize", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    init.start();\n    checkInitialize(init);\n}", "repo_id": "8", "comment": "/**\n * Tests whether initialize() is invoked.\n */\n", "repo_name": "commons-lang-master/", "id": 1540, "method_signature": "void testInitialize()", "filename": "BackgroundInitializerTest.testInitialize.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.getActiveExecutor"], "method_name": "BackgroundInitializerTest.testInitializeTempExecutor", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    assertTrue(init.start(), \"Wrong result of start()\");\n    checkInitialize(init);\n    assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n}", "repo_id": "8", "comment": "/**\n * Tests the execution of the background task if a temporary executor has to\n * be created.\n */\n", "repo_name": "commons-lang-master/", "id": 1541, "method_signature": "void testInitializeTempExecutor()", "filename": "BackgroundInitializerTest.testInitializeTempExecutor.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.enableLatch", "AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.isStarted", "AbstractBackgroundInitializerTestImpl.isInitialized", "AbstractBackgroundInitializerTestImpl.releaseLatch", "AbstractBackgroundInitializerTestImpl.get", "AbstractBackgroundInitializerTestImpl.isInitialized"], "method_name": "BackgroundInitializerTest.testIsInitialized", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    init.enableLatch();\n    init.start();\n    //Started and Initialized should return opposite values\n    assertTrue(init.isStarted(), \"Not started\");\n    assertFalse(init.isInitialized(), \"Initialized before releasing latch\");\n    init.releaseLatch();\n    //to ensure the initialize thread has completed.\n    init.get();\n    assertTrue(init.isInitialized(), \"Not initialized after releasing latch\");\n}", "repo_id": "8", "comment": "/**\n * Tests isInitialized() before and after the background task has finished.\n */\n", "repo_name": "commons-lang-master/", "id": 1542, "method_signature": "void testIsInitialized()", "filename": "BackgroundInitializerTest.testIsInitialized.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.isStarted"], "method_name": "BackgroundInitializerTest.testIsStartedAfterGet", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    init.start();\n    checkInitialize(init);\n    assertTrue(init.isStarted(), \"Not started\");\n}", "repo_id": "8", "comment": "/**\n * Tests isStarted() after the background task has finished.\n */\n", "repo_name": "commons-lang-master/", "id": 1543, "method_signature": "void testIsStartedAfterGet()", "filename": "BackgroundInitializerTest.testIsStartedAfterGet.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.isStarted"], "method_name": "BackgroundInitializerTest.testIsStartedFalse", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    assertFalse(init.isStarted(), \"Already started\");\n}", "repo_id": "8", "comment": "/**\n * Tests isStarted() before start() was called.\n */\n", "repo_name": "commons-lang-master/", "id": 1544, "method_signature": "void testIsStartedFalse()", "filename": "BackgroundInitializerTest.testIsStartedFalse.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.isStarted"], "method_name": "BackgroundInitializerTest.testIsStartedTrue", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    init.start();\n    assertTrue(init.isStarted(), \"Not started\");\n}", "repo_id": "8", "comment": "/**\n * Tests isStarted() after start().\n */\n", "repo_name": "commons-lang-master/", "id": 1545, "method_signature": "void testIsStartedTrue()", "filename": "BackgroundInitializerTest.testIsStartedTrue.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.setExternalExecutor", "AbstractBackgroundInitializerTestImpl.getExternalExecutor", "AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.getActiveExecutor", "ExecutorService.isShutdown", "ExecutorService.shutdown"], "method_name": "BackgroundInitializerTest.testSetExternalExecutor", "method_implementation": "{\n    final ExecutorService exec = Executors.newCachedThreadPool();\n    try {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.setExternalExecutor(exec);\n        assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n        assertTrue(init.start(), \"Wrong result of start()\");\n        assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n        checkInitialize(init);\n        assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n    } finally {\n        exec.shutdown();\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests whether an external executor can be set using the\n * setExternalExecutor() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1546, "method_signature": "void testSetExternalExecutor()", "filename": "BackgroundInitializerTest.testSetExternalExecutor.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.setExternalExecutor", "AbstractBackgroundInitializerTestImpl.get", "ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "BackgroundInitializerTest.testSetExternalExecutorAfterStart", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    init.start();\n    final ExecutorService exec = Executors.newSingleThreadExecutor();\n    try {\n        assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n        init.get();\n    } finally {\n        exec.shutdown();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that setting an executor after start() causes an exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n */\n", "repo_name": "commons-lang-master/", "id": 1547, "method_signature": "void testSetExternalExecutorAfterStart()", "filename": "BackgroundInitializerTest.testSetExternalExecutorAfterStart.json"}
{"callee_method_names": ["AbstractBackgroundInitializerTestImpl.start", "AbstractBackgroundInitializerTestImpl.start"], "method_name": "BackgroundInitializerTest.testStartMultipleTimes", "method_implementation": "{\n    final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n    assertTrue(init.start(), \"Wrong result for start()\");\n    for (int i = 0; i < 10; i++) {\n        assertFalse(init.start(), \"Could start again\");\n    }\n    checkInitialize(init);\n}", "repo_id": "8", "comment": "/**\n * Tests invoking start() multiple times. Only the first invocation should\n * have an effect.\n */\n", "repo_name": "commons-lang-master/", "id": 1548, "method_signature": "void testStartMultipleTimes()", "filename": "BackgroundInitializerTest.testStartMultipleTimes.json"}
{"callee_method_names": [], "method_name": "BasicThreadFactory.build", "method_implementation": "{\n    final BasicThreadFactory factory = new BasicThreadFactory(this);\n    reset();\n    return factory;\n}", "repo_id": "8", "comment": "/**\n * Creates a new {@link BasicThreadFactory} with all configuration\n * options that have been specified by calling methods on this builder.\n * After creating the factory {@link #reset()} is called.\n *\n * @return the new {@link BasicThreadFactory}\n */\n", "repo_name": "commons-lang-master/", "id": 110, "method_signature": "BasicThreadFactory build()", "filename": "BasicThreadFactory.build.json"}
{"callee_method_names": ["AtomicLong.incrementAndGet", "Thread.setName", "Thread.setUncaughtExceptionHandler", "Thread.setPriority", "Thread.setDaemon"], "method_name": "BasicThreadFactory.initializeThread", "method_implementation": "{\n    if (getNamingPattern() != null) {\n        final Long count = Long.valueOf(threadCounter.incrementAndGet());\n        thread.setName(String.format(getNamingPattern(), count));\n    }\n    if (getUncaughtExceptionHandler() != null) {\n        thread.setUncaughtExceptionHandler(getUncaughtExceptionHandler());\n    }\n    if (getPriority() != null) {\n        thread.setPriority(getPriority().intValue());\n    }\n    if (getDaemonFlag() != null) {\n        thread.setDaemon(getDaemonFlag().booleanValue());\n    }\n}", "repo_id": "8", "comment": "/**\n * Initializes the specified thread. This method is called by\n * {@link #newThread(Runnable)} after a new thread has been obtained from\n * the wrapped thread factory. It initializes the thread according to the\n * options set for this factory.\n *\n * @param thread the thread to be initialized\n */\n", "repo_name": "commons-lang-master/", "id": 115, "method_signature": "void initializeThread(Thread)", "filename": "BasicThreadFactory.initializeThread.json"}
{"callee_method_names": [], "method_name": "BasicThreadFactory.namingPattern", "method_implementation": "{\n    Objects.requireNonNull(pattern, \"pattern\");\n    namingPattern = pattern;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the naming pattern to be used by the new {@code\n * BasicThreadFactory}.\n *\n * @param pattern the naming pattern (must not be <b>null</b>)\n * @return a reference to this {@link Builder}\n * @throws NullPointerException if the naming pattern is <b>null</b>\n */\n", "repo_name": "commons-lang-master/", "id": 111, "method_signature": "Builder namingPattern(String)", "filename": "BasicThreadFactory.namingPattern.json"}
{"callee_method_names": [], "method_name": "BasicThreadFactory.newThread", "method_implementation": "{\n    final Thread thread = getWrappedFactory().newThread(runnable);\n    initializeThread(thread);\n    return thread;\n}", "repo_id": "8", "comment": "/**\n * Creates a new thread. This implementation delegates to the wrapped\n * factory for creating the thread. Then, on the newly created thread the\n * corresponding configuration options are set.\n *\n * @param runnable the {@link Runnable} to be executed by the new thread\n * @return the newly created thread\n */\n", "repo_name": "commons-lang-master/", "id": 116, "method_signature": "Thread newThread(Runnable)", "filename": "BasicThreadFactory.newThread.json"}
{"callee_method_names": [], "method_name": "BasicThreadFactory.reset", "method_implementation": "{\n    wrappedFactory = null;\n    exceptionHandler = null;\n    namingPattern = null;\n    priority = null;\n    daemon = null;\n}", "repo_id": "8", "comment": "/**\n * Resets this builder. All configuration options are set to default\n * values. Note: If the {@link #build()} method was called, it is not\n * necessary to call {@code reset()} explicitly because this is done\n * automatically.\n */\n", "repo_name": "commons-lang-master/", "id": 112, "method_signature": "void reset()", "filename": "BasicThreadFactory.reset.json"}
{"callee_method_names": [], "method_name": "BasicThreadFactory.uncaughtExceptionHandler", "method_implementation": "{\n    Objects.requireNonNull(handler, \"handler\");\n    exceptionHandler = handler;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the uncaught exception handler for the threads created by the\n * new {@link BasicThreadFactory}.\n *\n * @param handler the {@link UncaughtExceptionHandler} (must not be\n * <b>null</b>)\n * @return a reference to this {@link Builder}\n * @throws NullPointerException if the exception handler is <b>null</b>\n */\n", "repo_name": "commons-lang-master/", "id": 113, "method_signature": "Builder uncaughtExceptionHandler(Thread.UncaughtExceptionHandler)", "filename": "BasicThreadFactory.uncaughtExceptionHandler.json"}
{"callee_method_names": [], "method_name": "BasicThreadFactory.wrappedFactory", "method_implementation": "{\n    Objects.requireNonNull(factory, \"factory\");\n    wrappedFactory = factory;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the {@link ThreadFactory} to be wrapped by the new {@code\n * BasicThreadFactory}.\n *\n * @param factory the wrapped {@link ThreadFactory} (must not be\n * <b>null</b>)\n * @return a reference to this {@link Builder}\n * @throws NullPointerException if the passed in {@link ThreadFactory}\n * is <b>null</b>\n */\n", "repo_name": "commons-lang-master/", "id": 114, "method_signature": "Builder wrappedFactory(ThreadFactory)", "filename": "BasicThreadFactory.wrappedFactory.json"}
{"callee_method_ids": [116], "callee_method_names": ["ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.isDaemon"], "method_name": "BasicThreadFactoryTest.checkDaemonFlag", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r = EasyMock.createMock(Runnable.class);\n    final Thread t = new Thread();\n    EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n    EasyMock.replay(wrapped, r);\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).daemon(flag).build();\n    assertSame(t, factory.newThread(r), \"Wrong thread\");\n    assertEquals(flag, t.isDaemon(), \"Wrong daemon flag\");\n    EasyMock.verify(wrapped, r);\n}", "repo_id": "8", "comment": "/**\n * Helper method for testing whether the daemon flag is taken into account.\n *\n * @param flag the value of the flag\n */\n", "repo_name": "commons-lang-master/", "id": 1501, "method_signature": "void checkDaemonFlag(boolean)", "filename": "BasicThreadFactoryTest.checkDaemonFlag.json"}
{"callee_method_names": ["BasicThreadFactory.getNamingPattern", "BasicThreadFactory.getUncaughtExceptionHandler", "BasicThreadFactory.getPriority", "BasicThreadFactory.getDaemonFlag", "BasicThreadFactory.getWrappedFactory"], "method_name": "BasicThreadFactoryTest.checkFactoryDefaults", "method_implementation": "{\n    assertNull(factory.getNamingPattern(), \"Got a naming pattern\");\n    assertNull(factory.getUncaughtExceptionHandler(), \"Got an exception handler\");\n    assertNull(factory.getPriority(), \"Got a priority\");\n    assertNull(factory.getDaemonFlag(), \"Got a daemon flag\");\n    assertNotNull(factory.getWrappedFactory(), \"No wrapped factory\");\n}", "repo_id": "8", "comment": "/**\n * Tests the default options of a thread factory.\n *\n * @param factory the factory to be checked\n */\n", "repo_name": "commons-lang-master/", "id": 1502, "method_signature": "void checkFactoryDefaults(BasicThreadFactory)", "filename": "BasicThreadFactoryTest.checkFactoryDefaults.json"}
{"callee_method_names": ["BasicThreadFactory.Builder.build"], "method_name": "BasicThreadFactoryTest.testBuildDefaults", "method_implementation": "{\n    final BasicThreadFactory factory = builder.build();\n    checkFactoryDefaults(factory);\n}", "repo_id": "8", "comment": "/**\n * Tests the default values used by the builder.\n */\n", "repo_name": "commons-lang-master/", "id": 1503, "method_signature": "void testBuildDefaults()", "filename": "BasicThreadFactoryTest.testBuildDefaults.json"}
{"callee_method_names": ["BasicThreadFactory.Builder.namingPattern", "BasicThreadFactory.Builder.reset", "BasicThreadFactory.Builder.build", "BasicThreadFactory.getWrappedFactory"], "method_name": "BasicThreadFactoryTest.testBuilderReset", "method_implementation": "{\n    final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class);\n    final Thread.UncaughtExceptionHandler exHandler = EasyMock.createMock(Thread.UncaughtExceptionHandler.class);\n    EasyMock.replay(wrappedFactory, exHandler);\n    builder.namingPattern(PATTERN).daemon(true).priority(Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler).wrappedFactory(wrappedFactory);\n    builder.reset();\n    final BasicThreadFactory factory = builder.build();\n    checkFactoryDefaults(factory);\n    assertNotSame(wrappedFactory, factory.getWrappedFactory(), \"Wrapped factory not reset\");\n    EasyMock.verify(wrappedFactory, exHandler);\n}", "repo_id": "8", "comment": "/**\n * Tests the reset() method of the builder.\n */\n", "repo_name": "commons-lang-master/", "id": 1504, "method_signature": "void testBuilderReset()", "filename": "BasicThreadFactoryTest.testBuilderReset.json"}
{"callee_method_names": ["BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.Builder.build"], "method_name": "BasicThreadFactoryTest.testBuilderResetAfterBuild", "method_implementation": "{\n    builder.wrappedFactory(EasyMock.createNiceMock(ThreadFactory.class)).namingPattern(PATTERN).daemon(true).build();\n    checkFactoryDefaults(builder.build());\n}", "repo_id": "8", "comment": "/**\n * Tests whether reset() is automatically called after build().\n */\n", "repo_name": "commons-lang-master/", "id": 1505, "method_signature": "void testBuilderResetAfterBuild()", "filename": "BasicThreadFactoryTest.testBuilderResetAfterBuild.json"}
{"callee_method_ids": [116], "callee_method_names": ["ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.getUncaughtExceptionHandler"], "method_name": "BasicThreadFactoryTest.testNewThreadExHandler", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r = EasyMock.createMock(Runnable.class);\n    final Thread.UncaughtExceptionHandler handler = EasyMock.createMock(Thread.UncaughtExceptionHandler.class);\n    final Thread t = new Thread();\n    EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n    EasyMock.replay(wrapped, r, handler);\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).uncaughtExceptionHandler(handler).build();\n    assertSame(t, factory.newThread(r), \"Wrong thread\");\n    assertEquals(handler, t.getUncaughtExceptionHandler(), \"Wrong exception handler\");\n    EasyMock.verify(wrapped, r, handler);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the exception handler is set if one is provided.\n */\n", "repo_name": "commons-lang-master/", "id": 1506, "method_signature": "void testNewThreadExHandler()", "filename": "BasicThreadFactoryTest.testNewThreadExHandler.json"}
{"callee_method_ids": [116], "callee_method_names": ["ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.getName", "BasicThreadFactory.getThreadCount"], "method_name": "BasicThreadFactoryTest.testNewThreadNamingPattern", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r = EasyMock.createMock(Runnable.class);\n    final int count = 12;\n    for (int i = 0; i < count; i++) {\n        EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread());\n    }\n    EasyMock.replay(wrapped, r);\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).namingPattern(PATTERN).build();\n    for (int i = 0; i < count; i++) {\n        final Thread t = factory.newThread(r);\n        assertEquals(String.format(PATTERN, Long.valueOf(i + 1)), t.getName(), \"Wrong thread name\");\n        assertEquals(i + 1, factory.getThreadCount(), \"Wrong thread count\");\n    }\n    EasyMock.verify(wrapped, r);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the naming pattern is applied to new threads.\n */\n", "repo_name": "commons-lang-master/", "id": 1507, "method_signature": "void testNewThreadNamingPattern()", "filename": "BasicThreadFactoryTest.testNewThreadNamingPattern.json"}
{"callee_method_ids": [116, 116], "callee_method_names": ["Thread.setDaemon", "ThreadFactory.newThread", "ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.isDaemon", "BasicThreadFactory.newThread", "Thread.isDaemon"], "method_name": "BasicThreadFactoryTest.testNewThreadNoDaemonFlag", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r1 = EasyMock.createMock(Runnable.class);\n    final Runnable r2 = EasyMock.createMock(Runnable.class);\n    final Thread t1 = new Thread();\n    final Thread t2 = new Thread();\n    t1.setDaemon(true);\n    EasyMock.expect(wrapped.newThread(r1)).andReturn(t1);\n    EasyMock.expect(wrapped.newThread(r2)).andReturn(t2);\n    EasyMock.replay(wrapped, r1, r2);\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n    assertSame(t1, factory.newThread(r1), \"Wrong thread 1\");\n    assertTrue(t1.isDaemon(), \"No daemon thread\");\n    assertSame(t2, factory.newThread(r2), \"Wrong thread 2\");\n    assertFalse(t2.isDaemon(), \"A daemon thread\");\n    EasyMock.verify(wrapped, r1, r2);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the daemon flag is not touched on newly created threads if\n * it is not specified.\n */\n", "repo_name": "commons-lang-master/", "id": 1508, "method_signature": "void testNewThreadNoDaemonFlag()", "filename": "BasicThreadFactoryTest.testNewThreadNoDaemonFlag.json"}
{"callee_method_ids": [116], "callee_method_names": ["Thread.setUncaughtExceptionHandler", "ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.getUncaughtExceptionHandler"], "method_name": "BasicThreadFactoryTest.testNewThreadNoExHandler", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r = EasyMock.createMock(Runnable.class);\n    final Thread.UncaughtExceptionHandler handler = EasyMock.createMock(Thread.UncaughtExceptionHandler.class);\n    final Thread t = new Thread();\n    t.setUncaughtExceptionHandler(handler);\n    EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n    EasyMock.replay(wrapped, r, handler);\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n    assertSame(t, factory.newThread(r), \"Wrong thread\");\n    assertEquals(handler, t.getUncaughtExceptionHandler(), \"Wrong exception handler\");\n    EasyMock.verify(wrapped, r, handler);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the original exception handler is not touched if none is\n * specified.\n */\n", "repo_name": "commons-lang-master/", "id": 1509, "method_signature": "void testNewThreadNoExHandler()", "filename": "BasicThreadFactoryTest.testNewThreadNoExHandler.json"}
{"callee_method_ids": [116], "callee_method_names": ["ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.getName"], "method_name": "BasicThreadFactoryTest.testNewThreadNoNamingPattern", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r = EasyMock.createMock(Runnable.class);\n    final String name = \"unchangedThreadName\";\n    final Thread t = new Thread(name);\n    EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n    EasyMock.replay(wrapped, r);\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n    assertSame(t, factory.newThread(r), \"Wrong thread\");\n    assertEquals(name, t.getName(), \"Name was changed\");\n    EasyMock.verify(wrapped, r);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the thread name is not modified if no naming pattern is\n * set.\n */\n", "repo_name": "commons-lang-master/", "id": 1510, "method_signature": "void testNewThreadNoNamingPattern()", "filename": "BasicThreadFactoryTest.testNewThreadNoNamingPattern.json"}
{"callee_method_ids": [116], "callee_method_names": ["Thread.setPriority", "ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.getPriority"], "method_name": "BasicThreadFactoryTest.testNewThreadNoPriority", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r = EasyMock.createMock(Runnable.class);\n    final int orgPriority = Thread.NORM_PRIORITY + 1;\n    final Thread t = new Thread();\n    t.setPriority(orgPriority);\n    EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n    EasyMock.replay(wrapped, r);\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n    assertSame(t, factory.newThread(r), \"Wrong thread\");\n    assertEquals(orgPriority, t.getPriority(), \"Wrong priority\");\n    EasyMock.verify(wrapped, r);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the original priority is not changed if no priority is\n * specified.\n */\n", "repo_name": "commons-lang-master/", "id": 1511, "method_signature": "void testNewThreadNoPriority()", "filename": "BasicThreadFactoryTest.testNewThreadNoPriority.json"}
{"callee_method_ids": [116], "callee_method_names": ["ThreadFactory.newThread", "BasicThreadFactory.Builder.wrappedFactory", "BasicThreadFactory.newThread", "Thread.getPriority"], "method_name": "BasicThreadFactoryTest.testNewThreadPriority", "method_implementation": "{\n    final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n    final Runnable r = EasyMock.createMock(Runnable.class);\n    final Thread t = new Thread();\n    EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n    EasyMock.replay(wrapped, r);\n    final int priority = Thread.NORM_PRIORITY + 1;\n    final BasicThreadFactory factory = builder.wrappedFactory(wrapped).priority(priority).build();\n    assertSame(t, factory.newThread(r), \"Wrong thread\");\n    assertEquals(priority, t.getPriority(), \"Wrong priority\");\n    EasyMock.verify(wrapped, r);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the priority is set on newly created threads.\n */\n", "repo_name": "commons-lang-master/", "id": 1512, "method_signature": "void testNewThreadPriority()", "filename": "BasicThreadFactoryTest.testNewThreadPriority.json"}
{"callee_method_names": ["BitField.clear", "BitField.clear", "BitField.clear"], "method_name": "BitFieldTest.testClear", "method_implementation": "{\n    assertEquals(bf_multi.clear(-1), 0xFFFFC07F);\n    assertEquals(bf_single.clear(-1), 0xFFFFBFFF);\n    assertEquals(bf_zero.clear(-1), 0xFFFFFFFF);\n}", "repo_id": "8", "comment": "/**\n * test the clear() method\n */\n", "repo_name": "commons-lang-master/", "id": 1915, "method_signature": "void testClear()", "filename": "BitFieldTest.testClear.json"}
{"callee_method_names": ["BitField.clearShort", "BitField.clearShort", "BitField.clearShort"], "method_name": "BitFieldTest.testClearShort", "method_implementation": "{\n    assertEquals(bf_multi.clearShort((short) -1), (short) 0xC07F);\n    assertEquals(bf_single.clearShort((short) -1), (short) 0xBFFF);\n    assertEquals(bf_zero.clearShort((short) -1), (short) 0xFFFF);\n}", "repo_id": "8", "comment": "/**\n * test the clearShort() method\n */\n", "repo_name": "commons-lang-master/", "id": 1916, "method_signature": "void testClearShort()", "filename": "BitFieldTest.testClearShort.json"}
{"callee_method_names": ["BitField.getRawValue", "BitField.getRawValue", "BitField.getRawValue", "BitField.getRawValue", "BitField.getRawValue", "BitField.getRawValue"], "method_name": "BitFieldTest.testGetRawValue", "method_implementation": "{\n    assertEquals(bf_multi.getRawValue(-1), 0x3F80);\n    assertEquals(bf_multi.getRawValue(0), 0);\n    assertEquals(bf_single.getRawValue(-1), 0x4000);\n    assertEquals(bf_single.getRawValue(0), 0);\n    assertEquals(bf_zero.getRawValue(-1), 0);\n    assertEquals(bf_zero.getRawValue(0), 0);\n}", "repo_id": "8", "comment": "/**\n * test the getRawValue() method\n */\n", "repo_name": "commons-lang-master/", "id": 1917, "method_signature": "void testGetRawValue()", "filename": "BitFieldTest.testGetRawValue.json"}
{"callee_method_names": ["BitField.getShortRawValue", "BitField.getShortRawValue", "BitField.getShortRawValue", "BitField.getShortRawValue", "BitField.getShortRawValue", "BitField.getShortRawValue"], "method_name": "BitFieldTest.testGetShortRawValue", "method_implementation": "{\n    assertEquals(bf_multi.getShortRawValue((short) -1), (short) 0x3F80);\n    assertEquals(bf_multi.getShortRawValue((short) 0), (short) 0);\n    assertEquals(bf_single.getShortRawValue((short) -1), (short) 0x4000);\n    assertEquals(bf_single.getShortRawValue((short) 0), (short) 0);\n    assertEquals(bf_zero.getShortRawValue((short) -1), (short) 0);\n    assertEquals(bf_zero.getShortRawValue((short) 0), (short) 0);\n}", "repo_id": "8", "comment": "/**\n * test the getShortRawValue() method\n */\n", "repo_name": "commons-lang-master/", "id": 1918, "method_signature": "void testGetShortRawValue()", "filename": "BitFieldTest.testGetShortRawValue.json"}
{"callee_method_names": ["BitField.getShortValue", "BitField.getShortValue", "BitField.getShortValue", "BitField.getShortValue", "BitField.getShortValue", "BitField.getShortValue"], "method_name": "BitFieldTest.testGetShortValue", "method_implementation": "{\n    assertEquals(bf_multi.getShortValue((short) -1), (short) 127);\n    assertEquals(bf_multi.getShortValue((short) 0), (short) 0);\n    assertEquals(bf_single.getShortValue((short) -1), (short) 1);\n    assertEquals(bf_single.getShortValue((short) 0), (short) 0);\n    assertEquals(bf_zero.getShortValue((short) -1), (short) 0);\n    assertEquals(bf_zero.getShortValue((short) 0), (short) 0);\n}", "repo_id": "8", "comment": "/**\n * test the getShortValue() method\n */\n", "repo_name": "commons-lang-master/", "id": 1919, "method_signature": "void testGetShortValue()", "filename": "BitFieldTest.testGetShortValue.json"}
{"callee_method_names": ["BitField.getValue", "BitField.getValue", "BitField.getValue", "BitField.getValue", "BitField.getValue", "BitField.getValue"], "method_name": "BitFieldTest.testGetValue", "method_implementation": "{\n    assertEquals(bf_multi.getValue(-1), 127);\n    assertEquals(bf_multi.getValue(0), 0);\n    assertEquals(bf_single.getValue(-1), 1);\n    assertEquals(bf_single.getValue(0), 0);\n    assertEquals(bf_zero.getValue(-1), 0);\n    assertEquals(bf_zero.getValue(0), 0);\n}", "repo_id": "8", "comment": "/**\n * test the getValue() method\n */\n", "repo_name": "commons-lang-master/", "id": 1920, "method_signature": "void testGetValue()", "filename": "BitFieldTest.testGetValue.json"}
{"callee_method_names": ["BitField.isAllSet", "BitField.isAllSet", "BitField.isAllSet", "BitField.isAllSet", "BitField.isAllSet"], "method_name": "BitFieldTest.testIsAllSet", "method_implementation": "{\n    for (int j = 0; j < 0x3F80; j += 0x80) {\n        assertFalse(bf_multi.isAllSet(j));\n        assertTrue(bf_zero.isAllSet(j));\n    }\n    assertTrue(bf_multi.isAllSet(0x3F80));\n    assertFalse(bf_single.isAllSet(0));\n    assertTrue(bf_single.isAllSet(0x4000));\n}", "repo_id": "8", "comment": "/**\n * test the isAllSet() method\n */\n", "repo_name": "commons-lang-master/", "id": 1921, "method_signature": "void testIsAllSet()", "filename": "BitFieldTest.testIsAllSet.json"}
{"callee_method_names": ["BitField.isSet", "BitField.isSet", "BitField.isSet", "BitField.isSet", "BitField.isSet", "BitField.isSet"], "method_name": "BitFieldTest.testIsSet", "method_implementation": "{\n    assertFalse(bf_multi.isSet(0));\n    assertFalse(bf_zero.isSet(0));\n    for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n        assertTrue(bf_multi.isSet(j));\n    }\n    for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n        assertFalse(bf_zero.isSet(j));\n    }\n    assertFalse(bf_single.isSet(0));\n    assertTrue(bf_single.isSet(0x4000));\n}", "repo_id": "8", "comment": "/**\n * test the isSet() method\n */\n", "repo_name": "commons-lang-master/", "id": 1922, "method_signature": "void testIsSet()", "filename": "BitFieldTest.testIsSet.json"}
{"callee_method_names": ["BitField.set", "BitField.set", "BitField.set"], "method_name": "BitFieldTest.testSet", "method_implementation": "{\n    assertEquals(bf_multi.set(0), 0x3F80);\n    assertEquals(bf_single.set(0), 0x4000);\n    assertEquals(bf_zero.set(0), 0);\n}", "repo_id": "8", "comment": "/**\n * test the set() method\n */\n", "repo_name": "commons-lang-master/", "id": 1923, "method_signature": "void testSet()", "filename": "BitFieldTest.testSet.json"}
{"callee_method_names": ["BitField.set", "BitField.setBoolean", "BitField.set", "BitField.setBoolean", "BitField.set", "BitField.setBoolean", "BitField.clear", "BitField.setBoolean", "BitField.clear", "BitField.setBoolean", "BitField.clear", "BitField.setBoolean"], "method_name": "BitFieldTest.testSetBoolean", "method_implementation": "{\n    assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true));\n    assertEquals(bf_single.set(0), bf_single.setBoolean(0, true));\n    assertEquals(bf_zero.set(0), bf_zero.setBoolean(0, true));\n    assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false));\n    assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false));\n    assertEquals(bf_zero.clear(-1), bf_zero.setBoolean(-1, false));\n}", "repo_id": "8", "comment": "/**\n * test the setBoolean() method\n */\n", "repo_name": "commons-lang-master/", "id": 1924, "method_signature": "void testSetBoolean()", "filename": "BitFieldTest.testSetBoolean.json"}
{"callee_method_names": ["BitField.setShort", "BitField.setShort", "BitField.setShort"], "method_name": "BitFieldTest.testSetShort", "method_implementation": "{\n    assertEquals(bf_multi.setShort((short) 0), (short) 0x3F80);\n    assertEquals(bf_single.setShort((short) 0), (short) 0x4000);\n    assertEquals(bf_zero.setShort((short) 0), (short) 0);\n}", "repo_id": "8", "comment": "/**\n * test the setShort() method\n */\n", "repo_name": "commons-lang-master/", "id": 1925, "method_signature": "void testSetShort()", "filename": "BitFieldTest.testSetShort.json"}
{"callee_method_names": ["BitField.setShort", "BitField.setShortBoolean", "BitField.setShort", "BitField.setShortBoolean", "BitField.setShort", "BitField.setShortBoolean", "BitField.clearShort", "BitField.setShortBoolean", "BitField.clearShort", "BitField.setShortBoolean", "BitField.clearShort", "BitField.setShortBoolean"], "method_name": "BitFieldTest.testSetShortBoolean", "method_implementation": "{\n    assertEquals(bf_multi.setShort((short) 0), bf_multi.setShortBoolean((short) 0, true));\n    assertEquals(bf_single.setShort((short) 0), bf_single.setShortBoolean((short) 0, true));\n    assertEquals(bf_zero.setShort((short) 0), bf_zero.setShortBoolean((short) 0, true));\n    assertEquals(bf_multi.clearShort((short) -1), bf_multi.setShortBoolean((short) -1, false));\n    assertEquals(bf_single.clearShort((short) -1), bf_single.setShortBoolean((short) -1, false));\n    assertEquals(bf_zero.clearShort((short) -1), bf_zero.setShortBoolean((short) -1, false));\n}", "repo_id": "8", "comment": "/**\n * test the setShortBoolean() method\n */\n", "repo_name": "commons-lang-master/", "id": 1926, "method_signature": "void testSetShortBoolean()", "filename": "BitFieldTest.testSetShortBoolean.json"}
{"callee_method_names": ["BitField.getShortValue", "BitField.setShortValue", "BitField.setShortValue", "BitField.getShortValue", "BitField.setShortValue", "BitField.setShortValue", "BitField.setShortValue", "BitField.getShortValue", "BitField.setShortValue", "BitField.setShortValue", "BitField.setShortValue"], "method_name": "BitFieldTest.testSetShortValue", "method_implementation": "{\n    for (int j = 0; j < 128; j++) {\n        assertEquals(bf_multi.getShortValue(bf_multi.setShortValue((short) 0, (short) j)), (short) j);\n        assertEquals(bf_multi.setShortValue((short) 0, (short) j), (short) (j << 7));\n    }\n    for (int j = 0; j < 128; j++) {\n        assertEquals(bf_zero.getShortValue(bf_zero.setShortValue((short) 0, (short) j)), (short) 0);\n        assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) 0);\n    }\n    // verify that excess bits are stripped off\n    assertEquals(bf_multi.setShortValue((short) 0x3f80, (short) 128), (short) 0);\n    for (int j = 0; j < 2; j++) {\n        assertEquals(bf_single.getShortValue(bf_single.setShortValue((short) 0, (short) j)), (short) j);\n        assertEquals(bf_single.setShortValue((short) 0, (short) j), (short) (j << 14));\n    }\n    // verify that excess bits are stripped off\n    assertEquals(bf_single.setShortValue((short) 0x4000, (short) 2), (short) 0);\n}", "repo_id": "8", "comment": "/**\n * test the setShortValue() method\n */\n", "repo_name": "commons-lang-master/", "id": 1927, "method_signature": "void testSetShortValue()", "filename": "BitFieldTest.testSetShortValue.json"}
{"callee_method_names": ["BitField.getValue", "BitField.setValue", "BitField.setValue", "BitField.getValue", "BitField.setValue", "BitField.setValue", "BitField.setValue", "BitField.getValue", "BitField.setValue", "BitField.setValue", "BitField.setValue"], "method_name": "BitFieldTest.testSetValue", "method_implementation": "{\n    for (int j = 0; j < 128; j++) {\n        assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j);\n        assertEquals(bf_multi.setValue(0, j), j << 7);\n    }\n    for (int j = 0; j < 128; j++) {\n        assertEquals(bf_zero.getValue(bf_zero.setValue(0, j)), 0);\n        assertEquals(bf_zero.setValue(0, j), 0);\n    }\n    // verify that excess bits are stripped off\n    assertEquals(bf_multi.setValue(0x3f80, 128), 0);\n    for (int j = 0; j < 2; j++) {\n        assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j);\n        assertEquals(bf_single.setValue(0, j), j << 14);\n    }\n    // verify that excess bits are stripped off\n    assertEquals(bf_single.setValue(0x4000, 2), 0);\n}", "repo_id": "8", "comment": "/**\n * test the setValue() method\n */\n", "repo_name": "commons-lang-master/", "id": 1928, "method_signature": "void testSetValue()", "filename": "BitFieldTest.testSetValue.json"}
{"callee_method_names": ["BooleanConsumer.accept"], "method_name": "BooleanConsumer.andThen", "method_implementation": "{\n    Objects.requireNonNull(after);\n    return (final boolean t) -> {\n        accept(t);\n        after.accept(t);\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns a composed {@link BooleanConsumer} that performs, in sequence, this operation followed by the {@code after}\n * operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation.\n * If performing this operation throws an exception, the {@code after} operation will not be performed.\n *\n * @param after the operation to perform after this operation\n * @return a composed {@link BooleanConsumer} that performs in sequence this operation followed by the {@code after}\n *         operation\n * @throws NullPointerException if {@code after} is null\n */\n", "repo_name": "commons-lang-master/", "id": 162, "method_signature": "BooleanConsumer andThen(BooleanConsumer)", "filename": "BooleanConsumer.andThen.json"}
{"callee_method_names": [], "method_name": "BooleanUtils.and", "method_implementation": "{\n    ObjectUtils.requireNonEmpty(array, \"array\");\n    for (final boolean element : array) {\n        if (!element) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Performs an 'and' operation on a set of booleans.\n *\n * <pre>\n *   BooleanUtils.and(true, true)         = true\n *   BooleanUtils.and(false, false)       = false\n *   BooleanUtils.and(true, false)        = false\n *   BooleanUtils.and(true, true, false)  = false\n *   BooleanUtils.and(true, true, true)   = true\n * </pre>\n *\n * @param array  an array of {@code boolean}s\n * @return the result of the logical 'and' operation. That is {@code false}\n * if any of the parameters is {@code false} and {@code true} otherwise.\n * @throws NullPointerException if {@code array} is {@code null}\n * @throws IllegalArgumentException if {@code array} is empty.\n * @since 3.0.1\n */\n", "repo_name": "commons-lang-master/", "id": 583, "method_signature": "boolean and(boolean[])", "filename": "BooleanUtils.and.json"}
{"callee_method_names": [], "method_name": "BooleanUtils.compare", "method_implementation": "{\n    if (x == y) {\n        return 0;\n    }\n    return x ? 1 : -1;\n}", "repo_id": "8", "comment": "/**\n * Compares two {@code boolean} values. This is the same functionality as provided in Java 7.\n *\n * @param x the first {@code boolean} to compare\n * @param y the second {@code boolean} to compare\n * @return the value {@code 0} if {@code x == y};\n *         a value less than {@code 0} if {@code !x && y}; and\n *         a value greater than {@code 0} if {@code x && !y}\n * @since 3.4\n */\n", "repo_name": "commons-lang-master/", "id": 584, "method_signature": "int compare(boolean, boolean)", "filename": "BooleanUtils.compare.json"}
{"callee_method_names": ["Boolean.booleanValue"], "method_name": "BooleanUtils.negate", "method_implementation": "{\n    if (bool == null) {\n        return null;\n    }\n    return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE;\n}", "repo_id": "8", "comment": "/**\n * Negates the specified boolean.\n *\n * <p>If {@code null} is passed in, {@code null} will be returned.</p>\n *\n * <p>NOTE: This returns {@code null} and will throw a {@link NullPointerException}\n * if unboxed to a boolean.</p>\n *\n * <pre>\n *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n *   BooleanUtils.negate(null)          = null;\n * </pre>\n *\n * @param bool  the Boolean to negate, may be null\n * @return the negated Boolean, or {@code null} if {@code null} input\n */\n", "repo_name": "commons-lang-master/", "id": 585, "method_signature": "Boolean negate(Boolean)", "filename": "BooleanUtils.negate.json"}
{"callee_method_names": [], "method_name": "BooleanUtils.oneHot", "method_implementation": "{\n    ObjectUtils.requireNonEmpty(array, \"array\");\n    boolean result = false;\n    for (final boolean element : array) {\n        if (element) {\n            if (result) {\n                return false;\n            }\n            result = true;\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Performs a one-hot on an array of booleans.\n * <p>\n * This implementation returns true if one, and only one, of the supplied values is true.\n * </p>\n * <p>\n * See also <a href=\"https://en.wikipedia.org/wiki/One-hot\">One-hot</a>.\n * </p>\n * @param array  an array of {@code boolean}s\n * @return the result of the one-hot operations\n * @throws NullPointerException if {@code array} is {@code null}\n * @throws IllegalArgumentException if {@code array} is empty.\n */\n", "repo_name": "commons-lang-master/", "id": 586, "method_signature": "boolean oneHot(boolean[])", "filename": "BooleanUtils.oneHot.json"}
{"callee_method_names": [], "method_name": "BooleanUtils.or", "method_implementation": "{\n    ObjectUtils.requireNonEmpty(array, \"array\");\n    for (final boolean element : array) {\n        if (element) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Performs an 'or' operation on a set of booleans.\n *\n * <pre>\n *   BooleanUtils.or(true, true)          = true\n *   BooleanUtils.or(false, false)        = false\n *   BooleanUtils.or(true, false)         = true\n *   BooleanUtils.or(true, true, false)   = true\n *   BooleanUtils.or(true, true, true)    = true\n *   BooleanUtils.or(false, false, false) = false\n * </pre>\n *\n * @param array  an array of {@code boolean}s\n * @return {@code true} if any of the arguments is {@code true}, and it returns {@code false} otherwise.\n * @throws NullPointerException if {@code array} is {@code null}\n * @throws IllegalArgumentException if {@code array} is empty.\n * @since 3.0.1\n */\n", "repo_name": "commons-lang-master/", "id": 587, "method_signature": "boolean or(boolean[])", "filename": "BooleanUtils.or.json"}
{"callee_method_names": ["String.equals", "String.equals"], "method_name": "BooleanUtils.toBoolean", "method_implementation": "{\n    if (str == trueString) {\n        return true;\n    }\n    if (str == falseString) {\n        return false;\n    }\n    if (str != null) {\n        if (str.equals(trueString)) {\n            return true;\n        }\n        if (str.equals(falseString)) {\n            return false;\n        }\n    }\n    throw new IllegalArgumentException(\"The String did not match either specified value\");\n}", "repo_id": "8", "comment": "/**\n * Converts a String to a Boolean throwing an exception if no match found.\n *\n * <pre>\n *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n * </pre>\n *\n * @param str  the String to check\n * @param trueString  the String to match for {@code true} (case-sensitive), may be {@code null}\n * @param falseString  the String to match for {@code false} (case-sensitive), may be {@code null}\n * @return the boolean value of the string\n * @throws IllegalArgumentException if the String doesn't match\n */\n", "repo_name": "commons-lang-master/", "id": 590, "method_signature": "boolean toBoolean(String, String, String)", "filename": "BooleanUtils.toBoolean.json"}
{"callee_method_names": ["Boolean.booleanValue"], "method_name": "BooleanUtils.toBooleanDefaultIfNull", "method_implementation": "{\n    if (bool == null) {\n        return valueIfNull;\n    }\n    return bool.booleanValue();\n}", "repo_id": "8", "comment": "/**\n * Converts a Boolean to a boolean handling {@code null}.\n *\n * <pre>\n *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false)  = true\n *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true)   = true\n *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true)  = false\n *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false) = false\n *   BooleanUtils.toBooleanDefaultIfNull(null, true)           = true\n *   BooleanUtils.toBooleanDefaultIfNull(null, false)          = false\n * </pre>\n *\n * @param bool  the boolean object to convert to primitive\n * @param valueIfNull  the boolean value to return if the parameter {@code bool} is {@code null}\n * @return {@code true} or {@code false}\n */\n", "repo_name": "commons-lang-master/", "id": 591, "method_signature": "boolean toBooleanDefaultIfNull(Boolean, boolean)", "filename": "BooleanUtils.toBooleanDefaultIfNull.json"}
{"callee_method_names": ["String.equals", "String.equals", "String.equals"], "method_name": "BooleanUtils.toBooleanObject", "method_implementation": "{\n    if (str == null) {\n        if (trueString == null) {\n            return Boolean.TRUE;\n        }\n        if (falseString == null) {\n            return Boolean.FALSE;\n        }\n        if (nullString == null) {\n            return null;\n        }\n    } else if (str.equals(trueString)) {\n        return Boolean.TRUE;\n    } else if (str.equals(falseString)) {\n        return Boolean.FALSE;\n    } else if (str.equals(nullString)) {\n        return null;\n    }\n    // no match\n    throw new IllegalArgumentException(\"The String did not match any specified value\");\n}", "repo_id": "8", "comment": "/**\n * Converts a String to a Boolean throwing an exception if no match.\n *\n * <p>NOTE: This method may return {@code null} and may throw a {@link NullPointerException}\n * if unboxed to a {@code boolean}.</p>\n *\n * <pre>\n *   BooleanUtils.toBooleanObject(\"true\", \"true\", \"false\", \"null\")   = Boolean.TRUE\n *   BooleanUtils.toBooleanObject(null, null, \"false\", \"null\")       = Boolean.TRUE\n *   BooleanUtils.toBooleanObject(null, null, null, \"null\")          = Boolean.TRUE\n *   BooleanUtils.toBooleanObject(null, null, null, null)            = Boolean.TRUE\n *   BooleanUtils.toBooleanObject(\"false\", \"true\", \"false\", \"null\")  = Boolean.FALSE\n *   BooleanUtils.toBooleanObject(\"false\", \"true\", \"false\", \"false\") = Boolean.FALSE\n *   BooleanUtils.toBooleanObject(null, \"true\", null, \"false\")       = Boolean.FALSE\n *   BooleanUtils.toBooleanObject(null, \"true\", null, null)          = Boolean.FALSE\n *   BooleanUtils.toBooleanObject(\"null\", \"true\", \"false\", \"null\")   = null\n * </pre>\n *\n * @param str  the String to check\n * @param trueString  the String to match for {@code true} (case-sensitive), may be {@code null}\n * @param falseString  the String to match for {@code false} (case-sensitive), may be {@code null}\n * @param nullString  the String to match for {@code null} (case-sensitive), may be {@code null}\n * @return the Boolean value of the string, {@code null} if either the String matches {@code nullString}\n *  or if {@code null} input and {@code nullString} is {@code null}\n * @throws IllegalArgumentException if the String doesn't match\n */\n", "repo_name": "commons-lang-master/", "id": 596, "method_signature": "Boolean toBooleanObject(String, String, String, String)", "filename": "BooleanUtils.toBooleanObject.json"}
{"callee_method_names": ["Boolean.booleanValue"], "method_name": "BooleanUtils.toInteger", "method_implementation": "{\n    if (bool == null) {\n        return nullValue;\n    }\n    return bool.booleanValue() ? trueValue : falseValue;\n}", "repo_id": "8", "comment": "/**\n * Converts a Boolean to an int specifying the conversion values.\n *\n * <pre>\n *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n * </pre>\n *\n * @param bool  the Boolean to convert\n * @param trueValue  the value to return if {@code true}\n * @param falseValue  the value to return if {@code false}\n * @param nullValue  the value to return if {@code null}\n * @return the appropriate value\n */\n", "repo_name": "commons-lang-master/", "id": 597, "method_signature": "int toInteger(Boolean, int, int, int)", "filename": "BooleanUtils.toInteger.json"}
{"callee_method_names": ["Boolean.booleanValue"], "method_name": "BooleanUtils.toIntegerObject", "method_implementation": "{\n    if (bool == null) {\n        return nullValue;\n    }\n    return bool.booleanValue() ? trueValue : falseValue;\n}", "repo_id": "8", "comment": "/**\n * Converts a Boolean to an Integer specifying the conversion values.\n *\n * <pre>\n *   BooleanUtils.toIntegerObject(Boolean.TRUE, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2))  = Integer.valueOf(1)\n *   BooleanUtils.toIntegerObject(Boolean.FALSE, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2)) = Integer.valueOf(0)\n *   BooleanUtils.toIntegerObject(null, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2))          = Integer.valueOf(2)\n * </pre>\n *\n * @param bool  the Boolean to convert\n * @param trueValue  the value to return if {@code true}, may be {@code null}\n * @param falseValue  the value to return if {@code false}, may be {@code null}\n * @param nullValue  the value to return if {@code null}, may be {@code null}\n * @return the appropriate value\n */\n", "repo_name": "commons-lang-master/", "id": 599, "method_signature": "Integer toIntegerObject(Boolean, Integer, Integer, Integer)", "filename": "BooleanUtils.toIntegerObject.json"}
{"callee_method_names": ["Boolean.booleanValue"], "method_name": "BooleanUtils.toString", "method_implementation": "{\n    if (bool == null) {\n        return nullString;\n    }\n    return bool.booleanValue() ? trueString : falseString;\n}", "repo_id": "8", "comment": "/**\n * Converts a Boolean to a String returning one of the input Strings.\n *\n * <pre>\n *   BooleanUtils.toString(Boolean.TRUE, \"true\", \"false\", null)   = \"true\"\n *   BooleanUtils.toString(Boolean.FALSE, \"true\", \"false\", null)  = \"false\"\n *   BooleanUtils.toString(null, \"true\", \"false\", null)           = null;\n * </pre>\n *\n * @param bool  the Boolean to check\n * @param trueString  the String to return if {@code true}, may be {@code null}\n * @param falseString  the String to return if {@code false}, may be {@code null}\n * @param nullString  the String to return if {@code null}, may be {@code null}\n * @return one of the three input Strings\n */\n", "repo_name": "commons-lang-master/", "id": 600, "method_signature": "String toString(Boolean, String, String, String)", "filename": "BooleanUtils.toString.json"}
{"callee_method_names": [], "method_name": "BooleanUtils.xor", "method_implementation": "{\n    ObjectUtils.requireNonEmpty(array, \"array\");\n    // false if the neutral element of the xor operator\n    boolean result = false;\n    for (final boolean element : array) {\n        result ^= element;\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Performs an xor on a set of booleans.\n * <p>\n *   This behaves like an XOR gate;\n *   it returns true if the number of true values is odd,\n *   and false if the number of true values is zero or even.\n * </p>\n *\n * <pre>\n *   BooleanUtils.xor(true, true)             = false\n *   BooleanUtils.xor(false, false)           = false\n *   BooleanUtils.xor(true, false)            = true\n *   BooleanUtils.xor(true, false, false)     = true\n *   BooleanUtils.xor(true, true, true)       = true\n *   BooleanUtils.xor(true, true, true, true) = false\n * </pre>\n *\n * @param array  an array of {@code boolean}s\n * @return true if the number of true values in the array is odd; otherwise returns false.\n * @throws NullPointerException if {@code array} is {@code null}\n * @throws IllegalArgumentException if {@code array} is empty.\n */\n", "repo_name": "commons-lang-master/", "id": 601, "method_signature": "boolean xor(boolean[])", "filename": "BooleanUtils.xor.json"}
{"callee_method_names": [], "method_name": "Builder.build", "method_implementation": "{\n    final BasicThreadFactory factory = new BasicThreadFactory(this);\n    reset();\n    return factory;\n}", "repo_id": "8", "comment": "/**\n * Creates a new {@link BasicThreadFactory} with all configuration\n * options that have been specified by calling methods on this builder.\n * After creating the factory {@link #reset()} is called.\n *\n * @return the new {@link BasicThreadFactory}\n */\n", "repo_name": "commons-lang-master/", "id": 117, "method_signature": "BasicThreadFactory build()", "filename": "Builder.build.json"}
{"callee_method_names": [], "method_name": "Builder.namingPattern", "method_implementation": "{\n    Objects.requireNonNull(pattern, \"pattern\");\n    namingPattern = pattern;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the naming pattern to be used by the new {@code\n * BasicThreadFactory}.\n *\n * @param pattern the naming pattern (must not be <b>null</b>)\n * @return a reference to this {@link Builder}\n * @throws NullPointerException if the naming pattern is <b>null</b>\n */\n", "repo_name": "commons-lang-master/", "id": 118, "method_signature": "Builder namingPattern(String)", "filename": "Builder.namingPattern.json"}
{"callee_method_names": [], "method_name": "Builder.reset", "method_implementation": "{\n    wrappedFactory = null;\n    exceptionHandler = null;\n    namingPattern = null;\n    priority = null;\n    daemon = null;\n}", "repo_id": "8", "comment": "/**\n * Resets this builder. All configuration options are set to default\n * values. Note: If the {@link #build()} method was called, it is not\n * necessary to call {@code reset()} explicitly because this is done\n * automatically.\n */\n", "repo_name": "commons-lang-master/", "id": 119, "method_signature": "void reset()", "filename": "Builder.reset.json"}
{"callee_method_names": [], "method_name": "Builder.uncaughtExceptionHandler", "method_implementation": "{\n    Objects.requireNonNull(handler, \"handler\");\n    exceptionHandler = handler;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the uncaught exception handler for the threads created by the\n * new {@link BasicThreadFactory}.\n *\n * @param handler the {@link UncaughtExceptionHandler} (must not be\n * <b>null</b>)\n * @return a reference to this {@link Builder}\n * @throws NullPointerException if the exception handler is <b>null</b>\n */\n", "repo_name": "commons-lang-master/", "id": 120, "method_signature": "Builder uncaughtExceptionHandler(Thread.UncaughtExceptionHandler)", "filename": "Builder.uncaughtExceptionHandler.json"}
{"callee_method_names": [], "method_name": "Builder.wrappedFactory", "method_implementation": "{\n    Objects.requireNonNull(factory, \"factory\");\n    wrappedFactory = factory;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the {@link ThreadFactory} to be wrapped by the new {@code\n * BasicThreadFactory}.\n *\n * @param factory the wrapped {@link ThreadFactory} (must not be\n * <b>null</b>)\n * @return a reference to this {@link Builder}\n * @throws NullPointerException if the passed in {@link ThreadFactory}\n * is <b>null</b>\n */\n", "repo_name": "commons-lang-master/", "id": 121, "method_signature": "Builder wrappedFactory(ThreadFactory)", "filename": "Builder.wrappedFactory.json"}
{"callee_method_names": ["Calendar.getDisplayNames", "Map<String, Integer>.size", "Map<String, Integer>.forEach"], "method_name": "CalendarUtils.getMonthDisplayNames", "method_implementation": "{\n    // Unfortunately standalone month names are not available in DateFormatSymbols,\n    // so we have to extract them.\n    final Map<String, Integer> displayNames = calendar.getDisplayNames(Calendar.MONTH, style, locale);\n    if (displayNames == null) {\n        return null;\n    }\n    final String[] monthNames = new String[displayNames.size()];\n    displayNames.forEach((k, v) -> monthNames[v] = k);\n    return monthNames;\n}", "repo_id": "8", "comment": "/**\n * Gets month names in the requested style.\n * @param style Must be a valid {@link Calendar#getDisplayNames(int, int, Locale)} month style.\n * @return Styled names of months\n */\n", "repo_name": "commons-lang-master/", "id": 709, "method_signature": "String[] getMonthDisplayNames(int)", "filename": "CalendarUtils.getMonthDisplayNames.json"}
{"callee_method_names": [], "method_name": "CallableBackgroundInitializer.getTypedException", "method_implementation": "{\n    //This Exception object will be used for type comparison in AbstractConcurrentInitializer.initialize but not thrown\n    return new Exception(e);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 87, "method_signature": "Exception getTypedException(Exception)", "filename": "CallableBackgroundInitializer.getTypedException.json"}
{"callee_method_names": [], "method_name": "CallableBackgroundInitializerTest.call", "method_implementation": "{\n    callCount++;\n    return RESULT;\n}", "repo_id": "8", "comment": "/**\n * Records this invocation and returns the test result.\n */\n", "repo_name": "commons-lang-master/", "id": 1550, "method_signature": "Integer call()", "filename": "CallableBackgroundInitializerTest.call.json"}
{"callee_method_names": ["CallableBackgroundInitializer<Integer>.getExternalExecutor", "ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "CallableBackgroundInitializerTest.testInitExecutor", "method_implementation": "{\n    final ExecutorService exec = Executors.newSingleThreadExecutor();\n    final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<>(new TestCallable(), exec);\n    assertEquals(exec, init.getExternalExecutor(), \"Executor not set\");\n    exec.shutdown();\n    exec.awaitTermination(1, TimeUnit.SECONDS);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the executor service is correctly passed to the super\n * class.\n */\n", "repo_name": "commons-lang-master/", "id": 1551, "method_signature": "void testInitExecutor()", "filename": "CallableBackgroundInitializerTest.testInitExecutor.json"}
{"callee_method_names": ["ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "CallableBackgroundInitializerTest.testInitExecutorNullCallable", "method_implementation": "{\n    final ExecutorService exec = Executors.newSingleThreadExecutor();\n    try {\n        assertThrows(NullPointerException.class, () -> new CallableBackgroundInitializer<Integer>(null, exec));\n    } finally {\n        exec.shutdown();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tries to pass a null Callable to the constructor that takes an executor.\n * This should cause an exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1552, "method_signature": "void testInitExecutorNullCallable()", "filename": "CallableBackgroundInitializerTest.testInitExecutorNullCallable.json"}
{"callee_method_names": ["CallableBackgroundInitializer<Integer>.initialize"], "method_name": "CallableBackgroundInitializerTest.testInitialize", "method_implementation": "{\n    final TestCallable call = new TestCallable();\n    final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<>(call);\n    assertEquals(RESULT, init.initialize(), \"Wrong result\");\n    assertEquals(1, call.callCount, \"Wrong number of invocations\");\n}", "repo_id": "8", "comment": "/**\n * Tests the implementation of initialize().\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1553, "method_signature": "void testInitialize()", "filename": "CallableBackgroundInitializerTest.testInitialize.json"}
{"callee_method_names": ["String.toLowerCase", "Map<String, Integer>.get", "Map<String, Integer>.get", "Calendar.set", "Integer.intValue"], "method_name": "CaseInsensitiveTextStrategy.setCalendar", "method_implementation": "{\n    final String lowerCase = value.toLowerCase(locale);\n    Integer iVal = lKeyValues.get(lowerCase);\n    if (iVal == null) {\n        // match missing the optional trailing period\n        iVal = lKeyValues.get(lowerCase + '.');\n    }\n    // LANG-1669: Mimic fix done in OpenJDK 17 to resolve issue with parsing newly supported day periods added in OpenJDK 16\n    if (Calendar.AM_PM != this.field || iVal <= 1) {\n        calendar.set(field, iVal.intValue());\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 626, "method_signature": "void setCalendar(FastDateParser, Calendar, String)", "filename": "CaseInsensitiveTextStrategy.setCalendar.json"}
{"callee_method_names": [], "method_name": "CharEncoding.isSupported", "method_implementation": "{\n    if (name == null) {\n        return false;\n    }\n    try {\n        return Charset.isSupported(name);\n    } catch (final IllegalCharsetNameException ex) {\n        return false;\n    }\n}", "repo_id": "8", "comment": "/**\n * Returns whether the named charset is supported.\n *\n * <p>This is similar to <a\n * href=\"https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#isSupported%28java.lang.String%29\">\n * java.nio.charset.Charset.isSupported(String)</a> but handles more formats</p>\n *\n * @param name  the name of the requested charset; may be either a canonical name or an alias, null returns false\n * @return {@code true} if the charset is available in the current Java virtual machine\n * @deprecated Please use {@link Charset#isSupported(String)} instead, although be aware that {@code null}\n * values are not accepted by that method and an {@link IllegalCharsetNameException} may be thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 81, "method_signature": "boolean isSupported(String)", "filename": "CharEncoding.isSupported.json"}
{"callee_method_names": [], "method_name": "CharRange.contains", "method_implementation": "{\n    Objects.requireNonNull(range, \"range\");\n    if (negated) {\n        if (range.negated) {\n            return start >= range.start && end <= range.end;\n        }\n        return range.end < start || range.start > end;\n    }\n    if (range.negated) {\n        return start == 0 && end == Character.MAX_VALUE;\n    }\n    return start <= range.start && end >= range.end;\n}", "repo_id": "8", "comment": "/**\n * Are all the characters of the passed in range contained in\n * this range.\n *\n * @param range  the range to check against\n * @return {@code true} if this range entirely contains the input range\n * @throws NullPointerException if {@code null} input\n */\n", "repo_name": "commons-lang-master/", "id": 76, "method_signature": "boolean contains(CharRange)", "filename": "CharRange.contains.json"}
{"callee_method_names": [], "method_name": "CharRange.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof CharRange)) {\n        return false;\n    }\n    final CharRange other = (CharRange) obj;\n    return start == other.start && end == other.end && negated == other.negated;\n}", "repo_id": "8", "comment": "/**\n * Compares two CharRange objects, returning true if they represent\n * exactly the same range of characters defined in the same way.\n *\n * @param obj  the object to compare to\n * @return true if equal\n */\n", "repo_name": "commons-lang-master/", "id": 77, "method_signature": "boolean equals(Object)", "filename": "CharRange.equals.json"}
{"callee_method_names": [], "method_name": "CharRange.next", "method_implementation": "{\n    if (!hasNext) {\n        throw new NoSuchElementException();\n    }\n    final char cur = current;\n    prepareNext();\n    return Character.valueOf(cur);\n}", "repo_id": "8", "comment": "/**\n * Returns the next character in the iteration\n *\n * @return {@link Character} for the next character\n */\n", "repo_name": "commons-lang-master/", "id": 74, "method_signature": "Character next()", "filename": "CharRange.next.json"}
{"callee_method_names": [], "method_name": "CharRange.prepareNext", "method_implementation": "{\n    if (range.negated) {\n        if (current == Character.MAX_VALUE) {\n            hasNext = false;\n        } else if (current + 1 == range.start) {\n            if (range.end == Character.MAX_VALUE) {\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = (char) (current + 1);\n        }\n    } else if (current < range.end) {\n        current = (char) (current + 1);\n    } else {\n        hasNext = false;\n    }\n}", "repo_id": "8", "comment": "/**\n * Prepares the next character in the range.\n */\n", "repo_name": "commons-lang-master/", "id": 75, "method_signature": "void prepareNext()", "filename": "CharRange.prepareNext.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CharRange.toString", "method_implementation": "{\n    if (iToString == null) {\n        final StringBuilder buf = new StringBuilder(4);\n        if (isNegated()) {\n            buf.append('^');\n        }\n        buf.append(start);\n        if (start != end) {\n            buf.append('-');\n            buf.append(end);\n        }\n        iToString = buf.toString();\n    }\n    return iToString;\n}", "repo_id": "8", "comment": "/**\n * Gets a string representation of the character range.\n *\n * @return string representation of this range\n */\n", "repo_name": "commons-lang-master/", "id": 78, "method_signature": "String toString()", "filename": "CharRange.toString.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "Writer.write", "CharSequence.charAt", "Writer.write"], "method_name": "CharSequenceTranslator.translate", "method_implementation": "{\n    Objects.requireNonNull(writer, \"writer\");\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    final int len = input.length();\n    while (pos < len) {\n        final int consumed = translate(input, pos, writer);\n        if (consumed == 0) {\n            // inlined implementation of Character.toChars(Character.codePointAt(input, pos))\n            // avoids allocating temp char arrays and duplicate checks\n            final char c1 = input.charAt(pos);\n            writer.write(c1);\n            pos++;\n            if (Character.isHighSurrogate(c1) && pos < len) {\n                final char c2 = input.charAt(pos);\n                if (Character.isLowSurrogate(c2)) {\n                    writer.write(c2);\n                    pos++;\n                }\n            }\n            continue;\n        }\n        // contract with translators is that they have to understand code points\n        // and they just took care of a surrogate pair\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\n * tightly coupled with the abstract method of this class.\n *\n * @param input CharSequence that is being translated\n * @param writer Writer to translate the text to\n * @throws IOException if and only if the Writer produces an IOException\n */\n", "repo_name": "commons-lang-master/", "id": 424, "method_signature": "void translate(CharSequence, Writer)", "filename": "CharSequenceTranslator.translate.json"}
{"callee_method_names": [], "method_name": "CharSequenceTranslator.with", "method_implementation": "{\n    final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n    newArray[0] = this;\n    System.arraycopy(translators, 0, newArray, 1, translators.length);\n    return new AggregateTranslator(newArray);\n}", "repo_id": "8", "comment": "/**\n * Helper method to create a merger of this translator with another set of\n * translators. Useful in customizing the standard functionality.\n *\n * @param translators CharSequenceTranslator array of translators to merge with this one\n * @return CharSequenceTranslator merging this translator with the others\n */\n", "repo_name": "commons-lang-master/", "id": 425, "method_signature": "CharSequenceTranslator with(CharSequenceTranslator[])", "filename": "CharSequenceTranslator.with.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "CharSequenceUtils.indexOf", "method_implementation": "{\n    if (cs instanceof String) {\n        return ((String) cs).indexOf(searchChar, start);\n    }\n    final int sz = cs.length();\n    if (start < 0) {\n        start = 0;\n    }\n    if (searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n        for (int i = start; i < sz; i++) {\n            if (cs.charAt(i) == searchChar) {\n                return i;\n            }\n        }\n        return NOT_FOUND;\n    }\n    //supplementary characters (LANG1300)\n    if (searchChar <= Character.MAX_CODE_POINT) {\n        final char[] chars = Character.toChars(searchChar);\n        for (int i = start; i < sz - 1; i++) {\n            final char high = cs.charAt(i);\n            final char low = cs.charAt(i + 1);\n            if (high == chars[0] && low == chars[1]) {\n                return i;\n            }\n        }\n    }\n    return NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Returns the index within {@code cs} of the first occurrence of the\n * specified character, starting the search at the specified index.\n * <p>\n * If a character with value {@code searchChar} occurs in the\n * character sequence represented by the {@code cs}\n * object at an index no smaller than {@code start}, then\n * the index of the first such occurrence is returned. For values\n * of {@code searchChar} in the range from 0 to 0xFFFF (inclusive),\n * this is the smallest value <i>k</i> such that:\n * </p>\n * <blockquote><pre>\n * (this.charAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &gt;= start)\n * </pre></blockquote>\n * is true. For other values of {@code searchChar}, it is the\n * smallest value <i>k</i> such that:\n * <blockquote><pre>\n * (this.codePointAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &gt;= start)\n * </pre></blockquote>\n * <p>\n * is true. In either case, if no such character occurs inm {@code cs}\n * at or after position {@code start}, then\n * {@code -1} is returned.\n * </p>\n * <p>\n * There is no restriction on the value of {@code start}. If it\n * is negative, it has the same effect as if it were zero: the entire\n * {@link CharSequence} may be searched. If it is greater than\n * the length of {@code cs}, it has the same effect as if it were\n * equal to the length of {@code cs}: {@code -1} is returned.\n * </p>\n * <p>All indices are specified in {@code char} values\n * (Unicode code units).\n * </p>\n *\n * @param cs  the {@link CharSequence} to be processed, not null\n * @param searchChar  the char to be searched for\n * @param start  the start index, negative starts at the string start\n * @return the index where the search char was found, -1 if not found\n * @since 3.6 updated to behave more like {@link String}\n */\n", "repo_name": "commons-lang-master/", "id": 1365, "method_signature": "int indexOf(CharSequence, int, int)", "filename": "CharSequenceUtils.indexOf.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "CharSequenceUtils.lastIndexOf", "method_implementation": "{\n    if (cs instanceof String) {\n        return ((String) cs).lastIndexOf(searchChar, start);\n    }\n    final int sz = cs.length();\n    if (start < 0) {\n        return NOT_FOUND;\n    }\n    if (start >= sz) {\n        start = sz - 1;\n    }\n    if (searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n        for (int i = start; i >= 0; --i) {\n            if (cs.charAt(i) == searchChar) {\n                return i;\n            }\n        }\n        return NOT_FOUND;\n    }\n    //supplementary characters (LANG1300)\n    //NOTE - we must do a forward traversal for this to avoid duplicating code points\n    if (searchChar <= Character.MAX_CODE_POINT) {\n        final char[] chars = Character.toChars(searchChar);\n        //make sure it's not the last index\n        if (start == sz - 1) {\n            return NOT_FOUND;\n        }\n        for (int i = start; i >= 0; i--) {\n            final char high = cs.charAt(i);\n            final char low = cs.charAt(i + 1);\n            if (chars[0] == high && chars[1] == low) {\n                return i;\n            }\n        }\n    }\n    return NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Returns the index within {@code cs} of the last occurrence of\n * the specified character, searching backward starting at the\n * specified index. For values of {@code searchChar} in the range\n * from 0 to 0xFFFF (inclusive), the index returned is the largest\n * value <i>k</i> such that:\n * <blockquote><pre>\n * (this.charAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= start)\n * </pre></blockquote>\n * is true. For other values of {@code searchChar}, it is the\n * largest value <i>k</i> such that:\n * <blockquote><pre>\n * (this.codePointAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= start)\n * </pre></blockquote>\n * is true. In either case, if no such character occurs in {@code cs}\n * at or before position {@code start}, then {@code -1} is returned.\n *\n * <p>\n * All indices are specified in {@code char} values\n * (Unicode code units).\n * </p>\n *\n * @param cs  the {@link CharSequence} to be processed\n * @param searchChar  the char to be searched for\n * @param start  the start index, negative returns -1, beyond length starts at end\n * @return the index where the search char was found, -1 if not found\n * @since 3.6 updated to behave more like {@link String}\n */\n", "repo_name": "commons-lang-master/", "id": 1367, "method_signature": "int lastIndexOf(CharSequence, int, int)", "filename": "CharSequenceUtils.lastIndexOf.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "CharSequenceUtils.regionMatches", "method_implementation": "{\n    if (cs instanceof String && substring instanceof String) {\n        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n    }\n    int index1 = thisStart;\n    int index2 = start;\n    int tmpLen = length;\n    // Extract these first so we detect NPEs the same as the java.lang.String version\n    final int srcLen = cs.length() - thisStart;\n    final int otherLen = substring.length() - start;\n    // Check for invalid parameters\n    if (thisStart < 0 || start < 0 || length < 0) {\n        return false;\n    }\n    // Check that the regions are long enough\n    if (srcLen < length || otherLen < length) {\n        return false;\n    }\n    while (tmpLen-- > 0) {\n        final char c1 = cs.charAt(index1++);\n        final char c2 = substring.charAt(index2++);\n        if (c1 == c2) {\n            continue;\n        }\n        if (!ignoreCase) {\n            return false;\n        }\n        // The real same check as in String.regionMatches():\n        final char u1 = Character.toUpperCase(c1);\n        final char u2 = Character.toUpperCase(c2);\n        if (u1 != u2 && Character.toLowerCase(u1) != Character.toLowerCase(u2)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Green implementation of regionMatches.\n *\n * @param cs the {@link CharSequence} to be processed\n * @param ignoreCase whether or not to be case-insensitive\n * @param thisStart the index to start on the {@code cs} CharSequence\n * @param substring the {@link CharSequence} to be looked for\n * @param start the index to start on the {@code substring} CharSequence\n * @param length character length of the region\n * @return whether the region matched\n */\n", "repo_name": "commons-lang-master/", "id": 1368, "method_signature": "boolean regionMatches(CharSequence, boolean, int, CharSequence, int, int)", "filename": "CharSequenceUtils.regionMatches.json"}
{"callee_method_names": ["CharSequence.charAt"], "method_name": "CharSequenceUtils.toCharArray", "method_implementation": "{\n    final int len = StringUtils.length(source);\n    if (len == 0) {\n        return ArrayUtils.EMPTY_CHAR_ARRAY;\n    }\n    if (source instanceof String) {\n        return ((String) source).toCharArray();\n    }\n    final char[] array = new char[len];\n    for (int i = 0; i < len; i++) {\n        array[i] = source.charAt(i);\n    }\n    return array;\n}", "repo_id": "8", "comment": "/**\n * Converts the given CharSequence to a char[].\n *\n * @param source the {@link CharSequence} to be processed.\n * @return the resulting char array, never null.\n * @since 3.11\n */\n", "repo_name": "commons-lang-master/", "id": 1369, "method_signature": "char[] toCharArray(CharSequence)", "filename": "CharSequenceUtils.toCharArray.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.charAt", "Set<CharRange>.add", "String.charAt", "String.charAt", "String.charAt", "Set<CharRange>.add", "String.charAt", "String.charAt", "String.charAt", "Set<CharRange>.add", "String.charAt", "Set<CharRange>.add", "String.charAt"], "method_name": "CharSet.add", "method_implementation": "{\n    if (str == null) {\n        return;\n    }\n    final int len = str.length();\n    int pos = 0;\n    while (pos < len) {\n        final int remainder = len - pos;\n        if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') {\n            // negated range\n            set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3)));\n            pos += 4;\n        } else if (remainder >= 3 && str.charAt(pos + 1) == '-') {\n            // range\n            set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2)));\n            pos += 3;\n        } else if (remainder >= 2 && str.charAt(pos) == '^') {\n            // negated char\n            set.add(CharRange.isNot(str.charAt(pos + 1)));\n            pos += 2;\n        } else {\n            // char\n            set.add(CharRange.is(str.charAt(pos)));\n            pos += 1;\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Add a set definition string to the {@link CharSet}.\n *\n * @param str  set definition string\n */\n", "repo_name": "commons-lang-master/", "id": 538, "method_signature": "void add(String)", "filename": "CharSet.add.json"}
{"callee_method_ids": [76], "callee_method_names": ["Set<CharRange>.stream", "CharRange.contains"], "method_name": "CharSet.contains", "method_implementation": "{\n    synchronized (set) {\n        return set.stream().anyMatch(range -> range.contains(ch));\n    }\n}", "repo_id": "8", "comment": "/**\n * Does the {@link CharSet} contain the specified\n * character {@code ch}.\n *\n * @param ch  the character to check for\n * @return {@code true} if the set contains the characters\n */\n", "repo_name": "commons-lang-master/", "id": 539, "method_signature": "boolean contains(char)", "filename": "CharSet.contains.json"}
{"callee_method_names": ["Set<CharRange>.equals"], "method_name": "CharSet.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof CharSet)) {\n        return false;\n    }\n    final CharSet other = (CharSet) obj;\n    return set.equals(other.set);\n}", "repo_id": "8", "comment": "/**\n * Compares two {@link CharSet} objects, returning true if they represent\n * exactly the same set of characters defined in the same way.\n *\n * <p>The two sets {@code abc} and {@code a-c} are <i>not</i>\n * equal according to this method.</p>\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 540, "method_signature": "boolean equals(Object)", "filename": "CharSet.equals.json"}
{"callee_method_names": ["Map<String, CharSet>.get"], "method_name": "CharSet.getInstance", "method_implementation": "{\n    if (setStrs == null) {\n        return null;\n    }\n    if (setStrs.length == 1) {\n        final CharSet common = COMMON.get(setStrs[0]);\n        if (common != null) {\n            return common;\n        }\n    }\n    return new CharSet(setStrs);\n}", "repo_id": "8", "comment": "/**\n * Factory method to create a new CharSet using a special syntax.\n *\n * <ul>\n *  <li>{@code null} or empty string (\"\")\n * - set containing no characters</li>\n *  <li>Single character, such as \"a\"\n *  - set containing just that character</li>\n *  <li>Multi character, such as \"a-e\"\n *  - set containing characters from one character to the other</li>\n *  <li>Negated, such as \"^a\" or \"^a-e\"\n *  - set containing all characters except those defined</li>\n *  <li>Combinations, such as \"abe-g\"\n *  - set containing all the characters from the individual sets</li>\n * </ul>\n *\n * <p>The matching order is:</p>\n * <ol>\n *  <li>Negated multi character range, such as \"^a-e\"\n *  <li>Ordinary multi character range, such as \"a-e\"\n *  <li>Negated single character, such as \"^a\"\n *  <li>Ordinary single character, such as \"a\"\n * </ol>\n *\n * <p>Matching works left to right. Once a match is found the\n * search starts again from the next character.</p>\n *\n * <p>If the same range is defined twice using the same syntax, only\n * one range will be kept.\n * Thus, \"a-ca-c\" creates only one range of \"a-c\".</p>\n *\n * <p>If the start and end of a range are in the wrong order,\n * they are reversed. Thus \"a-e\" is the same as \"e-a\".\n * As a result, \"a-ee-a\" would create only one range,\n * as the \"a-e\" and \"e-a\" are the same.</p>\n *\n * <p>The set of characters represented is the union of the specified ranges.</p>\n *\n * <p>There are two ways to add a literal negation character ({@code ^}):</p>\n * <ul>\n *     <li>As the last character in a string, e.g. {@code CharSet.getInstance(\"a-z^\")}</li>\n *     <li>As a separate element, e.g. {@code CharSet.getInstance(\"^\", \"a-z\")}</li>\n * </ul>\n *\n * <p>Examples using the negation character:</p>\n * <pre>\n *     CharSet.getInstance(\"^a-c\").contains('a') = false\n *     CharSet.getInstance(\"^a-c\").contains('d') = true\n *     CharSet.getInstance(\"^^a-c\").contains('a') = true // (only '^' is negated)\n *     CharSet.getInstance(\"^^a-c\").contains('^') = false\n *     CharSet.getInstance(\"^a-cd-f\").contains('d') = true\n *     CharSet.getInstance(\"a-c^\").contains('^') = true\n *     CharSet.getInstance(\"^\", \"a-c\").contains('^') = true\n * </pre>\n *\n * <p>All CharSet objects returned by this method will be immutable.</p>\n *\n * @param setStrs  Strings to merge into the set, may be null\n * @return a CharSet instance\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 537, "method_signature": "CharSet getInstance(String[])", "filename": "CharSet.getInstance.json"}
{"callee_method_ids": [539], "callee_method_names": ["String.toCharArray", "CharSet.contains"], "method_name": "CharSetUtils.containsAny", "method_implementation": "{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return false;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Takes an argument in set-syntax, see evaluateSet,\n * and identifies whether any of the characters are present in the specified string.\n *\n * <pre>\n * CharSetUtils.containsAny(null, *)        = false\n * CharSetUtils.containsAny(\"\", *)          = false\n * CharSetUtils.containsAny(*, null)        = false\n * CharSetUtils.containsAny(*, \"\")          = false\n * CharSetUtils.containsAny(\"hello\", \"k-p\") = true\n * CharSetUtils.containsAny(\"hello\", \"a-d\") = false\n * </pre>\n *\n * @see CharSet#getInstance(String...) for set-syntax.\n * @param str  String to look for characters in, may be null\n * @param set  String[] set of characters to identify, may be null\n * @return whether or not the characters in the set are in the primary string\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 762, "method_signature": "boolean containsAny(String, String[])", "filename": "CharSetUtils.containsAny.json"}
{"callee_method_ids": [539], "callee_method_names": ["String.toCharArray", "CharSet.contains"], "method_name": "CharSetUtils.count", "method_implementation": "{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}", "repo_id": "8", "comment": "/**\n * Takes an argument in set-syntax, see evaluateSet,\n * and returns the number of characters present in the specified string.\n *\n * <pre>\n * CharSetUtils.count(null, *)        = 0\n * CharSetUtils.count(\"\", *)          = 0\n * CharSetUtils.count(*, null)        = 0\n * CharSetUtils.count(*, \"\")          = 0\n * CharSetUtils.count(\"hello\", \"k-p\") = 3\n * CharSetUtils.count(\"hello\", \"a-e\") = 1\n * </pre>\n *\n * @see CharSet#getInstance(String...) for set-syntax.\n * @param str  String to count characters in, may be null\n * @param set  String[] set of characters to count, may be null\n * @return the character count, zero if null string input\n */\n", "repo_name": "commons-lang-master/", "id": 763, "method_signature": "int count(String, String[])", "filename": "CharSetUtils.count.json"}
{"callee_method_names": [], "method_name": "CharSetUtils.delete", "method_implementation": "{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, false);\n}", "repo_id": "8", "comment": "/**\n * Takes an argument in set-syntax, see evaluateSet,\n * and deletes any of characters present in the specified string.\n *\n * <pre>\n * CharSetUtils.delete(null, *)        = null\n * CharSetUtils.delete(\"\", *)          = \"\"\n * CharSetUtils.delete(*, null)        = *\n * CharSetUtils.delete(*, \"\")          = *\n * CharSetUtils.delete(\"hello\", \"hl\")  = \"eo\"\n * CharSetUtils.delete(\"hello\", \"le\")  = \"ho\"\n * </pre>\n *\n * @see CharSet#getInstance(String...) for set-syntax.\n * @param str  String to delete characters from, may be null\n * @param set  String[] set of characters to delete, may be null\n * @return the modified String, {@code null} if null string input\n */\n", "repo_name": "commons-lang-master/", "id": 764, "method_signature": "String delete(String, String[])", "filename": "CharSetUtils.delete.json"}
{"callee_method_names": ["String.isEmpty"], "method_name": "CharSetUtils.keep", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty() || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    return modify(str, set, true);\n}", "repo_id": "8", "comment": "/**\n * Takes an argument in set-syntax, see evaluateSet,\n * and keeps any of characters present in the specified string.\n *\n * <pre>\n * CharSetUtils.keep(null, *)        = null\n * CharSetUtils.keep(\"\", *)          = \"\"\n * CharSetUtils.keep(*, null)        = \"\"\n * CharSetUtils.keep(*, \"\")          = \"\"\n * CharSetUtils.keep(\"hello\", \"hl\")  = \"hll\"\n * CharSetUtils.keep(\"hello\", \"le\")  = \"ell\"\n * </pre>\n *\n * @see CharSet#getInstance(String...) for set-syntax.\n * @param str  String to keep characters from, may be null\n * @param set  String[] set of characters to keep, may be null\n * @return the modified String, {@code null} if null string input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 765, "method_signature": "String keep(String, String[])", "filename": "CharSetUtils.keep.json"}
{"callee_method_ids": [539], "callee_method_names": ["String.length", "String.toCharArray", "CharSet.contains", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CharSetUtils.modify", "method_implementation": "{\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    for (final char chr : chrs) {\n        if (chars.contains(chr) == expect) {\n            buffer.append(chr);\n        }\n    }\n    return buffer.toString();\n}", "repo_id": "8", "comment": "/**\n * Implementation of delete and keep\n *\n * @param str String to modify characters within\n * @param set String[] set of characters to modify\n * @param expect whether to evaluate on match, or non-match\n * @return the modified String, not null\n */\n", "repo_name": "commons-lang-master/", "id": 766, "method_signature": "String modify(String, String[], boolean)", "filename": "CharSetUtils.modify.json"}
{"callee_method_ids": [539], "callee_method_names": ["String.length", "String.toCharArray", "StringBuilder.append", "CharSet.contains", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CharSetUtils.squeeze", "method_implementation": "{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    char lastChar = chrs[0];\n    char ch;\n    Character inChars = null;\n    Character notInChars = null;\n    buffer.append(lastChar);\n    for (int i = 1; i < sz; i++) {\n        ch = chrs[i];\n        if (ch == lastChar) {\n            if (inChars != null && ch == inChars) {\n                continue;\n            }\n            if (notInChars == null || ch != notInChars) {\n                if (chars.contains(ch)) {\n                    inChars = ch;\n                    continue;\n                }\n                notInChars = ch;\n            }\n        }\n        buffer.append(ch);\n        lastChar = ch;\n    }\n    return buffer.toString();\n}", "repo_id": "8", "comment": "/**\n * Squeezes any repetitions of a character that is mentioned in the\n * supplied set.\n *\n * <pre>\n * CharSetUtils.squeeze(null, *)        = null\n * CharSetUtils.squeeze(\"\", *)          = \"\"\n * CharSetUtils.squeeze(*, null)        = *\n * CharSetUtils.squeeze(*, \"\")          = *\n * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n * </pre>\n *\n * @see CharSet#getInstance(String...) for set-syntax.\n * @param str  the string to squeeze, may be null\n * @param set  the character set to use for manipulation, may be null\n * @return the modified String, {@code null} if null string input\n */\n", "repo_name": "commons-lang-master/", "id": 767, "method_signature": "String squeeze(String, String[])", "filename": "CharSetUtils.squeeze.json"}
{"callee_method_names": [], "method_name": "CharUtils.toIntValue", "method_implementation": "{\n    if (!isAsciiNumeric(ch)) {\n        throw new IllegalArgumentException(\"The character \" + ch + \" is not in the range '0' - '9'\");\n    }\n    return ch - 48;\n}", "repo_id": "8", "comment": "/**\n * Converts the character to the Integer it represents, throwing an\n * exception if the character is not numeric.\n *\n * <p>This method converts the char '1' to the int 1 and so on.</p>\n *\n * <pre>\n *   CharUtils.toIntValue('3')  = 3\n *   CharUtils.toIntValue('A')  throws IllegalArgumentException\n * </pre>\n *\n * @param ch  the character to convert\n * @return the int value of the character\n * @throws IllegalArgumentException if the character is not ASCII numeric\n */\n", "repo_name": "commons-lang-master/", "id": 82, "method_signature": "int toIntValue(char)", "filename": "CharUtils.toIntValue.json"}
{"callee_method_names": [], "method_name": "CharUtils.toString", "method_implementation": "{\n    if (ch < CHAR_STRING_ARRAY.length) {\n        return CHAR_STRING_ARRAY[ch];\n    }\n    return String.valueOf(ch);\n}", "repo_id": "8", "comment": "/**\n * Converts the character to a String that contains the one character.\n *\n * <p>For ASCII 7 bit characters, this uses a cache that will return the\n * same String object each time.</p>\n *\n * <pre>\n *   CharUtils.toString(' ')  = \" \"\n *   CharUtils.toString('A')  = \"A\"\n * </pre>\n *\n * @param ch  the character to convert\n * @return a String containing the one specified character\n */\n", "repo_name": "commons-lang-master/", "id": 83, "method_signature": "String toString(char)", "filename": "CharUtils.toString.json"}
{"callee_method_names": [], "method_name": "CharUtils.unicodeEscaped", "method_implementation": "{\n    return \"\\\\u\" + HEX_DIGITS[(ch >> 12) & 15] + HEX_DIGITS[(ch >> 8) & 15] + HEX_DIGITS[(ch >> 4) & 15] + HEX_DIGITS[(ch) & 15];\n}", "repo_id": "8", "comment": "/**\n * Converts the string to the Unicode format '\\u0020'.\n *\n * <p>This format is the Java source code format.</p>\n *\n * <pre>\n *   CharUtils.unicodeEscaped(' ') = \"\\u0020\"\n *   CharUtils.unicodeEscaped('A') = \"\\u0041\"\n * </pre>\n *\n * @param ch  the character to convert\n * @return the escaped Unicode string\n */\n", "repo_name": "commons-lang-master/", "id": 84, "method_signature": "String unicodeEscaped(char)", "filename": "CharUtils.unicodeEscaped.json"}
{"callee_method_names": [], "method_name": "CharacterIterator.next", "method_implementation": "{\n    if (!hasNext) {\n        throw new NoSuchElementException();\n    }\n    final char cur = current;\n    prepareNext();\n    return Character.valueOf(cur);\n}", "repo_id": "8", "comment": "/**\n * Returns the next character in the iteration\n *\n * @return {@link Character} for the next character\n */\n", "repo_name": "commons-lang-master/", "id": 79, "method_signature": "Character next()", "filename": "CharacterIterator.next.json"}
{"callee_method_names": [], "method_name": "CharacterIterator.prepareNext", "method_implementation": "{\n    if (range.negated) {\n        if (current == Character.MAX_VALUE) {\n            hasNext = false;\n        } else if (current + 1 == range.start) {\n            if (range.end == Character.MAX_VALUE) {\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = (char) (current + 1);\n        }\n    } else if (current < range.end) {\n        current = (char) (current + 1);\n    } else {\n        hasNext = false;\n    }\n}", "repo_id": "8", "comment": "/**\n * Prepares the next character in the range.\n */\n", "repo_name": "commons-lang-master/", "id": 80, "method_signature": "void prepareNext()", "filename": "CharacterIterator.prepareNext.json"}
{"callee_method_names": ["ObjectStreamClass.getName", "HashMap.get"], "method_name": "ClassLoaderAwareObjectInputStream.resolveClass", "method_implementation": "{\n    final String name = desc.getName();\n    try {\n        return Class.forName(name, false, classLoader);\n    } catch (final ClassNotFoundException ex) {\n        try {\n            return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n        } catch (final ClassNotFoundException cnfe) {\n            final Class<?> cls = primitiveTypes.get(name);\n            if (cls != null) {\n                return cls;\n            }\n            throw cnfe;\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Overridden version that uses the parameterized {@link ClassLoader} or the {@link ClassLoader}\n * of the current {@link Thread} to resolve the class.\n * @param desc An instance of class {@link ObjectStreamClass}.\n * @return A {@link Class} object corresponding to {@code desc}.\n * @throws IOException Any of the usual Input/Output exceptions.\n * @throws ClassNotFoundException If class of a serialized object cannot be found.\n */\n", "repo_name": "commons-lang-master/", "id": 536, "method_signature": "Class<?> resolveClass(ObjectStreamClass)", "filename": "ClassLoaderAwareObjectInputStream.resolveClass.json"}
{"callee_method_names": [], "method_name": "ClassLoaderUtils.toString", "method_implementation": "{\n    if (classLoader instanceof URLClassLoader) {\n        return toString((URLClassLoader) classLoader);\n    }\n    return Objects.toString(classLoader);\n}", "repo_id": "8", "comment": "/**\n * Converts the given class loader to a String calling {@link #toString(URLClassLoader)}.\n *\n * @param classLoader to URLClassLoader to convert.\n * @return the formatted string.\n */\n", "repo_name": "commons-lang-master/", "id": 1139, "method_signature": "String toString(ClassLoader)", "filename": "ClassLoaderUtils.toString.json"}
{"callee_method_names": ["Package.getName"], "method_name": "ClassPathUtils.toFullyQualifiedName", "method_implementation": "{\n    Objects.requireNonNull(context, \"context\");\n    Objects.requireNonNull(resourceName, \"resourceName\");\n    return context.getName() + \".\" + resourceName;\n}", "repo_id": "8", "comment": "/**\n * Returns the fully qualified name for the resource with name {@code resourceName} relative to the given context.\n *\n * <p>\n * Note that this method does not check whether the resource actually exists. It only constructs the name. Null inputs are not allowed.\n * </p>\n *\n * <pre>\n * ClassPathUtils.toFullyQualifiedName(StringUtils.class.getPackage(), \"StringUtils.properties\") = \"org.apache.commons.lang3.StringUtils.properties\"\n * </pre>\n *\n * @param context      The context for constructing the name.\n * @param resourceName the resource name to construct the fully qualified name for.\n * @return the fully qualified name of the resource with name {@code resourceName}.\n * @throws NullPointerException if either {@code context} or {@code resourceName} is null.\n */\n", "repo_name": "commons-lang-master/", "id": 733, "method_signature": "String toFullyQualifiedName(Package, String)", "filename": "ClassPathUtils.toFullyQualifiedName.json"}
{"callee_method_names": ["Package.getName"], "method_name": "ClassPathUtils.toFullyQualifiedPath", "method_implementation": "{\n    Objects.requireNonNull(context, \"context\");\n    Objects.requireNonNull(resourceName, \"resourceName\");\n    return packageToPath(context.getName()) + \"/\" + resourceName;\n}", "repo_id": "8", "comment": "/**\n * Returns the fully qualified path for the resource with name {@code resourceName} relative to the given context.\n *\n * <p>\n * Note that this method does not check whether the resource actually exists. It only constructs the path. Null inputs are not allowed.\n * </p>\n *\n * <pre>\n * ClassPathUtils.toFullyQualifiedPath(StringUtils.class.getPackage(), \"StringUtils.properties\") = \"org/apache/commons/lang3/StringUtils.properties\"\n * </pre>\n *\n * @param context      The context for constructing the path.\n * @param resourceName the resource name to construct the fully qualified path for.\n * @return the fully qualified path of the resource with name {@code resourceName}.\n * @throws NullPointerException if either {@code context} or {@code resourceName} is null.\n */\n", "repo_name": "commons-lang-master/", "id": 735, "method_signature": "String toFullyQualifiedPath(Package, String)", "filename": "ClassPathUtils.toFullyQualifiedPath.json"}
{"callee_method_names": ["List<String>.size", "List<String>.forEach", "List<Class<?>>.add", "List<Class<?>>.add"], "method_name": "ClassUtils.convertClassNamesToClasses", "method_implementation": "{\n    if (classNames == null) {\n        return null;\n    }\n    final List<Class<?>> classes = new ArrayList<>(classNames.size());\n    classNames.forEach(className -> {\n        try {\n            classes.add(Class.forName(className));\n        } catch (final Exception ex) {\n            classes.add(null);\n        }\n    });\n    return classes;\n}", "repo_id": "8", "comment": "/**\n * Given a {@link List} of class names, this method converts them into classes.\n *\n * <p>\n * A new {@link List} is returned. If the class name cannot be found, {@code null} is stored in the {@link List}. If the\n * class name in the {@link List} is {@code null}, {@code null} is stored in the output {@link List}.\n * </p>\n *\n * @param classNames the classNames to change\n * @return a {@link List} of Class objects corresponding to the class names, {@code null} if null input\n * @throws ClassCastException if classNames contains a non String entry\n */\n", "repo_name": "commons-lang-master/", "id": 1335, "method_signature": "List<Class<?>> convertClassNamesToClasses(List)", "filename": "ClassUtils.convertClassNamesToClasses.json"}
{"callee_method_names": ["String.length", "String.toCharArray"], "method_name": "ClassUtils.getAbbreviatedName", "method_implementation": "{\n    if (lengthHint <= 0) {\n        throw new IllegalArgumentException(\"len must be > 0\");\n    }\n    if (className == null) {\n        return StringUtils.EMPTY;\n    }\n    if (className.length() <= lengthHint) {\n        return className;\n    }\n    final char[] abbreviated = className.toCharArray();\n    int target = 0;\n    int source = 0;\n    while (source < abbreviated.length) {\n        // copy the next part\n        int runAheadTarget = target;\n        while (source < abbreviated.length && abbreviated[source] != '.') {\n            abbreviated[runAheadTarget++] = abbreviated[source++];\n        }\n        ++target;\n        if (useFull(runAheadTarget, source, abbreviated.length, lengthHint) || target > runAheadTarget) {\n            target = runAheadTarget;\n        }\n        // copy the '.' unless it was the last part\n        if (source < abbreviated.length) {\n            abbreviated[target++] = abbreviated[source++];\n        }\n    }\n    return new String(abbreviated, 0, target);\n}", "repo_id": "8", "comment": "/**\n * Gets the abbreviated class name from a {@link String}.\n *\n * <p>\n * The string passed in is assumed to be a class name - it is not checked.\n * </p>\n *\n * <p>\n * The abbreviation algorithm will shorten the class name, usually without significant loss of meaning.\n * </p>\n *\n * <p>\n * The abbreviated class name will always include the complete package hierarchy. If enough space is available,\n * rightmost sub-packages will be displayed in full length. The abbreviated package names will be shortened to a single\n * character.\n * </p>\n * <p>\n * Only package names are shortened, the class simple name remains untouched. (See examples.)\n * </p>\n * <p>\n * The result will be longer than the desired length only if all the package names shortened to a single character plus\n * the class simple name with the separating dots together are longer than the desired length. In other words, when the\n * class name cannot be shortened to the desired length.\n * </p>\n * <p>\n * If the class name can be shortened then the final length will be at most {@code lengthHint} characters.\n * </p>\n * <p>\n * If the {@code lengthHint} is zero or negative then the method throws exception. If you want to achieve the shortest\n * possible version then use {@code 1} as a {@code lengthHint}.\n * </p>\n *\n * <table>\n * <caption>Examples</caption>\n * <tr>\n * <td>className</td>\n * <td>len</td>\n * <td>return</td>\n * </tr>\n * <tr>\n * <td>null</td>\n * <td>1</td>\n * <td>\"\"</td>\n * </tr>\n * <tr>\n * <td>\"java.lang.String\"</td>\n * <td>5</td>\n * <td>\"j.l.String\"</td>\n * </tr>\n * <tr>\n * <td>\"java.lang.String\"</td>\n * <td>15</td>\n * <td>\"j.lang.String\"</td>\n * </tr>\n * <tr>\n * <td>\"java.lang.String\"</td>\n * <td>30</td>\n * <td>\"java.lang.String\"</td>\n * </tr>\n * <tr>\n * <td>\"org.apache.commons.lang3.ClassUtils\"</td>\n * <td>18</td>\n * <td>\"o.a.c.l.ClassUtils\"</td>\n * </tr>\n * </table>\n *\n * @param className the className to get the abbreviated name for, may be {@code null}\n * @param lengthHint the desired length of the abbreviated name\n * @return the abbreviated name or an empty string if the specified class name is {@code null} or empty string. The\n *         abbreviated name may be longer than the desired length if it cannot be abbreviated to the desired length.\n * @throws IllegalArgumentException if {@code len <= 0}\n * @since 3.4\n */\n", "repo_name": "commons-lang-master/", "id": 1337, "method_signature": "String getAbbreviatedName(String, int)", "filename": "ClassUtils.getAbbreviatedName.json"}
{"callee_method_names": ["Class<?>.getInterfaces", "HashSet<Class<?>>.add", "Class<?>.getSuperclass"], "method_name": "ClassUtils.getAllInterfaces", "method_implementation": "{\n    while (cls != null) {\n        final Class<?>[] interfaces = cls.getInterfaces();\n        for (final Class<?> i : interfaces) {\n            if (interfacesFound.add(i)) {\n                getAllInterfaces(i, interfacesFound);\n            }\n        }\n        cls = cls.getSuperclass();\n    }\n}", "repo_id": "8", "comment": "/**\n * Gets the interfaces for the specified class.\n *\n * @param cls the class to look up, may be {@code null}\n * @param interfacesFound the {@link Set} of interfaces for the class\n */\n", "repo_name": "commons-lang-master/", "id": 1339, "method_signature": "void getAllInterfaces(Class, HashSet)", "filename": "ClassUtils.getAllInterfaces.json"}
{"callee_method_names": ["Class<?>.getSuperclass", "List<Class<?>>.add", "Class<?>.getSuperclass"], "method_name": "ClassUtils.getAllSuperclasses", "method_implementation": "{\n    if (cls == null) {\n        return null;\n    }\n    final List<Class<?>> classes = new ArrayList<>();\n    Class<?> superclass = cls.getSuperclass();\n    while (superclass != null) {\n        classes.add(superclass);\n        superclass = superclass.getSuperclass();\n    }\n    return classes;\n}", "repo_id": "8", "comment": "/**\n * Gets a {@link List} of superclasses for the given class.\n *\n * @param cls the class to look up, may be {@code null}\n * @return the {@link List} of superclasses in order going up from this one {@code null} if null input\n */\n", "repo_name": "commons-lang-master/", "id": 1340, "method_signature": "List<Class<?>> getAllSuperclasses(Class)", "filename": "ClassUtils.getAllSuperclasses.json"}
{"callee_method_names": ["String.startsWith", "String.substring", "String.startsWith", "String.substring", "String.endsWith", "String.length", "String.length", "String.isEmpty", "Map<String, String>.get", "String.substring", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ClassUtils.getCanonicalName", "method_implementation": "{\n    className = StringUtils.deleteWhitespace(className);\n    if (className == null) {\n        return null;\n    }\n    int dim = 0;\n    while (className.startsWith(\"[\")) {\n        dim++;\n        className = className.substring(1);\n    }\n    if (dim < 1) {\n        return className;\n    }\n    if (className.startsWith(\"L\")) {\n        className = className.substring(1, className.endsWith(\";\") ? className.length() - 1 : className.length());\n    } else if (!className.isEmpty()) {\n        className = reverseAbbreviationMap.get(className.substring(0, 1));\n    }\n    final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n    for (int i = 0; i < dim; i++) {\n        canonicalClassNameBuffer.append(\"[]\");\n    }\n    return canonicalClassNameBuffer.toString();\n}", "repo_id": "8", "comment": "/**\n * Converts a given name of class into canonical format. If name of class is not a name of array class it returns\n * unchanged name.\n *\n * <p>\n * The method does not change the {@code $} separators in case the class is inner class.\n * </p>\n *\n * <p>\n * Example:\n * <ul>\n * <li>{@code getCanonicalName(\"[I\") = \"int[]\"}</li>\n * <li>{@code getCanonicalName(\"[Ljava.lang.String;\") = \"java.lang.String[]\"}</li>\n * <li>{@code getCanonicalName(\"java.lang.String\") = \"java.lang.String\"}</li>\n * </ul>\n * </p>\n *\n * @param className the name of class\n * @return canonical form of class name\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1343, "method_signature": "String getCanonicalName(String)", "filename": "ClassUtils.getCanonicalName.json"}
{"callee_method_names": [], "method_name": "ClassUtils.getClass", "method_implementation": "{\n    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n    return getClass(loader, className, initialize);\n}", "repo_id": "8", "comment": "/**\n * Returns the class represented by {@code className} using the current thread's context class loader. This\n * implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n *\n * @param className the class name\n * @param initialize whether the class must be initialized\n * @return the class represented by {@code className} using the current thread's context class loader\n * @throws NullPointerException if the className is null\n * @throws ClassNotFoundException if the class is not found\n */\n", "repo_name": "commons-lang-master/", "id": 1345, "method_signature": "Class<?> getClass(String, boolean)", "filename": "ClassUtils.getClass.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "ClassUtils.getPackageCanonicalName", "method_implementation": "{\n    if (object == null) {\n        return valueIfNull;\n    }\n    return getPackageCanonicalName(object.getClass().getName());\n}", "repo_id": "8", "comment": "/**\n * Gets the package name from the class name of an {@link Object}.\n *\n * @param object the class to get the package name for, may be null\n * @param valueIfNull the value to return if null\n * @return the package name of the object, or the null value\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1347, "method_signature": "String getPackageCanonicalName(Object, String)", "filename": "ClassUtils.getPackageCanonicalName.json"}
{"callee_method_names": ["String.charAt", "String.substring", "String.charAt", "String.charAt", "String.length", "String.substring", "String.lastIndexOf", "String.substring"], "method_name": "ClassUtils.getPackageName", "method_implementation": "{\n    if (StringUtils.isEmpty(className)) {\n        return StringUtils.EMPTY;\n    }\n    // Strip array encoding\n    while (className.charAt(0) == '[') {\n        className = className.substring(1);\n    }\n    // Strip Object type encoding\n    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n        className = className.substring(1);\n    }\n    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n    if (i == -1) {\n        return StringUtils.EMPTY;\n    }\n    return className.substring(0, i);\n}", "repo_id": "8", "comment": "/**\n * Gets the package name from a {@link String}.\n *\n * <p>\n * The string passed in is assumed to be a class name - it is not checked.\n * </p>\n * <p>\n * If the class is unpackaged, return an empty string.\n * </p>\n *\n * @param className the className to get the package name for, may be {@code null}\n * @return the package name or an empty string\n */\n", "repo_name": "commons-lang-master/", "id": 1350, "method_signature": "String getPackageName(String)", "filename": "ClassUtils.getPackageName.json"}
{"callee_method_names": ["Class<?>.getMethod", "Method.getDeclaringClass", "List<Class<?>>.addAll", "Method.getDeclaringClass"], "method_name": "ClassUtils.getPublicMethod", "method_implementation": "{\n    final Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n    if (isPublic(declaredMethod.getDeclaringClass())) {\n        return declaredMethod;\n    }\n    final List<Class<?>> candidateClasses = new ArrayList<>(getAllInterfaces(cls));\n    candidateClasses.addAll(getAllSuperclasses(cls));\n    for (final Class<?> candidateClass : candidateClasses) {\n        if (!isPublic(candidateClass)) {\n            continue;\n        }\n        final Method candidateMethod;\n        try {\n            candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n        } catch (final NoSuchMethodException ex) {\n            continue;\n        }\n        if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n            return candidateMethod;\n        }\n    }\n    throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes));\n}", "repo_id": "8", "comment": "/**\n * Returns the desired Method much like {@code Class.getMethod}, however it ensures that the returned Method is from a\n * public class or interface and not from an anonymous inner class. This means that the Method is invokable and doesn't\n * fall foul of Java bug <a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n *\n * <pre>\n *  <code>Set set = Collections.unmodifiableSet(...);\n *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n *  Object result = method.invoke(set, new Object[]);</code>\n * </pre>\n *\n * @param cls the class to check, not null\n * @param methodName the name of the method\n * @param parameterTypes the list of parameters\n * @return the method\n * @throws NullPointerException if the class is null\n * @throws SecurityException if a security violation occurred\n * @throws NoSuchMethodException if the method is not found in the given class or if the method doesn't conform with the\n *         requirements\n */\n", "repo_name": "commons-lang-master/", "id": 1351, "method_signature": "Method getPublicMethod(Class, String, Class<?>[])", "filename": "ClassUtils.getPublicMethod.json"}
{"callee_method_names": ["String.startsWith", "String.charAt", "String.substring", "StringBuilder.append", "String.charAt", "String.charAt", "String.length", "String.substring", "String.length", "Map<String, String>.containsKey", "Map<String, String>.get", "String.lastIndexOf", "String.indexOf", "String.substring", "String.replace"], "method_name": "ClassUtils.getShortClassName", "method_implementation": "{\n    if (StringUtils.isEmpty(className)) {\n        return StringUtils.EMPTY;\n    }\n    final StringBuilder arrayPrefix = new StringBuilder();\n    // Handle array encoding\n    if (className.startsWith(\"[\")) {\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n            arrayPrefix.append(\"[]\");\n        }\n        // Strip Object type encoding\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1, className.length() - 1);\n        }\n        if (reverseAbbreviationMap.containsKey(className)) {\n            className = reverseAbbreviationMap.get(className);\n        }\n    }\n    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n    String out = className.substring(lastDotIdx + 1);\n    if (innerIdx != -1) {\n        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n    }\n    return out + arrayPrefix;\n}", "repo_id": "8", "comment": "/**\n * Gets the class name minus the package name from a String.\n *\n * <p>\n * The string passed in is assumed to be a class name - it is not checked. The string has to be formatted the way as the\n * JDK method {@code Class.getName()} returns it, and not the usual way as we write it, for example in import\n * statements, or as it is formatted by {@code Class.getCanonicalName()}.\n * </p>\n *\n * <p>\n * The difference is is significant only in case of classes that are inner classes of some other classes. In this case\n * the separator between the outer and inner class (possibly on multiple hierarchy level) has to be {@code $} (dollar\n * sign) and not {@code .} (dot), as it is returned by {@code Class.getName()}\n * </p>\n *\n * <p>\n * Note that this method is called from the {@link #getShortClassName(Class)} method using the string returned by\n * {@code Class.getName()}.\n * </p>\n *\n * <p>\n * Note that this method differs from {@link #getSimpleName(Class)} in that this will return, for example\n * {@code \"Map.Entry\"} whilst the {@link Class} variant will simply return {@code \"Entry\"}. In this example\n * the argument {@code className} is the string {@code java.util.Map$Entry} (note the {@code $} sign.\n * </p>\n *\n * @param className the className to get the short name for. It has to be formatted as returned by\n *        {@code Class.getName()} and not {@code Class.getCanonicalName()}\n * @return the class name of the class without the package name or an empty string. If the class is an inner class then\n *         value contains the outer class or classes and the separator is replaced to be {@code .} (dot) character.\n */\n", "repo_name": "commons-lang-master/", "id": 1354, "method_signature": "String getShortClassName(String)", "filename": "ClassUtils.getShortClassName.json"}
{"callee_method_names": ["MutableObject<Class<?>>.getValue", "MutableObject<Class<?>>.getValue", "MutableObject<Class<?>>.setValue", "Class<?>.getSuperclass", "Iterable<Class<?>>.iterator", "Class<?>[].hasNext", "Iterator<Class<?>>.hasNext", "Class<?>[].hasNext", "Class<?>[].next", "Set<Class<?>>.add", "Iterator<Class<?>>.next", "Set<Class<?>>.iterator", "char[].getInterfaces", "Set<Class<?>>.contains"], "method_name": "ClassUtils.hierarchy", "method_implementation": "{\n    final Iterable<Class<?>> classes = () -> {\n        final MutableObject<Class<?>> next = new MutableObject<>(type);\n        return new Iterator<Class<?>>() {\n\n            @Override\n            public boolean hasNext() {\n                return next.getValue() != null;\n            }\n\n            @Override\n            public Class<?> next() {\n                final Class<?> result = next.getValue();\n                next.setValue(result.getSuperclass());\n                return result;\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    };\n    if (interfacesBehavior != Interfaces.INCLUDE) {\n        return classes;\n    }\n    return () -> {\n        final Set<Class<?>> seenInterfaces = new HashSet<>();\n        final Iterator<Class<?>> wrapped = classes.iterator();\n        return new Iterator<Class<?>>() {\n\n            Iterator<Class<?>> interfaces = Collections.emptyIterator();\n\n            @Override\n            public boolean hasNext() {\n                return interfaces.hasNext() || wrapped.hasNext();\n            }\n\n            @Override\n            public Class<?> next() {\n                if (interfaces.hasNext()) {\n                    final Class<?> nextInterface = interfaces.next();\n                    seenInterfaces.add(nextInterface);\n                    return nextInterface;\n                }\n                final Class<?> nextSuperclass = wrapped.next();\n                final Set<Class<?>> currentInterfaces = new LinkedHashSet<>();\n                walkInterfaces(currentInterfaces, nextSuperclass);\n                interfaces = currentInterfaces.iterator();\n                return nextSuperclass;\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n\n            private void walkInterfaces(final Set<Class<?>> addTo, final Class<?> c) {\n                for (final Class<?> iface : c.getInterfaces()) {\n                    if (!seenInterfaces.contains(iface)) {\n                        addTo.add(iface);\n                    }\n                    walkInterfaces(addTo, iface);\n                }\n            }\n        };\n    };\n}", "repo_id": "8", "comment": "/**\n * Gets an {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order.\n *\n * @param type the type to get the class hierarchy from\n * @param interfacesBehavior switch indicating whether to include or exclude interfaces\n * @return Iterable an Iterable over the class hierarchy of the given class\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 1355, "method_signature": "Iterable<Class<?>> hierarchy(Class, Interfaces)", "filename": "ClassUtils.hierarchy.json"}
{"callee_method_names": [], "method_name": "ClassUtils.isAssignable", "method_implementation": "{\n    if (!ArrayUtils.isSameLength(classArray, toClassArray)) {\n        return false;\n    }\n    if (classArray == null) {\n        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    if (toClassArray == null) {\n        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    for (int i = 0; i < classArray.length; i++) {\n        if (!isAssignable(classArray[i], toClassArray[i], autoboxing)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if an array of Classes can be assigned to another array of Classes.\n *\n * <p>\n * This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It can be\n * used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter\n * types (the second parameter).\n * </p>\n *\n * <p>\n * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n * primitive classes and {@code null}s.\n * </p>\n *\n * <p>\n * Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code double}. This method\n * returns the correct result for these cases.\n * </p>\n *\n * <p>\n * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n * and the toClass is non-primitive.\n * </p>\n *\n * <p>\n * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n * </p>\n *\n * @param classArray the array of Classes to check, may be {@code null}\n * @param toClassArray the array of Classes to try to assign into, may be {@code null}\n * @param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n * @return {@code true} if assignment possible\n */\n", "repo_name": "commons-lang-master/", "id": 1357, "method_signature": "boolean isAssignable(Class<?>[], Class<?>[], boolean)", "filename": "ClassUtils.isAssignable.json"}
{"callee_method_names": ["Class<?>.isPrimitive"], "method_name": "ClassUtils.isPrimitiveOrWrapper", "method_implementation": "{\n    if (type == null) {\n        return false;\n    }\n    return type.isPrimitive() || isPrimitiveWrapper(type);\n}", "repo_id": "8", "comment": "/**\n * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n * {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n *\n * @param type The class to query or null.\n * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n *         {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n * @since 3.1\n */\n", "repo_name": "commons-lang-master/", "id": 1358, "method_signature": "boolean isPrimitiveOrWrapper(Class)", "filename": "ClassUtils.isPrimitiveOrWrapper.json"}
{"callee_method_names": ["Class<?>.isPrimitive", "HashMap.get"], "method_name": "ClassUtils.primitiveToWrapper", "method_implementation": "{\n    Class<?> convertedClass = cls;\n    if (cls != null && cls.isPrimitive()) {\n        convertedClass = primitiveWrapperMap.get(cls);\n    }\n    return convertedClass;\n}", "repo_id": "8", "comment": "/**\n * Converts the specified primitive Class object to its corresponding wrapper Class object.\n *\n * <p>\n * NOTE: From v2.2, this method handles {@code Void.TYPE}, returning {@code Void.TYPE}.\n * </p>\n *\n * @param cls the class to convert, may be null\n * @return the wrapper class for {@code cls} or {@code cls} if {@code cls} is not a primitive. {@code null} if null\n *         input.\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 1360, "method_signature": "Class<?> primitiveToWrapper(Class)", "filename": "ClassUtils.primitiveToWrapper.json"}
{"callee_method_names": [], "method_name": "ClassUtils.primitivesToWrappers", "method_implementation": "{\n    if (classes == null) {\n        return null;\n    }\n    if (classes.length == 0) {\n        return classes;\n    }\n    final Class<?>[] convertedClasses = new Class[classes.length];\n    Arrays.setAll(convertedClasses, i -> primitiveToWrapper(classes[i]));\n    return convertedClasses;\n}", "repo_id": "8", "comment": "/**\n * Converts the specified array of primitive Class objects to an array of its corresponding wrapper Class objects.\n *\n * @param classes the class array to convert, may be null or empty\n * @return an array which contains for each given class, the wrapper class or the original class if class is not a\n *         primitive. {@code null} if null input. Empty array if an empty array passed in.\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 1359, "method_signature": "Class<?>[] primitivesToWrappers(Class<?>[])", "filename": "ClassUtils.primitivesToWrappers.json"}
{"callee_method_names": ["String.endsWith", "String.endsWith", "String.substring", "String.length", "StringBuilder.append", "Map<String, String>.get", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ClassUtils.toCanonicalName", "method_implementation": "{\n    String canonicalName = StringUtils.deleteWhitespace(className);\n    Objects.requireNonNull(canonicalName, \"className\");\n    if (canonicalName.endsWith(\"[]\")) {\n        final StringBuilder classNameBuffer = new StringBuilder();\n        while (canonicalName.endsWith(\"[]\")) {\n            canonicalName = canonicalName.substring(0, canonicalName.length() - 2);\n            classNameBuffer.append(\"[\");\n        }\n        final String abbreviation = abbreviationMap.get(canonicalName);\n        if (abbreviation != null) {\n            classNameBuffer.append(abbreviation);\n        } else {\n            classNameBuffer.append(\"L\").append(canonicalName).append(\";\");\n        }\n        canonicalName = classNameBuffer.toString();\n    }\n    return canonicalName;\n}", "repo_id": "8", "comment": "/**\n * Converts a class name to a JLS style class name.\n *\n * @param className the class name\n * @return the converted name\n * @throws NullPointerException if the className is null\n */\n", "repo_name": "commons-lang-master/", "id": 1361, "method_signature": "String toCanonicalName(String)", "filename": "ClassUtils.toCanonicalName.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "ClassUtils.toClass", "method_implementation": "{\n    if (array == null) {\n        return null;\n    }\n    if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    final Class<?>[] classes = new Class[array.length];\n    Arrays.setAll(classes, i -> array[i] == null ? null : array[i].getClass());\n    return classes;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of {@link Object} in to an array of {@link Class} objects. If any of these objects is null, a null\n * element will be inserted into the array.\n *\n * <p>\n * This method returns {@code null} for a {@code null} input array.\n * </p>\n *\n * @param array an {@link Object} array\n * @return a {@link Class} array, {@code null} if null array input\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1362, "method_signature": "Class<?>[] toClass(Object[])", "filename": "ClassUtils.toClass.json"}
{"callee_method_names": [], "method_name": "ClassUtils.wrappersToPrimitives", "method_implementation": "{\n    if (classes == null) {\n        return null;\n    }\n    if (classes.length == 0) {\n        return classes;\n    }\n    final Class<?>[] convertedClasses = new Class[classes.length];\n    Arrays.setAll(convertedClasses, i -> wrapperToPrimitive(classes[i]));\n    return convertedClasses;\n}", "repo_id": "8", "comment": "/**\n * Converts the specified array of wrapper Class objects to an array of its corresponding primitive Class objects.\n *\n * <p>\n * This method invokes {@code wrapperToPrimitive()} for each element of the passed in array.\n * </p>\n *\n * @param classes the class array to convert, may be null or empty\n * @return an array which contains for each given class, the primitive class or <b>null</b> if the original class is not\n *         a wrapper class. {@code null} if null input. Empty array if an empty array passed in.\n * @see #wrapperToPrimitive(Class)\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1363, "method_signature": "Class<?>[] wrappersToPrimitives(Class<?>[])", "filename": "ClassUtils.wrappersToPrimitives.json"}
{"callee_method_names": ["Set<?>.getClass", "Method.invoke"], "method_name": "ClassUtilsTest.testShowJavaBug", "method_implementation": "{\n    // Tests with Collections$UnmodifiableSet\n    final Set<?> set = Collections.unmodifiableSet(new HashSet<>());\n    final Method isEmptyMethod = set.getClass().getMethod(\"isEmpty\");\n    assertThrows(IllegalAccessException.class, () -> isEmptyMethod.invoke(set));\n}", "repo_id": "8", "comment": "// We may have to delete this if a JDK fixes the bug.\n", "repo_name": "commons-lang-master/", "id": 1670, "method_signature": "void testShowJavaBug()", "filename": "ClassUtilsTest.testShowJavaBug.json"}
{"callee_method_names": ["String.length", "String.length"], "method_name": "ClassUtilsTest.test_getAbbreviatedName_TooLongHint", "method_implementation": "{\n    final String className = \"java.lang.String\";\n    Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length() + 1));\n    Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length()));\n}", "repo_id": "8", "comment": "/**\n * Test that in case the required length is larger than the name and thus there is no need for any shortening then the\n * returned string object is the same as the one passed as argument. Note, however, that this is tested as an internal\n * implementation detail, but it is not a guaranteed feature of the implementation.\n */\n", "repo_name": "commons-lang-master/", "id": 1669, "method_signature": "void test_getAbbreviatedName_TooLongHint()", "filename": "ClassUtilsTest.test_getAbbreviatedName_TooLongHint.json"}
{"callee_method_names": [], "method_name": "CodePointTranslator.translate", "method_implementation": "{\n    final int codePoint = Character.codePointAt(input, index);\n    final boolean consumed = translate(codePoint, out);\n    return consumed ? 1 : 0;\n}", "repo_id": "8", "comment": "/**\n * Implementation of translate that maps onto the abstract translate(int, Writer) method.\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 429, "method_signature": "int translate(CharSequence, int, Writer)", "filename": "CodePointTranslator.translate.json"}
{"callee_method_names": [], "method_name": "CompareToBuilder.append", "method_implementation": "{\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code builder} the deep comparison of\n * two {@code short} arrays.\n *\n * <ol>\n *  <li>Check if arrays are the same using {@code ==}</li>\n *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n *  <li>Check array length, a shorter length array is less than a longer length array</li>\n *  <li>Check array contents element by element using {@link #append(short, short)}</li>\n * </ol>\n *\n * @param lhs  left-hand side array\n * @param rhs  right-hand side array\n * @return this\n */\n", "repo_name": "commons-lang-master/", "id": 883, "method_signature": "CompareToBuilder append(short[], short[])", "filename": "CompareToBuilder.append.json"}
{"callee_method_names": [], "method_name": "CompareToBuilder.appendSuper", "method_implementation": "{\n    if (comparison != 0) {\n        return this;\n    }\n    comparison = superCompareTo;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code builder} the {@code compareTo(Object)}\n * result of the superclass.\n *\n * @param superCompareTo  result of calling {@code super.compareTo(Object)}\n * @return this\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 884, "method_signature": "CompareToBuilder appendSuper(int)", "filename": "CompareToBuilder.appendSuper.json"}
{"callee_method_ids": [883], "callee_method_names": ["Class<?>.getDeclaredFields", "Field.getName", "Field.getName", "Field.getModifiers", "Field.getModifiers", "CompareToBuilder.append"], "method_name": "CompareToBuilder.reflectionAppend", "method_implementation": "{\n    final Field[] fields = clazz.getDeclaredFields();\n    AccessibleObject.setAccessible(fields, true);\n    for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n        final Field field = fields[i];\n        if (!ArrayUtils.contains(excludeFields, field.getName()) && !field.getName().contains(\"$\") && (useTransients || !Modifier.isTransient(field.getModifiers())) && !Modifier.isStatic(field.getModifiers())) {\n            // IllegalAccessException can't happen. Would get a Security exception instead.\n            // Throw a runtime exception in case the impossible happens.\n            builder.append(Reflection.getUnchecked(field, lhs), Reflection.getUnchecked(field, rhs));\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends to {@code builder} the comparison of {@code lhs}\n * to {@code rhs} using the fields defined in {@code clazz}.\n *\n * @param lhs  left-hand side object\n * @param rhs  right-hand side object\n * @param clazz  {@link Class} that defines fields to be compared\n * @param builder  {@link CompareToBuilder} to append to\n * @param useTransients  whether to compare transient fields\n * @param excludeFields  fields to exclude\n */\n", "repo_name": "commons-lang-master/", "id": 864, "method_signature": "void reflectionAppend(Object, Object, Class, CompareToBuilder, boolean, String[])", "filename": "CompareToBuilder.reflectionAppend.json"}
{"callee_method_names": ["Object.getClass", "Class<?>.isInstance", "Class<?>.getSuperclass", "Class<?>.getSuperclass", "CompareToBuilder.toComparison"], "method_name": "CompareToBuilder.reflectionCompare", "method_implementation": "{\n    if (lhs == rhs) {\n        return 0;\n    }\n    Objects.requireNonNull(lhs, \"lhs\");\n    Objects.requireNonNull(rhs, \"rhs\");\n    Class<?> lhsClazz = lhs.getClass();\n    if (!lhsClazz.isInstance(rhs)) {\n        throw new ClassCastException();\n    }\n    final CompareToBuilder compareToBuilder = new CompareToBuilder();\n    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n        lhsClazz = lhsClazz.getSuperclass();\n        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n    }\n    return compareToBuilder.toComparison();\n}", "repo_id": "8", "comment": "/**\n * Compares two {@link Object}s via reflection.\n *\n * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n * is used to bypass normal access control checks. This will fail under a\n * security manager unless the appropriate permissions are set.</p>\n *\n * <ul>\n * <li>Static fields will not be compared</li>\n * <li>If the {@code compareTransients} is {@code true},\n *     compares transient members.  Otherwise ignores them, as they\n *     are likely derived fields.</li>\n * <li>Compares superclass fields up to and including {@code reflectUpToClass}.\n *     If {@code reflectUpToClass} is {@code null}, compares all superclass fields.</li>\n * </ul>\n *\n * <p>If both {@code lhs} and {@code rhs} are {@code null},\n * they are considered equal.</p>\n *\n * @param lhs  left-hand side object\n * @param rhs  right-hand side object\n * @param compareTransients  whether to compare transient fields\n * @param reflectUpToClass  last superclass for which fields are compared\n * @param excludeFields  fields to exclude\n * @return a negative integer, zero, or a positive integer as {@code lhs}\n *  is less than, equal to, or greater than {@code rhs}\n * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n *  (but not both) is {@code null}\n * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n *  with {@code lhs}\n * @since 2.2 (2.0 as {@code reflectionCompare(Object, Object, boolean, Class)})\n */\n", "repo_name": "commons-lang-master/", "id": 865, "method_signature": "int reflectionCompare(Object, Object, boolean, Class, String[])", "filename": "CompareToBuilder.reflectionCompare.json"}
{"callee_method_names": [], "method_name": "CompareToBuilderTest.assertReflectionCompareContract", "method_implementation": "{\n    // signum\n    assertEquals(reflectionCompareSignum(x, y, testTransients, excludeFields), -reflectionCompareSignum(y, x, testTransients, excludeFields));\n    // transitive\n    if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) > 0 && CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields) > 0) {\n        assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields) > 0);\n    }\n    // un-named\n    if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) == 0) {\n        assertEquals(reflectionCompareSignum(x, z, testTransients, excludeFields), -reflectionCompareSignum(y, z, testTransients, excludeFields));\n    }\n    // strongly recommended but not strictly required\n    assertTrue(CompareToBuilder.reflectionCompare(x, y, testTransients) == 0 == EqualsBuilder.reflectionEquals(x, y, testTransients));\n}", "repo_id": "8", "comment": "/**\n * See \"Effective Java\" under \"Consider Implementing Comparable\".\n *\n * @param x an object to compare\n * @param y an object to compare\n * @param z an object to compare\n * @param testTransients Whether to include transients in the comparison\n * @param excludeFields fields to exclude\n */\n", "repo_name": "commons-lang-master/", "id": 1993, "method_signature": "void assertReflectionCompareContract(Object, Object, Object, boolean, String[])", "filename": "CompareToBuilderTest.assertReflectionCompareContract.json"}
{"callee_method_names": ["Format.format"], "method_name": "CompositeFormat.format", "method_implementation": "{\n    return formatter.format(obj, toAppendTo, pos);\n}", "repo_id": "8", "comment": "/**\n * Uses the formatter Format instance.\n *\n * @param obj the object to format\n * @param toAppendTo the {@link StringBuffer} to append to\n * @param pos the FieldPosition to use (or ignore).\n * @return {@code toAppendTo}\n * @see Format#format(Object, StringBuffer, FieldPosition)\n */\n", "repo_name": "commons-lang-master/", "id": 370, "method_signature": "StringBuffer format(Object, StringBuffer, FieldPosition)", "filename": "CompositeFormat.format.json"}
{"callee_method_ids": [370], "callee_method_names": ["CompositeFormat.parseObject", "CompositeFormat.format", "CompositeFormat.getParser", "CompositeFormat.getFormatter"], "method_name": "CompositeFormatTest.testCompositeFormat", "method_implementation": "{\n    final Format parser = new Format() {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n            throw new UnsupportedOperationException(\"Not implemented\");\n        }\n\n        @Override\n        public Object parseObject(final String source, final ParsePosition pos) {\n            // do nothing\n            return null;\n        }\n    };\n    final Format formatter = new Format() {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n            // do nothing\n            return null;\n        }\n\n        @Override\n        public Object parseObject(final String source, final ParsePosition pos) {\n            throw new UnsupportedOperationException(\"Not implemented\");\n        }\n    };\n    final CompositeFormat composite = new CompositeFormat(parser, formatter);\n    composite.parseObject(\"\", null);\n    composite.format(new Object(), new StringBuffer(), null);\n    assertEquals(parser, composite.getParser(), \"Parser get method incorrectly implemented\");\n    assertEquals(formatter, composite.getFormatter(), \"Formatter get method incorrectly implemented\");\n}", "repo_id": "8", "comment": "/**\n * Ensures that the parse/format separation is correctly maintained.\n */\n", "repo_name": "commons-lang-master/", "id": 1702, "method_signature": "void testCompositeFormat()", "filename": "CompositeFormatTest.testCompositeFormat.json"}
{"callee_method_names": ["ConcurrentMap<K,V>.get", "ConcurrentInitializer<V>.get"], "method_name": "ConcurrentUtils.createIfAbsent", "method_implementation": "{\n    if (map == null || init == null) {\n        return null;\n    }\n    final V value = map.get(key);\n    if (value == null) {\n        return putIfAbsent(map, key, init.get());\n    }\n    return value;\n}", "repo_id": "8", "comment": "/**\n * Checks if a concurrent map contains a key and creates a corresponding\n * value if not. This method first checks the presence of the key in the\n * given map. If it is already contained, its value is returned. Otherwise\n * the {@code get()} method of the passed in {@link ConcurrentInitializer}\n * is called. With the resulting object\n * {@link #putIfAbsent(ConcurrentMap, Object, Object)} is called. This\n * handles the case that in the meantime another thread has added the key to\n * the map. Both the map and the initializer can be <b>null</b>; in this\n * case this method simply returns <b>null</b>.\n *\n * @param <K> the type of the keys of the map\n * @param <V> the type of the values of the map\n * @param map the map to be modified\n * @param key the key of the value to be added\n * @param init the {@link ConcurrentInitializer} for creating the value\n * @return the value stored in the map after this operation; this may or may\n * not be the object created by the {@link ConcurrentInitializer}\n * @throws ConcurrentException if the initializer throws an exception\n */\n", "repo_name": "commons-lang-master/", "id": 93, "method_signature": "V createIfAbsent(ConcurrentMap, K, ConcurrentInitializer)", "filename": "ConcurrentUtils.createIfAbsent.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtils.createIfAbsentUnchecked", "method_implementation": "{\n    try {\n        return createIfAbsent(map, key, init);\n    } catch (final ConcurrentException cex) {\n        throw new ConcurrentRuntimeException(cex.getCause());\n    }\n}", "repo_id": "8", "comment": "/**\n * Checks if a concurrent map contains a key and creates a corresponding\n * value if not, suppressing checked exceptions. This method calls\n * {@code createIfAbsent()}. If a {@link ConcurrentException} is thrown, it\n * is caught and re-thrown as a {@link ConcurrentRuntimeException}.\n *\n * @param <K> the type of the keys of the map\n * @param <V> the type of the values of the map\n * @param map the map to be modified\n * @param key the key of the value to be added\n * @param init the {@link ConcurrentInitializer} for creating the value\n * @return the value stored in the map after this operation; this may or may\n * not be the object created by the {@link ConcurrentInitializer}\n * @throws ConcurrentRuntimeException if the initializer throws an exception\n */\n", "repo_name": "commons-lang-master/", "id": 94, "method_signature": "V createIfAbsentUnchecked(ConcurrentMap, K, ConcurrentInitializer)", "filename": "ConcurrentUtils.createIfAbsentUnchecked.json"}
{"callee_method_names": ["ExecutionException.getCause", "ExecutionException.getCause", "ExecutionException.getMessage", "ExecutionException.getCause"], "method_name": "ConcurrentUtils.extractCause", "method_implementation": "{\n    if (ex == null || ex.getCause() == null) {\n        return null;\n    }\n    ExceptionUtils.throwUnchecked(ex.getCause());\n    return new ConcurrentException(ex.getMessage(), ex.getCause());\n}", "repo_id": "8", "comment": "/**\n * Inspects the cause of the specified {@link ExecutionException} and\n * creates a {@link ConcurrentException} with the checked cause if\n * necessary. This method performs the following checks on the cause of the\n * passed in exception:\n * <ul>\n * <li>If the passed in exception is <b>null</b> or the cause is\n * <b>null</b>, this method returns <b>null</b>.</li>\n * <li>If the cause is a runtime exception, it is directly thrown.</li>\n * <li>If the cause is an error, it is directly thrown, too.</li>\n * <li>In any other case the cause is a checked exception. The method then\n * creates a {@link ConcurrentException}, initializes it with the cause, and\n * returns it.</li>\n * </ul>\n *\n * @param ex the exception to be processed\n * @return a {@link ConcurrentException} with the checked cause\n */\n", "repo_name": "commons-lang-master/", "id": 95, "method_signature": "ConcurrentException extractCause(ExecutionException)", "filename": "ConcurrentUtils.extractCause.json"}
{"callee_method_names": ["ExecutionException.getCause", "ExecutionException.getCause", "ExecutionException.getMessage", "ExecutionException.getCause"], "method_name": "ConcurrentUtils.extractCauseUnchecked", "method_implementation": "{\n    if (ex == null || ex.getCause() == null) {\n        return null;\n    }\n    ExceptionUtils.throwUnchecked(ex.getCause());\n    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());\n}", "repo_id": "8", "comment": "/**\n * Inspects the cause of the specified {@link ExecutionException} and\n * creates a {@link ConcurrentRuntimeException} with the checked cause if\n * necessary. This method works exactly like\n * {@link #extractCause(ExecutionException)}. The only difference is that\n * the cause of the specified {@link ExecutionException} is extracted as a\n * runtime exception. This is an alternative for client code that does not\n * want to deal with checked exceptions.\n *\n * @param ex the exception to be processed\n * @return a {@link ConcurrentRuntimeException} with the checked cause\n */\n", "repo_name": "commons-lang-master/", "id": 96, "method_signature": "ConcurrentRuntimeException extractCauseUnchecked(ExecutionException)", "filename": "ConcurrentUtils.extractCauseUnchecked.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtils.handleCause", "method_implementation": "{\n    final ConcurrentException cause = extractCause(ex);\n    if (cause != null) {\n        throw cause;\n    }\n}", "repo_id": "8", "comment": "/**\n * Handles the specified {@link ExecutionException}. This method calls\n * {@link #extractCause(ExecutionException)} for obtaining the cause of the\n * exception - which might already cause an unchecked exception or an error\n * being thrown. If the cause is a checked exception however, it is wrapped\n * in a {@link ConcurrentException}, which is thrown. If the passed in\n * exception is <b>null</b> or has no cause, the method simply returns\n * without throwing an exception.\n *\n * @param ex the exception to be handled\n * @throws ConcurrentException if the cause of the {@code\n * ExecutionException} is a checked exception\n */\n", "repo_name": "commons-lang-master/", "id": 97, "method_signature": "void handleCause(ExecutionException)", "filename": "ConcurrentUtils.handleCause.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtils.handleCauseUnchecked", "method_implementation": "{\n    final ConcurrentRuntimeException cause = extractCauseUnchecked(ex);\n    if (cause != null) {\n        throw cause;\n    }\n}", "repo_id": "8", "comment": "/**\n * Handles the specified {@link ExecutionException} and transforms it into a\n * runtime exception. This method works exactly like\n * {@link #handleCause(ExecutionException)}, but instead of a\n * {@link ConcurrentException} it throws a\n * {@link ConcurrentRuntimeException}. This is an alternative for client\n * code that does not want to deal with checked exceptions.\n *\n * @param ex the exception to be handled\n * @throws ConcurrentRuntimeException if the cause of the {@code\n * ExecutionException} is a checked exception; this exception is then\n * wrapped in the thrown runtime exception\n */\n", "repo_name": "commons-lang-master/", "id": 98, "method_signature": "void handleCauseUnchecked(ExecutionException)", "filename": "ConcurrentUtils.handleCauseUnchecked.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtils.initializeUnchecked", "method_implementation": "{\n    try {\n        return initialize(initializer);\n    } catch (final ConcurrentException cex) {\n        throw new ConcurrentRuntimeException(cex.getCause());\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes the specified {@link ConcurrentInitializer} and transforms\n * occurring exceptions to runtime exceptions. This method works like\n * {@link #initialize(ConcurrentInitializer)}, but if the {@code\n * ConcurrentInitializer} throws a {@link ConcurrentException}, it is\n * caught, and the cause is wrapped in a {@link ConcurrentRuntimeException}.\n * So client code does not have to deal with checked exceptions.\n *\n * @param <T> the type of the object produced by the initializer\n * @param initializer the {@link ConcurrentInitializer} to be invoked\n * @return the object managed by the {@link ConcurrentInitializer}\n * @throws ConcurrentRuntimeException if the initializer throws an exception\n */\n", "repo_name": "commons-lang-master/", "id": 99, "method_signature": "T initializeUnchecked(ConcurrentInitializer)", "filename": "ConcurrentUtils.initializeUnchecked.json"}
{"callee_method_names": ["ConcurrentMap<K,V>.putIfAbsent"], "method_name": "ConcurrentUtils.putIfAbsent", "method_implementation": "{\n    if (map == null) {\n        return null;\n    }\n    final V result = map.putIfAbsent(key, value);\n    return result != null ? result : value;\n}", "repo_id": "8", "comment": "/**\n * Puts a value in the specified {@link ConcurrentMap} if the key is not yet\n * present. This method works similar to the {@code putIfAbsent()} method of\n * the {@link ConcurrentMap} interface, but the value returned is different.\n * Basically, this method is equivalent to the following code fragment:\n *\n * <pre>\n * if (!map.containsKey(key)) {\n *     map.put(key, value);\n *     return value;\n * } else {\n *     return map.get(key);\n * }\n * </pre>\n *\n * <p>\n * except that the action is performed atomically. So this method always\n * returns the value which is stored in the map.\n * </p>\n * <p>\n * This method is <b>null</b>-safe: It accepts a <b>null</b> map as input\n * without throwing an exception. In this case the return value is\n * <b>null</b>, too.\n * </p>\n *\n * @param <K> the type of the keys of the map\n * @param <V> the type of the values of the map\n * @param map the map to be modified\n * @param key the key of the value to be added\n * @param value the value to be added\n * @return the value stored in the map after this operation\n */\n", "repo_name": "commons-lang-master/", "id": 100, "method_signature": "V putIfAbsent(ConcurrentMap, K, V)", "filename": "ConcurrentUtils.putIfAbsent.json"}
{"callee_method_names": ["Future<Integer>.isDone", "Future<Integer>.get", "Future<Integer>.get", "Future<Integer>.get", "Future<Integer>.isCancelled", "Future<Integer>.cancel", "Future<Integer>.cancel"], "method_name": "ConcurrentUtilsTest.testConstantFuture_Integer", "method_implementation": "{\n    final Integer value = Integer.valueOf(5);\n    final Future<Integer> test = ConcurrentUtils.constantFuture(value);\n    assertTrue(test.isDone());\n    assertSame(value, test.get());\n    assertSame(value, test.get(1000, TimeUnit.SECONDS));\n    assertSame(value, test.get(1000, null));\n    assertFalse(test.isCancelled());\n    assertFalse(test.cancel(true));\n    assertFalse(test.cancel(false));\n}", "repo_id": "8", "comment": "/**\n * Tests constant future.\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1438, "method_signature": "void testConstantFuture_Integer()", "filename": "ConcurrentUtilsTest.testConstantFuture_Integer.json"}
{"callee_method_names": ["Future<Integer>.isDone", "Future<Integer>.get", "Future<Integer>.get", "Future<Integer>.get", "Future<Integer>.isCancelled", "Future<Integer>.cancel", "Future<Integer>.cancel"], "method_name": "ConcurrentUtilsTest.testConstantFuture_null", "method_implementation": "{\n    final Integer value = null;\n    final Future<Integer> test = ConcurrentUtils.constantFuture(value);\n    assertTrue(test.isDone());\n    assertSame(value, test.get());\n    assertSame(value, test.get(1000, TimeUnit.SECONDS));\n    assertSame(value, test.get(1000, null));\n    assertFalse(test.isCancelled());\n    assertFalse(test.cancel(true));\n    assertFalse(test.cancel(false));\n}", "repo_id": "8", "comment": "/**\n * Tests constant future.\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1439, "method_signature": "void testConstantFuture_null()", "filename": "ConcurrentUtilsTest.testConstantFuture_null.json"}
{"callee_method_names": ["ConcurrentInitializer<Integer>.get", "ConcurrentMap<String, Integer>.get"], "method_name": "ConcurrentUtilsTest.testCreateIfAbsentKeyNotPresent", "method_implementation": "{\n    final ConcurrentInitializer<Integer> init = EasyMock.createMock(ConcurrentInitializer.class);\n    final String key = \"testKey\";\n    final Integer value = 42;\n    EasyMock.expect(init.get()).andReturn(value);\n    EasyMock.replay(init);\n    final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();\n    assertEquals(value, ConcurrentUtils.createIfAbsent(map, key, init), \"Wrong result\");\n    assertEquals(value, map.get(key), \"Wrong value in map\");\n    EasyMock.verify(init);\n}", "repo_id": "8", "comment": "/**\n * Tests createIfAbsent() if the map does not contain the key in question.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1440, "method_signature": "void testCreateIfAbsentKeyNotPresent()", "filename": "ConcurrentUtilsTest.testCreateIfAbsentKeyNotPresent.json"}
{"callee_method_names": ["ConcurrentMap<String, Integer>.put", "ConcurrentMap<String, Integer>.get"], "method_name": "ConcurrentUtilsTest.testCreateIfAbsentKeyPresent", "method_implementation": "{\n    final ConcurrentInitializer<Integer> init = EasyMock.createMock(ConcurrentInitializer.class);\n    EasyMock.replay(init);\n    final String key = \"testKey\";\n    final Integer value = 42;\n    final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();\n    map.put(key, value);\n    assertEquals(value, ConcurrentUtils.createIfAbsent(map, key, init), \"Wrong result\");\n    assertEquals(value, map.get(key), \"Wrong value in map\");\n    EasyMock.verify(init);\n}", "repo_id": "8", "comment": "/**\n * Tests createIfAbsent() if the key is found in the map.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1441, "method_signature": "void testCreateIfAbsentKeyPresent()", "filename": "ConcurrentUtilsTest.testCreateIfAbsentKeyPresent.json"}
{"callee_method_names": ["ConcurrentMap<String, Integer>.put", "ConcurrentMap<String, Integer>.get"], "method_name": "ConcurrentUtilsTest.testCreateIfAbsentNullInit", "method_implementation": "{\n    final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();\n    final String key = \"testKey\";\n    final Integer value = 42;\n    map.put(key, value);\n    assertNull(ConcurrentUtils.createIfAbsent(map, key, null), \"Wrong result\");\n    assertEquals(value, map.get(key), \"Map was changed\");\n}", "repo_id": "8", "comment": "/**\n * Tests createIfAbsent() if a null initializer is passed in.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1442, "method_signature": "void testCreateIfAbsentNullInit()", "filename": "ConcurrentUtilsTest.testCreateIfAbsentNullInit.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testCreateIfAbsentNullMap", "method_implementation": "{\n    final ConcurrentInitializer<Integer> init = EasyMock.createMock(ConcurrentInitializer.class);\n    EasyMock.replay(init);\n    assertNull(ConcurrentUtils.createIfAbsent(null, \"test\", init), \"Wrong result\");\n    EasyMock.verify(init);\n}", "repo_id": "8", "comment": "/**\n * Tests createIfAbsent() if a null map is passed in.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1443, "method_signature": "void testCreateIfAbsentNullMap()", "filename": "ConcurrentUtilsTest.testCreateIfAbsentNullMap.json"}
{"callee_method_names": ["ConcurrentInitializer<Integer>.get", "ConcurrentRuntimeException.getCause"], "method_name": "ConcurrentUtilsTest.testCreateIfAbsentUncheckedException", "method_implementation": "{\n    final ConcurrentInitializer<Integer> init = EasyMock.createMock(ConcurrentInitializer.class);\n    final Exception ex = new Exception();\n    EasyMock.expect(init.get()).andThrow(new ConcurrentException(ex));\n    EasyMock.replay(init);\n    final ConcurrentRuntimeException crex = assertThrows(ConcurrentRuntimeException.class, () -> ConcurrentUtils.createIfAbsentUnchecked(new ConcurrentHashMap<>(), \"test\", init));\n    assertEquals(ex, crex.getCause(), \"Wrong cause\");\n    EasyMock.verify(init);\n}", "repo_id": "8", "comment": "/**\n * Tests createIfAbsentUnchecked() if an exception is thrown.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1444, "method_signature": "void testCreateIfAbsentUncheckedException()", "filename": "ConcurrentUtilsTest.testCreateIfAbsentUncheckedException.json"}
{"callee_method_names": ["ConcurrentMap<String, Integer>.get"], "method_name": "ConcurrentUtilsTest.testCreateIfAbsentUncheckedSuccess", "method_implementation": "{\n    final String key = \"testKey\";\n    final Integer value = 42;\n    final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();\n    assertEquals(value, ConcurrentUtils.createIfAbsentUnchecked(map, key, new ConstantInitializer<>(value)), \"Wrong result\");\n    assertEquals(value, map.get(key), \"Wrong value in map\");\n}", "repo_id": "8", "comment": "/**\n * Tests createIfAbsentUnchecked() if no exception is thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 1445, "method_signature": "void testCreateIfAbsentUncheckedSuccess()", "filename": "ConcurrentUtilsTest.testCreateIfAbsentUncheckedSuccess.json"}
{"callee_method_names": ["ConcurrentException.getCause"], "method_name": "ConcurrentUtilsTest.testExtractCauseChecked", "method_implementation": "{\n    final Exception ex = new Exception(\"Test\");\n    final ConcurrentException cex = ConcurrentUtils.extractCause(new ExecutionException(ex));\n    assertSame(ex, cex.getCause(), \"Wrong cause\");\n}", "repo_id": "8", "comment": "/**\n * Tests extractCause() if the cause is a checked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1446, "method_signature": "void testExtractCauseChecked()", "filename": "ConcurrentUtilsTest.testExtractCauseChecked.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testExtractCauseError", "method_implementation": "{\n    final Error err = new AssertionError(\"Test\");\n    final AssertionError e = assertThrows(AssertionError.class, () -> ConcurrentUtils.extractCause(new ExecutionException(err)));\n    assertEquals(err, e, \"Wrong error\");\n}", "repo_id": "8", "comment": "/**\n * Tests extractCause() if the cause is an error.\n */\n", "repo_name": "commons-lang-master/", "id": 1447, "method_signature": "void testExtractCauseError()", "filename": "ConcurrentUtilsTest.testExtractCauseError.json"}
{"callee_method_names": ["ConcurrentRuntimeException.getCause"], "method_name": "ConcurrentUtilsTest.testExtractCauseUncheckedChecked", "method_implementation": "{\n    final Exception ex = new Exception(\"Test\");\n    final ConcurrentRuntimeException cex = ConcurrentUtils.extractCauseUnchecked(new ExecutionException(ex));\n    assertSame(ex, cex.getCause(), \"Wrong cause\");\n}", "repo_id": "8", "comment": "/**\n * Tests extractCauseUnchecked() if the cause is a checked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1448, "method_signature": "void testExtractCauseUncheckedChecked()", "filename": "ConcurrentUtilsTest.testExtractCauseUncheckedChecked.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testExtractCauseUncheckedError", "method_implementation": "{\n    final Error err = new AssertionError(\"Test\");\n    final Error e = assertThrows(Error.class, () -> ConcurrentUtils.extractCauseUnchecked(new ExecutionException(err)));\n    assertEquals(err, e, \"Wrong error\");\n}", "repo_id": "8", "comment": "/**\n * Tests extractCauseUnchecked() if the cause is an error.\n */\n", "repo_name": "commons-lang-master/", "id": 1449, "method_signature": "void testExtractCauseUncheckedError()", "filename": "ConcurrentUtilsTest.testExtractCauseUncheckedError.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testExtractCauseUncheckedException", "method_implementation": "{\n    final RuntimeException rex = new RuntimeException(\"Test\");\n    assertThrows(RuntimeException.class, () -> ConcurrentUtils.extractCause(new ExecutionException(rex)));\n}", "repo_id": "8", "comment": "/**\n * Tests extractCause() if the cause is an unchecked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1450, "method_signature": "void testExtractCauseUncheckedException()", "filename": "ConcurrentUtilsTest.testExtractCauseUncheckedException.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testExtractCauseUncheckedUncheckedException", "method_implementation": "{\n    final RuntimeException rex = new RuntimeException(\"Test\");\n    final RuntimeException r = assertThrows(RuntimeException.class, () -> ConcurrentUtils.extractCauseUnchecked(new ExecutionException(rex)));\n    assertEquals(rex, r, \"Wrong exception\");\n}", "repo_id": "8", "comment": "/**\n * Tests extractCauseUnchecked() if the cause is an unchecked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1451, "method_signature": "void testExtractCauseUncheckedUncheckedException()", "filename": "ConcurrentUtilsTest.testExtractCauseUncheckedUncheckedException.json"}
{"callee_method_names": ["ConcurrentException.getCause"], "method_name": "ConcurrentUtilsTest.testHandleCauseChecked", "method_implementation": "{\n    final Exception ex = new Exception(\"Test\");\n    final ConcurrentException cex = assertThrows(ConcurrentException.class, () -> ConcurrentUtils.handleCause(new ExecutionException(ex)));\n    assertEquals(ex, cex.getCause(), \"Wrong cause\");\n}", "repo_id": "8", "comment": "/**\n * Tests handleCause() if the cause is a checked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1452, "method_signature": "void testHandleCauseChecked()", "filename": "ConcurrentUtilsTest.testHandleCauseChecked.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testHandleCauseError", "method_implementation": "{\n    final Error err = new AssertionError(\"Test\");\n    final Error e = assertThrows(Error.class, () -> ConcurrentUtils.handleCause(new ExecutionException(err)));\n    assertEquals(err, e, \"Wrong error\");\n}", "repo_id": "8", "comment": "/**\n * Tests handleCause() if the cause is an error.\n */\n", "repo_name": "commons-lang-master/", "id": 1453, "method_signature": "void testHandleCauseError()", "filename": "ConcurrentUtilsTest.testHandleCauseError.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testHandleCauseNull", "method_implementation": "{\n    ConcurrentUtils.handleCause(null);\n    ConcurrentUtils.handleCause(new ExecutionException(\"Test\", null));\n}", "repo_id": "8", "comment": "/**\n * Tests handleCause() for a null parameter or a null cause. In this case the method should do nothing. We can only test\n * that no exception is thrown.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1454, "method_signature": "void testHandleCauseNull()", "filename": "ConcurrentUtilsTest.testHandleCauseNull.json"}
{"callee_method_names": ["ConcurrentRuntimeException.getCause"], "method_name": "ConcurrentUtilsTest.testHandleCauseUncheckedChecked", "method_implementation": "{\n    final Exception ex = new Exception(\"Test\");\n    final ConcurrentRuntimeException crex = assertThrows(ConcurrentRuntimeException.class, () -> ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex)));\n    assertEquals(ex, crex.getCause(), \"Wrong cause\");\n}", "repo_id": "8", "comment": "/**\n * Tests handleCauseUnchecked() if the cause is a checked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1455, "method_signature": "void testHandleCauseUncheckedChecked()", "filename": "ConcurrentUtilsTest.testHandleCauseUncheckedChecked.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testHandleCauseUncheckedError", "method_implementation": "{\n    final Error err = new AssertionError(\"Test\");\n    final Error e = assertThrows(Error.class, () -> ConcurrentUtils.handleCauseUnchecked(new ExecutionException(err)));\n    assertEquals(err, e, \"Wrong error\");\n}", "repo_id": "8", "comment": "/**\n * Tests handleCauseUnchecked() if the cause is an error.\n */\n", "repo_name": "commons-lang-master/", "id": 1456, "method_signature": "void testHandleCauseUncheckedError()", "filename": "ConcurrentUtilsTest.testHandleCauseUncheckedError.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testHandleCauseUncheckedException", "method_implementation": "{\n    final RuntimeException rex = new RuntimeException(\"Test\");\n    final RuntimeException r = assertThrows(RuntimeException.class, () -> ConcurrentUtils.handleCause(new ExecutionException(rex)));\n    assertEquals(rex, r, \"Wrong exception\");\n}", "repo_id": "8", "comment": "/**\n * Tests handleCause() if the cause is an unchecked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1457, "method_signature": "void testHandleCauseUncheckedException()", "filename": "ConcurrentUtilsTest.testHandleCauseUncheckedException.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testHandleCauseUncheckedNull", "method_implementation": "{\n    ConcurrentUtils.handleCauseUnchecked(null);\n    ConcurrentUtils.handleCauseUnchecked(new ExecutionException(\"Test\", null));\n}", "repo_id": "8", "comment": "/**\n * Tests handleCauseUnchecked() for a null parameter or a null cause. In this case the method should do nothing. We can\n * only test that no exception is thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 1458, "method_signature": "void testHandleCauseUncheckedNull()", "filename": "ConcurrentUtilsTest.testHandleCauseUncheckedNull.json"}
{"callee_method_names": [], "method_name": "ConcurrentUtilsTest.testHandleCauseUncheckedUncheckedException", "method_implementation": "{\n    final RuntimeException rex = new RuntimeException(\"Test\");\n    final RuntimeException r = assertThrows(RuntimeException.class, () -> ConcurrentUtils.handleCauseUnchecked(new ExecutionException(rex)));\n    assertEquals(rex, r, \"Wrong exception\");\n}", "repo_id": "8", "comment": "/**\n * Tests handleCauseUnchecked() if the cause is an unchecked exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1459, "method_signature": "void testHandleCauseUncheckedUncheckedException()", "filename": "ConcurrentUtilsTest.testHandleCauseUncheckedUncheckedException.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.get"], "method_name": "ConcurrentUtilsTest.testInitialize", "method_implementation": "{\n    final ConcurrentInitializer<Object> init = EasyMock.createMock(ConcurrentInitializer.class);\n    final Object result = new Object();\n    EasyMock.expect(init.get()).andReturn(result);\n    EasyMock.replay(init);\n    assertSame(result, ConcurrentUtils.initialize(init), \"Wrong result object\");\n    EasyMock.verify(init);\n}", "repo_id": "8", "comment": "/**\n * Tests a successful initialize() operation.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1460, "method_signature": "void testInitialize()", "filename": "ConcurrentUtilsTest.testInitialize.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.get"], "method_name": "ConcurrentUtilsTest.testInitializeUnchecked", "method_implementation": "{\n    final ConcurrentInitializer<Object> init = EasyMock.createMock(ConcurrentInitializer.class);\n    final Object result = new Object();\n    EasyMock.expect(init.get()).andReturn(result);\n    EasyMock.replay(init);\n    assertSame(result, ConcurrentUtils.initializeUnchecked(init), \"Wrong result object\");\n    EasyMock.verify(init);\n}", "repo_id": "8", "comment": "/**\n * Tests a successful initializeUnchecked() operation.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1461, "method_signature": "void testInitializeUnchecked()", "filename": "ConcurrentUtilsTest.testInitializeUnchecked.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.get", "ConcurrentRuntimeException.getCause"], "method_name": "ConcurrentUtilsTest.testInitializeUncheckedEx", "method_implementation": "{\n    final ConcurrentInitializer<Object> init = EasyMock.createMock(ConcurrentInitializer.class);\n    final Exception cause = new Exception();\n    EasyMock.expect(init.get()).andThrow(new ConcurrentException(cause));\n    EasyMock.replay(init);\n    final ConcurrentRuntimeException crex = assertThrows(ConcurrentRuntimeException.class, () -> ConcurrentUtils.initializeUnchecked(init));\n    assertSame(cause, crex.getCause(), \"Wrong cause\");\n    EasyMock.verify(init);\n}", "repo_id": "8", "comment": "/**\n * Tests whether exceptions are correctly handled by initializeUnchecked().\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1462, "method_signature": "void testInitializeUncheckedEx()", "filename": "ConcurrentUtilsTest.testInitializeUncheckedEx.json"}
{"callee_method_names": ["ConcurrentMap<String, Integer>.get"], "method_name": "ConcurrentUtilsTest.testPutIfAbsentKeyNotPresent", "method_implementation": "{\n    final String key = \"testKey\";\n    final Integer value = 42;\n    final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();\n    assertEquals(value, ConcurrentUtils.putIfAbsent(map, key, value), \"Wrong result\");\n    assertEquals(value, map.get(key), \"Wrong value in map\");\n}", "repo_id": "8", "comment": "/**\n * Tests putIfAbsent() if the map does not contain the key in question.\n */\n", "repo_name": "commons-lang-master/", "id": 1463, "method_signature": "void testPutIfAbsentKeyNotPresent()", "filename": "ConcurrentUtilsTest.testPutIfAbsentKeyNotPresent.json"}
{"callee_method_names": ["ConcurrentMap<String, Integer>.put", "ConcurrentMap<String, Integer>.get"], "method_name": "ConcurrentUtilsTest.testPutIfAbsentKeyPresent", "method_implementation": "{\n    final String key = \"testKey\";\n    final Integer value = 42;\n    final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();\n    map.put(key, value);\n    assertEquals(value, ConcurrentUtils.putIfAbsent(map, key, 0), \"Wrong result\");\n    assertEquals(value, map.get(key), \"Wrong value in map\");\n}", "repo_id": "8", "comment": "/**\n * Tests putIfAbsent() if the map contains the key in question.\n */\n", "repo_name": "commons-lang-master/", "id": 1464, "method_signature": "void testPutIfAbsentKeyPresent()", "filename": "ConcurrentUtilsTest.testPutIfAbsentKeyPresent.json"}
{"callee_method_names": ["ConstantInitializer<?>.getObject"], "method_name": "ConstantInitializer.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (!(obj instanceof ConstantInitializer<?>)) {\n        return false;\n    }\n    final ConstantInitializer<?> c = (ConstantInitializer<?>) obj;\n    return Objects.equals(getObject(), c.getObject());\n}", "repo_id": "8", "comment": "/**\n * Compares this object with another one. This implementation returns\n * <b>true</b> if and only if the passed in object is an instance of\n * {@link ConstantInitializer} which refers to an object equals to the\n * object managed by this instance.\n *\n * @param obj the object to compare to\n * @return a flag whether the objects are equal\n */\n", "repo_name": "commons-lang-master/", "id": 132, "method_signature": "boolean equals(Object)", "filename": "ConstantInitializer.equals.json"}
{"callee_method_names": [], "method_name": "ConstantInitializer.toString", "method_implementation": "{\n    return String.format(FMT_TO_STRING, Integer.valueOf(System.identityHashCode(this)), String.valueOf(getObject()));\n}", "repo_id": "8", "comment": "/**\n * Returns a string representation for this object. This string also\n * contains a string representation of the object managed by this\n * initializer.\n *\n * @return a string for this object\n */\n", "repo_name": "commons-lang-master/", "id": 133, "method_signature": "String toString()", "filename": "ConstantInitializer.toString.json"}
{"callee_method_names": ["ConstantInitializer<Integer>.equals", "Object.equals", "ConstantInitializer<Integer>.hashCode", "Object.hashCode"], "method_name": "ConstantInitializerTest.checkEquals", "method_implementation": "{\n    assertEquals(expected, init.equals(obj), \"Wrong result of equals\");\n    if (obj != null) {\n        assertEquals(expected, obj.equals(init), \"Not symmetric\");\n        if (expected) {\n            assertEquals(init.hashCode(), obj.hashCode(), \"Different hash codes\");\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Helper method for testing equals() and hashCode().\n *\n * @param obj the object to compare with the test instance\n * @param expected the expected result\n */\n", "repo_name": "commons-lang-master/", "id": 1580, "method_signature": "void checkEquals(Object, boolean)", "filename": "ConstantInitializerTest.checkEquals.json"}
{"callee_method_names": [], "method_name": "ConstantInitializerTest.testEqualsFalse", "method_implementation": "{\n    ConstantInitializer<Integer> init2 = new ConstantInitializer<>(null);\n    checkEquals(init2, false);\n    init2 = new ConstantInitializer<>(VALUE + 1);\n    checkEquals(init2, false);\n}", "repo_id": "8", "comment": "/**\n * Tests equals() if the expected result is false.\n */\n", "repo_name": "commons-lang-master/", "id": 1581, "method_signature": "void testEqualsFalse()", "filename": "ConstantInitializerTest.testEqualsFalse.json"}
{"callee_method_names": ["Integer.intValue"], "method_name": "ConstantInitializerTest.testEqualsTrue", "method_implementation": "{\n    checkEquals(init, true);\n    ConstantInitializer<Integer> init2 = new ConstantInitializer<>(Integer.valueOf(VALUE.intValue()));\n    checkEquals(init2, true);\n    init = new ConstantInitializer<>(null);\n    init2 = new ConstantInitializer<>(null);\n    checkEquals(init2, true);\n}", "repo_id": "8", "comment": "/**\n * Tests equals() if the expected result is true.\n */\n", "repo_name": "commons-lang-master/", "id": 1582, "method_signature": "void testEqualsTrue()", "filename": "ConstantInitializerTest.testEqualsTrue.json"}
{"callee_method_names": [], "method_name": "ConstantInitializerTest.testEqualsWithOtherObjects", "method_implementation": "{\n    checkEquals(null, false);\n    checkEquals(this, false);\n    checkEquals(new ConstantInitializer<>(\"Test\"), false);\n}", "repo_id": "8", "comment": "/**\n * Tests equals() with objects of other classes.\n */\n", "repo_name": "commons-lang-master/", "id": 1583, "method_signature": "void testEqualsWithOtherObjects()", "filename": "ConstantInitializerTest.testEqualsWithOtherObjects.json"}
{"callee_method_names": ["ConstantInitializer<Integer>.toString", "Pattern.matcher"], "method_name": "ConstantInitializerTest.testToString", "method_implementation": "{\n    final String s = init.toString();\n    final Pattern pattern = Pattern.compile(\"ConstantInitializer@-?\\\\d+ \\\\[ object = \" + VALUE + \" \\\\]\");\n    assertTrue(pattern.matcher(s).matches(), \"Wrong string: \" + s);\n}", "repo_id": "8", "comment": "/**\n * Tests the string representation.\n */\n", "repo_name": "commons-lang-master/", "id": 1585, "method_signature": "void testToString()", "filename": "ConstantInitializerTest.testToString.json"}
{"callee_method_names": ["String.indexOf"], "method_name": "ConstantInitializerTest.testToStringNull", "method_implementation": "{\n    final String s = new ConstantInitializer<>(null).toString();\n    assertTrue(s.indexOf(\"object = null\") > 0, \"Object not found: \" + s);\n}", "repo_id": "8", "comment": "/**\n * Tests the string representation if the managed object is null.\n */\n", "repo_name": "commons-lang-master/", "id": 1586, "method_signature": "void testToStringNull()", "filename": "ConstantInitializerTest.testToStringNull.json"}
{"callee_method_names": ["ConstantInitializer<Integer>.isInitialized", "ConstantInitializer<Integer>.getObject", "ConstantInitializer<Integer>.isInitialized"], "method_name": "ConstantInitializerTest.testisInitialized", "method_implementation": "{\n    assertTrue(init.isInitialized(), \"was not initialized before get()\");\n    assertEquals(VALUE, init.getObject(), \"Wrong object\");\n    assertTrue(init.isInitialized(), \"was not initialized after get()\");\n}", "repo_id": "8", "comment": "/**\n * Tests a simple invocation of the isInitialized() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1584, "method_signature": "void testisInitialized()", "filename": "ConstantInitializerTest.testisInitialized.json"}
{"callee_method_names": ["Constructor<T>.getDeclaringClass"], "method_name": "ConstructorUtils.getAccessibleConstructor", "method_implementation": "{\n    Objects.requireNonNull(ctor, \"ctor\");\n    return MemberUtils.isAccessible(ctor) && isAccessible(ctor.getDeclaringClass()) ? ctor : null;\n}", "repo_id": "8", "comment": "/**\n * Checks if the specified constructor is accessible.\n *\n * <p>This simply ensures that the constructor is accessible.</p>\n *\n * @param <T> the constructor type\n * @param ctor  the prototype constructor object, not {@code null}\n * @return the constructor, {@code null} if no matching accessible constructor found\n * @see SecurityManager\n * @throws NullPointerException if {@code ctor} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 335, "method_signature": "Constructor<T> getAccessibleConstructor(Constructor)", "filename": "ConstructorUtils.getAccessibleConstructor.json"}
{"callee_method_names": ["Class<T>.getConstructor", "Class<T>.getConstructors"], "method_name": "ConstructorUtils.getMatchingAccessibleConstructor", "method_implementation": "{\n    Objects.requireNonNull(cls, \"cls\");\n    // see if we can find the constructor directly\n    // most of the time this works and it's much faster\n    try {\n        return MemberUtils.setAccessibleWorkaround(cls.getConstructor(parameterTypes));\n    } catch (final NoSuchMethodException ignored) {\n        // ignore\n    }\n    Constructor<T> result = null;\n    /*\n         * (1) Class.getConstructors() is documented to return Constructor<T> so as\n         * long as the array is not subsequently modified, everything's fine.\n         */\n    final Constructor<?>[] ctors = cls.getConstructors();\n    // return best match:\n    for (Constructor<?> ctor : ctors) {\n        // compare parameters\n        if (MemberUtils.isMatchingConstructor(ctor, parameterTypes)) {\n            // get accessible version of constructor\n            ctor = getAccessibleConstructor(ctor);\n            if (ctor != null) {\n                MemberUtils.setAccessibleWorkaround(ctor);\n                if (result == null || MemberUtils.compareConstructorFit(ctor, result, parameterTypes) < 0) {\n                    // temporary variable for annotation, see comment above (1)\n                    @SuppressWarnings(\"unchecked\")\n                    final Constructor<T> constructor = (Constructor<T>) ctor;\n                    result = constructor;\n                }\n            }\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Finds an accessible constructor with compatible parameters.\n *\n * <p>This checks all the constructor and finds one with compatible parameters\n * This requires that every parameter is assignable from the given parameter types.\n * This is a more flexible search than the normal exact matching algorithm.</p>\n *\n * <p>First it checks if there is a constructor matching the exact signature.\n * If not then all the constructors of the class are checked to see if their\n * signatures are assignment-compatible with the parameter types.\n * The first assignment-compatible matching constructor is returned.</p>\n *\n * @param <T> the constructor type\n * @param cls  the class to find a constructor for, not {@code null}\n * @param parameterTypes find method with compatible parameters\n * @return the constructor, null if no matching accessible constructor found\n * @throws NullPointerException if {@code cls} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 336, "method_signature": "Constructor<T> getMatchingAccessibleConstructor(Class, Class<?>[])", "filename": "ConstructorUtils.getMatchingAccessibleConstructor.json"}
{"callee_method_names": ["Class<T>.getName", "Constructor<T>.isVarArgs", "Constructor<T>.getParameterTypes", "Constructor<T>.newInstance"], "method_name": "ConstructorUtils.invokeConstructor", "method_implementation": "{\n    args = ArrayUtils.nullToEmpty(args);\n    parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);\n    if (ctor == null) {\n        throw new NoSuchMethodException(\"No such accessible constructor on object: \" + cls.getName());\n    }\n    if (ctor.isVarArgs()) {\n        final Class<?>[] methodParameterTypes = ctor.getParameterTypes();\n        args = MethodUtils.getVarArgs(args, methodParameterTypes);\n    }\n    return ctor.newInstance(args);\n}", "repo_id": "8", "comment": "/**\n * Returns a new instance of the specified class choosing the right constructor\n * from the list of parameter types.\n *\n * <p>This locates and calls a constructor.\n * The constructor signature must match the parameter types by assignment compatibility.</p>\n *\n * @param <T> the type to be constructed\n * @param cls  the class to be constructed, not {@code null}\n * @param args  the array of arguments, {@code null} treated as empty\n * @param parameterTypes  the array of parameter types, {@code null} treated as empty\n * @return new instance of {@code cls}, not {@code null}\n *\n * @throws NullPointerException if {@code cls} is {@code null}\n * @throws NoSuchMethodException if a matching constructor cannot be found\n * @throws IllegalAccessException if invocation is not permitted by security\n * @throws InvocationTargetException if an error occurs on invocation\n * @throws InstantiationException if an error occurs on instantiation\n * @see Constructor#newInstance\n */\n", "repo_name": "commons-lang-master/", "id": 338, "method_signature": "T invokeConstructor(Class, Object[], Class<?>[])", "filename": "ConstructorUtils.invokeConstructor.json"}
{"callee_method_names": ["Class<T>.getName", "Constructor<T>.newInstance"], "method_name": "ConstructorUtils.invokeExactConstructor", "method_implementation": "{\n    args = ArrayUtils.nullToEmpty(args);\n    parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n    final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);\n    if (ctor == null) {\n        throw new NoSuchMethodException(\"No such accessible constructor on object: \" + cls.getName());\n    }\n    return ctor.newInstance(args);\n}", "repo_id": "8", "comment": "/**\n * Returns a new instance of the specified class choosing the right constructor\n * from the list of parameter types.\n *\n * <p>This locates and calls a constructor.\n * The constructor signature must match the parameter types exactly.</p>\n *\n * @param <T> the type to be constructed\n * @param cls the class to be constructed, not {@code null}\n * @param args the array of arguments, {@code null} treated as empty\n * @param parameterTypes  the array of parameter types, {@code null} treated as empty\n * @return new instance of {@code cls}, not {@code null}\n *\n * @throws NullPointerException if {@code cls} is {@code null}\n * @throws NoSuchMethodException if a matching constructor cannot be found\n * @throws IllegalAccessException if invocation is not permitted by security\n * @throws InvocationTargetException if an error occurs on invocation\n * @throws InstantiationException if an error occurs on instantiation\n * @see Constructor#newInstance\n */\n", "repo_name": "commons-lang-master/", "id": 340, "method_signature": "T invokeExactConstructor(Class, Object[], Class<?>[])", "filename": "ConstructorUtils.invokeExactConstructor.json"}
{"callee_method_names": ["Class<?>.getEnclosingClass"], "method_name": "ConstructorUtils.isAccessible", "method_implementation": "{\n    Class<?> cls = type;\n    while (cls != null) {\n        if (!ClassUtils.isPublic(cls)) {\n            return false;\n        }\n        cls = cls.getEnclosingClass();\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Tests whether the specified class is generally accessible, i.e. is\n * declared in an entirely {@code public} manner.\n * @param type to check\n * @return {@code true} if {@code type} and any enclosing classes are\n *         {@code public}.\n */\n", "repo_name": "commons-lang-master/", "id": 341, "method_signature": "boolean isAccessible(Class)", "filename": "ConstructorUtils.isAccessible.json"}
{"callee_method_names": ["Consumer<?>.accept", "Consumer<Object>.accept", "Consumer<String>.accept"], "method_name": "ConsumersTest.testNop", "method_implementation": "{\n    Stream.of(\"\").forEach(Consumers.nop());\n    //\n    final Consumer<?> c1 = Consumers.nop();\n    c1.accept(null);\n    final Consumer<Object> c2 = Consumers.nop();\n    c2.accept(null);\n    final Consumer<String> c3 = Consumers.nop();\n    c3.accept(null);\n    //\n    Consumers.nop().accept(null);\n    Consumers.nop().accept(\"\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Consumers#nop()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1665, "method_signature": "void testNop()", "filename": "ConsumersTest.testNop.json"}
{"callee_method_names": ["ExceptionContext.addContextValue"], "method_name": "ContextedException.addContextValue", "method_implementation": "{\n    exceptionContext.addContextValue(label, value);\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Adds information helpful to a developer in diagnosing and correcting the problem.\n * For the information to be meaningful, the value passed should have a reasonable\n * toString() implementation.\n * Different values can be added with the same label multiple times.\n * <p>\n * Note: This exception is only serializable if the object added is serializable.\n * </p>\n *\n * @param label  a textual label associated with information, {@code null} not recommended\n * @param value  information needed to understand exception, may be {@code null}\n * @return {@code this}, for method chaining, not {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 543, "method_signature": "ContextedException addContextValue(String, Object)", "filename": "ContextedException.addContextValue.json"}
{"callee_method_names": ["ExceptionContext.setContextValue"], "method_name": "ContextedException.setContextValue", "method_implementation": "{\n    exceptionContext.setContextValue(label, value);\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets information helpful to a developer in diagnosing and correcting the problem.\n * For the information to be meaningful, the value passed should have a reasonable\n * toString() implementation.\n * Any existing values with the same labels are removed before the new one is added.\n * <p>\n * Note: This exception is only serializable if the object added as value is serializable.\n * </p>\n *\n * @param label  a textual label associated with information, {@code null} not recommended\n * @param value  information needed to understand exception, may be {@code null}\n * @return {@code this}, for method chaining, not {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 544, "method_signature": "ContextedException setContextValue(String, Object)", "filename": "ContextedException.setContextValue.json"}
{"callee_method_names": ["ExceptionContext.addContextValue"], "method_name": "ContextedRuntimeException.addContextValue", "method_implementation": "{\n    exceptionContext.addContextValue(label, value);\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Adds information helpful to a developer in diagnosing and correcting the problem.\n * For the information to be meaningful, the value passed should have a reasonable\n * toString() implementation.\n * Different values can be added with the same label multiple times.\n * <p>\n * Note: This exception is only serializable if the object added is serializable.\n * </p>\n *\n * @param label  a textual label associated with information, {@code null} not recommended\n * @param value  information needed to understand exception, may be {@code null}\n * @return {@code this}, for method chaining, not {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 541, "method_signature": "ContextedRuntimeException addContextValue(String, Object)", "filename": "ContextedRuntimeException.addContextValue.json"}
{"callee_method_names": ["ExceptionContext.setContextValue"], "method_name": "ContextedRuntimeException.setContextValue", "method_implementation": "{\n    exceptionContext.setContextValue(label, value);\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets information helpful to a developer in diagnosing and correcting the problem.\n * For the information to be meaningful, the value passed should have a reasonable\n * toString() implementation.\n * Any existing values with the same labels are removed before the new one is added.\n * <p>\n * Note: This exception is only serializable if the object added as value is serializable.\n * </p>\n *\n * @param label  a textual label associated with information, {@code null} not recommended\n * @param value  information needed to understand exception, may be {@code null}\n * @return {@code this}, for method chaining, not {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 542, "method_signature": "ContextedRuntimeException setContextValue(String, Object)", "filename": "ContextedRuntimeException.setContextValue.json"}
{"callee_method_names": [], "method_name": "Conversion.binaryBeMsb0ToHexDigit", "method_implementation": "{\n    // JDK 9: Objects.checkIndex(int index, int length)\n    if (Integer.compareUnsigned(srcPos, src.length) >= 0) {\n        // Throw the correct exception\n        if (src.length == 0) {\n            throw new IllegalArgumentException(\"Cannot convert an empty array.\");\n        }\n        throw new IndexOutOfBoundsException(srcPos + \" is not within array length \" + src.length);\n    }\n    // Little-endian bit 0 position\n    final int pos = src.length - 1 - srcPos;\n    if (3 <= pos && src[pos - 3]) {\n        if (src[pos - 2]) {\n            if (src[pos - 1]) {\n                return src[pos] ? 'f' : 'e';\n            }\n            return src[pos] ? 'd' : 'c';\n        }\n        if (src[pos - 1]) {\n            return src[pos] ? 'b' : 'a';\n        }\n        return src[pos] ? '9' : '8';\n    }\n    if (2 <= pos && src[pos - 2]) {\n        if (src[pos - 1]) {\n            return src[pos] ? '7' : '6';\n        }\n        return src[pos] ? '5' : '4';\n    }\n    if (1 <= pos && src[pos - 1]) {\n        return src[pos] ? '3' : '2';\n    }\n    return src[pos] ? '1' : '0';\n}", "repo_id": "8", "comment": "/**\n * Converts a binary (represented as boolean array) in big-endian Msb0 bit ordering to a\n * hexadecimal digit.\n *\n * <p>\n * (1, 0, 0, 0) with srcPos = 0 is converted as follow: '8' (1, 0, 0, 0, 0, 0, 0, 0,\n * 0, 0, 0, 1, 0, 1, 0, 0) with srcPos = 2 is converted to '5'\n * </p>\n *\n * @param src the binary to convert\n * @param srcPos the position of the lsb to start the conversion\n * @return a hexadecimal digit representing the selected bits\n * @throws IllegalArgumentException if {@code src} is empty\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IndexOutOfBoundsException if {@code srcPos} is outside the array.\n */\n", "repo_name": "commons-lang-master/", "id": 779, "method_signature": "char binaryBeMsb0ToHexDigit(boolean[], int)", "filename": "Conversion.binaryBeMsb0ToHexDigit.json"}
{"callee_method_names": [], "method_name": "Conversion.binaryToByte", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 8) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 8\");\n    }\n    byte out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (byte) ((out & ~mask) | bits);\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts binary (represented as boolean array) into a byte using the default (little\n * endian, Lsb0) byte and bit ordering.\n *\n * @param src the binary to convert\n * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination byte\n * @param dstPos the position of the lsb, in bits, in the result byte\n * @param nBools the number of booleans to convert\n * @return a byte containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 780, "method_signature": "byte binaryToByte(boolean[], int, byte, int, int)", "filename": "Conversion.binaryToByte.json"}
{"callee_method_names": [], "method_name": "Conversion.binaryToHexDigit", "method_implementation": "{\n    if (src.length == 0) {\n        throw new IllegalArgumentException(\"Cannot convert an empty array.\");\n    }\n    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n        if (src[srcPos + 2]) {\n            if (src[srcPos + 1]) {\n                return src[srcPos] ? 'f' : 'e';\n            }\n            return src[srcPos] ? 'd' : 'c';\n        }\n        if (src[srcPos + 1]) {\n            return src[srcPos] ? 'b' : 'a';\n        }\n        return src[srcPos] ? '9' : '8';\n    }\n    if (src.length > srcPos + 2 && src[srcPos + 2]) {\n        if (src[srcPos + 1]) {\n            return src[srcPos] ? '7' : '6';\n        }\n        return src[srcPos] ? '5' : '4';\n    }\n    if (src.length > srcPos + 1 && src[srcPos + 1]) {\n        return src[srcPos] ? '3' : '2';\n    }\n    return src[srcPos] ? '1' : '0';\n}", "repo_id": "8", "comment": "/**\n * Converts binary (represented as boolean array) to a hexadecimal digit using the default\n * (Lsb0) bit ordering.\n *\n * <p>\n * (1, 0, 0, 0) is converted as follow: '1'\n * </p>\n *\n * @param src the binary to convert\n * @param srcPos the position of the lsb to start the conversion\n * @return a hexadecimal digit representing the selected bits\n * @throws IllegalArgumentException if {@code src} is empty\n * @throws NullPointerException if {@code src} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 781, "method_signature": "char binaryToHexDigit(boolean[], int)", "filename": "Conversion.binaryToHexDigit.json"}
{"callee_method_names": [], "method_name": "Conversion.binaryToHexDigitMsb0_4bits", "method_implementation": "{\n    if (src.length > 8) {\n        throw new IllegalArgumentException(\"src.length>8: src.length=\" + src.length);\n    }\n    if (src.length - srcPos < 4) {\n        throw new IllegalArgumentException(\"src.length-srcPos<4: src.length=\" + src.length + \", srcPos=\" + srcPos);\n    }\n    if (src[srcPos + 3]) {\n        if (src[srcPos + 2]) {\n            if (src[srcPos + 1]) {\n                return src[srcPos] ? 'f' : '7';\n            }\n            return src[srcPos] ? 'b' : '3';\n        }\n        if (src[srcPos + 1]) {\n            return src[srcPos] ? 'd' : '5';\n        }\n        return src[srcPos] ? '9' : '1';\n    }\n    if (src[srcPos + 2]) {\n        if (src[srcPos + 1]) {\n            return src[srcPos] ? 'e' : '6';\n        }\n        return src[srcPos] ? 'a' : '2';\n    }\n    if (src[srcPos + 1]) {\n        return src[srcPos] ? 'c' : '4';\n    }\n    return src[srcPos] ? '8' : '0';\n}", "repo_id": "8", "comment": "/**\n * Converts binary (represented as boolean array) to a hexadecimal digit using the Msb0 bit\n * ordering.\n *\n * <p>\n * (1, 0, 0, 0) is converted as follow: '8' (1, 0, 0, 1, 1, 0, 1, 0) with srcPos = 3 is converted\n * to 'D'\n * </p>\n *\n * @param src the binary to convert\n * @param srcPos the position of the lsb to start the conversion\n * @return a hexadecimal digit representing the selected bits\n * @throws IllegalArgumentException if {@code src} is empty, {@code src.length > 8} or\n *             {@code src.length - srcPos < 4}\n * @throws NullPointerException if {@code src} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 782, "method_signature": "char binaryToHexDigitMsb0_4bits(boolean[], int)", "filename": "Conversion.binaryToHexDigitMsb0_4bits.json"}
{"callee_method_names": [], "method_name": "Conversion.binaryToInt", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts binary (represented as boolean array) into an int using the default (little\n * endian, Lsb0) byte and bit ordering.\n *\n * @param src the binary to convert\n * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination int\n * @param dstPos the position of the lsb, in bits, in the result int\n * @param nBools the number of booleans to convert\n * @return an int containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 783, "method_signature": "int binaryToInt(boolean[], int, int, int, int)", "filename": "Conversion.binaryToInt.json"}
{"callee_method_names": [], "method_name": "Conversion.binaryToLong", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final long bits = (src[i + srcPos] ? 1L : 0) << shift;\n        final long mask = 0x1L << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts binary (represented as boolean array) into a long using the default (little\n * endian, Lsb0) byte and bit ordering.\n *\n * @param src the binary to convert\n * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination long\n * @param dstPos the position of the lsb, in bits, in the result long\n * @param nBools the number of booleans to convert\n * @return a long containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 784, "method_signature": "long binaryToLong(boolean[], int, long, int, int)", "filename": "Conversion.binaryToLong.json"}
{"callee_method_names": [], "method_name": "Conversion.binaryToShort", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 16) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 16\");\n    }\n    short out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (short) ((out & ~mask) | bits);\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts binary (represented as boolean array) into a short using the default (little\n * endian, Lsb0) byte and bit ordering.\n *\n * @param src the binary to convert\n * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination short\n * @param dstPos the position of the lsb, in bits, in the result short\n * @param nBools the number of booleans to convert\n * @return a short containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 785, "method_signature": "short binaryToShort(boolean[], int, short, int, int)", "filename": "Conversion.binaryToShort.json"}
{"callee_method_names": [], "method_name": "Conversion.byteArrayToInt", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nBytes) {\n        return dstInit;\n    }\n    if ((nBytes - 1) * 8 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + dstPos;\n        final int bits = (0xff & src[i + srcPos]) << shift;\n        final int mask = 0xff << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of byte into an int using the default (little-endian, Lsb0) byte and bit\n * ordering.\n *\n * @param src the byte array to convert\n * @param srcPos the position in {@code src}, in byte unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination int\n * @param dstPos the position of the lsb, in bits, in the result int\n * @param nBytes the number of bytes to convert\n * @return an int containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 786, "method_signature": "int byteArrayToInt(byte[], int, int, int, int)", "filename": "Conversion.byteArrayToInt.json"}
{"callee_method_names": [], "method_name": "Conversion.byteArrayToLong", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nBytes) {\n        return dstInit;\n    }\n    if ((nBytes - 1) * 8 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + dstPos;\n        final long bits = (0xffL & src[i + srcPos]) << shift;\n        final long mask = 0xffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of byte into a long using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the byte array to convert\n * @param srcPos the position in {@code src}, in byte unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination long\n * @param dstPos the position of the lsb, in bits, in the result long\n * @param nBytes the number of bytes to convert\n * @return a long containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 787, "method_signature": "long byteArrayToLong(byte[], int, long, int, int)", "filename": "Conversion.byteArrayToLong.json"}
{"callee_method_names": [], "method_name": "Conversion.byteArrayToShort", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nBytes) {\n        return dstInit;\n    }\n    if ((nBytes - 1) * 8 + dstPos >= 16) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 16\");\n    }\n    short out = dstInit;\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + dstPos;\n        final int bits = (0xff & src[i + srcPos]) << shift;\n        final int mask = 0xff << shift;\n        out = (short) ((out & ~mask) | bits);\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of byte into a short using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the byte array to convert\n * @param srcPos the position in {@code src}, in byte unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination short\n * @param dstPos the position of the lsb, in bits, in the result short\n * @param nBytes the number of bytes to convert\n * @return a short containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 16}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 788, "method_signature": "short byteArrayToShort(byte[], int, short, int, int)", "filename": "Conversion.byteArrayToShort.json"}
{"callee_method_names": [], "method_name": "Conversion.byteArrayToUuid", "method_implementation": "{\n    if (src.length - srcPos < 16) {\n        throw new IllegalArgumentException(\"Need at least 16 bytes for UUID\");\n    }\n    return new UUID(byteArrayToLong(src, srcPos, 0, 0, 8), byteArrayToLong(src, srcPos + 8, 0, 0, 8));\n}", "repo_id": "8", "comment": "/**\n * Converts bytes from an array into a UUID using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the byte array to convert\n * @param srcPos the position in {@code src} where to copy the result from\n * @return a UUID\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if array does not contain at least 16 bytes beginning\n *             with {@code srcPos}\n */\n", "repo_name": "commons-lang-master/", "id": 789, "method_signature": "UUID byteArrayToUuid(byte[], int)", "filename": "Conversion.byteArrayToUuid.json"}
{"callee_method_names": [], "method_name": "Conversion.byteToBinary", "method_implementation": "{\n    if (0 == nBools) {\n        return dst;\n    }\n    if (nBools - 1 + srcPos >= 8) {\n        throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 8\");\n    }\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + srcPos;\n        dst[dstPos + i] = (0x1 & (src >> shift)) != 0;\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts a byte into an array of boolean using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the byte to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n *            the width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 8}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 790, "method_signature": "boolean[] byteToBinary(byte, int, boolean[], int, int)", "filename": "Conversion.byteToBinary.json"}
{"callee_method_names": ["StringBuilder.length", "StringBuilder.append", "StringBuilder.setCharAt", "StringBuilder.toString"], "method_name": "Conversion.byteToHex", "method_implementation": "{\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 8) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 8\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = 0xF & (src >> shift);\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}", "repo_id": "8", "comment": "/**\n * Converts a byte into an array of Char using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the byte to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dstInit the initial value for the result String\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 8}\n * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n */\n", "repo_name": "commons-lang-master/", "id": 791, "method_signature": "String byteToHex(byte, int, String, int, int)", "filename": "Conversion.byteToHex.json"}
{"callee_method_names": ["boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone"], "method_name": "Conversion.hexDigitMsb0ToBinary", "method_implementation": "{\n    switch(hexDigit) {\n        case '0':\n            return FFFF.clone();\n        case '1':\n            return FFFT.clone();\n        case '2':\n            return FFTF.clone();\n        case '3':\n            return FFTT.clone();\n        case '4':\n            return FTFF.clone();\n        case '5':\n            return FTFT.clone();\n        case '6':\n            return FTTF.clone();\n        case '7':\n            return FTTT.clone();\n        case '8':\n            return TFFF.clone();\n        case '9':\n            return TFFT.clone();\n        // fall through\n        case 'a':\n        case 'A':\n            return TFTF.clone();\n        // fall through\n        case 'b':\n        case 'B':\n            return TFTT.clone();\n        // fall through\n        case 'c':\n        case 'C':\n            return TTFF.clone();\n        // fall through\n        case 'd':\n        case 'D':\n            return TTFT.clone();\n        // fall through\n        case 'e':\n        case 'E':\n            return TTTF.clone();\n        // fall through\n        case 'f':\n        case 'F':\n            return TTTT.clone();\n        default:\n            throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Converts a hexadecimal digit into binary (represented as boolean array) using the Msb0\n * bit ordering.\n *\n * <p>\n * '1' is converted as follow: (0, 0, 0, 1)\n * </p>\n *\n * @param hexDigit the hexadecimal digit to convert\n * @return a boolean array with the binary representation of {@code hexDigit}\n * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n */\n", "repo_name": "commons-lang-master/", "id": 792, "method_signature": "boolean[] hexDigitMsb0ToBinary(char)", "filename": "Conversion.hexDigitMsb0ToBinary.json"}
{"callee_method_names": [], "method_name": "Conversion.hexDigitMsb0ToInt", "method_implementation": "{\n    switch(hexDigit) {\n        case '0':\n            return 0x0;\n        case '1':\n            return 0x8;\n        case '2':\n            return 0x4;\n        case '3':\n            return 0xC;\n        case '4':\n            return 0x2;\n        case '5':\n            return 0xA;\n        case '6':\n            return 0x6;\n        case '7':\n            return 0xE;\n        case '8':\n            return 0x1;\n        case '9':\n            return 0x9;\n        // fall through\n        case 'a':\n        case 'A':\n            return 0x5;\n        // fall through\n        case 'b':\n        case 'B':\n            return 0xD;\n        // fall through\n        case 'c':\n        case 'C':\n            return 0x3;\n        // fall through\n        case 'd':\n        case 'D':\n            return 0xB;\n        // fall through\n        case 'e':\n        case 'E':\n            return 0x7;\n        // fall through\n        case 'f':\n        case 'F':\n            return 0xF;\n        default:\n            throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Converts a hexadecimal digit into an int using the Msb0 bit ordering.\n *\n * <p>\n * '1' is converted to 8\n * </p>\n *\n * @param hexDigit the hexadecimal digit to convert\n * @return an int equals to {@code hexDigit}\n * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n */\n", "repo_name": "commons-lang-master/", "id": 793, "method_signature": "int hexDigitMsb0ToInt(char)", "filename": "Conversion.hexDigitMsb0ToInt.json"}
{"callee_method_names": ["boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone", "boolean[].clone"], "method_name": "Conversion.hexDigitToBinary", "method_implementation": "{\n    switch(hexDigit) {\n        case '0':\n            return FFFF.clone();\n        case '1':\n            return TFFF.clone();\n        case '2':\n            return FTFF.clone();\n        case '3':\n            return TTFF.clone();\n        case '4':\n            return FFTF.clone();\n        case '5':\n            return TFTF.clone();\n        case '6':\n            return FTTF.clone();\n        case '7':\n            return TTTF.clone();\n        case '8':\n            return FFFT.clone();\n        case '9':\n            return TFFT.clone();\n        // fall through\n        case 'a':\n        case 'A':\n            return FTFT.clone();\n        // fall through\n        case 'b':\n        case 'B':\n            return TTFT.clone();\n        // fall through\n        case 'c':\n        case 'C':\n            return FFTT.clone();\n        // fall through\n        case 'd':\n        case 'D':\n            return TFTT.clone();\n        // fall through\n        case 'e':\n        case 'E':\n            return FTTT.clone();\n        // fall through\n        case 'f':\n        case 'F':\n            return TTTT.clone();\n        default:\n            throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Converts a hexadecimal digit into binary (represented as boolean array) using the default\n * (Lsb0) bit ordering.\n *\n * <p>\n * '1' is converted as follow: (1, 0, 0, 0)\n * </p>\n *\n * @param hexDigit the hexadecimal digit to convert\n * @return a boolean array with the binary representation of {@code hexDigit}\n * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n */\n", "repo_name": "commons-lang-master/", "id": 794, "method_signature": "boolean[] hexDigitToBinary(char)", "filename": "Conversion.hexDigitToBinary.json"}
{"callee_method_names": [], "method_name": "Conversion.hexDigitToInt", "method_implementation": "{\n    final int digit = Character.digit(hexDigit, 16);\n    if (digit < 0) {\n        throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n    }\n    return digit;\n}", "repo_id": "8", "comment": "/**\n * Converts a hexadecimal digit into an int using the default (Lsb0) bit ordering.\n *\n * <p>\n * '1' is converted to 1\n * </p>\n *\n * @param hexDigit the hexadecimal digit to convert\n * @return an int equals to {@code hexDigit}\n * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n */\n", "repo_name": "commons-lang-master/", "id": 795, "method_signature": "int hexDigitToInt(char)", "filename": "Conversion.hexDigitToInt.json"}
{"callee_method_names": ["String.charAt"], "method_name": "Conversion.hexToByte", "method_implementation": "{\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 8) {\n        throw new IllegalArgumentException(\"(nHex-1)*4+dstPos is greater than or equal to 8\");\n    }\n    byte out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (byte) ((out & ~mask) | bits);\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts a hexadecimal string into a byte using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the hexadecimal string to convert\n * @param srcPos the position in {@code src}, in Char unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination byte\n * @param dstPos the position of the lsb, in bits, in the result byte\n * @param nHex the number of Chars to convert\n * @return a byte containing the selected bits\n * @throws IllegalArgumentException if {@code (nHex-1)*4+dstPos >= 8}\n */\n", "repo_name": "commons-lang-master/", "id": 796, "method_signature": "byte hexToByte(String, int, byte, int, int)", "filename": "Conversion.hexToByte.json"}
{"callee_method_names": ["String.charAt"], "method_name": "Conversion.hexToInt", "method_implementation": "{\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of Char into an int using the default (little-endian, Lsb0) byte and bit\n * ordering.\n *\n * @param src the hexadecimal string to convert\n * @param srcPos the position in {@code src}, in Char unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination int\n * @param dstPos the position of the lsb, in bits, in the result int\n * @param nHex the number of Chars to convert\n * @return an int containing the selected bits\n * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}\n */\n", "repo_name": "commons-lang-master/", "id": 797, "method_signature": "int hexToInt(String, int, int, int, int)", "filename": "Conversion.hexToInt.json"}
{"callee_method_names": ["String.charAt"], "method_name": "Conversion.hexToLong", "method_implementation": "{\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final long mask = 0xfL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of Char into a long using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the hexadecimal string to convert\n * @param srcPos the position in {@code src}, in Char unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination long\n * @param dstPos the position of the lsb, in bits, in the result long\n * @param nHex the number of Chars to convert\n * @return a long containing the selected bits\n * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}\n */\n", "repo_name": "commons-lang-master/", "id": 798, "method_signature": "long hexToLong(String, int, long, int, int)", "filename": "Conversion.hexToLong.json"}
{"callee_method_names": ["String.charAt"], "method_name": "Conversion.hexToShort", "method_implementation": "{\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 16) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 16\");\n    }\n    short out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (short) ((out & ~mask) | bits);\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of Char into a short using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the hexadecimal string to convert\n * @param srcPos the position in {@code src}, in Char unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination short\n * @param dstPos the position of the lsb, in bits, in the result short\n * @param nHex the number of Chars to convert\n * @return a short containing the selected bits\n * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}\n */\n", "repo_name": "commons-lang-master/", "id": 799, "method_signature": "short hexToShort(String, int, short, int, int)", "filename": "Conversion.hexToShort.json"}
{"callee_method_names": [], "method_name": "Conversion.intArrayToLong", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nInts) {\n        return dstInit;\n    }\n    if ((nInts - 1) * 32 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nInts-1)*32+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nInts; i++) {\n        final int shift = i * 32 + dstPos;\n        final long bits = (0xffffffffL & src[i + srcPos]) << shift;\n        final long mask = 0xffffffffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of int into a long using the default (little-endian, Lsb0) byte and bit\n * ordering.\n *\n * @param src the int array to convert\n * @param srcPos the position in {@code src}, in int unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination long\n * @param dstPos the position of the lsb, in bits, in the result long\n * @param nInts the number of ints to convert\n * @return a long containing the selected bits\n * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nInts > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 800, "method_signature": "long intArrayToLong(int[], int, long, int, int)", "filename": "Conversion.intArrayToLong.json"}
{"callee_method_names": [], "method_name": "Conversion.intToBinary", "method_implementation": "{\n    if (0 == nBools) {\n        return dst;\n    }\n    if (nBools - 1 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 32\");\n    }\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + srcPos;\n        dst[dstPos + i] = (0x1 & (src >> shift)) != 0;\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts an int into an array of boolean using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the int to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n *            the width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 32}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 801, "method_signature": "boolean[] intToBinary(int, int, boolean[], int, int)", "filename": "Conversion.intToBinary.json"}
{"callee_method_names": [], "method_name": "Conversion.intToByteArray", "method_implementation": "{\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 32\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts an int into an array of byte using the default (little-endian, Lsb0) byte and bit\n * ordering.\n *\n * @param src the int to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 802, "method_signature": "byte[] intToByteArray(int, int, byte[], int, int)", "filename": "Conversion.intToByteArray.json"}
{"callee_method_names": ["StringBuilder.length", "StringBuilder.append", "StringBuilder.setCharAt", "StringBuilder.toString"], "method_name": "Conversion.intToHex", "method_implementation": "{\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 32\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = 0xF & (src >> shift);\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}", "repo_id": "8", "comment": "/**\n * Converts an int into an array of Char using the default (little-endian, Lsb0) byte and bit\n * ordering.\n *\n * @param src the int to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dstInit the initial value for the result String\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 32}\n * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n */\n", "repo_name": "commons-lang-master/", "id": 803, "method_signature": "String intToHex(int, int, String, int, int)", "filename": "Conversion.intToHex.json"}
{"callee_method_names": [], "method_name": "Conversion.intToHexDigit", "method_implementation": "{\n    final char c = Character.forDigit(nibble, 16);\n    if (c == Character.MIN_VALUE) {\n        throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n    }\n    return c;\n}", "repo_id": "8", "comment": "/**\n * Converts the 4 lsb of an int to a hexadecimal digit.\n *\n * <p>\n * 0 returns '0'\n * </p>\n * <p>\n * 1 returns '1'\n * </p>\n * <p>\n * 10 returns 'A' and so on...\n * </p>\n *\n * @param nibble the 4 bits to convert\n * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}\n */\n", "repo_name": "commons-lang-master/", "id": 804, "method_signature": "char intToHexDigit(int)", "filename": "Conversion.intToHexDigit.json"}
{"callee_method_names": [], "method_name": "Conversion.intToHexDigitMsb0", "method_implementation": "{\n    switch(nibble) {\n        case 0x0:\n            return '0';\n        case 0x1:\n            return '8';\n        case 0x2:\n            return '4';\n        case 0x3:\n            return 'c';\n        case 0x4:\n            return '2';\n        case 0x5:\n            return 'a';\n        case 0x6:\n            return '6';\n        case 0x7:\n            return 'e';\n        case 0x8:\n            return '1';\n        case 0x9:\n            return '9';\n        case 0xA:\n            return '5';\n        case 0xB:\n            return 'd';\n        case 0xC:\n            return '3';\n        case 0xD:\n            return 'b';\n        case 0xE:\n            return '7';\n        case 0xF:\n            return 'f';\n        default:\n            throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n    }\n}", "repo_id": "8", "comment": "/**\n * Converts the 4 lsb of an int to a hexadecimal digit encoded using the Msb0 bit ordering.\n *\n * <p>\n * 0 returns '0'\n * </p>\n * <p>\n * 1 returns '8'\n * </p>\n * <p>\n * 10 returns '5' and so on...\n * </p>\n *\n * @param nibble the 4 bits to convert\n * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}\n */\n", "repo_name": "commons-lang-master/", "id": 805, "method_signature": "char intToHexDigitMsb0(int)", "filename": "Conversion.intToHexDigitMsb0.json"}
{"callee_method_names": [], "method_name": "Conversion.intToShortArray", "method_implementation": "{\n    if (0 == nShorts) {\n        return dst;\n    }\n    if ((nShorts - 1) * 16 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 32\");\n    }\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + srcPos;\n        dst[dstPos + i] = (short) (0xffff & (src >> shift));\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts an int into an array of short using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the int to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n *            the width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 806, "method_signature": "short[] intToShortArray(int, int, short[], int, int)", "filename": "Conversion.intToShortArray.json"}
{"callee_method_names": [], "method_name": "Conversion.longToBinary", "method_implementation": "{\n    if (0 == nBools) {\n        return dst;\n    }\n    if (nBools - 1 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + srcPos;\n        dst[dstPos + i] = (0x1 & (src >> shift)) != 0;\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts a long into an array of boolean using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the long to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n *            the width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 64}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 807, "method_signature": "boolean[] longToBinary(long, int, boolean[], int, int)", "filename": "Conversion.longToBinary.json"}
{"callee_method_names": [], "method_name": "Conversion.longToByteArray", "method_implementation": "{\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts a long into an array of byte using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the long to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 808, "method_signature": "byte[] longToByteArray(long, int, byte[], int, int)", "filename": "Conversion.longToByteArray.json"}
{"callee_method_names": ["StringBuilder.length", "StringBuilder.append", "StringBuilder.setCharAt", "StringBuilder.toString"], "method_name": "Conversion.longToHex", "method_implementation": "{\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 64\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = (int) (0xF & (src >> shift));\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}", "repo_id": "8", "comment": "/**\n * Converts a long into an array of Char using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the long to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dstInit the initial value for the result String\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}\n * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n */\n", "repo_name": "commons-lang-master/", "id": 809, "method_signature": "String longToHex(long, int, String, int, int)", "filename": "Conversion.longToHex.json"}
{"callee_method_names": [], "method_name": "Conversion.longToIntArray", "method_implementation": "{\n    if (0 == nInts) {\n        return dst;\n    }\n    if ((nInts - 1) * 32 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nInts-1)*32+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nInts; i++) {\n        final int shift = i * 32 + srcPos;\n        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts a long into an array of int using the default (little-endian, Lsb0) byte and bit\n * ordering.\n *\n * @param src the long to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nInts the number of ints to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null} and {@code nInts > 0}\n * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nInts > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 810, "method_signature": "int[] longToIntArray(long, int, int[], int, int)", "filename": "Conversion.longToIntArray.json"}
{"callee_method_names": [], "method_name": "Conversion.longToShortArray", "method_implementation": "{\n    if (0 == nShorts) {\n        return dst;\n    }\n    if ((nShorts - 1) * 16 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + srcPos;\n        dst[dstPos + i] = (short) (0xffff & (src >> shift));\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts a long into an array of short using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the long to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n *            the width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 811, "method_signature": "short[] longToShortArray(long, int, short[], int, int)", "filename": "Conversion.longToShortArray.json"}
{"callee_method_names": [], "method_name": "Conversion.shortArrayToInt", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nShorts) {\n        return dstInit;\n    }\n    if ((nShorts - 1) * 16 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + dstPos;\n        final int bits = (0xffff & src[i + srcPos]) << shift;\n        final int mask = 0xffff << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of short into an int using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the short array to convert\n * @param srcPos the position in {@code src}, in short unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination int\n * @param dstPos the position of the lsb, in bits, in the result int\n * @param nShorts the number of shorts to convert\n * @return an int containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 812, "method_signature": "int shortArrayToInt(short[], int, int, int, int)", "filename": "Conversion.shortArrayToInt.json"}
{"callee_method_names": [], "method_name": "Conversion.shortArrayToLong", "method_implementation": "{\n    if (src.length == 0 && srcPos == 0 || 0 == nShorts) {\n        return dstInit;\n    }\n    if ((nShorts - 1) * 16 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + dstPos;\n        final long bits = (0xffffL & src[i + srcPos]) << shift;\n        final long mask = 0xffffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}", "repo_id": "8", "comment": "/**\n * Converts an array of short into a long using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the short array to convert\n * @param srcPos the position in {@code src}, in short unit, from where to start the\n *            conversion\n * @param dstInit initial value of the destination long\n * @param dstPos the position of the lsb, in bits, in the result long\n * @param nShorts the number of shorts to convert\n * @return a long containing the selected bits\n * @throws NullPointerException if {@code src} is {@code null}\n * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}\n * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n */\n", "repo_name": "commons-lang-master/", "id": 813, "method_signature": "long shortArrayToLong(short[], int, long, int, int)", "filename": "Conversion.shortArrayToLong.json"}
{"callee_method_names": [], "method_name": "Conversion.shortToBinary", "method_implementation": "{\n    if (0 == nBools) {\n        return dst;\n    }\n    if (nBools - 1 + srcPos >= 16) {\n        throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 16\");\n    }\n    assert (nBools - 1) < 16 - srcPos;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + srcPos;\n        dst[dstPos + i] = (0x1 & (src >> shift)) != 0;\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts a short into an array of boolean using the default (little-endian, Lsb0) byte\n * and bit ordering.\n *\n * @param src the short to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n *            the width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 16}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 814, "method_signature": "boolean[] shortToBinary(short, int, boolean[], int, int)", "filename": "Conversion.shortToBinary.json"}
{"callee_method_names": [], "method_name": "Conversion.shortToByteArray", "method_implementation": "{\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 16) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 16\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts a short into an array of byte using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the short to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 815, "method_signature": "byte[] shortToByteArray(short, int, byte[], int, int)", "filename": "Conversion.shortToByteArray.json"}
{"callee_method_names": ["StringBuilder.length", "StringBuilder.append", "StringBuilder.setCharAt", "StringBuilder.toString"], "method_name": "Conversion.shortToHex", "method_implementation": "{\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 16) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 16\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = 0xF & (src >> shift);\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}", "repo_id": "8", "comment": "/**\n * Converts a short into an array of Char using the default (little-endian, Lsb0) byte and\n * bit ordering.\n *\n * @param src the short to convert\n * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n * @param dstInit the initial value for the result String\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}\n * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n */\n", "repo_name": "commons-lang-master/", "id": 816, "method_signature": "String shortToHex(short, int, String, int, int)", "filename": "Conversion.shortToHex.json"}
{"callee_method_names": ["UUID.getMostSignificantBits", "UUID.getLeastSignificantBits"], "method_name": "Conversion.uuidToByteArray", "method_implementation": "{\n    if (0 == nBytes) {\n        return dst;\n    }\n    if (nBytes > 16) {\n        throw new IllegalArgumentException(\"nBytes is greater than 16\");\n    }\n    longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, Math.min(nBytes, 8));\n    if (nBytes >= 8) {\n        longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8);\n    }\n    return dst;\n}", "repo_id": "8", "comment": "/**\n * Converts UUID into an array of byte using the default (little-endian, Lsb0) byte and bit\n * ordering.\n *\n * @param src the UUID to convert\n * @param dst the destination array\n * @param dstPos the position in {@code dst} where to copy the result\n * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n *            width of the input (from srcPos to msb)\n * @return {@code dst}\n * @throws NullPointerException if {@code dst} is {@code null}\n * @throws IllegalArgumentException if {@code nBytes > 16}\n * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n */\n", "repo_name": "commons-lang-master/", "id": 817, "method_signature": "byte[] uuidToByteArray(UUID, byte[], int, int)", "filename": "Conversion.uuidToByteArray.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryBeMsb0ToHexDigit", "method_implementation": "{\n    assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false }));\n    assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true }));\n    assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false }));\n    assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, true }));\n    assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false }));\n    assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true }));\n    assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false }));\n    assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true }));\n    assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false }));\n    assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true }));\n    assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false }));\n    assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true }));\n    assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, true, false, false }));\n    assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, true, false, true }));\n    assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, true, true, false }));\n    assertEquals('f', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, true, true, true }));\n    assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false }));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.binaryBeMsb0ToHexDigit(new boolean[] {}));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToHexDigit(boolean[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 1371, "method_signature": "void testBinaryBeMsb0ToHexDigit()", "filename": "ConversionTest.testBinaryBeMsb0ToHexDigit.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryBeMsb0ToHexDigit_2args", "method_implementation": "{\n    assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false }, 2));\n    final boolean[] shortArray = { true, true, false };\n    assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(shortArray, 0));\n    assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray, 1));\n    assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray, 2));\n    final boolean[] shortArray2 = { true, true, true, false, false, true, false, true };\n    assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 0));\n    assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 1));\n    assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 2));\n    assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 3));\n    assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 4));\n    assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 5));\n    assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 6));\n    assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 7));\n    final boolean[] multiBytesArray = { true, true, false, false, true, false, true, false, true, true, true, false, false, true, false, true };\n    assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 0));\n    assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 1));\n    assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 2));\n    assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 3));\n    assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 4));\n    assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 5));\n    assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 6));\n    assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 7));\n    assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 8));\n    assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 9));\n    assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 10));\n    assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 11));\n    assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 12));\n    assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 13));\n    assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 14));\n    assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 15));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1372, "method_signature": "void testBinaryBeMsb0ToHexDigit_2args()", "filename": "ConversionTest.testBinaryBeMsb0ToHexDigit_2args.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToByte", "method_implementation": "{\n    final boolean[] src = { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals((byte) 0x00, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 0 * 4));\n    assertEquals((byte) 0x0C, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 1 * 4));\n    assertEquals((byte) 0xDC, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 2 * 4));\n    assertEquals((byte) 0xFD, Conversion.binaryToByte(src, 1 * 4, (byte) 0, 0, 2 * 4));\n    assertEquals((byte) 0x34, Conversion.binaryToByte(src, 0 * 4, (byte) 0x34, 0, 0 * 4));\n    assertEquals((byte) 0x84, Conversion.binaryToByte(src, 17 * 4, (byte) 0x34, 4, 1 * 4));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToByte(boolean[], int, byte, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1373, "method_signature": "void testBinaryToByte()", "filename": "ConversionTest.testBinaryToByte.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToHexDigit", "method_implementation": "{\n    assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false }));\n    assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false }));\n    assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false }));\n    assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false }));\n    assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, false, true, false }));\n    assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false }));\n    assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false }));\n    assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false }));\n    assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true }));\n    assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, true }));\n    assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true }));\n    assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, true, false, true }));\n    assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, false, true, true }));\n    assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true }));\n    assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { false, true, true, true }));\n    assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true }));\n    assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true }));\n    assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true, true }));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.binaryToHexDigit(new boolean[] {}));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToHexDigit(boolean[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 1374, "method_signature": "void testBinaryToHexDigit()", "filename": "ConversionTest.testBinaryToHexDigit.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToHexDigitMsb0_4bits_2args", "method_implementation": "{\n    // boolean[] shortArray = new boolean[]{true, true, false};\n    // assertEquals('6', Conversion.BinaryToHexDigitMsb0(shortArray, 0));\n    // assertEquals('3', Conversion.BinaryToHexDigitMsb0(shortArray, 1));\n    // assertEquals('1', Conversion.BinaryToHexDigitMsb0(shortArray, 2));\n    final boolean[] shortArray = { true, true, false, true };\n    assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(shortArray, 0));\n    final boolean[] longArray = { true, false, true, false, false, true, true };\n    assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(longArray, 0));\n    assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(longArray, 1));\n    assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(longArray, 2));\n    assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(longArray, 3));\n    // assertEquals('6', Conversion.BinaryToHexDigitMsb0(longArray, 4));\n    // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray, 5));\n    // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray, 6));\n    final boolean[] maxLengthArray = { true, false, true, false, false, true, true, true };\n    assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 0));\n    assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 1));\n    assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 2));\n    assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 3));\n    assertEquals('7', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 4));\n    // assertEquals('7', Conversion.BinaryToHexDigitMsb0(longArray, 5));\n    // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray, 6));\n    // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray, 7));\n    final boolean[] javaDocCheck = { true, false, false, true, true, false, true, false };\n    assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(javaDocCheck, 3));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToHexDigitMsb0_4bits(boolean[], int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1376, "method_signature": "void testBinaryToHexDigitMsb0_4bits_2args()", "filename": "ConversionTest.testBinaryToHexDigitMsb0_4bits_2args.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToHexDigitMsb0_bits", "method_implementation": "{\n    assertEquals('0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, false, false, false }));\n    assertEquals('1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, false, false, true }));\n    assertEquals('2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, false, true, false }));\n    assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, false, true, true }));\n    assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, true, false, false }));\n    assertEquals('5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, true, false, true }));\n    assertEquals('6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, true, true, false }));\n    assertEquals('7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { false, true, true, true }));\n    assertEquals('8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, false, false, false }));\n    assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, false, false, true }));\n    assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, false, true, false }));\n    assertEquals('b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, false, true, true }));\n    assertEquals('c', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, true, false, false }));\n    assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, true, false, true }));\n    assertEquals('e', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, true, true, false }));\n    assertEquals('f', Conversion.binaryToHexDigitMsb0_4bits(new boolean[] { true, true, true, true }));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.binaryToHexDigitMsb0_4bits(new boolean[] {}));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToHexDigitMsb0_4bits(boolean[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 1377, "method_signature": "void testBinaryToHexDigitMsb0_bits()", "filename": "ConversionTest.testBinaryToHexDigitMsb0_bits.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToHexDigit_2args", "method_implementation": "{\n    final boolean[] shortArray = { false, true, true };\n    assertEquals('6', Conversion.binaryToHexDigit(shortArray, 0));\n    assertEquals('3', Conversion.binaryToHexDigit(shortArray, 1));\n    assertEquals('1', Conversion.binaryToHexDigit(shortArray, 2));\n    final boolean[] longArray = { true, false, true, false, false, true, true };\n    assertEquals('5', Conversion.binaryToHexDigit(longArray, 0));\n    assertEquals('2', Conversion.binaryToHexDigit(longArray, 1));\n    assertEquals('9', Conversion.binaryToHexDigit(longArray, 2));\n    assertEquals('c', Conversion.binaryToHexDigit(longArray, 3));\n    assertEquals('6', Conversion.binaryToHexDigit(longArray, 4));\n    assertEquals('3', Conversion.binaryToHexDigit(longArray, 5));\n    assertEquals('1', Conversion.binaryToHexDigit(longArray, 6));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryBeMsb0ToHexDigit(boolean[], int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1375, "method_signature": "void testBinaryToHexDigit_2args()", "filename": "ConversionTest.testBinaryToHexDigit_2args.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToInt", "method_implementation": "{\n    final boolean[] src = { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals(0x00000000, Conversion.binaryToInt(src, 0 * 4, 0, 0, 0 * 4));\n    assertEquals(0x0000000C, Conversion.binaryToInt(src, 0 * 4, 0, 0, 1 * 4));\n    assertEquals(0x1C0F1FDC, Conversion.binaryToInt(src, 0 * 4, 0, 0, 8 * 4));\n    assertEquals(0x01C0F1FD, Conversion.binaryToInt(src, 1 * 4, 0, 0, 8 * 4));\n    assertEquals(0x12345679, Conversion.binaryToInt(src, 0 * 4, 0x12345679, 0, 0 * 4));\n    assertEquals(0x87645679, Conversion.binaryToInt(src, 15 * 4, 0x12345679, 20, 3 * 4));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToInt(boolean[], int, int, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1378, "method_signature": "void testBinaryToInt()", "filename": "ConversionTest.testBinaryToInt.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToLong", "method_implementation": "{\n    final boolean[] src = { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4));\n    assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4));\n    assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4));\n    assertEquals(0x123456798ABCDEF0L, Conversion.binaryToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n    assertEquals(0x1234567876BCDEF0L, Conversion.binaryToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1379, "method_signature": "void testBinaryToLong()", "filename": "ConversionTest.testBinaryToLong.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testBinaryToShort", "method_implementation": "{\n    final boolean[] src = { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals((short) 0x0000, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 0 * 4));\n    assertEquals((short) 0x000C, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 1 * 4));\n    assertEquals((short) 0x1FDC, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 4 * 4));\n    assertEquals((short) 0xF1FD, Conversion.binaryToShort(src, 1 * 4, (short) 0, 0, 4 * 4));\n    assertEquals((short) 0x1234, Conversion.binaryToShort(src, 0 * 4, (short) 0x1234, 0, 0 * 4));\n    assertEquals((short) 0x8764, Conversion.binaryToShort(src, 15 * 4, (short) 0x1234, 4, 3 * 4));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#binaryToShort(boolean[], int, short, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1380, "method_signature": "void testBinaryToShort()", "filename": "ConversionTest.testBinaryToShort.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testByteArrayToInt", "method_implementation": "{\n    final byte[] src = { (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34, (byte) 0x56, (byte) 0x78 };\n    assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0));\n    assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1));\n    assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4));\n    assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4));\n    assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0));\n    assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1));\n    // assertEquals(0x56341278, Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1381, "method_signature": "void testByteArrayToInt()", "filename": "ConversionTest.testByteArrayToInt.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testByteArrayToLong", "method_implementation": "{\n    final byte[] src = { (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34, (byte) 0x56, (byte) 0x78 };\n    assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4));\n    assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4));\n    assertEquals(0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n    assertEquals(0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));\n    assertEquals(0x123456789A7856F0L, Conversion.byteArrayToLong(src, 7, 0x123456789ABCDEF0L, 8, 2));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#byteArrayToLong(byte[], int, long, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1382, "method_signature": "void testByteArrayToLong()", "filename": "ConversionTest.testByteArrayToLong.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testByteArrayToShort", "method_implementation": "{\n    final byte[] src = { (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34, (byte) 0x56, (byte) 0x78 };\n    assertEquals((short) 0x0000, Conversion.byteArrayToShort(src, 0, (short) 0, 0, 0));\n    assertEquals((short) 0x00CD, Conversion.byteArrayToShort(src, 0, (short) 0, 0, 1));\n    assertEquals((short) 0xF1CD, Conversion.byteArrayToShort(src, 0, (short) 0, 0, 2));\n    assertEquals((short) 0xF0F1, Conversion.byteArrayToShort(src, 1, (short) 0, 0, 2));\n    assertEquals((short) 0x1234, Conversion.byteArrayToShort(src, 0, (short) 0x1234, 0, 0));\n    assertEquals((short) 0xCD34, Conversion.byteArrayToShort(src, 0, (short) 0x1234, 8, 1));\n    // assertEquals((short) 0x5678, Conversion.ByteArrayToShort(src, 7, (short) 0x0123, 8,\n    // 2));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#byteArrayToShort(byte[], int, short, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1383, "method_signature": "void testByteArrayToShort()", "filename": "ConversionTest.testByteArrayToShort.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testByteArrayToUuid", "method_implementation": "{\n    assertEquals(new UUID(0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), Conversion.byteArrayToUuid(new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff }, 0));\n    assertEquals(new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L), Conversion.byteArrayToUuid(new byte[] { (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77 }, 0));\n    assertEquals(new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L), Conversion.byteArrayToUuid(new byte[] { 0, 0, (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77 }, 2));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#byteArrayToUuid(byte[], int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1384, "method_signature": "void testByteArrayToUuid()", "filename": "ConversionTest.testByteArrayToUuid.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testByteToBinary", "method_implementation": "{\n    assertArrayEquals(new boolean[] {}, Conversion.byteToBinary((byte) 0x00, 0, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.byteToBinary((byte) 0x00, 100, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.byteToBinary((byte) 0x00, 0, new boolean[] {}, 100, 0));\n    assertArrayEquals(new boolean[69], Conversion.byteToBinary((byte) 0xEF, 0, new boolean[69], 0, 0));\n    assertArrayEquals(new boolean[] { true, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 1));\n    assertArrayEquals(new boolean[] { true, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 2));\n    assertArrayEquals(new boolean[] { true, false, true, false, false, false, false, false, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 3));\n    assertArrayEquals(new boolean[] { true, false, true, false, true, false, false, false, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 7));\n    assertArrayEquals(new boolean[] { true, false, true, false, true, false, false, true, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 8));\n    assertArrayEquals(new boolean[] { false, false, true, false, false, false, false, false, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 2, 1));\n    assertArrayEquals(new boolean[] { false, false, true, false, true, false, true, false, false, true, false, false, false }, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 2, 8));\n    assertArrayEquals(new boolean[] { false, true, false, true, false, false, true, false, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 1, new boolean[13], 0, 7));\n    assertArrayEquals(new boolean[] { true, false, true, false, false, true, false, false, false, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 2, new boolean[13], 0, 6));\n    // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,\n    // false, false, false, false, false}, Conversion.byteToBinary((byte) 0x95, 2, new\n    // boolean[13], 3, 7));//rejected by assertion\n    assertArrayEquals(new boolean[] { false, false, false, true, false, true, false, false, true, false, false, false, false }, Conversion.byteToBinary((byte) 0x95, 2, new boolean[13], 3, 6));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#byteToBinary(byte, int, boolean[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1385, "method_signature": "void testByteToBinary()", "filename": "ConversionTest.testByteToBinary.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testByteToHex", "method_implementation": "{\n    assertEquals(\"\", Conversion.byteToHex((byte) 0x00, 0, \"\", 0, 0));\n    assertEquals(\"\", Conversion.byteToHex((byte) 0x00, 100, \"\", 0, 0));\n    assertEquals(\"\", Conversion.byteToHex((byte) 0x00, 0, \"\", 100, 0));\n    assertEquals(\"00000\", Conversion.byteToHex((byte) 0xEF, 0, \"00000\", 0, 0));\n    assertEquals(\"f0000\", Conversion.byteToHex((byte) 0xEF, 0, \"00000\", 0, 1));\n    assertEquals(\"fe000\", Conversion.byteToHex((byte) 0xEF, 0, \"00000\", 0, 2));\n    assertEquals(\"000f0\", Conversion.byteToHex((byte) 0xEF, 0, \"00000\", 3, 1));\n    assertEquals(\"000fe\", Conversion.byteToHex((byte) 0xEF, 0, \"00000\", 3, 2));\n    assertEquals(\"70000\", Conversion.byteToHex((byte) 0xEF, 1, \"00000\", 0, 1));\n    assertEquals(\"b0000\", Conversion.byteToHex((byte) 0xEF, 2, \"00000\", 0, 1));\n    assertEquals(\"000df\", Conversion.byteToHex((byte) 0xEF, 3, \"00000\", 3, 2));\n    // assertEquals(\"00000\", Conversion.byteToHex((byte) 0xEF, 4, \"00000\", 3, 2));//rejected by\n    // assertion\n    assertEquals(\"000e0\", Conversion.byteToHex((byte) 0xEF, 4, \"00000\", 3, 1));\n    assertEquals(\"fe\", Conversion.byteToHex((byte) 0xEF, 0, \"\", 0, 2));\n    assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.byteToHex((byte) 0xEF, 0, \"\", 1, 2));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1386, "method_signature": "void testByteToHex()", "filename": "ConversionTest.testByteToHex.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexDigitMsb0ToBinary", "method_implementation": "{\n    assertArrayEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitMsb0ToBinary('0'));\n    assertArrayEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitMsb0ToBinary('1'));\n    assertArrayEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitMsb0ToBinary('2'));\n    assertArrayEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitMsb0ToBinary('3'));\n    assertArrayEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitMsb0ToBinary('4'));\n    assertArrayEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitMsb0ToBinary('5'));\n    assertArrayEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitMsb0ToBinary('6'));\n    assertArrayEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitMsb0ToBinary('7'));\n    assertArrayEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitMsb0ToBinary('8'));\n    assertArrayEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitMsb0ToBinary('9'));\n    assertArrayEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitMsb0ToBinary('A'));\n    assertArrayEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitMsb0ToBinary('a'));\n    assertArrayEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitMsb0ToBinary('B'));\n    assertArrayEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitMsb0ToBinary('b'));\n    assertArrayEquals(new boolean[] { true, true, false, false }, Conversion.hexDigitMsb0ToBinary('C'));\n    assertArrayEquals(new boolean[] { true, true, false, false }, Conversion.hexDigitMsb0ToBinary('c'));\n    assertArrayEquals(new boolean[] { true, true, false, true }, Conversion.hexDigitMsb0ToBinary('D'));\n    assertArrayEquals(new boolean[] { true, true, false, true }, Conversion.hexDigitMsb0ToBinary('d'));\n    assertArrayEquals(new boolean[] { true, true, true, false }, Conversion.hexDigitMsb0ToBinary('E'));\n    assertArrayEquals(new boolean[] { true, true, true, false }, Conversion.hexDigitMsb0ToBinary('e'));\n    assertArrayEquals(new boolean[] { true, true, true, true }, Conversion.hexDigitMsb0ToBinary('F'));\n    assertArrayEquals(new boolean[] { true, true, true, true }, Conversion.hexDigitMsb0ToBinary('f'));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitMsb0ToBinary('G'));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1387, "method_signature": "void testHexDigitMsb0ToBinary()", "filename": "ConversionTest.testHexDigitMsb0ToBinary.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexDigitMsb0ToInt", "method_implementation": "{\n    assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0'));\n    assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1'));\n    assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2'));\n    assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3'));\n    assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4'));\n    assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5'));\n    assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6'));\n    assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7'));\n    assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8'));\n    assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9'));\n    assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A'));\n    assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a'));\n    assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B'));\n    assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b'));\n    assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C'));\n    assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c'));\n    assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D'));\n    assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d'));\n    assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E'));\n    assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e'));\n    assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F'));\n    assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f'));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitMsb0ToInt('G'));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexDigitMsb0ToInt(char)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1388, "method_signature": "void testHexDigitMsb0ToInt()", "filename": "ConversionTest.testHexDigitMsb0ToInt.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexDigitToBinary", "method_implementation": "{\n    assertArrayEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0'));\n    assertArrayEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('1'));\n    assertArrayEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('2'));\n    assertArrayEquals(new boolean[] { true, true, false, false }, Conversion.hexDigitToBinary('3'));\n    assertArrayEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('4'));\n    assertArrayEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('5'));\n    assertArrayEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6'));\n    assertArrayEquals(new boolean[] { true, true, true, false }, Conversion.hexDigitToBinary('7'));\n    assertArrayEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('8'));\n    assertArrayEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9'));\n    assertArrayEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('A'));\n    assertArrayEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('a'));\n    assertArrayEquals(new boolean[] { true, true, false, true }, Conversion.hexDigitToBinary('B'));\n    assertArrayEquals(new boolean[] { true, true, false, true }, Conversion.hexDigitToBinary('b'));\n    assertArrayEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('C'));\n    assertArrayEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('c'));\n    assertArrayEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('D'));\n    assertArrayEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('d'));\n    assertArrayEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('E'));\n    assertArrayEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('e'));\n    assertArrayEquals(new boolean[] { true, true, true, true }, Conversion.hexDigitToBinary('F'));\n    assertArrayEquals(new boolean[] { true, true, true, true }, Conversion.hexDigitToBinary('f'));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitToBinary('G'));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexDigitToBinary(char)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1389, "method_signature": "void testHexDigitToBinary()", "filename": "ConversionTest.testHexDigitToBinary.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexDigitToInt", "method_implementation": "{\n    assertEquals(0, Conversion.hexDigitToInt('0'));\n    assertEquals(1, Conversion.hexDigitToInt('1'));\n    assertEquals(2, Conversion.hexDigitToInt('2'));\n    assertEquals(3, Conversion.hexDigitToInt('3'));\n    assertEquals(4, Conversion.hexDigitToInt('4'));\n    assertEquals(5, Conversion.hexDigitToInt('5'));\n    assertEquals(6, Conversion.hexDigitToInt('6'));\n    assertEquals(7, Conversion.hexDigitToInt('7'));\n    assertEquals(8, Conversion.hexDigitToInt('8'));\n    assertEquals(9, Conversion.hexDigitToInt('9'));\n    assertEquals(10, Conversion.hexDigitToInt('A'));\n    assertEquals(10, Conversion.hexDigitToInt('a'));\n    assertEquals(11, Conversion.hexDigitToInt('B'));\n    assertEquals(11, Conversion.hexDigitToInt('b'));\n    assertEquals(12, Conversion.hexDigitToInt('C'));\n    assertEquals(12, Conversion.hexDigitToInt('c'));\n    assertEquals(13, Conversion.hexDigitToInt('D'));\n    assertEquals(13, Conversion.hexDigitToInt('d'));\n    assertEquals(14, Conversion.hexDigitToInt('E'));\n    assertEquals(14, Conversion.hexDigitToInt('e'));\n    assertEquals(15, Conversion.hexDigitToInt('F'));\n    assertEquals(15, Conversion.hexDigitToInt('f'));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitToInt('G'));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexDigitToInt(char)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1390, "method_signature": "void testHexDigitToInt()", "filename": "ConversionTest.testHexDigitToInt.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexToByte", "method_implementation": "{\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals((byte) 0x00, Conversion.hexToByte(src, 0, (byte) 0, 0, 0));\n    assertEquals((byte) 0x0C, Conversion.hexToByte(src, 0, (byte) 0, 0, 1));\n    assertEquals((byte) 0xDC, Conversion.hexToByte(src, 0, (byte) 0, 0, 2));\n    assertEquals((byte) 0xFD, Conversion.hexToByte(src, 1, (byte) 0, 0, 2));\n    assertEquals((byte) 0x34, Conversion.hexToByte(src, 0, (byte) 0x34, 0, 0));\n    assertEquals((byte) 0x84, Conversion.hexToByte(src, 17, (byte) 0x34, 4, 1));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1391, "method_signature": "void testHexToByte()", "filename": "ConversionTest.testHexToByte.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexToInt", "method_implementation": "{\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0));\n    assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1));\n    assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8));\n    assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8));\n    assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0));\n    assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexToInt(String, int, int, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1392, "method_signature": "void testHexToInt()", "filename": "ConversionTest.testHexToInt.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexToLong", "method_implementation": "{\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8));\n    assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8));\n    assertEquals(0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n    assertEquals(0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexToLong(String, int, long, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1393, "method_signature": "void testHexToLong()", "filename": "ConversionTest.testHexToLong.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testHexToShort", "method_implementation": "{\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals((short) 0x0000, Conversion.hexToShort(src, 0, (short) 0, 0, 0));\n    assertEquals((short) 0x000C, Conversion.hexToShort(src, 0, (short) 0, 0, 1));\n    assertEquals((short) 0x1FDC, Conversion.hexToShort(src, 0, (short) 0, 0, 4));\n    assertEquals((short) 0xF1FD, Conversion.hexToShort(src, 1, (short) 0, 0, 4));\n    assertEquals((short) 0x1234, Conversion.hexToShort(src, 0, (short) 0x1234, 0, 0));\n    assertEquals((short) 0x8764, Conversion.hexToShort(src, 15, (short) 0x1234, 4, 3));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#hexToShort(String, int, short, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1394, "method_signature": "void testHexToShort()", "filename": "ConversionTest.testHexToShort.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testIntArrayToLong", "method_implementation": "{\n    final int[] src = { 0xCDF1F0C1, 0x0F123456, 0x78000000 };\n    assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0));\n    assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2));\n    assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1));\n    assertEquals(0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n    assertEquals(0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1));\n    // assertEquals(0x0F12345678000000L, Conversion.intsToLong(src, 1, 0x123456789ABCDEF0L, 32, 2));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1395, "method_signature": "void testIntArrayToLong()", "filename": "ConversionTest.testIntArrayToLong.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testIntToBinary", "method_implementation": "{\n    assertArrayEquals(new boolean[] {}, Conversion.intToBinary(0x00000000, 0, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.intToBinary(0x00000000, 100, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.intToBinary(0x00000000, 0, new boolean[] {}, 100, 0));\n    assertArrayEquals(new boolean[69], Conversion.intToBinary(0x90ABCDEF, 0, new boolean[69], 0, 0));\n    assertArrayEquals(new boolean[] { true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 1));\n    assertArrayEquals(new boolean[] { true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 2));\n    assertArrayEquals(new boolean[] { true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 3));\n    assertArrayEquals(new boolean[] { true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, false, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 31));\n    assertArrayEquals(new boolean[] { true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 32));\n    assertArrayEquals(new boolean[] { false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 2, 1));\n    assertArrayEquals(new boolean[] { false, false, true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 2, 32));\n    assertArrayEquals(new boolean[] { true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 1, new boolean[37], 0, 31));\n    assertArrayEquals(new boolean[] { true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37], 0, 30));\n    // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true,\n    // true,\n    // true, true, false, true, true, false, false, true, true, true, true, false, true,\n    // false, true, false, true, false, false, false, false, true, false, false, false,\n    // false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37],\n    // 3, 31));//rejected by assertion\n    assertArrayEquals(new boolean[] { false, false, false, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false }, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37], 3, 30));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#intToBinary(int, int, boolean[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1396, "method_signature": "void testIntToBinary()", "filename": "ConversionTest.testIntToBinary.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testIntToByteArray", "method_implementation": "{\n    assertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 0, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 100, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 0, new byte[] {}, 100, 0));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n    assertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n    // assertArrayEquals(new\n    // byte[]{(byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0x00, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF}, Conversion.intToByteArray(0x90ABCDEF, 13, new\n    // byte[]{-1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));//rejected by assertion\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 3));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#intToByteArray(int, int, byte[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1397, "method_signature": "void testIntToByteArray()", "filename": "ConversionTest.testIntToByteArray.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testIntToHex", "method_implementation": "{\n    assertEquals(\"\", Conversion.intToHex(0x00000000, 0, \"\", 0, 0));\n    assertEquals(\"\", Conversion.intToHex(0x00000000, 100, \"\", 0, 0));\n    assertEquals(\"\", Conversion.intToHex(0x00000000, 0, \"\", 100, 0));\n    assertEquals(\"ffffffffffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 0, 0));\n    assertEquals(\"3fffffffffffffffffffffff\", Conversion.intToHex(0x90ABCDE3, 0, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"feffffffffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 0, 2));\n    assertEquals(\"fedcffffffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 0, 4));\n    assertEquals(\"fedcba0fffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 0, 7));\n    assertEquals(\"fedcba09ffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 0, 8));\n    assertEquals(\"fff3ffffffffffffffffffff\", Conversion.intToHex(0x90ABCDE3, 0, \"ffffffffffffffffffffffff\", 3, 1));\n    assertEquals(\"ffffefffffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 3, 2));\n    assertEquals(\"ffffedcfffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 3, 4));\n    assertEquals(\"ffffedcba0ffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 3, 7));\n    assertEquals(\"ffffedcba09fffffffffffff\", Conversion.intToHex(0x90ABCDEF, 0, \"ffffffffffffffffffffffff\", 3, 8));\n    assertEquals(\"7fffffffffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 1, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"bfffffffffffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 2, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"fffdb97512ffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 3, \"ffffffffffffffffffffffff\", 3, 8));\n    // assertEquals(\"ffffffffffffffffffffffff\", Conversion.intToHex(0x90ABCDEF,\n    // 4, \"ffffffffffffffffffffffff\", 3, 8));//rejected by assertion\n    assertEquals(\"fffedcba09ffffffffffffff\", Conversion.intToHex(0x90ABCDEF, 4, \"ffffffffffffffffffffffff\", 3, 7));\n    assertEquals(\"fedcba09\", Conversion.intToHex(0x90ABCDEF, 0, \"\", 0, 8));\n    assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.intToHex(0x90ABCDEF, 0, \"\", 1, 8));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#intToHex(int, int, String, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1398, "method_signature": "void testIntToHex()", "filename": "ConversionTest.testIntToHex.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testIntToHexDigit", "method_implementation": "{\n    assertEquals('0', Conversion.intToHexDigit(0));\n    assertEquals('1', Conversion.intToHexDigit(1));\n    assertEquals('2', Conversion.intToHexDigit(2));\n    assertEquals('3', Conversion.intToHexDigit(3));\n    assertEquals('4', Conversion.intToHexDigit(4));\n    assertEquals('5', Conversion.intToHexDigit(5));\n    assertEquals('6', Conversion.intToHexDigit(6));\n    assertEquals('7', Conversion.intToHexDigit(7));\n    assertEquals('8', Conversion.intToHexDigit(8));\n    assertEquals('9', Conversion.intToHexDigit(9));\n    assertEquals('a', Conversion.intToHexDigit(10));\n    assertEquals('b', Conversion.intToHexDigit(11));\n    assertEquals('c', Conversion.intToHexDigit(12));\n    assertEquals('d', Conversion.intToHexDigit(13));\n    assertEquals('e', Conversion.intToHexDigit(14));\n    assertEquals('f', Conversion.intToHexDigit(15));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.intToHexDigit(16));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#intToHexDigit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1399, "method_signature": "void testIntToHexDigit()", "filename": "ConversionTest.testIntToHexDigit.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testIntToHexDigitMsb0", "method_implementation": "{\n    assertEquals('0', Conversion.intToHexDigitMsb0(0));\n    assertEquals('8', Conversion.intToHexDigitMsb0(1));\n    assertEquals('4', Conversion.intToHexDigitMsb0(2));\n    assertEquals('c', Conversion.intToHexDigitMsb0(3));\n    assertEquals('2', Conversion.intToHexDigitMsb0(4));\n    assertEquals('a', Conversion.intToHexDigitMsb0(5));\n    assertEquals('6', Conversion.intToHexDigitMsb0(6));\n    assertEquals('e', Conversion.intToHexDigitMsb0(7));\n    assertEquals('1', Conversion.intToHexDigitMsb0(8));\n    assertEquals('9', Conversion.intToHexDigitMsb0(9));\n    assertEquals('5', Conversion.intToHexDigitMsb0(10));\n    assertEquals('d', Conversion.intToHexDigitMsb0(11));\n    assertEquals('3', Conversion.intToHexDigitMsb0(12));\n    assertEquals('b', Conversion.intToHexDigitMsb0(13));\n    assertEquals('7', Conversion.intToHexDigitMsb0(14));\n    assertEquals('f', Conversion.intToHexDigitMsb0(15));\n    assertThrows(IllegalArgumentException.class, () -> Conversion.intToHexDigitMsb0(16));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#intToHexDigitMsb0(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1400, "method_signature": "void testIntToHexDigitMsb0()", "filename": "ConversionTest.testIntToHexDigitMsb0.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testIntToShortArray", "method_implementation": "{\n    assertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 0, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 100, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 0, new short[] {}, 100, 0));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new short[] { (short) 0x5678, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new short[] { (short) 0x5678, (short) 0x1234, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 2));\n    // assertArrayEquals(new\n    // short[]{(short) 0x5678, (short) 0x1234, (short) 0x5678, (short) 0xFFFF}, Conversion.intToShortArray(0x12345678,\n    // 0, new short[]{-1, -1, -1, -1}, 0, 3));//rejected by assertion\n    // assertArrayEquals(new\n    // short[]{(short) 0x5678, (short) 0x1234, (short) 0x5678, (short) 0x1234}, Conversion.intToShortArray(0x12345678,\n    // 0, new short[]{-1, -1, -1, -1}, 0, 4));\n    // assertArrayEquals(new\n    // short[]{(short) 0xFFFF, (short) 0x5678, (short) 0x1234, (short) 0x5678}, Conversion.intToShortArray(0x12345678,\n    // 0, new short[]{-1, -1, -1, -1}, 1, 3));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0x1234 }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 2, 2));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678 }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x2B3C, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 1, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x159E, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 2, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x8ACF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 3, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x4567, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 4, new short[] { -1, -1, -1, -1 }, 2, 1));\n    // assertArrayEquals(new\n    // short[]{(short) 0xE6F7, (short) 0x4855, (short) 0x2B3C, (short) 0x091A}, Conversion.intToShortArray(0x12345678,\n    // 1, new short[]{-1, -1, -1, -1}, 0, 4));//rejected by assertion\n    // assertArrayEquals(new\n    // short[]{(short) 0x2B3C}, Conversion.intToShortArray(0x12345678, 33, new\n    // short[]{0}, 0, 1));//rejected by assertion\n    assertArrayEquals(new short[] { (short) 0x091A }, Conversion.intToShortArray(0x12345678, 17, new short[] { 0 }, 0, 1));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#intToShortArray(int, int, short[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1401, "method_signature": "void testIntToShortArray()", "filename": "ConversionTest.testIntToShortArray.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testLongToBinary", "method_implementation": "{\n    assertArrayEquals(new boolean[] {}, Conversion.longToBinary(0x0000000000000000L, 0, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.longToBinary(0x0000000000000000L, 100, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.longToBinary(0x0000000000000000L, 0, new boolean[] {}, 100, 0));\n    assertArrayEquals(new boolean[69], Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 0));\n    assertArrayEquals(new boolean[] { true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 1));\n    assertArrayEquals(new boolean[] { true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 2));\n    assertArrayEquals(new boolean[] { true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 3));\n    assertArrayEquals(new boolean[] { true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 63));\n    assertArrayEquals(new boolean[] { true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 64));\n    assertArrayEquals(new boolean[] { false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 2, 1));\n    assertArrayEquals(new boolean[] { false, false, true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 2, 64));\n    assertArrayEquals(new boolean[] { true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 1, new boolean[69], 0, 63));\n    assertArrayEquals(new boolean[] { true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 2, new boolean[69], 0, 62));\n    // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,\n    // true, true, false, true, true, false, false, true, true, true, true, false, true,\n    // false, true, false, true, false, false, false, false, true, false, false, true,\n    // false, false, false, true, true, true, true, false, false, true, true, false, true,\n    // false, true, false, false, false, true, false, true, true, false, false, false, true,\n    // false, false, true, false, false, false\n    // , false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 2, new\n    // boolean[69], 3, 63));//rejected by assertion\n    assertArrayEquals(new boolean[] { false, false, false, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false }, Conversion.longToBinary(0x1234567890ABCDEFL, 2, new boolean[69], 3, 62));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#longToBinary(long, int, boolean[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1402, "method_signature": "void testLongToBinary()", "filename": "ConversionTest.testLongToBinary.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testLongToByteArray", "method_implementation": "{\n    assertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 100, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[] {}, 100, 0));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 7));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 8));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 7));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0x12 }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 8));\n    assertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00 }, Conversion.longToByteArray(0x1234567890ABCDEFL, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 8));\n    // assertArrayEquals(new\n    // byte[]{(byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00, (byte) 0x00}, Conversion.longToByteArray(0x1234567890ABCDEFL, 13, new\n    // byte[]{-1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8));//rejected by assertion\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 7));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#longToByteArray(long, int, byte[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1403, "method_signature": "void testLongToByteArray()", "filename": "ConversionTest.testLongToByteArray.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testLongToHex", "method_implementation": "{\n    assertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 0, \"\", 0, 0));\n    assertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 100, \"\", 0, 0));\n    assertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 0, \"\", 100, 0));\n    assertEquals(\"ffffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 0));\n    assertEquals(\"3fffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDE3L, 0, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"feffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 2));\n    assertEquals(\"fedcffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 4));\n    assertEquals(\"fedcba098765432fffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 15));\n    assertEquals(\"fedcba0987654321ffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 16));\n    assertEquals(\"fff3ffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDE3L, 0, \"ffffffffffffffffffffffff\", 3, 1));\n    assertEquals(\"ffffefffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 2));\n    assertEquals(\"ffffedcfffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 4));\n    assertEquals(\"ffffedcba098765432ffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 15));\n    assertEquals(\"ffffedcba0987654321fffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 16));\n    assertEquals(\"7fffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 1, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"bfffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 2, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"fffdb975121fca86420fffff\", Conversion.longToHex(0x1234567890ABCDEFL, 3, \"ffffffffffffffffffffffff\", 3, 16));\n    // assertEquals(\"ffffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 4, \"ffffffffffffffffffffffff\", 3, 16));//rejected\n    // by assertion\n    assertEquals(\"fffedcba0987654321ffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 4, \"ffffffffffffffffffffffff\", 3, 15));\n    assertEquals(\"fedcba0987654321\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"\", 0, 16));\n    assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.longToHex(0x1234567890ABCDEFL, 0, \"\", 1, 8));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#longToHex(long, int, String, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1404, "method_signature": "void testLongToHex()", "filename": "ConversionTest.testLongToHex.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testLongToIntArray", "method_implementation": "{\n    assertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[] {}, 0, 0));\n    assertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[] {}, 0, 0));\n    assertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[] {}, 100, 0));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new int[] { 0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new int[] { 0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 2));\n    // assertArrayEquals(new\n    // int[]{0x90ABCDEF, 0x12345678, 0x90ABCDEF, 0x12345678}, Conversion.longToIntArray(0x1234567890ABCDEFL,\n    // 0, new int[]{-1, -1, -1, -1}, 0, 4));//rejected by assertion\n    // assertArrayEquals(new\n    // int[]{0xFFFFFFFF, 0x90ABCDEF, 0x12345678, 0x90ABCDEF}, Conversion.longToIntArray(0x1234567890ABCDEFL,\n    // 0, new int[]{-1, -1, -1, -1}, 1, 3));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678 }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 2, 2));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 1, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 2, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 3, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 4, new int[] { -1, -1, -1, -1 }, 2, 1));\n    // assertArrayEquals(new\n    // int[]{0x4855E6F7, 0x091A2B3C, 0x4855E6F7, 0x091A2B3C}, Conversion.longToIntArray(0x1234567890ABCDEFL,\n    // 1, new int[]{-1, -1, -1, -1}, 0, 4));//rejected by assertion\n    assertArrayEquals(new int[] { 0x091A2B3C }, Conversion.longToIntArray(0x1234567890ABCDEFL, 33, new int[] { 0 }, 0, 1));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#longToIntArray(long, int, int[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1405, "method_signature": "void testLongToIntArray()", "filename": "ConversionTest.testLongToIntArray.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testLongToShortArray", "method_implementation": "{\n    assertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 100, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[] {}, 100, 0));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 3));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0x1234 }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB, (short) 0x5678 }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 1, 3));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 2, 2));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xE6F7, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 1, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xF37B, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 2, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x79BD, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 3, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xBCDE, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 4, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xE6F7, (short) 0x4855, (short) 0x2B3C, (short) 0x091A }, Conversion.longToShortArray(0x1234567890ABCDEFL, 1, new short[] { -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new short[] { (short) 0x2B3C }, Conversion.longToShortArray(0x1234567890ABCDEFL, 33, new short[] { 0 }, 0, 1));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#longToShortArray(long, int, short[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1406, "method_signature": "void testLongToShortArray()", "filename": "ConversionTest.testLongToShortArray.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testShortArrayToInt", "method_implementation": "{\n    final short[] src = { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 };\n    assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0));\n    assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1));\n    assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2));\n    assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2));\n    assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0));\n    assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1));\n    // assertEquals(0x34567800, Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1407, "method_signature": "void testShortArrayToInt()", "filename": "ConversionTest.testShortArrayToInt.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testShortArrayToLong", "method_implementation": "{\n    final short[] src = { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 };\n    assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2));\n    assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4));\n    assertEquals(0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n    assertEquals(0x123456CDF1BCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));\n    assertEquals(0x123478003456DEF0L, Conversion.shortArrayToLong(src, 3, 0x123456789ABCDEF0L, 16, 2));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#shortArrayToLong(short[], int, long, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1408, "method_signature": "void testShortArrayToLong()", "filename": "ConversionTest.testShortArrayToLong.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testShortToBinary", "method_implementation": "{\n    assertArrayEquals(new boolean[] {}, Conversion.shortToBinary((short) 0x0000, 0, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.shortToBinary((short) 0x0000, 100, new boolean[] {}, 0, 0));\n    assertArrayEquals(new boolean[] {}, Conversion.shortToBinary((short) 0x0000, 0, new boolean[] {}, 100, 0));\n    assertArrayEquals(new boolean[69], Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[69], 0, 0));\n    assertArrayEquals(new boolean[] { true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 1));\n    assertArrayEquals(new boolean[] { true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 2));\n    assertArrayEquals(new boolean[] { true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 3));\n    assertArrayEquals(new boolean[] { true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, false, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 15));\n    assertArrayEquals(new boolean[] { true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 16));\n    assertArrayEquals(new boolean[] { false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 2, 1));\n    assertArrayEquals(new boolean[] { false, false, true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 2, 16));\n    assertArrayEquals(new boolean[] { true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 1, new boolean[21], 0, 15));\n    assertArrayEquals(new boolean[] { true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 2, new boolean[21], 0, 14));\n    // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,\n    // true, true, false, true, true, false, false, true, false, false, false, false,\n    // false}, Conversion.shortToBinary((short) 0xCDEF, 2, new boolean[21],\n    // 3, 15));//rejected by\n    // assertion\n    assertArrayEquals(new boolean[] { false, false, false, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false }, Conversion.shortToBinary((short) 0xCDEF, 2, new boolean[21], 3, 14));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#shortToBinary(short, int, boolean[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1409, "method_signature": "void testShortToBinary()", "filename": "ConversionTest.testShortToBinary.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testShortToByteArray", "method_implementation": "{\n    assertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 100, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[] {}, 100, 0));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n    assertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0xFE, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1 }, 3, 2));\n    // assertArrayEquals(new\n    // byte[]{(byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 13, new\n    // byte[]{-1, 0, -1, -1, -1, -1, -1}, 3, 2));//rejected by assertion\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0xFE, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1 }, 3, 1));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#shortToByteArray(short, int, byte[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1410, "method_signature": "void testShortToByteArray()", "filename": "ConversionTest.testShortToByteArray.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testShortToHex", "method_implementation": "{\n    assertEquals(\"\", Conversion.shortToHex((short) 0x0000, 0, \"\", 0, 0));\n    assertEquals(\"\", Conversion.shortToHex((short) 0x0000, 100, \"\", 0, 0));\n    assertEquals(\"\", Conversion.shortToHex((short) 0x0000, 0, \"\", 100, 0));\n    assertEquals(\"ffffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 0));\n    assertEquals(\"3fffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDE3, 0, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"feffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 2));\n    assertEquals(\"fedfffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 3));\n    assertEquals(\"fedcffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 4));\n    assertEquals(\"fff3ffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDE3, 0, \"ffffffffffffffffffffffff\", 3, 1));\n    assertEquals(\"ffffefffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 3, 2));\n    assertEquals(\"7fffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 1, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"bfffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 2, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"fffdb9ffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 3, \"ffffffffffffffffffffffff\", 3, 4));\n    // assertEquals(\"ffffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF,\n    // 4, \"ffffffffffffffffffffffff\", 3, 4));//rejected by assertion\n    assertEquals(\"fffedcffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 4, \"ffffffffffffffffffffffff\", 3, 3));\n    assertEquals(\"fedc\", Conversion.shortToHex((short) 0xCDEF, 0, \"\", 0, 4));\n    assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.shortToHex((short) 0xCDEF, 0, \"\", 1, 4));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#shortToHex(short, int, String, int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1411, "method_signature": "void testShortToHex()", "filename": "ConversionTest.testShortToHex.json"}
{"callee_method_names": [], "method_name": "ConversionTest.testUuidToByteArray", "method_implementation": "{\n    assertArrayEquals(new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff }, Conversion.uuidToByteArray(new UUID(0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), new byte[16], 0, 16));\n    assertArrayEquals(new byte[] { (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77 }, Conversion.uuidToByteArray(new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 0, 16));\n    assertArrayEquals(new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 }, Conversion.uuidToByteArray(new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 4, 8));\n    assertArrayEquals(new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x00, (byte) 0x00 }, Conversion.uuidToByteArray(new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 2, 12));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Conversion#uuidToByteArray(UUID, byte[], int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1412, "method_signature": "void testUuidToByteArray()", "filename": "ConversionTest.testUuidToByteArray.json"}
{"callee_method_names": ["Calendar.clear", "Calendar.set", "Calendar.getTimeInMillis", "Calendar.getTimeInMillis", "Calendar.getTimeInMillis"], "method_name": "DateFormatUtilsTest.testLang916", "method_implementation": "{\n    final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Paris\"));\n    cal.clear();\n    cal.set(2009, 9, 16, 8, 42, 16);\n    // Long.\n    {\n        final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/Paris\"));\n        assertEquals(\"2009-10-16T08:42:16+02:00\", value, \"long\");\n    }\n    {\n        final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Asia/Kolkata\"));\n        assertEquals(\"2009-10-16T12:12:16+05:30\", value, \"long\");\n    }\n    {\n        final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/London\"));\n        assertEquals(\"2009-10-16T07:42:16+01:00\", value, \"long\");\n    }\n    // Calendar.\n    {\n        final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/Paris\"));\n        assertEquals(\"2009-10-16T08:42:16+02:00\", value, \"calendar\");\n    }\n    {\n        final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Asia/Kolkata\"));\n        assertEquals(\"2009-10-16T12:12:16+05:30\", value, \"calendar\");\n    }\n    {\n        final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/London\"));\n        assertEquals(\"2009-10-16T07:42:16+01:00\", value, \"calendar\");\n    }\n}", "repo_id": "8", "comment": "/**\n * According to LANG-916 (https://issues.apache.org/jira/browse/LANG-916),\n * the format method did contain a bug: it did not use the TimeZone data.\n *\n * This method test that the bug is fixed.\n */\n", "repo_name": "commons-lang-master/", "id": 1820, "method_signature": "void testLang916()", "filename": "DateFormatUtilsTest.testLang916.json"}
{"callee_method_names": ["Calendar.equals", "Calendar.add", "Calendar.clone"], "method_name": "DateIterator.next", "method_implementation": "{\n    if (spot.equals(endFinal)) {\n        throw new NoSuchElementException();\n    }\n    spot.add(Calendar.DATE, 1);\n    return (Calendar) spot.clone();\n}", "repo_id": "8", "comment": "/**\n * Returns the next calendar in the iteration\n *\n * @return Object calendar for the next date\n */\n", "repo_name": "commons-lang-master/", "id": 706, "method_signature": "Calendar next()", "filename": "DateIterator.next.json"}
{"callee_method_names": ["Calendar.setTime", "Calendar.add", "Calendar.getTime"], "method_name": "DateUtils.add", "method_implementation": "{\n    validateDateNotNull(date);\n    final Calendar c = Calendar.getInstance();\n    c.setTime(date);\n    c.add(calendarField, amount);\n    return c.getTime();\n}", "repo_id": "8", "comment": "/**\n * Adds to a date returning a new object.\n * The original {@link Date} is unchanged.\n *\n * @param date  the date, not null\n * @param calendarField  the calendar field to add to\n * @param amount  the amount to add, may be negative\n * @return the new {@link Date} with the amount added\n * @throws NullPointerException if the date is null\n */\n", "repo_name": "commons-lang-master/", "id": 687, "method_signature": "Date add(Date, int, int)", "filename": "DateUtils.add.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "DateUtils.ceiling", "method_implementation": "{\n    Objects.requireNonNull(date, \"date\");\n    if (date instanceof Date) {\n        return ceiling((Date) date, field);\n    }\n    if (date instanceof Calendar) {\n        return ceiling((Calendar) date, field).getTime();\n    }\n    throw new ClassCastException(\"Could not find ceiling of for type: \" + date.getClass());\n}", "repo_id": "8", "comment": "/**\n * Gets a date ceiling, leaving the field specified as the most\n * significant field.\n *\n * <p>For example, if you had the date-time of 28 Mar 2002\n * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n * 2002 14:00:00.000.  If this was passed with MONTH, it would\n * return 1 Apr 2002 0:00:00.000.</p>\n *\n * @param date  the date to work with, either {@link Date} or {@link Calendar}, not null\n * @param field  the field from {@link Calendar} or {@code SEMI_MONTH}\n * @return the different ceil date, not null\n * @throws NullPointerException if the date is {@code null}\n * @throws ClassCastException if the object type is not a {@link Date} or {@link Calendar}\n * @throws ArithmeticException if the year is over 280 million\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 688, "method_signature": "Date ceiling(Object, int)", "filename": "DateUtils.ceiling.json"}
{"callee_method_names": ["Calendar.setTime"], "method_name": "DateUtils.getFragment", "method_implementation": "{\n    validateDateNotNull(date);\n    final Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    return getFragment(calendar, fragment, unit);\n}", "repo_id": "8", "comment": "/**\n * Gets a Date fragment for any unit.\n *\n * @param date the date to work with, not null\n * @param fragment the Calendar field part of date to calculate\n * @param unit the time unit\n * @return number of units within the fragment of the date\n * @throws NullPointerException if the date is {@code null}\n * @throws IllegalArgumentException if fragment is not supported\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 690, "method_signature": "long getFragment(Date, int, TimeUnit)", "filename": "DateUtils.getFragment.json"}
{"callee_method_names": ["Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get"], "method_name": "DateUtils.isSameDay", "method_implementation": "{\n    Objects.requireNonNull(cal1, \"cal1\");\n    Objects.requireNonNull(cal2, \"cal2\");\n    return cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);\n}", "repo_id": "8", "comment": "/**\n * Checks if two calendar objects are on the same day ignoring time.\n *\n * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n * </p>\n *\n * @param cal1  the first calendar, not altered, not null\n * @param cal2  the second calendar, not altered, not null\n * @return true if they represent the same day\n * @throws NullPointerException if either calendar is {@code null}\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 691, "method_signature": "boolean isSameDay(Calendar, Calendar)", "filename": "DateUtils.isSameDay.json"}
{"callee_method_names": ["Date.getTime", "Date.getTime"], "method_name": "DateUtils.isSameInstant", "method_implementation": "{\n    Objects.requireNonNull(date1, \"date1\");\n    Objects.requireNonNull(date2, \"date2\");\n    return date1.getTime() == date2.getTime();\n}", "repo_id": "8", "comment": "/**\n * Checks if two date objects represent the same instant in time.\n *\n * <p>This method compares the long millisecond time of the two objects.</p>\n *\n * @param date1  the first date, not altered, not null\n * @param date2  the second date, not altered, not null\n * @return true if they represent the same millisecond instant\n * @throws NullPointerException if either date is {@code null}\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 693, "method_signature": "boolean isSameInstant(Date, Date)", "filename": "DateUtils.isSameInstant.json"}
{"callee_method_names": ["Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.getClass", "Calendar.getClass"], "method_name": "DateUtils.isSameLocalTime", "method_implementation": "{\n    Objects.requireNonNull(cal1, \"cal1\");\n    Objects.requireNonNull(cal2, \"cal2\");\n    return cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass();\n}", "repo_id": "8", "comment": "/**\n * Checks if two calendar objects represent the same local time.\n *\n * <p>This method compares the values of the fields of the two objects.\n * In addition, both calendars must be the same of the same type.</p>\n *\n * @param cal1  the first calendar, not altered, not null\n * @param cal2  the second calendar, not altered, not null\n * @return true if they represent the same millisecond instant\n * @throws NullPointerException if either date is {@code null}\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 694, "method_signature": "boolean isSameLocalTime(Calendar, Calendar)", "filename": "DateUtils.isSameLocalTime.json"}
{"callee_method_names": [], "method_name": "DateUtils.iterator", "method_implementation": "{\n    Objects.requireNonNull(calendar, \"calendar\");\n    if (calendar instanceof Date) {\n        return iterator((Date) calendar, rangeStyle);\n    }\n    if (calendar instanceof Calendar) {\n        return iterator((Calendar) calendar, rangeStyle);\n    }\n    throw new ClassCastException(\"Could not iterate based on \" + calendar);\n}", "repo_id": "8", "comment": "/**\n * Constructs an {@link Iterator} over each day in a date\n * range defined by a focus date and range style.\n *\n * <p>For instance, passing Thursday, July 4, 2002 and a\n * {@code RANGE_MONTH_SUNDAY} will return an {@link Iterator}\n * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n * 2002, returning a Calendar instance for each intermediate day.</p>\n *\n * @param calendar  the date to work with, either {@link Date} or {@link Calendar}, not null\n * @param rangeStyle  the style constant to use. Must be one of the range\n * styles listed for the {@link #iterator(Calendar, int)} method.\n * @return the date iterator, not null\n * @throws NullPointerException if the date is {@code null}\n * @throws ClassCastException if the object type is not a {@link Date} or {@link Calendar}\n */\n", "repo_name": "commons-lang-master/", "id": 696, "method_signature": "Iterator<?> iterator(Object, int)", "filename": "DateUtils.iterator.json"}
{"callee_method_names": ["Calendar.get", "Calendar.getTime", "Date.getTime", "Calendar.get", "Calendar.get", "Calendar.get", "Date.getTime", "Date.setTime", "Calendar.setTime", "Calendar.get", "Calendar.add", "Calendar.add", "Calendar.add", "Calendar.get", "Calendar.add", "Calendar.add", "Calendar.add", "Calendar.add", "Calendar.get", "Calendar.get", "Calendar.getActualMinimum", "Calendar.getActualMaximum", "Calendar.get", "Calendar.set", "Calendar.get"], "method_name": "DateUtils.modify", "method_implementation": "{\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field == Calendar.MILLISECOND) {\n        return val;\n    }\n    // Fix for LANG-59 START\n    // see https://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    final Date date = val.getTime();\n    long time = date.getTime();\n    boolean done = false;\n    // truncate milliseconds\n    final int millisecs = val.get(Calendar.MILLISECOND);\n    if (ModifyType.TRUNCATE == modType || millisecs < 500) {\n        time -= millisecs;\n    }\n    if (field == Calendar.SECOND) {\n        done = true;\n    }\n    // truncate seconds\n    final int seconds = val.get(Calendar.SECOND);\n    if (!done && (ModifyType.TRUNCATE == modType || seconds < 30)) {\n        time = time - seconds * 1000L;\n    }\n    if (field == Calendar.MINUTE) {\n        done = true;\n    }\n    // truncate minutes\n    final int minutes = val.get(Calendar.MINUTE);\n    if (!done && (ModifyType.TRUNCATE == modType || minutes < 30)) {\n        time = time - minutes * 60000L;\n    }\n    // reset time\n    if (date.getTime() != time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    // Fix for LANG-59 END\n    boolean roundUp = false;\n    for (final int[] aField : fields) {\n        for (final int element : aField) {\n            if (element == field) {\n                //This is our field... we stop looping\n                if (modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp) {\n                    if (field == SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                        // Fix for LANG-440 START\n                    } else if (field == Calendar.AM_PM) {\n                        // This is a special case\n                        // If the time is 0, we round up to 12, otherwise\n                        //  we subtract 12 hours and add 1 day\n                        if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                        // Fix for LANG-440 END\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(aField[0], 1);\n                    }\n                }\n                return val;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case SEMI_MONTH:\n                if (aField[0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtract 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset >= 6;\n                    offsetSet = true;\n                }\n                break;\n            default:\n                break;\n        }\n        if (!offsetSet) {\n            final int min = val.getActualMinimum(aField[0]);\n            final int max = val.getActualMaximum(aField[0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(aField[0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > (max - min) / 2;\n        }\n        //We need to remove this field\n        if (offset != 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "repo_id": "8", "comment": "/**\n * Internal calculation method.\n *\n * @param val  the calendar, not null\n * @param field  the field constant\n * @param modType  type to truncate, round or ceiling\n * @return the given calendar\n * @throws ArithmeticException if the year is over 280 million\n */\n", "repo_name": "commons-lang-master/", "id": 697, "method_signature": "Calendar modify(Calendar, int, ModifyType)", "filename": "DateUtils.modify.json"}
{"callee_method_names": ["Calendar.equals", "Calendar.add", "Calendar.clone"], "method_name": "DateUtils.next", "method_implementation": "{\n    if (spot.equals(endFinal)) {\n        throw new NoSuchElementException();\n    }\n    spot.add(Calendar.DATE, 1);\n    return (Calendar) spot.clone();\n}", "repo_id": "8", "comment": "/**\n * Returns the next calendar in the iteration\n *\n * @return Object calendar for the next date\n */\n", "repo_name": "commons-lang-master/", "id": 686, "method_signature": "Calendar next()", "filename": "DateUtils.next.json"}
{"callee_method_ids": [624], "callee_method_names": ["Calendar.setLenient", "Calendar.clear", "FastDateParser.parse", "ParsePosition.getIndex", "String.length", "Calendar.getTime", "ParsePosition.setIndex"], "method_name": "DateUtils.parseDateWithLeniency", "method_implementation": "{\n    Objects.requireNonNull(dateStr, \"str\");\n    Objects.requireNonNull(parsePatterns, \"parsePatterns\");\n    final TimeZone tz = TimeZone.getDefault();\n    final Locale lcl = LocaleUtils.toLocale(locale);\n    final ParsePosition pos = new ParsePosition(0);\n    final Calendar calendar = Calendar.getInstance(tz, lcl);\n    calendar.setLenient(lenient);\n    for (final String parsePattern : parsePatterns) {\n        final FastDateParser fdp = new FastDateParser(parsePattern, tz, lcl);\n        calendar.clear();\n        try {\n            if (fdp.parse(dateStr, pos, calendar) && pos.getIndex() == dateStr.length()) {\n                return calendar.getTime();\n            }\n        } catch (final IllegalArgumentException ignored) {\n            // leniency is preventing calendar from being set\n        }\n        pos.setIndex(0);\n    }\n    throw new ParseException(\"Unable to parse the date: \" + dateStr, -1);\n}", "repo_id": "8", "comment": "/**\n * Parses a string representing a date by trying a variety of different parsers.\n *\n * <p>The parse will try each parse pattern in turn.\n * A parse is only deemed successful if it parses the whole of the input string.\n * If no parse patterns match, a ParseException is thrown.</p>\n *\n * @param dateStr  the date to parse, not null\n * @param locale the locale to use when interpreting the pattern, can be null in which\n * case the default system locale is used\n * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n * @param lenient Specify whether or not date/time parsing is to be lenient.\n * @return the parsed date\n * @throws NullPointerException if the date string or pattern array is null\n * @throws ParseException if none of the date patterns were suitable\n * @see java.util.Calendar#isLenient()\n */\n", "repo_name": "commons-lang-master/", "id": 698, "method_signature": "Date parseDateWithLeniency(String, Locale, String[], boolean)", "filename": "DateUtils.parseDateWithLeniency.json"}
{"callee_method_names": [], "method_name": "DateUtils.round", "method_implementation": "{\n    Objects.requireNonNull(date, \"date\");\n    if (date instanceof Date) {\n        return round((Date) date, field);\n    }\n    if (date instanceof Calendar) {\n        return round((Calendar) date, field).getTime();\n    }\n    throw new ClassCastException(\"Could not round \" + date);\n}", "repo_id": "8", "comment": "/**\n * Rounds a date, leaving the field specified as the most\n * significant field.\n *\n * <p>For example, if you had the date-time of 28 Mar 2002\n * 13:45:01.231, if this was passed with HOUR, it would return\n * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n * would return 1 April 2002 0:00:00.000.</p>\n *\n * <p>For a date in a time zone that handles the change to daylight\n * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n * Suppose daylight saving time begins at 02:00 on March 30. Rounding a\n * date that crosses this time would produce the following values:\n * </p>\n * <ul>\n * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n * </ul>\n *\n * @param date  the date to work with, either {@link Date} or {@link Calendar}, not null\n * @param field  the field from {@link Calendar} or {@code SEMI_MONTH}\n * @return the different rounded date, not null\n * @throws NullPointerException if the date is {@code null}\n * @throws ClassCastException if the object type is not a {@link Date} or {@link Calendar}\n * @throws ArithmeticException if the year is over 280 million\n */\n", "repo_name": "commons-lang-master/", "id": 699, "method_signature": "Date round(Object, int)", "filename": "DateUtils.round.json"}
{"callee_method_names": ["Calendar.setLenient", "Calendar.setTime", "Calendar.set", "Calendar.getTime"], "method_name": "DateUtils.set", "method_implementation": "{\n    validateDateNotNull(date);\n    // getInstance() returns a new object, so this method is thread safe.\n    final Calendar c = Calendar.getInstance();\n    c.setLenient(false);\n    c.setTime(date);\n    c.set(calendarField, amount);\n    return c.getTime();\n}", "repo_id": "8", "comment": "/**\n * Sets the specified field to a date returning a new object.\n * This does not use a lenient calendar.\n * The original {@link Date} is unchanged.\n *\n * @param date  the date, not null\n * @param calendarField  the {@link Calendar} field to set the amount to\n * @param amount the amount to set\n * @return a new {@link Date} set with the specified value\n * @throws NullPointerException if the date is null\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 700, "method_signature": "Date set(Date, int, int)", "filename": "DateUtils.set.json"}
{"callee_method_names": ["Calendar.setTime"], "method_name": "DateUtils.toCalendar", "method_implementation": "{\n    final Calendar c = Calendar.getInstance(tz);\n    c.setTime(Objects.requireNonNull(date, \"date\"));\n    return c;\n}", "repo_id": "8", "comment": "/**\n * Converts a {@link Date} of a given {@link TimeZone} into a {@link Calendar}\n * @param date the date to convert to a Calendar\n * @param tz the time zone of the {@code date}\n * @return the created Calendar\n * @throws NullPointerException if {@code date} or {@code tz} is null\n */\n", "repo_name": "commons-lang-master/", "id": 702, "method_signature": "Calendar toCalendar(Date, TimeZone)", "filename": "DateUtils.toCalendar.json"}
{"callee_method_names": [], "method_name": "DateUtils.truncate", "method_implementation": "{\n    Objects.requireNonNull(date, \"date\");\n    if (date instanceof Date) {\n        return truncate((Date) date, field);\n    }\n    if (date instanceof Calendar) {\n        return truncate((Calendar) date, field).getTime();\n    }\n    throw new ClassCastException(\"Could not truncate \" + date);\n}", "repo_id": "8", "comment": "/**\n * Truncates a date, leaving the field specified as the most\n * significant field.\n *\n * <p>For example, if you had the date-time of 28 Mar 2002\n * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n * 2002 13:00:00.000.  If this was passed with MONTH, it would\n * return 1 Mar 2002 0:00:00.000.</p>\n *\n * @param date  the date to work with, either {@link Date} or {@link Calendar}, not null\n * @param field  the field from {@link Calendar} or {@code SEMI_MONTH}\n * @return the different truncated date, not null\n * @throws NullPointerException if the date is {@code null}\n * @throws ClassCastException if the object type is not a {@link Date} or {@link Calendar}\n * @throws ArithmeticException if the year is over 280 million\n */\n", "repo_name": "commons-lang-master/", "id": 703, "method_signature": "Date truncate(Object, int)", "filename": "DateUtils.truncate.json"}
{"callee_method_names": ["Date.compareTo"], "method_name": "DateUtils.truncatedCompareTo", "method_implementation": "{\n    final Date truncatedDate1 = truncate(date1, field);\n    final Date truncatedDate2 = truncate(date2, field);\n    return truncatedDate1.compareTo(truncatedDate2);\n}", "repo_id": "8", "comment": "/**\n * Determines how two dates compare up to no more than the specified\n * most significant field.\n *\n * @param date1 the first date, not {@code null}\n * @param date2 the second date, not {@code null}\n * @param field the field from {@link Calendar}\n * @return a negative integer, zero, or a positive integer as the first\n * date is less than, equal to, or greater than the second.\n * @throws NullPointerException if any argument is {@code null}\n * @see #truncate(Calendar, int)\n * @see #truncatedCompareTo(Date, Date, int)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 705, "method_signature": "int truncatedCompareTo(Date, Date, int)", "filename": "DateUtils.truncatedCompareTo.json"}
{"callee_method_names": [], "method_name": "DateUtilsFragmentTest.testMillisecondsOfDayWithDate", "method_implementation": "{\n    long testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DATE);\n    final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR);\n    assertEquals(expectedValue, testresult);\n    testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DAY_OF_YEAR);\n    assertEquals(expectedValue, testresult);\n}", "repo_id": "8", "comment": "//Calendar.DATE and Calendar.DAY_OF_YEAR as useful fragment\n", "repo_name": "commons-lang-master/", "id": 1821, "method_signature": "void testMillisecondsOfDayWithDate()", "filename": "DateUtilsFragmentTest.testMillisecondsOfDayWithDate.json"}
{"callee_method_names": [], "method_name": "DateUtilsFragmentTest.testMillisecondsOfMonthWithDate", "method_implementation": "{\n    final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH);\n    assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY), testResult);\n}", "repo_id": "8", "comment": "//Calendar.MONTH as useful fragment\n", "repo_name": "commons-lang-master/", "id": 1822, "method_signature": "void testMillisecondsOfMonthWithDate()", "filename": "DateUtilsFragmentTest.testMillisecondsOfMonthWithDate.json"}
{"callee_method_names": ["Calendar.setTime", "Calendar.get"], "method_name": "DateUtilsFragmentTest.testMillisecondsOfYearWithDate", "method_implementation": "{\n    final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR);\n    final Calendar cal = Calendar.getInstance();\n    cal.setTime(aDate);\n    assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + ((cal.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY), testResult);\n}", "repo_id": "8", "comment": "//Calendar.YEAR as useful fragment\n", "repo_name": "commons-lang-master/", "id": 1823, "method_signature": "void testMillisecondsOfYearWithDate()", "filename": "DateUtilsFragmentTest.testMillisecondsOfYearWithDate.json"}
{"callee_method_names": ["Calendar.setTime", "Calendar.setTime", "Calendar.setTime", "Calendar.setTime"], "method_name": "DateUtilsRoundingTest.baseRoundTest", "method_implementation": "{\n    final Date firstRoundUpDate = DateUtils.addMilliseconds(lastRoundDownDate, 1);\n    //Date-comparison\n    assertEquals(roundedDownDate, DateUtils.round(roundedDownDate, calendarField));\n    assertEquals(roundedUpDate, DateUtils.round(roundedUpDate, calendarField));\n    assertEquals(roundedDownDate, DateUtils.round(lastRoundDownDate, calendarField));\n    assertEquals(roundedUpDate, DateUtils.round(firstRoundUpDate, calendarField));\n    //Calendar-initiations\n    final Calendar roundedUpCalendar;\n    final Calendar roundedDownCalendar;\n    final Calendar lastRoundDownCalendar;\n    final Calendar firstRoundUpCalendar;\n    roundedDownCalendar = Calendar.getInstance();\n    roundedUpCalendar = Calendar.getInstance();\n    lastRoundDownCalendar = Calendar.getInstance();\n    firstRoundUpCalendar = Calendar.getInstance();\n    roundedDownCalendar.setTime(roundedDownDate);\n    roundedUpCalendar.setTime(roundedUpDate);\n    lastRoundDownCalendar.setTime(lastRoundDownDate);\n    firstRoundUpCalendar.setTime(firstRoundUpDate);\n    //Calendar-comparison\n    assertEquals(roundedDownCalendar, DateUtils.round(roundedDownCalendar, calendarField));\n    assertEquals(roundedUpCalendar, DateUtils.round(roundedUpCalendar, calendarField));\n    assertEquals(roundedDownCalendar, DateUtils.round(lastRoundDownCalendar, calendarField));\n    assertEquals(roundedUpCalendar, DateUtils.round(firstRoundUpCalendar, calendarField));\n    //Object-comparison\n    assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownDate, calendarField));\n    assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpDate, calendarField));\n    assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField));\n    assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField));\n    assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownCalendar, calendarField));\n    assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpCalendar, calendarField));\n    assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField));\n    assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField));\n}", "repo_id": "8", "comment": "/**\n * When using this basetest all extremes are tested.<br>\n * It will test the Date, Calendar and Object-implementation<br>\n * lastRoundDownDate should round down to roundedDownDate<br>\n * lastRoundDownDate + 1 millisecond should round up to roundedUpDate\n *\n * @param roundedUpDate the next rounded date after <strong>roundedDownDate</strong> when using <strong>calendarField</strong>\n * @param roundedDownDate the result if <strong>lastRoundDownDate</strong> was rounded with <strong>calendarField</strong>\n * @param lastRoundDownDate rounding this value with <strong>calendarField</strong> will result in <strong>roundedDownDate</strong>\n * @param calendarField a Calendar.field value\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1793, "method_signature": "void baseRoundTest(Date, Date, Date, int)", "filename": "DateUtilsRoundingTest.baseRoundTest.json"}
{"callee_method_ids": [605, 605, 605, 605, 605, 605, 605, 605], "callee_method_names": ["FastDateFormat.format", "FastDateFormat.format", "Calendar.setTime", "Calendar.setTime", "Calendar.setTime", "FastDateFormat.format", "FastDateFormat.format", "FastDateFormat.format", "FastDateFormat.format", "FastDateFormat.format", "FastDateFormat.format"], "method_name": "DateUtilsRoundingTest.baseTruncateTest", "method_implementation": "{\n    final Date nextTruncateDate = DateUtils.addMilliseconds(lastTruncateDate, 1);\n    //Date-comparison\n    assertEquals(truncatedDate, DateUtils.truncate(truncatedDate, calendarField), \"Truncating \" + fdf.format(truncatedDate) + \" as Date with CalendarField-value \" + calendarField + \" must return itself\");\n    assertEquals(truncatedDate, DateUtils.truncate(lastTruncateDate, calendarField));\n    assertNotEquals(truncatedDate, DateUtils.truncate(nextTruncateDate, calendarField), fdf.format(lastTruncateDate) + \" is not an extreme when truncating as Date with CalendarField-value \" + calendarField);\n    //Calendar-initiations\n    final Calendar truncatedCalendar;\n    final Calendar lastTruncateCalendar;\n    final Calendar nextTruncateCalendar;\n    truncatedCalendar = Calendar.getInstance();\n    lastTruncateCalendar = Calendar.getInstance();\n    nextTruncateCalendar = Calendar.getInstance();\n    truncatedCalendar.setTime(truncatedDate);\n    lastTruncateCalendar.setTime(lastTruncateDate);\n    nextTruncateCalendar.setTime(nextTruncateDate);\n    //Calendar-comparison\n    assertEquals(truncatedCalendar, DateUtils.truncate(truncatedCalendar, calendarField), \"Truncating \" + fdf.format(truncatedCalendar) + \" as Calendar with CalendarField-value \" + calendarField + \" must return itself\");\n    assertEquals(truncatedCalendar, DateUtils.truncate(lastTruncateCalendar, calendarField));\n    assertNotEquals(truncatedCalendar, DateUtils.truncate(nextTruncateCalendar, calendarField), fdf.format(lastTruncateCalendar) + \" is not an extreme when truncating as Calendar with CalendarField-value \" + calendarField);\n    //Object-comparison\n    assertEquals(truncatedDate, DateUtils.truncate((Object) truncatedDate, calendarField), \"Truncating \" + fdf.format(truncatedDate) + \" as Date cast to Object with CalendarField-value \" + calendarField + \" must return itself as Date\");\n    assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateDate, calendarField));\n    assertNotEquals(truncatedDate, DateUtils.truncate((Object) nextTruncateDate, calendarField), fdf.format(lastTruncateDate) + \" is not an extreme when truncating as Date cast to Object with CalendarField-value \" + calendarField);\n    assertEquals(truncatedDate, DateUtils.truncate((Object) truncatedCalendar, calendarField), \"Truncating \" + fdf.format(truncatedCalendar) + \" as Calendar cast to Object with CalendarField-value \" + calendarField + \" must return itself as Date\");\n    assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateCalendar, calendarField));\n    assertNotEquals(truncatedDate, DateUtils.truncate((Object) nextTruncateCalendar, calendarField), fdf.format(lastTruncateCalendar) + \" is not an extreme when truncating as Calendar cast to Object with CalendarField-value \" + calendarField);\n}", "repo_id": "8", "comment": "/**\n * When using this basetest all extremes are tested.<br>\n * It will test the Date, Calendar and Object-implementation<br>\n * lastTruncateDate should round down to truncatedDate<br>\n * lastTruncateDate + 1 millisecond should never round down to truncatedDate\n *\n * @param truncatedDate expected Date when <strong>lastTruncateDate</strong> is truncated with <strong>calendarField</strong>\n * @param lastTruncateDate the last possible Date which will truncate to <strong>truncatedDate</strong> with <strong>calendarField</strong>\n * @param calendarField a Calendar.field value\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1794, "method_signature": "void baseTruncateTest(Date, Date, int)", "filename": "DateUtilsRoundingTest.baseTruncateTest.json"}
{"callee_method_ids": [605, 605, 605, 605, 605, 605], "callee_method_names": ["FastDateFormat.format", "Calendar.setTime", "Calendar.setTime", "FastDateFormat.format", "FastDateFormat.format", "FastDateFormat.format", "Calendar.setTime", "Calendar.setTime", "FastDateFormat.format", "FastDateFormat.format"], "method_name": "DateUtilsRoundingTest.roundToJanuaryFirst", "method_implementation": "{\n    assertEquals(januaryOneDate, DateUtils.round(januaryOneDate, calendarField), \"Rounding \" + fdf.format(januaryOneDate) + \" as Date with CalendarField-value \" + calendarField + \" must return itself\");\n    assertEquals(januaryOneDate, DateUtils.round(minDate, calendarField));\n    assertEquals(januaryOneDate, DateUtils.round(maxDate, calendarField));\n    final Calendar minCalendar = Calendar.getInstance();\n    minCalendar.setTime(minDate);\n    final Calendar maxCalendar = Calendar.getInstance();\n    maxCalendar.setTime(maxDate);\n    assertEquals(januaryOneCalendar, DateUtils.round(januaryOneCalendar, calendarField), \"Rounding \" + fdf.format(januaryOneCalendar) + \" as Date with CalendarField-value \" + calendarField + \" must return itself\");\n    assertEquals(januaryOneCalendar, DateUtils.round(minCalendar, calendarField));\n    assertEquals(januaryOneCalendar, DateUtils.round(maxCalendar, calendarField));\n    final Date toPrevRoundDate = DateUtils.addMilliseconds(minDate, -1);\n    final Date toNextRoundDate = DateUtils.addMilliseconds(maxDate, 1);\n    assertNotEquals(januaryOneDate, DateUtils.round(toPrevRoundDate, calendarField), fdf.format(minDate) + \" is not an lower-extreme when rounding as Date with CalendarField-value \" + calendarField);\n    assertNotEquals(januaryOneDate, DateUtils.round(toNextRoundDate, calendarField), fdf.format(maxDate) + \" is not an upper-extreme when rounding as Date with CalendarField-value \" + calendarField);\n    final Calendar toPrevRoundCalendar = Calendar.getInstance();\n    toPrevRoundCalendar.setTime(toPrevRoundDate);\n    final Calendar toNextRoundCalendar = Calendar.getInstance();\n    toNextRoundCalendar.setTime(toNextRoundDate);\n    assertNotEquals(januaryOneDate, DateUtils.round(toPrevRoundDate, calendarField), fdf.format(minCalendar) + \" is not an lower-extreme when rounding as Date with CalendarField-value \" + calendarField);\n    assertNotEquals(januaryOneDate, DateUtils.round(toNextRoundDate, calendarField), fdf.format(maxCalendar) + \" is not an upper-extreme when rounding as Date with CalendarField-value \" + calendarField);\n}", "repo_id": "8", "comment": "/**\n * Any January 1 could be considered as the ultimate extreme.\n * Instead of comparing the results if the input has a difference of 1 millisecond we check the output to be exactly January first.\n *\n * @param minDate the lower bound\n * @param maxDate the upper bound\n * @param calendarField a Calendar.field value\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1795, "method_signature": "void roundToJanuaryFirst(Date, Date, int)", "filename": "DateUtilsRoundingTest.roundToJanuaryFirst.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundAmPm", "method_implementation": "{\n    final int calendarField = Calendar.AM_PM;\n    Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    //AM\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 12:00:00.000\");\n    roundedDownDate = targetAmDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 5:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //PM\n    roundedUpDate = dateTimeParser.parse(\"June 2, 2008 0:00:00.000\");\n    roundedDownDate = targetPmDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 17:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 31, 2007 18:00:00.000\");\n    maxDate = dateTimeParser.parse(\"January 1, 2008 5:59:59.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.AM_PM\n * Includes rounding the extremes of both AM and PM of one day\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1796, "method_signature": "void testRoundAmPm()", "filename": "DateUtilsRoundingTest.testRoundAmPm.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundDate", "method_implementation": "{\n    final int calendarField = Calendar.DATE;\n    final Date roundedUpDate;\n    final Date roundedDownDate;\n    final Date lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    roundedUpDate = dateTimeParser.parse(\"June 2, 2008 0:00:00.000\");\n    roundedDownDate = targetDateDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 11:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 31, 2007 12:00:00.000\");\n    maxDate = dateTimeParser.parse(\"January 1, 2008 11:59:59.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.DATE\n * Includes rounding the extremes of one day\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1797, "method_signature": "void testRoundDate()", "filename": "DateUtilsRoundingTest.testRoundDate.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundDayOfMonth", "method_implementation": "{\n    final int calendarField = Calendar.DAY_OF_MONTH;\n    final Date roundedUpDate;\n    final Date roundedDownDate;\n    final Date lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    roundedUpDate = dateTimeParser.parse(\"June 2, 2008 0:00:00.000\");\n    roundedDownDate = targetDayOfMonthDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 11:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 31, 2007 12:00:00.000\");\n    maxDate = dateTimeParser.parse(\"January 1, 2008 11:59:59.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.DAY_OF_MONTH\n * Includes rounding the extremes of one day\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1798, "method_signature": "void testRoundDayOfMonth()", "filename": "DateUtilsRoundingTest.testRoundDayOfMonth.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundHour", "method_implementation": "{\n    final int calendarField = Calendar.HOUR;\n    final Date roundedUpDate;\n    final Date roundedDownDate;\n    final Date lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 9:00:00.000\");\n    roundedDownDate = targetHourDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:29:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 31, 2007 23:30:00.000\");\n    maxDate = dateTimeParser.parse(\"January 1, 2008 0:29:59.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.HOUR\n * Includes rounding the extremes of one hour\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1799, "method_signature": "void testRoundHour()", "filename": "DateUtilsRoundingTest.testRoundHour.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundHourOfDay", "method_implementation": "{\n    final int calendarField = Calendar.HOUR_OF_DAY;\n    final Date roundedUpDate;\n    final Date roundedDownDate;\n    final Date lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 9:00:00.000\");\n    roundedDownDate = targetHourOfDayDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:29:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 31, 2007 23:30:00.000\");\n    maxDate = dateTimeParser.parse(\"January 1, 2008 0:29:59.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY\n * Includes rounding the extremes of one hour\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1800, "method_signature": "void testRoundHourOfDay()", "filename": "DateUtilsRoundingTest.testRoundHourOfDay.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundMilliSecond", "method_implementation": "{\n    final int calendarField = Calendar.MILLISECOND;\n    final Date roundedUpDate;\n    final Date roundedDownDate;\n    final Date lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    roundedDownDate = lastRoundedDownDate = targetMilliSecondDate;\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.232\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = maxDate = januaryOneDate;\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.MILLISECOND\n * Includes rounding the extremes of one second\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1801, "method_signature": "void testRoundMilliSecond()", "filename": "DateUtilsRoundingTest.testRoundMilliSecond.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundMinute", "method_implementation": "{\n    final int calendarField = Calendar.MINUTE;\n    final Date roundedUpDate;\n    final Date roundedDownDate;\n    final Date lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 8:16:00.000\");\n    roundedDownDate = targetMinuteDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:15:29.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 31, 2007 23:59:30.000\");\n    maxDate = dateTimeParser.parse(\"January 1, 2008 0:00:29.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.MINUTE\n * Includes rounding the extremes of one minute\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1802, "method_signature": "void testRoundMinute()", "filename": "DateUtilsRoundingTest.testRoundMinute.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundMonth", "method_implementation": "{\n    final int calendarField = Calendar.MONTH;\n    Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    //month with 28 days\n    roundedUpDate = dateTimeParser.parse(\"March 1, 2007 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"February 1, 2007 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"February 14, 2007 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 29 days\n    roundedUpDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"February 1, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"February 15, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 30 days\n    roundedUpDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"April 1, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"April 15, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 31 days\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"May 16, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 17, 2007 00:00:00.000\");\n    maxDate = dateTimeParser.parse(\"January 16, 2008 23:59:59.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.MONTH\n * Includes rounding months with 28, 29, 30 and 31 days\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1803, "method_signature": "void testRoundMonth()", "filename": "DateUtilsRoundingTest.testRoundMonth.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundSecond", "method_implementation": "{\n    final int calendarField = Calendar.SECOND;\n    final Date roundedUpDate;\n    final Date roundedDownDate;\n    final Date lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 8:15:15.000\");\n    roundedDownDate = targetSecondDate;\n    lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.499\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 31, 2007 23:59:59.500\");\n    maxDate = dateTimeParser.parse(\"January 1, 2008 0:00:00.499\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.SECOND\n * Includes rounding the extremes of one second\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1804, "method_signature": "void testRoundSecond()", "filename": "DateUtilsRoundingTest.testRoundSecond.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundSemiMonth", "method_implementation": "{\n    final int calendarField = DateUtils.SEMI_MONTH;\n    Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n    final Date minDate;\n    final Date maxDate;\n    //month with 28 days (1)\n    roundedUpDate = dateTimeParser.parse(\"February 16, 2007 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"February 1, 2007 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"February 8, 2007 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 28 days (2)\n    roundedUpDate = dateTimeParser.parse(\"March 1, 2007 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"February 16, 2007 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"February 23, 2007 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 29 days (1)\n    roundedUpDate = dateTimeParser.parse(\"February 16, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"February 1, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"February 8, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 29 days (2)\n    roundedUpDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"February 16, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"February 23, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 30 days (1)\n    roundedUpDate = dateTimeParser.parse(\"April 16, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"April 1, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"April 8, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 30 days (2)\n    roundedUpDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"April 16, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"April 23, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 31 days (1)\n    roundedUpDate = dateTimeParser.parse(\"May 16, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"May 8, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //month with 31 days (2)\n    roundedUpDate = dateTimeParser.parse(\"June 1, 2008 0:00:00.000\");\n    roundedDownDate = dateTimeParser.parse(\"May 16, 2008 0:00:00.000\");\n    lastRoundedDownDate = dateTimeParser.parse(\"May 23, 2008 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n    //round to January 1\n    minDate = dateTimeParser.parse(\"December 24, 2007 00:00:00.000\");\n    maxDate = dateTimeParser.parse(\"January 8, 2008 23:59:59.999\");\n    roundToJanuaryFirst(minDate, maxDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with DateUtils.SEMI_MONTH\n * Includes rounding months with 28, 29, 30 and 31 days, each with first and second half\n * Includes rounding to January 1\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1805, "method_signature": "void testRoundSemiMonth()", "filename": "DateUtilsRoundingTest.testRoundSemiMonth.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testRoundYear", "method_implementation": "{\n    final int calendarField = Calendar.YEAR;\n    final Date roundedUpDate = dateTimeParser.parse(\"January 1, 2008 0:00:00.000\");\n    final Date roundedDownDate = targetYearDate;\n    final Date lastRoundedDownDate = dateTimeParser.parse(\"June 30, 2007 23:59:59.999\");\n    baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Tests DateUtils.round()-method with Calendar.Year\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1806, "method_signature": "void testRoundYear()", "filename": "DateUtilsRoundingTest.testRoundYear.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateAmPm", "method_implementation": "{\n    final int calendarField = Calendar.AM_PM;\n    //AM\n    Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 11:59:59.999\");\n    baseTruncateTest(targetAmDate, lastTruncateDate, calendarField);\n    //PM\n    lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n    baseTruncateTest(targetPmDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.AM_PM\n * Includes truncating the extremes of both AM and PM of one day\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1807, "method_signature": "void testTruncateAmPm()", "filename": "DateUtilsRoundingTest.testTruncateAmPm.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateDate", "method_implementation": "{\n    final int calendarField = Calendar.DATE;\n    final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n    baseTruncateTest(targetDateDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.DATE\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1808, "method_signature": "void testTruncateDate()", "filename": "DateUtilsRoundingTest.testTruncateDate.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateDayOfMonth", "method_implementation": "{\n    final int calendarField = Calendar.DAY_OF_MONTH;\n    final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n    baseTruncateTest(targetDayOfMonthDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.DAY_OF_MONTH\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1809, "method_signature": "void testTruncateDayOfMonth()", "filename": "DateUtilsRoundingTest.testTruncateDayOfMonth.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateHour", "method_implementation": "{\n    final int calendarField = Calendar.HOUR;\n    final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n    baseTruncateTest(targetHourDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.HOUR\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1810, "method_signature": "void testTruncateHour()", "filename": "DateUtilsRoundingTest.testTruncateHour.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateHourOfDay", "method_implementation": "{\n    final int calendarField = Calendar.HOUR_OF_DAY;\n    final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n    baseTruncateTest(targetHourOfDayDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.HOUR_OF_DAY\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1811, "method_signature": "void testTruncateHourOfDay()", "filename": "DateUtilsRoundingTest.testTruncateHourOfDay.json"}
{"callee_method_names": [], "method_name": "DateUtilsRoundingTest.testTruncateMilliSecond", "method_implementation": "{\n    final int calendarField = Calendar.MILLISECOND;\n    baseTruncateTest(targetMilliSecondDate, targetMilliSecondDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.SECOND\n *\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1812, "method_signature": "void testTruncateMilliSecond()", "filename": "DateUtilsRoundingTest.testTruncateMilliSecond.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateMinute", "method_implementation": "{\n    final int calendarField = Calendar.MINUTE;\n    final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:59.999\");\n    baseTruncateTest(targetMinuteDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.MINUTE\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1813, "method_signature": "void testTruncateMinute()", "filename": "DateUtilsRoundingTest.testTruncateMinute.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateMonth", "method_implementation": "{\n    final int calendarField = Calendar.MONTH;\n    final Date truncatedDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n    final Date lastTruncateDate = dateTimeParser.parse(\"March 31, 2008 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.MONTH\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1814, "method_signature": "void testTruncateMonth()", "filename": "DateUtilsRoundingTest.testTruncateMonth.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateSecond", "method_implementation": "{\n    final int calendarField = Calendar.SECOND;\n    final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.999\");\n    baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.SECOND\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1815, "method_signature": "void testTruncateSecond()", "filename": "DateUtilsRoundingTest.testTruncateSecond.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateSemiMonth", "method_implementation": "{\n    final int calendarField = DateUtils.SEMI_MONTH;\n    Date truncatedDate, lastTruncateDate;\n    //month with 28 days (1)\n    truncatedDate = dateTimeParser.parse(\"February 1, 2007 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"February 15, 2007 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n    //month with 28 days (2)\n    truncatedDate = dateTimeParser.parse(\"February 16, 2007 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"February 28, 2007 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n    //month with 29 days (1)\n    truncatedDate = dateTimeParser.parse(\"February 1, 2008 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"February 15, 2008 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n    //month with 29 days (2)\n    truncatedDate = dateTimeParser.parse(\"February 16, 2008 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"February 29, 2008 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n    //month with 30 days (1)\n    truncatedDate = dateTimeParser.parse(\"April 1, 2008 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"April 15, 2008 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n    //month with 30 days (2)\n    truncatedDate = dateTimeParser.parse(\"April 16, 2008 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"April 30, 2008 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n    //month with 31 days (1)\n    truncatedDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"March 15, 2008 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n    //month with 31 days (2)\n    truncatedDate = dateTimeParser.parse(\"March 16, 2008 0:00:00.000\");\n    lastTruncateDate = dateTimeParser.parse(\"March 31, 2008 23:59:59.999\");\n    baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with DateUtils.SEMI_MONTH\n * Includes truncating months with 28, 29, 30 and 31 days, each with first and second half\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1816, "method_signature": "void testTruncateSemiMonth()", "filename": "DateUtilsRoundingTest.testTruncateSemiMonth.json"}
{"callee_method_names": ["DateFormat.parse"], "method_name": "DateUtilsRoundingTest.testTruncateYear", "method_implementation": "{\n    final int calendarField = Calendar.YEAR;\n    final Date lastTruncateDate = dateTimeParser.parse(\"December 31, 2007 23:59:59.999\");\n    baseTruncateTest(targetYearDate, lastTruncateDate, calendarField);\n}", "repo_id": "8", "comment": "/**\n * Test DateUtils.truncate()-method with Calendar.YEAR\n *\n * @throws Exception so we don't have to catch it\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1817, "method_signature": "void testTruncateYear()", "filename": "DateUtilsRoundingTest.testTruncateYear.json"}
{"callee_method_names": ["Calendar.setTime", "Calendar.setTime"], "method_name": "DateUtilsTest.assertWeekIterator", "method_implementation": "{\n    final Calendar calStart = Calendar.getInstance();\n    calStart.setTime(start);\n    final Calendar calEnd = Calendar.getInstance();\n    calEnd.setTime(end);\n    assertWeekIterator(it, calStart, calEnd);\n}", "repo_id": "8", "comment": "/**\n * Convenience method for when working with Date objects\n */\n", "repo_name": "commons-lang-master/", "id": 1833, "method_signature": "void assertWeekIterator(Iterator, Date, Date)", "filename": "DateUtilsTest.assertWeekIterator.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.setTimeZone", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.setTimeZone", "GregorianCalendar.setTime", "GregorianCalendar.set", "GregorianCalendar.set", "Calendar.get"], "method_name": "DateUtilsTest.testCeil", "method_implementation": "{\n    // test javadoc\n    assertEquals(dateTimeParser.parse(\"March 28, 2002 14:00:00.000\"), DateUtils.ceiling(dateTimeParser.parse(\"March 28, 2002 13:45:01.231\"), Calendar.HOUR), \"ceiling javadoc-1 failed\");\n    assertEquals(dateTimeParser.parse(\"April 1, 2002 00:00:00.000\"), DateUtils.ceiling(dateTimeParser.parse(\"March 28, 2002 13:45:01.231\"), Calendar.MONTH), \"ceiling javadoc-2 failed\");\n    // tests public static Date ceiling(Date date, int field)\n    assertEquals(dateParser.parse(\"January 1, 2003\"), DateUtils.ceiling(date1, Calendar.YEAR), \"ceiling year-1 failed\");\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.ceiling(date2, Calendar.YEAR), \"ceiling year-2 failed\");\n    assertEquals(dateParser.parse(\"March 1, 2002\"), DateUtils.ceiling(date1, Calendar.MONTH), \"ceiling month-1 failed\");\n    assertEquals(dateParser.parse(\"December 1, 2001\"), DateUtils.ceiling(date2, Calendar.MONTH), \"ceiling month-2 failed\");\n    assertEquals(dateParser.parse(\"February 16, 2002\"), DateUtils.ceiling(date1, DateUtils.SEMI_MONTH), \"ceiling semimonth-1 failed\");\n    assertEquals(dateParser.parse(\"December 1, 2001\"), DateUtils.ceiling(date2, DateUtils.SEMI_MONTH), \"ceiling semimonth-2 failed\");\n    assertEquals(dateParser.parse(\"February 13, 2002\"), DateUtils.ceiling(date1, Calendar.DATE), \"ceiling date-1 failed\");\n    assertEquals(dateParser.parse(\"November 19, 2001\"), DateUtils.ceiling(date2, Calendar.DATE), \"ceiling date-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.ceiling(date1, Calendar.HOUR), \"ceiling hour-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 2:00:00.000\"), DateUtils.ceiling(date2, Calendar.HOUR), \"ceiling hour-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.ceiling(date1, Calendar.MINUTE), \"ceiling minute-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:24:00.000\"), DateUtils.ceiling(date2, Calendar.MINUTE), \"ceiling minute-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.ceiling(date1, Calendar.SECOND), \"ceiling second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:12.000\"), DateUtils.ceiling(date2, Calendar.SECOND), \"ceiling second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.ceiling(dateAmPm1, Calendar.AM_PM), \"ceiling ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.ceiling(dateAmPm2, Calendar.AM_PM), \"ceiling ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.ceiling(dateAmPm3, Calendar.AM_PM), \"ceiling ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.ceiling(dateAmPm4, Calendar.AM_PM), \"ceiling ampm-4 failed\");\n    // tests public static Date ceiling(Object date, int field)\n    assertEquals(dateParser.parse(\"January 1, 2003\"), DateUtils.ceiling((Object) date1, Calendar.YEAR), \"ceiling year-1 failed\");\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.ceiling((Object) date2, Calendar.YEAR), \"ceiling year-2 failed\");\n    assertEquals(dateParser.parse(\"March 1, 2002\"), DateUtils.ceiling((Object) date1, Calendar.MONTH), \"ceiling month-1 failed\");\n    assertEquals(dateParser.parse(\"December 1, 2001\"), DateUtils.ceiling((Object) date2, Calendar.MONTH), \"ceiling month-2 failed\");\n    assertEquals(dateParser.parse(\"February 16, 2002\"), DateUtils.ceiling((Object) date1, DateUtils.SEMI_MONTH), \"ceiling semimonth-1 failed\");\n    assertEquals(dateParser.parse(\"December 1, 2001\"), DateUtils.ceiling((Object) date2, DateUtils.SEMI_MONTH), \"ceiling semimonth-2 failed\");\n    assertEquals(dateParser.parse(\"February 13, 2002\"), DateUtils.ceiling((Object) date1, Calendar.DATE), \"ceiling date-1 failed\");\n    assertEquals(dateParser.parse(\"November 19, 2001\"), DateUtils.ceiling((Object) date2, Calendar.DATE), \"ceiling date-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.ceiling((Object) date1, Calendar.HOUR), \"ceiling hour-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 2:00:00.000\"), DateUtils.ceiling((Object) date2, Calendar.HOUR), \"ceiling hour-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.ceiling((Object) date1, Calendar.MINUTE), \"ceiling minute-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:24:00.000\"), DateUtils.ceiling((Object) date2, Calendar.MINUTE), \"ceiling minute-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.ceiling((Object) date1, Calendar.SECOND), \"ceiling second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:12.000\"), DateUtils.ceiling((Object) date2, Calendar.SECOND), \"ceiling second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.ceiling((Object) dateAmPm1, Calendar.AM_PM), \"ceiling ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.ceiling((Object) dateAmPm2, Calendar.AM_PM), \"ceiling ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.ceiling((Object) dateAmPm3, Calendar.AM_PM), \"ceiling ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.ceiling((Object) dateAmPm4, Calendar.AM_PM), \"ceiling ampm-4 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.ceiling((Object) cal1, Calendar.SECOND), \"ceiling calendar second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:12.000\"), DateUtils.ceiling((Object) cal2, Calendar.SECOND), \"ceiling calendar second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.ceiling((Object) calAmPm1, Calendar.AM_PM), \"ceiling ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.ceiling((Object) calAmPm2, Calendar.AM_PM), \"ceiling ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.ceiling((Object) calAmPm3, Calendar.AM_PM), \"ceiling ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.ceiling((Object) calAmPm4, Calendar.AM_PM), \"ceiling ampm-4 failed\");\n    assertThrows(NullPointerException.class, () -> DateUtils.ceiling((Date) null, Calendar.SECOND));\n    assertThrows(NullPointerException.class, () -> DateUtils.ceiling((Calendar) null, Calendar.SECOND));\n    assertThrows(NullPointerException.class, () -> DateUtils.ceiling((Object) null, Calendar.SECOND));\n    assertThrows(ClassCastException.class, () -> DateUtils.ceiling(\"\", Calendar.SECOND));\n    assertThrows(IllegalArgumentException.class, () -> DateUtils.ceiling(date1, -9999));\n    // Fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n    // Test ceiling across the beginning of daylight saving time\n    try {\n        TimeZone.setDefault(zone);\n        dateTimeParser.setTimeZone(zone);\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling(date4, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling((Object) cal4, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling(date5, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling((Object) cal5, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling(date6, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling((Object) cal6, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling(date7, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"), DateUtils.ceiling((Object) cal7, Calendar.DATE), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.ceiling(date4, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.ceiling((Object) cal4, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.ceiling(date5, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.ceiling((Object) cal5, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.ceiling(date6, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.ceiling((Object) cal6, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.ceiling(date7, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.ceiling((Object) cal7, Calendar.HOUR_OF_DAY), \"ceiling MET date across DST change-over\");\n    } finally {\n        TimeZone.setDefault(DEFAULT_ZONE);\n        dateTimeParser.setTimeZone(DEFAULT_ZONE);\n    }\n    // Bug 31395, large dates\n    // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n    final Date endOfTime = new Date(Long.MAX_VALUE);\n    final GregorianCalendar endCal = new GregorianCalendar();\n    endCal.setTime(endOfTime);\n    assertThrows(ArithmeticException.class, () -> DateUtils.ceiling(endCal, Calendar.DATE));\n    endCal.set(Calendar.YEAR, 280000001);\n    assertThrows(ArithmeticException.class, () -> DateUtils.ceiling(endCal, Calendar.DATE));\n    endCal.set(Calendar.YEAR, 280000000);\n    final Calendar cal = DateUtils.ceiling(endCal, Calendar.DATE);\n    assertEquals(0, cal.get(Calendar.HOUR));\n}", "repo_id": "8", "comment": "/**\n * Tests various values with the ceiling method\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1834, "method_signature": "void testCeil()", "filename": "DateUtilsTest.testCeil.json"}
{"callee_method_names": [], "method_name": "DateUtilsTest.testIteratorEx", "method_implementation": "{\n    assertThrows(IllegalArgumentException.class, () -> DateUtils.iterator(Calendar.getInstance(), -9999));\n    assertThrows(NullPointerException.class, () -> DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER));\n    assertThrows(NullPointerException.class, () -> DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER));\n    assertThrows(NullPointerException.class, () -> DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER));\n    assertThrows(ClassCastException.class, () -> DateUtils.iterator(\"\", DateUtils.RANGE_WEEK_CENTER));\n}", "repo_id": "8", "comment": "/**\n * Tests the iterator exceptions\n */\n", "repo_name": "commons-lang-master/", "id": 1835, "method_signature": "void testIteratorEx()", "filename": "DateUtilsTest.testIteratorEx.json"}
{"callee_method_names": [], "method_name": "DateUtilsTest.testLANG799_DE_FAIL", "method_implementation": "{\n    assertThrows(ParseException.class, () -> DateUtils.parseDate(\"Wed, 09 Apr 2008 23:55:38 GMT\", \"EEE, dd MMM yyyy HH:mm:ss zzz\"));\n}", "repo_id": "8", "comment": "/**\n * Parse English date with German Locale.\n */\n", "repo_name": "commons-lang-master/", "id": 1837, "method_signature": "void testLANG799_DE_FAIL()", "filename": "DateUtilsTest.testLANG799_DE_FAIL.json"}
{"callee_method_names": [], "method_name": "DateUtilsTest.testLANG799_EN_FAIL", "method_implementation": "{\n    assertThrows(ParseException.class, () -> DateUtils.parseDate(\"Mi, 09 Apr 2008 23:55:38 GMT\", \"EEE, dd MMM yyyy HH:mm:ss zzz\"));\n}", "repo_id": "8", "comment": "// Parse German date with English Locale\n", "repo_name": "commons-lang-master/", "id": 1838, "method_signature": "void testLANG799_EN_FAIL()", "filename": "DateUtilsTest.testLANG799_EN_FAIL.json"}
{"callee_method_names": [], "method_name": "DateUtilsTest.testLANG799_EN_WITH_DE_LOCALE", "method_implementation": "{\n    DateUtils.parseDate(\"Mi, 09 Apr 2008 23:55:38 GMT\", Locale.GERMAN, \"EEE, dd MMM yyyy HH:mm:ss zzz\");\n}", "repo_id": "8", "comment": "/**\n * Parse German date with English Locale, specifying German Locale override.\n */\n", "repo_name": "commons-lang-master/", "id": 1839, "method_signature": "void testLANG799_EN_WITH_DE_LOCALE()", "filename": "DateUtilsTest.testLANG799_EN_WITH_DE_LOCALE.json"}
{"callee_method_names": ["Date.getTime", "Date.getTime", "Date.getTime"], "method_name": "DateUtilsTest.testLang530", "method_implementation": "{\n    final Date d = new Date();\n    final String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);\n    final Date d2 = DateUtils.parseDate(isoDateStr, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern());\n    // the format loses milliseconds so have to reintroduce them\n    assertEquals(d.getTime(), d2.getTime() + d.getTime() % 1000, \"Date not equal to itself ISO formatted and parsed\");\n}", "repo_id": "8", "comment": "/**\n * See https://issues.apache.org/jira/browse/LANG-530\n */\n", "repo_name": "commons-lang-master/", "id": 1836, "method_signature": "void testLang530()", "filename": "DateUtilsTest.testLang530.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse"], "method_name": "DateUtilsTest.testMonthIterator", "method_implementation": "{\n    Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY);\n    assertWeekIterator(it, dateParser.parse(\"January 27, 2002\"), dateParser.parse(\"March 2, 2002\"));\n    it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY);\n    assertWeekIterator(it, dateParser.parse(\"January 28, 2002\"), dateParser.parse(\"March 3, 2002\"));\n    it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY);\n    assertWeekIterator(it, dateParser.parse(\"October 28, 2001\"), dateParser.parse(\"December 1, 2001\"));\n    it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY);\n    assertWeekIterator(it, dateParser.parse(\"October 29, 2001\"), dateParser.parse(\"December 2, 2001\"));\n}", "repo_id": "8", "comment": "/**\n * Tests the calendar iterator for month-based ranges\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1840, "method_signature": "void testMonthIterator()", "filename": "DateUtilsTest.testMonthIterator.json"}
{"callee_method_names": ["GregorianCalendar.getTime"], "method_name": "DateUtilsTest.testParseDateWithLeniency", "method_implementation": "{\n    final GregorianCalendar cal = new GregorianCalendar(1998, 6, 30);\n    final String dateStr = \"02 942, 1996\";\n    final String[] parsers = { \"MM DDD, yyyy\" };\n    final Date date = DateUtils.parseDate(dateStr, parsers);\n    assertEquals(cal.getTime(), date);\n    assertThrows(ParseException.class, () -> DateUtils.parseDateStrictly(dateStr, parsers));\n}", "repo_id": "8", "comment": "/**\n * LANG-486\n */\n", "repo_name": "commons-lang-master/", "id": 1841, "method_signature": "void testParseDateWithLeniency()", "filename": "DateUtilsTest.testParseDateWithLeniency.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.setTimeZone", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.setTimeZone"], "method_name": "DateUtilsTest.testRound", "method_implementation": "{\n    // tests for public static Date round(Date date, int field)\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.round(date1, Calendar.YEAR), \"round year-1 failed\");\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.round(date2, Calendar.YEAR), \"round year-2 failed\");\n    assertEquals(dateParser.parse(\"February 1, 2002\"), DateUtils.round(date1, Calendar.MONTH), \"round month-1 failed\");\n    assertEquals(dateParser.parse(\"December 1, 2001\"), DateUtils.round(date2, Calendar.MONTH), \"round month-2 failed\");\n    assertEquals(dateParser.parse(\"February 1, 2002\"), DateUtils.round(date0, DateUtils.SEMI_MONTH), \"round semimonth-0 failed\");\n    assertEquals(dateParser.parse(\"February 16, 2002\"), DateUtils.round(date1, DateUtils.SEMI_MONTH), \"round semimonth-1 failed\");\n    assertEquals(dateParser.parse(\"November 16, 2001\"), DateUtils.round(date2, DateUtils.SEMI_MONTH), \"round semimonth-2 failed\");\n    assertEquals(dateParser.parse(\"February 13, 2002\"), DateUtils.round(date1, Calendar.DATE), \"round date-1 failed\");\n    assertEquals(dateParser.parse(\"November 18, 2001\"), DateUtils.round(date2, Calendar.DATE), \"round date-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.round(date1, Calendar.HOUR), \"round hour-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.round(date2, Calendar.HOUR), \"round hour-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.round(date1, Calendar.MINUTE), \"round minute-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.round(date2, Calendar.MINUTE), \"round minute-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round(date1, Calendar.SECOND), \"round second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round(date2, Calendar.SECOND), \"round second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round(dateAmPm1, Calendar.AM_PM), \"round ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round(dateAmPm2, Calendar.AM_PM), \"round ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round(dateAmPm3, Calendar.AM_PM), \"round ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round(dateAmPm4, Calendar.AM_PM), \"round ampm-4 failed\");\n    // tests for public static Date round(Object date, int field)\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.round((Object) date1, Calendar.YEAR), \"round year-1 failed\");\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.round((Object) date2, Calendar.YEAR), \"round year-2 failed\");\n    assertEquals(dateParser.parse(\"February 1, 2002\"), DateUtils.round((Object) date1, Calendar.MONTH), \"round month-1 failed\");\n    assertEquals(dateParser.parse(\"December 1, 2001\"), DateUtils.round((Object) date2, Calendar.MONTH), \"round month-2 failed\");\n    assertEquals(dateParser.parse(\"February 16, 2002\"), DateUtils.round((Object) date1, DateUtils.SEMI_MONTH), \"round semimonth-1 failed\");\n    assertEquals(dateParser.parse(\"November 16, 2001\"), DateUtils.round((Object) date2, DateUtils.SEMI_MONTH), \"round semimonth-2 failed\");\n    assertEquals(dateParser.parse(\"February 13, 2002\"), DateUtils.round((Object) date1, Calendar.DATE), \"round date-1 failed\");\n    assertEquals(dateParser.parse(\"November 18, 2001\"), DateUtils.round((Object) date2, Calendar.DATE), \"round date-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.round((Object) date1, Calendar.HOUR), \"round hour-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.round((Object) date2, Calendar.HOUR), \"round hour-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.round((Object) date1, Calendar.MINUTE), \"round minute-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.round((Object) date2, Calendar.MINUTE), \"round minute-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round((Object) date1, Calendar.SECOND), \"round second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round((Object) date2, Calendar.SECOND), \"round second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round((Object) cal1, Calendar.SECOND), \"round calendar second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round((Object) cal2, Calendar.SECOND), \"round calendar second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round((Object) dateAmPm1, Calendar.AM_PM), \"round ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) dateAmPm2, Calendar.AM_PM), \"round ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) dateAmPm3, Calendar.AM_PM), \"round ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round((Object) dateAmPm4, Calendar.AM_PM), \"round ampm-4 failed\");\n    assertThrows(NullPointerException.class, () -> DateUtils.round((Date) null, Calendar.SECOND));\n    assertThrows(NullPointerException.class, () -> DateUtils.round((Calendar) null, Calendar.SECOND));\n    assertThrows(NullPointerException.class, () -> DateUtils.round((Object) null, Calendar.SECOND));\n    assertThrows(ClassCastException.class, () -> DateUtils.round(\"\", Calendar.SECOND));\n    assertThrows(IllegalArgumentException.class, () -> DateUtils.round(date1, -9999));\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round((Object) calAmPm1, Calendar.AM_PM), \"round ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) calAmPm2, Calendar.AM_PM), \"round ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) calAmPm3, Calendar.AM_PM), \"round ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round((Object) calAmPm4, Calendar.AM_PM), \"round ampm-4 failed\");\n    // Fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=25560 / LANG-13\n    // Test rounding across the beginning of daylight saving time\n    try {\n        TimeZone.setDefault(zone);\n        dateTimeParser.setTimeZone(zone);\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date4, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal4, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date5, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal5, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date6, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal6, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date7, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal7, Calendar.DATE), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"), DateUtils.round(date4, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"), DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round(date5, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round(date6, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.round(date7, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY), \"round MET date across DST change-over\");\n    } finally {\n        TimeZone.setDefault(DEFAULT_ZONE);\n        dateTimeParser.setTimeZone(DEFAULT_ZONE);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests various values with the round method\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1842, "method_signature": "void testRound()", "filename": "DateUtilsTest.testRound.json"}
{"callee_method_names": ["Calendar.set", "Calendar.getTime", "DateFormat.parse", "Calendar.set", "Calendar.getTime", "DateFormat.parse", "Calendar.set", "Calendar.set", "Calendar.getTime", "DateFormat.parse", "Calendar.set", "Calendar.set", "Calendar.getTime", "DateFormat.parse", "Calendar.set", "Calendar.set", "Calendar.getTime", "DateFormat.parse", "Calendar.set", "Calendar.set", "Calendar.getTime", "DateFormat.parse", "Calendar.set", "Calendar.getTime", "DateFormat.parse", "Calendar.set", "Calendar.getTime", "DateFormat.parse"], "method_name": "DateUtilsTest.testRoundLang346", "method_implementation": "{\n    final Calendar testCalendar = Calendar.getInstance();\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);\n    Date date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 08:09:00.000\"), DateUtils.round(date, Calendar.MINUTE), \"Minute Round Up Failed\");\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 20);\n    date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 08:08:00.000\"), DateUtils.round(date, Calendar.MINUTE), \"Minute No Round Failed\");\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);\n    testCalendar.set(Calendar.MILLISECOND, 600);\n    date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 08:08:51.000\"), DateUtils.round(date, Calendar.SECOND), \"Second Round Up with 600 Milli Seconds Failed\");\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);\n    testCalendar.set(Calendar.MILLISECOND, 200);\n    date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 08:08:50.000\"), DateUtils.round(date, Calendar.SECOND), \"Second Round Down with 200 Milli Seconds Failed\");\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 20);\n    testCalendar.set(Calendar.MILLISECOND, 600);\n    date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 08:08:21.000\"), DateUtils.round(date, Calendar.SECOND), \"Second Round Up with 200 Milli Seconds Failed\");\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 20);\n    testCalendar.set(Calendar.MILLISECOND, 200);\n    date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 08:08:20.000\"), DateUtils.round(date, Calendar.SECOND), \"Second Round Down with 200 Milli Seconds Failed\");\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);\n    date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 08:00:00.000\"), DateUtils.round(date, Calendar.HOUR), \"Hour Round Down Failed\");\n    testCalendar.set(2007, Calendar.JULY, 2, 8, 31, 50);\n    date = testCalendar.getTime();\n    assertEquals(dateTimeParser.parse(\"July 2, 2007 09:00:00.000\"), DateUtils.round(date, Calendar.HOUR), \"Hour Round Up Failed\");\n}", "repo_id": "8", "comment": "/**\n * Tests the Changes Made by LANG-346 to the DateUtils.modify() private method invoked\n * by DateUtils.round().\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1843, "method_signature": "void testRoundLang346()", "filename": "DateUtilsTest.testRoundLang346.json"}
{"callee_method_names": ["DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.setTimeZone", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.parse", "DateFormat.setTimeZone", "GregorianCalendar.setTime", "GregorianCalendar.set", "GregorianCalendar.set", "Calendar.get"], "method_name": "DateUtilsTest.testTruncate", "method_implementation": "{\n    // tests public static Date truncate(Date date, int field)\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.truncate(date1, Calendar.YEAR), \"truncate year-1 failed\");\n    assertEquals(dateParser.parse(\"January 1, 2001\"), DateUtils.truncate(date2, Calendar.YEAR), \"truncate year-2 failed\");\n    assertEquals(dateParser.parse(\"February 1, 2002\"), DateUtils.truncate(date1, Calendar.MONTH), \"truncate month-1 failed\");\n    assertEquals(dateParser.parse(\"November 1, 2001\"), DateUtils.truncate(date2, Calendar.MONTH), \"truncate month-2 failed\");\n    assertEquals(dateParser.parse(\"February 1, 2002\"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH), \"truncate semimonth-1 failed\");\n    assertEquals(dateParser.parse(\"November 16, 2001\"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH), \"truncate semimonth-2 failed\");\n    assertEquals(dateParser.parse(\"February 12, 2002\"), DateUtils.truncate(date1, Calendar.DATE), \"truncate date-1 failed\");\n    assertEquals(dateParser.parse(\"November 18, 2001\"), DateUtils.truncate(date2, Calendar.DATE), \"truncate date-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"), DateUtils.truncate(date1, Calendar.HOUR), \"truncate hour-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.truncate(date2, Calendar.HOUR), \"truncate hour-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"), DateUtils.truncate(date1, Calendar.MINUTE), \"truncate minute-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.truncate(date2, Calendar.MINUTE), \"truncate minute-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate(date1, Calendar.SECOND), \"truncate second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate(date2, Calendar.SECOND), \"truncate second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate(dateAmPm1, Calendar.AM_PM), \"truncate ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate(dateAmPm2, Calendar.AM_PM), \"truncate ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate(dateAmPm3, Calendar.AM_PM), \"truncate ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate(dateAmPm4, Calendar.AM_PM), \"truncate ampm-4 failed\");\n    // tests public static Date truncate(Object date, int field)\n    assertEquals(dateParser.parse(\"January 1, 2002\"), DateUtils.truncate((Object) date1, Calendar.YEAR), \"truncate year-1 failed\");\n    assertEquals(dateParser.parse(\"January 1, 2001\"), DateUtils.truncate((Object) date2, Calendar.YEAR), \"truncate year-2 failed\");\n    assertEquals(dateParser.parse(\"February 1, 2002\"), DateUtils.truncate((Object) date1, Calendar.MONTH), \"truncate month-1 failed\");\n    assertEquals(dateParser.parse(\"November 1, 2001\"), DateUtils.truncate((Object) date2, Calendar.MONTH), \"truncate month-2 failed\");\n    assertEquals(dateParser.parse(\"February 1, 2002\"), DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH), \"truncate semimonth-1 failed\");\n    assertEquals(dateParser.parse(\"November 16, 2001\"), DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH), \"truncate semimonth-2 failed\");\n    assertEquals(dateParser.parse(\"February 12, 2002\"), DateUtils.truncate((Object) date1, Calendar.DATE), \"truncate date-1 failed\");\n    assertEquals(dateParser.parse(\"November 18, 2001\"), DateUtils.truncate((Object) date2, Calendar.DATE), \"truncate date-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"), DateUtils.truncate((Object) date1, Calendar.HOUR), \"truncate hour-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.truncate((Object) date2, Calendar.HOUR), \"truncate hour-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"), DateUtils.truncate((Object) date1, Calendar.MINUTE), \"truncate minute-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.truncate((Object) date2, Calendar.MINUTE), \"truncate minute-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate((Object) date1, Calendar.SECOND), \"truncate second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate((Object) date2, Calendar.SECOND), \"truncate second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM), \"truncate ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM), \"truncate ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM), \"truncate ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM), \"truncate ampm-4 failed\");\n    assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate((Object) cal1, Calendar.SECOND), \"truncate calendar second-1 failed\");\n    assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate((Object) cal2, Calendar.SECOND), \"truncate calendar second-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM), \"truncate ampm-1 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM), \"truncate ampm-2 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM), \"truncate ampm-3 failed\");\n    assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM), \"truncate ampm-4 failed\");\n    assertThrows(NullPointerException.class, () -> DateUtils.truncate((Date) null, Calendar.SECOND));\n    assertThrows(NullPointerException.class, () -> DateUtils.truncate((Calendar) null, Calendar.SECOND));\n    assertThrows(NullPointerException.class, () -> DateUtils.truncate((Object) null, Calendar.SECOND));\n    assertThrows(ClassCastException.class, () -> DateUtils.truncate(\"\", Calendar.SECOND));\n    // Fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n    // Test truncate across beginning of daylight saving time\n    try {\n        TimeZone.setDefault(zone);\n        dateTimeParser.setTimeZone(zone);\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.truncate(date3, Calendar.DATE), \"truncate MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.truncate((Object) cal3, Calendar.DATE), \"truncate MET date across DST change-over\");\n        // Test truncate across end of daylight saving time\n        assertEquals(dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"), DateUtils.truncate(date8, Calendar.DATE), \"truncate MET date across DST change-over\");\n        assertEquals(dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"), DateUtils.truncate((Object) cal8, Calendar.DATE), \"truncate MET date across DST change-over\");\n    } finally {\n        TimeZone.setDefault(DEFAULT_ZONE);\n        dateTimeParser.setTimeZone(DEFAULT_ZONE);\n    }\n    // Bug 31395, large dates\n    // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n    final Date endOfTime = new Date(Long.MAX_VALUE);\n    final GregorianCalendar endCal = new GregorianCalendar();\n    endCal.setTime(endOfTime);\n    assertThrows(ArithmeticException.class, () -> DateUtils.truncate(endCal, Calendar.DATE));\n    endCal.set(Calendar.YEAR, 280000001);\n    assertThrows(ArithmeticException.class, () -> DateUtils.truncate(endCal, Calendar.DATE));\n    endCal.set(Calendar.YEAR, 280000000);\n    final Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);\n    assertEquals(0, cal.get(Calendar.HOUR));\n}", "repo_id": "8", "comment": "/**\n * Tests various values with the trunc method\n *\n * @throws Exception so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1844, "method_signature": "void testTruncate()", "filename": "DateUtilsTest.testTruncate.json"}
{"callee_method_names": ["DateFormat.setTimeZone", "Date.getTime", "Date.getTime", "Date.getTime", "Date.getTime", "DateFormat.format", "DateFormat.format", "DateFormat.format", "DateFormat.format", "DateFormat.format", "Calendar.setTime", "Date.getTime", "Calendar.set", "Calendar.get", "Calendar.getTime", "Date.getTime"], "method_name": "DateUtilsTest.testTruncateLang59", "method_implementation": "{\n    try {\n        // Set TimeZone to Mountain Time\n        final TimeZone denverZone = TimeZone.getTimeZone(\"America/Denver\");\n        TimeZone.setDefault(denverZone);\n        final DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS XXX\");\n        format.setTimeZone(denverZone);\n        final Date oct31_01MDT = new Date(1099206000000L);\n        // - 1 hour\n        final Date oct31MDT = new Date(oct31_01MDT.getTime() - 3600000L);\n        // + 2 minutes\n        final Date oct31_01_02MDT = new Date(oct31_01MDT.getTime() + 120000L);\n        // + 3 seconds\n        final Date oct31_01_02_03MDT = new Date(oct31_01_02MDT.getTime() + 3000L);\n        // + 4 milliseconds\n        final Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);\n        assertEquals(\"2004-10-31 00:00:00.000 -06:00\", format.format(oct31MDT), \"Check 00:00:00.000\");\n        assertEquals(\"2004-10-31 01:00:00.000 -06:00\", format.format(oct31_01MDT), \"Check 01:00:00.000\");\n        assertEquals(\"2004-10-31 01:02:00.000 -06:00\", format.format(oct31_01_02MDT), \"Check 01:02:00.000\");\n        assertEquals(\"2004-10-31 01:02:03.000 -06:00\", format.format(oct31_01_02_03MDT), \"Check 01:02:03.000\");\n        assertEquals(\"2004-10-31 01:02:03.004 -06:00\", format.format(oct31_01_02_03_04MDT), \"Check 01:02:03.004\");\n        // ------- Demonstrate Problem -------\n        final Calendar gval = Calendar.getInstance();\n        gval.setTime(new Date(oct31_01MDT.getTime()));\n        // set minutes to the same value\n        gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE));\n        assertEquals(gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L, \"Demonstrate Problem\");\n        // ---------- Test Truncate ----------\n        assertEquals(oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND), \"Truncate Calendar.MILLISECOND\");\n        assertEquals(oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND), \"Truncate Calendar.SECOND\");\n        assertEquals(oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE), \"Truncate Calendar.MINUTE\");\n        assertEquals(oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY), \"Truncate Calendar.HOUR_OF_DAY\");\n        assertEquals(oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR), \"Truncate Calendar.HOUR\");\n        assertEquals(oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE), \"Truncate Calendar.DATE\");\n        // ---------- Test Round (down) ----------\n        assertEquals(oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND), \"Round Calendar.MILLISECOND\");\n        assertEquals(oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND), \"Round Calendar.SECOND\");\n        assertEquals(oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE), \"Round Calendar.MINUTE\");\n        assertEquals(oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY), \"Round Calendar.HOUR_OF_DAY\");\n        assertEquals(oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR), \"Round Calendar.HOUR\");\n        assertEquals(oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE), \"Round Calendar.DATE\");\n    } finally {\n        // restore default time zone\n        TimeZone.setDefault(DEFAULT_ZONE);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests for LANG-59\n *\n * see https://issues.apache.org/jira/browse/LANG-59\n */\n", "repo_name": "commons-lang-master/", "id": 1845, "method_signature": "void testTruncateLang59()", "filename": "DateUtilsTest.testTruncateLang59.json"}
{"callee_method_names": ["Calendar.add", "Calendar.get", "Calendar.get", "Calendar.add", "Calendar.add", "Calendar.get", "Calendar.add", "Calendar.getTime", "Iterator<?>.next", "Calendar.add"], "method_name": "DateUtilsTest.testWeekIterator", "method_implementation": "{\n    final Calendar now = Calendar.getInstance();\n    for (int i = 0; i < 7; i++) {\n        final Calendar today = DateUtils.truncate(now, Calendar.DATE);\n        final Calendar sunday = DateUtils.truncate(now, Calendar.DATE);\n        sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n        final Calendar monday = DateUtils.truncate(now, Calendar.DATE);\n        if (monday.get(Calendar.DAY_OF_WEEK) == 1) {\n            //This is sunday... roll back 6 days\n            monday.add(Calendar.DATE, -6);\n        } else {\n            monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n        }\n        final Calendar centered = DateUtils.truncate(now, Calendar.DATE);\n        centered.add(Calendar.DATE, -3);\n        Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY);\n        assertWeekIterator(it, sunday);\n        it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY);\n        assertWeekIterator(it, monday);\n        it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE);\n        assertWeekIterator(it, today);\n        it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n        assertWeekIterator(it, centered);\n        it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER);\n        assertWeekIterator(it, centered);\n        final Iterator<?> it2 = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER);\n        assertWeekIterator(it2, centered);\n        assertThrows(NoSuchElementException.class, it2::next);\n        final Iterator<?> it3 = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n        it3.next();\n        assertThrows(UnsupportedOperationException.class, it3::remove);\n        now.add(Calendar.DATE, 1);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests the calendar iterator for week ranges\n */\n", "repo_name": "commons-lang-master/", "id": 1846, "method_signature": "void testWeekIterator()", "filename": "DateUtilsTest.testWeekIterator.json"}
{"callee_method_names": ["ArrayList.add"], "method_name": "DefaultExceptionContext.addContextValue", "method_implementation": "{\n    contextValues.add(new ImmutablePair<>(label, value));\n    return this;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 545, "method_signature": "DefaultExceptionContext addContextValue(String, Object)", "filename": "DefaultExceptionContext.addContextValue.json"}
{"callee_method_names": ["StringBuilder.append", "ArrayList.isEmpty", "StringBuilder.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Object.toString", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "DefaultExceptionContext.getFormattedExceptionMessage", "method_implementation": "{\n    final StringBuilder buffer = new StringBuilder(256);\n    if (baseMessage != null) {\n        buffer.append(baseMessage);\n    }\n    if (!contextValues.isEmpty()) {\n        if (buffer.length() > 0) {\n            buffer.append('\\n');\n        }\n        buffer.append(\"Exception Context:\\n\");\n        int i = 0;\n        for (final Pair<String, Object> pair : contextValues) {\n            buffer.append(\"\\t[\");\n            buffer.append(++i);\n            buffer.append(':');\n            buffer.append(pair.getKey());\n            buffer.append(\"=\");\n            final Object value = pair.getValue();\n            if (value == null) {\n                buffer.append(\"null\");\n            } else {\n                String valueStr;\n                try {\n                    valueStr = value.toString();\n                } catch (final Exception e) {\n                    valueStr = \"Exception thrown on toString(): \" + ExceptionUtils.getStackTrace(e);\n                }\n                buffer.append(valueStr);\n            }\n            buffer.append(\"]\\n\");\n        }\n        buffer.append(\"---------------------------------\");\n    }\n    return buffer.toString();\n}", "repo_id": "8", "comment": "/**\n * Builds the message containing the contextual information.\n *\n * @param baseMessage  the base exception message <b>without</b> context information appended\n * @return the exception message <b>with</b> context information appended, never null\n */\n", "repo_name": "commons-lang-master/", "id": 546, "method_signature": "String getFormattedExceptionMessage(String)", "filename": "DefaultExceptionContext.getFormattedExceptionMessage.json"}
{"callee_method_names": ["ArrayList.removeIf", "Pattern.getKey"], "method_name": "DefaultExceptionContext.setContextValue", "method_implementation": "{\n    contextValues.removeIf(p -> StringUtils.equals(label, p.getKey()));\n    addContextValue(label, value);\n    return this;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 547, "method_signature": "DefaultExceptionContext setContextValue(String, Object)", "filename": "DefaultExceptionContext.setContextValue.json"}
{"callee_method_names": [], "method_name": "DiffBuilder.append", "method_implementation": "{\n    if (equals || lhs == rhs) {\n        return this;\n    }\n    // rhs cannot be null, as lhs != rhs\n    final Object test = lhs != null ? lhs : rhs;\n    if (ObjectUtils.isArray(test)) {\n        if (test instanceof boolean[]) {\n            return append(fieldName, (boolean[]) lhs, (boolean[]) rhs);\n        }\n        if (test instanceof byte[]) {\n            return append(fieldName, (byte[]) lhs, (byte[]) rhs);\n        }\n        if (test instanceof char[]) {\n            return append(fieldName, (char[]) lhs, (char[]) rhs);\n        }\n        if (test instanceof double[]) {\n            return append(fieldName, (double[]) lhs, (double[]) rhs);\n        }\n        if (test instanceof float[]) {\n            return append(fieldName, (float[]) lhs, (float[]) rhs);\n        }\n        if (test instanceof int[]) {\n            return append(fieldName, (int[]) lhs, (int[]) rhs);\n        }\n        if (test instanceof long[]) {\n            return append(fieldName, (long[]) lhs, (long[]) rhs);\n        }\n        if (test instanceof short[]) {\n            return append(fieldName, (short[]) lhs, (short[]) rhs);\n        }\n        return append(fieldName, (Object[]) lhs, (Object[]) rhs);\n    }\n    // Not array type\n    return Objects.equals(lhs, rhs) ? this : add(fieldName, () -> lhs, () -> rhs, Object.class);\n}", "repo_id": "8", "comment": "/**\n * Test if two {@link Objects}s are equal.\n *\n * @param fieldName the field name\n * @param lhs       the left-hand side {@link Object}\n * @param rhs       the right-hand side {@link Object}\n * @return this\n * @throws NullPointerException if field name is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 888, "method_signature": "DiffBuilder<T> append(String, Object, Object)", "filename": "DiffBuilder.append.json"}
{"callee_method_names": ["TypeTestClass.diff", "DiffResult<TypeTestClass>.getNumberOfDiffs"], "method_name": "DiffBuilderTest.testObjectsNotSameButEqual", "method_implementation": "{\n    final TypeTestClass left = new TypeTestClass();\n    left.objectField = Integer.valueOf(1000);\n    final TypeTestClass right = new TypeTestClass();\n    right.objectField = Integer.valueOf(1000);\n    assertNotSame(left.objectField, right.objectField);\n    assertEquals(left.objectField, right.objectField);\n    final DiffResult<TypeTestClass> list = left.diff(right);\n    assertEquals(0, list.getNumberOfDiffs());\n}", "repo_id": "8", "comment": "/**\n * Test that \"left\" and \"right\" are the same instance but are equal.\n */\n", "repo_name": "commons-lang-master/", "id": 1987, "method_signature": "void testObjectsNotSameButEqual()", "filename": "DiffBuilderTest.testObjectsNotSameButEqual.json"}
{"callee_method_names": ["TypeTestClass.diff", "DiffResult<TypeTestClass>.getNumberOfDiffs"], "method_name": "DiffBuilderTest.testObjectsNotSameNorEqual", "method_implementation": "{\n    final TypeTestClass left = new TypeTestClass();\n    left.objectField = 4;\n    final TypeTestClass right = new TypeTestClass();\n    right.objectField = 100;\n    assertNotSame(left.objectField, right.objectField);\n    assertNotEquals(left.objectField, right.objectField);\n    final DiffResult<TypeTestClass> list = left.diff(right);\n    assertEquals(1, list.getNumberOfDiffs());\n}", "repo_id": "8", "comment": "/**\n * Test that \"left\" and \"right\" are not the same instance and are not equal.\n */\n", "repo_name": "commons-lang-master/", "id": 1988, "method_signature": "void testObjectsNotSameNorEqual()", "filename": "DiffBuilderTest.testObjectsNotSameNorEqual.json"}
{"callee_method_names": ["TypeTestClass.diff", "DiffResult<TypeTestClass>.getNumberOfDiffs"], "method_name": "DiffBuilderTest.testObjectsSameAndEqual", "method_implementation": "{\n    final Integer sameObject = 1;\n    final TypeTestClass left = new TypeTestClass();\n    left.objectField = sameObject;\n    final TypeTestClass right = new TypeTestClass();\n    right.objectField = sameObject;\n    assertSame(left.objectField, right.objectField);\n    assertEquals(left.objectField, right.objectField);\n    final DiffResult<TypeTestClass> list = left.diff(right);\n    assertEquals(0, list.getNumberOfDiffs());\n}", "repo_id": "8", "comment": "/**\n * Test that \"left\" and \"right\" are the same instance and are equal.\n */\n", "repo_name": "commons-lang-master/", "id": 1989, "method_signature": "void testObjectsSameAndEqual()", "filename": "DiffBuilderTest.testObjectsSameAndEqual.json"}
{"callee_method_names": ["List<Diff<?>>.isEmpty", "List<Diff<?>>.forEach", "ToStringBuilder.append", "ToStringBuilder.append", "ToStringBuilder.build", "ToStringBuilder.build"], "method_name": "DiffResult.toString", "method_implementation": "{\n    if (diffList.isEmpty()) {\n        return OBJECTS_SAME_STRING;\n    }\n    final ToStringBuilder lhsBuilder = new ToStringBuilder(lhs, style);\n    final ToStringBuilder rhsBuilder = new ToStringBuilder(rhs, style);\n    diffList.forEach(diff -> {\n        lhsBuilder.append(diff.getFieldName(), diff.getLeft());\n        rhsBuilder.append(diff.getFieldName(), diff.getRight());\n    });\n    return String.format(toStringFormat, lhsBuilder.build(), rhsBuilder.build());\n}", "repo_id": "8", "comment": "/**\n * Builds a {@link String} description of the differences contained within\n * this {@link DiffResult}, using the supplied {@link ToStringStyle}.\n *\n * @param style\n *            the {@link ToStringStyle} to use when outputting the objects\n *\n * @return a {@link String} description of the differences.\n */\n", "repo_name": "commons-lang-master/", "id": 886, "method_signature": "String toString(ToStringStyle)", "filename": "DiffResult.toString.json"}
{"callee_method_names": ["Token.getClass", "Token.toString"], "method_name": "DurationFormatUtils.equals", "method_implementation": "{\n    if (obj2 instanceof Token) {\n        final Token tok2 = (Token) obj2;\n        if (this.value.getClass() != tok2.value.getClass()) {\n            return false;\n        }\n        if (this.count != tok2.count) {\n            return false;\n        }\n        if (this.value instanceof StringBuilder) {\n            return this.value.toString().equals(tok2.value.toString());\n        }\n        if (this.value instanceof Number) {\n            return this.value.equals(tok2.value);\n        }\n        return this.value == tok2.value;\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Supports equality of this Token to another Token.\n *\n * @param obj2 Object to consider equality of\n * @return boolean {@code true} if equal\n */\n", "repo_name": "commons-lang-master/", "id": 606, "method_signature": "boolean equals(Object)", "filename": "DurationFormatUtils.equals.json"}
{"callee_method_names": ["String.getValue", "String.getCount", "StringBuilder.length", "StringBuilder.append", "Object.toString", "Object.equals", "StringBuilder.append", "Object.equals", "StringBuilder.append", "Object.equals", "StringBuilder.append", "Object.equals", "StringBuilder.append", "Object.equals", "StringBuilder.append", "Object.equals", "StringBuilder.append", "Object.equals", "StringBuilder.append", "StringBuilder.append", "StringBuilder.delete", "StringBuilder.length", "StringBuilder.toString"], "method_name": "DurationFormatUtils.format", "method_implementation": "{\n    final StringBuilder buffer = new StringBuilder();\n    boolean lastOutputSeconds = false;\n    boolean lastOutputZero = false;\n    int optionalStart = -1;\n    boolean firstOptionalNonLiteral = false;\n    int optionalIndex = -1;\n    boolean inOptional = false;\n    for (final Token token : tokens) {\n        final Object value = token.getValue();\n        final boolean isLiteral = value instanceof StringBuilder;\n        final int count = token.getCount();\n        if (optionalIndex != token.optionalIndex) {\n            optionalIndex = token.optionalIndex;\n            if (optionalIndex > -1) {\n                //entering new optional block\n                optionalStart = buffer.length();\n                lastOutputZero = false;\n                inOptional = true;\n                firstOptionalNonLiteral = false;\n            } else {\n                //leaving optional block\n                inOptional = false;\n            }\n        }\n        if (isLiteral) {\n            if (!inOptional || !lastOutputZero) {\n                buffer.append(value.toString());\n            }\n        } else if (value.equals(y)) {\n            lastOutputSeconds = false;\n            lastOutputZero = years == 0;\n            if (!inOptional || !lastOutputZero) {\n                buffer.append(paddedValue(years, padWithZeros, count));\n            }\n        } else if (value.equals(M)) {\n            lastOutputSeconds = false;\n            lastOutputZero = months == 0;\n            if (!inOptional || !lastOutputZero) {\n                buffer.append(paddedValue(months, padWithZeros, count));\n            }\n        } else if (value.equals(d)) {\n            lastOutputSeconds = false;\n            lastOutputZero = days == 0;\n            if (!inOptional || !lastOutputZero) {\n                buffer.append(paddedValue(days, padWithZeros, count));\n            }\n        } else if (value.equals(H)) {\n            lastOutputSeconds = false;\n            lastOutputZero = hours == 0;\n            if (!inOptional || !lastOutputZero) {\n                buffer.append(paddedValue(hours, padWithZeros, count));\n            }\n        } else if (value.equals(m)) {\n            lastOutputSeconds = false;\n            lastOutputZero = minutes == 0;\n            if (!inOptional || !lastOutputZero) {\n                buffer.append(paddedValue(minutes, padWithZeros, count));\n            }\n        } else if (value.equals(s)) {\n            lastOutputSeconds = true;\n            lastOutputZero = seconds == 0;\n            if (!inOptional || !lastOutputZero) {\n                buffer.append(paddedValue(seconds, padWithZeros, count));\n            }\n        } else if (value.equals(S)) {\n            lastOutputZero = milliseconds == 0;\n            if (!inOptional || !lastOutputZero) {\n                if (lastOutputSeconds) {\n                    // ensure at least 3 digits are displayed even if padding is not selected\n                    final int width = padWithZeros ? Math.max(3, count) : 3;\n                    buffer.append(paddedValue(milliseconds, true, width));\n                } else {\n                    buffer.append(paddedValue(milliseconds, padWithZeros, count));\n                }\n            }\n            lastOutputSeconds = false;\n        }\n        //as soon as we hit first nonliteral in optional, check for literal prefix\n        if (inOptional && !isLiteral && !firstOptionalNonLiteral) {\n            firstOptionalNonLiteral = true;\n            if (lastOutputZero) {\n                buffer.delete(optionalStart, buffer.length());\n            }\n        }\n    }\n    return buffer.toString();\n}", "repo_id": "8", "comment": "/**\n * The internal method to do the formatting.\n *\n * @param tokens  the tokens\n * @param years  the number of years\n * @param months  the number of months\n * @param days  the number of days\n * @param hours  the number of hours\n * @param minutes  the number of minutes\n * @param seconds  the number of seconds\n * @param milliseconds  the number of millis\n * @param padWithZeros  whether to pad\n * @return the formatted string\n */\n", "repo_name": "commons-lang-master/", "id": 607, "method_signature": "String format(Token[], long, long, long, long, long, long, long, boolean)", "filename": "DurationFormatUtils.format.json"}
{"callee_method_names": [], "method_name": "DurationFormatUtils.formatDuration", "method_implementation": "{\n    Validate.inclusiveBetween(0, Long.MAX_VALUE, durationMillis, \"durationMillis must not be negative\");\n    final Token[] tokens = lexx(format);\n    long days = 0;\n    long hours = 0;\n    long minutes = 0;\n    long seconds = 0;\n    long milliseconds = durationMillis;\n    if (Token.containsTokenWithValue(tokens, d)) {\n        days = milliseconds / DateUtils.MILLIS_PER_DAY;\n        milliseconds -= days * DateUtils.MILLIS_PER_DAY;\n    }\n    if (Token.containsTokenWithValue(tokens, H)) {\n        hours = milliseconds / DateUtils.MILLIS_PER_HOUR;\n        milliseconds -= hours * DateUtils.MILLIS_PER_HOUR;\n    }\n    if (Token.containsTokenWithValue(tokens, m)) {\n        minutes = milliseconds / DateUtils.MILLIS_PER_MINUTE;\n        milliseconds -= minutes * DateUtils.MILLIS_PER_MINUTE;\n    }\n    if (Token.containsTokenWithValue(tokens, s)) {\n        seconds = milliseconds / DateUtils.MILLIS_PER_SECOND;\n        milliseconds -= seconds * DateUtils.MILLIS_PER_SECOND;\n    }\n    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "repo_id": "8", "comment": "/**\n * Formats the time gap as a string, using the specified format.\n * Padding the left-hand side side of numbers with zeroes is optional.\n *\n * <p>This method formats durations using the days and lower fields of the\n * format pattern. Months and larger are not used.</p>\n *\n * @param durationMillis  the duration to format\n * @param format  the way in which to format the duration, not null\n * @param padWithZeros  whether to pad the left-hand side side of numbers with 0's\n * @return the formatted duration, not null\n * @throws IllegalArgumentException if durationMillis is negative\n */\n", "repo_name": "commons-lang-master/", "id": 608, "method_signature": "String formatDuration(long, String, boolean)", "filename": "DurationFormatUtils.formatDuration.json"}
{"callee_method_names": ["String.length", "String.length", "String.length", "String.length", "String.isEmpty", "String.substring", "String.length", "String.length", "String.length", "String.length", "String.length", "String.length", "String.trim"], "method_name": "DurationFormatUtils.formatDurationWords", "method_implementation": "{\n    // This method is generally replaceable by the format method, but\n    // there are a series of tweaks and special cases that require\n    // trickery to replicate.\n    String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n    if (suppressLeadingZeroElements) {\n        // this is a temporary marker on the front. Like ^ in regexp.\n        duration = \" \" + duration;\n        String tmp = StringUtils.replaceOnce(duration, \" 0 days\", StringUtils.EMPTY);\n        if (tmp.length() != duration.length()) {\n            duration = tmp;\n            tmp = StringUtils.replaceOnce(duration, \" 0 hours\", StringUtils.EMPTY);\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", StringUtils.EMPTY);\n                duration = tmp;\n            }\n        }\n        if (!duration.isEmpty()) {\n            // strip the space off again\n            duration = duration.substring(1);\n        }\n    }\n    if (suppressTrailingZeroElements) {\n        String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", StringUtils.EMPTY);\n        if (tmp.length() != duration.length()) {\n            duration = tmp;\n            tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", StringUtils.EMPTY);\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", StringUtils.EMPTY);\n                if (tmp.length() != duration.length()) {\n                    duration = StringUtils.replaceOnce(tmp, \" 0 days\", StringUtils.EMPTY);\n                }\n            }\n        }\n    }\n    // handle plurals\n    duration = \" \" + duration;\n    duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n    duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n    duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n    duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n    return duration.trim();\n}", "repo_id": "8", "comment": "/**\n * Formats an elapsed time into a pluralization correct string.\n *\n * <p>This method formats durations using the days and lower fields of the\n * format pattern. Months and larger are not used.</p>\n *\n * @param durationMillis  the elapsed time to report in milliseconds\n * @param suppressLeadingZeroElements  suppresses leading 0 elements\n * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n * @return the formatted text in days/hours/minutes/seconds, not null\n * @throws IllegalArgumentException if durationMillis is negative\n */\n", "repo_name": "commons-lang-master/", "id": 609, "method_signature": "String formatDurationWords(long, boolean, boolean)", "filename": "DurationFormatUtils.formatDurationWords.json"}
{"callee_method_names": ["Calendar.setTime", "Calendar.setTime", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.getActualMaximum", "Calendar.add", "Calendar.get", "Calendar.get", "Calendar.getActualMaximum", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.add", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.getActualMaximum", "Calendar.add", "Calendar.getActualMaximum", "Calendar.add"], "method_name": "DurationFormatUtils.formatPeriod", "method_implementation": "{\n    Validate.isTrue(startMillis <= endMillis, \"startMillis must not be greater than endMillis\");\n    // Used to optimize for differences under 28 days and\n    // called formatDuration(millis, format); however this did not work\n    // over leap years.\n    // TODO: Compare performance to see if anything was lost by\n    // losing this optimization.\n    final Token[] tokens = lexx(format);\n    // time zones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    final Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    final Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    if (Token.containsTokenWithValue(tokens, M)) {\n        while (days < 0) {\n            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n            start.add(Calendar.MONTH, 1);\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n            while (years != 0) {\n                months += 12 * years;\n                years = 0;\n            }\n        }\n    } else {\n        // there are no M's in the format string\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            int target = end.get(Calendar.YEAR);\n            if (months < 0) {\n                // target is end-year -1\n                target -= 1;\n            }\n            while (start.get(Calendar.YEAR) != target) {\n                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                // Not sure I grok why this is needed, but the brutal tests show it is\n                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {\n                    days += 1;\n                }\n                start.add(Calendar.YEAR, 1);\n                days += start.get(Calendar.DAY_OF_YEAR);\n            }\n            years = 0;\n        }\n        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {\n            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            start.add(Calendar.MONTH, 1);\n        }\n        months = 0;\n        while (days < 0) {\n            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n            start.add(Calendar.MONTH, 1);\n        }\n    }\n    // The rest of this code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "repo_id": "8", "comment": "/**\n * <p>Formats the time gap as a string, using the specified format.\n * Padding the left-hand side side of numbers with zeroes is optional and\n * the time zone may be specified.\n *\n * <p>When calculating the difference between months/days, it chooses to\n * calculate months first. So when working out the number of months and\n * days between January 15th and March 10th, it choose 1 month and\n * 23 days gained by choosing January-&gt;February = 1 month and then\n * calculating days forwards, and not the 1 month and 26 days gained by\n * choosing March -&gt; February = 1 month and then calculating days\n * backwards.</p>\n *\n * <p>For more control, the <a href=\"https://www.joda.org/joda-time/\">Joda-Time</a>\n * library is recommended.</p>\n *\n * @param startMillis  the start of the duration\n * @param endMillis  the end of the duration\n * @param format  the way in which to format the duration, not null\n * @param padWithZeros  whether to pad the left-hand side side of numbers with 0's\n * @param timezone  the millis are defined in\n * @return the formatted duration, not null\n * @throws IllegalArgumentException if startMillis is greater than endMillis\n */\n", "repo_name": "commons-lang-master/", "id": 610, "method_signature": "String formatPeriod(long, long, String, boolean, TimeZone)", "filename": "DurationFormatUtils.formatPeriod.json"}
{"callee_method_names": ["String.length", "String.length", "String.charAt", "StringBuilder.append", "ArrayList<Token>.add", "ArrayList<Token>.add", "StringBuilder.append", "Token.getValue", "Token.increment", "ArrayList<Token>.add", "ArrayList<Token>.toArray"], "method_name": "DurationFormatUtils.lexx", "method_implementation": "{\n    final ArrayList<Token> list = new ArrayList<>(format.length());\n    boolean inLiteral = false;\n    // Although the buffer is stored in a Token, the Tokens are only\n    // used internally, so cannot be accessed by other threads\n    StringBuilder buffer = null;\n    Token previous = null;\n    boolean inOptional = false;\n    int optionalIndex = -1;\n    for (int i = 0; i < format.length(); i++) {\n        final char ch = format.charAt(i);\n        if (inLiteral && ch != '\\'') {\n            // buffer can't be null if inLiteral is true\n            buffer.append(ch);\n            continue;\n        }\n        String value = null;\n        switch(ch) {\n            // TODO: Need to handle escaping of '\n            case '[':\n                if (inOptional) {\n                    throw new IllegalArgumentException(\"Nested optional block at index: \" + i);\n                }\n                optionalIndex++;\n                inOptional = true;\n                break;\n            case ']':\n                if (!inOptional) {\n                    throw new IllegalArgumentException(\"Attempting to close unopened optional block at index: \" + i);\n                }\n                inOptional = false;\n                break;\n            case '\\'':\n                if (inLiteral) {\n                    buffer = null;\n                    inLiteral = false;\n                } else {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer, inOptional, optionalIndex));\n                    inLiteral = true;\n                }\n                break;\n            case 'y':\n                value = y;\n                break;\n            case 'M':\n                value = M;\n                break;\n            case 'd':\n                value = d;\n                break;\n            case 'H':\n                value = H;\n                break;\n            case 'm':\n                value = m;\n                break;\n            case 's':\n                value = s;\n                break;\n            case 'S':\n                value = S;\n                break;\n            default:\n                if (buffer == null) {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer, inOptional, optionalIndex));\n                }\n                buffer.append(ch);\n        }\n        if (value != null) {\n            if (previous != null && previous.getValue().equals(value)) {\n                previous.increment();\n            } else {\n                final Token token = new Token(value, inOptional, optionalIndex);\n                list.add(token);\n                previous = token;\n            }\n            buffer = null;\n        }\n    }\n    if (inLiteral) {\n        // i.e. we have not found the end of the literal\n        throw new IllegalArgumentException(\"Unmatched quote in format: \" + format);\n    }\n    if (inOptional) {\n        // i.e. we have not found the end of the literal\n        throw new IllegalArgumentException(\"Unmatched optional in format: \" + format);\n    }\n    return list.toArray(Token.EMPTY_ARRAY);\n}", "repo_id": "8", "comment": "/**\n * Parses a classic date format string into Tokens\n *\n * @param format  the format to parse, not null\n * @return array of Token[]\n */\n", "repo_name": "commons-lang-master/", "id": 611, "method_signature": "Token[] lexx(String)", "filename": "DurationFormatUtils.lexx.json"}
{"callee_method_names": [], "method_name": "DurationFormatUtilsTest.testBugzilla38401", "method_implementation": "{\n    assertEqualDuration(\"0000/00/30 16:00:00 000\", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, \"yyyy/MM/dd HH:mm:ss SSS\");\n}", "repo_id": "8", "comment": "/**\n * See https://issues.apache.org/bugzilla/show_bug.cgi?id=38401\n */\n", "repo_name": "commons-lang-master/", "id": 1783, "method_signature": "void testBugzilla38401()", "filename": "DurationFormatUtilsTest.testBugzilla38401.json"}
{"callee_method_names": [], "method_name": "DurationFormatUtilsTest.testEdgeDurations", "method_implementation": "{\n    // This test case must use a time zone without DST\n    TimeZone.setDefault(FastTimeZone.getGmtTimeZone());\n    assertEqualDuration(\"01\", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, \"MM\");\n    assertEqualDuration(\"12\", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, \"MM\");\n    assertEqualDuration(\"12\", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, \"MM\");\n    assertEqualDuration(\"11\", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, \"MM\");\n    assertEqualDuration(\"01 26\", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, \"MM dd\");\n    assertEqualDuration(\"54\", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"09 12\", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, \"MM dd\");\n    assertEqualDuration(\"287\", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"11 30\", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, \"MM dd\");\n    assertEqualDuration(\"364\", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"12 00\", new int[] { 2006, 0, 1, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, \"MM dd\");\n    assertEqualDuration(\"365\", new int[] { 2006, 0, 1, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"31\", new int[] { 2006, 0, 1, 0, 0, 0 }, new int[] { 2006, 1, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"92\", new int[] { 2005, 9, 1, 0, 0, 0 }, new int[] { 2006, 0, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"77\", new int[] { 2005, 9, 16, 0, 0, 0 }, new int[] { 2006, 0, 1, 0, 0, 0 }, \"dd\");\n    // test month larger in start than end\n    assertEqualDuration(\"136\", new int[] { 2005, 9, 16, 0, 0, 0 }, new int[] { 2006, 2, 1, 0, 0, 0 }, \"dd\");\n    // test when start in leap year\n    assertEqualDuration(\"136\", new int[] { 2004, 9, 16, 0, 0, 0 }, new int[] { 2005, 2, 1, 0, 0, 0 }, \"dd\");\n    // test when end in leap year\n    assertEqualDuration(\"137\", new int[] { 2003, 9, 16, 0, 0, 0 }, new int[] { 2004, 2, 1, 0, 0, 0 }, \"dd\");\n    // test when end in leap year but less than end of feb\n    assertEqualDuration(\"135\", new int[] { 2003, 9, 16, 0, 0, 0 }, new int[] { 2004, 1, 28, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"364\", new int[] { 2007, 0, 2, 0, 0, 0 }, new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"729\", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"365\", new int[] { 2007, 2, 2, 0, 0, 0 }, new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"333\", new int[] { 2007, 1, 2, 0, 0, 0 }, new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"28\", new int[] { 2008, 1, 2, 0, 0, 0 }, new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"393\", new int[] { 2007, 1, 2, 0, 0, 0 }, new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"369\", new int[] { 2004, 0, 29, 0, 0, 0 }, new int[] { 2005, 1, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"338\", new int[] { 2004, 1, 29, 0, 0, 0 }, new int[] { 2005, 1, 1, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"28\", new int[] { 2004, 2, 8, 0, 0, 0 }, new int[] { 2004, 3, 5, 0, 0, 0 }, \"dd\");\n    assertEqualDuration(\"48\", new int[] { 1992, 1, 29, 0, 0, 0 }, new int[] { 1996, 1, 29, 0, 0, 0 }, \"M\");\n    // this seems odd - and will fail if I throw it in as a brute force\n    // below as it expects the answer to be 12. It's a tricky edge case\n    assertEqualDuration(\"11\", new int[] { 1996, 1, 29, 0, 0, 0 }, new int[] { 1997, 1, 28, 0, 0, 0 }, \"M\");\n    // again - this seems odd\n    assertEqualDuration(\"11 28\", new int[] { 1996, 1, 29, 0, 0, 0 }, new int[] { 1997, 1, 28, 0, 0, 0 }, \"M d\");\n}", "repo_id": "8", "comment": "/**\n * Attempting to test edge cases in DurationFormatUtils.formatPeriod.\n */\n", "repo_name": "commons-lang-master/", "id": 1784, "method_signature": "void testEdgeDurations()", "filename": "DurationFormatUtilsTest.testEdgeDurations.json"}
{"callee_method_names": [], "method_name": "DurationFormatUtilsTest.testFormatDurationPluralWords", "method_implementation": "{\n    final long oneSecond = 1000;\n    final long oneMinute = oneSecond * 60;\n    final long oneHour = oneMinute * 60;\n    final long oneDay = oneHour * 24;\n    String text;\n    text = DurationFormatUtils.formatDurationWords(oneSecond, false, false);\n    assertEquals(\"0 days 0 hours 0 minutes 1 second\", text);\n    text = DurationFormatUtils.formatDurationWords(oneSecond * 2, false, false);\n    assertEquals(\"0 days 0 hours 0 minutes 2 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneSecond * 11, false, false);\n    assertEquals(\"0 days 0 hours 0 minutes 11 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneMinute, false, false);\n    assertEquals(\"0 days 0 hours 1 minute 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneMinute * 2, false, false);\n    assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneMinute * 11, false, false);\n    assertEquals(\"0 days 0 hours 11 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneMinute + oneSecond, false, false);\n    assertEquals(\"0 days 0 hours 1 minute 1 second\", text);\n    text = DurationFormatUtils.formatDurationWords(oneHour, false, false);\n    assertEquals(\"0 days 1 hour 0 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneHour * 2, false, false);\n    assertEquals(\"0 days 2 hours 0 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneHour * 11, false, false);\n    assertEquals(\"0 days 11 hours 0 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneHour + oneMinute + oneSecond, false, false);\n    assertEquals(\"0 days 1 hour 1 minute 1 second\", text);\n    text = DurationFormatUtils.formatDurationWords(oneDay, false, false);\n    assertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneDay * 2, false, false);\n    assertEquals(\"2 days 0 hours 0 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneDay * 11, false, false);\n    assertEquals(\"11 days 0 hours 0 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(oneDay + oneHour + oneMinute + oneSecond, false, false);\n    assertEquals(\"1 day 1 hour 1 minute 1 second\", text);\n}", "repo_id": "8", "comment": "/**\n * Tests that \"1 &lt;unit&gt;s\" gets converted to \"1 &lt;unit&gt;\" but that \"11 &lt;unit&gt;s\" is left alone.\n */\n", "repo_name": "commons-lang-master/", "id": 1785, "method_signature": "void testFormatDurationPluralWords()", "filename": "DurationFormatUtilsTest.testFormatDurationPluralWords.json"}
{"callee_method_names": [], "method_name": "DurationFormatUtilsTest.testJiraLang281", "method_implementation": "{\n    assertEqualDuration(\"09\", new int[] { 2005, 11, 31, 0, 0, 0 }, new int[] { 2006, 9, 6, 0, 0, 0 }, \"MM\");\n}", "repo_id": "8", "comment": "// https://issues.apache.org/jira/browse/LANG-281\n", "repo_name": "commons-lang-master/", "id": 1786, "method_signature": "void testJiraLang281()", "filename": "DurationFormatUtilsTest.testJiraLang281.json"}
{"callee_method_names": [], "method_name": "DurationFormatUtilsTest.testLowDurations", "method_implementation": "{\n    for (int hr = 0; hr < 24; hr++) {\n        for (int min = 0; min < 60; min++) {\n            for (int sec = 0; sec < 60; sec++) {\n                assertEqualDuration(hr + \":\" + min + \":\" + sec, new int[] { 2000, 0, 1, 0, 0, 0, 0 }, new int[] { 2000, 0, 1, hr, min, sec }, \"H:m:s\");\n            }\n        }\n    }\n}", "repo_id": "8", "comment": "// Testing the under a day range in DurationFormatUtils.formatPeriod\n", "repo_name": "commons-lang-master/", "id": 1787, "method_signature": "void testLowDurations()", "filename": "DurationFormatUtilsTest.testLowDurations.json"}
{"callee_method_names": ["FailableBiConsumer<Long,Integer,T>.accept", "Duration.toMillis"], "method_name": "DurationUtils.accept", "method_implementation": "{\n    if (consumer != null && duration != null) {\n        consumer.accept(duration.toMillis(), getNanosOfMilli(duration));\n    }\n}", "repo_id": "8", "comment": "/**\n * Accepts the function with the duration as a long milliseconds and int nanoseconds.\n *\n * @param <T> The function exception.\n * @param consumer Accepting function.\n * @param duration The duration to pick apart.\n * @throws T See the function signature.\n */\n", "repo_name": "commons-lang-master/", "id": 710, "method_signature": "void accept(FailableBiConsumer, Duration)", "filename": "DurationUtils.accept.json"}
{"callee_method_names": ["TimeUnit.toString"], "method_name": "DurationUtils.toChronoUnit", "method_implementation": "{\n    // TODO when using Java >= 9: Use TimeUnit.toChronoUnit().\n    switch(Objects.requireNonNull(timeUnit)) {\n        case NANOSECONDS:\n            return ChronoUnit.NANOS;\n        case MICROSECONDS:\n            return ChronoUnit.MICROS;\n        case MILLISECONDS:\n            return ChronoUnit.MILLIS;\n        case SECONDS:\n            return ChronoUnit.SECONDS;\n        case MINUTES:\n            return ChronoUnit.MINUTES;\n        case HOURS:\n            return ChronoUnit.HOURS;\n        case DAYS:\n            return ChronoUnit.DAYS;\n        default:\n            throw new IllegalArgumentException(timeUnit.toString());\n    }\n}", "repo_id": "8", "comment": "/**\n * Converts a {@link TimeUnit} to a {@link ChronoUnit}.\n *\n * @param timeUnit A non-null TimeUnit.\n * @return The corresponding ChronoUnit.\n */\n", "repo_name": "commons-lang-master/", "id": 711, "method_signature": "ChronoUnit toChronoUnit(TimeUnit)", "filename": "DurationUtils.toChronoUnit.json"}
{"callee_method_names": ["LongRange.fit", "Duration.toMillis"], "method_name": "DurationUtils.toMillisInt", "method_implementation": "{\n    Objects.requireNonNull(duration, \"duration\");\n    // intValue() does not do a narrowing conversion here\n    return LONG_TO_INT_RANGE.fit(Long.valueOf(duration.toMillis())).intValue();\n}", "repo_id": "8", "comment": "/**\n * Converts a Duration to milliseconds bound to an int (instead of a long).\n * <p>\n * Handy for low-level APIs that take millisecond timeouts in ints rather than longs.\n * </p>\n * <ul>\n * <li>If the duration milliseconds are greater than {@link Integer#MAX_VALUE}, then return\n * {@link Integer#MAX_VALUE}.</li>\n * <li>If the duration milliseconds are lesser than {@link Integer#MIN_VALUE}, then return\n * {@link Integer#MIN_VALUE}.</li>\n * </ul>\n *\n * @param duration The duration to convert, not null.\n * @return int milliseconds.\n */\n", "repo_name": "commons-lang-master/", "id": 712, "method_signature": "int toMillisInt(Duration)", "filename": "DurationUtils.toMillisInt.json"}
{"callee_method_names": [], "method_name": "EntityArrays.invert", "method_implementation": "{\n    final String[][] newarray = new String[array.length][2];\n    for (int i = 0; i < array.length; i++) {\n        newarray[i][0] = array[i][1];\n        newarray[i][1] = array[i][0];\n    }\n    return newarray;\n}", "repo_id": "8", "comment": "/**\n * Used to invert an escape array into an unescape array\n * @param array String[][] to be inverted\n * @return String[][] inverted array\n */\n", "repo_name": "commons-lang-master/", "id": 436, "method_signature": "String[][] invert(String[][])", "filename": "EntityArrays.invert.json"}
{"callee_method_names": ["Set<String>.add", "Set<String>.add"], "method_name": "EntityArraysTest.testHTML40_EXTENDED_ESCAPE", "method_implementation": "{\n    final Set<String> col0 = new HashSet<>();\n    final Set<String> col1 = new HashSet<>();\n    final String[][] sa = EntityArrays.HTML40_EXTENDED_ESCAPE();\n    for (int i = 0; i < sa.length; i++) {\n        assertTrue(col0.add(sa[i][0]), \"Already added entry 0: \" + i + \" \" + sa[i][0]);\n        assertTrue(col1.add(sa[i][1]), \"Already added entry 1: \" + i + \" \" + sa[i][1]);\n    }\n}", "repo_id": "8", "comment": "// LANG-659 - check arrays for duplicate entries\n", "repo_name": "commons-lang-master/", "id": 1746, "method_signature": "void testHTML40_EXTENDED_ESCAPE()", "filename": "EntityArraysTest.testHTML40_EXTENDED_ESCAPE.json"}
{"callee_method_names": ["Set<String>.add", "Set<String>.add"], "method_name": "EntityArraysTest.testISO8859_1_ESCAPE", "method_implementation": "{\n    final Set<String> col0 = new HashSet<>();\n    final Set<String> col1 = new HashSet<>();\n    final String[][] sa = EntityArrays.ISO8859_1_ESCAPE();\n    boolean success = true;\n    for (int i = 0; i < sa.length; i++) {\n        final boolean add0 = col0.add(sa[i][0]);\n        final boolean add1 = col1.add(sa[i][1]);\n        if (!add0) {\n            success = false;\n            System.out.println(\"Already added entry 0: \" + i + \" \" + sa[i][0] + \" \" + sa[i][1]);\n        }\n        if (!add1) {\n            success = false;\n            System.out.println(\"Already added entry 1: \" + i + \" \" + sa[i][0] + \" \" + sa[i][1]);\n        }\n    }\n    assertTrue(success, \"One or more errors detected\");\n}", "repo_id": "8", "comment": "// LANG-658 - check arrays for duplicate entries\n", "repo_name": "commons-lang-master/", "id": 1747, "method_signature": "void testISO8859_1_ESCAPE()", "filename": "EntityArraysTest.testISO8859_1_ESCAPE.json"}
{"callee_method_names": ["Class<E>.isEnum"], "method_name": "EnumUtils.asEnum", "method_implementation": "{\n    Objects.requireNonNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED);\n    Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass);\n    return enumClass;\n}", "repo_id": "8", "comment": "/**\n * Validate {@code enumClass}.\n * @param <E> the type of the enumeration\n * @param enumClass to check\n * @return {@code enumClass}\n * @throws NullPointerException if {@code enumClass} is {@code null}\n * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 752, "method_signature": "Class<E> asEnum(Class)", "filename": "EnumUtils.asEnum.json"}
{"callee_method_names": ["Class<E>.getSimpleName"], "method_name": "EnumUtils.checkBitVectorable", "method_implementation": "{\n    final E[] constants = asEnum(enumClass).getEnumConstants();\n    Validate.isTrue(constants.length <= Long.SIZE, CANNOT_STORE_S_S_VALUES_IN_S_BITS, Integer.valueOf(constants.length), enumClass.getSimpleName(), Integer.valueOf(Long.SIZE));\n    return enumClass;\n}", "repo_id": "8", "comment": "/**\n * Validate that {@code enumClass} is compatible with representation in a {@code long}.\n * @param <E> the type of the enumeration\n * @param enumClass to check\n * @return {@code enumClass}\n * @throws NullPointerException if {@code enumClass} is {@code null}\n * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n * @since 3.0.1\n */\n", "repo_name": "commons-lang-master/", "id": 753, "method_signature": "Class<E> checkBitVectorable(Class)", "filename": "EnumUtils.checkBitVectorable.json"}
{"callee_method_names": [], "method_name": "EnumUtils.generateBitVector", "method_implementation": "{\n    checkBitVectorable(enumClass);\n    Objects.requireNonNull(values, \"values\");\n    long total = 0;\n    for (final E constant : values) {\n        Objects.requireNonNull(constant, NULL_ELEMENTS_NOT_PERMITTED);\n        total |= 1L << constant.ordinal();\n    }\n    return total;\n}", "repo_id": "8", "comment": "/**\n * Creates a long bit vector representation of the given subset of an Enum.\n *\n * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n *\n * <p>Do not use this method if you have more than 64 values in your Enum, as this\n * would create a value greater than a long can hold.</p>\n *\n * @param enumClass the class of the enum we are working with, not {@code null}\n * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n * @param <E>       the type of the enumeration\n * @return a long whose value provides a binary representation of the given set of enum values.\n * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values,\n *                                  or if any {@code values} {@code null}\n * @since 3.0.1\n * @see #generateBitVectors(Class, Iterable)\n */\n", "repo_name": "commons-lang-master/", "id": 755, "method_signature": "long generateBitVector(Class, Iterable)", "filename": "EnumUtils.generateBitVector.json"}
{"callee_method_names": ["Iterable<? extends E>.forEach", "EnumSet<E>.add", "Class<E>.getEnumConstants", "String.ordinal", "String.ordinal"], "method_name": "EnumUtils.generateBitVectors", "method_implementation": "{\n    asEnum(enumClass);\n    Objects.requireNonNull(values, \"values\");\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    values.forEach(constant -> condensed.add(Objects.requireNonNull(constant, NULL_ELEMENTS_NOT_PERMITTED)));\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1L << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.\n *\n * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n *\n * <p>Use this method if you have more than 64 values in your Enum.</p>\n *\n * @param enumClass the class of the enum we are working with, not {@code null}\n * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n * @param <E>       the type of the enumeration\n * @return a long[] whose values provide a binary representation of the given set of enum values\n *         with the least significant digits rightmost.\n * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 757, "method_signature": "long[] generateBitVectors(Class, Iterable)", "filename": "EnumUtils.generateBitVectors.json"}
{"callee_method_names": [], "method_name": "EnumUtils.getEnum", "method_implementation": "{\n    if (enumName == null) {\n        return defaultEnum;\n    }\n    try {\n        return Enum.valueOf(enumClass, enumName);\n    } catch (final IllegalArgumentException ex) {\n        return defaultEnum;\n    }\n}", "repo_id": "8", "comment": "/**\n * Gets the enum for the class, returning {@code defaultEnum} if not found.\n *\n * <p>This method differs from {@link Enum#valueOf} in that it does not throw an exception\n * for an invalid enum name.</p>\n *\n * @param <E> the type of the enumeration\n * @param enumClass   the class of the enum to query, not null\n * @param enumName    the enum name, null returns default enum\n * @param defaultEnum the default enum\n * @return the enum, default enum if not found\n * @since 3.10\n */\n", "repo_name": "commons-lang-master/", "id": 758, "method_signature": "E getEnum(Class, String, E)", "filename": "EnumUtils.getEnum.json"}
{"callee_method_names": [], "method_name": "EnumUtils.getEnumSystemProperty", "method_implementation": "{\n    return enumClass == null || propName == null ? defaultEnum : getEnum(enumClass, System.getProperty(propName), defaultEnum);\n}", "repo_id": "8", "comment": "/**\n * Gets the enum for the class in a system property, returning {@code defaultEnum} if not found.\n *\n * <p>\n * This method differs from {@link Enum#valueOf} in that it does not throw an exception for an invalid enum name.\n * </p>\n *\n * @param <E> the type of the enumeration\n * @param enumClass the class of the enum to query, not null\n * @param propName the system property key for the enum name, null returns default enum\n * @param defaultEnum the default enum\n * @return the enum, default enum if not found\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 759, "method_signature": "E getEnumSystemProperty(Class, String, E)", "filename": "EnumUtils.getEnumSystemProperty.json"}
{"callee_method_names": ["Class<E>.isEnum", "Class<E>.getEnumConstants", "String.equalsIgnoreCase", "Function<E,String>.apply"], "method_name": "EnumUtils.getFirstEnumIgnoreCase", "method_implementation": "{\n    if (enumName == null || !enumClass.isEnum()) {\n        return defaultEnum;\n    }\n    return Stream.of(enumClass.getEnumConstants()).filter(e -> enumName.equalsIgnoreCase(stringFunction.apply(e))).findFirst().orElse(defaultEnum);\n}", "repo_id": "8", "comment": "/**\n * Gets the enum for the class, returning {@code defaultEnum} if not found.\n *\n * <p>This method differs from {@link Enum#valueOf} in that it does not throw an exception\n * for an invalid enum name and performs case insensitive matching of the name.</p>\n *\n * @param <E>         the type of the enumeration\n * @param enumClass   the class of the enum to query, not null\n * @param enumName    the enum name, null returns default enum\n * @param stringFunction the function that gets the string for an enum for comparison to {@code enumName}.\n * @param defaultEnum the default enum\n * @return the enum, default enum if not found\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 760, "method_signature": "E getFirstEnumIgnoreCase(Class, String, Function, E)", "filename": "EnumUtils.getFirstEnumIgnoreCase.json"}
{"callee_method_names": ["Class<E>.getEnumConstants", "EnumSet<E>.add"], "method_name": "EnumUtils.processBitVectors", "method_implementation": "{\n    final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));\n    final long[] lvalues = ArrayUtils.clone(Objects.requireNonNull(values, \"values\"));\n    ArrayUtils.reverse(lvalues);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int block = constant.ordinal() / Long.SIZE;\n        if (block < lvalues.length && (lvalues[block] & 1L << (constant.ordinal() % Long.SIZE)) != 0) {\n            results.add(constant);\n        }\n    }\n    return results;\n}", "repo_id": "8", "comment": "/**\n * Convert a {@code long[]} created by {@link EnumUtils#generateBitVectors} into the set of\n * enum values that it represents.\n *\n * <p>If you store this value, beware any changes to the enum that would affect ordinal values.</p>\n * @param enumClass the class of the enum we are working with, not {@code null}\n * @param values     the long[] bearing the representation of a set of enum values, the least significant digits rightmost, not {@code null}\n * @param <E>       the type of the enumeration\n * @return a set of enum values\n * @throws NullPointerException if {@code enumClass} is {@code null}\n * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 761, "method_signature": "EnumSet<E> processBitVectors(Class, long[])", "filename": "EnumUtils.processBitVectors.json"}
{"callee_method_names": [], "method_name": "EnumUtilsTest.test_getEnumIgnoreCase_nonEnumClass", "method_implementation": "{\n    @SuppressWarnings(\"rawtypes\")\n    final Class rawType = Object.class;\n    assertNull(EnumUtils.getEnumIgnoreCase(rawType, \"rawType\"));\n}", "repo_id": "8", "comment": "/**\n * Tests raw type.\n */\n", "repo_name": "commons-lang-master/", "id": 1914, "method_signature": "void test_getEnumIgnoreCase_nonEnumClass()", "filename": "EnumUtilsTest.test_getEnumIgnoreCase_nonEnumClass.json"}
{"callee_method_names": [], "method_name": "EnumUtilsTest.test_getEnum_nonEnumClass", "method_implementation": "{\n    @SuppressWarnings(\"rawtypes\")\n    final Class rawType = Object.class;\n    assertNull(EnumUtils.getEnum(rawType, \"rawType\"));\n}", "repo_id": "8", "comment": "/**\n * Tests raw type.\n */\n", "repo_name": "commons-lang-master/", "id": 1913, "method_signature": "void test_getEnum_nonEnumClass()", "filename": "EnumUtilsTest.test_getEnum_nonEnumClass.json"}
{"callee_method_names": [], "method_name": "EqualsBuilder.append", "method_implementation": "{\n    if (!isEquals) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null || rhs == null) {\n        this.setEquals(false);\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        this.setEquals(false);\n        return this;\n    }\n    for (int i = 0; i < lhs.length && isEquals; ++i) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Deep comparison of array of {@code short}. Length and all\n * values are compared.\n *\n * <p>The method {@link #append(short, short)} is used.</p>\n *\n * @param lhs  the left-hand side {@code short[]}\n * @param rhs  the right-hand side {@code short[]}\n * @return this\n */\n", "repo_name": "commons-lang-master/", "id": 859, "method_signature": "EqualsBuilder append(short[], short[])", "filename": "EqualsBuilder.append.json"}
{"callee_method_names": ["Object.getClass", "Object.getClass"], "method_name": "EqualsBuilder.appendArray", "method_implementation": "{\n    // First we compare different dimensions, for example: a boolean[][] to a boolean[]\n    // then we 'Switch' on type of array, to dispatch to the correct handler\n    // This handles multidimensional arrays of the same depth\n    if (lhs.getClass() != rhs.getClass()) {\n        this.setEquals(false);\n    } else if (lhs instanceof long[]) {\n        append((long[]) lhs, (long[]) rhs);\n    } else if (lhs instanceof int[]) {\n        append((int[]) lhs, (int[]) rhs);\n    } else if (lhs instanceof short[]) {\n        append((short[]) lhs, (short[]) rhs);\n    } else if (lhs instanceof char[]) {\n        append((char[]) lhs, (char[]) rhs);\n    } else if (lhs instanceof byte[]) {\n        append((byte[]) lhs, (byte[]) rhs);\n    } else if (lhs instanceof double[]) {\n        append((double[]) lhs, (double[]) rhs);\n    } else if (lhs instanceof float[]) {\n        append((float[]) lhs, (float[]) rhs);\n    } else if (lhs instanceof boolean[]) {\n        append((boolean[]) lhs, (boolean[]) rhs);\n    } else {\n        // Not an array of primitives\n        append((Object[]) lhs, (Object[]) rhs);\n    }\n}", "repo_id": "8", "comment": "/**\n * Test if an {@link Object} is equal to an array.\n *\n * @param lhs  the left-hand side object, an array\n * @param rhs  the right-hand side object\n */\n", "repo_name": "commons-lang-master/", "id": 860, "method_signature": "void appendArray(Object, Object)", "filename": "EqualsBuilder.appendArray.json"}
{"callee_method_names": [], "method_name": "EqualsBuilder.appendSuper", "method_implementation": "{\n    if (!isEquals) {\n        return this;\n    }\n    isEquals = superEquals;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Adds the result of {@code super.equals()} to this builder.\n *\n * @param superEquals  the result of calling {@code super.equals()}\n * @return this\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 861, "method_signature": "EqualsBuilder appendSuper(boolean)", "filename": "EqualsBuilder.appendSuper.json"}
{"callee_method_names": [], "method_name": "EqualsBuilder.getRegisterPair", "method_implementation": "{\n    final IDKey left = new IDKey(lhs);\n    final IDKey right = new IDKey(rhs);\n    return Pair.of(left, right);\n}", "repo_id": "8", "comment": "/**\n * Converters value pair into a register pair.\n *\n * @param lhs {@code this} object\n * @param rhs the other object\n *\n * @return the pair\n */\n", "repo_name": "commons-lang-master/", "id": 837, "method_signature": "Pair<IDKey,IDKey> getRegisterPair(Object, Object)", "filename": "EqualsBuilder.getRegisterPair.json"}
{"callee_method_names": ["Pair<IDKey, IDKey>.getRight", "Pair<IDKey, IDKey>.getLeft", "Set<Pair<IDKey, IDKey>>.contains", "Set<Pair<IDKey, IDKey>>.contains"], "method_name": "EqualsBuilder.isRegistered", "method_implementation": "{\n    final Set<Pair<IDKey, IDKey>> registry = getRegistry();\n    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getRight(), pair.getLeft());\n    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));\n}", "repo_id": "8", "comment": "/**\n * Returns {@code true} if the registry contains the given object pair.\n * Used by the reflection methods to avoid infinite loops.\n * Objects might be swapped therefore a check is needed if the object pair\n * is registered in given or swapped order.\n *\n * @param lhs {@code this} object to lookup in registry\n * @param rhs the other object to lookup on registry\n * @return boolean {@code true} if the registry contains the given object.\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 838, "method_signature": "boolean isRegistered(Object, Object)", "filename": "EqualsBuilder.isRegistered.json"}
{"callee_method_names": ["Class<?>.getDeclaredFields", "Field.getName", "Field.getName", "Field.getModifiers", "Field.getModifiers", "Field.isAnnotationPresent"], "method_name": "EqualsBuilder.reflectionAppend", "method_implementation": "{\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && isEquals; i++) {\n            final Field field = fields[i];\n            if (!ArrayUtils.contains(excludeFields, field.getName()) && !field.getName().contains(\"$\") && (testTransients || !Modifier.isTransient(field.getModifiers())) && !Modifier.isStatic(field.getModifiers()) && !field.isAnnotationPresent(EqualsExclude.class)) {\n                append(Reflection.getUnchecked(field, lhs), Reflection.getUnchecked(field, rhs));\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends the fields and values defined by the given object of the\n * given Class.\n *\n * @param lhs  the left-hand side object\n * @param rhs  the right-hand side object\n * @param clazz  the class to append details of\n */\n", "repo_name": "commons-lang-master/", "id": 863, "method_signature": "void reflectionAppend(Object, Object, Class)", "filename": "EqualsBuilder.reflectionAppend.json"}
{"callee_method_names": [], "method_name": "EqualsBuilder.reflectionEquals", "method_implementation": "{\n    if (lhs == rhs) {\n        return true;\n    }\n    if (lhs == null || rhs == null) {\n        return false;\n    }\n    return new EqualsBuilder().setExcludeFields(excludeFields).setReflectUpToClass(reflectUpToClass).setTestTransients(testTransients).setTestRecursive(testRecursive).reflectionAppend(lhs, rhs).isEquals();\n}", "repo_id": "8", "comment": "/**\n * This method uses reflection to determine if the two {@link Object}s\n * are equal.\n *\n * <p>It uses {@code AccessibleObject.setAccessible} to gain access to private\n * fields. This means that it will throw a security exception if run under\n * a security manager, if the permissions are not set up correctly. It is also\n * not as efficient as testing explicitly. Non-primitive fields are compared using\n * {@code equals()}.</p>\n *\n * <p>If the testTransients parameter is set to {@code true}, transient\n * members will be tested, otherwise they are ignored, as they are likely\n * derived fields, and not part of the value of the {@link Object}.</p>\n *\n * <p>Static fields will not be included. Superclass fields will be appended\n * up to and including the specified superclass. A null superclass is treated\n * as java.lang.Object.</p>\n *\n * <p>If the testRecursive parameter is set to {@code true}, non primitive\n * (and non primitive wrapper) field types will be compared by\n * {@link EqualsBuilder} recursively instead of invoking their\n * {@code equals()} method. Leading to a deep reflection equals test.\n *\n * @param lhs  {@code this} object\n * @param rhs  the other object\n * @param testTransients  whether to include transient fields\n * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n *  may be {@code null}\n * @param testRecursive  whether to call reflection equals on non-primitive\n *  fields recursively.\n * @param excludeFields  array of field names to exclude from testing\n * @return {@code true} if the two Objects have tested equals.\n *\n * @see EqualsExclude\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 839, "method_signature": "boolean reflectionEquals(Object, Object, boolean, Class, boolean, String[])", "filename": "EqualsBuilder.reflectionEquals.json"}
{"callee_method_names": ["ThreadLocal.set", "Set<Pair<IDKey, IDKey>>.add"], "method_name": "EqualsBuilder.register", "method_implementation": "{\n    Set<Pair<IDKey, IDKey>> registry = getRegistry();\n    if (registry == null) {\n        registry = new HashSet<>();\n        REGISTRY.set(registry);\n    }\n    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n    registry.add(pair);\n}", "repo_id": "8", "comment": "/**\n * Registers the given object pair.\n * Used by the reflection methods to avoid infinite loops.\n *\n * @param lhs {@code this} object to register\n * @param rhs the other object to register\n */\n", "repo_name": "commons-lang-master/", "id": 840, "method_signature": "void register(Object, Object)", "filename": "EqualsBuilder.register.json"}
{"callee_method_names": ["Set<Pair<IDKey, IDKey>>.remove", "Set<Pair<IDKey, IDKey>>.isEmpty", "ThreadLocal.remove"], "method_name": "EqualsBuilder.unregister", "method_implementation": "{\n    final Set<Pair<IDKey, IDKey>> registry = getRegistry();\n    if (registry != null) {\n        registry.remove(getRegisterPair(lhs, rhs));\n        if (registry.isEmpty()) {\n            REGISTRY.remove();\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Unregisters the given object pair.\n *\n * <p>\n * Used by the reflection methods to avoid infinite loops.\n *\n * @param lhs {@code this} object to unregister\n * @param rhs the other object to unregister\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 841, "method_signature": "void unregister(Object, Object)", "filename": "EqualsBuilder.unregister.json"}
{"callee_method_names": ["TestObjectReference.setObjectReference", "TestObjectReference.setObjectReference", "TestObjectReference.setObjectReference", "TestObjectReference.setObjectReference", "TestObjectReference.setObjectReference", "TestObjectReference.setObjectReference"], "method_name": "EqualsBuilderTest.testCyclicalObjectReferences", "method_implementation": "{\n    final TestObjectReference refX1 = new TestObjectReference(1);\n    final TestObjectReference x1 = new TestObjectReference(1);\n    x1.setObjectReference(refX1);\n    refX1.setObjectReference(x1);\n    final TestObjectReference refX2 = new TestObjectReference(1);\n    final TestObjectReference x2 = new TestObjectReference(1);\n    x2.setObjectReference(refX2);\n    refX2.setObjectReference(x2);\n    final TestObjectReference refX3 = new TestObjectReference(2);\n    final TestObjectReference x3 = new TestObjectReference(2);\n    x3.setObjectReference(refX3);\n    refX3.setObjectReference(x3);\n    assertEquals(x1, x2);\n    assertNull(EqualsBuilder.getRegistry());\n    assertNotEquals(x1, x3);\n    assertNull(EqualsBuilder.getRegistry());\n    assertNotEquals(x2, x3);\n    assertNull(EqualsBuilder.getRegistry());\n}", "repo_id": "8", "comment": "/**\n * Test cyclical object references which cause a StackOverflowException if\n * not handled properly. s. LANG-606\n */\n", "repo_name": "commons-lang-master/", "id": 1995, "method_signature": "void testCyclicalObjectReferences()", "filename": "EqualsBuilderTest.testCyclicalObjectReferences.json"}
{"callee_method_names": [], "method_name": "EqualsBuilderTest.testNpeForNullElement", "method_implementation": "{\n    final Object[] x1 = { Integer.valueOf(1), null, Integer.valueOf(3) };\n    final Object[] x2 = { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) };\n    // causes an NPE in 2.0 according to:\n    // https://issues.apache.org/jira/browse/LANG-42\n    new EqualsBuilder().append(x1, x2);\n}", "repo_id": "8", "comment": "/**\n * Test from https://issues.apache.org/jira/browse/LANG-42\n */\n", "repo_name": "commons-lang-master/", "id": 1996, "method_signature": "void testNpeForNullElement()", "filename": "EqualsBuilderTest.testNpeForNullElement.json"}
{"callee_method_names": ["TestObject.setA", "TestObject.getA", "TestObject.setA", "TestObject.getA"], "method_name": "EqualsBuilderTest.testReflectionEqualsEquivalenceRelationship", "method_implementation": "{\n    // reflection test\n    assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));\n    assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));\n    // symmetry test\n    assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));\n    // transitive test\n    assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients) && EqualsBuilder.reflectionEquals(to, toTer, testTransients));\n    // consistency test\n    oToChange.setA(to.getA());\n    if (oToChange instanceof TestSubObject) {\n        ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());\n    }\n    assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n    assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n    oToChange.setA(to.getA() + 1);\n    if (oToChange instanceof TestSubObject) {\n        ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);\n    }\n    assertFalse(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n    assertFalse(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n    // non-null reference test\n    assertFalse(EqualsBuilder.reflectionEquals(to, null, testTransients));\n    assertFalse(EqualsBuilder.reflectionEquals(to2, null, testTransients));\n    assertFalse(EqualsBuilder.reflectionEquals(null, to, testTransients));\n    assertFalse(EqualsBuilder.reflectionEquals(null, to2, testTransients));\n    assertTrue(EqualsBuilder.reflectionEquals(null, null, testTransients));\n}", "repo_id": "8", "comment": "/**\n * Equivalence relationship tests inspired by \"Effective Java\":\n * <ul>\n * <li>reflection</li>\n * <li>symmetry</li>\n * <li>transitive</li>\n * <li>consistency</li>\n * <li>non-null reference</li>\n * </ul>\n *\n * @param to             a TestObject\n * @param toBis          a TestObject, equal to to and toTer\n * @param toTer          left-hand side side, equal to to and toBis\n * @param to2            a different TestObject\n * @param oToChange      a TestObject that will be changed\n * @param testTransients whether to test transient instance variables\n */\n", "repo_name": "commons-lang-master/", "id": 1997, "method_signature": "void testReflectionEqualsEquivalenceRelationship(TestObject, TestObject, TestObject, TestObject, TestObject, boolean)", "filename": "EqualsBuilderTest.testReflectionEqualsEquivalenceRelationship.json"}
{"callee_method_names": [], "method_name": "EqualsBuilderTest.testUnrelatedClasses", "method_implementation": "{\n    final Object[] x = { new TestACanEqualB(1) };\n    final Object[] y = { new TestBCanEqualA(1) };\n    // sanity checks:\n    assertArrayEquals(x, x);\n    assertArrayEquals(y, y);\n    assertArrayEquals(x, y);\n    assertArrayEquals(y, x);\n    // real tests:\n    assertEquals(x[0], x[0]);\n    assertEquals(y[0], y[0]);\n    assertEquals(x[0], y[0]);\n    assertEquals(y[0], x[0]);\n    assertTrue(new EqualsBuilder().append(x, x).isEquals());\n    assertTrue(new EqualsBuilder().append(y, y).isEquals());\n    assertTrue(new EqualsBuilder().append(x, y).isEquals());\n    assertTrue(new EqualsBuilder().append(y, x).isEquals());\n}", "repo_id": "8", "comment": "/**\n * Tests two instances of classes that can be equal and that are not \"related\". The two classes are not subclasses\n * of each other and do not share a parent aside from Object.\n * See https://issues.apache.org/jira/browse/LANG-6\n */\n", "repo_name": "commons-lang-master/", "id": 1998, "method_signature": "void testUnrelatedClasses()", "filename": "EqualsBuilderTest.testUnrelatedClasses.json"}
{"callee_method_names": ["Set<String>.isEmpty", "Set<String>.contains", "Method.getName"], "method_name": "EventBindingInvocationHandler.invoke", "method_implementation": "{\n    if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) {\n        if (hasMatchingParametersMethod(method)) {\n            return MethodUtils.invokeMethod(target, methodName, parameters);\n        }\n        return MethodUtils.invokeMethod(target, methodName);\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Handles a method invocation on the proxy object.\n *\n * @param proxy the proxy instance\n * @param method the method to be invoked\n * @param parameters the parameters for the method invocation\n * @return the result of the method call\n * @throws Throwable if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 731, "method_signature": "Object invoke(Object, Method, Object[])", "filename": "EventBindingInvocationHandler.invoke.json"}
{"callee_method_names": ["AtomicReference<CheckIntervalData>.set"], "method_name": "EventCountCircuitBreaker.close", "method_implementation": "{\n    super.close();\n    checkIntervalData.set(new CheckIntervalData(0, nanoTime()));\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n * <p>\n * A new check interval is started. If too many events are received in\n * this interval, the circuit breaker changes again to state open. If this circuit\n * breaker is already closed, this method has no effect, except that a new check\n * interval is started.\n * </p>\n */\n", "repo_name": "commons-lang-master/", "id": 137, "method_signature": "void close()", "filename": "EventCountCircuitBreaker.close.json"}
{"callee_method_names": ["Map<State, StateStrategy>.put", "Map<State, StateStrategy>.put"], "method_name": "EventCountCircuitBreaker.createStrategyMap", "method_implementation": "{\n    final Map<State, StateStrategy> map = new EnumMap<>(State.class);\n    map.put(State.CLOSED, new StateStrategyClosed());\n    map.put(State.OPEN, new StateStrategyOpen());\n    return map;\n}", "repo_id": "8", "comment": "/**\n * Creates the map with strategy objects. It allows access for a strategy for a given\n * state.\n *\n * @return the strategy map\n */\n", "repo_name": "commons-lang-master/", "id": 136, "method_signature": "Map<State,StateStrategy> createStrategyMap()", "filename": "EventCountCircuitBreaker.createStrategyMap.json"}
{"callee_method_names": ["CheckIntervalData.getCheckIntervalStart", "CheckIntervalData.getCheckIntervalStart", "CheckIntervalData.getEventCount", "EventCountCircuitBreaker.getClosingThreshold"], "method_name": "EventCountCircuitBreaker.isStateTransition", "method_implementation": "{\n    return nextData.getCheckIntervalStart() != currentData.getCheckIntervalStart() && currentData.getEventCount() < breaker.getClosingThreshold();\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 135, "method_signature": "boolean isStateTransition(EventCountCircuitBreaker, CheckIntervalData, CheckIntervalData)", "filename": "EventCountCircuitBreaker.isStateTransition.json"}
{"callee_method_names": ["CheckIntervalData.increment"], "method_name": "EventCountCircuitBreaker.nextCheckIntervalData", "method_implementation": "{\n    final CheckIntervalData nextData;\n    if (stateStrategy(currentState).isCheckIntervalFinished(this, currentData, time)) {\n        nextData = new CheckIntervalData(increment, time);\n    } else {\n        nextData = currentData.increment(increment);\n    }\n    return nextData;\n}", "repo_id": "8", "comment": "/**\n * Calculates the next {@link CheckIntervalData} object based on the current data and\n * the current state. The next data object takes the counter increment and the current\n * time into account.\n *\n * @param increment the increment for the internal counter\n * @param currentData the current check data object\n * @param currentState the current state of the circuit breaker\n * @param time the current time\n * @return the updated {@link CheckIntervalData} object\n */\n", "repo_name": "commons-lang-master/", "id": 138, "method_signature": "CheckIntervalData nextCheckIntervalData(int, CheckIntervalData, State, long)", "filename": "EventCountCircuitBreaker.nextCheckIntervalData.json"}
{"callee_method_names": ["AtomicReference<CheckIntervalData>.set"], "method_name": "EventCountCircuitBreaker.open", "method_implementation": "{\n    super.open();\n    checkIntervalData.set(new CheckIntervalData(0, nanoTime()));\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n * <p>\n * This circuit breaker may close itself again if the number of events\n * received during a check interval goes below the closing threshold. If this circuit\n * breaker is already open, this method has no effect, except that a new check\n * interval is started.\n * </p>\n */\n", "repo_name": "commons-lang-master/", "id": 139, "method_signature": "void open()", "filename": "EventCountCircuitBreaker.open.json"}
{"callee_method_names": ["AtomicReference<CheckIntervalData>.get", "State.oppositeState"], "method_name": "EventCountCircuitBreaker.performStateCheck", "method_implementation": "{\n    CheckIntervalData currentData;\n    CheckIntervalData nextData;\n    State currentState;\n    do {\n        final long time = nanoTime();\n        currentState = state.get();\n        currentData = checkIntervalData.get();\n        nextData = nextCheckIntervalData(increment, currentData, currentState, time);\n    } while (!updateCheckIntervalData(currentData, nextData));\n    // This might cause a race condition if other changes happen in between!\n    // Refer to the header comment!\n    if (stateStrategy(currentState).isStateTransition(this, currentData, nextData)) {\n        currentState = currentState.oppositeState();\n        changeStateAndStartNewCheckInterval(currentState);\n    }\n    return !isOpen(currentState);\n}", "repo_id": "8", "comment": "/**\n * Actually checks the state of this circuit breaker and executes a state transition\n * if necessary.\n *\n * @param increment the increment for the internal counter\n * @return a flag whether the circuit breaker is now closed\n */\n", "repo_name": "commons-lang-master/", "id": 140, "method_signature": "boolean performStateCheck(int)", "filename": "EventCountCircuitBreaker.performStateCheck.json"}
{"callee_method_names": ["AtomicReference<CheckIntervalData>.compareAndSet"], "method_name": "EventCountCircuitBreaker.updateCheckIntervalData", "method_implementation": "{\n    return currentData == nextData || checkIntervalData.compareAndSet(currentData, nextData);\n}", "repo_id": "8", "comment": "/**\n * Updates the {@link CheckIntervalData} object. The current data object is replaced\n * by the one modified by the last check. The return value indicates whether this was\n * successful. If it is <strong>false</strong>, another thread interfered, and the\n * whole operation has to be redone.\n *\n * @param currentData the current check data object\n * @param nextData the replacing check data object\n * @return a flag whether the update was successful\n */\n", "repo_name": "commons-lang-master/", "id": 141, "method_signature": "boolean updateCheckIntervalData(CheckIntervalData, CheckIntervalData)", "filename": "EventCountCircuitBreaker.updateCheckIntervalData.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isOpen", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.at"], "method_name": "EventCountCircuitBreakerTest.testAutomaticOpenStartsNewCheckInterval", "method_implementation": "{\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    long time = 10 * NANO_FACTOR;\n    for (int i = 0; i <= OPENING_THRESHOLD; i++) {\n        breaker.at(time++).incrementAndCheckState();\n    }\n    assertTrue(breaker.isOpen(), \"Not open\");\n    time += NANO_FACTOR - 1000;\n    assertFalse(breaker.at(time).incrementAndCheckState(), \"Already closed\");\n    time += 1001;\n    assertTrue(breaker.at(time).checkState(), \"Not closed in time interval\");\n}", "repo_id": "8", "comment": "/**\n * Tests whether a new check interval is started if the circuit breaker has a\n * transition to open state.\n */\n", "repo_name": "commons-lang-master/", "id": 1513, "method_signature": "void testAutomaticOpenStartsNewCheckInterval()", "filename": "EventCountCircuitBreakerTest.testAutomaticOpenStartsNewCheckInterval.json"}
{"callee_method_ids": [139, 137], "callee_method_names": ["EventCountCircuitBreaker.addChangeListener", "EventCountCircuitBreaker.open", "EventCountCircuitBreaker.close", "ChangeListener.verify"], "method_name": "EventCountCircuitBreakerTest.testChangeEvents", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS);\n    final ChangeListener listener = new ChangeListener(breaker);\n    breaker.addChangeListener(listener);\n    breaker.open();\n    breaker.close();\n    listener.verify(Boolean.TRUE, Boolean.FALSE);\n}", "repo_id": "8", "comment": "/**\n * Tests whether events are generated when the state is changed.\n */\n", "repo_name": "commons-lang-master/", "id": 1514, "method_signature": "void testChangeEvents()", "filename": "EventCountCircuitBreakerTest.testChangeEvents.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.addChangeListener", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.at", "ChangeListener.verify"], "method_name": "EventCountCircuitBreakerTest.testChangeEventsGeneratedByAutomaticTransitions", "method_implementation": "{\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    final ChangeListener listener = new ChangeListener(breaker);\n    breaker.addChangeListener(listener);\n    long time = 0;\n    for (int i = 0; i <= OPENING_THRESHOLD; i++, time += 1000) {\n        breaker.at(time).incrementAndCheckState();\n    }\n    breaker.at(NANO_FACTOR + 1).checkState();\n    breaker.at(3 * NANO_FACTOR).checkState();\n    listener.verify(Boolean.TRUE, Boolean.FALSE);\n}", "repo_id": "8", "comment": "/**\n * Tests that automatic state transitions generate change events as well.\n */\n", "repo_name": "commons-lang-master/", "id": 1515, "method_signature": "void testChangeEventsGeneratedByAutomaticTransitions()", "filename": "EventCountCircuitBreakerTest.testChangeEventsGeneratedByAutomaticTransitions.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isOpen", "EventCountCircuitBreakerTestImpl.close", "EventCountCircuitBreakerTestImpl.isClosed", "EventCountCircuitBreakerTestImpl.at"], "method_name": "EventCountCircuitBreakerTest.testClose", "method_implementation": "{\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    long time = 0;\n    for (int i = 0; i <= OPENING_THRESHOLD; i++, time += 1000) {\n        breaker.at(time).incrementAndCheckState();\n    }\n    assertTrue(breaker.isOpen(), \"Not open\");\n    breaker.close();\n    assertTrue(breaker.isClosed(), \"Not closed\");\n    assertTrue(breaker.at(time + 1000).incrementAndCheckState(), \"Open again\");\n}", "repo_id": "8", "comment": "/**\n * Tests whether the circuit breaker can be closed explicitly.\n */\n", "repo_name": "commons-lang-master/", "id": 1516, "method_signature": "void testClose()", "filename": "EventCountCircuitBreakerTest.testClose.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.open", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isClosed"], "method_name": "EventCountCircuitBreakerTest.testClosingWhenThresholdReached", "method_implementation": "{\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 10, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    breaker.open();\n    breaker.at(1000).incrementAndCheckState();\n    assertFalse(breaker.at(2000).checkState(), \"Already closed\");\n    assertFalse(breaker.at(NANO_FACTOR).checkState(), \"Closed at interval end\");\n    assertTrue(breaker.at(NANO_FACTOR + 1).checkState(), \"Not closed after interval end\");\n    assertTrue(breaker.isClosed(), \"Not closed at end\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the circuit breaker closes automatically if the number of events\n * received goes under the closing threshold.\n */\n", "repo_name": "commons-lang-master/", "id": 1517, "method_signature": "void testClosingWhenThresholdReached()", "filename": "EventCountCircuitBreakerTest.testClosingWhenThresholdReached.json"}
{"callee_method_names": ["EventCountCircuitBreaker.getClosingInterval"], "method_name": "EventCountCircuitBreakerTest.testDefaultClosingInterval", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS, CLOSING_THRESHOLD);\n    assertEquals(NANO_FACTOR, breaker.getClosingInterval(), \"Wrong closing interval\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the closing interval is the same as the opening interval if it is not\n * specified.\n */\n", "repo_name": "commons-lang-master/", "id": 1518, "method_signature": "void testDefaultClosingInterval()", "filename": "EventCountCircuitBreakerTest.testDefaultClosingInterval.json"}
{"callee_method_names": ["EventCountCircuitBreaker.getClosingInterval", "EventCountCircuitBreaker.getClosingThreshold"], "method_name": "EventCountCircuitBreakerTest.testDefaultClosingThreshold", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS);\n    assertEquals(NANO_FACTOR, breaker.getClosingInterval(), \"Wrong closing interval\");\n    assertEquals(OPENING_THRESHOLD, breaker.getClosingThreshold(), \"Wrong closing threshold\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the closing threshold is the same as the opening threshold if not\n * specified otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 1519, "method_signature": "void testDefaultClosingThreshold()", "filename": "EventCountCircuitBreakerTest.testDefaultClosingThreshold.json"}
{"callee_method_names": ["EventCountCircuitBreaker.isOpen", "EventCountCircuitBreaker.isClosed"], "method_name": "EventCountCircuitBreakerTest.testInitiallyClosed", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS);\n    assertFalse(breaker.isOpen(), \"Open\");\n    assertTrue(breaker.isClosed(), \"Not closed\");\n}", "repo_id": "8", "comment": "/**\n * Tests that a circuit breaker is closed after its creation.\n */\n", "repo_name": "commons-lang-master/", "id": 1520, "method_signature": "void testInitiallyClosed()", "filename": "EventCountCircuitBreakerTest.testInitiallyClosed.json"}
{"callee_method_names": ["EventCountCircuitBreaker.getOpeningInterval", "EventCountCircuitBreaker.getClosingInterval"], "method_name": "EventCountCircuitBreakerTest.testIntervalCalculation", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS, CLOSING_THRESHOLD, 2, TimeUnit.MILLISECONDS);\n    assertEquals(NANO_FACTOR, breaker.getOpeningInterval(), \"Wrong opening interval\");\n    assertEquals(2 * NANO_FACTOR / 1000, breaker.getClosingInterval(), \"Wrong closing interval\");\n}", "repo_id": "8", "comment": "/**\n * Tests that time units are correctly taken into account by constructors.\n */\n", "repo_name": "commons-lang-master/", "id": 1521, "method_signature": "void testIntervalCalculation()", "filename": "EventCountCircuitBreakerTest.testIntervalCalculation.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.open", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isOpen"], "method_name": "EventCountCircuitBreakerTest.testNotClosingOverThreshold", "method_implementation": "{\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 10, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    long startTime = 0;\n    breaker.open();\n    for (int i = 0; i <= CLOSING_THRESHOLD; i++) {\n        assertFalse(breaker.at(startTime).incrementAndCheckState(), \"Not open\");\n        startTime += 1000;\n    }\n    assertFalse(breaker.at(startTime + NANO_FACTOR).incrementAndCheckState(), \"Closed in new interval\");\n    assertTrue(breaker.isOpen(), \"Not open at end\");\n}", "repo_id": "8", "comment": "/**\n * Tests that an open circuit breaker does not close itself when the number of events\n * received is over the threshold.\n */\n", "repo_name": "commons-lang-master/", "id": 1522, "method_signature": "void testNotClosingOverThreshold()", "filename": "EventCountCircuitBreakerTest.testNotClosingOverThreshold.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isClosed"], "method_name": "EventCountCircuitBreakerTest.testNotOpeningCheckIntervalExceeded", "method_implementation": "{\n    long startTime = 0L;\n    final long timeIncrement = 3 * NANO_FACTOR / (2 * OPENING_THRESHOLD);\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    for (int i = 0; i < 5 * OPENING_THRESHOLD; i++) {\n        assertTrue(breaker.at(startTime).incrementAndCheckState(), \"In open state\");\n        startTime += timeIncrement;\n    }\n    assertTrue(breaker.isClosed(), \"Not closed\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the circuit breaker stays closed if there are a number of received\n * events, but not in a single check interval.\n */\n", "repo_name": "commons-lang-master/", "id": 1523, "method_signature": "void testNotOpeningCheckIntervalExceeded()", "filename": "EventCountCircuitBreakerTest.testNotOpeningCheckIntervalExceeded.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isClosed"], "method_name": "EventCountCircuitBreakerTest.testNotOpeningUnderThreshold", "method_implementation": "{\n    long startTime = 1000;\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    for (int i = 0; i < OPENING_THRESHOLD - 1; i++) {\n        assertTrue(breaker.at(startTime).incrementAndCheckState(), \"In open state\");\n        startTime++;\n    }\n    assertTrue(breaker.isClosed(), \"Not closed\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the circuit breaker stays closed if the number of received events stays\n * below the threshold.\n */\n", "repo_name": "commons-lang-master/", "id": 1524, "method_signature": "void testNotOpeningUnderThreshold()", "filename": "EventCountCircuitBreakerTest.testNotOpeningUnderThreshold.json"}
{"callee_method_names": ["EventCountCircuitBreaker.nanoTime"], "method_name": "EventCountCircuitBreakerTest.testNow", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS);\n    final long nowNanos = breaker.nanoTime();\n    final long deltaNanos = Math.abs(System.nanoTime() - nowNanos);\n    assertTrue(deltaNanos < 100_000, String.format(\"Delta %,d ns to current time too large\", deltaNanos));\n}", "repo_id": "8", "comment": "/**\n * Tests whether the current time is correctly determined.\n */\n", "repo_name": "commons-lang-master/", "id": 1525, "method_signature": "void testNow()", "filename": "EventCountCircuitBreakerTest.testNow.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isOpen", "EventCountCircuitBreakerTestImpl.at"], "method_name": "EventCountCircuitBreakerTest.testOpenStartsNewCheckInterval", "method_implementation": "{\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    breaker.at(NANO_FACTOR - 1000).open();\n    assertTrue(breaker.isOpen(), \"Not open\");\n    assertFalse(breaker.at(NANO_FACTOR + 100).checkState(), \"Already closed\");\n}", "repo_id": "8", "comment": "/**\n * Tests whether an explicit open operation fully initializes the internal check data\n * object. Otherwise, the circuit breaker may close itself directly afterwards.\n */\n", "repo_name": "commons-lang-master/", "id": 1528, "method_signature": "void testOpenStartsNewCheckInterval()", "filename": "EventCountCircuitBreakerTest.testOpenStartsNewCheckInterval.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isClosed"], "method_name": "EventCountCircuitBreakerTest.testOpeningWhenThresholdReached", "method_implementation": "{\n    long startTime = 0;\n    final long timeIncrement = NANO_FACTOR / OPENING_THRESHOLD - 1;\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    boolean open = false;\n    for (int i = 0; i < OPENING_THRESHOLD + 1; i++) {\n        open = !breaker.at(startTime).incrementAndCheckState();\n        startTime += timeIncrement;\n    }\n    assertTrue(open, \"Not open\");\n    assertFalse(breaker.isClosed(), \"Closed\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the circuit breaker opens if all conditions are met.\n */\n", "repo_name": "commons-lang-master/", "id": 1526, "method_signature": "void testOpeningWhenThresholdReached()", "filename": "EventCountCircuitBreakerTest.testOpeningWhenThresholdReached.json"}
{"callee_method_names": ["EventCountCircuitBreakerTestImpl.at", "EventCountCircuitBreakerTestImpl.isClosed"], "method_name": "EventCountCircuitBreakerTest.testOpeningWhenThresholdReachedThroughBatch", "method_implementation": "{\n    final long timeIncrement = NANO_FACTOR / OPENING_THRESHOLD - 1;\n    final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n    final long startTime = timeIncrement * (OPENING_THRESHOLD + 1);\n    final boolean open = !breaker.at(startTime).incrementAndCheckState(OPENING_THRESHOLD + 1);\n    assertTrue(open, \"Not open\");\n    assertFalse(breaker.isClosed(), \"Closed\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the circuit breaker opens if all conditions are met when using\n * {@link EventCountCircuitBreaker#incrementAndCheckState(Integer increment)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1527, "method_signature": "void testOpeningWhenThresholdReachedThroughBatch()", "filename": "EventCountCircuitBreakerTest.testOpeningWhenThresholdReachedThroughBatch.json"}
{"callee_method_ids": [139, 137], "callee_method_names": ["EventCountCircuitBreaker.addChangeListener", "EventCountCircuitBreaker.open", "EventCountCircuitBreaker.removeChangeListener", "EventCountCircuitBreaker.close", "ChangeListener.verify"], "method_name": "EventCountCircuitBreakerTest.testRemoveChangeListener", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS);\n    final ChangeListener listener = new ChangeListener(breaker);\n    breaker.addChangeListener(listener);\n    breaker.open();\n    breaker.removeChangeListener(listener);\n    breaker.close();\n    listener.verify(Boolean.TRUE);\n}", "repo_id": "8", "comment": "/**\n * Tests whether a change listener can be removed.\n */\n", "repo_name": "commons-lang-master/", "id": 1529, "method_signature": "void testRemoveChangeListener()", "filename": "EventCountCircuitBreakerTest.testRemoveChangeListener.json"}
{"callee_method_ids": [139], "callee_method_names": ["EventCountCircuitBreaker.addChangeListener", "CountDownLatch.await", "EventCountCircuitBreaker.open", "Thread[].start", "CountDownLatch.countDown", "Thread.join", "ChangeListener.verify"], "method_name": "EventCountCircuitBreakerTest.testStateTransitionGuarded", "method_implementation": "{\n    final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1, TimeUnit.SECONDS);\n    final ChangeListener listener = new ChangeListener(breaker);\n    breaker.addChangeListener(listener);\n    final int threadCount = 128;\n    final CountDownLatch latch = new CountDownLatch(1);\n    final Thread[] threads = new Thread[threadCount];\n    for (int i = 0; i < threadCount; i++) {\n        threads[i] = new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    latch.await();\n                } catch (final InterruptedException iex) {\n                    // ignore\n                }\n                breaker.open();\n            }\n        };\n        threads[i].start();\n    }\n    latch.countDown();\n    for (final Thread thread : threads) {\n        thread.join();\n    }\n    listener.verify(Boolean.TRUE);\n}", "repo_id": "8", "comment": "/**\n * Tests that a state transition triggered by multiple threads is handled correctly.\n * Only the first transition should cause an event to be sent.\n */\n", "repo_name": "commons-lang-master/", "id": 1530, "method_signature": "void testStateTransitionGuarded()", "filename": "EventCountCircuitBreakerTest.testStateTransitionGuarded.json"}
{"callee_method_names": ["CopyOnWriteArrayList.contains", "CopyOnWriteArrayList.add"], "method_name": "EventListenerSupport.addListener", "method_implementation": "{\n    Objects.requireNonNull(listener, \"listener\");\n    if (allowDuplicate || !listeners.contains(listener)) {\n        listeners.add(listener);\n    }\n}", "repo_id": "8", "comment": "/**\n * Registers an event listener.  Will not add a pre-existing listener\n * object to the list if {@code allowDuplicate} is false.\n *\n * @param listener the event listener (may not be {@code null}).\n * @param allowDuplicate the flag for determining if duplicate listener\n * objects are allowed to be registered.\n *\n * @throws NullPointerException if {@code listener} is {@code null}.\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 723, "method_signature": "void addListener(L, boolean)", "filename": "EventListenerSupport.addListener.json"}
{"callee_method_names": [], "method_name": "EventListenerSupport.initializeTransientFields", "method_implementation": "{\n    // Will throw CCE here if not correct\n    this.prototypeArray = ArrayUtils.newInstance(listenerInterface, 0);\n    createProxy(listenerInterface, classLoader);\n}", "repo_id": "8", "comment": "/**\n * Initialize transient fields.\n * @param listenerInterface the class of the listener interface\n * @param classLoader the class loader to be used\n */\n", "repo_name": "commons-lang-master/", "id": 724, "method_signature": "void initializeTransientFields(Class, ClassLoader)", "filename": "EventListenerSupport.initializeTransientFields.json"}
{"callee_method_names": ["Method.invoke"], "method_name": "EventListenerSupport.invoke", "method_implementation": "{\n    for (final L listener : listeners) {\n        method.invoke(listener, args);\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Propagates the method call to all registered listeners in place of the proxy listener object.\n *\n * @param unusedProxy the proxy object representing a listener on which the invocation was called; not used\n * @param method the listener method that will be called on all of the listeners.\n * @param args event arguments to propagate to the listeners.\n * @return the result of the method call\n * @throws InvocationTargetException if an error occurs\n * @throws IllegalArgumentException if an error occurs\n * @throws IllegalAccessException if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 722, "method_signature": "Object invoke(Object, Method, Object[])", "filename": "EventListenerSupport.invoke.json"}
{"callee_method_names": ["ObjectInputStream.readObject"], "method_name": "EventListenerSupport.readObject", "method_implementation": "{\n    // Will throw CCE here if not correct\n    @SuppressWarnings(\"unchecked\")\n    final L[] srcListeners = (L[]) objectInputStream.readObject();\n    this.listeners = new CopyOnWriteArrayList<>(srcListeners);\n    final Class<L> listenerInterface = ArrayUtils.getComponentType(srcListeners);\n    initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n}", "repo_id": "8", "comment": "/**\n * Deserialize.\n * @param objectInputStream the input stream\n * @throws IOException if an IO error occurs\n * @throws ClassNotFoundException if the class cannot be resolved\n */\n", "repo_name": "commons-lang-master/", "id": 725, "method_signature": "void readObject(ObjectInputStream)", "filename": "EventListenerSupport.readObject.json"}
{"callee_method_names": ["ObjectOutputStream.writeObject", "ArrayList<L>.add", "ObjectOutputStream.writeObject", "ArrayList<L>.toArray"], "method_name": "EventListenerSupport.writeObject", "method_implementation": "{\n    final ArrayList<L> serializableListeners = new ArrayList<>();\n    // don't just rely on instanceof Serializable:\n    ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n    for (final L listener : listeners) {\n        try {\n            testObjectOutputStream.writeObject(listener);\n            serializableListeners.add(listener);\n        } catch (final IOException exception) {\n            //recreate test stream in case of indeterminate state\n            testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n        }\n    }\n    /*\n         * we can reconstitute everything we need from an array of our listeners,\n         * which has the additional advantage of typically requiring less storage than a list:\n         */\n    objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\n}", "repo_id": "8", "comment": "/**\n * Serialize.\n * @param objectOutputStream the output stream\n * @throws IOException if an IO error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 726, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "EventListenerSupport.writeObject.json"}
{"callee_method_names": ["Class<L>.getSimpleName", "Object.getClass", "Class<L>.getSimpleName", "Class<L>.getName", "Object.getClass", "Class<L>.getSimpleName", "Class<L>.getName", "Exception.getCause"], "method_name": "EventUtils.addEventListener", "method_implementation": "{\n    try {\n        MethodUtils.invokeMethod(eventSource, \"add\" + listenerType.getSimpleName(), listener);\n    } catch (final NoSuchMethodException e) {\n        throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName() + \" does not have a public add\" + listenerType.getSimpleName() + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n    } catch (final IllegalAccessException e) {\n        throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName() + \" does not have an accessible add\" + listenerType.getSimpleName() + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n    } catch (final InvocationTargetException e) {\n        throw new IllegalArgumentException(\"Unable to add listener.\", e.getCause());\n    }\n}", "repo_id": "8", "comment": "/**\n * Adds an event listener to the specified source.  This looks for an \"add\" method corresponding to the event\n * type (addActionListener, for example).\n * @param eventSource   the event source\n * @param listenerType  the event listener type\n * @param listener      the listener\n * @param <L>           the event listener type\n *\n * @throws IllegalArgumentException if the object doesn't support the listener type\n */\n", "repo_name": "commons-lang-master/", "id": 729, "method_signature": "void addEventListener(Object, Class, L)", "filename": "EventUtils.addEventListener.json"}
{"callee_method_names": ["Class<L>.cast", "Object.getClass"], "method_name": "EventUtils.bindEventsToMethod", "method_implementation": "{\n    final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes)));\n    addEventListener(eventSource, listenerType, listener);\n}", "repo_id": "8", "comment": "/**\n * Binds an event listener to a specific method on a specific object.\n *\n * @param <L>          the event listener type\n * @param target       the target object\n * @param methodName   the name of the method to be called\n * @param eventSource  the object which is generating events (JButton, JList, etc.)\n * @param listenerType the listener interface (ActionListener.class, SelectionListener.class, etc.)\n * @param eventTypes   the event types (method names) from the listener interface (if none specified, all will be\n *                     supported)\n */\n", "repo_name": "commons-lang-master/", "id": 730, "method_signature": "void bindEventsToMethod(Object, String, Object, Class, String[])", "filename": "EventUtils.bindEventsToMethod.json"}
{"callee_method_names": ["Set<String>.isEmpty", "Set<String>.contains", "Method.getName"], "method_name": "EventUtils.invoke", "method_implementation": "{\n    if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) {\n        if (hasMatchingParametersMethod(method)) {\n            return MethodUtils.invokeMethod(target, methodName, parameters);\n        }\n        return MethodUtils.invokeMethod(target, methodName);\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Handles a method invocation on the proxy object.\n *\n * @param proxy the proxy instance\n * @param method the method to be invoked\n * @param parameters the parameters for the method invocation\n * @return the result of the method call\n * @throws Throwable if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 728, "method_signature": "Object invoke(Object, Method, Object[])", "filename": "EventUtils.invoke.json"}
{"callee_method_names": ["Throwable.getCause"], "method_name": "ExceptionUtils.getCause", "method_implementation": "{\n    if (throwable == null) {\n        return null;\n    }\n    if (methodNames == null) {\n        final Throwable cause = throwable.getCause();\n        if (cause != null) {\n            return cause;\n        }\n        methodNames = CAUSE_METHOD_NAMES;\n    }\n    return Stream.of(methodNames).map(m -> getCauseUsingMethodName(throwable, m)).filter(Objects::nonNull).findFirst().orElse(null);\n}", "repo_id": "8", "comment": "/**\n * Introspects the {@link Throwable} to obtain the cause.\n *\n * <p>A {@code null} set of method names means use the default set.\n * A {@code null} in the set of method names will be ignored.</p>\n *\n * @param throwable  the throwable to introspect for a cause, may be null\n * @param methodNames  the method names, null treated as default set\n * @return the cause of the {@link Throwable},\n *  {@code null} if none found or null throwable input\n * @since 1.0\n * @deprecated This feature will be removed in Lang 4, use {@link Throwable#getCause} instead\n */\n", "repo_name": "commons-lang-master/", "id": 548, "method_signature": "Throwable getCause(Throwable, String[])", "filename": "ExceptionUtils.getCause.json"}
{"callee_method_names": ["Throwable.getClass", "Method.getReturnType", "Method.invoke"], "method_name": "ExceptionUtils.getCauseUsingMethodName", "method_implementation": "{\n    if (methodName != null) {\n        Method method = null;\n        try {\n            method = throwable.getClass().getMethod(methodName);\n        } catch (final NoSuchMethodException | SecurityException ignored) {\n            // exception ignored\n        }\n        if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n            try {\n                return (Throwable) method.invoke(throwable);\n            } catch (final IllegalAccessException | IllegalArgumentException | InvocationTargetException ignored) {\n                // exception ignored\n            }\n        }\n    }\n    return null;\n}", "repo_id": "8", "comment": "// TODO: Remove in Lang 4\n", "repo_name": "commons-lang-master/", "id": 549, "method_signature": "Throwable getCauseUsingMethodName(Throwable, String)", "filename": "ExceptionUtils.getCauseUsingMethodName.json"}
{"callee_method_names": ["Throwable.getMessage"], "method_name": "ExceptionUtils.getMessage", "method_implementation": "{\n    if (th == null) {\n        return StringUtils.EMPTY;\n    }\n    final String clsName = ClassUtils.getShortClassName(th, null);\n    return clsName + \": \" + StringUtils.defaultString(th.getMessage());\n}", "repo_id": "8", "comment": "/**\n * Gets a short message summarizing the exception.\n * <p>\n * The message returned is of the form\n * {ClassNameWithoutPackage}: {ThrowableMessage}\n * </p>\n *\n * @param th  the throwable to get a message for, null returns empty string\n * @return the message, non-null\n * @since 2.2\n */\n", "repo_name": "commons-lang-master/", "id": 550, "method_signature": "String getMessage(Throwable)", "filename": "ExceptionUtils.getMessage.json"}
{"callee_method_names": ["List<String>.add", "Throwable[].toString", "List<String>.add", "Throwable[].toString", "List<String>.addAll"], "method_name": "ExceptionUtils.getRootCauseStackTraceList", "method_implementation": "{\n    if (throwable == null) {\n        return Collections.emptyList();\n    }\n    final Throwable[] throwables = getThrowables(throwable);\n    final int count = throwables.length;\n    final List<String> frames = new ArrayList<>();\n    List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n    for (int i = count; --i >= 0; ) {\n        final List<String> trace = nextTrace;\n        if (i != 0) {\n            nextTrace = getStackFrameList(throwables[i - 1]);\n            removeCommonFrames(trace, nextTrace);\n        }\n        if (i == count - 1) {\n            frames.add(throwables[i].toString());\n        } else {\n            frames.add(WRAPPED_MARKER + throwables[i].toString());\n        }\n        frames.addAll(trace);\n    }\n    return frames;\n}", "repo_id": "8", "comment": "/**\n * Gets a compact stack trace for the root cause of the supplied {@link Throwable}.\n *\n * <p>\n * The output of this method is consistent across JDK versions. It consists of the root exception followed by each of\n * its wrapping exceptions separated by '[wrapped]'. Note that this is the opposite order to the JDK1.4 display.\n * </p>\n *\n * @param throwable the throwable to examine, may be null\n * @return a list of stack trace frames, never null\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 551, "method_signature": "List<String> getRootCauseStackTraceList(Throwable)", "filename": "ExceptionUtils.getRootCauseStackTraceList.json"}
{"callee_method_names": ["StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "String.indexOf", "String.substring", "List<String>.add"], "method_name": "ExceptionUtils.getStackFrameList", "method_implementation": "{\n    final String stackTrace = getStackTrace(throwable);\n    final String linebreak = System.lineSeparator();\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != NOT_FOUND && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}", "repo_id": "8", "comment": "/**\n * Gets a {@link List} of stack frames - the message\n * is not included. Only the trace of the specified exception is\n * returned, any caused by trace is stripped.\n *\n * <p>This works in most cases - it will only fail if the exception\n * message contains a line that starts with:\n * {@code &quot;&nbsp;&nbsp;&nbsp;at&quot;.}</p>\n *\n * @param throwable is any throwable\n * @return List of stack frames\n */\n", "repo_name": "commons-lang-master/", "id": 552, "method_signature": "List<String> getStackFrameList(Throwable)", "filename": "ExceptionUtils.getStackFrameList.json"}
{"callee_method_names": [], "method_name": "ExceptionUtils.getStackFrames", "method_implementation": "{\n    if (throwable == null) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    return getStackFrames(getStackTrace(throwable));\n}", "repo_id": "8", "comment": "/**\n * Gets the stack trace associated with the specified\n * {@link Throwable} object, decomposing it into a list of\n * stack frames.\n *\n * <p>The result of this method vary by JDK version as this method\n * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n * On JDK1.3 and earlier, the cause exception will not be shown\n * unless the specified throwable alters printStackTrace.</p>\n *\n * @param throwable  the {@link Throwable} to examine, may be null\n * @return an array of strings describing each stack frame, never null\n */\n", "repo_name": "commons-lang-master/", "id": 554, "method_signature": "String[] getStackFrames(Throwable)", "filename": "ExceptionUtils.getStackFrames.json"}
{"callee_method_names": ["Throwable.printStackTrace", "StringWriter.toString"], "method_name": "ExceptionUtils.getStackTrace", "method_implementation": "{\n    if (throwable == null) {\n        return StringUtils.EMPTY;\n    }\n    final StringWriter sw = new StringWriter();\n    throwable.printStackTrace(new PrintWriter(sw, true));\n    return sw.toString();\n}", "repo_id": "8", "comment": "/**\n * Gets the stack trace from a Throwable as a String.\n *\n * <p>The result of this method vary by JDK version as this method\n * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n * On JDK1.3 and earlier, the cause exception will not be shown\n * unless the specified throwable alters printStackTrace.</p>\n *\n * @param throwable  the {@link Throwable} to be examined, may be null\n * @return the stack trace as generated by the exception's\n * {@code printStackTrace(PrintWriter)} method, or an empty String if {@code null} input\n */\n", "repo_name": "commons-lang-master/", "id": 555, "method_signature": "String getStackTrace(Throwable)", "filename": "ExceptionUtils.getStackTrace.json"}
{"callee_method_names": ["List<Throwable>.contains", "List<Throwable>.add", "Throwable.getCause"], "method_name": "ExceptionUtils.getThrowableList", "method_implementation": "{\n    final List<Throwable> list = new ArrayList<>();\n    while (throwable != null && !list.contains(throwable)) {\n        list.add(throwable);\n        throwable = throwable.getCause();\n    }\n    return list;\n}", "repo_id": "8", "comment": "/**\n * Gets the list of {@link Throwable} objects in the\n * exception chain.\n *\n * <p>A throwable without cause will return a list containing\n * one element - the input throwable.\n * A throwable with one cause will return a list containing\n * two elements. - the input throwable and the cause throwable.\n * A {@code null} throwable will return a list of size zero.</p>\n *\n * <p>This method handles recursive cause chains that might\n * otherwise cause infinite loops. The cause chain is processed until\n * the end, or until the next item in the chain is already\n * in the result list.</p>\n *\n * @param throwable  the throwable to inspect, may be null\n * @return the list of throwables, never null\n * @since 2.2\n */\n", "repo_name": "commons-lang-master/", "id": 556, "method_signature": "List<Throwable> getThrowableList(Throwable)", "filename": "ExceptionUtils.getThrowableList.json"}
{"callee_method_names": ["Throwable.getCause", "Class<? extends Throwable>.isInstance"], "method_name": "ExceptionUtils.hasCause", "method_implementation": "{\n    if (chain instanceof UndeclaredThrowableException) {\n        chain = chain.getCause();\n    }\n    return type.isInstance(chain);\n}", "repo_id": "8", "comment": "/**\n * Tests if the throwable's causal chain have an immediate or wrapped exception\n * of the given type?\n *\n * @param chain\n *            The root of a Throwable causal chain.\n * @param type\n *            The exception type to test.\n * @return true, if chain is an instance of type or is an\n *         UndeclaredThrowableException wrapping a cause.\n * @since 3.5\n * @see #wrapAndThrow(Throwable)\n */\n", "repo_name": "commons-lang-master/", "id": 557, "method_signature": "boolean hasCause(Throwable, Class)", "filename": "ExceptionUtils.hasCause.json"}
{"callee_method_names": ["Class<? extends Throwable>.isAssignableFrom", "Throwable[].getClass", "Class<? extends Throwable>.equals", "Throwable[].getClass"], "method_name": "ExceptionUtils.indexOf", "method_implementation": "{\n    if (throwable == null || type == null) {\n        return NOT_FOUND;\n    }\n    if (fromIndex < 0) {\n        fromIndex = 0;\n    }\n    final Throwable[] throwables = getThrowables(throwable);\n    if (fromIndex >= throwables.length) {\n        return NOT_FOUND;\n    }\n    if (subclass) {\n        for (int i = fromIndex; i < throwables.length; i++) {\n            if (type.isAssignableFrom(throwables[i].getClass())) {\n                return i;\n            }\n        }\n    } else {\n        for (int i = fromIndex; i < throwables.length; i++) {\n            if (type.equals(throwables[i].getClass())) {\n                return i;\n            }\n        }\n    }\n    return NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Worker method for the {@code indexOfType} methods.\n *\n * @param throwable  the throwable to inspect, may be null\n * @param type  the type to search for, subclasses match, null returns -1\n * @param fromIndex  the (zero-based) index of the starting position,\n *  negative treated as zero, larger than chain size returns -1\n * @param subclass if {@code true}, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares\n * using references\n * @return index of the {@code type} within throwables nested within the specified {@code throwable}\n */\n", "repo_name": "commons-lang-master/", "id": 558, "method_signature": "int indexOf(Throwable, Class, int, boolean)", "filename": "ExceptionUtils.indexOf.json"}
{"callee_method_names": ["PrintWriter.flush"], "method_name": "ExceptionUtils.printRootCauseStackTrace", "method_implementation": "{\n    if (throwable == null) {\n        return;\n    }\n    Objects.requireNonNull(printWriter, \"printWriter\");\n    getRootCauseStackTraceList(throwable).forEach(printWriter::println);\n    printWriter.flush();\n}", "repo_id": "8", "comment": "/**\n * Prints a compact stack trace for the root cause of a throwable.\n *\n * <p>The compact stack trace starts with the root cause and prints\n * stack frames up to the place where it was caught and wrapped.\n * Then it prints the wrapped exception and continues with stack frames\n * until the wrapper exception is caught and wrapped again, etc.</p>\n *\n * <p>The output of this method is consistent across JDK versions.\n * Note that this is the opposite order to the JDK1.4 display.</p>\n *\n * <p>The method is equivalent to {@code printStackTrace} for throwables\n * that don't have nested causes.</p>\n *\n * @param throwable  the throwable to output, may be null\n * @param printWriter  the writer to output to, may not be null\n * @throws NullPointerException if the printWriter is {@code null}\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 560, "method_signature": "void printRootCauseStackTrace(Throwable, PrintWriter)", "filename": "ExceptionUtils.printRootCauseStackTrace.json"}
{"callee_method_names": ["List<String>.size", "List<String>.size", "List<String>.get", "List<String>.get", "String.equals", "List<String>.remove"], "method_name": "ExceptionUtils.removeCommonFrames", "method_implementation": "{\n    Objects.requireNonNull(causeFrames, \"causeFrames\");\n    Objects.requireNonNull(wrapperFrames, \"wrapperFrames\");\n    int causeFrameIndex = causeFrames.size() - 1;\n    int wrapperFrameIndex = wrapperFrames.size() - 1;\n    while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n        // Remove the frame from the cause trace if it is the same\n        // as in the wrapper trace\n        final String causeFrame = causeFrames.get(causeFrameIndex);\n        final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n        if (causeFrame.equals(wrapperFrame)) {\n            causeFrames.remove(causeFrameIndex);\n        }\n        causeFrameIndex--;\n        wrapperFrameIndex--;\n    }\n}", "repo_id": "8", "comment": "/**\n * Removes common frames from the cause trace given the two stack traces.\n *\n * @param causeFrames  stack trace of a cause throwable\n * @param wrapperFrames  stack trace of a wrapper throwable\n * @throws NullPointerException if either argument is null\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 561, "method_signature": "void removeCommonFrames(List, List)", "filename": "ExceptionUtils.removeCommonFrames.json"}
{"callee_method_names": [], "method_name": "ExceptionUtils.throwUnchecked", "method_implementation": "{\n    if (isUnchecked(throwable)) {\n        throw asRuntimeException(throwable);\n    }\n    return throwable;\n}", "repo_id": "8", "comment": "/**\n * Tests whether the specified {@link Throwable} is unchecked and throws it if so.\n *\n * @param <T> The Throwable type.\n * @param throwable the throwable to test and throw or return.\n * @return the given throwable.\n * @since 3.14.0\n */\n", "repo_name": "commons-lang-master/", "id": 564, "method_signature": "T throwUnchecked(T)", "filename": "ExceptionUtils.throwUnchecked.json"}
{"callee_method_names": ["Class<T>.isAssignableFrom", "Throwable[].getClass", "Class<T>.cast", "Class<T>.equals", "Throwable[].getClass", "Class<T>.cast"], "method_name": "ExceptionUtils.throwableOf", "method_implementation": "{\n    if (throwable == null || type == null) {\n        return null;\n    }\n    if (fromIndex < 0) {\n        fromIndex = 0;\n    }\n    final Throwable[] throwables = getThrowables(throwable);\n    if (fromIndex >= throwables.length) {\n        return null;\n    }\n    if (subclass) {\n        for (int i = fromIndex; i < throwables.length; i++) {\n            if (type.isAssignableFrom(throwables[i].getClass())) {\n                return type.cast(throwables[i]);\n            }\n        }\n    } else {\n        for (int i = fromIndex; i < throwables.length; i++) {\n            if (type.equals(throwables[i].getClass())) {\n                return type.cast(throwables[i]);\n            }\n        }\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Worker method for the {@code throwableOfType} methods.\n *\n * @param <T> the type of Throwable you are searching.\n * @param throwable  the throwable to inspect, may be null\n * @param type  the type to search, subclasses match, null returns null\n * @param fromIndex  the (zero-based) index of the starting position,\n *  negative treated as zero, larger than chain size returns null\n * @param subclass if {@code true}, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares\n * using references\n * @return throwable of the {@code type} within throwables nested within the specified {@code throwable}\n */\n", "repo_name": "commons-lang-master/", "id": 562, "method_signature": "T throwableOf(Throwable, Class, int, boolean)", "filename": "ExceptionUtils.throwableOf.json"}
{"callee_method_names": ["PrintWriter.write"], "method_name": "ExceptionUtilsTest.printStackTrace", "method_implementation": "{\n    s.write(\"org.apache.commons.lang3.exception.ExceptionUtilsTest$1\\n\" + \"\\tat org.apache.commons.lang3.exception.ExceptionUtilsTest.testgetStackFramesGappyPath(ExceptionUtilsTest.java:706)\\n\" + \"\\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\" + \"\\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)\\n\" + \"\\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)\\n\");\n}", "repo_id": "8", "comment": "// provide static stack trace to make test stable\n", "repo_name": "commons-lang-master/", "id": 1782, "method_signature": "void printStackTrace(PrintWriter)", "filename": "ExceptionUtilsTest.printStackTrace.json"}
{"callee_method_names": ["String.toCharArray", "ParsePosition.getIndex", "StringBuilder.append", "ParsePosition.getIndex", "String.toCharArray", "ParsePosition.getIndex", "String.length", "ParsePosition.getIndex", "StringBuilder.append", "ParsePosition.getIndex"], "method_name": "ExtendedMessageFormat.appendQuotedString", "method_implementation": "{\n    assert pattern.toCharArray()[pos.getIndex()] == QUOTE : \"Quoted string must start with quote character\";\n    // handle quote character at the beginning of the string\n    if (appendTo != null) {\n        appendTo.append(QUOTE);\n    }\n    next(pos);\n    final int start = pos.getIndex();\n    final char[] c = pattern.toCharArray();\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (c[pos.getIndex()] == QUOTE) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(c, start, pos.getIndex() - start);\n        }\n        next(pos);\n    }\n    throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n}", "repo_id": "8", "comment": "/**\n * Consume a quoted string, adding it to {@code appendTo} if\n * specified.\n *\n * @param pattern pattern to parse\n * @param pos current parse position\n * @param appendTo optional StringBuilder to append\n * @return {@code appendTo}\n */\n", "repo_name": "commons-lang-master/", "id": 385, "method_signature": "StringBuilder appendQuotedString(String, ParsePosition, StringBuilder)", "filename": "ExtendedMessageFormat.appendQuotedString.json"}
{"callee_method_names": ["String.length", "String.toCharArray", "ParsePosition.getIndex", "String.length", "ParsePosition.getIndex", "ParsePosition.getIndex", "StringBuilder.append", "ParsePosition.getIndex", "StringBuilder.append", "ArrayList<Format>.add", "ArrayList<String>.add", "ArrayList<Format>.size", "ArrayList<String>.size", "ParsePosition.getIndex", "StringBuilder.append", "ParsePosition.getIndex", "StringBuilder.toString"], "method_name": "ExtendedMessageFormat.applyPattern", "method_implementation": "{\n    if (registry == null) {\n        super.applyPattern(pattern);\n        toPattern = super.toPattern();\n        return;\n    }\n    final ArrayList<Format> foundFormats = new ArrayList<>();\n    final ArrayList<String> foundDescriptions = new ArrayList<>();\n    final StringBuilder stripCustom = new StringBuilder(pattern.length());\n    final ParsePosition pos = new ParsePosition(0);\n    final char[] c = pattern.toCharArray();\n    int fmtCount = 0;\n    while (pos.getIndex() < pattern.length()) {\n        switch(c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                final int start = pos.getIndex();\n                final int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern, next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n                }\n            //$FALL-THROUGH$\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n        }\n    }\n    super.applyPattern(stripCustom.toString());\n    toPattern = insertFormats(super.toPattern(), foundDescriptions);\n    if (containsElements(foundFormats)) {\n        final Format[] origFormats = getFormats();\n        // only loop over what we know we have, as MessageFormat on Java 1.3\n        // seems to provide an extra format element:\n        int i = 0;\n        for (final Format f : foundFormats) {\n            if (f != null) {\n                origFormats[i] = f;\n            }\n            i++;\n        }\n        super.setFormats(origFormats);\n    }\n}", "repo_id": "8", "comment": "/**\n * Apply the specified pattern.\n *\n * @param pattern String\n */\n", "repo_name": "commons-lang-master/", "id": 386, "method_signature": "void applyPattern(String)", "filename": "ExtendedMessageFormat.applyPattern.json"}
{"callee_method_names": ["Collection<?>.isEmpty", "Collection<?>.stream"], "method_name": "ExtendedMessageFormat.containsElements", "method_implementation": "{\n    if (coll == null || coll.isEmpty()) {\n        return false;\n    }\n    return coll.stream().anyMatch(Objects::nonNull);\n}", "repo_id": "8", "comment": "/**\n * Learn whether the specified Collection contains non-null elements.\n * @param coll to check\n * @return {@code true} if some Object was found, {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 387, "method_signature": "boolean containsElements(Collection)", "filename": "ExtendedMessageFormat.containsElements.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "ExtendedMessageFormat.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!super.equals(obj)) {\n        return false;\n    }\n    if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n        return false;\n    }\n    final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;\n    if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n        return false;\n    }\n    return !ObjectUtils.notEqual(registry, rhs.registry);\n}", "repo_id": "8", "comment": "/**\n * Check if this extended message format is equal to another object.\n *\n * @param obj the object to compare to\n * @return true if this object equals the other, otherwise false\n */\n", "repo_name": "commons-lang-master/", "id": 388, "method_signature": "boolean equals(Object)", "filename": "ExtendedMessageFormat.equals.json"}
{"callee_method_names": ["String.indexOf", "String.substring", "String.substring", "Map<String, ? extends FormatFactory>.get", "FormatFactory.getFormat"], "method_name": "ExtendedMessageFormat.getFormat", "method_implementation": "{\n    if (registry != null) {\n        String name = desc;\n        String args = null;\n        final int i = desc.indexOf(START_FMT);\n        if (i > 0) {\n            name = desc.substring(0, i).trim();\n            args = desc.substring(i + 1).trim();\n        }\n        final FormatFactory factory = registry.get(name);\n        if (factory != null) {\n            return factory.getFormat(name, args, getLocale());\n        }\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Gets a custom format from a format description.\n *\n * @param desc String\n * @return Format\n */\n", "repo_name": "commons-lang-master/", "id": 389, "method_signature": "Format getFormat(String)", "filename": "ExtendedMessageFormat.getFormat.json"}
{"callee_method_names": [], "method_name": "ExtendedMessageFormat.hashCode", "method_implementation": "{\n    int result = super.hashCode();\n    result = HASH_SEED * result + Objects.hashCode(registry);\n    result = HASH_SEED * result + Objects.hashCode(toPattern);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 390, "method_signature": "int hashCode()", "filename": "ExtendedMessageFormat.hashCode.json"}
{"callee_method_names": ["String.length", "ParsePosition.getIndex", "String.length", "String.charAt", "ParsePosition.getIndex", "StringBuilder.append", "ArrayList<String>.get", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ExtendedMessageFormat.insertFormats", "method_implementation": "{\n    if (!containsElements(customPatterns)) {\n        return pattern;\n    }\n    final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n    final ParsePosition pos = new ParsePosition(0);\n    int fe = -1;\n    int depth = 0;\n    while (pos.getIndex() < pattern.length()) {\n        final char c = pattern.charAt(pos.getIndex());\n        switch(c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb);\n                break;\n            case START_FE:\n                depth++;\n                sb.append(START_FE).append(readArgumentIndex(pattern, next(pos)));\n                // do not look for custom patterns when they are embedded, e.g. in a choice\n                if (depth == 1) {\n                    fe++;\n                    final String customPattern = customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n            //$FALL-THROUGH$\n            default:\n                sb.append(c);\n                next(pos);\n        }\n    }\n    return sb.toString();\n}", "repo_id": "8", "comment": "/**\n * Insert formats back into the pattern for toPattern() support.\n *\n * @param pattern source\n * @param customPatterns The custom patterns to re-insert, if any\n * @return full pattern\n */\n", "repo_name": "commons-lang-master/", "id": 391, "method_signature": "String insertFormats(String, ArrayList)", "filename": "ExtendedMessageFormat.insertFormats.json"}
{"callee_method_names": ["ParsePosition.getIndex", "ParsePosition.getIndex", "ParsePosition.getIndex", "String.length", "String.charAt", "ParsePosition.getIndex", "String.substring", "ParsePosition.getIndex"], "method_name": "ExtendedMessageFormat.parseFormatDescription", "method_implementation": "{\n    final int start = pos.getIndex();\n    seekNonWs(pattern, pos);\n    final int text = pos.getIndex();\n    int depth = 1;\n    for (; pos.getIndex() < pattern.length(); next(pos)) {\n        switch(pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos);\n                break;\n            default:\n                break;\n        }\n    }\n    throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n}", "repo_id": "8", "comment": "/**\n * Parse the format component of a format element.\n *\n * @param pattern string to parse\n * @param pos current parse position\n * @return Format description String\n */\n", "repo_name": "commons-lang-master/", "id": 392, "method_signature": "String parseFormatDescription(String, ParsePosition)", "filename": "ExtendedMessageFormat.parseFormatDescription.json"}
{"callee_method_names": ["ParsePosition.getIndex", "ParsePosition.getIndex", "String.length", "String.charAt", "ParsePosition.getIndex", "String.charAt", "ParsePosition.getIndex", "StringBuilder.length", "StringBuilder.toString", "StringBuilder.append", "String.substring", "ParsePosition.getIndex"], "method_name": "ExtendedMessageFormat.readArgumentIndex", "method_implementation": "{\n    final int start = pos.getIndex();\n    seekNonWs(pattern, pos);\n    final StringBuilder result = new StringBuilder();\n    boolean error = false;\n    for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n        char c = pattern.charAt(pos.getIndex());\n        if (Character.isWhitespace(c)) {\n            seekNonWs(pattern, pos);\n            c = pattern.charAt(pos.getIndex());\n            if (c != START_FMT && c != END_FE) {\n                error = true;\n                continue;\n            }\n        }\n        if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n            try {\n                return Integer.parseInt(result.toString());\n            } catch (final NumberFormatException ignored) {\n                // we've already ensured only digits, so unless something\n                // outlandishly large was specified we should be okay.\n            }\n        }\n        error = !Character.isDigit(c);\n        result.append(c);\n    }\n    if (error) {\n        throw new IllegalArgumentException(\"Invalid format argument index at position \" + start + \": \" + pattern.substring(start, pos.getIndex()));\n    }\n    throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n}", "repo_id": "8", "comment": "/**\n * Read the argument index from the current format element\n *\n * @param pattern pattern to parse\n * @param pos current parse position\n * @return argument index\n */\n", "repo_name": "commons-lang-master/", "id": 393, "method_signature": "int readArgumentIndex(String, ParsePosition)", "filename": "ExtendedMessageFormat.readArgumentIndex.json"}
{"callee_method_names": ["String.toCharArray", "ParsePosition.getIndex", "ParsePosition.setIndex", "ParsePosition.getIndex", "ParsePosition.getIndex", "String.length"], "method_name": "ExtendedMessageFormat.seekNonWs", "method_implementation": "{\n    int len;\n    final char[] buffer = pattern.toCharArray();\n    do {\n        len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n        pos.setIndex(pos.getIndex() + len);\n    } while (len > 0 && pos.getIndex() < pattern.length());\n}", "repo_id": "8", "comment": "/**\n * Consume whitespace from the current parse position.\n *\n * @param pattern String to read\n * @param pos current position\n */\n", "repo_name": "commons-lang-master/", "id": 394, "method_signature": "void seekNonWs(String, ParsePosition)", "filename": "ExtendedMessageFormat.seekNonWs.json"}
{"callee_method_names": [], "method_name": "ExtendedMessageFormatTest.checkBuiltInFormat", "method_implementation": "{\n    checkBuiltInFormat(pattern, fmtRegistry, args, (Locale) null);\n    for (final Locale locale : locales) {\n        checkBuiltInFormat(pattern, fmtRegistry, args, locale);\n    }\n}", "repo_id": "8", "comment": "/**\n * Test a built-in format for the specified Locales, plus {@code null} Locale.\n * @param pattern MessageFormat pattern\n * @param fmtRegistry FormatFactory registry to use\n * @param args MessageFormat arguments\n * @param locales to test\n */\n", "repo_name": "commons-lang-master/", "id": 1705, "method_signature": "void checkBuiltInFormat(String, Map, Object[], Locale[])", "filename": "ExtendedMessageFormatTest.checkBuiltInFormat.json"}
{"callee_method_names": ["MessageFormat.setLocale", "MessageFormat.applyPattern"], "method_name": "ExtendedMessageFormatTest.createMessageFormat", "method_implementation": "{\n    final MessageFormat result = new MessageFormat(pattern);\n    if (locale != null) {\n        result.setLocale(locale);\n        result.applyPattern(pattern);\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Replace MessageFormat(String, Locale) constructor (not available until JDK 1.4).\n * @param pattern string\n * @param locale Locale\n * @return MessageFormat\n */\n", "repo_name": "commons-lang-master/", "id": 1706, "method_signature": "MessageFormat createMessageFormat(String, Locale)", "filename": "ExtendedMessageFormatTest.createMessageFormat.json"}
{"callee_method_names": [], "method_name": "ExtendedMessageFormatTest.testBuiltInChoiceFormat", "method_implementation": "{\n    final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf(\"2.2\"), Double.valueOf(\"1234.5\") };\n    String choicePattern;\n    final Locale[] availableLocales = NumberFormat.getAvailableLocales();\n    choicePattern = \"{0,choice,1#One|2#Two|3#Many {0,number}}\";\n    for (final Object value : values) {\n        checkBuiltInFormat(value + \": \" + choicePattern, new Object[] { value }, availableLocales);\n    }\n    choicePattern = \"{0,choice,1#''One''|2#\\\"Two\\\"|3#''{Many}'' {0,number}}\";\n    for (final Object value : values) {\n        checkBuiltInFormat(value + \": \" + choicePattern, new Object[] { value }, availableLocales);\n    }\n}", "repo_id": "8", "comment": "/**\n * Test the built-in choice format.\n */\n", "repo_name": "commons-lang-master/", "id": 1707, "method_signature": "void testBuiltInChoiceFormat()", "filename": "ExtendedMessageFormatTest.testBuiltInChoiceFormat.json"}
{"callee_method_names": ["Calendar.set", "Calendar.getTime"], "method_name": "ExtendedMessageFormatTest.testBuiltInDateTimeFormat", "method_implementation": "{\n    final Calendar cal = Calendar.getInstance();\n    cal.set(2007, Calendar.JANUARY, 23, 18, 33, 5);\n    final Object[] args = { cal.getTime() };\n    final Locale[] availableLocales = DateFormat.getAvailableLocales();\n    checkBuiltInFormat(\"1: {0,date,short}\", args, availableLocales);\n    checkBuiltInFormat(\"2: {0,date,medium}\", args, availableLocales);\n    checkBuiltInFormat(\"3: {0,date,long}\", args, availableLocales);\n    checkBuiltInFormat(\"4: {0,date,full}\", args, availableLocales);\n    checkBuiltInFormat(\"5: {0,date,d MMM yy}\", args, availableLocales);\n    checkBuiltInFormat(\"6: {0,time,short}\", args, availableLocales);\n    checkBuiltInFormat(\"7: {0,time,medium}\", args, availableLocales);\n    checkBuiltInFormat(\"8: {0,time,long}\", args, availableLocales);\n    checkBuiltInFormat(\"9: {0,time,full}\", args, availableLocales);\n    checkBuiltInFormat(\"10: {0,time,HH:mm}\", args, availableLocales);\n    checkBuiltInFormat(\"11: {0,date}\", args, availableLocales);\n    checkBuiltInFormat(\"12: {0,time}\", args, availableLocales);\n}", "repo_id": "8", "comment": "/**\n * Test the built-in date/time formats\n */\n", "repo_name": "commons-lang-master/", "id": 1708, "method_signature": "void testBuiltInDateTimeFormat()", "filename": "ExtendedMessageFormatTest.testBuiltInDateTimeFormat.json"}
{"callee_method_names": [], "method_name": "ExtendedMessageFormatTest.testBuiltInNumberFormat", "method_implementation": "{\n    final Object[] args = { Double.valueOf(\"6543.21\") };\n    final Locale[] availableLocales = NumberFormat.getAvailableLocales();\n    checkBuiltInFormat(\"1: {0,number}\", args, availableLocales);\n    checkBuiltInFormat(\"2: {0,number,integer}\", args, availableLocales);\n    checkBuiltInFormat(\"3: {0,number,currency}\", args, availableLocales);\n    checkBuiltInFormat(\"4: {0,number,percent}\", args, availableLocales);\n    checkBuiltInFormat(\"5: {0,number,00000.000}\", args, availableLocales);\n}", "repo_id": "8", "comment": "/**\n * Test the built-in number formats.\n */\n", "repo_name": "commons-lang-master/", "id": 1709, "method_signature": "void testBuiltInNumberFormat()", "filename": "ExtendedMessageFormatTest.testBuiltInNumberFormat.json"}
{"callee_method_names": ["ExtendedMessageFormat.format"], "method_name": "ExtendedMessageFormatTest.testEmbeddedPatternInChoice", "method_implementation": "{\n    final String pattern = \"Hi {0,lower}, got {1,choice,0#none|1#one|1<{1,number}}, {2,upper}!\";\n    final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n    assertEquals(emf.format(new Object[] { \"there\", 3, \"great\" }), \"Hi there, got 3, GREAT!\");\n}", "repo_id": "8", "comment": "/**\n * Test Bug LANG-917 - IndexOutOfBoundsException and/or infinite loop when using a choice pattern\n */\n", "repo_name": "commons-lang-master/", "id": 1710, "method_signature": "void testEmbeddedPatternInChoice()", "filename": "ExtendedMessageFormatTest.testEmbeddedPatternInChoice.json"}
{"callee_method_ids": [390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390], "callee_method_names": ["ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode", "ExtendedMessageFormat.hashCode"], "method_name": "ExtendedMessageFormatTest.testEqualsHashcode", "method_implementation": "{\n    final Map<String, ? extends FormatFactory> fmtRegistry = Collections.singletonMap(\"testfmt\", new LowerCaseFormatFactory());\n    final Map<String, ? extends FormatFactory> otherRegistry = Collections.singletonMap(\"testfmt\", new UpperCaseFormatFactory());\n    final String pattern = \"Pattern: {0,testfmt}\";\n    final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, fmtRegistry);\n    ExtendedMessageFormat other;\n    // Same object\n    assertEquals(emf, emf, \"same, equals()\");\n    assertEquals(emf.hashCode(), emf.hashCode(), \"same, hashCode()\");\n    // Equal Object\n    other = new ExtendedMessageFormat(pattern, Locale.US, fmtRegistry);\n    assertEquals(emf, other, \"equal, equals()\");\n    assertEquals(emf.hashCode(), other.hashCode(), \"equal, hashCode()\");\n    // Different Class\n    other = new OtherExtendedMessageFormat(pattern, Locale.US, fmtRegistry);\n    assertNotEquals(emf, other, \"class, equals()\");\n    // same hash code\n    assertEquals(emf.hashCode(), other.hashCode(), \"class, hashCode()\");\n    // Different pattern\n    other = new ExtendedMessageFormat(\"X\" + pattern, Locale.US, fmtRegistry);\n    assertNotEquals(emf, other, \"pattern, equals()\");\n    assertNotEquals(emf.hashCode(), other.hashCode(), \"pattern, hashCode()\");\n    // Different registry\n    other = new ExtendedMessageFormat(pattern, Locale.US, otherRegistry);\n    assertNotEquals(emf, other, \"registry, equals()\");\n    assertNotEquals(emf.hashCode(), other.hashCode(), \"registry, hashCode()\");\n    // Different Locale\n    other = new ExtendedMessageFormat(pattern, Locale.FRANCE, fmtRegistry);\n    assertNotEquals(emf, other, \"locale, equals()\");\n    // same hash code\n    assertEquals(emf.hashCode(), other.hashCode(), \"locale, hashCode()\");\n}", "repo_id": "8", "comment": "/**\n * Test equals() and hashCode().\n */\n", "repo_name": "commons-lang-master/", "id": 1711, "method_signature": "void testEqualsHashcode()", "filename": "ExtendedMessageFormatTest.testEqualsHashcode.json"}
{"callee_method_names": ["ExtendedMessageFormat.format", "ExtendedMessageFormat.format"], "method_name": "ExtendedMessageFormatTest.testEscapedBraces_LANG_948", "method_implementation": "{\n    // message without placeholder because braces are escaped by quotes\n    final String pattern = \"Message without placeholders '{}'\";\n    final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n    assertEquals(\"Message without placeholders {}\", emf.format(new Object[] { \"DUMMY\" }));\n    // message with placeholder because quotes are escaped by quotes\n    final String pattern2 = \"Message with placeholder ''{0}''\";\n    final ExtendedMessageFormat emf2 = new ExtendedMessageFormat(pattern2, registry);\n    assertEquals(\"Message with placeholder 'DUMMY'\", emf2.format(new Object[] { \"DUMMY\" }));\n}", "repo_id": "8", "comment": "/**\n * Test Bug LANG-948 - Exception while using ExtendedMessageFormat and escaping braces\n */\n", "repo_name": "commons-lang-master/", "id": 1712, "method_signature": "void testEscapedBraces_LANG_948()", "filename": "ExtendedMessageFormatTest.testEscapedBraces_LANG_948.json"}
{"callee_method_names": ["ExtendedMessageFormat.format"], "method_name": "ExtendedMessageFormatTest.testEscapedQuote_LANG_477", "method_implementation": "{\n    final String pattern = \"it''s a {0,lower} 'test'!\";\n    final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n    assertEquals(\"it's a dummy test!\", emf.format(new Object[] { \"DUMMY\" }));\n}", "repo_id": "8", "comment": "/**\n * Test Bug LANG-477 - out of memory error with escaped quote\n */\n", "repo_name": "commons-lang-master/", "id": 1713, "method_signature": "void testEscapedQuote_LANG_477()", "filename": "ExtendedMessageFormatTest.testEscapedQuote_LANG_477.json"}
{"callee_method_names": ["Calendar.set", "Calendar.getTime", "HashSet<Locale>.retainAll", "HashSet<Locale>.add", "MessageFormat.toPattern", "StringBuilder.append", "StringBuilder.append", "Object[].toString", "StringBuilder.append", "StringBuilder.append", "DateFormat.format", "StringBuilder.append", "StringBuilder.append", "NumberFormat.format", "ExtendedMessageFormat.toPattern", "StringBuilder.toString", "ExtendedMessageFormat.format"], "method_name": "ExtendedMessageFormatTest.testExtendedAndBuiltInFormats", "method_implementation": "{\n    final Calendar cal = Calendar.getInstance();\n    cal.set(2007, Calendar.JANUARY, 23, 18, 33, 5);\n    final Object[] args = { \"John Doe\", cal.getTime(), Double.valueOf(\"12345.67\") };\n    final String builtinsPattern = \"DOB: {1,date,short} Salary: {2,number,currency}\";\n    final String extendedPattern = \"Name: {0,upper} \";\n    final String pattern = extendedPattern + builtinsPattern;\n    final HashSet<Locale> testLocales = new HashSet<>(Arrays.asList(DateFormat.getAvailableLocales()));\n    testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales()));\n    testLocales.add(null);\n    for (final Locale locale : testLocales) {\n        final MessageFormat builtins = createMessageFormat(builtinsPattern, locale);\n        final String expectedPattern = extendedPattern + builtins.toPattern();\n        DateFormat df = null;\n        NumberFormat nf = null;\n        ExtendedMessageFormat emf = null;\n        if (locale == null) {\n            df = DateFormat.getDateInstance(DateFormat.SHORT);\n            nf = NumberFormat.getCurrencyInstance();\n            emf = new ExtendedMessageFormat(pattern, registry);\n        } else {\n            df = DateFormat.getDateInstance(DateFormat.SHORT, locale);\n            nf = NumberFormat.getCurrencyInstance(locale);\n            emf = new ExtendedMessageFormat(pattern, locale, registry);\n        }\n        final StringBuilder expected = new StringBuilder();\n        expected.append(\"Name: \");\n        expected.append(args[0].toString().toUpperCase(Locale.ROOT));\n        expected.append(\" DOB: \");\n        expected.append(df.format(args[1]));\n        expected.append(\" Salary: \");\n        expected.append(nf.format(args[2]));\n        assertEquals(expectedPattern, emf.toPattern(), \"pattern comparison for locale \" + locale);\n        assertEquals(expected.toString(), emf.format(args), String.valueOf(locale));\n    }\n}", "repo_id": "8", "comment": "/**\n * Test extended and built in formats.\n */\n", "repo_name": "commons-lang-master/", "id": 1714, "method_signature": "void testExtendedAndBuiltInFormats()", "filename": "ExtendedMessageFormatTest.testExtendedAndBuiltInFormats.json"}
{"callee_method_names": ["ExtendedMessageFormat.toPattern", "ExtendedMessageFormat.format", "ExtendedMessageFormat.format", "ExtendedMessageFormat.format", "ExtendedMessageFormat.format", "ExtendedMessageFormat.format"], "method_name": "ExtendedMessageFormatTest.testExtendedFormats", "method_implementation": "{\n    final String pattern = \"Lower: {0,lower} Upper: {1,upper}\";\n    final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n    assertEquals(pattern, emf.toPattern(), \"TOPATTERN\");\n    assertEquals(emf.format(new Object[] { \"foo\", \"bar\" }), \"Lower: foo Upper: BAR\");\n    assertEquals(emf.format(new Object[] { \"Foo\", \"Bar\" }), \"Lower: foo Upper: BAR\");\n    assertEquals(emf.format(new Object[] { \"FOO\", \"BAR\" }), \"Lower: foo Upper: BAR\");\n    assertEquals(emf.format(new Object[] { \"FOO\", \"bar\" }), \"Lower: foo Upper: BAR\");\n    assertEquals(emf.format(new Object[] { \"foo\", \"BAR\" }), \"Lower: foo Upper: BAR\");\n}", "repo_id": "8", "comment": "/**\n * Test extended formats.\n */\n", "repo_name": "commons-lang-master/", "id": 1715, "method_signature": "void testExtendedFormats()", "filename": "ExtendedMessageFormatTest.testExtendedFormats.json"}
{"callee_method_names": ["FailableSupplier<T,E>.get"], "method_name": "Failable.get", "method_implementation": "{\n    try {\n        return supplier.get();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes a supplier, and returns the result.\n *\n * @param supplier The supplier to invoke.\n * @param <T> The suppliers output type.\n * @param <E> The type of checked exception, which the supplier can throw.\n * @return The object, which has been created by the supplier\n */\n", "repo_name": "commons-lang-master/", "id": 163, "method_signature": "T get(FailableSupplier)", "filename": "Failable.get.json"}
{"callee_method_names": ["FailableBooleanSupplier<E>.getAsBoolean"], "method_name": "Failable.getAsBoolean", "method_implementation": "{\n    try {\n        return supplier.getAsBoolean();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes a boolean supplier, and returns the result.\n *\n * @param supplier The boolean supplier to invoke.\n * @param <E> The type of checked exception, which the supplier can throw.\n * @return The boolean, which has been created by the supplier\n */\n", "repo_name": "commons-lang-master/", "id": 164, "method_signature": "boolean getAsBoolean(FailableBooleanSupplier)", "filename": "Failable.getAsBoolean.json"}
{"callee_method_names": ["FailableDoubleSupplier<E>.getAsDouble"], "method_name": "Failable.getAsDouble", "method_implementation": "{\n    try {\n        return supplier.getAsDouble();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes a double supplier, and returns the result.\n *\n * @param supplier The double supplier to invoke.\n * @param <E> The type of checked exception, which the supplier can throw.\n * @return The double, which has been created by the supplier\n */\n", "repo_name": "commons-lang-master/", "id": 165, "method_signature": "double getAsDouble(FailableDoubleSupplier)", "filename": "Failable.getAsDouble.json"}
{"callee_method_names": ["FailableIntSupplier<E>.getAsInt"], "method_name": "Failable.getAsInt", "method_implementation": "{\n    try {\n        return supplier.getAsInt();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes an int supplier, and returns the result.\n *\n * @param supplier The int supplier to invoke.\n * @param <E> The type of checked exception, which the supplier can throw.\n * @return The int, which has been created by the supplier\n */\n", "repo_name": "commons-lang-master/", "id": 166, "method_signature": "int getAsInt(FailableIntSupplier)", "filename": "Failable.getAsInt.json"}
{"callee_method_names": ["FailableLongSupplier<E>.getAsLong"], "method_name": "Failable.getAsLong", "method_implementation": "{\n    try {\n        return supplier.getAsLong();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes a long supplier, and returns the result.\n *\n * @param supplier The long supplier to invoke.\n * @param <E> The type of checked exception, which the supplier can throw.\n * @return The long, which has been created by the supplier\n */\n", "repo_name": "commons-lang-master/", "id": 167, "method_signature": "long getAsLong(FailableLongSupplier)", "filename": "Failable.getAsLong.json"}
{"callee_method_names": ["FailableShortSupplier<E>.getAsShort"], "method_name": "Failable.getAsShort", "method_implementation": "{\n    try {\n        return supplier.getAsShort();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes a short supplier, and returns the result.\n *\n * @param supplier The short supplier to invoke.\n * @param <E> The type of checked exception, which the supplier can throw.\n * @return The short, which has been created by the supplier\n */\n", "repo_name": "commons-lang-master/", "id": 168, "method_signature": "short getAsShort(FailableShortSupplier)", "filename": "Failable.getAsShort.json"}
{"callee_method_names": [], "method_name": "Failable.rethrow", "method_implementation": "{\n    Objects.requireNonNull(throwable, \"throwable\");\n    ExceptionUtils.throwUnchecked(throwable);\n    if (throwable instanceof IOException) {\n        throw new UncheckedIOException((IOException) throwable);\n    }\n    throw new UndeclaredThrowableException(throwable);\n}", "repo_id": "8", "comment": "/**\n * Rethrows a {@link Throwable} as an unchecked exception. If the argument is already unchecked, namely a\n * {@link RuntimeException} or {@link Error} then the argument will be rethrown without modification. If the\n * exception is {@link IOException} then it will be wrapped into a {@link UncheckedIOException}. In every other\n * cases the exception will be wrapped into a {@code\n * UndeclaredThrowableException}\n *\n * <p>\n * Note that there is a declared return type for this method, even though it never returns. The reason for that is\n * to support the usual pattern:\n * </p>\n *\n * <pre>\n * throw rethrow(myUncheckedException);\n * </pre>\n *\n * <p>\n * instead of just calling the method. This pattern may help the Java compiler to recognize that at that point an\n * exception will be thrown and the code flow analysis will not demand otherwise mandatory commands that could\n * follow the method call, like a {@code return} statement from a value returning method.\n * </p>\n *\n * @param throwable The throwable to rethrow possibly wrapped into an unchecked exception\n * @return Never returns anything, this method never terminates normally.\n */\n", "repo_name": "commons-lang-master/", "id": 169, "method_signature": "RuntimeException rethrow(Throwable)", "filename": "Failable.rethrow.json"}
{"callee_method_names": ["FailableRunnable<E>.run"], "method_name": "Failable.run", "method_implementation": "{\n    try {\n        runnable.run();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Runs a runnable and rethrows any exception as a {@link RuntimeException}.\n *\n * @param runnable The runnable to run\n * @param <E> the type of checked exception the runnable may throw\n */\n", "repo_name": "commons-lang-master/", "id": 170, "method_signature": "void run(FailableRunnable)", "filename": "Failable.run.json"}
{"callee_method_names": [], "method_name": "Failable.tryWithResources", "method_implementation": "{\n    tryWithResources(action, null, resources);\n}", "repo_id": "8", "comment": "/**\n * A simple try-with-resources implementation, that can be used, if your objects do not implement the\n * {@link AutoCloseable} interface. The method executes the {@code action}. The method guarantees, that <em>all</em>\n * the {@code resources} are being executed, in the given order, afterwards, and regardless of success, or failure.\n * If either the original action, or any of the resource action fails, then the <em>first</em> failure (AKA\n * {@link Throwable}) is rethrown. Example use:\n *\n * <pre>\n * final FileInputStream fis = new FileInputStream(\"my.file\");\n * Functions.tryWithResources(useInputStream(fis), () -&gt; fis.close());\n * </pre>\n *\n * @param action The action to execute. This object <em>will</em> always be invoked.\n * @param resources The resource actions to execute. <em>All</em> resource actions will be invoked, in the given\n *        order. A resource action is an instance of {@link FailableRunnable}, which will be executed.\n * @see #tryWithResources(FailableRunnable, FailableConsumer, FailableRunnable...)\n */\n", "repo_name": "commons-lang-master/", "id": 172, "method_signature": "void tryWithResources(FailableRunnable, FailableRunnable<? extends Throwable>[])", "filename": "Failable.tryWithResources.json"}
{"callee_method_names": ["FailableBiConsumer<? super T,? super U,E>.accept"], "method_name": "FailableBiConsumer.andThen", "method_implementation": "{\n    Objects.requireNonNull(after);\n    return (t, u) -> {\n        accept(t, u);\n        after.accept(t, u);\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns a composed {@link FailableBiConsumer} like {@link BiConsumer#andThen(BiConsumer)}.\n *\n * @param after the operation to perform after this one.\n * @return a composed {@link FailableBiConsumer} like {@link BiConsumer#andThen(BiConsumer)}.\n * @throws NullPointerException when {@code after} is null.\n */\n", "repo_name": "commons-lang-master/", "id": 158, "method_signature": "FailableBiConsumer<T,U,E> andThen(FailableBiConsumer)", "filename": "FailableBiConsumer.andThen.json"}
{"callee_method_names": ["FailableConsumer<? super T,E>.accept"], "method_name": "FailableConsumer.andThen", "method_implementation": "{\n    Objects.requireNonNull(after);\n    return (final T t) -> {\n        accept(t);\n        after.accept(t);\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns a composed {@link Consumer} like {@link Consumer#andThen(Consumer)}.\n *\n * @param after the operation to perform after this operation\n * @return a composed {@link Consumer} like {@link Consumer#andThen(Consumer)}.\n * @throws NullPointerException when {@code after} is null\n */\n", "repo_name": "commons-lang-master/", "id": 159, "method_signature": "FailableConsumer<T,E> andThen(FailableConsumer)", "filename": "FailableConsumer.andThen.json"}
{"callee_method_names": ["FailableDoubleConsumer<E>.accept"], "method_name": "FailableDoubleConsumer.andThen", "method_implementation": "{\n    Objects.requireNonNull(after);\n    return (final double t) -> {\n        accept(t);\n        after.accept(t);\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns a composed {@link FailableDoubleConsumer} like {@link DoubleConsumer#andThen(DoubleConsumer)}.\n *\n * @param after the operation to perform after this one.\n * @return a composed {@link FailableDoubleConsumer} like {@link DoubleConsumer#andThen(DoubleConsumer)}.\n * @throws NullPointerException when {@code after} is null.\n */\n", "repo_name": "commons-lang-master/", "id": 160, "method_signature": "FailableDoubleConsumer<E> andThen(FailableDoubleConsumer)", "filename": "FailableDoubleConsumer.andThen.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBiConsumer_Object_Throwable", "method_implementation": "{\n    new FailableBiConsumer<Object, Object, Throwable>() {\n\n        @Override\n        public void accept(final Object object1, final Object object2) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1589, "method_signature": "void testThrows_FailableBiConsumer_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableBiConsumer_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBiConsumer_String_IOException", "method_implementation": "{\n    new FailableBiConsumer<String, String, IOException>() {\n\n        @Override\n        public void accept(final String object1, final String object2) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1590, "method_signature": "void testThrows_FailableBiConsumer_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableBiConsumer_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBiFunction_Object_Throwable", "method_implementation": "{\n    new FailableBiFunction<Object, Object, Object, Throwable>() {\n\n        @Override\n        public Object apply(final Object input1, final Object input2) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1591, "method_signature": "void testThrows_FailableBiFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableBiFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBiFunction_String_IOException", "method_implementation": "{\n    new FailableBiFunction<String, String, String, IOException>() {\n\n        @Override\n        public String apply(final String input1, final String input2) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1592, "method_signature": "void testThrows_FailableBiFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableBiFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBiPredicate_Object_Throwable", "method_implementation": "{\n    new FailableBiPredicate<Object, Object, Throwable>() {\n\n        @Override\n        public boolean test(final Object object1, final Object object2) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1593, "method_signature": "void testThrows_FailableBiPredicate_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableBiPredicate_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBiPredicate_String_IOException", "method_implementation": "{\n    new FailableBiPredicate<String, String, IOException>() {\n\n        @Override\n        public boolean test(final String object1, final String object2) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1594, "method_signature": "void testThrows_FailableBiPredicate_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableBiPredicate_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBooleanSupplier_IOException", "method_implementation": "{\n    new FailableBooleanSupplier<IOException>() {\n\n        @Override\n        public boolean getAsBoolean() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1595, "method_signature": "void testThrows_FailableBooleanSupplier_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableBooleanSupplier_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableBooleanSupplier_Throwable", "method_implementation": "{\n    new FailableBooleanSupplier<Throwable>() {\n\n        @Override\n        public boolean getAsBoolean() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1596, "method_signature": "void testThrows_FailableBooleanSupplier_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableBooleanSupplier_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableCallable_Object_Throwable", "method_implementation": "{\n    new FailableCallable<Object, Throwable>() {\n\n        @Override\n        public Object call() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1597, "method_signature": "void testThrows_FailableCallable_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableCallable_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableCallable_String_IOException", "method_implementation": "{\n    new FailableCallable<String, IOException>() {\n\n        @Override\n        public String call() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1598, "method_signature": "void testThrows_FailableCallable_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableCallable_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableConsumer_Object_Throwable", "method_implementation": "{\n    new FailableConsumer<Object, Throwable>() {\n\n        @Override\n        public void accept(final Object object) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1599, "method_signature": "void testThrows_FailableConsumer_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableConsumer_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableConsumer_String_IOException", "method_implementation": "{\n    new FailableConsumer<String, IOException>() {\n\n        @Override\n        public void accept(final String object) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1600, "method_signature": "void testThrows_FailableConsumer_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableConsumer_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleBinaryOperator_IOException", "method_implementation": "{\n    new FailableDoubleBinaryOperator<IOException>() {\n\n        @Override\n        public double applyAsDouble(final double left, final double right) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1601, "method_signature": "void testThrows_FailableDoubleBinaryOperator_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleBinaryOperator_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleBinaryOperator_Throwable", "method_implementation": "{\n    new FailableDoubleBinaryOperator<Throwable>() {\n\n        @Override\n        public double applyAsDouble(final double left, final double right) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1602, "method_signature": "void testThrows_FailableDoubleBinaryOperator_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleBinaryOperator_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleConsumer_IOException", "method_implementation": "{\n    new FailableDoubleConsumer<IOException>() {\n\n        @Override\n        public void accept(final double value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1603, "method_signature": "void testThrows_FailableDoubleConsumer_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleConsumer_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleConsumer_Throwable", "method_implementation": "{\n    new FailableDoubleConsumer<Throwable>() {\n\n        @Override\n        public void accept(final double value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1604, "method_signature": "void testThrows_FailableDoubleConsumer_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleConsumer_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleFunction_IOException", "method_implementation": "{\n    new FailableDoubleFunction<String, IOException>() {\n\n        @Override\n        public String apply(final double input) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1605, "method_signature": "void testThrows_FailableDoubleFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleFunction_Throwable", "method_implementation": "{\n    new FailableDoubleFunction<Object, Throwable>() {\n\n        @Override\n        public Object apply(final double input) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1606, "method_signature": "void testThrows_FailableDoubleFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleSupplier_IOException", "method_implementation": "{\n    new FailableDoubleSupplier<IOException>() {\n\n        @Override\n        public double getAsDouble() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1607, "method_signature": "void testThrows_FailableDoubleSupplier_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleSupplier_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleSupplier_Throwable", "method_implementation": "{\n    new FailableDoubleSupplier<Throwable>() {\n\n        @Override\n        public double getAsDouble() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1608, "method_signature": "void testThrows_FailableDoubleSupplier_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleSupplier_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleToIntFunction_IOException", "method_implementation": "{\n    new FailableDoubleToIntFunction<IOException>() {\n\n        @Override\n        public int applyAsInt(final double value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1609, "method_signature": "void testThrows_FailableDoubleToIntFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleToIntFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleToIntFunction_Throwable", "method_implementation": "{\n    new FailableDoubleToIntFunction<Throwable>() {\n\n        @Override\n        public int applyAsInt(final double value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1610, "method_signature": "void testThrows_FailableDoubleToIntFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleToIntFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleToLongFunction_IOException", "method_implementation": "{\n    new FailableDoubleToLongFunction<IOException>() {\n\n        @Override\n        public int applyAsLong(final double value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1611, "method_signature": "void testThrows_FailableDoubleToLongFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleToLongFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableDoubleToLongFunction_Throwable", "method_implementation": "{\n    new FailableDoubleToLongFunction<Throwable>() {\n\n        @Override\n        public int applyAsLong(final double value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1612, "method_signature": "void testThrows_FailableDoubleToLongFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableDoubleToLongFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableFunction_Object_Throwable", "method_implementation": "{\n    new FailableFunction<Object, Object, Throwable>() {\n\n        @Override\n        public Object apply(final Object input) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1613, "method_signature": "void testThrows_FailableFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableFunction_String_IOException", "method_implementation": "{\n    new FailableFunction<String, String, IOException>() {\n\n        @Override\n        public String apply(final String input) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1614, "method_signature": "void testThrows_FailableFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntBinaryOperator_IOException", "method_implementation": "{\n    new FailableIntBinaryOperator<IOException>() {\n\n        @Override\n        public int applyAsInt(final int left, final int right) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1615, "method_signature": "void testThrows_FailableIntBinaryOperator_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableIntBinaryOperator_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntBinaryOperator_Throwable", "method_implementation": "{\n    new FailableIntBinaryOperator<Throwable>() {\n\n        @Override\n        public int applyAsInt(final int left, final int right) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1616, "method_signature": "void testThrows_FailableIntBinaryOperator_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableIntBinaryOperator_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntConsumer_IOException", "method_implementation": "{\n    new FailableIntConsumer<IOException>() {\n\n        @Override\n        public void accept(final int value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1617, "method_signature": "void testThrows_FailableIntConsumer_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableIntConsumer_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntConsumer_Throwable", "method_implementation": "{\n    new FailableIntConsumer<Throwable>() {\n\n        @Override\n        public void accept(final int value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1618, "method_signature": "void testThrows_FailableIntConsumer_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableIntConsumer_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntFunction_Object_Throwable", "method_implementation": "{\n    new FailableIntFunction<Object, Throwable>() {\n\n        @Override\n        public Object apply(final int input) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1619, "method_signature": "void testThrows_FailableIntFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableIntFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntFunction_String_IOException", "method_implementation": "{\n    new FailableIntFunction<String, IOException>() {\n\n        @Override\n        public String apply(final int input) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1620, "method_signature": "void testThrows_FailableIntFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableIntFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntSupplier_IOException", "method_implementation": "{\n    new FailableIntSupplier<IOException>() {\n\n        @Override\n        public int getAsInt() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1621, "method_signature": "void testThrows_FailableIntSupplier_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableIntSupplier_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntSupplier_Throwable", "method_implementation": "{\n    new FailableIntSupplier<Throwable>() {\n\n        @Override\n        public int getAsInt() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1622, "method_signature": "void testThrows_FailableIntSupplier_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableIntSupplier_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntToDoubleFunction_IOException", "method_implementation": "{\n    new FailableIntToDoubleFunction<IOException>() {\n\n        @Override\n        public double applyAsDouble(final int value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1623, "method_signature": "void testThrows_FailableIntToDoubleFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableIntToDoubleFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntToDoubleFunction_Throwable", "method_implementation": "{\n    new FailableIntToDoubleFunction<Throwable>() {\n\n        @Override\n        public double applyAsDouble(final int value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1624, "method_signature": "void testThrows_FailableIntToDoubleFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableIntToDoubleFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntToLongFunction_IOException", "method_implementation": "{\n    new FailableIntToLongFunction<IOException>() {\n\n        @Override\n        public long applyAsLong(final int value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1625, "method_signature": "void testThrows_FailableIntToLongFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableIntToLongFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableIntToLongFunction_Throwable", "method_implementation": "{\n    new FailableIntToLongFunction<Throwable>() {\n\n        @Override\n        public long applyAsLong(final int value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1626, "method_signature": "void testThrows_FailableIntToLongFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableIntToLongFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongBinaryOperator_IOException", "method_implementation": "{\n    new FailableLongBinaryOperator<IOException>() {\n\n        @Override\n        public long applyAsLong(final long left, final long right) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1627, "method_signature": "void testThrows_FailableLongBinaryOperator_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableLongBinaryOperator_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongBinaryOperator_Throwable", "method_implementation": "{\n    new FailableLongBinaryOperator<Throwable>() {\n\n        @Override\n        public long applyAsLong(final long left, final long right) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1628, "method_signature": "void testThrows_FailableLongBinaryOperator_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableLongBinaryOperator_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongConsumer_IOException", "method_implementation": "{\n    new FailableLongConsumer<IOException>() {\n\n        @Override\n        public void accept(final long object) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1629, "method_signature": "void testThrows_FailableLongConsumer_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableLongConsumer_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongConsumer_Throwable", "method_implementation": "{\n    new FailableLongConsumer<Throwable>() {\n\n        @Override\n        public void accept(final long object) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1630, "method_signature": "void testThrows_FailableLongConsumer_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableLongConsumer_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongFunction_IOException", "method_implementation": "{\n    new FailableLongFunction<String, IOException>() {\n\n        @Override\n        public String apply(final long input) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1631, "method_signature": "void testThrows_FailableLongFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableLongFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongFunction_Throwable", "method_implementation": "{\n    new FailableLongFunction<Object, Throwable>() {\n\n        @Override\n        public Object apply(final long input) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1632, "method_signature": "void testThrows_FailableLongFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableLongFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongSupplier_IOException", "method_implementation": "{\n    new FailableLongSupplier<IOException>() {\n\n        @Override\n        public long getAsLong() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1633, "method_signature": "void testThrows_FailableLongSupplier_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableLongSupplier_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongSupplier_Throwable", "method_implementation": "{\n    new FailableLongSupplier<Throwable>() {\n\n        @Override\n        public long getAsLong() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1634, "method_signature": "void testThrows_FailableLongSupplier_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableLongSupplier_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongToDoubleFunction_IOException", "method_implementation": "{\n    new FailableLongToDoubleFunction<IOException>() {\n\n        @Override\n        public double applyAsDouble(final long value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1635, "method_signature": "void testThrows_FailableLongToDoubleFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableLongToDoubleFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongToDoubleFunction_Throwable", "method_implementation": "{\n    new FailableLongToDoubleFunction<Throwable>() {\n\n        @Override\n        public double applyAsDouble(final long value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1636, "method_signature": "void testThrows_FailableLongToDoubleFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableLongToDoubleFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongToIntFunction_IOException", "method_implementation": "{\n    new FailableLongToIntFunction<IOException>() {\n\n        @Override\n        public int applyAsInt(final long value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1637, "method_signature": "void testThrows_FailableLongToIntFunction_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableLongToIntFunction_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableLongToIntFunction_Throwable", "method_implementation": "{\n    new FailableLongToIntFunction<Throwable>() {\n\n        @Override\n        public int applyAsInt(final long value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1638, "method_signature": "void testThrows_FailableLongToIntFunction_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableLongToIntFunction_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableObjDoubleConsumer_Object_Throwable", "method_implementation": "{\n    new FailableObjDoubleConsumer<Object, Throwable>() {\n\n        @Override\n        public void accept(final Object object, final double value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1639, "method_signature": "void testThrows_FailableObjDoubleConsumer_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableObjDoubleConsumer_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableObjDoubleConsumer_String_IOException", "method_implementation": "{\n    new FailableObjDoubleConsumer<String, IOException>() {\n\n        @Override\n        public void accept(final String object, final double value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1640, "method_signature": "void testThrows_FailableObjDoubleConsumer_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableObjDoubleConsumer_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableObjIntConsumer_Object_Throwable", "method_implementation": "{\n    new FailableObjIntConsumer<Object, Throwable>() {\n\n        @Override\n        public void accept(final Object object, final int value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1641, "method_signature": "void testThrows_FailableObjIntConsumer_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableObjIntConsumer_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableObjIntConsumer_String_IOException", "method_implementation": "{\n    new FailableObjIntConsumer<String, IOException>() {\n\n        @Override\n        public void accept(final String object, final int value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1642, "method_signature": "void testThrows_FailableObjIntConsumer_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableObjIntConsumer_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableObjLongConsumer_Object_Throwable", "method_implementation": "{\n    new FailableObjLongConsumer<Object, Throwable>() {\n\n        @Override\n        public void accept(final Object object, final long value) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1643, "method_signature": "void testThrows_FailableObjLongConsumer_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableObjLongConsumer_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableObjLongConsumer_String_IOException", "method_implementation": "{\n    new FailableObjLongConsumer<String, IOException>() {\n\n        @Override\n        public void accept(final String object, final long value) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1644, "method_signature": "void testThrows_FailableObjLongConsumer_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableObjLongConsumer_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailablePredicate_Object_Throwable", "method_implementation": "{\n    new FailablePredicate<Object, Throwable>() {\n\n        @Override\n        public boolean test(final Object object) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1645, "method_signature": "void testThrows_FailablePredicate_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailablePredicate_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailablePredicate_String_IOException", "method_implementation": "{\n    new FailablePredicate<String, IOException>() {\n\n        @Override\n        public boolean test(final String object) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1646, "method_signature": "void testThrows_FailablePredicate_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailablePredicate_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableRunnable_IOException", "method_implementation": "{\n    new FailableRunnable<IOException>() {\n\n        @Override\n        public void run() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1647, "method_signature": "void testThrows_FailableRunnable_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableRunnable_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableRunnable_Throwable", "method_implementation": "{\n    new FailableRunnable<Throwable>() {\n\n        @Override\n        public void run() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1648, "method_signature": "void testThrows_FailableRunnable_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableRunnable_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableShortSupplier_IOException", "method_implementation": "{\n    new FailableShortSupplier<IOException>() {\n\n        @Override\n        public short getAsShort() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1649, "method_signature": "void testThrows_FailableShortSupplier_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableShortSupplier_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableShortSupplier_Throwable", "method_implementation": "{\n    new FailableShortSupplier<Throwable>() {\n\n        @Override\n        public short getAsShort() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1650, "method_signature": "void testThrows_FailableShortSupplier_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableShortSupplier_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableSupplier_Object_Throwable", "method_implementation": "{\n    new FailableSupplier<Object, Throwable>() {\n\n        @Override\n        public Object get() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1651, "method_signature": "void testThrows_FailableSupplier_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableSupplier_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableSupplier_String_IOException", "method_implementation": "{\n    new FailableSupplier<String, IOException>() {\n\n        @Override\n        public String get() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1652, "method_signature": "void testThrows_FailableSupplier_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableSupplier_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToDoubleBiFunction_Object_Throwable", "method_implementation": "{\n    new FailableToDoubleBiFunction<Object, Object, Throwable>() {\n\n        @Override\n        public double applyAsDouble(final Object t, final Object u) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1653, "method_signature": "void testThrows_FailableToDoubleBiFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableToDoubleBiFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToDoubleBiFunction_String_IOException", "method_implementation": "{\n    new FailableToDoubleBiFunction<String, String, IOException>() {\n\n        @Override\n        public double applyAsDouble(final String t, final String u) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1654, "method_signature": "void testThrows_FailableToDoubleBiFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableToDoubleBiFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToDoubleFunction_Object_Throwable", "method_implementation": "{\n    new FailableToDoubleFunction<Object, Throwable>() {\n\n        @Override\n        public double applyAsDouble(final Object t) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1655, "method_signature": "void testThrows_FailableToDoubleFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableToDoubleFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToDoubleFunction_String_IOException", "method_implementation": "{\n    new FailableToDoubleFunction<String, IOException>() {\n\n        @Override\n        public double applyAsDouble(final String t) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1656, "method_signature": "void testThrows_FailableToDoubleFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableToDoubleFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToIntBiFunction_Object_Throwable", "method_implementation": "{\n    new FailableToIntBiFunction<Object, Object, Throwable>() {\n\n        @Override\n        public int applyAsInt(final Object t, final Object u) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1657, "method_signature": "void testThrows_FailableToIntBiFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableToIntBiFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToIntBiFunction_String_IOException", "method_implementation": "{\n    new FailableToIntBiFunction<String, String, IOException>() {\n\n        @Override\n        public int applyAsInt(final String t, final String u) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1658, "method_signature": "void testThrows_FailableToIntBiFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableToIntBiFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToIntFunction_Object_Throwable", "method_implementation": "{\n    new FailableToIntFunction<Object, Throwable>() {\n\n        @Override\n        public int applyAsInt(final Object t) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1659, "method_signature": "void testThrows_FailableToIntFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableToIntFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToIntFunction_String_IOException", "method_implementation": "{\n    new FailableToIntFunction<String, IOException>() {\n\n        @Override\n        public int applyAsInt(final String t) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1660, "method_signature": "void testThrows_FailableToIntFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableToIntFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToLongBiFunction_Object_Throwable", "method_implementation": "{\n    new FailableToLongBiFunction<Object, Object, Throwable>() {\n\n        @Override\n        public long applyAsLong(final Object t, final Object u) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1661, "method_signature": "void testThrows_FailableToLongBiFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableToLongBiFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToLongBiFunction_String_IOException", "method_implementation": "{\n    new FailableToLongBiFunction<String, String, IOException>() {\n\n        @Override\n        public long applyAsLong(final String t, final String u) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1662, "method_signature": "void testThrows_FailableToLongBiFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableToLongBiFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToLongFunction_Object_Throwable", "method_implementation": "{\n    new FailableToLongFunction<Object, Throwable>() {\n\n        @Override\n        public long applyAsLong(final Object t) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1663, "method_signature": "void testThrows_FailableToLongFunction_Object_Throwable()", "filename": "FailableFunctionsTest.testThrows_FailableToLongFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FailableFunctionsTest.testThrows_FailableToLongFunction_String_IOException", "method_implementation": "{\n    new FailableToLongFunction<String, IOException>() {\n\n        @Override\n        public long applyAsLong(final String t) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1664, "method_signature": "void testThrows_FailableToLongFunction_String_IOException()", "filename": "FailableFunctionsTest.testThrows_FailableToLongFunction_String_IOException.json"}
{"callee_method_names": ["FailableIntConsumer<E>.accept"], "method_name": "FailableIntConsumer.andThen", "method_implementation": "{\n    Objects.requireNonNull(after);\n    return (final int t) -> {\n        accept(t);\n        after.accept(t);\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns a composed {@link FailableIntConsumer} like {@link IntConsumer#andThen(IntConsumer)}.\n *\n * @param after the operation to perform after this one.\n * @return a composed {@link FailableLongConsumer} like {@link IntConsumer#andThen(IntConsumer)}.\n * @throws NullPointerException if {@code after} is null\n */\n", "repo_name": "commons-lang-master/", "id": 157, "method_signature": "FailableIntConsumer<E> andThen(FailableIntConsumer)", "filename": "FailableIntConsumer.andThen.json"}
{"callee_method_names": ["FailableLongConsumer<E>.accept"], "method_name": "FailableLongConsumer.andThen", "method_implementation": "{\n    Objects.requireNonNull(after);\n    return (final long t) -> {\n        accept(t);\n        after.accept(t);\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns a composed {@link FailableLongConsumer} like {@link LongConsumer#andThen(LongConsumer)}.\n *\n * @param after the operation to perform after this one.\n * @return a composed {@link FailableLongConsumer} like {@link LongConsumer#andThen(LongConsumer)}.\n * @throws NullPointerException if {@code after} is null\n */\n", "repo_name": "commons-lang-master/", "id": 161, "method_signature": "FailableLongConsumer<E> andThen(FailableLongConsumer)", "filename": "FailableLongConsumer.andThen.json"}
{"callee_method_names": [], "method_name": "FailableStream.assertNotTerminated", "method_implementation": "{\n    if (terminated) {\n        throw new IllegalStateException(\"This stream is already terminated.\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Throws IllegalStateException if this stream is already terminated.\n *\n * @throws IllegalStateException if this stream is already terminated.\n */\n", "repo_name": "commons-lang-master/", "id": 978, "method_signature": "void assertNotTerminated()", "filename": "FailableStream.assertNotTerminated.json"}
{"callee_method_names": ["Stream<O>.filter"], "method_name": "FailableStream.filter", "method_implementation": "{\n    assertNotTerminated();\n    stream = stream.filter(Functions.asPredicate(predicate));\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Returns a FailableStream consisting of the elements of this stream that match\n * the given FailablePredicate.\n *\n * <p>\n * This is an intermediate operation.\n * </p>\n *\n * @param predicate a non-interfering, stateless predicate to apply to each\n * element to determine if it should be included.\n * @return the new stream\n */\n", "repo_name": "commons-lang-master/", "id": 979, "method_signature": "FailableStream<O> filter(FailablePredicate)", "filename": "FailableStream.filter.json"}
{"callee_method_ids": [658], "callee_method_names": ["FastDatePrinter.equals"], "method_name": "FastDateFormat.equals", "method_implementation": "{\n    if (!(obj instanceof FastDateFormat)) {\n        return false;\n    }\n    final FastDateFormat other = (FastDateFormat) obj;\n    // no need to check parser, as it has same invariants as printer\n    return printer.equals(other.printer);\n}", "repo_id": "8", "comment": "/**\n * Compares two objects for equality.\n *\n * @param obj  the object to compare to\n * @return {@code true} if equal\n */\n", "repo_name": "commons-lang-master/", "id": 602, "method_signature": "boolean equals(Object)", "filename": "FastDateFormat.equals.json"}
{"callee_method_ids": [668], "callee_method_names": ["FastDatePrinter.format"], "method_name": "FastDateFormat.format", "method_implementation": "{\n    return printer.format(millis, buf);\n}", "repo_id": "8", "comment": "/**\n * Formats a millisecond {@code long} value into the\n * supplied {@link StringBuffer}.\n *\n * @param millis  the millisecond value to format\n * @param buf  the buffer to format into\n * @return the specified string buffer\n * @since 2.1\n * @deprecated Use {{@link #format(long, Appendable)}.\n */\n", "repo_name": "commons-lang-master/", "id": 605, "method_signature": "StringBuffer format(long, StringBuffer)", "filename": "FastDateFormat.format.json"}
{"callee_method_names": [], "method_name": "FastDateFormatTest.testLANG_954", "method_implementation": "{\n    final String pattern = \"yyyy-MM-dd'T'\";\n    FastDateFormat.getInstance(pattern);\n}", "repo_id": "8", "comment": "/**\n * According to LANG-954 (https://issues.apache.org/jira/browse/LANG-954) this is broken in Android 2.1.\n */\n", "repo_name": "commons-lang-master/", "id": 1819, "method_signature": "void testLANG_954()", "filename": "FastDateFormatTest.testLANG_954.json"}
{"callee_method_names": [], "method_name": "FastDateFormatTest.test_getInstance", "method_implementation": "{\n    final FastDateFormat format1 = FastDateFormat.getInstance();\n    final FastDateFormat format2 = FastDateFormat.getInstance();\n    assertSame(format1, format2);\n}", "repo_id": "8", "comment": "/*\n     * Only the cache methods need to be tested here.\n     * The print methods are tested by {@link FastDateFormat_PrinterTest}\n     * and the parse methods are tested by {@link FastDateFormat_ParserTest}\n     */\n", "repo_name": "commons-lang-master/", "id": 1818, "method_signature": "void test_getInstance()", "filename": "FastDateFormatTest.test_getInstance.json"}
{"callee_method_names": ["Calendar.getDisplayNames", "Map<String, Integer>.forEach", "int.toLowerCase", "TreeSet<String>.add", "Map<String, Integer>.put", "TreeSet<String>.forEach"], "method_name": "FastDateParser.appendDisplayNames", "method_implementation": "{\n    Objects.requireNonNull(calendar, \"calendar\");\n    final Map<String, Integer> values = new HashMap<>();\n    final Locale actualLocale = LocaleUtils.toLocale(locale);\n    final Map<String, Integer> displayNames = calendar.getDisplayNames(field, Calendar.ALL_STYLES, actualLocale);\n    final TreeSet<String> sorted = new TreeSet<>(LONGER_FIRST_LOWERCASE);\n    displayNames.forEach((k, v) -> {\n        final String keyLc = k.toLowerCase(actualLocale);\n        if (sorted.add(keyLc)) {\n            values.put(keyLc, v);\n        }\n    });\n    sorted.forEach(symbol -> simpleQuote(regex, symbol).append('|'));\n    return values;\n}", "repo_id": "8", "comment": "/**\n * Gets the short and long values displayed for a field\n *\n * @param calendar The calendar to obtain the short and long values\n * @param locale   The locale of display names\n * @param field    The field of interest\n * @param regex    The regular expression to build\n * @return The map of string display names to field values\n */\n", "repo_name": "commons-lang-master/", "id": 616, "method_signature": "Map<String,Integer> appendDisplayNames(Calendar, Locale, int, StringBuilder)", "filename": "FastDateParser.appendDisplayNames.json"}
{"callee_method_names": ["String.equals", "String.equals", "Locale.equals"], "method_name": "FastDateParser.equals", "method_implementation": "{\n    if (!(obj instanceof FastDateParser)) {\n        return false;\n    }\n    final FastDateParser other = (FastDateParser) obj;\n    return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale);\n}", "repo_id": "8", "comment": "/**\n * Compares another object for equality with this object.\n *\n * @param obj the object to compare to\n * @return {@code true}if equal to this instance\n */\n", "repo_name": "commons-lang-master/", "id": 618, "method_signature": "boolean equals(Object)", "filename": "FastDateParser.equals.json"}
{"callee_method_names": [], "method_name": "FastDateParser.getCache", "method_implementation": "{\n    synchronized (caches) {\n        if (caches[field] == null) {\n            caches[field] = new ConcurrentHashMap<>(3);\n        }\n        return caches[field];\n    }\n}", "repo_id": "8", "comment": "/**\n * Gets a cache of Strategies for a particular field\n *\n * @param field The Calendar field\n * @return a cache of Locale to Strategy\n */\n", "repo_name": "commons-lang-master/", "id": 617, "method_signature": "ConcurrentMap<Locale,Strategy> getCache(int)", "filename": "FastDateParser.getCache.json"}
{"callee_method_names": ["ConcurrentMap<Locale, Strategy>.computeIfAbsent"], "method_name": "FastDateParser.getLocaleSpecificStrategy", "method_implementation": "{\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    return cache.computeIfAbsent(locale, k -> field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy(locale) : new CaseInsensitiveTextStrategy(field, definingCalendar, locale));\n}", "repo_id": "8", "comment": "/**\n * Constructs a Strategy that parses a Text field\n *\n * @param field            The Calendar field\n * @param definingCalendar The calendar to obtain the short and long values\n * @return a TextStrategy for the field and Locale\n */\n", "repo_name": "commons-lang-master/", "id": 619, "method_signature": "Strategy getLocaleSpecificStrategy(int, Calendar)", "filename": "FastDateParser.getLocaleSpecificStrategy.json"}
{"callee_method_names": [], "method_name": "FastDateParser.getStrategy", "method_implementation": "{\n    switch(f) {\n        default:\n            throw new IllegalArgumentException(\"Format '\" + f + \"' not supported\");\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar);\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar);\n        case // Hour in day (0-23)\n        'H':\n            return HOUR_OF_DAY_STRATEGY;\n        case // Hour in am/pm (0-11)\n        'K':\n            return HOUR_STRATEGY;\n        case 'M':\n        case 'L':\n            return width >= 3 ? getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) : NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'a':\n            return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar);\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0\n        'h':\n            return HOUR12_STRATEGY;\n        case // Hour in day (1-24), i.e. midnight is 24, not 0\n        'k':\n            return HOUR24_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'u':\n            return DAY_OF_WEEK_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n        case 'Y':\n            return width > 2 ? LITERAL_YEAR_STRATEGY : ABBREVIATED_YEAR_STRATEGY;\n        case 'X':\n            return ISO8601TimeZoneStrategy.getStrategy(width);\n        case 'Z':\n            if (width == 2) {\n                return ISO8601TimeZoneStrategy.ISO_8601_3_STRATEGY;\n            }\n        //$FALL-THROUGH$\n        case 'z':\n            return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar);\n    }\n}", "repo_id": "8", "comment": "/**\n * Gets a Strategy given a field from a SimpleDateFormat pattern\n *\n * @param f                A sub-sequence of the SimpleDateFormat pattern\n * @param width            formatting width\n * @param definingCalendar The calendar to obtain the short and long values\n * @return The Strategy that will handle parsing for the field\n */\n", "repo_name": "commons-lang-master/", "id": 620, "method_signature": "Strategy getStrategy(char, int, Calendar)", "filename": "FastDateParser.getStrategy.json"}
{"callee_method_names": ["StrategyParser.getNextStrategy", "List<StrategyAndWidth>.add"], "method_name": "FastDateParser.init", "method_implementation": "{\n    patterns = new ArrayList<>();\n    final StrategyParser strategyParser = new StrategyParser(definingCalendar);\n    for (; ; ) {\n        final StrategyAndWidth field = strategyParser.getNextStrategy();\n        if (field == null) {\n            break;\n        }\n        patterns.add(field);\n    }\n}", "repo_id": "8", "comment": "/**\n * Initializes derived fields from defining fields. This is called from constructor and from readObject (de-serialization)\n *\n * @param definingCalendar the {@link java.util.Calendar} instance used to initialize this FastDateParser\n */\n", "repo_name": "commons-lang-master/", "id": 621, "method_signature": "void init(Calendar)", "filename": "FastDateParser.init.json"}
{"callee_method_names": ["List<StrategyAndWidth>.listIterator", "ListIterator<StrategyAndWidth>.hasNext", "ListIterator<StrategyAndWidth>.next", "StrategyAndWidth.getMaxWidth", "StrategyAndWidth.parse"], "method_name": "FastDateParser.parse", "method_implementation": "{\n    final ListIterator<StrategyAndWidth> lt = patterns.listIterator();\n    while (lt.hasNext()) {\n        final StrategyAndWidth strategyAndWidth = lt.next();\n        final int maxWidth = strategyAndWidth.getMaxWidth(lt);\n        if (!strategyAndWidth.strategy.parse(this, calendar, source, pos, maxWidth)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Parses a formatted date string according to the format. Updates the Calendar with parsed fields. Upon success, the ParsePosition index is updated to\n * indicate how much of the source text was consumed. Not all source text needs to be consumed. Upon parse failure, ParsePosition error index is updated to\n * the offset of the source text which does not match the supplied format.\n *\n * @param source   The text to parse.\n * @param pos      On input, the position in the source to start parsing, on output, updated position.\n * @param calendar The calendar into which to set parsed fields.\n * @return true, if source has been parsed (pos parsePosition is updated); otherwise false (and pos errorIndex is updated)\n * @throws IllegalArgumentException when Calendar has been set to be not lenient, and a parsed field is out of range.\n */\n", "repo_name": "commons-lang-master/", "id": 624, "method_signature": "boolean parse(String, ParsePosition, Calendar)", "filename": "FastDateParser.parse.json"}
{"callee_method_names": ["ObjectInputStream.defaultReadObject"], "method_name": "FastDateParser.readObject", "method_implementation": "{\n    in.defaultReadObject();\n    final Calendar definingCalendar = Calendar.getInstance(timeZone, locale);\n    init(definingCalendar);\n}", "repo_id": "8", "comment": "/**\n * Creates the object after serialization. This implementation reinitializes the transient properties.\n *\n * @param in ObjectInputStream from which the object is being deserialized.\n * @throws IOException            if there is an IO issue.\n * @throws ClassNotFoundException if a class cannot be found.\n */\n", "repo_name": "commons-lang-master/", "id": 625, "method_signature": "void readObject(ObjectInputStream)", "filename": "FastDateParser.readObject.json"}
{"callee_method_names": ["Calendar.setTimeZone", "String.toLowerCase", "HashMap.get", "HashMap.get", "Calendar.set", "Calendar.set", "TzInfo.getRawOffset"], "method_name": "FastDateParser.setCalendar", "method_implementation": "{\n    final TimeZone tz = FastTimeZone.getGmtTimeZone(timeZone);\n    if (tz != null) {\n        calendar.setTimeZone(tz);\n    } else {\n        final String lowerCase = timeZone.toLowerCase(locale);\n        TzInfo tzInfo = tzNames.get(lowerCase);\n        if (tzInfo == null) {\n            // match missing the optional trailing period\n            tzInfo = tzNames.get(lowerCase + '.');\n        }\n        calendar.set(Calendar.DST_OFFSET, tzInfo.dstOffset);\n        calendar.set(Calendar.ZONE_OFFSET, tzInfo.zone.getRawOffset());\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 615, "method_signature": "void setCalendar(FastDateParser, Calendar, String)", "filename": "FastDateParser.setCalendar.json"}
{"callee_method_names": ["Calendar.clear", "Calendar.set", "Calendar.getTime", "DateParser.parse", "Calendar.set", "Calendar.getTime", "DateParser.parse", "Calendar.set", "Calendar.getTime", "DateParser.parse", "Calendar.set", "Calendar.getTime", "DateParser.parse"], "method_name": "FastDateParserTest.testLowYearPadding", "method_implementation": "{\n    final DateParser parser = getInstance(YMD_SLASH);\n    final Calendar cal = Calendar.getInstance();\n    cal.clear();\n    cal.set(1, Calendar.JANUARY, 1);\n    assertEquals(cal.getTime(), parser.parse(\"0001/01/01\"));\n    cal.set(10, Calendar.JANUARY, 1);\n    assertEquals(cal.getTime(), parser.parse(\"0010/01/01\"));\n    cal.set(100, Calendar.JANUARY, 1);\n    assertEquals(cal.getTime(), parser.parse(\"0100/01/01\"));\n    cal.set(999, Calendar.JANUARY, 1);\n    assertEquals(cal.getTime(), parser.parse(\"0999/01/01\"));\n}", "repo_id": "8", "comment": "/**\n * Tests that pre-1000AD years get padded with yyyy\n *\n * @throws ParseException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1825, "method_signature": "void testLowYearPadding()", "filename": "FastDateParserTest.testLowYearPadding.json"}
{"callee_method_names": ["Locale.toString", "Calendar.getTime", "Calendar.set", "Calendar.set", "Calendar.getTime"], "method_name": "FastDateParserTest.testParsesKnownJava16Ea25Failure", "method_implementation": "{\n    final String format = LONG_FORMAT;\n    final int year = 2003;\n    final Locale locale = new Locale.Builder().setLanguage(\"sq\").setRegion(\"MK\").build();\n    assertEquals(\"sq_MK\", locale.toString());\n    assertNotNull(locale);\n    final TimeZone timeZone = NEW_YORK;\n    final Calendar cal = getEraStart(year, timeZone, locale);\n    final Date centuryStart = cal.getTime();\n    cal.set(Calendar.MONTH, 1);\n    cal.set(Calendar.DAY_OF_MONTH, 10);\n    final Date in = cal.getTime();\n    final FastDateParser fastDateParser = new FastDateParser(format, timeZone, locale, centuryStart);\n    validateSdfFormatFdpParseEquality(format, locale, timeZone, fastDateParser, in, year, centuryStart);\n}", "repo_id": "8", "comment": "/**\n * Fails on Java 16 Early Access build 25 and above, last tested with build 36.\n */\n", "repo_name": "commons-lang-master/", "id": 1826, "method_signature": "void testParsesKnownJava16Ea25Failure()", "filename": "FastDateParserTest.testParsesKnownJava16Ea25Failure.json"}
{"callee_method_names": ["Calendar.clear", "Calendar.set", "Calendar.getTime", "DateParser.parse", "Calendar.getTime", "DateParser.parse"], "method_name": "FastDateParserTest.testShortDateStyleWithLocales", "method_implementation": "{\n    DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);\n    final Calendar cal = Calendar.getInstance();\n    cal.clear();\n    cal.set(2004, Calendar.FEBRUARY, 3);\n    assertEquals(cal.getTime(), fdf.parse(\"2/3/04\"));\n    fdf = getDateInstance(FastDateFormat.SHORT, SWEDEN);\n    assertEquals(cal.getTime(), fdf.parse(\"2004-02-03\"));\n}", "repo_id": "8", "comment": "/**\n * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}.\n *\n * @throws ParseException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1827, "method_signature": "void testShortDateStyleWithLocales()", "filename": "FastDateParserTest.testShortDateStyleWithLocales.json"}
{"callee_method_ids": [624], "callee_method_names": ["Calendar.clear", "Calendar.set", "Calendar.set", "Calendar.set", "Calendar.getTime", "FastDateParser.parse", "TimeZone.getDisplayName", "TimeZone.getID", "Locale.getDisplayName"], "method_name": "FastDateParserTest.testTzParses", "method_implementation": "{\n    // Check that all Locales can parse the time formats we use\n    for (final Locale locale : Locale.getAvailableLocales()) {\n        final FastDateParser fdp = new FastDateParser(\"yyyy/MM/dd z\", TimeZone.getDefault(), locale);\n        for (final TimeZone timeZone : new TimeZone[] { NEW_YORK, REYKJAVIK, TimeZones.GMT }) {\n            final Calendar cal = Calendar.getInstance(timeZone, locale);\n            cal.clear();\n            cal.set(Calendar.YEAR, 2000);\n            cal.set(Calendar.MONTH, 1);\n            cal.set(Calendar.DAY_OF_MONTH, 10);\n            final Date expected = cal.getTime();\n            final Date actual = fdp.parse(\"2000/02/10 \" + timeZone.getDisplayName(locale));\n            assertEquals(expected, actual, \"timeZone:\" + timeZone.getID() + \" locale:\" + locale.getDisplayName());\n        }\n    }\n}", "repo_id": "8", "comment": "// as well as hours and minutes which makes the z formats a low fidelity round trip\n", "repo_name": "commons-lang-master/", "id": 1828, "method_signature": "void testTzParses()", "filename": "FastDateParserTest.testTzParses.json"}
{"callee_method_ids": [624], "callee_method_names": ["TimeZone.getDisplayName", "FastDateParser.parse", "FastDateParser.toStringAll"], "method_name": "FastDateParser_TimeZoneStrategyTest.testTimeZoneStrategyPattern_TimeZone_getAvailableIDs", "method_implementation": "{\n    Objects.requireNonNull(locale, \"locale\");\n    assumeFalse(LocaleUtils.isLanguageUndetermined(locale), () -> toFailureMessage(locale, null));\n    assumeTrue(LocaleUtils.isAvailableLocale(locale), () -> toFailureMessage(locale, null));\n    for (final String id : ArraySorter.sort(TimeZone.getAvailableIDs())) {\n        final TimeZone timeZone = TimeZone.getTimeZone(id);\n        final FastDateParser parser = new FastDateParser(\"z\", timeZone, locale);\n        final String displayName = timeZone.getDisplayName(locale);\n        try {\n            parser.parse(displayName);\n        } catch (ParseException e) {\n            // Missing \"Zulu\" or something else in broken JDK's GH builds?\n            fail(String.format(\"%s: with locale = %s, id = '%s', timeZone = %s, displayName = '%s', parser = '%s'\", e, locale, id, timeZone, displayName, parser.toStringAll()), e);\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Breaks randomly on GitHub for Locale \"pt_PT\", TimeZone \"Etc/UTC\" if we do not check if the Locale's language is \"undetermined\".\n *\n * @throws ParseException\n */\n", "repo_name": "commons-lang-master/", "id": 1824, "method_signature": "void testTimeZoneStrategyPattern_TimeZone_getAvailableIDs(Locale)", "filename": "FastDateParser_TimeZoneStrategyTest.testTimeZoneStrategyPattern_TimeZone_getAvailableIDs.json"}
{"callee_method_names": ["Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append"], "method_name": "FastDatePrinter.appendFullDigits", "method_implementation": "{\n    // specialized paths for 1 to 4 digits -> avoid the memory allocation from the temporary work array\n    // see LANG-1248\n    if (value < 10000) {\n        // less memory allocation path works for four digits or less\n        int nDigits = 4;\n        if (value < 1000) {\n            --nDigits;\n            if (value < 100) {\n                --nDigits;\n                if (value < 10) {\n                    --nDigits;\n                }\n            }\n        }\n        // left zero pad\n        for (int i = minFieldWidth - nDigits; i > 0; --i) {\n            buffer.append('0');\n        }\n        switch(nDigits) {\n            case 4:\n                buffer.append((char) (value / 1000 + '0'));\n                value %= 1000;\n            case 3:\n                if (value >= 100) {\n                    buffer.append((char) (value / 100 + '0'));\n                    value %= 100;\n                } else {\n                    buffer.append('0');\n                }\n            case 2:\n                if (value >= 10) {\n                    buffer.append((char) (value / 10 + '0'));\n                    value %= 10;\n                } else {\n                    buffer.append('0');\n                }\n            case 1:\n                buffer.append((char) (value + '0'));\n        }\n    } else {\n        // more memory allocation path works for any digits\n        // build up decimal representation in reverse\n        final char[] work = new char[MAX_DIGITS];\n        int digit = 0;\n        while (value != 0) {\n            work[digit++] = (char) (value % 10 + '0');\n            value /= 10;\n        }\n        // pad with zeros\n        while (digit < minFieldWidth) {\n            buffer.append('0');\n            --minFieldWidth;\n        }\n        // reverse\n        while (--digit >= 0) {\n            buffer.append(work[digit]);\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends all digits to the given buffer.\n *\n * @param buffer the buffer to append to.\n * @param value the value to append digits from.\n * @param minFieldWidth Minimum field width.\n * @throws IOException If an I/O error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 655, "method_signature": "void appendFullDigits(Appendable, int, int)", "filename": "FastDatePrinter.appendFullDigits.json"}
{"callee_method_names": ["Appendable.append"], "method_name": "FastDatePrinter.appendTo", "method_implementation": "{\n    if (value < 10) {\n        buffer.append((char) (value + '0'));\n    } else if (value < 100) {\n        appendDigits(buffer, value);\n    } else {\n        appendFullDigits(buffer, value, 1);\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 654, "method_signature": "void appendTo(Appendable, int)", "filename": "FastDatePrinter.appendTo.json"}
{"callee_method_names": ["NumberRule.appendTo"], "method_name": "FastDatePrinter.applyRules", "method_implementation": "{\n    try {\n        for (final Rule rule : rules) {\n            rule.appendTo(buf, calendar);\n        }\n    } catch (final IOException ioe) {\n        ExceptionUtils.asRuntimeException(ioe);\n    }\n    return buf;\n}", "repo_id": "8", "comment": "/**\n * Performs the formatting by applying the rules to the\n * specified calendar.\n *\n * @param calendar  the calendar to format\n * @param buf  the buffer to format into\n * @param <B> the Appendable class type, usually StringBuilder or StringBuffer.\n * @return the specified string buffer\n */\n", "repo_name": "commons-lang-master/", "id": 657, "method_signature": "B applyRules(Calendar, B)", "filename": "FastDatePrinter.applyRules.json"}
{"callee_method_names": ["String.equals", "TimeZone.equals", "Locale.equals"], "method_name": "FastDatePrinter.equals", "method_implementation": "{\n    if (!(obj instanceof FastDatePrinter)) {\n        return false;\n    }\n    final FastDatePrinter other = (FastDatePrinter) obj;\n    return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale);\n}", "repo_id": "8", "comment": "/**\n * Compares two objects for equality.\n *\n * @param obj  the object to compare to\n * @return {@code true} if equal\n */\n", "repo_name": "commons-lang-master/", "id": 658, "method_signature": "boolean equals(Object)", "filename": "FastDatePrinter.equals.json"}
{"callee_method_names": ["String.length", "String.length"], "method_name": "FastDatePrinter.estimateLength", "method_implementation": "{\n    // We have no access to the Calendar object that will be passed to\n    // appendTo so base estimate on the TimeZone passed to the\n    // constructor\n    return Math.max(standard.length(), daylight.length());\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 648, "method_signature": "int estimateLength()", "filename": "FastDatePrinter.estimateLength.json"}
{"callee_method_names": [], "method_name": "FastDatePrinter.format", "method_implementation": "{\n    if (obj instanceof Date) {\n        return format((Date) obj, toAppendTo);\n    }\n    if (obj instanceof Calendar) {\n        return format((Calendar) obj, toAppendTo);\n    }\n    if (obj instanceof Long) {\n        return format(((Long) obj).longValue(), toAppendTo);\n    }\n    throw new IllegalArgumentException(\"Unknown class: \" + ClassUtils.getName(obj, \"<null>\"));\n}", "repo_id": "8", "comment": "/**\n * Formats a {@link Date}, {@link Calendar} or\n * {@link Long} (milliseconds) object.\n * @deprecated Use {{@link #format(Date)}, {{@link #format(Calendar)}, {{@link #format(long)}.\n * @param obj  the object to format\n * @param toAppendTo  the buffer to append to\n * @param pos  the position - ignored\n * @return the buffer passed in\n */\n", "repo_name": "commons-lang-master/", "id": 668, "method_signature": "StringBuffer format(Object, StringBuffer, FieldPosition)", "filename": "FastDatePrinter.format.json"}
{"callee_method_names": [], "method_name": "FastDatePrinter.getRule", "method_implementation": "{\n    switch(tokenLen) {\n        case 1:\n            return ISO8601_HOURS;\n        case 2:\n            return ISO8601_HOURS_MINUTES;\n        case 3:\n            return ISO8601_HOURS_COLON_MINUTES;\n        default:\n            throw new IllegalArgumentException(\"invalid number of X\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Factory method for Iso8601_Rules.\n *\n * @param tokenLen a token indicating the length of the TimeZone String to be formatted.\n * @return an Iso8601_Rule that can format TimeZone String of length {@code tokenLen}. If no such\n *          rule exists, an IllegalArgumentException will be thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 642, "method_signature": "Iso8601_Rule getRule(int)", "filename": "FastDatePrinter.getRule.json"}
{"callee_method_names": ["ConcurrentHashMap.computeIfAbsent", "TimeZone.getDisplayName"], "method_name": "FastDatePrinter.getTimeZoneDisplay", "method_implementation": "{\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    // This is a very slow call, so cache the results.\n    return cTimeZoneDisplayCache.computeIfAbsent(key, k -> tz.getDisplayName(daylight, style, locale));\n}", "repo_id": "8", "comment": "/**\n * Gets the time zone display name, using a cache for performance.\n *\n * @param tz  the zone to query\n * @param daylight  true if daylight savings\n * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}\n * @param locale  the locale to use\n * @return the textual name of the time zone\n */\n", "repo_name": "commons-lang-master/", "id": 656, "method_signature": "String getTimeZoneDisplay(TimeZone, boolean, int, Locale)", "filename": "FastDatePrinter.getTimeZoneDisplay.json"}
{"callee_method_names": ["List<Rule>.toArray", "Rule[].estimateLength"], "method_name": "FastDatePrinter.init", "method_implementation": "{\n    final List<Rule> rulesList = parsePattern();\n    rules = rulesList.toArray(EMPTY_RULE_ARRAY);\n    int len = 0;\n    for (int i = rules.length; --i >= 0; ) {\n        len += rules[i].estimateLength();\n    }\n    maxLengthEstimate = len;\n}", "repo_id": "8", "comment": "/**\n * Initializes the instance for first use.\n */\n", "repo_name": "commons-lang-master/", "id": 669, "method_signature": "void init()", "filename": "FastDatePrinter.init.json"}
{"callee_method_names": ["DateFormatSymbols.getEras", "DateFormatSymbols.getMonths", "DateFormatSymbols.getShortMonths", "DateFormatSymbols.getWeekdays", "DateFormatSymbols.getShortWeekdays", "DateFormatSymbols.getAmPmStrings", "String.length", "String.length", "String.charAt", "String.substring", "String.length", "String.charAt", "List<Rule>.add"], "method_name": "FastDatePrinter.parsePattern", "method_implementation": "{\n    final DateFormatSymbols symbols = new DateFormatSymbols(locale);\n    final List<Rule> rules = new ArrayList<>();\n    final String[] ERAs = symbols.getEras();\n    final String[] months = symbols.getMonths();\n    final String[] shortMonths = symbols.getShortMonths();\n    final String[] weekdays = symbols.getWeekdays();\n    final String[] shortWeekdays = symbols.getShortWeekdays();\n    final String[] AmPmStrings = symbols.getAmPmStrings();\n    final int length = pattern.length();\n    final int[] indexRef = new int[1];\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        final String token = parseToken(pattern, indexRef);\n        i = indexRef[0];\n        final int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n        Rule rule;\n        final char c = token.charAt(0);\n        switch(c) {\n            case // era designator (text)\n            'G':\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            // year (number)\n            case 'y':\n            case // week year\n            'Y':\n                if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, Math.max(tokenLen, 4));\n                }\n                if (c == 'Y') {\n                    rule = new WeekYear((NumberRule) rule);\n                }\n                break;\n            case // month in year (text and number)\n            'M':\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case // month in year (text and number)\n            'L':\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, CalendarUtils.getInstance(locale).getStandaloneLongMonthNames());\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, CalendarUtils.getInstance(locale).getStandaloneShortMonthNames());\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case // day in month (number)\n            'd':\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case // hour in am/pm (number, 1..12)\n            'h':\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case // hour in day (number, 0..23)\n            'H':\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case // minute in hour (number)\n            'm':\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case // second in minute (number)\n            's':\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case // millisecond (number)\n            'S':\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case // day in week (text)\n            'E':\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case // day in week (number)\n            'u':\n                rule = new DayInWeekField(selectNumberRule(Calendar.DAY_OF_WEEK, tokenLen));\n                break;\n            case // day in year (number)\n            'D':\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case // day of week in month (number)\n            'F':\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case // week in year (number)\n            'w':\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case // week in month (number)\n            'W':\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case // am/pm marker (text)\n            'a':\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case // hour in day (1..24)\n            'k':\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case // hour in am/pm (0..11)\n            'K':\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case // ISO 8601\n            'X':\n                rule = Iso8601_Rule.getRule(tokenLen);\n                break;\n            case // time zone (text)\n            'z':\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(timeZone, locale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(timeZone, locale, TimeZone.SHORT);\n                }\n                break;\n            case // time zone (value)\n            'Z':\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else if (tokenLen == 2) {\n                    rule = Iso8601_Rule.ISO8601_HOURS_COLON_MINUTES;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case // literal text\n            '\\'':\n                final String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n        rules.add(rule);\n    }\n    return rules;\n}", "repo_id": "8", "comment": "/**\n * Returns a list of Rules given a pattern.\n *\n * @return a {@link List} of Rule objects\n * @throws IllegalArgumentException if pattern is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 670, "method_signature": "List<Rule> parsePattern()", "filename": "FastDatePrinter.parsePattern.json"}
{"callee_method_names": ["String.length", "String.charAt", "StringBuilder.append", "String.charAt", "StringBuilder.append", "StringBuilder.append", "String.charAt", "String.charAt", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "FastDatePrinter.parseToken", "method_implementation": "{\n    final StringBuilder buf = new StringBuilder();\n    int i = indexRef[0];\n    final int length = pattern.length();\n    char c = pattern.charAt(i);\n    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n        // Scan a run of the same character, which indicates a time\n        // pattern.\n        buf.append(c);\n        while (i + 1 < length) {\n            final char peek = pattern.charAt(i + 1);\n            if (peek != c) {\n                break;\n            }\n            buf.append(c);\n            i++;\n        }\n    } else {\n        // This will identify token as text.\n        buf.append('\\'');\n        boolean inLiteral = false;\n        for (; i < length; i++) {\n            c = pattern.charAt(i);\n            if (c == '\\'') {\n                if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                    // '' is treated as escaped '\n                    i++;\n                    buf.append(c);\n                } else {\n                    inLiteral = !inLiteral;\n                }\n            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                i--;\n                break;\n            } else {\n                buf.append(c);\n            }\n        }\n    }\n    indexRef[0] = i;\n    return buf.toString();\n}", "repo_id": "8", "comment": "/**\n * Performs the parsing of tokens.\n *\n * @param pattern  the pattern\n * @param indexRef  index references\n * @return parsed token\n */\n", "repo_name": "commons-lang-master/", "id": 671, "method_signature": "String parseToken(String, int[])", "filename": "FastDatePrinter.parseToken.json"}
{"callee_method_names": [], "method_name": "FastDatePrinter.selectNumberRule", "method_implementation": "{\n    switch(padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n    }\n}", "repo_id": "8", "comment": "/**\n * Gets an appropriate rule for the padding required.\n *\n * @param field  the field to get a rule for\n * @param padding  the padding required\n * @return a new rule with the correct padding\n */\n", "repo_name": "commons-lang-master/", "id": 672, "method_signature": "NumberRule selectNumberRule(int, int)", "filename": "FastDatePrinter.selectNumberRule.json"}
{"callee_method_names": ["Calendar.clear", "Calendar.set"], "method_name": "FastDatePrinterTest.testLang916", "method_implementation": "{\n    final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Paris\"));\n    cal.clear();\n    cal.set(2009, 9, 16, 8, 42, 16);\n    // calendar fast.\n    {\n        final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZone.getTimeZone(\"Europe/Paris\")).format(cal);\n        assertEquals(\"2009-10-16T08:42:16 +0200\", value, \"calendar\");\n    }\n    {\n        final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZone.getTimeZone(\"Asia/Kolkata\")).format(cal);\n        assertEquals(\"2009-10-16T12:12:16 +0530\", value, \"calendar\");\n    }\n    {\n        final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZone.getTimeZone(\"Europe/London\")).format(cal);\n        assertEquals(\"2009-10-16T07:42:16 +0100\", value, \"calendar\");\n    }\n}", "repo_id": "8", "comment": "/**\n * According to LANG-916 (https://issues.apache.org/jira/browse/LANG-916),\n * the format method did contain a bug: it did not use the TimeZone data.\n *\n * This method test that the bug is fixed.\n */\n", "repo_name": "commons-lang-master/", "id": 1788, "method_signature": "void testLang916()", "filename": "FastDatePrinterTest.testLang916.json"}
{"callee_method_names": ["Calendar.set", "DatePrinter.format", "Calendar.set", "DatePrinter.format", "Calendar.set", "DatePrinter.format", "Calendar.set", "DatePrinter.format"], "method_name": "FastDatePrinterTest.testLowYearPadding", "method_implementation": "{\n    final Calendar cal = Calendar.getInstance();\n    final DatePrinter format = getInstance(YYYY_MM_DD);\n    cal.set(1, Calendar.JANUARY, 1);\n    assertEquals(\"0001/01/01\", format.format(cal));\n    cal.set(10, Calendar.JANUARY, 1);\n    assertEquals(\"0010/01/01\", format.format(cal));\n    cal.set(100, Calendar.JANUARY, 1);\n    assertEquals(\"0100/01/01\", format.format(cal));\n    cal.set(999, Calendar.JANUARY, 1);\n    assertEquals(\"0999/01/01\", format.format(cal));\n}", "repo_id": "8", "comment": "/**\n * Tests that pre-1000AD years get padded with yyyy\n */\n", "repo_name": "commons-lang-master/", "id": 1789, "method_signature": "void testLowYearPadding()", "filename": "FastDatePrinterTest.testLowYearPadding.json"}
{"callee_method_names": ["Calendar.set", "DatePrinter.format"], "method_name": "FastDatePrinterTest.testMilleniumBug", "method_implementation": "{\n    final Calendar cal = Calendar.getInstance();\n    final DatePrinter format = getInstance(\"dd.MM.yyyy\");\n    cal.set(1000, Calendar.JANUARY, 1);\n    assertEquals(\"01.01.1000\", format.format(cal));\n}", "repo_id": "8", "comment": "/**\n * Show Bug #39410 is solved\n */\n", "repo_name": "commons-lang-master/", "id": 1790, "method_signature": "void testMilleniumBug()", "filename": "FastDatePrinterTest.testMilleniumBug.json"}
{"callee_method_names": ["Calendar.set", "DatePrinter.format", "DatePrinter.format"], "method_name": "FastDatePrinterTest.testShortDateStyleWithLocales", "method_implementation": "{\n    final Locale usLocale = Locale.US;\n    final Locale swedishLocale = new Locale(\"sv\", \"SE\");\n    final Calendar cal = Calendar.getInstance();\n    cal.set(2004, Calendar.FEBRUARY, 3);\n    DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale);\n    assertEquals(\"2/3/04\", fdf.format(cal));\n    fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale);\n    assertEquals(\"2004-02-03\", fdf.format(cal));\n}", "repo_id": "8", "comment": "/**\n * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1791, "method_signature": "void testShortDateStyleWithLocales()", "filename": "FastDatePrinterTest.testShortDateStyleWithLocales.json"}
{"callee_method_names": ["Calendar.set", "DatePrinter.format", "Calendar.set", "DatePrinter.format", "Calendar.set", "DatePrinter.format"], "method_name": "FastDatePrinterTest.testSimpleDate", "method_implementation": "{\n    final Calendar cal = Calendar.getInstance();\n    final DatePrinter format = getInstance(YYYY_MM_DD);\n    cal.set(2004, Calendar.DECEMBER, 31);\n    assertEquals(\"2004/12/31\", format.format(cal));\n    cal.set(999, Calendar.DECEMBER, 31);\n    assertEquals(\"0999/12/31\", format.format(cal));\n    cal.set(1, Calendar.MARCH, 2);\n    assertEquals(\"0001/03/02\", format.format(cal));\n}", "repo_id": "8", "comment": "/**\n * testLowYearPadding showed that the date was buggy\n * This test confirms it, getting 366 back as a date\n */\n", "repo_name": "commons-lang-master/", "id": 1792, "method_signature": "void testSimpleDate()", "filename": "FastDatePrinterTest.testSimpleDate.json"}
{"callee_method_names": ["Pattern.matcher", "Matcher.matches", "Matcher.group", "Matcher.group", "Matcher.group"], "method_name": "FastTimeZone.getGmtTimeZone", "method_implementation": "{\n    if (\"Z\".equals(pattern) || \"UTC\".equals(pattern)) {\n        return GREENWICH;\n    }\n    final Matcher m = GMT_PATTERN.matcher(pattern);\n    if (m.matches()) {\n        final int hours = parseInt(m.group(2));\n        final int minutes = parseInt(m.group(4));\n        if (hours == 0 && minutes == 0) {\n            return GREENWICH;\n        }\n        return new GmtTimeZone(parseSign(m.group(1)), hours, minutes);\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Gets a TimeZone with GMT offsets.  A GMT offset must be either 'Z', or 'UTC', or match\n * <em>(GMT)? hh?(:?mm?)?</em>, where h and m are digits representing hours and minutes.\n *\n * @param pattern The GMT offset\n * @return A TimeZone with offset from GMT or null, if pattern does not match.\n */\n", "repo_name": "commons-lang-master/", "id": 707, "method_signature": "TimeZone getGmtTimeZone(String)", "filename": "FastTimeZone.getGmtTimeZone.json"}
{"callee_method_names": [], "method_name": "FastTimeZone.getTimeZone", "method_implementation": "{\n    final TimeZone tz = getGmtTimeZone(id);\n    if (tz != null) {\n        return tz;\n    }\n    return TimeZone.getTimeZone(id);\n}", "repo_id": "8", "comment": "/**\n * Gets a TimeZone, looking first for GMT custom ids, then falling back to Olson ids.\n * A GMT custom id can be 'Z', or 'UTC', or has an optional prefix of GMT,\n * followed by sign, hours digit(s), optional colon(':'), and optional minutes digits.\n * i.e. <em>[GMT] (+|-) Hours [[:] Minutes]</em>\n *\n * @param id A GMT custom id (or Olson id\n * @return A time zone\n */\n", "repo_name": "commons-lang-master/", "id": 708, "method_signature": "TimeZone getTimeZone(String)", "filename": "FastTimeZone.getTimeZone.json"}
{"callee_method_names": ["Class<?>.getDeclaredFields", "Class<?>.getSuperclass"], "method_name": "FieldUtils.getAllFieldsList", "method_implementation": "{\n    Objects.requireNonNull(cls, \"cls\");\n    final List<Field> allFields = new ArrayList<>();\n    Class<?> currentClass = cls;\n    while (currentClass != null) {\n        final Field[] declaredFields = currentClass.getDeclaredFields();\n        Collections.addAll(allFields, declaredFields);\n        currentClass = currentClass.getSuperclass();\n    }\n    return allFields;\n}", "repo_id": "8", "comment": "/**\n * Gets all fields of the given class and its parents (if any).\n *\n * @param cls\n *            the {@link Class} to query\n * @return a list of Fields (possibly empty).\n * @throws NullPointerException\n *             if the class is {@code null}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 318, "method_signature": "List<Field> getAllFieldsList(Class)", "filename": "FieldUtils.getAllFieldsList.json"}
{"callee_method_names": ["Class<?>.getDeclaredField", "Field.setAccessible"], "method_name": "FieldUtils.getDeclaredField", "method_implementation": "{\n    Objects.requireNonNull(cls, \"cls\");\n    Validate.isTrue(StringUtils.isNotBlank(fieldName), \"The field name must not be blank/empty\");\n    try {\n        // only consider the specified class by using getDeclaredField()\n        final Field field = cls.getDeclaredField(fieldName);\n        if (!MemberUtils.isAccessible(field)) {\n            if (!forceAccess) {\n                return null;\n            }\n            field.setAccessible(true);\n        }\n        return field;\n    } catch (final NoSuchFieldException ignored) {\n        // ignore\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Gets an accessible {@link Field} by name, breaking scope if requested. Only the specified class will be\n * considered.\n *\n * @param cls\n *            the {@link Class} to reflect, must not be {@code null}\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @return the Field object\n * @throws NullPointerException\n *             if the class is {@code null}\n * @throws IllegalArgumentException\n *             if the field name is {@code null}, blank, or empty\n */\n", "repo_name": "commons-lang-master/", "id": 319, "method_signature": "Field getDeclaredField(Class, String, boolean)", "filename": "FieldUtils.getDeclaredField.json"}
{"callee_method_names": ["Class<?>.getSuperclass", "Class<?>.getDeclaredField", "Field.setAccessible"], "method_name": "FieldUtils.getField", "method_implementation": "{\n    Objects.requireNonNull(cls, \"cls\");\n    Validate.isTrue(StringUtils.isNotBlank(fieldName), \"The field name must not be blank/empty\");\n    // FIXME is this workaround still needed? lang requires Java 6\n    // Sun Java 1.3 has a bugged implementation of getField hence we write the\n    // code ourselves\n    // getField() will return the Field object with the declaring class\n    // set correctly to the class that declares the field. Thus requesting the\n    // field on a subclass will return the field from the superclass.\n    //\n    // priority order for lookup:\n    // searchclass private/protected/package/public\n    // superclass protected/package/public\n    // private/different package blocks access to further superclasses\n    // implementedinterface public\n    // check up the superclass hierarchy\n    for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n        try {\n            final Field field = acls.getDeclaredField(fieldName);\n            // getDeclaredField checks for non-public scopes as well\n            // and it returns accurate results\n            if (!MemberUtils.isPublic(field)) {\n                if (!forceAccess) {\n                    continue;\n                }\n                field.setAccessible(true);\n            }\n            return field;\n        } catch (final NoSuchFieldException ignored) {\n            // ignore\n        }\n    }\n    // check the public interface case. This must be manually searched for\n    // incase there is a public supersuperclass field hidden by a private/package\n    // superclass field.\n    Field match = null;\n    for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n        try {\n            final Field test = class1.getField(fieldName);\n            Validate.isTrue(match == null, \"Reference to field %s is ambiguous relative to %s\" + \"; a matching field exists on two or more implemented interfaces.\", fieldName, cls);\n            match = test;\n        } catch (final NoSuchFieldException ignored) {\n            // ignore\n        }\n    }\n    return match;\n}", "repo_id": "8", "comment": "/**\n * Gets an accessible {@link Field} by name, breaking scope if requested. Superclasses/interfaces will be\n * considered.\n *\n * @param cls\n *            the {@link Class} to reflect, must not be {@code null}\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @return the Field object\n * @throws NullPointerException if the class is {@code null}\n * @throws IllegalArgumentException if the field name is blank or empty or is matched at multiple places\n * in the inheritance hierarchy\n */\n", "repo_name": "commons-lang-master/", "id": 320, "method_signature": "Field getField(Class, String, boolean)", "filename": "FieldUtils.getField.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "FieldUtils.readDeclaredField", "method_implementation": "{\n    Objects.requireNonNull(target, \"target\");\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", cls, fieldName);\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}", "repo_id": "8", "comment": "/**\n * Gets a {@link Field} value by name. Only the class of the specified object will be considered.\n *\n * @param target\n *            the object to reflect, must not be {@code null}\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match public fields.\n * @return the Field object\n * @throws NullPointerException\n *             if {@code target} is {@code null}\n * @throws IllegalArgumentException\n *             if {@code fieldName} is {@code null}, blank or empty, or could not be found\n * @throws IllegalAccessException\n *             if the field is not made accessible\n */\n", "repo_name": "commons-lang-master/", "id": 321, "method_signature": "Object readDeclaredField(Object, String, boolean)", "filename": "FieldUtils.readDeclaredField.json"}
{"callee_method_names": ["Class<?>.getName"], "method_name": "FieldUtils.readDeclaredStaticField", "method_implementation": "{\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    Validate.notNull(field, \"Cannot locate declared field %s.%s\", cls.getName(), fieldName);\n    // already forced access above, don't repeat it here:\n    return readStaticField(field, false);\n}", "repo_id": "8", "comment": "/**\n * Gets the value of a {@code static} {@link Field} by name. Only the specified class will be considered.\n *\n * @param cls\n *            the {@link Class} to reflect, must not be {@code null}\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @return the Field object\n * @throws NullPointerException\n *             if the class is {@code null}, or the field could not be found\n * @throws IllegalArgumentException\n *             if the field name is blank or empty, is not {@code static}\n * @throws IllegalAccessException\n *             if the field is not made accessible\n */\n", "repo_name": "commons-lang-master/", "id": 322, "method_signature": "Object readDeclaredStaticField(Class, String, boolean)", "filename": "FieldUtils.readDeclaredStaticField.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "FieldUtils.readField", "method_implementation": "{\n    Objects.requireNonNull(target, \"target\");\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    Validate.isTrue(field != null, \"Cannot locate field %s on %s\", fieldName, cls);\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}", "repo_id": "8", "comment": "/**\n * Reads the named {@link Field}. Superclasses will be considered.\n *\n * @param target\n *            the object to reflect, must not be {@code null}\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @return the field value\n * @throws NullPointerException\n *             if {@code target} is {@code null}\n * @throws IllegalArgumentException\n *             if the field name is {@code null}, blank, empty, or could not be found\n * @throws IllegalAccessException\n *             if the named field is not made accessible\n */\n", "repo_name": "commons-lang-master/", "id": 324, "method_signature": "Object readField(Object, String, boolean)", "filename": "FieldUtils.readField.json"}
{"callee_method_names": ["Field.getName"], "method_name": "FieldUtils.readStaticField", "method_implementation": "{\n    Objects.requireNonNull(field, \"field\");\n    Validate.isTrue(MemberUtils.isStatic(field), \"The field '%s' is not static\", field.getName());\n    return readField(field, (Object) null, forceAccess);\n}", "repo_id": "8", "comment": "/**\n * Reads a static {@link Field}.\n *\n * @param field\n *            to read\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method.\n * @return the field value\n * @throws NullPointerException\n *             if the field is {@code null}\n * @throws IllegalArgumentException\n *             if the field is not {@code static}\n * @throws IllegalAccessException\n *             if the field is not made accessible\n */\n", "repo_name": "commons-lang-master/", "id": 326, "method_signature": "Object readStaticField(Field, boolean)", "filename": "FieldUtils.readStaticField.json"}
{"callee_method_names": ["Field.getModifiers", "Field.isAccessible", "Field.setAccessible", "Field.setInt", "Field.getModifiers", "Field.setAccessible"], "method_name": "FieldUtils.removeFinalModifier", "method_implementation": "{\n    Objects.requireNonNull(field, \"field\");\n    try {\n        if (Modifier.isFinal(field.getModifiers())) {\n            // Do all JREs implement Field with a private ivar called \"modifiers\"?\n            final Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n            final boolean doForceAccess = forceAccess && !modifiersField.isAccessible();\n            if (doForceAccess) {\n                modifiersField.setAccessible(true);\n            }\n            try {\n                modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\n            } finally {\n                if (doForceAccess) {\n                    modifiersField.setAccessible(false);\n                }\n            }\n        }\n    } catch (final NoSuchFieldException | IllegalAccessException e) {\n        if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_12)) {\n            throw new UnsupportedOperationException(\"In java 12+ final cannot be removed.\", e);\n        }\n        // else no exception is thrown because we can modify final.\n    }\n}", "repo_id": "8", "comment": "/**\n * Removes the final modifier from a {@link Field}.\n *\n * @param field\n *            to remove the final modifier\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @throws NullPointerException\n *             if the field is {@code null}\n * @deprecated As of Java 12, we can no longer drop the {@code final} modifier, thus\n *             rendering this method obsolete. The JDK discussion about this change can be found\n *             here: https://mail.openjdk.java.net/pipermail/core-libs-dev/2018-November/056486.html\n * @since 3.3\n */\n", "repo_name": "commons-lang-master/", "id": 327, "method_signature": "void removeFinalModifier(Field, boolean)", "filename": "FieldUtils.removeFinalModifier.json"}
{"callee_method_names": ["Object.getClass", "Class<?>.getName"], "method_name": "FieldUtils.writeDeclaredField", "method_implementation": "{\n    Objects.requireNonNull(target, \"target\");\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", cls.getName(), fieldName);\n    // already forced access above, don't repeat it here:\n    writeField(field, target, value, false);\n}", "repo_id": "8", "comment": "/**\n * Writes a {@code public} {@link Field}. Only the specified class will be considered.\n *\n * @param target\n *            the object to reflect, must not be {@code null}\n * @param fieldName\n *            the field name to obtain\n * @param value\n *            to set\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @throws IllegalArgumentException\n *             if {@code fieldName} is {@code null}, blank or empty, or could not be found,\n *             or {@code value} is not assignable\n * @throws IllegalAccessException\n *             if the field is not made accessible\n */\n", "repo_name": "commons-lang-master/", "id": 328, "method_signature": "void writeDeclaredField(Object, String, Object, boolean)", "filename": "FieldUtils.writeDeclaredField.json"}
{"callee_method_names": ["Class<?>.getName"], "method_name": "FieldUtils.writeDeclaredStaticField", "method_implementation": "{\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    Validate.notNull(field, \"Cannot locate declared field %s.%s\", cls.getName(), fieldName);\n    // already forced access above, don't repeat it here:\n    writeField(field, (Object) null, value, false);\n}", "repo_id": "8", "comment": "/**\n * Writes a named {@code static} {@link Field}. Only the specified class will be considered.\n *\n * @param cls\n *            {@link Class} on which the field is to be found\n * @param fieldName\n *            to write\n * @param value\n *            to set\n * @param forceAccess\n *            whether to break scope restrictions using the {@code AccessibleObject#setAccessible(boolean)} method.\n *            {@code false} will only match {@code public} fields.\n * @throws NullPointerException\n *             if {@code cls} is {@code null} or the field cannot be located\n * @throws IllegalArgumentException\n *             if the field name is {@code null}, blank, empty, not {@code static}, or {@code value} is not assignable\n * @throws IllegalAccessException\n *             if the field is not made accessible or is {@code final}\n */\n", "repo_name": "commons-lang-master/", "id": 329, "method_signature": "void writeDeclaredStaticField(Class, String, Object, boolean)", "filename": "FieldUtils.writeDeclaredStaticField.json"}
{"callee_method_names": ["Object.getClass", "Class<?>.getName"], "method_name": "FieldUtils.writeField", "method_implementation": "{\n    Objects.requireNonNull(target, \"target\");\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", cls.getName(), fieldName);\n    // already forced access above, don't repeat it here:\n    writeField(field, target, value, false);\n}", "repo_id": "8", "comment": "/**\n * Writes a {@link Field}. Superclasses will be considered.\n *\n * @param target\n *            the object to reflect, must not be {@code null}\n * @param fieldName\n *            the field name to obtain\n * @param value\n *            to set\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @throws NullPointerException\n *             if {@code target} is {@code null}\n * @throws IllegalArgumentException\n *             if {@code fieldName} is {@code null}, blank, empty, or could not be found,\n *             or {@code value} is not assignable\n * @throws IllegalAccessException\n *             if the field is not made accessible\n */\n", "repo_name": "commons-lang-master/", "id": 331, "method_signature": "void writeField(Object, String, Object, boolean)", "filename": "FieldUtils.writeField.json"}
{"callee_method_names": ["Field.getDeclaringClass", "Field.getName"], "method_name": "FieldUtils.writeStaticField", "method_implementation": "{\n    Objects.requireNonNull(field, \"field\");\n    Validate.isTrue(MemberUtils.isStatic(field), \"The field %s.%s is not static\", field.getDeclaringClass().getName(), field.getName());\n    writeField(field, (Object) null, value, forceAccess);\n}", "repo_id": "8", "comment": "/**\n * Writes a static {@link Field}.\n *\n * @param field\n *            to write\n * @param value\n *            to set\n * @param forceAccess\n *            whether to break scope restrictions using the\n *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only\n *            match {@code public} fields.\n * @throws NullPointerException\n *              if the field is {@code null}\n * @throws IllegalArgumentException\n *              if the field is not {@code static}, or {@code value} is not assignable\n * @throws IllegalAccessException\n *             if the field is not made accessible or is {@code final}\n */\n", "repo_name": "commons-lang-master/", "id": 333, "method_signature": "void writeStaticField(Field, Object, boolean)", "filename": "FieldUtils.writeStaticField.json"}
{"callee_method_names": ["Exception.getCause"], "method_name": "FieldUtilsTest.callRemoveFinalModifierCheckForException", "method_implementation": "{\n    try {\n        FieldUtils.removeFinalModifier(field, forceAccess);\n    } catch (final UnsupportedOperationException exception) {\n        if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_12)) {\n            assertTrue(exception.getCause() instanceof NoSuchFieldException);\n        } else {\n            fail(\"No exception should be thrown for java prior to 12.0\");\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Read the {@code @deprecated} notice on\n * {@link FieldUtils#removeFinalModifier(Field, boolean)}.\n *\n * @param field {@link Field} to be curried into\n *              {@link FieldUtils#removeFinalModifier(Field, boolean)}.\n * @param forceAccess {@link Boolean} to be curried into\n *              {@link FieldUtils#removeFinalModifier(Field, boolean)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1701, "method_signature": "void callRemoveFinalModifierCheckForException(Field, Boolean)", "filename": "FieldUtilsTest.callRemoveFinalModifierCheckForException.json"}
{"callee_method_names": [], "method_name": "FluentBitSet.clear", "method_implementation": "{\n    for (final int e : bitIndexArray) {\n        this.bitSet.clear(e);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the bits specified by the indexes to {@code false}.\n *\n * @param bitIndexArray the index of the bit to be cleared.\n * @throws IndexOutOfBoundsException if the specified index is negative.\n * @return this.\n */\n", "repo_name": "commons-lang-master/", "id": 749, "method_signature": "FluentBitSet clear(int[])", "filename": "FluentBitSet.clear.json"}
{"callee_method_names": [], "method_name": "FluentBitSet.or", "method_implementation": "{\n    for (final FluentBitSet e : set) {\n        this.bitSet.or(e.bitSet);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Performs a logical <b>OR</b> of this bit set with the bit set arguments. This bit set is modified so that a bit in it\n * has the value {@code true} if and only if it either already had the value {@code true} or the corresponding bit in\n * the bit set argument has the value {@code true}.\n *\n * @param set a bit set.\n * @return this.\n */\n", "repo_name": "commons-lang-master/", "id": 750, "method_signature": "FluentBitSet or(FluentBitSet[])", "filename": "FluentBitSet.or.json"}
{"callee_method_names": ["BitSet.set"], "method_name": "FluentBitSet.set", "method_implementation": "{\n    for (final int e : bitIndexArray) {\n        bitSet.set(e);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the bit at the specified indexes to {@code true}.\n *\n * @param bitIndexArray a bit index array.\n * @throws IndexOutOfBoundsException if the specified index is negative.\n * @return this.\n */\n", "repo_name": "commons-lang-master/", "id": 751, "method_signature": "FluentBitSet set(int[])", "filename": "FluentBitSet.set.json"}
{"callee_method_ids": [751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.bitSet"], "method_name": "FluentBitSetTest.beforeEach", "method_implementation": "{\n    eightFbs = newInstance();\n    for (int i = 0; i < 8; i++) {\n        eightFbs.set(i);\n    }\n    eightBs = eightFbs.bitSet();\n}", "repo_id": "8", "comment": "/**\n * BeforeEach.\n */\n", "repo_name": "commons-lang-master/", "id": 1929, "method_signature": "void beforeEach()", "filename": "FluentBitSetTest.beforeEach.json"}
{"callee_method_names": ["FluentBitSet.size", "FluentBitSet.toString"], "method_name": "FluentBitSetTest.test_Constructor", "method_implementation": "{\n    final FluentBitSet bs = newInstance();\n    assertEquals(64, bs.size(), \"Create FluentBitSet of incorrect size\");\n    assertEquals(\"{}\", bs.toString(), \"New FluentBitSet had invalid string representation\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#FluentBitSet()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1940, "method_signature": "void test_Constructor()", "filename": "FluentBitSetTest.test_Constructor.json"}
{"callee_method_names": ["FluentBitSet.size", "FluentBitSet.toString", "FluentBitSet.toString", "FluentBitSet.size"], "method_name": "FluentBitSetTest.test_ConstructorInt", "method_implementation": "{\n    FluentBitSet bs = newInstance(128);\n    assertEquals(128, bs.size(), \"Create FluentBitSet of incorrect size\");\n    assertEquals(\"{}\", bs.toString(), \"New FluentBitSet had invalid string representation: \" + bs.toString());\n    // All BitSets are created with elements of multiples of 64\n    bs = newInstance(89);\n    assertEquals(128, bs.size(), \"Failed to round FluentBitSet element size\");\n    assertThrows(NegativeArraySizeException.class, () -> newInstance(-9));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#FluentBitSet(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1941, "method_signature": "void test_ConstructorInt()", "filename": "FluentBitSetTest.test_ConstructorInt.json"}
{"callee_method_ids": [751, 751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.and", "FluentBitSet.equals", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.and", "FluentBitSet.get", "FluentBitSet.and", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_and", "method_implementation": "{\n    // Test for method void java.util.BitSet.and(BitSet)\n    final FluentBitSet bs = newInstance(128);\n    // Initialize the bottom half of the BitSet\n    for (int i = 64; i < 128; i++) {\n        bs.set(i);\n    }\n    eightFbs.and(bs);\n    assertFalse(eightFbs.equals(bs), \"AND failed to clear bits\");\n    eightFbs.set(3);\n    bs.set(3);\n    eightFbs.and(bs);\n    assertTrue(bs.get(3), \"AND failed to maintain set bits\");\n    bs.and(eightFbs);\n    for (int i = 64; i < 128; i++) {\n        assertFalse(bs.get(i), \"Failed to clear extra bits in the receiver BitSet\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#and(FluentBitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1930, "method_signature": "void test_and()", "filename": "FluentBitSetTest.test_and.json"}
{"callee_method_ids": [749, 751, 751], "callee_method_names": ["FluentBitSet.clone", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.andNot", "FluentBitSet.toString", "FluentBitSet.andNot", "FluentBitSet.size"], "method_name": "FluentBitSetTest.test_andNot", "method_implementation": "{\n    FluentBitSet bs = (FluentBitSet) eightFbs.clone();\n    bs.clear(5);\n    final FluentBitSet bs2 = newInstance();\n    bs2.set(2);\n    bs2.set(3);\n    bs.andNot(bs2);\n    assertEquals(\"{0, 1, 4, 6, 7}\", bs.toString(), \"Incorrect bitset after andNot\");\n    bs = newInstance(0);\n    bs.andNot(bs2);\n    assertEquals(0, bs.size(), \"Incorrect size\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#andNot(BitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1932, "method_signature": "void test_andNot()", "filename": "FluentBitSetTest.test_andNot.json"}
{"callee_method_ids": [749, 751, 751], "callee_method_names": ["FluentBitSet.clone", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.andNot", "FluentBitSet.bitSet", "FluentBitSet.toString", "FluentBitSet.andNot", "FluentBitSet.bitSet", "FluentBitSet.size"], "method_name": "FluentBitSetTest.test_andNot_BitSet", "method_implementation": "{\n    FluentBitSet bs = (FluentBitSet) eightFbs.clone();\n    bs.clear(5);\n    final FluentBitSet bs2 = newInstance();\n    bs2.set(2);\n    bs2.set(3);\n    bs.andNot(bs2.bitSet());\n    assertEquals(\"{0, 1, 4, 6, 7}\", bs.toString(), \"Incorrect bitset after andNot\");\n    bs = newInstance(0);\n    bs.andNot(bs2.bitSet());\n    assertEquals(0, bs.size(), \"Incorrect size\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#andNot(BitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1933, "method_signature": "void test_andNot_BitSet()", "filename": "FluentBitSetTest.test_andNot_BitSet.json"}
{"callee_method_ids": [751, 751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.and", "FluentBitSet.bitSet", "FluentBitSet.equals", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.and", "FluentBitSet.bitSet", "FluentBitSet.get", "FluentBitSet.and", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_and_BitSet", "method_implementation": "{\n    // Test for method void java.util.BitSet.and(BitSet)\n    final FluentBitSet bs = newInstance(128);\n    // Initialize the bottom half of the BitSet\n    for (int i = 64; i < 128; i++) {\n        bs.set(i);\n    }\n    eightFbs.and(bs.bitSet());\n    assertFalse(eightFbs.equals(bs), \"AND failed to clear bits\");\n    eightFbs.set(3);\n    bs.set(3);\n    eightFbs.and(bs.bitSet());\n    assertTrue(bs.get(3), \"AND failed to maintain set bits\");\n    bs.and(eightBs);\n    for (int i = 64; i < 128; i++) {\n        assertFalse(bs.get(i), \"Failed to clear extra bits in the receiver BitSet\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#and(BitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1931, "method_signature": "void test_and_BitSet()", "filename": "FluentBitSetTest.test_and_BitSet.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751, 751, 749, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.cardinality", "FluentBitSet.flip", "FluentBitSet.cardinality", "FluentBitSet.clear", "FluentBitSet.cardinality", "FluentBitSet.set", "FluentBitSet.cardinality"], "method_name": "FluentBitSetTest.test_cardinality", "method_implementation": "{\n    // test for method int java.util.BitSet.cardinality()\n    final FluentBitSet bs = newInstance(500);\n    bs.set(5);\n    bs.set(32);\n    bs.set(63);\n    bs.set(64);\n    bs.set(71, 110);\n    bs.set(127, 130);\n    bs.set(193);\n    bs.set(450);\n    assertEquals(48, bs.cardinality(), \"cardinality() returned wrong value\");\n    bs.flip(0, 500);\n    assertEquals(452, bs.cardinality(), \"cardinality() returned wrong value\");\n    bs.clear();\n    assertEquals(0, bs.cardinality(), \"cardinality() returned wrong value\");\n    bs.set(0, 500);\n    assertEquals(500, bs.cardinality(), \"cardinality() returned wrong value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#cardinality()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1934, "method_signature": "void test_cardinality()", "filename": "FluentBitSetTest.test_cardinality.json"}
{"callee_method_ids": [749, 751, 751, 749], "callee_method_names": ["FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.isEmpty", "FluentBitSet.cardinality"], "method_name": "FluentBitSetTest.test_clear", "method_implementation": "{\n    eightFbs.clear();\n    for (int i = 0; i < 8; i++) {\n        assertFalse(eightFbs.get(i), \"Clear didn't clear bit \" + i);\n    }\n    assertEquals(0, eightFbs.length(), \"Test1: Wrong length\");\n    final FluentBitSet bs = newInstance(3400);\n    // ensure all bits are 1's\n    bs.set(0, bs.size() - 1);\n    bs.set(bs.size() - 1);\n    bs.clear();\n    assertEquals(0, bs.length(), \"Test2: Wrong length\");\n    assertTrue(bs.isEmpty(), \"Test2: isEmpty() returned incorrect value\");\n    assertEquals(0, bs.cardinality(), \"Test2: cardinality() returned incorrect value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#clear()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1935, "method_signature": "void test_clear()", "filename": "FluentBitSetTest.test_clear.json"}
{"callee_method_ids": [749, 749, 749, 749, 749, 749, 751, 749, 749], "callee_method_names": ["FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length"], "method_name": "FluentBitSetTest.test_clearI", "method_implementation": "{\n    // Test for method void java.util.BitSet.clear(int)\n    eightFbs.clear(7);\n    assertFalse(eightFbs.get(7), \"Failed to clear bit\");\n    // Check to see all other bits are still set\n    for (int i = 0; i < 7; i++) {\n        assertTrue(eightFbs.get(i), \"Clear cleared incorrect bits\");\n    }\n    eightFbs.clear(165);\n    assertFalse(eightFbs.get(165), \"Failed to clear bit\");\n    // Try out of range\n    assertThrows(IndexOutOfBoundsException.class, () -> eightFbs.clear(-1));\n    final FluentBitSet bs = newInstance(0);\n    assertEquals(0, bs.length(), \"Test1: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test1: Wrong size,\");\n    bs.clear(0);\n    assertEquals(0, bs.length(), \"Test2: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test2: Wrong size,\");\n    bs.clear(60);\n    assertEquals(0, bs.length(), \"Test3: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test3: Wrong size,\");\n    bs.clear(120);\n    assertEquals(0, bs.size(), \"Test4: Wrong size,\");\n    assertEquals(0, bs.length(), \"Test4: Wrong length,\");\n    bs.set(25);\n    assertEquals(64, bs.size(), \"Test5: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test5: Wrong length,\");\n    bs.clear(80);\n    assertEquals(64, bs.size(), \"Test6: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test6: Wrong length,\");\n    bs.clear(25);\n    assertEquals(64, bs.size(), \"Test7: Wrong size,\");\n    assertEquals(0, bs.length(), \"Test7: Wrong length,\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#clear(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1936, "method_signature": "void test_clearI()", "filename": "FluentBitSetTest.test_clearI.json"}
{"callee_method_ids": [751, 749, 751, 749, 749, 749, 751, 749, 751, 749, 751, 749, 751, 749, 749, 749, 751, 749, 749, 749, 751, 749, 749, 749, 749, 751, 749, 749, 749, 749], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length"], "method_name": "FluentBitSetTest.test_clearII", "method_implementation": "{\n    // Regression for HARMONY-98\n    final FluentBitSet bitset = newInstance();\n    for (int i = 0; i < 20; i++) {\n        bitset.set(i);\n    }\n    bitset.clear(10, 10);\n    // Test for method void java.util.BitSet.clear(int, int)\n    // pos1 and pos2 are in the same bitset element\n    FluentBitSet bs = newInstance(16);\n    int initialSize = bs.size();\n    bs.set(0, initialSize);\n    bs.clear(5);\n    bs.clear(15);\n    bs.clear(7, 11);\n    for (int i = 0; i < 7; i++) {\n        if (i == 5) {\n            assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertTrue(bs.get(i), \"Shouldn't have cleared bit \" + i);\n        }\n    }\n    for (int i = 7; i < 11; i++) {\n        assertFalse(bs.get(i), \"Failed to clear bit \" + i);\n    }\n    for (int i = 11; i < initialSize; i++) {\n        if (i == 15) {\n            assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertTrue(bs.get(i), \"Shouldn't have cleared bit \" + i);\n        }\n    }\n    for (int i = initialSize; i < bs.size(); i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // pos1 and pos2 is in the same bitset element, boundary testing\n    bs = newInstance(16);\n    initialSize = bs.size();\n    bs.set(0, initialSize);\n    bs.clear(7, 64);\n    assertEquals(64, bs.size(), \"Failed to grow BitSet\");\n    for (int i = 0; i < 7; i++) {\n        assertTrue(bs.get(i), \"Shouldn't have cleared bit \" + i);\n    }\n    for (int i = 7; i < 64; i++) {\n        assertFalse(bs.get(i), \"Failed to clear bit \" + i);\n    }\n    for (int i = 64; i < bs.size(); i++) {\n        assertTrue(!bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // more boundary testing\n    bs = newInstance(32);\n    initialSize = bs.size();\n    bs.set(0, initialSize);\n    bs.clear(0, 64);\n    for (int i = 0; i < 64; i++) {\n        assertFalse(bs.get(i), \"Failed to clear bit \" + i);\n    }\n    for (int i = 64; i < bs.size(); i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    bs = newInstance(32);\n    initialSize = bs.size();\n    bs.set(0, initialSize);\n    bs.clear(0, 65);\n    for (int i = 0; i < 65; i++) {\n        assertFalse(bs.get(i), \"Failed to clear bit \" + i);\n    }\n    for (int i = 65; i < bs.size(); i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // pos1 and pos2 are in two sequential bitset elements\n    bs = newInstance(128);\n    initialSize = bs.size();\n    bs.set(0, initialSize);\n    bs.clear(7);\n    bs.clear(110);\n    bs.clear(9, 74);\n    for (int i = 0; i < 9; i++) {\n        if (i == 7) {\n            assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertTrue(bs.get(i), \"Shouldn't have cleared bit \" + i);\n        }\n    }\n    for (int i = 9; i < 74; i++) {\n        assertFalse(bs.get(i), \"Failed to clear bit \" + i);\n    }\n    for (int i = 74; i < initialSize; i++) {\n        if (i == 110) {\n            assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertTrue(bs.get(i), \"Shouldn't have cleared bit \" + i);\n        }\n    }\n    for (int i = initialSize; i < bs.size(); i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // pos1 and pos2 are in two non-sequential bitset elements\n    bs = newInstance(256);\n    bs.set(0, 256);\n    bs.clear(7);\n    bs.clear(255);\n    bs.clear(9, 219);\n    for (int i = 0; i < 9; i++) {\n        if (i == 7) {\n            assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertTrue(bs.get(i), \"Shouldn't have cleared bit \" + i);\n        }\n    }\n    for (int i = 9; i < 219; i++) {\n        assertFalse(bs.get(i), \"failed to clear bit \" + i);\n    }\n    for (int i = 219; i < 255; i++) {\n        assertTrue(bs.get(i), \"Shouldn't have cleared bit \" + i);\n    }\n    for (int i = 255; i < bs.size(); i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // test illegal args\n    bs = newInstance(10);\n    assertThrows(IndexOutOfBoundsException.class, () -> newInstance(10).clear(-1, 3), \"Test1: Attempt to flip with negative index failed to generate exception\");\n    assertThrows(IndexOutOfBoundsException.class, () -> newInstance(10).clear(2, -1), \"Test2: Attempt to flip with negative index failed to generate exception\");\n    bs.set(2, 4);\n    bs.clear(2, 2);\n    assertTrue(bs.get(2), \"Bit got cleared incorrectly \");\n    assertThrows(IndexOutOfBoundsException.class, () -> newInstance(10).clear(4, 2), \"Test4: Attempt to flip with illegal args failed to generate exception\");\n    bs = newInstance(0);\n    assertEquals(0, bs.length(), \"Test1: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test1: Wrong size,\");\n    bs.clear(0, 2);\n    assertEquals(0, bs.length(), \"Test2: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test2: Wrong size,\");\n    bs.clear(60, 64);\n    assertEquals(0, bs.length(), \"Test3: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test3: Wrong size,\");\n    bs.clear(64, 120);\n    assertEquals(0, bs.length(), \"Test4: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test4: Wrong size,\");\n    bs.set(25);\n    assertEquals(26, bs.length(), \"Test5: Wrong length,\");\n    assertEquals(64, bs.size(), \"Test5: Wrong size,\");\n    bs.clear(60, 64);\n    assertEquals(26, bs.length(), \"Test6: Wrong length,\");\n    assertEquals(64, bs.size(), \"Test6: Wrong size,\");\n    bs.clear(64, 120);\n    assertEquals(64, bs.size(), \"Test7: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test7: Wrong length,\");\n    bs.clear(80);\n    assertEquals(64, bs.size(), \"Test8: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test8: Wrong length,\");\n    bs.clear(25);\n    assertEquals(64, bs.size(), \"Test9: Wrong size,\");\n    assertEquals(0, bs.length(), \"Test9: Wrong length,\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#clear(int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1937, "method_signature": "void test_clearII()", "filename": "FluentBitSetTest.test_clearII.json"}
{"callee_method_ids": [749, 749, 749, 749, 749, 749, 751, 749, 749], "callee_method_names": ["FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.clear", "FluentBitSet.size", "FluentBitSet.length"], "method_name": "FluentBitSetTest.test_clearIntArray", "method_implementation": "{\n    // Test for method void java.util.BitSet.clear(int)\n    eightFbs.clear(new int[] { 7 });\n    assertFalse(eightFbs.get(7), \"Failed to clear bit\");\n    // Check to see all other bits are still set\n    for (int i = 0; i < 7; i++) {\n        assertTrue(eightFbs.get(i), \"Clear cleared incorrect bits\");\n    }\n    eightFbs.clear(165);\n    assertFalse(eightFbs.get(165), \"Failed to clear bit\");\n    // Try out of range\n    assertThrows(IndexOutOfBoundsException.class, () -> eightFbs.clear(-1));\n    final FluentBitSet bs = newInstance(0);\n    assertEquals(0, bs.length(), \"Test1: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test1: Wrong size,\");\n    bs.clear(new int[] { 0 });\n    assertEquals(0, bs.length(), \"Test2: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test2: Wrong size,\");\n    bs.clear(new int[] { 60 });\n    assertEquals(0, bs.length(), \"Test3: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test3: Wrong size,\");\n    bs.clear(new int[] { 120 });\n    assertEquals(0, bs.size(), \"Test4: Wrong size,\");\n    assertEquals(0, bs.length(), \"Test4: Wrong length,\");\n    bs.set(25);\n    assertEquals(64, bs.size(), \"Test5: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test5: Wrong length,\");\n    bs.clear(new int[] { 80 });\n    assertEquals(64, bs.size(), \"Test6: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test6: Wrong length,\");\n    bs.clear(new int[] { 25 });\n    assertEquals(64, bs.size(), \"Test7: Wrong size,\");\n    assertEquals(0, bs.length(), \"Test7: Wrong length,\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#clear(int...)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1938, "method_signature": "void test_clearIntArray()", "filename": "FluentBitSetTest.test_clearIntArray.json"}
{"callee_method_names": ["FluentBitSet.clone"], "method_name": "FluentBitSetTest.test_clone", "method_implementation": "{\n    final FluentBitSet bs = (FluentBitSet) eightFbs.clone();\n    assertEquals(bs, eightFbs, \"clone failed to return equal BitSet\");\n}", "repo_id": "8", "comment": "/**\n * Tests FluentBitSet#clone()\n */\n", "repo_name": "commons-lang-master/", "id": 1939, "method_signature": "void test_clone()", "filename": "FluentBitSetTest.test_clone.json"}
{"callee_method_ids": [749, 751, 749], "callee_method_names": ["FluentBitSet.clone", "FluentBitSet.clear", "FluentBitSet.equals", "FluentBitSet.equals", "FluentBitSet.equals", "FluentBitSet.clone", "FluentBitSet.set", "FluentBitSet.equals", "FluentBitSet.clear", "FluentBitSet.equals"], "method_name": "FluentBitSetTest.test_equals", "method_implementation": "{\n    FluentBitSet bs;\n    bs = (FluentBitSet) eightFbs.clone();\n    assertEquals(eightFbs, eightFbs, \"Same FluentBitSet returned false\");\n    assertEquals(bs, eightFbs, \"Identical FluentBitSet returned false\");\n    bs.clear(6);\n    assertFalse(eightFbs.equals(bs), \"Different BitSets returned true\");\n    assertFalse(eightFbs.equals(null), \"Different BitSets returned true\");\n    assertFalse(eightFbs.equals(new Object()), \"Different BitSets returned true\");\n    bs = (FluentBitSet) eightFbs.clone();\n    bs.set(128);\n    assertFalse(eightFbs.equals(bs), \"Different sized FluentBitSet with higher bit set returned true\");\n    bs.clear(128);\n    assertTrue(eightFbs.equals(bs), \"Different sized FluentBitSet with higher bits not set returned false\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#equals(java.lang.Object)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1942, "method_signature": "void test_equals()", "filename": "FluentBitSetTest.test_equals.json"}
{"callee_method_ids": [749, 749, 751, 751, 751, 749], "callee_method_names": ["FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.flip", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.flip", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.flip", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.flip", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.flip", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_flipI", "method_implementation": "{\n    // Test for method void java.util.BitSet.flip(int)\n    FluentBitSet bs = newInstance();\n    bs.clear(8);\n    bs.clear(9);\n    bs.set(10);\n    bs.flip(9);\n    assertFalse(bs.get(8), \"Failed to flip bit\");\n    assertTrue(bs.get(9), \"Failed to flip bit\");\n    assertTrue(bs.get(10), \"Failed to flip bit\");\n    bs.set(8);\n    bs.set(9);\n    bs.clear(10);\n    bs.flip(9);\n    assertTrue(bs.get(8), \"Failed to flip bit\");\n    assertFalse(bs.get(9), \"Failed to flip bit\");\n    assertFalse(bs.get(10), \"Failed to flip bit\");\n    assertThrows(IndexOutOfBoundsException.class, () -> newInstance().flip(-1), \"Attempt to flip at negative index failed to generate exception\");\n    // Try setting a bit on a 64 boundary\n    bs.flip(128);\n    assertEquals(192, bs.size(), \"Failed to grow BitSet\");\n    assertTrue(bs.get(128), \"Failed to flip bit\");\n    bs = newInstance(64);\n    for (int i = bs.size(); --i >= 0; ) {\n        bs.flip(i);\n        assertTrue(bs.get(i), \"Test1: Incorrectly flipped bit\" + i);\n        assertEquals(i + 1, bs.length(), \"Incorrect length\");\n        for (int j = bs.size(); --j > i; ) {\n            assertTrue(!bs.get(j), \"Test2: Incorrectly flipped bit\" + j);\n        }\n        for (int j = i; --j >= 0; ) {\n            assertTrue(!bs.get(j), \"Test3: Incorrectly flipped bit\" + j);\n        }\n        bs.flip(i);\n    }\n    final FluentBitSet bs0 = newInstance(0);\n    assertEquals(0, bs0.size(), \"Test1: Wrong size\");\n    assertEquals(0, bs0.length(), \"Test1: Wrong length\");\n    bs0.flip(0);\n    assertEquals(bs0.size(), 64, \"Test2: Wrong size\");\n    assertEquals(1, bs0.length(), \"Test2: Wrong length\");\n    bs0.flip(63);\n    assertEquals(64, bs0.size(), \"Test3: Wrong size\");\n    assertEquals(64, bs0.length(), \"Test3: Wrong length\");\n    eightFbs.flip(7);\n    assertTrue(!eightFbs.get(7), \"Failed to flip bit 7\");\n    // Check to see all other bits are still set\n    for (int i = 0; i < 7; i++) {\n        assertTrue(eightFbs.get(i), \"Flip flipped incorrect bits\");\n    }\n    eightFbs.flip(127);\n    assertTrue(eightFbs.get(127), \"Failed to flip bit 127\");\n    eightFbs.flip(127);\n    assertTrue(!eightFbs.get(127), \"Failed to flip bit 127\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#flip(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1943, "method_signature": "void test_flipI()", "filename": "FluentBitSetTest.test_flipI.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.flip", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.flip", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.flip", "FluentBitSet.flip", "FluentBitSet.flip"], "method_name": "FluentBitSetTest.test_flipII", "method_implementation": "{\n    final FluentBitSet bitset = newInstance();\n    for (int i = 0; i < 20; i++) {\n        bitset.set(i);\n    }\n    bitset.flip(10, 10);\n    // Test for method void java.util.BitSet.flip(int, int)\n    // pos1 and pos2 are in the same bitset element\n    FluentBitSet bs = newInstance(16);\n    bs.set(7);\n    bs.set(10);\n    bs.flip(7, 11);\n    for (int i = 0; i < 7; i++) {\n        assertTrue(!bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    assertFalse(bs.get(7), \"Failed to flip bit 7\");\n    assertTrue(bs.get(8), \"Failed to flip bit 8\");\n    assertTrue(bs.get(9), \"Failed to flip bit 9\");\n    assertFalse(bs.get(10), \"Failed to flip bit 10\");\n    for (int i = 11; i < bs.size(); i++) {\n        assertTrue(!bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // pos1 and pos2 is in the same bitset element, boundary testing\n    bs = newInstance(16);\n    bs.set(7);\n    bs.set(10);\n    bs.flip(7, 64);\n    assertEquals(64, bs.size(), \"Failed to grow BitSet\");\n    for (int i = 0; i < 7; i++) {\n        assertTrue(!bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    assertFalse(bs.get(7), \"Failed to flip bit 7\");\n    assertTrue(bs.get(8), \"Failed to flip bit 8\");\n    assertTrue(bs.get(9), \"Failed to flip bit 9\");\n    assertFalse(bs.get(10), \"Failed to flip bit 10\");\n    for (int i = 11; i < 64; i++) {\n        assertTrue(bs.get(i), \"failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(64), \"Shouldn't have flipped bit 64\");\n    // more boundary testing\n    bs = newInstance(32);\n    bs.flip(0, 64);\n    for (int i = 0; i < 64; i++) {\n        assertTrue(bs.get(i), \"Failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(64), \"Shouldn't have flipped bit 64\");\n    bs = newInstance(32);\n    bs.flip(0, 65);\n    for (int i = 0; i < 65; i++) {\n        assertTrue(bs.get(i), \"Failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(65), \"Shouldn't have flipped bit 65\");\n    // pos1 and pos2 are in two sequential bitset elements\n    bs = newInstance(128);\n    bs.set(7);\n    bs.set(10);\n    bs.set(72);\n    bs.set(110);\n    bs.flip(9, 74);\n    for (int i = 0; i < 7; i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    assertTrue(bs.get(7), \"Shouldn't have flipped bit 7\");\n    assertFalse(bs.get(8), \"Shouldn't have flipped bit 8\");\n    assertTrue(bs.get(9), \"Failed to flip bit 9\");\n    assertFalse(bs.get(10), \"Failed to flip bit 10\");\n    for (int i = 11; i < 72; i++) {\n        assertTrue(bs.get(i), \"failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(72), \"Failed to flip bit 72\");\n    assertTrue(bs.get(73), \"Failed to flip bit 73\");\n    for (int i = 74; i < 110; i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    assertTrue(bs.get(110), \"Shouldn't have flipped bit 110\");\n    for (int i = 111; i < bs.size(); i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // pos1 and pos2 are in two non-sequential bitset elements\n    bs = newInstance(256);\n    bs.set(7);\n    bs.set(10);\n    bs.set(72);\n    bs.set(110);\n    bs.set(181);\n    bs.set(220);\n    bs.flip(9, 219);\n    for (int i = 0; i < 7; i++) {\n        assertFalse(bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    assertTrue(bs.get(7), \"Shouldn't have flipped bit 7\");\n    assertFalse(bs.get(8), \"Shouldn't have flipped bit 8\");\n    assertTrue(bs.get(9), \"Failed to flip bit 9\");\n    assertFalse(bs.get(10), \"Failed to flip bit 10\");\n    for (int i = 11; i < 72; i++) {\n        assertTrue(bs.get(i), \"failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(72), \"Failed to flip bit 72\");\n    for (int i = 73; i < 110; i++) {\n        assertTrue(bs.get(i), \"failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(110), \"Failed to flip bit 110\");\n    for (int i = 111; i < 181; i++) {\n        assertTrue(bs.get(i), \"failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(181), \"Failed to flip bit 181\");\n    for (int i = 182; i < 219; i++) {\n        assertTrue(bs.get(i), \"failed to flip bit \" + i);\n    }\n    assertFalse(bs.get(219), \"Shouldn't have flipped bit 219\");\n    assertTrue(bs.get(220), \"Shouldn't have flipped bit 220\");\n    for (int i = 221; i < bs.size(); i++) {\n        assertTrue(!bs.get(i), \"Shouldn't have flipped bit \" + i);\n    }\n    // test illegal args\n    bs = newInstance(10);\n    try {\n        bs.flip(-1, 3);\n        fail(\"Test1: Attempt to flip with  negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // correct behavior\n    }\n    try {\n        bs.flip(2, -1);\n        fail(\"Test2: Attempt to flip with negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // correct behavior\n    }\n    try {\n        bs.flip(4, 2);\n        fail(\"Test4: Attempt to flip with illegal args failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // correct behavior\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#clear(int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1944, "method_signature": "void test_flipII()", "filename": "FluentBitSetTest.test_flipII.json"}
{"callee_method_ids": [751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size"], "method_name": "FluentBitSetTest.test_getI", "method_implementation": "{\n    // Test for method boolean java.util.BitSet.get(int)\n    FluentBitSet bs = newInstance();\n    bs.set(8);\n    assertFalse(eightFbs.get(99), \"Get returned true for index out of range\");\n    assertTrue(eightFbs.get(3), \"Get returned false for set value\");\n    assertFalse(bs.get(0), \"Get returned true for a non set value\");\n    assertThrows(IndexOutOfBoundsException.class, () -> newInstance().get(-1), \"Attempt to get at negative index failed to generate exception\");\n    bs = newInstance(1);\n    assertFalse(bs.get(64), \"Access greater than size\");\n    bs = newInstance();\n    bs.set(63);\n    assertTrue(bs.get(63), \"Test highest bit\");\n    bs = newInstance(0);\n    assertEquals(0, bs.length(), \"Test1: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test1: Wrong size,\");\n    bs.get(2);\n    assertEquals(0, bs.length(), \"Test2: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test2: Wrong size,\");\n    bs.get(70);\n    assertEquals(0, bs.length(), \"Test3: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test3: Wrong size,\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#get(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1945, "method_signature": "void test_getI()", "filename": "FluentBitSetTest.test_getI.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751], "callee_method_names": ["FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.flip", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.length", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.length"], "method_name": "FluentBitSetTest.test_getII", "method_implementation": "{\n    final FluentBitSet bitset = newInstance(30);\n    bitset.get(3, 3);\n    // Test for method boolean java.util.BitSet.get(int, int)\n    FluentBitSet bs, resultbs, correctbs;\n    bs = newInstance(512);\n    bs.set(3, 9);\n    bs.set(10, 20);\n    bs.set(60, 75);\n    bs.set(121);\n    bs.set(130, 140);\n    // pos1 and pos2 are in the same bitset element, at index0\n    resultbs = bs.get(3, 6);\n    correctbs = newInstance(3);\n    correctbs.set(0, 3);\n    assertEquals(correctbs, resultbs, \"Test1: Returned incorrect BitSet\");\n    // pos1 and pos2 are in the same bitset element, at index 1\n    resultbs = bs.get(100, 125);\n    correctbs = newInstance(25);\n    correctbs.set(21);\n    assertEquals(correctbs, resultbs, \"Test2: Returned incorrect BitSet\");\n    // pos1 in bitset element at index 0, and pos2 in bitset element at\n    // index 1\n    resultbs = bs.get(15, 125);\n    correctbs = newInstance(25);\n    correctbs.set(0, 5);\n    correctbs.set(45, 60);\n    correctbs.set(121 - 15);\n    assertEquals(correctbs, resultbs, \"Test3: Returned incorrect BitSet\");\n    // pos1 in bitset element at index 1, and pos2 in bitset element at\n    // index 2\n    resultbs = bs.get(70, 145);\n    correctbs = newInstance(75);\n    correctbs.set(0, 5);\n    correctbs.set(51);\n    correctbs.set(60, 70);\n    assertEquals(correctbs, resultbs, \"Test4: Returned incorrect BitSet\");\n    // pos1 in bitset element at index 0, and pos2 in bitset element at\n    // index 2\n    resultbs = bs.get(5, 145);\n    correctbs = newInstance(140);\n    correctbs.set(0, 4);\n    correctbs.set(5, 15);\n    correctbs.set(55, 70);\n    correctbs.set(116);\n    correctbs.set(125, 135);\n    assertEquals(correctbs, resultbs, \"Test5: Returned incorrect BitSet\");\n    // pos1 in bitset element at index 0, and pos2 in bitset element at\n    // index 3\n    resultbs = bs.get(5, 250);\n    correctbs = newInstance(200);\n    correctbs.set(0, 4);\n    correctbs.set(5, 15);\n    correctbs.set(55, 70);\n    correctbs.set(116);\n    correctbs.set(125, 135);\n    assertEquals(correctbs, resultbs, \"Test6: Returned incorrect BitSet\");\n    assertEquals(bs.get(0, bs.size()), bs, \"equality principle 1 \");\n    // more tests\n    FluentBitSet bs2 = newInstance(129);\n    bs2.set(0, 20);\n    bs2.set(62, 65);\n    bs2.set(121, 123);\n    resultbs = bs2.get(1, 124);\n    correctbs = newInstance(129);\n    correctbs.set(0, 19);\n    correctbs.set(61, 64);\n    correctbs.set(120, 122);\n    assertEquals(correctbs, resultbs, \"Test7: Returned incorrect BitSet\");\n    // equality principle with some boundary conditions\n    bs2 = newInstance(128);\n    bs2.set(2, 20);\n    bs2.set(62);\n    bs2.set(121, 123);\n    bs2.set(127);\n    resultbs = bs2.get(0, bs2.size());\n    assertEquals(resultbs, bs2, \"equality principle 2 \");\n    bs2 = newInstance(128);\n    bs2.set(2, 20);\n    bs2.set(62);\n    bs2.set(121, 123);\n    bs2.set(127);\n    bs2.flip(0, 128);\n    resultbs = bs2.get(0, bs.size());\n    assertEquals(resultbs, bs2, \"equality principle 3 \");\n    bs = newInstance(0);\n    assertEquals(0, bs.length(), \"Test1: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test1: Wrong size,\");\n    bs.get(0, 2);\n    assertEquals(0, bs.length(), \"Test2: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test2: Wrong size,\");\n    bs.get(60, 64);\n    assertEquals(0, bs.length(), \"Test3: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test3: Wrong size,\");\n    bs.get(64, 120);\n    assertEquals(0, bs.length(), \"Test4: Wrong length,\");\n    assertEquals(0, bs.size(), \"Test4: Wrong size,\");\n    bs.set(25);\n    assertEquals(26, bs.length(), \"Test5: Wrong length,\");\n    assertEquals(64, bs.size(), \"Test5: Wrong size,\");\n    bs.get(60, 64);\n    assertEquals(26, bs.length(), \"Test6: Wrong length,\");\n    assertEquals(64, bs.size(), \"Test6: Wrong size,\");\n    bs.get(64, 120);\n    assertEquals(64, bs.size(), \"Test7: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test7: Wrong length,\");\n    bs.get(80);\n    assertEquals(64, bs.size(), \"Test8: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test8: Wrong length,\");\n    bs.get(25);\n    assertEquals(64, bs.size(), \"Test9: Wrong size,\");\n    assertEquals(26, bs.length(), \"Test9: Wrong length,\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#get(int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1946, "method_signature": "void test_getII()", "filename": "FluentBitSetTest.test_getII.json"}
{"callee_method_ids": [749, 749, 751, 749], "callee_method_names": ["FluentBitSet.clone", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.bitSet", "FluentBitSet.hashCode", "FluentBitSet.set", "FluentBitSet.clear", "FluentBitSet.hashCode"], "method_name": "FluentBitSetTest.test_hashCode", "method_implementation": "{\n    // Test for method int java.util.BitSet.hashCode()\n    final FluentBitSet bs = (FluentBitSet) eightFbs.clone();\n    bs.clear(2);\n    bs.clear(6);\n    assertEquals(bs.bitSet().hashCode(), bs.hashCode(), \"BitSet returns wrong hash value\");\n    bs.set(10);\n    bs.clear(3);\n    assertEquals(97, bs.hashCode(), \"BitSet returns wrong hash value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#hashCode()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1947, "method_signature": "void test_hashCode()", "filename": "FluentBitSetTest.test_hashCode.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751, 751, 749, 751, 749, 751, 749, 751, 749, 751, 749, 751, 749, 751, 749, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.intersects"], "method_name": "FluentBitSetTest.test_intersects", "method_implementation": "{\n    // Test for method boolean java.util.BitSet.intersects(BitSet)\n    final FluentBitSet bs = newInstance(500);\n    bs.set(5);\n    bs.set(63);\n    bs.set(64);\n    bs.set(71, 110);\n    bs.set(127, 130);\n    bs.set(192);\n    bs.set(450);\n    final FluentBitSet bs2 = newInstance(8);\n    assertFalse(bs.intersects(bs2), \"Test1: intersects() returned incorrect value\");\n    assertFalse(bs2.intersects(bs), \"Test1: intersects() returned incorrect value\");\n    bs2.set(4);\n    assertFalse(bs.intersects(bs2), \"Test2: intersects() returned incorrect value\");\n    assertFalse(bs2.intersects(bs), \"Test2: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(5);\n    assertTrue(bs.intersects(bs2), \"Test3: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs), \"Test3: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(63);\n    assertTrue(bs.intersects(bs2), \"Test4: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs), \"Test4: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(80);\n    assertTrue(bs.intersects(bs2), \"Test5: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs), \"Test5: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(127);\n    assertTrue(bs.intersects(bs2), \"Test6: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs), \"Test6: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(192);\n    assertTrue(bs.intersects(bs2), \"Test7: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs), \"Test7: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(450);\n    assertTrue(bs.intersects(bs2), \"Test8: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs), \"Test8: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(500);\n    assertFalse(bs.intersects(bs2), \"Test9: intersects() returned incorrect value\");\n    assertFalse(bs2.intersects(bs), \"Test9: intersects() returned incorrect value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#intersects(FluentBitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1948, "method_signature": "void test_intersects()", "filename": "FluentBitSetTest.test_intersects.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751, 751, 749, 751, 749, 751, 749, 751, 749, 751, 749, 751, 749, 751, 749, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.intersects", "FluentBitSet.bitSet", "FluentBitSet.intersects", "FluentBitSet.bitSet"], "method_name": "FluentBitSetTest.test_intersects_BitSet", "method_implementation": "{\n    // Test for method boolean java.util.BitSet.intersects(BitSet)\n    final FluentBitSet bs = newInstance(500);\n    bs.set(5);\n    bs.set(63);\n    bs.set(64);\n    bs.set(71, 110);\n    bs.set(127, 130);\n    bs.set(192);\n    bs.set(450);\n    final FluentBitSet bs2 = newInstance(8);\n    assertFalse(bs.intersects(bs2.bitSet()), \"Test1: intersects() returned incorrect value\");\n    assertFalse(bs2.intersects(bs.bitSet()), \"Test1: intersects() returned incorrect value\");\n    bs2.set(4);\n    assertFalse(bs.intersects(bs2.bitSet()), \"Test2: intersects() returned incorrect value\");\n    assertFalse(bs2.intersects(bs.bitSet()), \"Test2: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(5);\n    assertTrue(bs.intersects(bs2.bitSet()), \"Test3: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs.bitSet()), \"Test3: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(63);\n    assertTrue(bs.intersects(bs2.bitSet()), \"Test4: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs.bitSet()), \"Test4: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(80);\n    assertTrue(bs.intersects(bs2.bitSet()), \"Test5: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs.bitSet()), \"Test5: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(127);\n    assertTrue(bs.intersects(bs2.bitSet()), \"Test6: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs.bitSet()), \"Test6: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(192);\n    assertTrue(bs.intersects(bs2.bitSet()), \"Test7: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs.bitSet()), \"Test7: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(450);\n    assertTrue(bs.intersects(bs2.bitSet()), \"Test8: intersects() returned incorrect value\");\n    assertTrue(bs2.intersects(bs.bitSet()), \"Test8: intersects() returned incorrect value\");\n    bs2.clear();\n    bs2.set(500);\n    assertFalse(bs.intersects(bs2.bitSet()), \"Test9: intersects() returned incorrect value\");\n    assertFalse(bs2.intersects(bs.bitSet()), \"Test9: intersects() returned incorrect value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#intersects(BitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1949, "method_signature": "void test_intersects_BitSet()", "filename": "FluentBitSetTest.test_intersects_BitSet.json"}
{"callee_method_ids": [751, 749, 751, 749, 751, 749, 751, 749, 751], "callee_method_names": ["FluentBitSet.isEmpty", "FluentBitSet.set", "FluentBitSet.isEmpty", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.isEmpty", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.isEmpty", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.isEmpty", "FluentBitSet.clear", "FluentBitSet.set", "FluentBitSet.isEmpty"], "method_name": "FluentBitSetTest.test_isEmpty", "method_implementation": "{\n    final FluentBitSet bs = newInstance(500);\n    assertTrue(bs.isEmpty(), \"Test: isEmpty() returned wrong value\");\n    // at bitset element 0\n    bs.set(3);\n    assertFalse(bs.isEmpty(), \"Test0: isEmpty() returned wrong value\");\n    // at bitset element 1\n    bs.clear();\n    bs.set(12);\n    assertFalse(bs.isEmpty(), \"Test1: isEmpty() returned wrong value\");\n    // at bitset element 2\n    bs.clear();\n    bs.set(128);\n    assertFalse(bs.isEmpty(), \"Test2: isEmpty() returned wrong value\");\n    // boundary testing\n    bs.clear();\n    bs.set(459);\n    assertFalse(bs.isEmpty(), \"Test3: isEmpty() returned wrong value\");\n    bs.clear();\n    bs.set(511);\n    assertFalse(bs.isEmpty(), \"Test4: isEmpty() returned wrong value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#isEmpty()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1950, "method_signature": "void test_isEmpty()", "filename": "FluentBitSetTest.test_isEmpty.json"}
{"callee_method_ids": [751, 751, 751, 751], "callee_method_names": ["FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.length"], "method_name": "FluentBitSetTest.test_length", "method_implementation": "{\n    final FluentBitSet bs = newInstance();\n    assertEquals(0, bs.length(), \"BitSet returned wrong length\");\n    bs.set(5);\n    assertEquals(6, bs.length(), \"BitSet returned wrong length\");\n    bs.set(10);\n    assertEquals(11, bs.length(), \"BitSet returned wrong length\");\n    bs.set(432);\n    assertEquals(433, bs.length(), \"BitSet returned wrong length\");\n    bs.set(300);\n    assertEquals(433, bs.length(), \"BitSet returned wrong length\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#length()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1951, "method_signature": "void test_length()", "filename": "FluentBitSetTest.test_length.json"}
{"callee_method_ids": [751, 751, 749, 749, 749, 749, 749, 749, 749, 749], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.clear", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit", "FluentBitSet.nextClearBit"], "method_name": "FluentBitSetTest.test_nextClearBitI", "method_implementation": "{\n    // Test for method int java.util.BitSet.nextSetBit()\n    final FluentBitSet bs = newInstance(500);\n    // ensure all the bits from 0 to bs.size()\n    bs.set(0, bs.size() - 1);\n    // -1\n    // are set to true\n    bs.set(bs.size() - 1);\n    bs.clear(5);\n    bs.clear(32);\n    bs.clear(63);\n    bs.clear(64);\n    bs.clear(71, 110);\n    bs.clear(127, 130);\n    bs.clear(193);\n    bs.clear(450);\n    try {\n        bs.nextClearBit(-1);\n        fail(\"Expected IndexOutOfBoundsException for negative index\");\n    } catch (final IndexOutOfBoundsException e) {\n        // correct behavior\n    }\n    assertEquals(5, bs.nextClearBit(0), \"nextClearBit() returned the wrong value\");\n    assertEquals(5, bs.nextClearBit(5), \"nextClearBit() returned the wrong value\");\n    assertEquals(32, bs.nextClearBit(6), \"nextClearBit() returned the wrong value\");\n    assertEquals(32, bs.nextClearBit(32), \"nextClearBit() returned the wrong value\");\n    assertEquals(63, bs.nextClearBit(33), \"nextClearBit() returned the wrong value\");\n    // boundary tests\n    assertEquals(63, bs.nextClearBit(63), \"nextClearBit() returned the wrong value\");\n    assertEquals(64, bs.nextClearBit(64), \"nextClearBit() returned the wrong value\");\n    // at bitset element 1\n    assertEquals(71, bs.nextClearBit(65), \"nextClearBit() returned the wrong value\");\n    assertEquals(71, bs.nextClearBit(71), \"nextClearBit() returned the wrong value\");\n    assertEquals(72, bs.nextClearBit(72), \"nextClearBit() returned the wrong value\");\n    assertEquals(127, bs.nextClearBit(110), \"nextClearBit() returned the wrong value\");\n    // boundary tests\n    assertEquals(127, bs.nextClearBit(127), \"nextClearBit() returned the wrong value\");\n    assertEquals(128, bs.nextClearBit(128), \"nextClearBit() returned the wrong value\");\n    // at bitset element 2\n    assertEquals(193, bs.nextClearBit(130), \"nextClearBit() returned the wrong value\");\n    assertEquals(193, bs.nextClearBit(191), \"nextClearBit() returned the wrong value\");\n    assertEquals(193, bs.nextClearBit(192), \"nextClearBit() returned the wrong value\");\n    assertEquals(193, bs.nextClearBit(193), \"nextClearBit() returned the wrong value\");\n    assertEquals(450, bs.nextClearBit(194), \"nextClearBit() returned the wrong value\");\n    assertEquals(450, bs.nextClearBit(255), \"nextClearBit() returned the wrong value\");\n    assertEquals(450, bs.nextClearBit(256), \"nextClearBit() returned the wrong value\");\n    assertEquals(450, bs.nextClearBit(450), \"nextClearBit() returned the wrong value\");\n    // bitset has 1 still the end of bs.size() -1, but calling nextClearBit\n    // with any index value\n    // after the last true bit should return bs.size(),\n    assertEquals(512, bs.nextClearBit(451), \"nextClearBit() returned the wrong value\");\n    assertEquals(512, bs.nextClearBit(511), \"nextClearBit() returned the wrong value\");\n    assertEquals(512, bs.nextClearBit(512), \"nextClearBit() returned the wrong value\");\n    // if the index is larger than bs.size(), nextClearBit should return\n    // index;\n    assertEquals(513, bs.nextClearBit(513), \"nextClearBit() returned the wrong value\");\n    assertEquals(800, bs.nextClearBit(800), \"nextClearBit() returned the wrong value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#nextClearBit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1952, "method_signature": "void test_nextClearBitI()", "filename": "FluentBitSetTest.test_nextClearBitI.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit", "FluentBitSet.nextSetBit"], "method_name": "FluentBitSetTest.test_nextSetBitI", "method_implementation": "{\n    // Test for method int java.util.BitSet.nextSetBit()\n    final FluentBitSet bs = newInstance(500);\n    bs.set(5);\n    bs.set(32);\n    bs.set(63);\n    bs.set(64);\n    bs.set(71, 110);\n    bs.set(127, 130);\n    bs.set(193);\n    bs.set(450);\n    try {\n        bs.nextSetBit(-1);\n        fail(\"Expected IndexOutOfBoundsException for negative index\");\n    } catch (final IndexOutOfBoundsException e) {\n        // correct behavior\n    }\n    assertEquals(5, bs.nextSetBit(0), \"nextSetBit() returned the wrong value\");\n    assertEquals(5, bs.nextSetBit(5), \"nextSetBit() returned the wrong value\");\n    assertEquals(32, bs.nextSetBit(6), \"nextSetBit() returned the wrong value\");\n    assertEquals(32, bs.nextSetBit(32), \"nextSetBit() returned the wrong value\");\n    assertEquals(63, bs.nextSetBit(33), \"nextSetBit() returned the wrong value\");\n    // boundary tests\n    assertEquals(63, bs.nextSetBit(63), \"nextSetBit() returned the wrong value\");\n    assertEquals(64, bs.nextSetBit(64), \"nextSetBit() returned the wrong value\");\n    // at bitset element 1\n    assertEquals(71, bs.nextSetBit(65), \"nextSetBit() returned the wrong value\");\n    assertEquals(71, bs.nextSetBit(71), \"nextSetBit() returned the wrong value\");\n    assertEquals(72, bs.nextSetBit(72), \"nextSetBit() returned the wrong value\");\n    assertEquals(127, bs.nextSetBit(110), \"nextSetBit() returned the wrong value\");\n    // boundary tests\n    assertEquals(127, bs.nextSetBit(127), \"nextSetBit() returned the wrong value\");\n    assertEquals(128, bs.nextSetBit(128), \"nextSetBit() returned the wrong value\");\n    // at bitset element 2\n    assertEquals(193, bs.nextSetBit(130), \"nextSetBit() returned the wrong value\");\n    assertEquals(193, bs.nextSetBit(191), \"nextSetBit() returned the wrong value\");\n    assertEquals(193, bs.nextSetBit(192), \"nextSetBit() returned the wrong value\");\n    assertEquals(193, bs.nextSetBit(193), \"nextSetBit() returned the wrong value\");\n    assertEquals(450, bs.nextSetBit(194), \"nextSetBit() returned the wrong value\");\n    assertEquals(450, bs.nextSetBit(255), \"nextSetBit() returned the wrong value\");\n    assertEquals(450, bs.nextSetBit(256), \"nextSetBit() returned the wrong value\");\n    assertEquals(450, bs.nextSetBit(450), \"nextSetBit() returned the wrong value\");\n    assertEquals(-1, bs.nextSetBit(451), \"nextSetBit() returned the wrong value\");\n    assertEquals(-1, bs.nextSetBit(511), \"nextSetBit() returned the wrong value\");\n    assertEquals(-1, bs.nextSetBit(512), \"nextSetBit() returned the wrong value\");\n    assertEquals(-1, bs.nextSetBit(800), \"nextSetBit() returned the wrong value\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#nextSetBit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1953, "method_signature": "void test_nextSetBitI()", "filename": "FluentBitSetTest.test_nextSetBitI.json"}
{"callee_method_ids": [750, 750, 749, 750], "callee_method_names": ["FluentBitSet.or", "FluentBitSet.get", "FluentBitSet.or", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.or", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_or", "method_implementation": "{\n    // Test for method void java.util.BitSet.or(BitSet)\n    FluentBitSet bs = newInstance(128);\n    bs.or(eightFbs);\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"OR failed to set bits\");\n    }\n    bs = newInstance(0);\n    bs.or(eightFbs);\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"OR(0) failed to set bits\");\n    }\n    eightFbs.clear(5);\n    bs = newInstance(128);\n    bs.or(eightFbs);\n    assertFalse(bs.get(5), \"OR set a bit which should be off\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#or(FluentBitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1954, "method_signature": "void test_or()", "filename": "FluentBitSetTest.test_or.json"}
{"callee_method_ids": [750, 750, 749, 750], "callee_method_names": ["FluentBitSet.or", "FluentBitSet.bitSet", "FluentBitSet.get", "FluentBitSet.or", "FluentBitSet.bitSet", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.or", "FluentBitSet.bitSet", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_or_BitSet", "method_implementation": "{\n    // Test for method void java.util.BitSet.or(BitSet)\n    FluentBitSet bs = newInstance(128);\n    bs.or(eightFbs.bitSet());\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"OR failed to set bits\");\n    }\n    bs = newInstance(0);\n    bs.or(eightFbs.bitSet());\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"OR(0) failed to set bits\");\n    }\n    eightFbs.clear(5);\n    bs = newInstance(128);\n    bs.or(eightFbs.bitSet());\n    assertFalse(bs.get(5), \"OR set a bit which should be off\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#or(BitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1955, "method_signature": "void test_or_BitSet()", "filename": "FluentBitSetTest.test_or_BitSet.json"}
{"callee_method_ids": [750, 750, 749, 750], "callee_method_names": ["FluentBitSet.or", "FluentBitSet.get", "FluentBitSet.or", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.or", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_or_FluentBitSetArray", "method_implementation": "{\n    // Test for method void java.util.BitSet.or(BitSet)\n    FluentBitSet bs = newInstance(128);\n    bs.or(new FluentBitSet[] { eightFbs });\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"OR failed to set bits\");\n    }\n    bs = newInstance(0);\n    bs.or(new FluentBitSet[] { eightFbs });\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"OR(0) failed to set bits\");\n    }\n    eightFbs.clear(5);\n    bs = newInstance(128);\n    bs.or(new FluentBitSet[] { eightFbs });\n    assertFalse(bs.get(5), \"OR set a bit which should be off\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#or(FluentBitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1956, "method_signature": "void test_or_FluentBitSetArray()", "filename": "FluentBitSetTest.test_or_FluentBitSetArray.json"}
{"callee_method_names": ["FluentBitSet.previousClearBit"], "method_name": "FluentBitSetTest.test_previousClearBit", "method_implementation": "{\n    final FluentBitSet bs = newInstance();\n    assertEquals(1, bs.previousClearBit(1), \"previousClearBit\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#previousClearBit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1957, "method_signature": "void test_previousClearBit()", "filename": "FluentBitSetTest.test_previousClearBit.json"}
{"callee_method_names": ["FluentBitSet.previousSetBit"], "method_name": "FluentBitSetTest.test_previousSetBit", "method_implementation": "{\n    final FluentBitSet bs = newInstance();\n    assertEquals(-1, bs.previousSetBit(1), \"previousSetBit\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#previousSetBit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1958, "method_signature": "void test_previousSetBit()", "filename": "FluentBitSetTest.test_previousSetBit.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set"], "method_name": "FluentBitSetTest.test_setII", "method_implementation": "{\n    final FluentBitSet bitset = newInstance(30);\n    bitset.set(29, 29);\n    // Test for method void java.util.BitSet.set(int, int)\n    // pos1 and pos2 are in the same bitset element\n    FluentBitSet bs = newInstance(16);\n    bs.set(5);\n    bs.set(15);\n    bs.set(7, 11);\n    for (int i = 0; i < 7; i++) {\n        if (i == 5) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    for (int i = 7; i < 11; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    for (int i = 11; i < bs.size(); i++) {\n        if (i == 15) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    // pos1 and pos2 is in the same bitset element, boundary testing\n    bs = newInstance(16);\n    bs.set(7, 64);\n    assertEquals(64, bs.size(), \"Failed to grow BitSet\");\n    for (int i = 0; i < 7; i++) {\n        assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n    }\n    for (int i = 7; i < 64; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    assertFalse(bs.get(64), \"Shouldn't have set bit 64\");\n    // more boundary testing\n    bs = newInstance(32);\n    bs.set(0, 64);\n    for (int i = 0; i < 64; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    assertFalse(bs.get(64), \"Shouldn't have set bit 64\");\n    bs = newInstance(32);\n    bs.set(0, 65);\n    for (int i = 0; i < 65; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    assertFalse(bs.get(65), \"Shouldn't have set bit 65\");\n    // pos1 and pos2 are in two sequential bitset elements\n    bs = newInstance(128);\n    bs.set(7);\n    bs.set(110);\n    bs.set(9, 74);\n    for (int i = 0; i < 9; i++) {\n        if (i == 7) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    for (int i = 9; i < 74; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    for (int i = 74; i < bs.size(); i++) {\n        if (i == 110) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    // pos1 and pos2 are in two non-sequential bitset elements\n    bs = newInstance(256);\n    bs.set(7);\n    bs.set(255);\n    bs.set(9, 219);\n    for (int i = 0; i < 9; i++) {\n        if (i == 7) {\n            assertTrue(bs.get(i), \"Shouldn't have set flipped \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    for (int i = 9; i < 219; i++) {\n        assertTrue(bs.get(i), \"failed to set bit \" + i);\n    }\n    for (int i = 219; i < 255; i++) {\n        assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n    }\n    assertTrue(bs.get(255), \"Shouldn't have flipped bit 255\");\n    // test illegal args\n    bs = newInstance(10);\n    try {\n        bs.set(-1, 3);\n        fail(\"Test1: Attempt to flip with  negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n    try {\n        bs.set(2, -1);\n        fail(\"Test2: Attempt to flip with negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n    bs.set(2, 2);\n    assertFalse(bs.get(2), \"Bit got set incorrectly \");\n    try {\n        bs.set(4, 2);\n        fail(\"Test4: Attempt to flip with illegal args failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#set(int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1959, "method_signature": "void test_setII()", "filename": "FluentBitSetTest.test_setII.json"}
{"callee_method_ids": [751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_setIIZ", "method_implementation": "{\n    // Test for method void java.util.BitSet.set(int, int, boolean)\n    eightFbs.set(3, 6, false);\n    assertTrue(!eightFbs.get(3) && !eightFbs.get(4) && !eightFbs.get(5), \"Should have set bits 3, 4, and 5 to false\");\n    eightFbs.set(3, 6, true);\n    assertTrue(eightFbs.get(3) && eightFbs.get(4) && eightFbs.get(5), \"Should have set bits 3, 4, and 5 to true\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#set(int, int, boolean)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1960, "method_signature": "void test_setIIZ()", "filename": "FluentBitSetTest.test_setIIZ.json"}
{"callee_method_ids": [751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.get"], "method_name": "FluentBitSetTest.test_setIZ", "method_implementation": "{\n    // Test for method void java.util.BitSet.set(int, boolean)\n    eightFbs.set(5, false);\n    assertFalse(eightFbs.get(5), \"Should have set bit 5 to true\");\n    eightFbs.set(5, true);\n    assertTrue(eightFbs.get(5), \"Should have set bit 5 to false\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#set(int, boolean)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1964, "method_signature": "void test_setIZ()", "filename": "FluentBitSetTest.test_setIZ.json"}
{"callee_method_ids": [751, 751, 751, 751, 751, 751, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.setInclusive", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.setInclusive", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.setInclusive", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.setInclusive", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.setInclusive", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.setInclusive", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.setInclusive", "FluentBitSet.setInclusive", "FluentBitSet.setInclusive", "FluentBitSet.get", "FluentBitSet.setInclusive"], "method_name": "FluentBitSetTest.test_setInclusive", "method_implementation": "{\n    final FluentBitSet bitset = newInstance(30);\n    bitset.set(29, 29);\n    // Test for method void java.util.BitSet.set(int, int)\n    // pos1 and pos2 are in the same bitset element\n    FluentBitSet bs = newInstance(16);\n    bs.set(5);\n    bs.set(15);\n    bs.setInclusive(7, 11);\n    for (int i = 0; i < 7; i++) {\n        if (i == 5) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    for (int i = 7; i < 12; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    for (int i = 12; i < bs.size(); i++) {\n        if (i == 15) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    // pos1 and pos2 is in the same bitset element, boundary testing\n    bs = newInstance(16);\n    bs.setInclusive(7, 64);\n    assertEquals(128, bs.size(), \"Failed to grow BitSet\");\n    for (int i = 0; i < 7; i++) {\n        assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n    }\n    for (int i = 7; i < 65; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    assertFalse(bs.get(65), \"Shouldn't have set bit 64\");\n    // more boundary testing\n    bs = newInstance(32);\n    bs.setInclusive(0, 64);\n    for (int i = 0; i < 65; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    assertFalse(bs.get(65), \"Shouldn't have set bit 64\");\n    bs = newInstance(32);\n    bs.setInclusive(0, 65);\n    for (int i = 0; i < 66; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    assertFalse(bs.get(66), \"Shouldn't have set bit 65\");\n    // pos1 and pos2 are in two sequential bitset elements\n    bs = newInstance(128);\n    bs.set(7);\n    bs.set(110);\n    bs.setInclusive(9, 74);\n    for (int i = 0; i < 9; i++) {\n        if (i == 7) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    for (int i = 9; i < 75; i++) {\n        assertTrue(bs.get(i), \"Failed to set bit \" + i);\n    }\n    for (int i = 75; i < bs.size(); i++) {\n        if (i == 110) {\n            assertTrue(bs.get(i), \"Shouldn't have flipped bit \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    // pos1 and pos2 are in two non-sequential bitset elements\n    bs = newInstance(256);\n    bs.set(7);\n    bs.set(255);\n    bs.setInclusive(9, 219);\n    for (int i = 0; i < 9; i++) {\n        if (i == 7) {\n            assertTrue(bs.get(i), \"Shouldn't have set flipped \" + i);\n        } else {\n            assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n        }\n    }\n    for (int i = 9; i < 220; i++) {\n        assertTrue(bs.get(i), \"failed to set bit \" + i);\n    }\n    for (int i = 220; i < 255; i++) {\n        assertFalse(bs.get(i), \"Shouldn't have set bit \" + i);\n    }\n    assertTrue(bs.get(255), \"Shouldn't have flipped bit 255\");\n    // test illegal args\n    bs = newInstance(10);\n    try {\n        bs.setInclusive(-1, 3);\n        fail(\"Test1: Attempt to flip with  negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n    try {\n        bs.setInclusive(2, -1);\n        fail(\"Test2: Attempt to flip with negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n    bs.setInclusive(2, 2);\n    assertFalse(bs.get(3), \"Bit got set incorrectly \");\n    try {\n        bs.setInclusive(4, 2);\n        fail(\"Test4: Attempt to flip with illegal args failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#setInclusive(int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1961, "method_signature": "void test_setInclusive()", "filename": "FluentBitSetTest.test_setInclusive.json"}
{"callee_method_ids": [751, 751, 751, 751, 749, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.length"], "method_name": "FluentBitSetTest.test_setInt", "method_implementation": "{\n    // Test for method void java.util.BitSet.set(int)\n    FluentBitSet bs = newInstance();\n    bs.set(8);\n    assertTrue(bs.get(8), \"Failed to set bit\");\n    try {\n        bs.set(-1);\n        fail(\"Attempt to set at negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n    // Try setting a bit on a 64 boundary\n    bs.set(128);\n    assertEquals(192, bs.size(), \"Failed to grow BitSet\");\n    assertTrue(bs.get(128), \"Failed to set bit\");\n    bs = newInstance(64);\n    for (int i = bs.size(); --i >= 0; ) {\n        bs.set(i);\n        assertTrue(bs.get(i), \"Incorrectly set\");\n        assertEquals(i + 1, bs.length(), \"Incorrect length\");\n        for (int j = bs.size(); --j > i; ) {\n            assertFalse(bs.get(j), \"Incorrectly set bit \" + j);\n        }\n        for (int j = i; --j >= 0; ) {\n            assertFalse(bs.get(j), \"Incorrectly set bit \" + j);\n        }\n        bs.clear(i);\n    }\n    bs = newInstance(0);\n    assertEquals(0, bs.length(), \"Test1: Wrong length\");\n    bs.set(0);\n    assertEquals(1, bs.length(), \"Test2: Wrong length\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#set(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1962, "method_signature": "void test_setInt()", "filename": "FluentBitSetTest.test_setInt.json"}
{"callee_method_ids": [751, 751, 751, 751, 749, 751], "callee_method_names": ["FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.set", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.get", "FluentBitSet.length", "FluentBitSet.size", "FluentBitSet.get", "FluentBitSet.get", "FluentBitSet.clear", "FluentBitSet.length", "FluentBitSet.set", "FluentBitSet.length"], "method_name": "FluentBitSetTest.test_setIntArray", "method_implementation": "{\n    // Test for method void java.util.BitSet.set(int)\n    FluentBitSet bs = newInstance();\n    bs.set(new int[] { 8 });\n    assertTrue(bs.get(8), \"Failed to set bit\");\n    try {\n        bs.set(new int[] { -1 });\n        fail(\"Attempt to set at negative index failed to generate exception\");\n    } catch (final IndexOutOfBoundsException e) {\n        // Correct behavior\n    }\n    // Try setting a bit on a 64 boundary\n    bs.set(new int[] { 128 });\n    assertEquals(192, bs.size(), \"Failed to grow BitSet\");\n    assertTrue(bs.get(128), \"Failed to set bit\");\n    bs = newInstance(64);\n    for (int i = bs.size(); --i >= 0; ) {\n        bs.set(new int[] { i });\n        assertTrue(bs.get(i), \"Incorrectly set\");\n        assertEquals(i + 1, bs.length(), \"Incorrect length\");\n        for (int j = bs.size(); --j > i; ) {\n            assertFalse(bs.get(j), \"Incorrectly set bit \" + j);\n        }\n        for (int j = i; --j >= 0; ) {\n            assertFalse(bs.get(j), \"Incorrectly set bit \" + j);\n        }\n        bs.clear(i);\n    }\n    bs = newInstance(0);\n    assertEquals(0, bs.length(), \"Test1: Wrong length\");\n    bs.set(new int[] { 0 });\n    assertEquals(1, bs.length(), \"Test2: Wrong length\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#set(int...)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1963, "method_signature": "void test_setIntArray()", "filename": "FluentBitSetTest.test_setIntArray.json"}
{"callee_method_ids": [751], "callee_method_names": ["FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.size"], "method_name": "FluentBitSetTest.test_setRangeInclusive", "method_implementation": "{\n    // Test for method int java.util.BitSet.size()\n    assertEquals(64, eightFbs.size(), \"Returned incorrect size\");\n    eightFbs.set(129);\n    assertTrue(eightFbs.size() >= 129, \"Returned incorrect size\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#setInclusive(int, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1965, "method_signature": "void test_setRangeInclusive()", "filename": "FluentBitSetTest.test_setRangeInclusive.json"}
{"callee_method_ids": [751], "callee_method_names": ["FluentBitSet.size", "FluentBitSet.set", "FluentBitSet.size"], "method_name": "FluentBitSetTest.test_size", "method_implementation": "{\n    // Test for method int java.util.BitSet.size()\n    assertEquals(64, eightFbs.size(), \"Returned incorrect size\");\n    eightFbs.set(129);\n    assertTrue(eightFbs.size() >= 129, \"Returned incorrect size\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#size()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1966, "method_signature": "void test_size()", "filename": "FluentBitSetTest.test_size.json"}
{"callee_method_names": ["FluentBitSet.stream"], "method_name": "FluentBitSetTest.test_stream", "method_implementation": "{\n    final FluentBitSet bs = newInstance();\n    assertEquals(0, bs.stream().count(), \"stream\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#previousSetBit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1967, "method_signature": "void test_stream()", "filename": "FluentBitSetTest.test_stream.json"}
{"callee_method_names": ["FluentBitSet.toByteArray"], "method_name": "FluentBitSetTest.test_toByteArray", "method_implementation": "{\n    final FluentBitSet bs = newInstance();\n    assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, bs.toByteArray(), \"stream\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#previousSetBit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1968, "method_signature": "void test_toByteArray()", "filename": "FluentBitSetTest.test_toByteArray.json"}
{"callee_method_names": ["FluentBitSet.toLongArray"], "method_name": "FluentBitSetTest.test_toLongArray", "method_implementation": "{\n    final FluentBitSet bs = newInstance();\n    assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, bs.toLongArray(), \"stream\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#previousSetBit(int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1969, "method_signature": "void test_toLongArray()", "filename": "FluentBitSetTest.test_toLongArray.json"}
{"callee_method_ids": [749], "callee_method_names": ["FluentBitSet.toString", "FluentBitSet.clear", "FluentBitSet.toString"], "method_name": "FluentBitSetTest.test_toString", "method_implementation": "{\n    // Test for method java.lang.String java.util.BitSet.toString()\n    assertEquals(\"{0, 1, 2, 3, 4, 5, 6, 7}\", eightFbs.toString(), \"Returned incorrect string representation\");\n    eightFbs.clear(2);\n    assertEquals(\"{0, 1, 3, 4, 5, 6, 7}\", eightFbs.toString(), \"Returned incorrect string representation\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#toString()}.\n */\n", "repo_name": "commons-lang-master/", "id": 1970, "method_signature": "void test_toString()", "filename": "FluentBitSetTest.test_toString.json"}
{"callee_method_ids": [751], "callee_method_names": ["FluentBitSet.clone", "FluentBitSet.xor", "FluentBitSet.get", "FluentBitSet.xor", "FluentBitSet.get", "FluentBitSet.xor", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.toString"], "method_name": "FluentBitSetTest.test_xor", "method_implementation": "{\n    // Test for method void java.util.BitSet.xor(BitSet)\n    FluentBitSet bs = (FluentBitSet) eightFbs.clone();\n    bs.xor(eightFbs);\n    for (int i = 0; i < 8; i++) {\n        assertFalse(bs.get(i), \"XOR failed to clear bits\");\n    }\n    bs.xor(eightFbs);\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"XOR failed to set bits\");\n    }\n    bs = newInstance(0);\n    bs.xor(eightFbs);\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"XOR(0) failed to set bits\");\n    }\n    bs = newInstance();\n    bs.set(63);\n    assertEquals(\"{63}\", bs.toString(), \"Test highest bit\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#xor(FluentBitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1971, "method_signature": "void test_xor()", "filename": "FluentBitSetTest.test_xor.json"}
{"callee_method_ids": [751], "callee_method_names": ["FluentBitSet.clone", "FluentBitSet.xor", "FluentBitSet.bitSet", "FluentBitSet.get", "FluentBitSet.xor", "FluentBitSet.bitSet", "FluentBitSet.get", "FluentBitSet.xor", "FluentBitSet.bitSet", "FluentBitSet.get", "FluentBitSet.set", "FluentBitSet.toString"], "method_name": "FluentBitSetTest.test_xor_BitSet", "method_implementation": "{\n    // Test for method void java.util.BitSet.xor(BitSet)\n    FluentBitSet bs = (FluentBitSet) eightFbs.clone();\n    bs.xor(eightFbs.bitSet());\n    for (int i = 0; i < 8; i++) {\n        assertFalse(bs.get(i), \"XOR failed to clear bits\");\n    }\n    bs.xor(eightFbs.bitSet());\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"XOR failed to set bits\");\n    }\n    bs = newInstance(0);\n    bs.xor(eightFbs.bitSet());\n    for (int i = 0; i < 8; i++) {\n        assertTrue(bs.get(i), \"XOR(0) failed to set bits\");\n    }\n    bs = newInstance();\n    bs.set(63);\n    assertEquals(\"{63}\", bs.toString(), \"Test highest bit\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link FluentBitSet#xor(BitSet)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1972, "method_signature": "void test_xor_BitSet()", "filename": "FluentBitSetTest.test_xor_BitSet.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "StringBuilder.replace", "CharSequence.length", "CharSequence.length", "CharSequence.toString", "StringBuilder.length", "StringBuilder.insert", "Formatter.format", "StringBuilder.toString"], "method_name": "FormattableUtils.append", "method_implementation": "{\n    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, \"Specified ellipsis '%1$s' exceeds precision of %2$s\", ellipsis, Integer.valueOf(precision));\n    final StringBuilder buf = new StringBuilder(seq);\n    if (precision >= 0 && precision < seq.length()) {\n        final CharSequence actualEllipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);\n        buf.replace(precision - actualEllipsis.length(), seq.length(), actualEllipsis.toString());\n    }\n    final boolean leftJustify = (flags & FormattableFlags.LEFT_JUSTIFY) == FormattableFlags.LEFT_JUSTIFY;\n    for (int i = buf.length(); i < width; i++) {\n        buf.insert(leftJustify ? i : 0, padChar);\n    }\n    formatter.format(buf.toString());\n    return formatter;\n}", "repo_id": "8", "comment": "/**\n * Handles the common {@link Formattable} operations of truncate-pad-append.\n *\n * @param seq  the string to handle, not null\n * @param formatter  the destination formatter, not null\n * @param flags  the flags for formatting, see {@link Formattable}\n * @param width  the width of the output, see {@link Formattable}\n * @param precision  the precision of the output, see {@link Formattable}\n * @param padChar  the pad character to use\n * @param ellipsis  the ellipsis to use when precision dictates truncation, null or\n *  empty causes a hard truncation\n * @return the {@code formatter} instance, not null\n */\n", "repo_name": "commons-lang-master/", "id": 437, "method_signature": "Formatter append(CharSequence, Formatter, int, int, int, char, CharSequence)", "filename": "FormattableUtils.append.json"}
{"callee_method_names": [], "method_name": "Fraction.abs", "method_implementation": "{\n    if (numerator >= 0) {\n        return this;\n    }\n    return negate();\n}", "repo_id": "8", "comment": "/**\n * Gets a fraction that is the positive equivalent of this one.\n * <p>More precisely: {@code (fraction &gt;= 0 ? this : -fraction)}</p>\n *\n * <p>The returned fraction is not reduced.</p>\n *\n * @return {@code this} if it is positive, or a new positive fraction\n *  instance with the opposite signed numerator\n */\n", "repo_name": "commons-lang-master/", "id": 228, "method_signature": "Fraction abs()", "filename": "Fraction.abs.json"}
{"callee_method_names": [], "method_name": "Fraction.addAndCheck", "method_implementation": "{\n    final long s = (long) x + (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new ArithmeticException(\"overflow: add\");\n    }\n    return (int) s;\n}", "repo_id": "8", "comment": "/**\n * Add two integers, checking for overflow.\n *\n * @param x an addend\n * @param y an addend\n * @return the sum {@code x+y}\n * @throws ArithmeticException if the result can not be represented as\n * an int\n */\n", "repo_name": "commons-lang-master/", "id": 218, "method_signature": "int addAndCheck(int, int)", "filename": "Fraction.addAndCheck.json"}
{"callee_method_ids": [236], "callee_method_names": ["Fraction.negate", "BigInteger.add", "BigInteger.subtract", "BigInteger.mod", "BigInteger.divide", "BigInteger.bitLength", "BigInteger.intValue"], "method_name": "Fraction.addSub", "method_implementation": "{\n    Objects.requireNonNull(fraction, \"fraction\");\n    // zero is identity for addition.\n    if (numerator == 0) {\n        return isAdd ? fraction : fraction.negate();\n    }\n    if (fraction.numerator == 0) {\n        return this;\n    }\n    // if denominators are randomly distributed, d1 will be 1 about 61%\n    // of the time.\n    final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n    if (d1 == 1) {\n        // result is ( (u*v' +/- u'v) / u'v')\n        final int uvp = mulAndCheck(numerator, fraction.denominator);\n        final int upv = mulAndCheck(fraction.numerator, denominator);\n        return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator));\n    }\n    // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n    // exercise 7. we're going to use a BigInteger.\n    // t = u(v'/d1) +/- v(u'/d1)\n    final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1));\n    final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1));\n    final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n    // but d2 doesn't need extra precision because\n    // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n    final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n    final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1);\n    // result is (t/d2) / (u'/d1)(v'/d2)\n    final BigInteger w = t.divide(BigInteger.valueOf(d2));\n    if (w.bitLength() > 31) {\n        throw new ArithmeticException(\"overflow: numerator too large after multiply\");\n    }\n    return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2));\n}", "repo_id": "8", "comment": "/**\n * Implement add and subtract using algorithm described in Knuth 4.5.1.\n *\n * @param fraction the fraction to subtract, must not be {@code null}\n * @param isAdd true to add, false to subtract\n * @return a {@link Fraction} instance with the resulting values\n * @throws IllegalArgumentException if the fraction is {@code null}\n * @throws ArithmeticException if the resulting numerator or denominator\n *   cannot be represented in an {@code int}.\n */\n", "repo_name": "commons-lang-master/", "id": 229, "method_signature": "Fraction addSub(Fraction, boolean)", "filename": "Fraction.addSub.json"}
{"callee_method_names": [], "method_name": "Fraction.compareTo", "method_implementation": "{\n    if (this == other) {\n        return 0;\n    }\n    if (numerator == other.numerator && denominator == other.denominator) {\n        return 0;\n    }\n    // otherwise see which is less\n    final long first = (long) numerator * (long) other.denominator;\n    final long second = (long) other.numerator * (long) denominator;\n    return Long.compare(first, second);\n}", "repo_id": "8", "comment": "/**\n * Compares this object to another based on size.\n *\n * <p>Note: this class has a natural ordering that is inconsistent\n * with equals, because, for example, equals treats 1/2 and 2/4 as\n * different, whereas compareTo treats them as equal.\n *\n * @param other  the object to compare to\n * @return -1 if this is less, 0 if equal, +1 if greater\n * @throws ClassCastException if the object is not a {@link Fraction}\n * @throws NullPointerException if the object is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 230, "method_signature": "int compareTo(Fraction)", "filename": "Fraction.compareTo.json"}
{"callee_method_ids": [234], "callee_method_names": ["Fraction.invert"], "method_name": "Fraction.divideBy", "method_implementation": "{\n    Objects.requireNonNull(fraction, \"fraction\");\n    if (fraction.numerator == 0) {\n        throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n    }\n    return multiplyBy(fraction.invert());\n}", "repo_id": "8", "comment": "/**\n * Divide the value of this fraction by another.\n *\n * @param fraction  the fraction to divide by, must not be {@code null}\n * @return a {@link Fraction} instance with the resulting values\n * @throws NullPointerException if the fraction is {@code null}\n * @throws ArithmeticException if the fraction to divide by is zero\n * @throws ArithmeticException if the resulting numerator or denominator exceeds\n *  {@code Integer.MAX_VALUE}\n */\n", "repo_name": "commons-lang-master/", "id": 231, "method_signature": "Fraction divideBy(Fraction)", "filename": "Fraction.divideBy.json"}
{"callee_method_names": ["Fraction.getNumerator", "Fraction.getDenominator"], "method_name": "Fraction.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof Fraction)) {\n        return false;\n    }\n    final Fraction other = (Fraction) obj;\n    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();\n}", "repo_id": "8", "comment": "/**\n * Compares this fraction to another object to test if they are equal..\n *\n * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n *\n * @param obj the reference object with which to compare\n * @return {@code true} if this object is equal\n */\n", "repo_name": "commons-lang-master/", "id": 232, "method_signature": "boolean equals(Object)", "filename": "Fraction.equals.json"}
{"callee_method_names": ["String.indexOf", "String.indexOf", "String.substring", "String.substring", "String.indexOf", "String.substring", "String.substring", "String.indexOf", "String.substring", "String.substring"], "method_name": "Fraction.getFraction", "method_implementation": "{\n    Objects.requireNonNull(str, \"str\");\n    // parse double format\n    int pos = str.indexOf('.');\n    if (pos >= 0) {\n        return getFraction(Double.parseDouble(str));\n    }\n    // parse X Y/Z format\n    pos = str.indexOf(' ');\n    if (pos > 0) {\n        final int whole = Integer.parseInt(str.substring(0, pos));\n        str = str.substring(pos + 1);\n        pos = str.indexOf('/');\n        if (pos < 0) {\n            throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n        }\n        final int numer = Integer.parseInt(str.substring(0, pos));\n        final int denom = Integer.parseInt(str.substring(pos + 1));\n        return getFraction(whole, numer, denom);\n    }\n    // parse Y/Z format\n    pos = str.indexOf('/');\n    if (pos < 0) {\n        // simple whole number\n        return getFraction(Integer.parseInt(str), 1);\n    }\n    final int numer = Integer.parseInt(str.substring(0, pos));\n    final int denom = Integer.parseInt(str.substring(pos + 1));\n    return getFraction(numer, denom);\n}", "repo_id": "8", "comment": "/**\n * Creates a Fraction from a {@link String}.\n *\n * <p>The formats accepted are:</p>\n *\n * <ol>\n *  <li>{@code double} String containing a dot</li>\n *  <li>'X Y/Z'</li>\n *  <li>'Y/Z'</li>\n *  <li>'X' (a simple whole number)</li>\n * </ol>\n * <p>and a .</p>\n *\n * @param str  the string to parse, must not be {@code null}\n * @return the new {@link Fraction} instance\n * @throws NullPointerException if the string is {@code null}\n * @throws NumberFormatException if the number format is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 222, "method_signature": "Fraction getFraction(String)", "filename": "Fraction.getFraction.json"}
{"callee_method_names": [], "method_name": "Fraction.getReducedFraction", "method_implementation": "{\n    if (denominator == 0) {\n        throw new ArithmeticException(\"The denominator must not be zero\");\n    }\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    // allow 2^k/-2^31 as a valid fraction (where k>0)\n    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n        numerator /= 2;\n        denominator /= 2;\n    }\n    if (denominator < 0) {\n        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: can't negate\");\n        }\n        numerator = -numerator;\n        denominator = -denominator;\n    }\n    // simplify fraction.\n    final int gcd = greatestCommonDivisor(numerator, denominator);\n    numerator /= gcd;\n    denominator /= gcd;\n    return new Fraction(numerator, denominator);\n}", "repo_id": "8", "comment": "/**\n * Creates a reduced {@link Fraction} instance with the 2 parts\n * of a fraction Y/Z.\n *\n * <p>For example, if the input parameters represent 2/4, then the created\n * fraction will be 1/2.</p>\n *\n * <p>Any negative signs are resolved to be on the numerator.</p>\n *\n * @param numerator  the numerator, for example the three in 'three sevenths'\n * @param denominator  the denominator, for example the seven in 'three sevenths'\n * @return a new fraction instance, with the numerator and denominator reduced\n * @throws ArithmeticException if the denominator is {@code zero}\n */\n", "repo_name": "commons-lang-master/", "id": 223, "method_signature": "Fraction getReducedFraction(int, int)", "filename": "Fraction.getReducedFraction.json"}
{"callee_method_names": [], "method_name": "Fraction.greatestCommonDivisor", "method_implementation": "{\n    // From Commons Math:\n    if (u == 0 || v == 0) {\n        if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        return Math.abs(u) + Math.abs(v);\n    }\n    // if either operand is abs 1, return 1:\n    if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n        return 1;\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = (u & 1) == 1 ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even.\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "repo_id": "8", "comment": "/**\n * Gets the greatest common divisor of the absolute value of\n * two numbers, using the \"binary gcd\" method which avoids\n * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n * This algorithm is due to Josef Stein (1961).\n *\n * @param u  a non-zero number\n * @param v  a non-zero number\n * @return the greatest common divisor, never zero\n */\n", "repo_name": "commons-lang-master/", "id": 224, "method_signature": "int greatestCommonDivisor(int, int)", "filename": "Fraction.greatestCommonDivisor.json"}
{"callee_method_names": [], "method_name": "Fraction.hashCode", "method_implementation": "{\n    if (hashCode == 0) {\n        // hash code update should be atomic.\n        hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n    }\n    return hashCode;\n}", "repo_id": "8", "comment": "/**\n * Gets a hashCode for the fraction.\n *\n * @return a hash code value for this object\n */\n", "repo_name": "commons-lang-master/", "id": 233, "method_signature": "int hashCode()", "filename": "Fraction.hashCode.json"}
{"callee_method_names": [], "method_name": "Fraction.invert", "method_implementation": "{\n    if (numerator == 0) {\n        throw new ArithmeticException(\"Unable to invert zero.\");\n    }\n    if (numerator == Integer.MIN_VALUE) {\n        throw new ArithmeticException(\"overflow: can't negate numerator\");\n    }\n    if (numerator < 0) {\n        return new Fraction(-denominator, -numerator);\n    }\n    return new Fraction(denominator, numerator);\n}", "repo_id": "8", "comment": "/**\n * Gets a fraction that is the inverse (1/fraction) of this one.\n *\n * <p>The returned fraction is not reduced.</p>\n *\n * @return a new fraction instance with the numerator and denominator\n *         inverted.\n * @throws ArithmeticException if the fraction represents zero.\n */\n", "repo_name": "commons-lang-master/", "id": 234, "method_signature": "Fraction invert()", "filename": "Fraction.invert.json"}
{"callee_method_names": [], "method_name": "Fraction.mulAndCheck", "method_implementation": "{\n    final long m = (long) x * (long) y;\n    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n        throw new ArithmeticException(\"overflow: mul\");\n    }\n    return (int) m;\n}", "repo_id": "8", "comment": "/**\n * Multiply two integers, checking for overflow.\n *\n * @param x a factor\n * @param y a factor\n * @return the product {@code x*y}\n * @throws ArithmeticException if the result can not be represented as\n *                             an int\n */\n", "repo_name": "commons-lang-master/", "id": 225, "method_signature": "int mulAndCheck(int, int)", "filename": "Fraction.mulAndCheck.json"}
{"callee_method_names": [], "method_name": "Fraction.mulPosAndCheck", "method_implementation": "{\n    /* assert x>=0 && y>=0; */\n    final long m = (long) x * (long) y;\n    if (m > Integer.MAX_VALUE) {\n        throw new ArithmeticException(\"overflow: mulPos\");\n    }\n    return (int) m;\n}", "repo_id": "8", "comment": "/**\n *  Multiply two non-negative integers, checking for overflow.\n *\n * @param x a non-negative factor\n * @param y a non-negative factor\n * @return the product {@code x*y}\n * @throws ArithmeticException if the result can not be represented as\n * an int\n */\n", "repo_name": "commons-lang-master/", "id": 226, "method_signature": "int mulPosAndCheck(int, int)", "filename": "Fraction.mulPosAndCheck.json"}
{"callee_method_names": [], "method_name": "Fraction.multiplyBy", "method_implementation": "{\n    Objects.requireNonNull(fraction, \"fraction\");\n    if (numerator == 0 || fraction.numerator == 0) {\n        return ZERO;\n    }\n    // knuth 4.5.1\n    // make sure we don't overflow unless the result *must* overflow.\n    final int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n    final int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));\n}", "repo_id": "8", "comment": "/**\n * Multiplies the value of this fraction by another, returning the\n * result in reduced form.\n *\n * @param fraction  the fraction to multiply by, must not be {@code null}\n * @return a {@link Fraction} instance with the resulting values\n * @throws NullPointerException if the fraction is {@code null}\n * @throws ArithmeticException if the resulting numerator or denominator exceeds\n *  {@code Integer.MAX_VALUE}\n */\n", "repo_name": "commons-lang-master/", "id": 235, "method_signature": "Fraction multiplyBy(Fraction)", "filename": "Fraction.multiplyBy.json"}
{"callee_method_names": [], "method_name": "Fraction.negate", "method_implementation": "{\n    // the positive range is one smaller than the negative range of an int.\n    if (numerator == Integer.MIN_VALUE) {\n        throw new ArithmeticException(\"overflow: too large to negate\");\n    }\n    return new Fraction(-numerator, denominator);\n}", "repo_id": "8", "comment": "/**\n * Gets a fraction that is the negative (-fraction) of this one.\n *\n * <p>The returned fraction is not reduced.</p>\n *\n * @return a new fraction instance with the opposite signed numerator\n */\n", "repo_name": "commons-lang-master/", "id": 236, "method_signature": "Fraction negate()", "filename": "Fraction.negate.json"}
{"callee_method_ids": [237, 237], "callee_method_names": ["Fraction.pow", "Fraction.pow"], "method_name": "Fraction.pow", "method_implementation": "{\n    if (power == 1) {\n        return this;\n    }\n    if (power == 0) {\n        return ONE;\n    }\n    if (power < 0) {\n        if (power == Integer.MIN_VALUE) {\n            // MIN_VALUE can't be negated.\n            return this.invert().pow(2).pow(-(power / 2));\n        }\n        return this.invert().pow(-power);\n    }\n    final Fraction f = this.multiplyBy(this);\n    if (power % 2 == 0) {\n        // if even...\n        return f.pow(power / 2);\n    }\n    return f.pow(power / 2).multiplyBy(this);\n}", "repo_id": "8", "comment": "/**\n * Gets a fraction that is raised to the passed in power.\n *\n * <p>The returned fraction is in reduced form.</p>\n *\n * @param power  the power to raise the fraction to\n * @return {@code this} if the power is one, {@link #ONE} if the power\n * is zero (even if the fraction equals ZERO) or a new fraction instance\n * raised to the appropriate power\n * @throws ArithmeticException if the resulting numerator or denominator exceeds\n *  {@code Integer.MAX_VALUE}\n */\n", "repo_name": "commons-lang-master/", "id": 237, "method_signature": "Fraction pow(int)", "filename": "Fraction.pow.json"}
{"callee_method_names": [], "method_name": "Fraction.reduce", "method_implementation": "{\n    if (numerator == 0) {\n        return equals(ZERO) ? this : ZERO;\n    }\n    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return getFraction(numerator / gcd, denominator / gcd);\n}", "repo_id": "8", "comment": "/**\n * Reduce the fraction to the smallest values for the numerator and\n * denominator, returning the result.\n *\n * <p>For example, if this fraction represents 2/4, then the result\n * will be 1/2.</p>\n *\n * @return a new reduced fraction instance, or this if no simplification possible\n */\n", "repo_name": "commons-lang-master/", "id": 238, "method_signature": "Fraction reduce()", "filename": "Fraction.reduce.json"}
{"callee_method_names": [], "method_name": "Fraction.subAndCheck", "method_implementation": "{\n    final long s = (long) x - (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new ArithmeticException(\"overflow: add\");\n    }\n    return (int) s;\n}", "repo_id": "8", "comment": "/**\n * Subtract two integers, checking for overflow.\n *\n * @param x the minuend\n * @param y the subtrahend\n * @return the difference {@code x-y}\n * @throws ArithmeticException if the result can not be represented as\n * an int\n */\n", "repo_name": "commons-lang-master/", "id": 227, "method_signature": "int subAndCheck(int, int)", "filename": "Fraction.subAndCheck.json"}
{"callee_method_names": [], "method_name": "Fraction.toProperString", "method_implementation": "{\n    if (toProperString == null) {\n        if (numerator == 0) {\n            toProperString = \"0\";\n        } else if (numerator == denominator) {\n            toProperString = \"1\";\n        } else if (numerator == -1 * denominator) {\n            toProperString = \"-1\";\n        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {\n            // note that we do the magnitude comparison test above with\n            // NEGATIVE (not positive) numbers, since negative numbers\n            // have a larger range. otherwise numerator==Integer.MIN_VALUE\n            // is handled incorrectly.\n            final int properNumerator = getProperNumerator();\n            if (properNumerator == 0) {\n                toProperString = Integer.toString(getProperWhole());\n            } else {\n                toProperString = getProperWhole() + \" \" + properNumerator + \"/\" + getDenominator();\n            }\n        } else {\n            toProperString = getNumerator() + \"/\" + getDenominator();\n        }\n    }\n    return toProperString;\n}", "repo_id": "8", "comment": "/**\n * Gets the fraction as a proper {@link String} in the format X Y/Z.\n *\n * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\n * If the whole number is zero it will be omitted. If the numerator is zero,\n * only the whole number is returned.</p>\n *\n * @return a {@link String} form of the fraction\n */\n", "repo_name": "commons-lang-master/", "id": 239, "method_signature": "String toProperString()", "filename": "Fraction.toProperString.json"}
{"callee_method_names": [], "method_name": "Fraction.toString", "method_implementation": "{\n    if (toString == null) {\n        toString = getNumerator() + \"/\" + getDenominator();\n    }\n    return toString;\n}", "repo_id": "8", "comment": "/**\n * Gets the fraction as a {@link String}.\n *\n * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n *\n * @return a {@link String} form of the fraction\n */\n", "repo_name": "commons-lang-master/", "id": 240, "method_signature": "String toString()", "filename": "Fraction.toString.json"}
{"callee_method_names": ["FailableSupplier<O,T>.get"], "method_name": "Functions.get", "method_implementation": "{\n    try {\n        return supplier.get();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes a supplier, and returns the result.\n *\n * @param supplier The supplier to invoke.\n * @param <O> The suppliers output type.\n * @param <T> The type of checked exception, which the supplier can throw.\n * @return The object, which has been created by the supplier\n * @since 3.10\n */\n", "repo_name": "commons-lang-master/", "id": 1329, "method_signature": "O get(FailableSupplier)", "filename": "Functions.get.json"}
{"callee_method_names": ["FailableBooleanSupplier<T>.getAsBoolean"], "method_name": "Functions.getAsBoolean", "method_implementation": "{\n    try {\n        return supplier.getAsBoolean();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes a boolean supplier, and returns the result.\n *\n * @param supplier The boolean supplier to invoke.\n * @param <T> The type of checked exception, which the supplier can throw.\n * @return The boolean, which has been created by the supplier\n */\n", "repo_name": "commons-lang-master/", "id": 1330, "method_signature": "boolean getAsBoolean(FailableBooleanSupplier)", "filename": "Functions.getAsBoolean.json"}
{"callee_method_names": [], "method_name": "Functions.rethrow", "method_implementation": "{\n    Objects.requireNonNull(throwable, \"throwable\");\n    ExceptionUtils.throwUnchecked(throwable);\n    if (throwable instanceof IOException) {\n        throw new UncheckedIOException((IOException) throwable);\n    }\n    throw new UndeclaredThrowableException(throwable);\n}", "repo_id": "8", "comment": "/**\n * Rethrows a {@link Throwable} as an unchecked exception. If the argument is already unchecked, namely a\n * {@link RuntimeException} or {@link Error} then the argument will be rethrown without modification. If the\n * exception is {@link IOException} then it will be wrapped into a {@link UncheckedIOException}. In every other\n * cases the exception will be wrapped into a {@code\n * UndeclaredThrowableException}\n *\n * <p>\n * Note that there is a declared return type for this method, even though it never returns. The reason for that is\n * to support the usual pattern:\n * </p>\n *\n * <pre>\n * throw rethrow(myUncheckedException);</pre>\n *\n * <p>\n * instead of just calling the method. This pattern may help the Java compiler to recognize that at that point an\n * exception will be thrown and the code flow analysis will not demand otherwise mandatory commands that could\n * follow the method call, like a {@code return} statement from a value returning method.\n * </p>\n *\n * @param throwable The throwable to rethrow possibly wrapped into an unchecked exception\n * @return Never returns anything, this method never terminates normally.\n */\n", "repo_name": "commons-lang-master/", "id": 1331, "method_signature": "RuntimeException rethrow(Throwable)", "filename": "Functions.rethrow.json"}
{"callee_method_names": ["FailableRunnable<T>.run"], "method_name": "Functions.run", "method_implementation": "{\n    try {\n        runnable.run();\n    } catch (final Throwable t) {\n        throw rethrow(t);\n    }\n}", "repo_id": "8", "comment": "/**\n * Runs a runnable and rethrows any exception as a {@link RuntimeException}.\n *\n * @param runnable The runnable to run\n * @param <T> the type of checked exception the runnable may throw\n */\n", "repo_name": "commons-lang-master/", "id": 1332, "method_signature": "void run(FailableRunnable)", "filename": "Functions.run.json"}
{"callee_method_names": [], "method_name": "Functions.tryWithResources", "method_implementation": "{\n    tryWithResources(action, null, resources);\n}", "repo_id": "8", "comment": "/**\n * A simple try-with-resources implementation, that can be used, if your objects do not implement the\n * {@link AutoCloseable} interface. The method executes the {@code action}. The method guarantees, that <em>all</em>\n * the {@code resources} are being executed, in the given order, afterwards, and regardless of success, or failure.\n * If either the original action, or any of the resource action fails, then the <em>first</em> failure (AKA\n * {@link Throwable}) is rethrown. Example use:\n *\n * <pre>\n * {@code\n *     final FileInputStream fis = new FileInputStream(\"my.file\");\n *     Functions.tryWithResources(useInputStream(fis), () -> fis.close());\n * }</pre>\n *\n * @param action The action to execute. This object <em>will</em> always be invoked.\n * @param resources The resource actions to execute. <em>All</em> resource actions will be invoked, in the given\n *        order. A resource action is an instance of {@link FailableRunnable}, which will be executed.\n * @see #tryWithResources(FailableRunnable, FailableConsumer, FailableRunnable...)\n */\n", "repo_name": "commons-lang-master/", "id": 1334, "method_signature": "void tryWithResources(FailableRunnable, FailableRunnable<? extends Throwable>[])", "filename": "Functions.tryWithResources.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableBiConsumer_Object_Throwable", "method_implementation": "{\n    new Functions.FailableBiConsumer<Object, Object, Throwable>() {\n\n        @Override\n        public void accept(final Object object1, final Object object2) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1895, "method_signature": "void testThrows_FailableBiConsumer_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableBiConsumer_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableBiConsumer_String_IOException", "method_implementation": "{\n    new Functions.FailableBiConsumer<String, String, IOException>() {\n\n        @Override\n        public void accept(final String object1, final String object2) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1896, "method_signature": "void testThrows_FailableBiConsumer_String_IOException()", "filename": "FunctionsTest.testThrows_FailableBiConsumer_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableBiFunction_Object_Throwable", "method_implementation": "{\n    new Functions.FailableBiFunction<Object, Object, Object, Throwable>() {\n\n        @Override\n        public Object apply(final Object input1, final Object input2) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1897, "method_signature": "void testThrows_FailableBiFunction_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableBiFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableBiFunction_String_IOException", "method_implementation": "{\n    new Functions.FailableBiFunction<String, String, String, IOException>() {\n\n        @Override\n        public String apply(final String input1, final String input2) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1898, "method_signature": "void testThrows_FailableBiFunction_String_IOException()", "filename": "FunctionsTest.testThrows_FailableBiFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableBiPredicate_Object_Throwable", "method_implementation": "{\n    new Functions.FailableBiPredicate<Object, Object, Throwable>() {\n\n        @Override\n        public boolean test(final Object object1, final Object object2) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1899, "method_signature": "void testThrows_FailableBiPredicate_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableBiPredicate_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableBiPredicate_String_IOException", "method_implementation": "{\n    new Functions.FailableBiPredicate<String, String, IOException>() {\n\n        @Override\n        public boolean test(final String object1, final String object2) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1900, "method_signature": "void testThrows_FailableBiPredicate_String_IOException()", "filename": "FunctionsTest.testThrows_FailableBiPredicate_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableCallable_Object_Throwable", "method_implementation": "{\n    new Functions.FailableCallable<Object, Throwable>() {\n\n        @Override\n        public Object call() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1901, "method_signature": "void testThrows_FailableCallable_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableCallable_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableCallable_String_IOException", "method_implementation": "{\n    new Functions.FailableCallable<String, IOException>() {\n\n        @Override\n        public String call() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1902, "method_signature": "void testThrows_FailableCallable_String_IOException()", "filename": "FunctionsTest.testThrows_FailableCallable_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableConsumer_Object_Throwable", "method_implementation": "{\n    new Functions.FailableConsumer<Object, Throwable>() {\n\n        @Override\n        public void accept(final Object object) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1903, "method_signature": "void testThrows_FailableConsumer_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableConsumer_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableConsumer_String_IOException", "method_implementation": "{\n    new Functions.FailableConsumer<String, IOException>() {\n\n        @Override\n        public void accept(final String object) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1904, "method_signature": "void testThrows_FailableConsumer_String_IOException()", "filename": "FunctionsTest.testThrows_FailableConsumer_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableFunction_Object_Throwable", "method_implementation": "{\n    new Functions.FailableFunction<Object, Object, Throwable>() {\n\n        @Override\n        public Object apply(final Object input) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1905, "method_signature": "void testThrows_FailableFunction_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableFunction_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableFunction_String_IOException", "method_implementation": "{\n    new Functions.FailableFunction<String, String, IOException>() {\n\n        @Override\n        public String apply(final String input) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1906, "method_signature": "void testThrows_FailableFunction_String_IOException()", "filename": "FunctionsTest.testThrows_FailableFunction_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailablePredicate_Object_Throwable", "method_implementation": "{\n    new Functions.FailablePredicate<Object, Throwable>() {\n\n        @Override\n        public boolean test(final Object object) throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1907, "method_signature": "void testThrows_FailablePredicate_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailablePredicate_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailablePredicate_String_IOException", "method_implementation": "{\n    new Functions.FailablePredicate<String, IOException>() {\n\n        @Override\n        public boolean test(final String object) throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1908, "method_signature": "void testThrows_FailablePredicate_String_IOException()", "filename": "FunctionsTest.testThrows_FailablePredicate_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableRunnable_Object_Throwable", "method_implementation": "{\n    new Functions.FailableRunnable<Throwable>() {\n\n        @Override\n        public void run() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1909, "method_signature": "void testThrows_FailableRunnable_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableRunnable_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableRunnable_String_IOException", "method_implementation": "{\n    new Functions.FailableRunnable<IOException>() {\n\n        @Override\n        public void run() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1910, "method_signature": "void testThrows_FailableRunnable_String_IOException()", "filename": "FunctionsTest.testThrows_FailableRunnable_String_IOException.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableSupplier_Object_Throwable", "method_implementation": "{\n    new Functions.FailableSupplier<Object, Throwable>() {\n\n        @Override\n        public Object get() throws Throwable {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception. using the top level generic types\n * Object and Throwable.\n */\n", "repo_name": "commons-lang-master/", "id": 1911, "method_signature": "void testThrows_FailableSupplier_Object_Throwable()", "filename": "FunctionsTest.testThrows_FailableSupplier_Object_Throwable.json"}
{"callee_method_names": [], "method_name": "FunctionsTest.testThrows_FailableSupplier_String_IOException", "method_implementation": "{\n    new Functions.FailableSupplier<String, IOException>() {\n\n        @Override\n        public String get() throws IOException {\n            throw new IOException(\"test\");\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as\n * generic test types.\n */\n", "repo_name": "commons-lang-master/", "id": 1912, "method_signature": "void testThrows_FailableSupplier_String_IOException()", "filename": "FunctionsTest.testThrows_FailableSupplier_String_IOException.json"}
{"callee_method_names": ["FutureTask<V>.run"], "method_name": "FutureTasks.run", "method_implementation": "{\n    final FutureTask<V> futureTask = new FutureTask<>(callable);\n    futureTask.run();\n    return futureTask;\n}", "repo_id": "8", "comment": "/**\n * Creates a {@link FutureTask} and runs the given {@link Callable}.\n *\n * @param <V> The result type returned by this FutureTask's {@code get} methods.\n * @param callable the Callable task.\n * @return a new FutureTask.\n */\n", "repo_name": "commons-lang-master/", "id": 131, "method_signature": "FutureTask<V> run(Callable)", "filename": "FutureTasks.run.json"}
{"callee_method_names": ["Type.hashCode"], "method_name": "GenericArrayTypeImpl.hashCode", "method_implementation": "{\n    int result = 67 << 4;\n    result |= componentType.hashCode();\n    return result;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 293, "method_signature": "int hashCode()", "filename": "GenericArrayTypeImpl.hashCode.json"}
{"callee_method_names": [], "method_name": "HashCodeBuilder.append", "method_implementation": "{\n    if (array == null) {\n        iTotal = iTotal * iConstant;\n    } else {\n        for (final short element : array) {\n            append(element);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Append a {@code hashCode} for a {@code short} array.\n *\n * @param array\n *            the array to add to the {@code hashCode}\n * @return this\n */\n", "repo_name": "commons-lang-master/", "id": 973, "method_signature": "HashCodeBuilder append(short[])", "filename": "HashCodeBuilder.append.json"}
{"callee_method_names": [], "method_name": "HashCodeBuilder.appendArray", "method_implementation": "{\n    // 'Switch' on type of array, to dispatch to the correct handler\n    // This handles multidimensional arrays\n    if (object instanceof long[]) {\n        append((long[]) object);\n    } else if (object instanceof int[]) {\n        append((int[]) object);\n    } else if (object instanceof short[]) {\n        append((short[]) object);\n    } else if (object instanceof char[]) {\n        append((char[]) object);\n    } else if (object instanceof byte[]) {\n        append((byte[]) object);\n    } else if (object instanceof double[]) {\n        append((double[]) object);\n    } else if (object instanceof float[]) {\n        append((float[]) object);\n    } else if (object instanceof boolean[]) {\n        append((boolean[]) object);\n    } else {\n        // Not an array of primitives\n        append((Object[]) object);\n    }\n}", "repo_id": "8", "comment": "/**\n * Append a {@code hashCode} for an array.\n *\n * @param object\n *            the array to add to the {@code hashCode}\n */\n", "repo_name": "commons-lang-master/", "id": 974, "method_signature": "void appendArray(Object)", "filename": "HashCodeBuilder.appendArray.json"}
{"callee_method_names": [], "method_name": "HashCodeBuilder.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (!(obj instanceof HashCodeBuilder)) {\n        return false;\n    }\n    final HashCodeBuilder other = (HashCodeBuilder) obj;\n    return iTotal == other.iTotal;\n}", "repo_id": "8", "comment": "/**\n * Implements equals using the hash code.\n *\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 975, "method_signature": "boolean equals(Object)", "filename": "HashCodeBuilder.equals.json"}
{"callee_method_ids": [973], "callee_method_names": ["Class<?>.getDeclaredFields", "Field.getName", "Field.getName", "Field.getModifiers", "Field.getModifiers", "Field.isAnnotationPresent", "HashCodeBuilder.append"], "method_name": "HashCodeBuilder.reflectionAppend", "method_implementation": "{\n    if (isRegistered(object)) {\n        return;\n    }\n    try {\n        register(object);\n        // The elements in the returned array are not sorted and are not in any particular order.\n        final Field[] fields = ArraySorter.sort(clazz.getDeclaredFields(), Comparator.comparing(Field::getName));\n        AccessibleObject.setAccessible(fields, true);\n        for (final Field field : fields) {\n            if (!ArrayUtils.contains(excludeFields, field.getName()) && !field.getName().contains(\"$\") && (useTransients || !Modifier.isTransient(field.getModifiers())) && !Modifier.isStatic(field.getModifiers()) && !field.isAnnotationPresent(HashCodeExclude.class)) {\n                builder.append(Reflection.getUnchecked(field, object));\n            }\n        }\n    } finally {\n        unregister(object);\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends the fields and values defined by the given object of the given {@link Class}.\n *\n * @param object\n *            the object to append details of\n * @param clazz\n *            the class to append details of\n * @param builder\n *            the builder to append to\n * @param useTransients\n *            whether to use transient fields\n * @param excludeFields\n *            Collection of String field names to exclude from use in calculation of hash code\n */\n", "repo_name": "commons-lang-master/", "id": 960, "method_signature": "void reflectionAppend(Object, Class, HashCodeBuilder, boolean, String[])", "filename": "HashCodeBuilder.reflectionAppend.json"}
{"callee_method_names": ["T.getClass", "Class<?>.getSuperclass", "Class<?>.getSuperclass", "HashCodeBuilder.toHashCode"], "method_name": "HashCodeBuilder.reflectionHashCode", "method_implementation": "{\n    Objects.requireNonNull(object, \"object\");\n    final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n    Class<?> clazz = object.getClass();\n    reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n    while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n        clazz = clazz.getSuperclass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n    }\n    return builder.toHashCode();\n}", "repo_id": "8", "comment": "/**\n * Uses reflection to build a valid hash code from the fields of {@code object}.\n *\n * <p>\n * It uses {@code AccessibleObject.setAccessible} to gain access to private fields. This means that it will\n * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n * also not as efficient as testing explicitly.\n * </p>\n *\n * <p>\n * If the TestTransients parameter is set to {@code true}, transient members will be tested, otherwise they\n * are ignored, as they are likely derived fields, and not part of the value of the {@link Object}.\n * </p>\n *\n * <p>\n * Static fields will not be included. Superclass fields will be included up to and including the specified\n * superclass. A null superclass is treated as java.lang.Object.\n * </p>\n *\n * <p>\n * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n * </p>\n *\n * @param <T>\n *            the type of the object involved\n * @param initialNonZeroOddNumber\n *            a non-zero, odd number used as the initial value. This will be the returned\n *            value if no fields are found to include in the hash code\n * @param multiplierNonZeroOddNumber\n *            a non-zero, odd number used as the multiplier\n * @param object\n *            the Object to create a {@code hashCode} for\n * @param testTransients\n *            whether to include transient fields\n * @param reflectUpToClass\n *            the superclass to reflect up to (inclusive), may be {@code null}\n * @param excludeFields\n *            array of field names to exclude from use in calculation of hash code\n * @return int hash code\n * @throws NullPointerException\n *             if the Object is {@code null}\n * @throws IllegalArgumentException\n *             if the number is zero or even\n *\n * @see HashCodeExclude\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 961, "method_signature": "int reflectionHashCode(int, int, T, boolean, Class, String[])", "filename": "HashCodeBuilder.reflectionHashCode.json"}
{"callee_method_names": ["ThreadLocal.set", "Set<IDKey>.add"], "method_name": "HashCodeBuilder.register", "method_implementation": "{\n    Set<IDKey> registry = getRegistry();\n    if (registry == null) {\n        registry = new HashSet<>();\n        REGISTRY.set(registry);\n    }\n    registry.add(new IDKey(value));\n}", "repo_id": "8", "comment": "/**\n * Registers the given object. Used by the reflection methods to avoid infinite loops.\n *\n * @param value\n *            The object to register.\n */\n", "repo_name": "commons-lang-master/", "id": 962, "method_signature": "void register(Object)", "filename": "HashCodeBuilder.register.json"}
{"callee_method_names": ["Set<IDKey>.remove", "Set<IDKey>.isEmpty", "ThreadLocal.remove"], "method_name": "HashCodeBuilder.unregister", "method_implementation": "{\n    final Set<IDKey> registry = getRegistry();\n    if (registry != null) {\n        registry.remove(new IDKey(value));\n        if (registry.isEmpty()) {\n            REGISTRY.remove();\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Unregisters the given object.\n *\n * <p>\n * Used by the reflection methods to avoid infinite loops.\n *\n * @param value\n *            The object to unregister.\n * @since 2.3\n */\n", "repo_name": "commons-lang-master/", "id": 963, "method_signature": "void unregister(Object)", "filename": "HashCodeBuilder.unregister.json"}
{"callee_method_names": [], "method_name": "HashCodeBuilderAndEqualsBuilderTest.assertEqualsAndHashCodeContract", "method_implementation": "{\n    if (EqualsBuilder.reflectionEquals(lhs, rhs, testTransients)) {\n        // test a couple of times for consistency.\n        assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n        assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n        assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n    }\n}", "repo_id": "8", "comment": "/**\n * Asserts that if {@code lhs} equals {@code rhs}\n * then their hash codes MUST be identical.\n *\n * @param lhs The Left-Hand-Side of the equals test\n * @param rhs The Right-Hand-Side of the equals test\n * @param testTransients whether to test transient fields\n */\n", "repo_name": "commons-lang-master/", "id": 1994, "method_signature": "void assertEqualsAndHashCodeContract(Object, Object, boolean)", "filename": "HashCodeBuilderAndEqualsBuilderTest.assertEqualsAndHashCodeContract.json"}
{"callee_method_names": ["ReflectionTestCycleA.hashCode", "ReflectionTestCycleB.hashCode"], "method_name": "HashCodeBuilderTest.testReflectionObjectCycle", "method_implementation": "{\n    final ReflectionTestCycleA a = new ReflectionTestCycleA();\n    final ReflectionTestCycleB b = new ReflectionTestCycleB();\n    a.b = b;\n    b.a = a;\n    // Used to caused:\n    // java.lang.StackOverflowError\n    // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n    // at java.lang.Class.getDeclaredFields(Class.java:992)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n    // at\n    // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n    // at\n    // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n    // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n    a.hashCode();\n    assertNull(HashCodeBuilder.getRegistry());\n    b.hashCode();\n    assertNull(HashCodeBuilder.getRegistry());\n}", "repo_id": "8", "comment": "/**\n * Test Objects pointing to each other.\n */\n", "repo_name": "commons-lang-master/", "id": 1991, "method_signature": "void testReflectionObjectCycle()", "filename": "HashCodeBuilderTest.testReflectionObjectCycle.json"}
{"callee_method_names": ["HashCodeBuilder.toHashCode", "HashCodeBuilder.hashCode"], "method_name": "HashCodeBuilderTest.testToHashCodeEqualsHashCode", "method_implementation": "{\n    final HashCodeBuilder hcb = new HashCodeBuilder(17, 37).append(new Object()).append('a');\n    assertEquals(hcb.toHashCode(), hcb.hashCode(), \"hashCode() is no longer returning the same value as toHashCode() - see LANG-520\");\n}", "repo_id": "8", "comment": "/**\n * Ensures LANG-520 remains true\n */\n", "repo_name": "commons-lang-master/", "id": 1992, "method_signature": "void testToHashCodeEqualsHashCode()", "filename": "HashCodeBuilderTest.testToHashCodeEqualsHashCode.json"}
{"callee_method_names": ["HashSet<Integer>.size", "int.intValue"], "method_name": "HashSetvBitSetTest.extractIndices", "method_implementation": "{\n    final int[] result = new int[coll.size()];\n    int i = 0;\n    for (final Integer index : coll) {\n        result[i++] = index.intValue();\n    }\n    return result;\n}", "repo_id": "8", "comment": "// --- utility methods\n", "repo_name": "commons-lang-master/", "id": 2017, "method_signature": "int[] extractIndices(HashSet)", "filename": "HashSetvBitSetTest.extractIndices.json"}
{"callee_method_names": [], "method_name": "IDKey.equals", "method_implementation": "{\n    if (!(other instanceof IDKey)) {\n        return false;\n    }\n    final IDKey idKey = (IDKey) other;\n    if (id != idKey.id) {\n        return false;\n    }\n    // Note that identity equals is used.\n    return value == idKey.value;\n}", "repo_id": "8", "comment": "/**\n * checks if instances are equal\n * @param other The other object to compare to\n * @return if the instances are for the same object\n */\n", "repo_name": "commons-lang-master/", "id": 885, "method_signature": "boolean equals(Object)", "filename": "IDKey.equals.json"}
{"callee_method_names": [], "method_name": "IEEE754rUtils.max", "method_implementation": "{\n    if (Float.isNaN(a)) {\n        return b;\n    }\n    if (Float.isNaN(b)) {\n        return a;\n    }\n    return Math.max(a, b);\n}", "repo_id": "8", "comment": "/**\n * Gets the maximum of two {@code float} values.\n *\n * <p>NaN is only returned if all numbers are NaN as per IEEE-754r.</p>\n *\n * @param a  value 1\n * @param b  value 2\n * @return  the largest of the values\n */\n", "repo_name": "commons-lang-master/", "id": 244, "method_signature": "float max(float, float)", "filename": "IEEE754rUtils.max.json"}
{"callee_method_names": [], "method_name": "IEEE754rUtils.min", "method_implementation": "{\n    if (Float.isNaN(a)) {\n        return b;\n    }\n    if (Float.isNaN(b)) {\n        return a;\n    }\n    return Math.min(a, b);\n}", "repo_id": "8", "comment": "/**\n * Gets the minimum of two {@code float} values.\n *\n * <p>NaN is only returned if all numbers are NaN as per IEEE-754r.</p>\n *\n * @param a  value 1\n * @param b  value 2\n * @return  the smallest of the values\n */\n", "repo_name": "commons-lang-master/", "id": 248, "method_signature": "float min(float, float)", "filename": "IEEE754rUtils.min.json"}
{"callee_method_names": [], "method_name": "ISO8601TimeZoneStrategy.getStrategy", "method_implementation": "{\n    switch(tokenLen) {\n        case 1:\n            return ISO_8601_1_STRATEGY;\n        case 2:\n            return ISO_8601_2_STRATEGY;\n        case 3:\n            return ISO_8601_3_STRATEGY;\n        default:\n            throw new IllegalArgumentException(\"invalid number of X\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Factory method for ISO8601TimeZoneStrategies.\n *\n * @param tokenLen a token indicating the length of the TimeZone String to be formatted.\n * @return a ISO8601TimeZoneStrategy that can format TimeZone String of length {@code tokenLen}. If no such strategy exists, an IllegalArgumentException\n *         will be thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 627, "method_signature": "Strategy getStrategy(int)", "filename": "ISO8601TimeZoneStrategy.getStrategy.json"}
{"callee_method_names": ["Class<?>.equals", "Class<?>.getSuperclass", "Class<?>.equals"], "method_name": "InheritanceUtils.distance", "method_implementation": "{\n    if (child == null || parent == null) {\n        return -1;\n    }\n    if (child.equals(parent)) {\n        return 0;\n    }\n    final Class<?> cParent = child.getSuperclass();\n    int d = BooleanUtils.toInteger(parent.equals(cParent));\n    if (d == 1) {\n        return d;\n    }\n    d += distance(cParent, parent);\n    return d > 0 ? d + 1 : -1;\n}", "repo_id": "8", "comment": "/**\n * Returns the number of inheritance hops between two classes.\n *\n * @param child the child class, may be {@code null}\n * @param parent the parent class, may be {@code null}\n * @return the number of generations between the child and parent; 0 if the same class;\n * -1 if the classes are not related as child and parent (includes where either class is null)\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 347, "method_signature": "int distance(Class, Class)", "filename": "InheritanceUtils.distance.json"}
{"callee_method_names": ["ExecutorService.shutdown"], "method_name": "InitializationTask.call", "method_implementation": "{\n    try {\n        return initialize();\n    } finally {\n        if (execFinally != null) {\n            execFinally.shutdown();\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Initiates initialization and returns the result.\n *\n * @return the result object\n * @throws Exception if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 108, "method_signature": "T call()", "filename": "InitializationTask.call.json"}
{"callee_method_names": ["Calendar.get", "Calendar.get", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append"], "method_name": "Iso8601_Rule.appendTo", "method_implementation": "{\n    int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n    if (offset == 0) {\n        buffer.append(\"Z\");\n        return;\n    }\n    if (offset < 0) {\n        buffer.append('-');\n        offset = -offset;\n    } else {\n        buffer.append('+');\n    }\n    final int hours = offset / (60 * 60 * 1000);\n    appendDigits(buffer, hours);\n    if (length < 5) {\n        return;\n    }\n    if (length == 6) {\n        buffer.append(':');\n    }\n    final int minutes = offset / (60 * 1000) - 60 * hours;\n    appendDigits(buffer, minutes);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 674, "method_signature": "void appendTo(Appendable, Calendar)", "filename": "Iso8601_Rule.appendTo.json"}
{"callee_method_names": [], "method_name": "Iso8601_Rule.getRule", "method_implementation": "{\n    switch(tokenLen) {\n        case 1:\n            return ISO8601_HOURS;\n        case 2:\n            return ISO8601_HOURS_MINUTES;\n        case 3:\n            return ISO8601_HOURS_COLON_MINUTES;\n        default:\n            throw new IllegalArgumentException(\"invalid number of X\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Factory method for Iso8601_Rules.\n *\n * @param tokenLen a token indicating the length of the TimeZone String to be formatted.\n * @return an Iso8601_Rule that can format TimeZone String of length {@code tokenLen}. If no such\n *          rule exists, an IllegalArgumentException will be thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 673, "method_signature": "Iso8601_Rule getRule(int)", "filename": "Iso8601_Rule.getRule.json"}
{"callee_method_names": [], "method_name": "JavaUnicodeEscaper.toUtf16Escape", "method_implementation": "{\n    final char[] surrogatePair = Character.toChars(codePoint);\n    return \"\\\\u\" + hex(surrogatePair[0]) + \"\\\\u\" + hex(surrogatePair[1]);\n}", "repo_id": "8", "comment": "/**\n * Converts the given code point to a hexadecimal string of the form {@code \"\\\\uXXXX\\\\uXXXX\"}\n *\n * @param codePoint\n *            a Unicode code point\n * @return the hexadecimal string for the given code point\n */\n", "repo_name": "commons-lang-master/", "id": 433, "method_signature": "String toUtf16Escape(int)", "filename": "JavaUnicodeEscaper.toUtf16Escape.json"}
{"callee_method_names": ["float.add", "Function<Object,String>.apply"], "method_name": "LangCollectors.joining", "method_implementation": "{\n    return new SimpleCollector<>(() -> new StringJoiner(delimiter, prefix, suffix), (a, t) -> a.add(toString.apply(t)), StringJoiner::merge, StringJoiner::toString, CH_NOID);\n}", "repo_id": "8", "comment": "/**\n * Returns a {@code Collector} that concatenates the input elements, separated by the specified delimiter, with the\n * specified prefix and suffix, in encounter order.\n * <p>\n * This is a variation of {@link Collectors#joining(CharSequence, CharSequence, CharSequence)} that works with any\n * element class, not just {@code CharSequence}.\n * </p>\n *\n * @param delimiter the delimiter to be used between each element\n * @param prefix the sequence of characters to be used at the beginning of the joined result\n * @param suffix the sequence of characters to be used at the end of the joined result\n * @param toString A function that takes an Object and returns a non-null String.\n * @return A {@code Collector} which concatenates CharSequence elements, separated by the specified delimiter, in\n *         encounter order\n */\n", "repo_name": "commons-lang-master/", "id": 744, "method_signature": "Collector<Object,?,String> joining(CharSequence, CharSequence, CharSequence, Function)", "filename": "LangCollectors.joining.json"}
{"callee_method_names": [], "method_name": "LazyInitializer.get", "method_implementation": "{\n    // use a temporary variable to reduce the number of reads of the\n    // volatile field\n    T result = object;\n    if (result == NO_INIT) {\n        synchronized (this) {\n            result = object;\n            if (result == NO_INIT) {\n                object = result = initialize();\n            }\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Returns the object wrapped by this instance. On first access the object is created. After that it is cached and can be accessed pretty fast.\n *\n * @return the object initialized by this {@link LazyInitializer}\n * @throws ConcurrentException if an error occurred during initialization of the object\n */\n", "repo_name": "commons-lang-master/", "id": 90, "method_signature": "T get()", "filename": "LazyInitializer.get.json"}
{"callee_method_names": [], "method_name": "LazyInitializerAnonClassTest.createInitializer", "method_implementation": "{\n    return new LazyInitializer<Object>() {\n\n        @Override\n        protected Object initialize() {\n            return new Object();\n        }\n    };\n}", "repo_id": "8", "comment": "/**\n * Creates the initializer to be tested. This implementation returns the {@code LazyInitializer} created in the {@code setUp()} method.\n *\n * @return the initializer to be tested\n */\n", "repo_name": "commons-lang-master/", "id": 1587, "method_signature": "LazyInitializer<Object> createInitializer()", "filename": "LazyInitializerAnonClassTest.createInitializer.json"}
{"callee_method_names": ["ConcurrentHashMap.computeIfAbsent", "String.equals", "Locale.getLanguage", "Locale.getCountry", "Locale.getVariant"], "method_name": "LocaleUtils.countriesByLanguage", "method_implementation": "{\n    if (languageCode == null) {\n        return Collections.emptyList();\n    }\n    return cCountriesByLanguage.computeIfAbsent(languageCode, lc -> Collections.unmodifiableList(availableLocaleList(locale -> languageCode.equals(locale.getLanguage()) && !locale.getCountry().isEmpty() && locale.getVariant().isEmpty())));\n}", "repo_id": "8", "comment": "/**\n * Obtains the list of countries supported for a given language.\n *\n * <p>This method takes a language code and searches to find the\n * countries available for that language. Variant locales are removed.</p>\n *\n * @param languageCode  the 2 letter language code, null returns empty\n * @return an unmodifiable List of Locale objects, not null\n */\n", "repo_name": "commons-lang-master/", "id": 716, "method_signature": "List<Locale> countriesByLanguage(String)", "filename": "LocaleUtils.countriesByLanguage.json"}
{"callee_method_names": ["ConcurrentHashMap.computeIfAbsent", "String.equals", "Locale.getCountry", "Locale.getVariant"], "method_name": "LocaleUtils.languagesByCountry", "method_implementation": "{\n    if (countryCode == null) {\n        return Collections.emptyList();\n    }\n    return cLanguagesByCountry.computeIfAbsent(countryCode, k -> Collections.unmodifiableList(availableLocaleList(locale -> countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty())));\n}", "repo_id": "8", "comment": "/**\n * Obtains the list of languages supported for a given country.\n *\n * <p>This method takes a country code and searches to find the\n * languages available for that country. Variant locales are removed.</p>\n *\n * @param countryCode  the 2-letter country code, null returns empty\n * @return an unmodifiable List of Locale objects, not null\n */\n", "repo_name": "commons-lang-master/", "id": 717, "method_signature": "List<Locale> languagesByCountry(String)", "filename": "LocaleUtils.languagesByCountry.json"}
{"callee_method_names": ["List<Locale>.add", "Locale.getVariant", "List<Locale>.add", "Locale.getLanguage", "Locale.getCountry", "Locale.getCountry", "List<Locale>.add", "Locale.getLanguage", "List<Locale>.contains", "List<Locale>.add"], "method_name": "LocaleUtils.localeLookupList", "method_implementation": "{\n    final List<Locale> list = new ArrayList<>(4);\n    if (locale != null) {\n        list.add(locale);\n        if (!locale.getVariant().isEmpty()) {\n            list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n        }\n        if (!locale.getCountry().isEmpty()) {\n            list.add(new Locale(locale.getLanguage(), StringUtils.EMPTY));\n        }\n        if (!list.contains(defaultLocale)) {\n            list.add(defaultLocale);\n        }\n    }\n    return Collections.unmodifiableList(list);\n}", "repo_id": "8", "comment": "/**\n * Obtains the list of locales to search through when performing\n * a locale search.\n *\n * <pre>\n * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n *   = [Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"fr\", \"CA\"), Locale(\"fr\"), Locale(\"en\"]\n * </pre>\n *\n * <p>The result list begins with the most specific locale, then the\n * next more general and so on, finishing with the default locale.\n * The list will never contain the same locale twice.</p>\n *\n * @param locale  the locale to start from, null returns empty list\n * @param defaultLocale  the default locale to use if no other is found\n * @return the unmodifiable list of Locale objects, 0 being locale, not null\n */\n", "repo_name": "commons-lang-master/", "id": 718, "method_signature": "List<Locale> localeLookupList(Locale, Locale)", "filename": "LocaleUtils.localeLookupList.json"}
{"callee_method_names": ["String.indexOf", "String.split", "String.split", "String.isEmpty", "String.isEmpty"], "method_name": "LocaleUtils.parseLocale", "method_implementation": "{\n    if (isISO639LanguageCode(str)) {\n        return new Locale(str);\n    }\n    final String[] segments = str.indexOf(UNDERSCORE) != -1 ? str.split(String.valueOf(UNDERSCORE), -1) : str.split(String.valueOf(DASH), -1);\n    final String language = segments[0];\n    if (segments.length == 2) {\n        final String country = segments[1];\n        if (isISO639LanguageCode(language) && isISO3166CountryCode(country) || isNumericAreaCode(country)) {\n            return new Locale(language, country);\n        }\n    } else if (segments.length == 3) {\n        final String country = segments[1];\n        final String variant = segments[2];\n        if (isISO639LanguageCode(language) && (country.isEmpty() || isISO3166CountryCode(country) || isNumericAreaCode(country)) && !variant.isEmpty()) {\n            return new Locale(language, country, variant);\n        }\n    }\n    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n}", "repo_id": "8", "comment": "/**\n * Tries to parse a locale from the given String.\n *\n * @param str the String to parse a locale from.\n * @return a Locale instance parsed from the given String.\n * @throws IllegalArgumentException if the given String can not be parsed.\n */\n", "repo_name": "commons-lang-master/", "id": 719, "method_signature": "Locale parseLocale(String)", "filename": "LocaleUtils.parseLocale.json"}
{"callee_method_names": ["String.isEmpty", "String.contains", "String.length", "String.charAt", "String.charAt", "String.charAt", "String.substring", "String.charAt", "String.substring", "String.substring"], "method_name": "LocaleUtils.toLocale", "method_implementation": "{\n    if (str == null) {\n        // TODO Should this return the default locale?\n        return null;\n    }\n    if (str.isEmpty()) {\n        // LANG-941 - JDK 8 introduced an empty locale where all fields are blank\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        // LANG-879 - Cannot handle Java 7 script & extensions\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len = str.length();\n    if (len < 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 = str.charAt(0);\n    if (ch0 == UNDERSCORE || ch0 == DASH) {\n        if (len < 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 = str.charAt(1);\n        final char ch2 = str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len < 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) != ch0) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    return parseLocale(str);\n}", "repo_id": "8", "comment": "/**\n * Converts a String to a Locale.\n *\n * <p>This method takes the string format of a locale and creates the\n * locale object from it.</p>\n *\n * <pre>\n *   LocaleUtils.toLocale(\"\")           = new Locale(\"\", \"\")\n *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n *   LocaleUtils.toLocale(\"en-GB\")      = new Locale(\"en\", \"GB\")\n *   LocaleUtils.toLocale(\"en_001\")     = new Locale(\"en\", \"001\")\n *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n * </pre>\n *\n * <p>(#) The behavior of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n * Thus, the result from getVariant() may vary depending on your JDK.</p>\n *\n * <p>This method validates the input strictly.\n * The language code must be lowercase.\n * The country code must be uppercase.\n * The separator must be an underscore or a dash.\n * The length must be correct.\n * </p>\n *\n * @param str  the locale String to convert, null returns null\n * @return a Locale, null if null input\n * @throws IllegalArgumentException if the string is an invalid format\n * @see Locale#forLanguageTag(String)\n */\n", "repo_name": "commons-lang-master/", "id": 720, "method_signature": "Locale toLocale(String)", "filename": "LocaleUtils.toLocale.json"}
{"callee_method_names": ["List<Locale>.iterator", "Iterator<Locale>.hasNext", "Iterator<Locale>.next", "Locale.getVariant", "Locale.getLanguage", "String.equals", "Locale.getCountry"], "method_name": "LocaleUtilsTest.assertCountriesByLanguage", "method_implementation": "{\n    final List<Locale> list = LocaleUtils.countriesByLanguage(language);\n    final List<Locale> list2 = LocaleUtils.countriesByLanguage(language);\n    assertNotNull(list);\n    assertSame(list, list2);\n    //search through languages\n    for (final String country : countries) {\n        final Iterator<Locale> iterator = list.iterator();\n        boolean found = false;\n        // see if it was returned by the set\n        while (iterator.hasNext()) {\n            final Locale locale = iterator.next();\n            // should have an en empty variant\n            assertTrue(StringUtils.isEmpty(locale.getVariant()));\n            assertEquals(language, locale.getLanguage());\n            if (country.equals(locale.getCountry())) {\n                found = true;\n                break;\n            }\n        }\n        assertTrue(found, \"Could not find language: \" + country + \" for country: \" + language);\n    }\n    assertUnmodifiableCollection(list);\n}", "repo_id": "8", "comment": "/**\n * Make sure the country by language is correct. It checks that\n * the LocaleUtils.countryByLanguage(language) call contains the\n * array of countries passed in. It may contain more due to JVM\n * variations.\n *\n * @param language\n * @param countries array of countries that should be returned\n */\n", "repo_name": "commons-lang-master/", "id": 1847, "method_signature": "void assertCountriesByLanguage(String, String[])", "filename": "LocaleUtilsTest.assertCountriesByLanguage.json"}
{"callee_method_names": ["List<Locale>.iterator", "Iterator<Locale>.hasNext", "Iterator<Locale>.next", "Locale.getVariant", "Locale.getCountry", "String.equals", "Locale.getLanguage"], "method_name": "LocaleUtilsTest.assertLanguageByCountry", "method_implementation": "{\n    final List<Locale> list = LocaleUtils.languagesByCountry(country);\n    final List<Locale> list2 = LocaleUtils.languagesByCountry(country);\n    assertNotNull(list);\n    assertSame(list, list2);\n    //search through languages\n    for (final String language : languages) {\n        final Iterator<Locale> iterator = list.iterator();\n        boolean found = false;\n        // see if it was returned by the set\n        while (iterator.hasNext()) {\n            final Locale locale = iterator.next();\n            // should have an en empty variant\n            assertTrue(StringUtils.isEmpty(locale.getVariant()));\n            assertEquals(country, locale.getCountry());\n            if (language.equals(locale.getLanguage())) {\n                found = true;\n                break;\n            }\n        }\n        assertTrue(found, \"Could not find language: \" + language + \" for country: \" + country);\n    }\n    assertUnmodifiableCollection(list);\n}", "repo_id": "8", "comment": "/**\n * Make sure the language by country is correct. It checks that\n * the LocaleUtils.languagesByCountry(country) call contains the\n * array of languages passed in. It may contain more due to JVM\n * variations.\n *\n * @param country\n * @param languages array of languages that should be returned\n */\n", "repo_name": "commons-lang-master/", "id": 1848, "method_signature": "void assertLanguageByCountry(String, String[])", "filename": "LocaleUtilsTest.assertLanguageByCountry.json"}
{"callee_method_names": ["List<Locale>.size"], "method_name": "LocaleUtilsTest.assertLocaleLookupList", "method_implementation": "{\n    final List<Locale> localeList = defaultLocale == null ? LocaleUtils.localeLookupList(locale) : LocaleUtils.localeLookupList(locale, defaultLocale);\n    assertEquals(expected.length, localeList.size());\n    assertEquals(Arrays.asList(expected), localeList);\n    assertUnmodifiableCollection(localeList);\n}", "repo_id": "8", "comment": "/**\n * Helper method for local lookups.\n *\n * @param locale  the input locale\n * @param defaultLocale  the input default locale\n * @param expected  expected results\n */\n", "repo_name": "commons-lang-master/", "id": 1849, "method_signature": "void assertLocaleLookupList(Locale, Locale, Locale[])", "filename": "LocaleUtilsTest.assertLocaleLookupList.json"}
{"callee_method_names": ["Locale.getLanguage", "Locale.getCountry", "Locale.getVariant"], "method_name": "LocaleUtilsTest.assertValidToLocale", "method_implementation": "{\n    final Locale locale = LocaleUtils.toLocale(localeString);\n    assertNotNull(locale, \"valid locale\");\n    assertEquals(language, locale.getLanguage());\n    assertEquals(country, locale.getCountry());\n    assertEquals(variant, locale.getVariant());\n}", "repo_id": "8", "comment": "/**\n * Pass in a valid language, test toLocale.\n *\n * @param localeString to pass to toLocale()\n * @param language of the resulting Locale\n * @param country of the resulting Locale\n * @param variant of the resulting Locale\n */\n", "repo_name": "commons-lang-master/", "id": 1852, "method_signature": "void assertValidToLocale(String, String, String, String)", "filename": "LocaleUtilsTest.assertValidToLocale.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testAvailableLocaleList", "method_implementation": "{\n    final List<Locale> list = LocaleUtils.availableLocaleList();\n    final List<Locale> list2 = LocaleUtils.availableLocaleList();\n    assertNotNull(list);\n    assertSame(list, list2);\n    assertUnmodifiableCollection(list);\n    final Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n    final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n    assertEquals(jdkLocaleList, list);\n}", "repo_id": "8", "comment": "/**\n * Test availableLocaleList() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1853, "method_signature": "void testAvailableLocaleList()", "filename": "LocaleUtilsTest.testAvailableLocaleList.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testAvailableLocaleSet", "method_implementation": "{\n    final Set<Locale> set = LocaleUtils.availableLocaleSet();\n    final Set<Locale> set2 = LocaleUtils.availableLocaleSet();\n    assertNotNull(set);\n    assertSame(set, set2);\n    assertUnmodifiableCollection(set);\n    final Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n    final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n    final Set<Locale> jdkLocaleSet = new HashSet<>(jdkLocaleList);\n    assertEquals(jdkLocaleSet, set);\n}", "repo_id": "8", "comment": "/**\n * Test availableLocaleSet() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1854, "method_signature": "void testAvailableLocaleSet()", "filename": "LocaleUtilsTest.testAvailableLocaleSet.json"}
{"callee_method_names": ["Constructor<?>[].getModifiers"], "method_name": "LocaleUtilsTest.testConstructor", "method_implementation": "{\n    assertNotNull(new LocaleUtils());\n    final Constructor<?>[] cons = LocaleUtils.class.getDeclaredConstructors();\n    assertEquals(1, cons.length);\n    assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n    assertTrue(Modifier.isPublic(LocaleUtils.class.getModifiers()));\n    assertFalse(Modifier.isFinal(LocaleUtils.class.getModifiers()));\n}", "repo_id": "8", "comment": "/**\n * Test that constructors are public, and work, etc.\n */\n", "repo_name": "commons-lang-master/", "id": 1855, "method_signature": "void testConstructor()", "filename": "LocaleUtilsTest.testConstructor.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testCountriesByLanguage", "method_implementation": "{\n    assertCountriesByLanguage(null, new String[0]);\n    assertCountriesByLanguage(\"de\", new String[] { \"DE\", \"CH\", \"AT\", \"LU\" });\n    assertCountriesByLanguage(\"zz\", new String[0]);\n    assertCountriesByLanguage(\"it\", new String[] { \"IT\", \"CH\" });\n}", "repo_id": "8", "comment": "/**\n * Test countriesByLanguage() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1856, "method_signature": "void testCountriesByLanguage()", "filename": "LocaleUtilsTest.testCountriesByLanguage.json"}
{"callee_method_names": ["Set<Locale>.contains", "Set<Locale>.contains", "Set<Locale>.contains", "Set<Locale>.contains", "Set<Locale>.contains", "Set<Locale>.contains", "Set<Locale>.contains"], "method_name": "LocaleUtilsTest.testIsAvailableLocale", "method_implementation": "{\n    final Set<Locale> set = LocaleUtils.availableLocaleSet();\n    assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n    assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n    assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n    assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));\n    assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));\n    assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));\n    assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));\n}", "repo_id": "8", "comment": "/**\n * Test availableLocaleSet() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1857, "method_signature": "void testIsAvailableLocale()", "filename": "LocaleUtilsTest.testIsAvailableLocale.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testLang328", "method_implementation": "{\n    assertValidToLocale(\"fr__P\", \"fr\", \"\", \"P\");\n    assertValidToLocale(\"fr__POSIX\", \"fr\", \"\", \"POSIX\");\n}", "repo_id": "8", "comment": "/**\n * Tests #LANG-328 - only language+variant\n */\n", "repo_name": "commons-lang-master/", "id": 1858, "method_signature": "void testLang328()", "filename": "LocaleUtilsTest.testLang328.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testLang865", "method_implementation": "{\n    assertValidToLocale(\"_GB\", \"\", \"GB\", \"\");\n    assertValidToLocale(\"_GB_P\", \"\", \"GB\", \"P\");\n    assertValidToLocale(\"_GB_POSIX\", \"\", \"GB\", \"POSIX\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"_G\"), \"Must be at least 3 chars if starts with underscore\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"_Gb\"), \"Must be uppercase if starts with underscore\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"_gB\"), \"Must be uppercase if starts with underscore\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"_1B\"), \"Must be letter if starts with underscore\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"_G1\"), \"Must be letter if starts with underscore\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"_GB_\"), \"Must be at least 5 chars if starts with underscore\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"_GBAP\"), \"Must have underscore after the country if starts with underscore and is at least 5 chars\");\n}", "repo_id": "8", "comment": "/**\n * Tests #LANG-865, strings starting with an underscore.\n */\n", "repo_name": "commons-lang-master/", "id": 1859, "method_signature": "void testLang865()", "filename": "LocaleUtilsTest.testLang865.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testLanguagesByCountry", "method_implementation": "{\n    assertLanguageByCountry(null, new String[0]);\n    assertLanguageByCountry(\"GB\", new String[] { \"en\" });\n    assertLanguageByCountry(\"ZZ\", new String[0]);\n    assertLanguageByCountry(\"CH\", new String[] { \"fr\", \"de\", \"it\" });\n}", "repo_id": "8", "comment": "/**\n * Test languagesByCountry() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1860, "method_signature": "void testLanguagesByCountry()", "filename": "LocaleUtilsTest.testLanguagesByCountry.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testLocaleLookupList_Locale", "method_implementation": "{\n    assertLocaleLookupList(null, null, new Locale[0]);\n    assertLocaleLookupList(LOCALE_QQ, null, new Locale[] { LOCALE_QQ });\n    assertLocaleLookupList(LOCALE_EN, null, new Locale[] { LOCALE_EN });\n    assertLocaleLookupList(LOCALE_EN, null, new Locale[] { LOCALE_EN });\n    assertLocaleLookupList(LOCALE_EN_US, null, new Locale[] { LOCALE_EN_US, LOCALE_EN });\n    assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN });\n}", "repo_id": "8", "comment": "/**\n * Test localeLookupList() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1861, "method_signature": "void testLocaleLookupList_Locale()", "filename": "LocaleUtilsTest.testLocaleLookupList_Locale.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testLocaleLookupList_LocaleLocale", "method_implementation": "{\n    assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, new Locale[] { LOCALE_QQ });\n    assertLocaleLookupList(LOCALE_EN, LOCALE_EN, new Locale[] { LOCALE_EN });\n    assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, new Locale[] { LOCALE_EN_US, LOCALE_EN });\n    assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ, new Locale[] { LOCALE_EN_US, LOCALE_EN, LOCALE_QQ });\n    assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ, new Locale[] { LOCALE_EN_US, LOCALE_EN, LOCALE_QQ_ZZ });\n    assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN });\n    assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN });\n    assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN, LOCALE_QQ });\n    assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN, LOCALE_QQ_ZZ });\n    assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN, new Locale[] { LOCALE_FR_CA, LOCALE_FR, LOCALE_EN });\n}", "repo_id": "8", "comment": "/**\n * Test localeLookupList() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1862, "method_signature": "void testLocaleLookupList_LocaleLocale()", "filename": "LocaleUtilsTest.testLocaleLookupList_LocaleLocale.json"}
{"callee_method_names": ["Locale.getLanguage", "Locale.getCountry"], "method_name": "LocaleUtilsTest.testThreeCharsLocale", "method_implementation": "{\n    for (final String str : Arrays.asList(\"udm\", \"tet\")) {\n        final Locale locale = LocaleUtils.toLocale(str);\n        assertNotNull(locale);\n        assertEquals(str, locale.getLanguage());\n        assertTrue(StringUtils.isBlank(locale.getCountry()));\n        assertEquals(new Locale(str), locale);\n    }\n}", "repo_id": "8", "comment": "/**\n * Test for 3-chars locale, further details at LANG-915\n */\n", "repo_name": "commons-lang-master/", "id": 1863, "method_signature": "void testThreeCharsLocale()", "filename": "LocaleUtilsTest.testThreeCharsLocale.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testToLocale_1Part", "method_implementation": "{\n    assertNull(LocaleUtils.toLocale((String) null));\n    assertValidToLocale(\"us\");\n    assertValidToLocale(\"fr\");\n    assertValidToLocale(\"de\");\n    assertValidToLocale(\"zh\");\n    // Valid format but lang doesn't exist, should make instance anyway\n    assertValidToLocale(\"qq\");\n    // LANG-941: JDK 8 introduced the empty locale as one of the default locales\n    assertValidToLocale(\"\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"Us\"), \"Should fail if not lowercase\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"uS\"), \"Should fail if not lowercase\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"u#\"), \"Should fail if not lowercase\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"u\"), \"Must be 2 chars if less than 5\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"uu_U\"), \"Must be 2 chars if less than 5\");\n}", "repo_id": "8", "comment": "/**\n * Test toLocale(String) method.\n */\n", "repo_name": "commons-lang-master/", "id": 1864, "method_signature": "void testToLocale_1Part()", "filename": "LocaleUtilsTest.testToLocale_1Part.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testToLocale_2Part", "method_implementation": "{\n    assertValidToLocale(\"us_EN\", \"us\", \"EN\");\n    assertValidToLocale(\"us-EN\", \"us\", \"EN\");\n    //valid though doesn't exist\n    assertValidToLocale(\"us_ZH\", \"us\", \"ZH\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"us_En\"), \"Should fail second part not uppercase\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"us_en\"), \"Should fail second part not uppercase\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"us_eN\"), \"Should fail second part not uppercase\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"uS_EN\"), \"Should fail first part not lowercase\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"us_E3\"), \"Should fail second part not uppercase\");\n}", "repo_id": "8", "comment": "/**\n * Test toLocale() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1865, "method_signature": "void testToLocale_2Part()", "filename": "LocaleUtilsTest.testToLocale_2Part.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testToLocale_3Part", "method_implementation": "{\n    assertValidToLocale(\"us_EN_A\", \"us\", \"EN\", \"A\");\n    assertValidToLocale(\"us-EN-A\", \"us\", \"EN\", \"A\");\n    // this isn't pretty, but was caused by a jdk bug it seems\n    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4210525\n    if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) {\n        assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"a\");\n        assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFsafdFDsdfF\");\n    } else {\n        assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"A\");\n        assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFSAFDFDSDFF\");\n    }\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"us_EN-a\"), \"Should fail as no consistent delimiter\");\n    assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(\"uu_UU_\"), \"Must be 3, 5 or 7+ in length\");\n}", "repo_id": "8", "comment": "/**\n * Test toLocale() method.\n */\n", "repo_name": "commons-lang-master/", "id": 1866, "method_signature": "void testToLocale_3Part()", "filename": "LocaleUtilsTest.testToLocale_3Part.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testToLocale_Locale_defaults", "method_implementation": "{\n    assertNull(LocaleUtils.toLocale((String) null));\n    assertEquals(Locale.getDefault(), LocaleUtils.toLocale((Locale) null));\n    assertEquals(Locale.getDefault(), LocaleUtils.toLocale(Locale.getDefault()));\n}", "repo_id": "8", "comment": "/**\n * Test toLocale(Locale) method.\n */\n", "repo_name": "commons-lang-master/", "id": 1867, "method_signature": "void testToLocale_Locale_defaults()", "filename": "LocaleUtilsTest.testToLocale_Locale_defaults.json"}
{"callee_method_names": [], "method_name": "LocaleUtilsTest.testToLocales", "method_implementation": "{\n    assertEquals(actualLocale, LocaleUtils.toLocale(actualLocale));\n}", "repo_id": "8", "comment": "/**\n * Test toLocale(Locale) method.\n */\n", "repo_name": "commons-lang-master/", "id": 1868, "method_signature": "void testToLocales(Locale)", "filename": "LocaleUtilsTest.testToLocales.json"}
{"callee_method_names": ["Supplier<Lock>.get", "Lock.lock", "FailableConsumer<O,?>.accept", "Lock.unlock"], "method_name": "LockVisitor.lockAcceptUnlock", "method_implementation": "{\n    final Lock lock = lockSupplier.get();\n    lock.lock();\n    try {\n        consumer.accept(object);\n    } catch (final Throwable t) {\n        throw Failable.rethrow(t);\n    } finally {\n        lock.unlock();\n    }\n}", "repo_id": "8", "comment": "/**\n * This method provides the default implementation for {@link #acceptReadLocked(FailableConsumer)}, and\n * {@link #acceptWriteLocked(FailableConsumer)}.\n *\n * @param lockSupplier A supplier for the lock. (This provides, in fact, a long, because a {@link StampedLock} is used\n *        internally.)\n * @param consumer The consumer, which is to be given access to the locked (hidden) object, which will be passed\n *        as a parameter.\n * @see #acceptReadLocked(FailableConsumer)\n * @see #acceptWriteLocked(FailableConsumer)\n */\n", "repo_name": "commons-lang-master/", "id": 124, "method_signature": "void lockAcceptUnlock(Supplier, FailableConsumer)", "filename": "LockVisitor.lockAcceptUnlock.json"}
{"callee_method_names": ["Supplier<Lock>.get", "Lock.lock", "FailableFunction<O,T,?>.apply", "Lock.unlock"], "method_name": "LockVisitor.lockApplyUnlock", "method_implementation": "{\n    final Lock lock = lockSupplier.get();\n    lock.lock();\n    try {\n        return function.apply(object);\n    } catch (final Throwable t) {\n        throw Failable.rethrow(t);\n    } finally {\n        lock.unlock();\n    }\n}", "repo_id": "8", "comment": "/**\n * This method provides the actual implementation for {@link #applyReadLocked(FailableFunction)}, and\n * {@link #applyWriteLocked(FailableFunction)}.\n *\n * @param <T> The result type (both the functions, and this method's.)\n * @param lockSupplier A supplier for the lock. (This provides, in fact, a long, because a {@link StampedLock} is used\n *        internally.)\n * @param function The function, which is being invoked to compute the result object. This function will receive\n *        the locked (hidden) object as a parameter.\n * @return The result object, which has been returned by the functions invocation.\n * @throws IllegalStateException The result object would be, in fact, the hidden object. This would extend\n *         access to the hidden object beyond this methods lifetime and will therefore be prevented.\n * @see #applyReadLocked(FailableFunction)\n * @see #applyWriteLocked(FailableFunction)\n */\n", "repo_name": "commons-lang-master/", "id": 125, "method_signature": "T lockApplyUnlock(Supplier, FailableFunction)", "filename": "LockVisitor.lockApplyUnlock.json"}
{"callee_method_names": ["Supplier<Lock>.get", "Lock.lock", "FailableConsumer<O,?>.accept", "Lock.unlock"], "method_name": "LockingVisitors.lockAcceptUnlock", "method_implementation": "{\n    final Lock lock = lockSupplier.get();\n    lock.lock();\n    try {\n        consumer.accept(object);\n    } catch (final Throwable t) {\n        throw Failable.rethrow(t);\n    } finally {\n        lock.unlock();\n    }\n}", "repo_id": "8", "comment": "/**\n * This method provides the default implementation for {@link #acceptReadLocked(FailableConsumer)}, and\n * {@link #acceptWriteLocked(FailableConsumer)}.\n *\n * @param lockSupplier A supplier for the lock. (This provides, in fact, a long, because a {@link StampedLock} is used\n *        internally.)\n * @param consumer The consumer, which is to be given access to the locked (hidden) object, which will be passed\n *        as a parameter.\n * @see #acceptReadLocked(FailableConsumer)\n * @see #acceptWriteLocked(FailableConsumer)\n */\n", "repo_name": "commons-lang-master/", "id": 122, "method_signature": "void lockAcceptUnlock(Supplier, FailableConsumer)", "filename": "LockingVisitors.lockAcceptUnlock.json"}
{"callee_method_names": ["Supplier<Lock>.get", "Lock.lock", "FailableFunction<O,T,?>.apply", "Lock.unlock"], "method_name": "LockingVisitors.lockApplyUnlock", "method_implementation": "{\n    final Lock lock = lockSupplier.get();\n    lock.lock();\n    try {\n        return function.apply(object);\n    } catch (final Throwable t) {\n        throw Failable.rethrow(t);\n    } finally {\n        lock.unlock();\n    }\n}", "repo_id": "8", "comment": "/**\n * This method provides the actual implementation for {@link #applyReadLocked(FailableFunction)}, and\n * {@link #applyWriteLocked(FailableFunction)}.\n *\n * @param <T> The result type (both the functions, and this method's.)\n * @param lockSupplier A supplier for the lock. (This provides, in fact, a long, because a {@link StampedLock} is used\n *        internally.)\n * @param function The function, which is being invoked to compute the result object. This function will receive\n *        the locked (hidden) object as a parameter.\n * @return The result object, which has been returned by the functions invocation.\n * @throws IllegalStateException The result object would be, in fact, the hidden object. This would extend\n *         access to the hidden object beyond this methods lifetime and will therefore be prevented.\n * @see #applyReadLocked(FailableFunction)\n * @see #applyWriteLocked(FailableFunction)\n */\n", "repo_name": "commons-lang-master/", "id": 123, "method_signature": "T lockApplyUnlock(Supplier, FailableFunction)", "filename": "LockingVisitors.lockApplyUnlock.json"}
{"callee_method_names": ["HashSet<Character>.contains", "CharSequence.charAt", "CharSequence.length", "CharSequence.length", "CharSequence.subSequence", "HashMap<String, String>.get", "CharSequence.toString", "Writer.write"], "method_name": "LookupTranslator.translate", "method_implementation": "{\n    // check if translation exists for the input at position index\n    if (prefixSet.contains(input.charAt(index))) {\n        int max = longest;\n        if (index + longest > input.length()) {\n            max = input.length() - index;\n        }\n        // implement greedy algorithm by trying maximum match first\n        for (int i = max; i >= shortest; i--) {\n            final CharSequence subSeq = input.subSequence(index, index + i);\n            final String result = lookupMap.get(subSeq.toString());\n            if (result != null) {\n                out.write(result);\n                return i;\n            }\n        }\n    }\n    return 0;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 428, "method_signature": "int translate(CharSequence, int, Writer)", "filename": "LookupTranslator.translate.json"}
{"callee_method_ids": [428], "callee_method_names": ["LookupTranslator.translate", "StringWriter.toString"], "method_name": "LookupTranslatorTest.testLang882", "method_implementation": "{\n    final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { new StringBuffer(\"one\"), new StringBuffer(\"two\") } });\n    final StringWriter out = new StringWriter();\n    final int result = lt.translate(new StringBuffer(\"one\"), 0, out);\n    assertEquals(3, result, \"Incorrect code point consumption\");\n    assertEquals(\"two\", out.toString(), \"Incorrect value\");\n}", "repo_id": "8", "comment": "// Tests: https://issues.apache.org/jira/browse/LANG-882\n", "repo_name": "commons-lang-master/", "id": 1744, "method_signature": "void testLang882()", "filename": "LookupTranslatorTest.testLang882.json"}
{"callee_method_names": ["Map<String, V>.get"], "method_name": "MapStrLookup.lookup", "method_implementation": "{\n    if (map == null) {\n        return null;\n    }\n    return Objects.toString(map.get(key), null);\n}", "repo_id": "8", "comment": "/**\n * Looks up a String key to a String value using the map.\n * <p>\n * If the map is null, then null is returned.\n * The map result object is converted to a string using toString().\n * </p>\n *\n * @param key  the key to be looked up, may be null\n * @return the matching value, null if no match\n */\n", "repo_name": "commons-lang-master/", "id": 384, "method_signature": "String lookup(String)", "filename": "MapStrLookup.lookup.json"}
{"callee_method_names": [], "method_name": "MemberUtils.compareParameterTypes", "method_implementation": "{\n    final float leftCost = getTotalTransformationCost(actual, left);\n    final float rightCost = getTotalTransformationCost(actual, right);\n    return Float.compare(leftCost, rightCost);\n}", "repo_id": "8", "comment": "/**\n * Compares the relative fitness of two Executables in terms of how well they\n * match a set of runtime parameter types, such that a list ordered\n * by the results of the comparison would return the best match first\n * (least).\n *\n * @param left the \"left\" Executable\n * @param right the \"right\" Executable\n * @param actual the runtime parameter types to match against\n * {@code left}/{@code right}\n * @return int consistent with {@code compare} semantics\n */\n", "repo_name": "commons-lang-master/", "id": 342, "method_signature": "int compareParameterTypes(Executable, Executable, Class<?>[])", "filename": "MemberUtils.compareParameterTypes.json"}
{"callee_method_names": ["Class<?>.isPrimitive", "Class<?>.equals", "Class<?>.isInterface", "Class<?>.getSuperclass"], "method_name": "MemberUtils.getObjectTransformationCost", "method_implementation": "{\n    if (destClass.isPrimitive()) {\n        return getPrimitivePromotionCost(srcClass, destClass);\n    }\n    float cost = 0.0f;\n    while (srcClass != null && !destClass.equals(srcClass)) {\n        if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {\n            // slight penalty for interface match.\n            // we still want an exact match to override an interface match,\n            // but\n            // an interface match should override anything where we have to\n            // get a superclass.\n            cost += 0.25f;\n            break;\n        }\n        cost++;\n        srcClass = srcClass.getSuperclass();\n    }\n    /*\n         * If the destination class is null, we've traveled all the way up to\n         * an Object match. We'll penalize this by adding 1.5 to the cost.\n         */\n    if (srcClass == null) {\n        cost += 1.5f;\n    }\n    return cost;\n}", "repo_id": "8", "comment": "/**\n * Gets the number of steps needed to turn the source class into\n * the destination class. This represents the number of steps in the object\n * hierarchy graph.\n * @param srcClass The source class\n * @param destClass The destination class\n * @return The cost of transforming an object\n */\n", "repo_name": "commons-lang-master/", "id": 343, "method_signature": "float getObjectTransformationCost(Class, Class)", "filename": "MemberUtils.getObjectTransformationCost.json"}
{"callee_method_names": ["Class<?>.isPrimitive"], "method_name": "MemberUtils.getPrimitivePromotionCost", "method_implementation": "{\n    if (srcClass == null) {\n        return 1.5f;\n    }\n    float cost = 0.0f;\n    Class<?> cls = srcClass;\n    if (!cls.isPrimitive()) {\n        // slight unwrapping penalty\n        cost += 0.1f;\n        cls = ClassUtils.wrapperToPrimitive(cls);\n    }\n    for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\n        if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\n            cost += 0.1f;\n            if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {\n                cls = ORDERED_PRIMITIVE_TYPES[i + 1];\n            }\n        }\n    }\n    return cost;\n}", "repo_id": "8", "comment": "/**\n * Gets the number of steps required to promote a primitive number to another\n * type.\n * @param srcClass the (primitive) source class\n * @param destClass the (primitive) destination class\n * @return The cost of promoting the primitive\n */\n", "repo_name": "commons-lang-master/", "id": 344, "method_signature": "float getPrimitivePromotionCost(Class, Class)", "filename": "MemberUtils.getPrimitivePromotionCost.json"}
{"callee_method_names": ["Executable.getParameterTypes", "Executable.isVarArgs", "Class<?>[].isArray", "Class<?>[].getComponentType", "Class<?>[].getComponentType"], "method_name": "MemberUtils.getTotalTransformationCost", "method_implementation": "{\n    final Class<?>[] destArgs = executable.getParameterTypes();\n    final boolean isVarArgs = executable.isVarArgs();\n    // \"source\" and \"destination\" are the actual and declared args respectively.\n    float totalCost = 0.0f;\n    final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length;\n    if (srcArgs.length < normalArgsLen) {\n        return Float.MAX_VALUE;\n    }\n    for (int i = 0; i < normalArgsLen; i++) {\n        totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]);\n    }\n    if (isVarArgs) {\n        // When isVarArgs is true, srcArgs and dstArgs may differ in length.\n        // There are two special cases to consider:\n        final boolean noVarArgsPassed = srcArgs.length < destArgs.length;\n        final boolean explicitArrayForVarargs = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1] != null && srcArgs[srcArgs.length - 1].isArray();\n        final float varArgsCost = 0.001f;\n        final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType();\n        if (noVarArgsPassed) {\n            // When no varargs passed, the best match is the most generic matching type, not the most specific.\n            totalCost += getObjectTransformationCost(destClass, Object.class) + varArgsCost;\n        } else if (explicitArrayForVarargs) {\n            final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType();\n            totalCost += getObjectTransformationCost(sourceClass, destClass) + varArgsCost;\n        } else {\n            // This is typical varargs case.\n            for (int i = destArgs.length - 1; i < srcArgs.length; i++) {\n                final Class<?> srcClass = srcArgs[i];\n                totalCost += getObjectTransformationCost(srcClass, destClass) + varArgsCost;\n            }\n        }\n    }\n    return totalCost;\n}", "repo_id": "8", "comment": "/**\n * Returns the sum of the object transformation cost for each class in the\n * source argument list.\n * @param srcArgs The source arguments\n * @param executable The executable to calculate transformation costs for\n * @return The total transformation cost\n */\n", "repo_name": "commons-lang-master/", "id": 345, "method_signature": "float getTotalTransformationCost(Class<?>[], Executable)", "filename": "MemberUtils.getTotalTransformationCost.json"}
{"callee_method_names": ["T.isAccessible", "T.isAccessible", "Member.getDeclaringClass", "T.setAccessible"], "method_name": "MemberUtils.setAccessibleWorkaround", "method_implementation": "{\n    if (obj == null || obj.isAccessible()) {\n        return obj;\n    }\n    final Member m = (Member) obj;\n    if (!obj.isAccessible() && isPublic(m) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n        try {\n            obj.setAccessible(true);\n            return obj;\n        } catch (final SecurityException ignored) {\n            // ignore in favor of subsequent IllegalAccessException\n        }\n    }\n    return obj;\n}", "repo_id": "8", "comment": "/**\n * Default access superclass workaround.\n *\n * When a {@code public} class has a default access superclass with {@code public} members,\n * these members are accessible. Calling them from compiled code works fine.\n * Unfortunately, on some JVMs, using reflection to invoke these members\n * seems to (wrongly) prevent access even when the modifier is {@code public}.\n * Calling {@code setAccessible(true)} solves the problem but will only work from\n * sufficiently privileged code. Better workarounds would be gratefully\n * accepted.\n * @param obj the AccessibleObject to set as accessible\n * @return a boolean indicating whether the accessibility of the object was set to true.\n */\n", "repo_name": "commons-lang-master/", "id": 346, "method_signature": "T setAccessibleWorkaround(T)", "filename": "MemberUtils.setAccessibleWorkaround.json"}
{"callee_method_names": ["ConcurrentHashMap.computeIfAbsent", "Future<O>.get", "ConcurrentHashMap.remove", "ConcurrentHashMap.remove", "Exception.getCause"], "method_name": "Memoizer.compute", "method_implementation": "{\n    while (true) {\n        final Future<O> future = cache.computeIfAbsent(arg, mappingFunction);\n        try {\n            return future.get();\n        } catch (final CancellationException e) {\n            cache.remove(arg, future);\n        } catch (final ExecutionException e) {\n            if (recalculate) {\n                cache.remove(arg, future);\n            }\n            throw launderException(e.getCause());\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * This method will return the result of the calculation and cache it, if it has not previously been calculated.\n *\n * <p>\n * This cache will also cache exceptions that occur during the computation if the {@code recalculate} parameter in the\n * constructor was set to {@code false}, or not set. Otherwise, if an exception happened on the previous calculation,\n * the method will attempt again to generate a value.\n * </p>\n *\n * @param arg the argument for the calculation\n * @return the result of the calculation\n * @throws InterruptedException thrown if the calculation is interrupted\n */\n", "repo_name": "commons-lang-master/", "id": 150, "method_signature": "O compute(I)", "filename": "Memoizer.compute.json"}
{"callee_method_names": ["Class<?>.equals"], "method_name": "MethodUtils.distance", "method_implementation": "{\n    int answer = 0;\n    if (!ClassUtils.isAssignable(fromClassArray, toClassArray, true)) {\n        return -1;\n    }\n    for (int offset = 0; offset < fromClassArray.length; offset++) {\n        // Note InheritanceUtils.distance() uses different scoring system.\n        final Class<?> aClass = fromClassArray[offset];\n        final Class<?> toClass = toClassArray[offset];\n        if (aClass == null || aClass.equals(toClass)) {\n            continue;\n        }\n        if (ClassUtils.isAssignable(aClass, toClass, true) && !ClassUtils.isAssignable(aClass, toClass, false)) {\n            answer++;\n        } else {\n            answer += 2;\n        }\n    }\n    return answer;\n}", "repo_id": "8", "comment": "/**\n * Returns the aggregate number of inheritance hops between assignable argument class types.  Returns -1\n * if the arguments aren't assignable.  Fills a specific purpose for getMatchingMethod and is not generalized.\n * @param fromClassArray the Class array to calculate the distance from.\n * @param toClassArray the Class array to calculate the distance to.\n * @return the aggregate number of inheritance hops between assignable argument class types.\n */\n", "repo_name": "commons-lang-master/", "id": 296, "method_signature": "int distance(Class<?>[], Class<?>[])", "filename": "MethodUtils.distance.json"}
{"callee_method_names": ["Method.getDeclaringClass", "Method.getName", "Method.getParameterTypes"], "method_name": "MethodUtils.getAccessibleMethod", "method_implementation": "{\n    if (!MemberUtils.isAccessible(method)) {\n        return null;\n    }\n    // If the declaring class is public, we are done\n    final Class<?> cls = method.getDeclaringClass();\n    if (ClassUtils.isPublic(cls)) {\n        return method;\n    }\n    final String methodName = method.getName();\n    final Class<?>[] parameterTypes = method.getParameterTypes();\n    // Check the implemented interfaces and subinterfaces\n    method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);\n    // Check the superclass chain\n    if (method == null) {\n        method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);\n    }\n    return method;\n}", "repo_id": "8", "comment": "/**\n * Returns an accessible method (that is, one that can be invoked via\n * reflection) that implements the specified Method. If no such method\n * can be found, return {@code null}.\n *\n * @param method The method that we wish to call\n * @return The accessible method\n */\n", "repo_name": "commons-lang-master/", "id": 298, "method_signature": "Method getAccessibleMethod(Method)", "filename": "MethodUtils.getAccessibleMethod.json"}
{"callee_method_names": ["Class<?>.getSuperclass", "Class<?>.getInterfaces"], "method_name": "MethodUtils.getAccessibleMethodFromInterfaceNest", "method_implementation": "{\n    // Search up the superclass chain\n    for (; cls != null; cls = cls.getSuperclass()) {\n        // Check the implemented interfaces of the parent class\n        final Class<?>[] interfaces = cls.getInterfaces();\n        for (final Class<?> anInterface : interfaces) {\n            // Is this interface public?\n            if (!ClassUtils.isPublic(anInterface)) {\n                continue;\n            }\n            // Does the method exist on this interface?\n            try {\n                return anInterface.getDeclaredMethod(methodName, parameterTypes);\n            } catch (final NoSuchMethodException ignored) {\n                /*\n                     * Swallow, if no method is found after the loop then this\n                     * method returns null.\n                     */\n            }\n            // Recursively check our parent interfaces\n            final Method method = getAccessibleMethodFromInterfaceNest(anInterface, methodName, parameterTypes);\n            if (method != null) {\n                return method;\n            }\n        }\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Returns an accessible method (that is, one that can be invoked via\n * reflection) that implements the specified method, by scanning through\n * all implemented interfaces and subinterfaces. If no such method\n * can be found, return {@code null}.\n *\n * <p>There isn't any good reason why this method must be {@code private}.\n * It is because there doesn't seem any reason why other classes should\n * call this rather than the higher level methods.</p>\n *\n * @param cls Parent class for the interfaces to be checked\n * @param methodName Method name of the method we wish to call\n * @param parameterTypes The parameter type signatures\n * @return the accessible method or {@code null} if not found\n */\n", "repo_name": "commons-lang-master/", "id": 299, "method_signature": "Method getAccessibleMethodFromInterfaceNest(Class, String, Class<?>[])", "filename": "MethodUtils.getAccessibleMethodFromInterfaceNest.json"}
{"callee_method_names": ["Class<?>.getSuperclass", "Class<?>.getMethod", "Class<?>.getSuperclass"], "method_name": "MethodUtils.getAccessibleMethodFromSuperclass", "method_implementation": "{\n    Class<?> parentClass = cls.getSuperclass();\n    while (parentClass != null) {\n        if (ClassUtils.isPublic(parentClass)) {\n            try {\n                return parentClass.getMethod(methodName, parameterTypes);\n            } catch (final NoSuchMethodException e) {\n                return null;\n            }\n        }\n        parentClass = parentClass.getSuperclass();\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Returns an accessible method (that is, one that can be invoked via\n * reflection) by scanning through the superclasses. If no such method\n * can be found, return {@code null}.\n *\n * @param cls Class to be checked\n * @param methodName Method name of the method we wish to call\n * @param parameterTypes The parameter type signatures\n * @return the accessible method or {@code null} if not found\n */\n", "repo_name": "commons-lang-master/", "id": 300, "method_signature": "Method getAccessibleMethodFromSuperclass(Class, String, Class<?>[])", "filename": "MethodUtils.getAccessibleMethodFromSuperclass.json"}
{"callee_method_names": ["List<Class<?>>.size", "List<Class<?>>.size", "List<Class<?>>.size", "List<Class<?>>.get", "List<Class<?>>.size", "List<Class<?>>.get", "List<Class<?>>.get", "List<Class<?>>.add"], "method_name": "MethodUtils.getAllSuperclassesAndInterfaces", "method_implementation": "{\n    if (cls == null) {\n        return null;\n    }\n    final List<Class<?>> allSuperClassesAndInterfaces = new ArrayList<>();\n    final List<Class<?>> allSuperclasses = ClassUtils.getAllSuperclasses(cls);\n    int superClassIndex = 0;\n    final List<Class<?>> allInterfaces = ClassUtils.getAllInterfaces(cls);\n    int interfaceIndex = 0;\n    while (interfaceIndex < allInterfaces.size() || superClassIndex < allSuperclasses.size()) {\n        final Class<?> acls;\n        if (interfaceIndex >= allInterfaces.size()) {\n            acls = allSuperclasses.get(superClassIndex++);\n        } else if (superClassIndex >= allSuperclasses.size() || !(superClassIndex < interfaceIndex)) {\n            acls = allInterfaces.get(interfaceIndex++);\n        } else {\n            acls = allSuperclasses.get(superClassIndex++);\n        }\n        allSuperClassesAndInterfaces.add(acls);\n    }\n    return allSuperClassesAndInterfaces;\n}", "repo_id": "8", "comment": "/**\n * Gets a combination of {@link ClassUtils#getAllSuperclasses(Class)} and\n * {@link ClassUtils#getAllInterfaces(Class)}, one from superclasses, one\n * from interfaces, and so on in a breadth first way.\n *\n * @param cls  the class to look up, may be {@code null}\n * @return the combined {@link List} of superclasses and interfaces in order\n * going up from this one\n *  {@code null} if null input\n */\n", "repo_name": "commons-lang-master/", "id": 301, "method_signature": "List<Class<?>> getAllSuperclassesAndInterfaces(Class)", "filename": "MethodUtils.getAllSuperclassesAndInterfaces.json"}
{"callee_method_names": ["Method.getAnnotation", "Method.getDeclaringClass", "Method.getName", "Method.getParameterTypes", "Method.getName", "Method.getParameterTypes", "Method.getAnnotation"], "method_name": "MethodUtils.getAnnotation", "method_implementation": "{\n    Objects.requireNonNull(method, \"method\");\n    Objects.requireNonNull(annotationCls, \"annotationCls\");\n    if (!ignoreAccess && !MemberUtils.isAccessible(method)) {\n        return null;\n    }\n    A annotation = method.getAnnotation(annotationCls);\n    if (annotation == null && searchSupers) {\n        final Class<?> mcls = method.getDeclaringClass();\n        final List<Class<?>> classes = getAllSuperclassesAndInterfaces(mcls);\n        for (final Class<?> acls : classes) {\n            final Method equivalentMethod = ignoreAccess ? MethodUtils.getMatchingMethod(acls, method.getName(), method.getParameterTypes()) : MethodUtils.getMatchingAccessibleMethod(acls, method.getName(), method.getParameterTypes());\n            if (equivalentMethod != null) {\n                annotation = equivalentMethod.getAnnotation(annotationCls);\n                if (annotation != null) {\n                    break;\n                }\n            }\n        }\n    }\n    return annotation;\n}", "repo_id": "8", "comment": "/**\n * Gets the annotation object with the given annotation type that is present on the given method\n * or optionally on any equivalent method in super classes and interfaces. Returns null if the annotation\n * type was not present.\n *\n * <p>Stops searching for an annotation once the first annotation of the specified type has been\n * found. Additional annotations of the specified type will be silently ignored.</p>\n * @param <A>\n *            the annotation type\n * @param method\n *            the {@link Method} to query\n * @param annotationCls\n *            the {@link Annotation} to check if is present on the method\n * @param searchSupers\n *            determines if a lookup in the entire inheritance hierarchy of the given class is performed\n *            if the annotation was not directly present\n * @param ignoreAccess\n *            determines if underlying method has to be accessible\n * @return the first matching annotation, or {@code null} if not found\n * @throws NullPointerException if either the method or annotation class is {@code null}\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 302, "method_signature": "A getAnnotation(Method, Class, boolean, boolean)", "filename": "MethodUtils.getAnnotation.json"}
{"callee_method_names": ["Class<?>.getMethod", "Class<?>.getMethods", "Method.getName", "List<Method>.sort", "Method.isVarArgs", "Method.getParameterTypes", "Method.getParameterTypes", "Class<?>[].getComponentType", "Class<?>.getName", "Class<?>.getSuperclass", "String.equals", "String.equals"], "method_name": "MethodUtils.getMatchingAccessibleMethod", "method_implementation": "{\n    try {\n        return MemberUtils.setAccessibleWorkaround(cls.getMethod(methodName, parameterTypes));\n    } catch (final NoSuchMethodException ignored) {\n        // Swallow the exception\n    }\n    // search through all methods\n    final Method[] methods = cls.getMethods();\n    final List<Method> matchingMethods = Stream.of(methods).filter(method -> method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)).collect(Collectors.toList());\n    // Sort methods by signature to force deterministic result\n    matchingMethods.sort(METHOD_BY_SIGNATURE);\n    Method bestMatch = null;\n    for (final Method method : matchingMethods) {\n        // get accessible version of method\n        final Method accessibleMethod = getAccessibleMethod(method);\n        if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) {\n            bestMatch = accessibleMethod;\n        }\n    }\n    if (bestMatch != null) {\n        MemberUtils.setAccessibleWorkaround(bestMatch);\n    }\n    if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n        final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();\n        final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n        final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName();\n        final Class<?> lastParameterType = parameterTypes[parameterTypes.length - 1];\n        final String parameterTypeName = lastParameterType == null ? null : lastParameterType.getName();\n        final String parameterTypeSuperClassName = lastParameterType == null ? null : lastParameterType.getSuperclass().getName();\n        if (parameterTypeName != null && parameterTypeSuperClassName != null && !methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {\n            return null;\n        }\n    }\n    return bestMatch;\n}", "repo_id": "8", "comment": "/**\n * Finds an accessible method that matches the given name and has compatible parameters.\n * Compatible parameters mean that every method parameter is assignable from\n * the given parameters.\n * In other words, it finds a method with the given name\n * that will take the parameters given.\n *\n * <p>This method is used by\n * {@link\n * #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n * </p>\n *\n * <p>This method can match primitive parameter by passing in wrapper classes.\n * For example, a {@link Boolean} will match a primitive {@code boolean}\n * parameter.\n * </p>\n *\n * @param cls find method in this class\n * @param methodName find method with this name\n * @param parameterTypes find method with most compatible parameters\n * @return The accessible method\n */\n", "repo_name": "commons-lang-master/", "id": 303, "method_signature": "Method getMatchingAccessibleMethod(Class, String, Class<?>[])", "filename": "MethodUtils.getMatchingAccessibleMethod.json"}
{"callee_method_names": ["Class<?>.getDeclaredMethods", "Method.getName", "Method.getName", "Method.getParameterTypes", "List<Method>.stream", "Method.getParameterTypes", "Method.getParameterTypes", "TreeMap<Integer, List<Method>>.computeIfAbsent", "List<Method>.add", "TreeMap<Integer, List<Method>>.isEmpty", "TreeMap<Integer, List<Method>>.values", "List<Method>.size", "List<Method>.get", "List<Method>.get", "List<Method>.get", "Class<?>.getName", "List<Method>.stream"], "method_name": "MethodUtils.getMatchingMethod", "method_implementation": "{\n    Objects.requireNonNull(cls, \"cls\");\n    Validate.notEmpty(methodName, \"methodName\");\n    final List<Method> methods = Stream.of(cls.getDeclaredMethods()).filter(method -> method.getName().equals(methodName)).collect(Collectors.toList());\n    ClassUtils.getAllSuperclasses(cls).stream().map(Class::getDeclaredMethods).flatMap(Stream::of).filter(method -> method.getName().equals(methodName)).forEach(methods::add);\n    for (final Method method : methods) {\n        if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n            return method;\n        }\n    }\n    final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n    methods.stream().filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)).forEach(method -> {\n        final int distance = distance(parameterTypes, method.getParameterTypes());\n        final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n        candidatesAtDistance.add(method);\n    });\n    if (candidates.isEmpty()) {\n        return null;\n    }\n    final List<Method> bestCandidates = candidates.values().iterator().next();\n    if (bestCandidates.size() == 1 || !Objects.equals(bestCandidates.get(0).getDeclaringClass(), bestCandidates.get(1).getDeclaringClass())) {\n        return bestCandidates.get(0);\n    }\n    throw new IllegalStateException(String.format(\"Found multiple candidates for method %s on class %s : %s\", methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")), cls.getName(), bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\"))));\n}", "repo_id": "8", "comment": "/**\n * Retrieves a method whether or not it's accessible. If no such method\n * can be found, return {@code null}.\n * @param cls The class that will be subjected to the method search\n * @param methodName The method that we wish to call\n * @param parameterTypes Argument class types\n * @throws IllegalStateException if there is no unique result\n * @throws NullPointerException if the class is {@code null}\n * @return The method\n *\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 304, "method_signature": "Method getMatchingMethod(Class, String, Class<?>[])", "filename": "MethodUtils.getMatchingMethod.json"}
{"callee_method_names": ["List<Class<?>>.add", "List<Class<?>>.forEach", "Class<?>.getDeclaredMethods", "Class<?>.getMethods", "Method.isAnnotationPresent"], "method_name": "MethodUtils.getMethodsListWithAnnotation", "method_implementation": "{\n    Objects.requireNonNull(cls, \"cls\");\n    Objects.requireNonNull(annotationCls, \"annotationCls\");\n    final List<Class<?>> classes = searchSupers ? getAllSuperclassesAndInterfaces(cls) : new ArrayList<>();\n    classes.add(0, cls);\n    final List<Method> annotatedMethods = new ArrayList<>();\n    classes.forEach(acls -> {\n        final Method[] methods = ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods();\n        Stream.of(methods).filter(method -> method.isAnnotationPresent(annotationCls)).forEachOrdered(annotatedMethods::add);\n    });\n    return annotatedMethods;\n}", "repo_id": "8", "comment": "/**\n * Gets all methods of the given class that are annotated with the given annotation.\n * @param cls\n *            the {@link Class} to query\n * @param annotationCls\n *            the {@link Annotation} that must be present on a method to be matched\n * @param searchSupers\n *            determines if a lookup in the entire inheritance hierarchy of the given class should be performed\n * @param ignoreAccess\n *            determines if non-public methods should be considered\n * @return a list of Methods (possibly empty).\n * @throws NullPointerException if either the class or annotation class is {@code null}\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 305, "method_signature": "List<Method> getMethodsListWithAnnotation(Class, Class, boolean, boolean)", "filename": "MethodUtils.getMethodsListWithAnnotation.json"}
{"callee_method_names": ["Set<Method>.add", "Method.getParameterTypes", "Method.getDeclaringClass", "Iterator<Class<?>>.next", "Iterator<Class<?>>.hasNext", "Iterator<Class<?>>.next", "Method.getName", "Method.getParameterTypes", "Set<Method>.add", "Method.getDeclaringClass", "Method.getGenericParameterTypes", "Method.getGenericParameterTypes", "Set<Method>.add"], "method_name": "MethodUtils.getOverrideHierarchy", "method_implementation": "{\n    Objects.requireNonNull(method, \"method\");\n    final Set<Method> result = new LinkedHashSet<>();\n    result.add(method);\n    final Class<?>[] parameterTypes = method.getParameterTypes();\n    final Class<?> declaringClass = method.getDeclaringClass();\n    final Iterator<Class<?>> hierarchy = ClassUtils.hierarchy(declaringClass, interfacesBehavior).iterator();\n    //skip the declaring class :P\n    hierarchy.next();\n    hierarchyTraversal: while (hierarchy.hasNext()) {\n        final Class<?> c = hierarchy.next();\n        final Method m = getMatchingAccessibleMethod(c, method.getName(), parameterTypes);\n        if (m == null) {\n            continue;\n        }\n        if (Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n            // matches without generics\n            result.add(m);\n            continue;\n        }\n        // necessary to get arguments every time in the case that we are including interfaces\n        final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments(declaringClass, m.getDeclaringClass());\n        for (int i = 0; i < parameterTypes.length; i++) {\n            final Type childType = TypeUtils.unrollVariables(typeArguments, method.getGenericParameterTypes()[i]);\n            final Type parentType = TypeUtils.unrollVariables(typeArguments, m.getGenericParameterTypes()[i]);\n            if (!TypeUtils.equals(childType, parentType)) {\n                continue hierarchyTraversal;\n            }\n        }\n        result.add(m);\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Gets the hierarchy of overridden methods down to {@code result} respecting generics.\n * @param method lowest to consider\n * @param interfacesBehavior whether to search interfaces, {@code null} {@code implies} false\n * @return Set&lt;Method&gt; in ascending order from sub- to superclass\n * @throws NullPointerException if the specified method is {@code null}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 306, "method_signature": "Set<Method> getOverrideHierarchy(Method, Interfaces)", "filename": "MethodUtils.getOverrideHierarchy.json"}
{"callee_method_names": ["Object[].getClass", "Class<?>[].getComponentType", "Class<?>.isPrimitive"], "method_name": "MethodUtils.getVarArgs", "method_implementation": "{\n    if (args.length == methodParameterTypes.length && (args[args.length - 1] == null || args[args.length - 1].getClass().equals(methodParameterTypes[methodParameterTypes.length - 1]))) {\n        // The args array is already in the canonical form for the method.\n        return args;\n    }\n    // Construct a new array matching the method's declared parameter types.\n    final Object[] newArgs = new Object[methodParameterTypes.length];\n    // Copy the normal (non-varargs) parameters\n    System.arraycopy(args, 0, newArgs, 0, methodParameterTypes.length - 1);\n    // Construct a new array for the variadic parameters\n    final Class<?> varArgComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n    final int varArgLength = args.length - methodParameterTypes.length + 1;\n    Object varArgsArray = Array.newInstance(ClassUtils.primitiveToWrapper(varArgComponentType), varArgLength);\n    // Copy the variadic arguments into the varargs array.\n    System.arraycopy(args, methodParameterTypes.length - 1, varArgsArray, 0, varArgLength);\n    if (varArgComponentType.isPrimitive()) {\n        // unbox from wrapper type to primitive type\n        varArgsArray = ArrayUtils.toPrimitive(varArgsArray);\n    }\n    // Store the varargs array in the last position of the array to return\n    newArgs[methodParameterTypes.length - 1] = varArgsArray;\n    // Return the canonical varargs array.\n    return newArgs;\n}", "repo_id": "8", "comment": "/**\n * Given an arguments array passed to a varargs method, return an array of arguments in the canonical form,\n * i.e. an array with the declared number of parameters, and whose last parameter is an array of the varargs type.\n *\n * @param args the array of arguments passed to the varags method\n * @param methodParameterTypes the declared array of method parameter types\n * @return an array of the variadic arguments passed to the method\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 307, "method_signature": "Object[] getVarArgs(Object[], Class<?>[])", "filename": "MethodUtils.getVarArgs.json"}
{"callee_method_names": ["Object.getClass", "Class<?>.getName", "Method.invoke"], "method_name": "MethodUtils.invokeExactMethod", "method_implementation": "{\n    Objects.requireNonNull(object, \"object\");\n    args = ArrayUtils.nullToEmpty(args);\n    parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n    final Class<?> cls = object.getClass();\n    final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n    if (method == null) {\n        throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on object: \" + cls.getName());\n    }\n    return method.invoke(object, args);\n}", "repo_id": "8", "comment": "/**\n * Invokes a method whose parameter types match exactly the parameter\n * types given.\n *\n * <p>This uses reflection to invoke the method obtained from a call to\n * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n *\n * @param object invoke method on this object\n * @param methodName get method with this name\n * @param args use these arguments - treat null as empty array\n * @param parameterTypes match these parameters - treat {@code null} as empty array\n * @return The value returned by the invoked method\n *\n * @throws NoSuchMethodException if there is no such accessible method\n * @throws InvocationTargetException wraps an exception thrown by the\n *  method invoked\n * @throws IllegalAccessException if the requested method is not accessible\n *  via reflection\n * @throws NullPointerException if the object or method name are {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 309, "method_signature": "Object invokeExactMethod(Object, String, Object[], Class<?>[])", "filename": "MethodUtils.invokeExactMethod.json"}
{"callee_method_names": ["Class<?>.getName", "Method.invoke"], "method_name": "MethodUtils.invokeExactStaticMethod", "method_implementation": "{\n    args = ArrayUtils.nullToEmpty(args);\n    parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n    final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n    if (method == null) {\n        throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n    }\n    return method.invoke(null, args);\n}", "repo_id": "8", "comment": "/**\n * Invokes a {@code static} method whose parameter types match exactly the parameter\n * types given.\n *\n * <p>This uses reflection to invoke the method obtained from a call to\n * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n *\n * @param cls invoke static method on this class\n * @param methodName get method with this name\n * @param args use these arguments - treat {@code null} as empty array\n * @param parameterTypes match these parameters - treat {@code null} as empty array\n * @return The value returned by the invoked method\n *\n * @throws NoSuchMethodException if there is no such accessible method\n * @throws InvocationTargetException wraps an exception thrown by the\n *  method invoked\n * @throws IllegalAccessException if the requested method is not accessible\n *  via reflection\n */\n", "repo_name": "commons-lang-master/", "id": 311, "method_signature": "Object invokeExactStaticMethod(Class, String, Object[], Class<?>[])", "filename": "MethodUtils.invokeExactStaticMethod.json"}
{"callee_method_names": [], "method_name": "MethodUtils.invokeMethod", "method_implementation": "{\n    return invokeMethod(object, false, methodName, args, parameterTypes);\n}", "repo_id": "8", "comment": "/**\n * Invokes a named method whose parameter type matches the object type.\n *\n * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n *\n * <p>This method supports calls to methods taking primitive parameters\n * via passing in wrapping classes. So, for example, a {@link Boolean} object\n * would match a {@code boolean} primitive.</p>\n *\n * @param object invoke method on this object\n * @param methodName get method with this name\n * @param args use these arguments - treat null as empty array\n * @param parameterTypes match these parameters - treat null as empty array\n * @return The value returned by the invoked method\n *\n * @throws NoSuchMethodException if there is no such accessible method\n * @throws InvocationTargetException wraps an exception thrown by the method invoked\n * @throws IllegalAccessException if the requested method is not accessible via reflection\n */\n", "repo_name": "commons-lang-master/", "id": 315, "method_signature": "Object invokeMethod(Object, String, Object[], Class<?>[])", "filename": "MethodUtils.invokeMethod.json"}
{"callee_method_names": ["Class<?>.getName", "Method.invoke"], "method_name": "MethodUtils.invokeStaticMethod", "method_implementation": "{\n    args = ArrayUtils.nullToEmpty(args);\n    parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);\n    if (method == null) {\n        throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n    }\n    args = toVarArgs(method, args);\n    return method.invoke(null, args);\n}", "repo_id": "8", "comment": "/**\n * Invokes a named {@code static} method whose parameter type matches the object type.\n *\n * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n *\n * <p>This method supports calls to methods taking primitive parameters\n * via passing in wrapping classes. So, for example, a {@link Boolean} class\n * would match a {@code boolean} primitive.</p>\n *\n * @param cls invoke static method on this class\n * @param methodName get method with this name\n * @param args use these arguments - treat {@code null} as empty array\n * @param parameterTypes match these parameters - treat {@code null} as empty array\n * @return The value returned by the invoked method\n *\n * @throws NoSuchMethodException if there is no such accessible method\n * @throws InvocationTargetException wraps an exception thrown by the\n *  method invoked\n * @throws IllegalAccessException if the requested method is not accessible\n *  via reflection\n */\n", "repo_name": "commons-lang-master/", "id": 317, "method_signature": "Object invokeStaticMethod(Class, String, Object[], Class<?>[])", "filename": "MethodUtils.invokeStaticMethod.json"}
{"callee_method_names": ["HashMap.put"], "method_name": "MultiBackgroundInitializer.addInitializer", "method_implementation": "{\n    Objects.requireNonNull(name, \"name\");\n    Objects.requireNonNull(backgroundInitializer, \"backgroundInitializer\");\n    synchronized (this) {\n        if (isStarted()) {\n            throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n        }\n        childInitializers.put(name, backgroundInitializer);\n    }\n}", "repo_id": "8", "comment": "/**\n * Adds a new {@link BackgroundInitializer} to this object. When this\n * {@link MultiBackgroundInitializer} is started, the given initializer will\n * be processed. This method must not be called after {@link #start()} has\n * been invoked.\n *\n * @param name the name of the initializer (must not be <b>null</b>)\n * @param backgroundInitializer the {@link BackgroundInitializer} to add (must not be\n * <b>null</b>)\n * @throws NullPointerException if either {@code name} or {@code backgroundInitializer}\n *         is {@code null}\n * @throws IllegalStateException if {@code start()} has already been called\n */\n", "repo_name": "commons-lang-master/", "id": 145, "method_signature": "void addInitializer(String, BackgroundInitializer)", "filename": "MultiBackgroundInitializer.addInitializer.json"}
{"callee_method_names": ["Map<String, BackgroundInitializer<?>>.get"], "method_name": "MultiBackgroundInitializer.checkName", "method_implementation": "{\n    final BackgroundInitializer<?> init = initializers.get(name);\n    if (init == null) {\n        throw new NoSuchElementException(\"No child initializer with name \" + name);\n    }\n    return init;\n}", "repo_id": "8", "comment": "/**\n * Checks whether an initializer with the given name exists. If not,\n * throws an exception. If it exists, the associated child initializer\n * is returned.\n *\n * @param name the name to check\n * @return the initializer with this name\n * @throws NoSuchElementException if the name is unknown\n */\n", "repo_name": "commons-lang-master/", "id": 144, "method_signature": "BackgroundInitializer<?> checkName(String)", "filename": "MultiBackgroundInitializer.checkName.json"}
{"callee_method_names": ["HashMap.values", "ConcurrentException.addSuppressed", "Exception.getCause", "ConcurrentException.addSuppressed"], "method_name": "MultiBackgroundInitializer.close", "method_implementation": "{\n    ConcurrentException exception = null;\n    for (BackgroundInitializer<?> child : childInitializers.values()) {\n        try {\n            child.close();\n        } catch (Exception e) {\n            if (exception == null) {\n                exception = new ConcurrentException();\n            }\n            if (e instanceof ConcurrentException) {\n                // Because ConcurrentException is only created by classes in this package\n                // we can safely unwrap it.\n                exception.addSuppressed(e.getCause());\n            } else {\n                exception.addSuppressed(e);\n            }\n        }\n    }\n    if (exception != null) {\n        throw exception;\n    }\n}", "repo_id": "8", "comment": "/**\n * Calls the closer of all child {@code BackgroundInitializer} objects\n *\n * @throws ConcurrentException throws an ConcurrentException that will have all other exceptions as suppressed exceptions. ConcurrentException thrown by children will be unwrapped.\n * @since 3.14.0\n */\n", "repo_name": "commons-lang-master/", "id": 146, "method_signature": "void close()", "filename": "MultiBackgroundInitializer.close.json"}
{"callee_method_names": ["Map<String, BackgroundInitializer<?>>.values", "Map<String, BackgroundInitializer<?>>.forEach", "Map<String, Object>.put", "Map<String, ConcurrentException>.put"], "method_name": "MultiBackgroundInitializer.initialize", "method_implementation": "{\n    final Map<String, BackgroundInitializer<?>> inits;\n    synchronized (this) {\n        // create a snapshot to operate on\n        inits = new HashMap<>(childInitializers);\n    }\n    // start the child initializers\n    final ExecutorService exec = getActiveExecutor();\n    inits.values().forEach(bi -> {\n        if (bi.getExternalExecutor() == null) {\n            // share the executor service if necessary\n            bi.setExternalExecutor(exec);\n        }\n        bi.start();\n    });\n    // collect the results\n    final Map<String, Object> results = new HashMap<>();\n    final Map<String, ConcurrentException> excepts = new HashMap<>();\n    inits.forEach((k, v) -> {\n        try {\n            results.put(k, v.get());\n        } catch (final ConcurrentException cex) {\n            excepts.put(k, cex);\n        }\n    });\n    return new MultiBackgroundInitializerResults(inits, results, excepts);\n}", "repo_id": "8", "comment": "/**\n * Creates the results object. This implementation starts all child {@code\n * BackgroundInitializer} objects. Then it collects their results and\n * creates a {@link MultiBackgroundInitializerResults} object with this\n * data. If a child initializer throws a checked exceptions, it is added to\n * the results object. Unchecked exceptions are propagated.\n *\n * @return the results object\n * @throws Exception if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 147, "method_signature": "MultiBackgroundInitializerResults initialize()", "filename": "MultiBackgroundInitializer.initialize.json"}
{"callee_method_names": ["HashMap.isEmpty", "HashMap.values"], "method_name": "MultiBackgroundInitializer.isInitialized", "method_implementation": "{\n    if (childInitializers.isEmpty()) {\n        return false;\n    }\n    return childInitializers.values().stream().allMatch(BackgroundInitializer::isInitialized);\n}", "repo_id": "8", "comment": "/**\n * Tests whether this all child {@code BackgroundInitializer} objects are initialized.\n * Once initialized, always returns true.\n *\n * @return whether all child {@code BackgroundInitializer} objects instance are initialized. Once initialized, always returns true. If there are no child {@code BackgroundInitializer} objects return false.\n * @since 3.14.0\n */\n", "repo_name": "commons-lang-master/", "id": 148, "method_signature": "boolean isInitialized()", "filename": "MultiBackgroundInitializer.isInitialized.json"}
{"callee_method_names": ["Map<String, BackgroundInitializer<?>>.get"], "method_name": "MultiBackgroundInitializerResults.checkName", "method_implementation": "{\n    final BackgroundInitializer<?> init = initializers.get(name);\n    if (init == null) {\n        throw new NoSuchElementException(\"No child initializer with name \" + name);\n    }\n    return init;\n}", "repo_id": "8", "comment": "/**\n * Checks whether an initializer with the given name exists. If not,\n * throws an exception. If it exists, the associated child initializer\n * is returned.\n *\n * @param name the name to check\n * @return the initializer with this name\n * @throws NoSuchElementException if the name is unknown\n */\n", "repo_name": "commons-lang-master/", "id": 149, "method_signature": "BackgroundInitializer<?> checkName(String)", "filename": "MultiBackgroundInitializerResults.checkName.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.isInitialized", "ConcurrentInitializer<Object>.addInitializer", "ConcurrentInitializer<Object>.addInitializer", "AbstractChildBackgroundInitializer.getCloseableCounter", "AbstractChildBackgroundInitializer.getCloseableCounter", "ConcurrentInitializer<Object>.start", "AbstractChildBackgroundInitializer.isStarted", "AbstractChildBackgroundInitializer.isStarted", "AbstractChildBackgroundInitializer.getCloseableCounter", "AbstractChildBackgroundInitializer.getCloseableCounter", "AbstractChildBackgroundInitializer.get", "AbstractChildBackgroundInitializer.get", "AbstractChildBackgroundInitializer.getCloseableCounter", "AbstractChildBackgroundInitializer.getCloseableCounter", "ConcurrentInitializer<Object>.close", "AbstractChildBackgroundInitializer.getCloseableCounter", "AbstractChildBackgroundInitializer.getCloseableCounter"], "method_name": "MultiBackgroundInitializerSupplierTest.testClose", "method_implementation": "{\n    final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n    final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n    assertFalse(initializer.isInitialized(), \"Initialized without having anything to initialize\");\n    initializer.addInitializer(\"child one\", childOne);\n    initializer.addInitializer(\"child two\", childTwo);\n    assertFalse(childOne.getCloseableCounter().isClosed(), \"child one closed() succeeded before start()\");\n    assertFalse(childTwo.getCloseableCounter().isClosed(), \"child two closed() succeeded before start()\");\n    initializer.start();\n    long startTime = System.currentTimeMillis();\n    long waitTime = 3000;\n    long endTime = startTime + waitTime;\n    //wait for the children to start\n    while (!childOne.isStarted() || !childTwo.isStarted()) {\n        if (System.currentTimeMillis() > endTime) {\n            fail(\"children never started\");\n            Thread.sleep(PERIOD_MILLIS);\n        }\n    }\n    assertFalse(childOne.getCloseableCounter().isClosed(), \"child one close() succeeded after start() but before close()\");\n    assertFalse(childTwo.getCloseableCounter().isClosed(), \"child two close() succeeded after start() but before close()\");\n    // ensure this child finishes initializing\n    childOne.get();\n    // ensure this child finishes initializing\n    childTwo.get();\n    assertFalse(childOne.getCloseableCounter().isClosed(), \"child one initializing succeeded after start() but before close()\");\n    assertFalse(childTwo.getCloseableCounter().isClosed(), \"child two initializing succeeded after start() but before close()\");\n    try {\n        initializer.close();\n    } catch (Exception e) {\n        fail();\n    }\n    assertTrue(childOne.getCloseableCounter().isClosed(), \"child one close() did not succeed\");\n    assertTrue(childOne.getCloseableCounter().isClosed(), \"child two close() did not succeed\");\n}", "repo_id": "8", "comment": "/**\n * Tests that close() method closes the wrapped object\n *\n * @throws Exception\n */\n", "repo_name": "commons-lang-master/", "id": 1434, "method_signature": "void testClose()", "filename": "MultiBackgroundInitializerSupplierTest.testClose.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.addInitializer", "ConcurrentInitializer<Object>.start", "AbstractChildBackgroundInitializer.isStarted", "AbstractChildBackgroundInitializer.get", "ConcurrentInitializer<Object>.close", "CloneFailedException.getSuppressed"], "method_name": "MultiBackgroundInitializerSupplierTest.testCloseWithCheckedException", "method_implementation": "{\n    final AbstractChildBackgroundInitializer childOne = new SupplierChildBackgroundInitializer(ioExceptionConsumer);\n    initializer.addInitializer(\"child one\", childOne);\n    initializer.start();\n    long startTime = System.currentTimeMillis();\n    long waitTime = 3000;\n    long endTime = startTime + waitTime;\n    //wait for the children to start\n    while (!childOne.isStarted()) {\n        if (System.currentTimeMillis() > endTime) {\n            fail(\"children never started\");\n            Thread.sleep(PERIOD_MILLIS);\n        }\n    }\n    // ensure the Future has completed.\n    childOne.get();\n    try {\n        initializer.close();\n        fail();\n    } catch (Exception e) {\n        assertThat(e, instanceOf(ConcurrentException.class));\n        assertSame(ioException, e.getSuppressed()[0]);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that close() wraps a checked exception from a child initializer in an ConcurrentException as the first suppressed under in an ConcurrentException\n *\n * @throws Exception\n */\n", "repo_name": "commons-lang-master/", "id": 1435, "method_signature": "void testCloseWithCheckedException()", "filename": "MultiBackgroundInitializerSupplierTest.testCloseWithCheckedException.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.addInitializer", "ConcurrentInitializer<Object>.start", "AbstractChildBackgroundInitializer.isStarted", "AbstractChildBackgroundInitializer.get", "ConcurrentInitializer<Object>.close", "CloneFailedException.getSuppressed"], "method_name": "MultiBackgroundInitializerSupplierTest.testCloseWithRuntimeException", "method_implementation": "{\n    final AbstractChildBackgroundInitializer childOne = new SupplierChildBackgroundInitializer(nullPointerExceptionConsumer);\n    initializer.addInitializer(\"child one\", childOne);\n    initializer.start();\n    long startTime = System.currentTimeMillis();\n    long waitTime = 3000;\n    long endTime = startTime + waitTime;\n    //wait for the children to start\n    while (!childOne.isStarted()) {\n        if (System.currentTimeMillis() > endTime) {\n            fail(\"children never started\");\n            Thread.sleep(PERIOD_MILLIS);\n        }\n    }\n    // ensure the Future has completed.\n    childOne.get();\n    try {\n        initializer.close();\n        fail();\n    } catch (Exception e) {\n        assertThat(e, instanceOf(ConcurrentException.class));\n        assertSame(npe, e.getSuppressed()[0]);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that close() wraps a runtime exception from a child initializer as the first suppressed under in an ConcurrentException\n *\n * @throws Exception\n */\n", "repo_name": "commons-lang-master/", "id": 1436, "method_signature": "void testCloseWithRuntimeException()", "filename": "MultiBackgroundInitializerSupplierTest.testCloseWithRuntimeException.json"}
{"callee_method_names": ["ConcurrentInitializer<Object>.addInitializer", "ConcurrentInitializer<Object>.addInitializer", "ConcurrentInitializer<Object>.start", "AbstractChildBackgroundInitializer.isStarted", "AbstractChildBackgroundInitializer.isStarted", "AbstractChildBackgroundInitializer.get", "AbstractChildBackgroundInitializer.get", "ConcurrentInitializer<Object>.close", "CloneFailedException.getSuppressed", "CharSequence.equals", "CharSequence.equals"], "method_name": "MultiBackgroundInitializerSupplierTest.testCloseWithTwoExceptions", "method_implementation": "{\n    final AbstractChildBackgroundInitializer childOne = new SupplierChildBackgroundInitializer(ioExceptionConsumer);\n    final AbstractChildBackgroundInitializer childTwo = new SupplierChildBackgroundInitializer(nullPointerExceptionConsumer);\n    initializer.addInitializer(\"child one\", childOne);\n    initializer.addInitializer(\"child two\", childTwo);\n    initializer.start();\n    final long startTime = System.currentTimeMillis();\n    final long waitTime = 3000;\n    final long endTime = startTime + waitTime;\n    //wait for the children to start\n    while (!childOne.isStarted() || !childTwo.isStarted()) {\n        if (System.currentTimeMillis() > endTime) {\n            fail(\"children never started\");\n            Thread.sleep(PERIOD_MILLIS);\n        }\n    }\n    // ensure this child finishes initializing\n    childOne.get();\n    // ensure this child finishes initializing\n    childTwo.get();\n    try {\n        initializer.close();\n        fail();\n    } catch (Exception e) {\n        // We don't actually know which order the children will be closed in\n        boolean foundChildOneException = false;\n        boolean foundChildTwoException = false;\n        for (Throwable t : e.getSuppressed()) {\n            if (t.equals(ioException)) {\n                foundChildOneException = true;\n            }\n            if (t.equals(npe)) {\n                foundChildTwoException = true;\n            }\n        }\n        assertTrue(foundChildOneException);\n        assertTrue(foundChildTwoException);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that calling close() on a MultiBackgroundInitializer with two children that both throw exceptions throws\n * an ConcurrentException and both the child exceptions are present\n *\n * @throws Exception\n */\n", "repo_name": "commons-lang-master/", "id": 1437, "method_signature": "void testCloseWithTwoExceptions()", "filename": "MultiBackgroundInitializerSupplierTest.testCloseWithTwoExceptions.json"}
{"callee_method_names": ["AbstractChildBackgroundInitializer.get", "Integer.intValue"], "method_name": "MultiBackgroundInitializerTest.checkChild", "method_implementation": "{\n    final AbstractChildBackgroundInitializer cinit = (AbstractChildBackgroundInitializer) child;\n    final Integer result = cinit.get().getInitializeCalls();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n    if (expExec != null) {\n        assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests whether a child initializer has been executed. Optionally the\n * expected executor service can be checked, too.\n *\n * @param child the child initializer\n * @param expExec the expected executor service (null if the executor should\n * not be checked)\n * @throws ConcurrentException if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 1557, "method_signature": "void checkChild(BackgroundInitializer, ExecutorService)", "filename": "MultiBackgroundInitializerTest.checkChild.json"}
{"callee_method_ids": [145], "callee_method_names": ["MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.start", "MultiBackgroundInitializer.get", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.initializerNames", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.initializerNames", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getResultObject", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.isException", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getException", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getInitializer", "MultiBackgroundInitializer.getActiveExecutor"], "method_name": "MultiBackgroundInitializerTest.checkInitialize", "method_implementation": "{\n    final int count = 5;\n    for (int i = 0; i < count; i++) {\n        initializer.addInitializer(CHILD_INIT + i, createChildBackgroundInitializer());\n    }\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n    for (int i = 0; i < count; i++) {\n        final String key = CHILD_INIT + i;\n        assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n        assertEquals(CloseableCounter.wrapInteger(1), res.getResultObject(key), \"Wrong result object\");\n        assertFalse(res.isException(key), \"Exception flag\");\n        assertNull(res.getException(key), \"Got an exception\");\n        checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n    }\n    return res;\n}", "repo_id": "8", "comment": "/**\n * Helper method for testing the initialize() method. This method can\n * operate with both an external and a temporary executor service.\n *\n * @return the result object produced by the initializer\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1558, "method_signature": "MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()", "filename": "MultiBackgroundInitializerTest.checkInitialize.json"}
{"callee_method_names": ["CountDownLatch.await", "CloseableCounter.increment"], "method_name": "MultiBackgroundInitializerTest.initializeInternal", "method_implementation": "{\n    initializeCalls++;\n    currentExecutor = getActiveExecutor();\n    if (waitForLatch) {\n        latch.await();\n    }\n    if (ex != null) {\n        throw ex;\n    }\n    return counter.increment();\n}", "repo_id": "8", "comment": "/**\n * Records this invocation. Optionally throws an exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1556, "method_signature": "CloseableCounter initializeInternal()", "filename": "MultiBackgroundInitializerTest.initializeInternal.json"}
{"callee_method_ids": [145], "callee_method_names": ["MultiBackgroundInitializer.start", "MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.get"], "method_name": "MultiBackgroundInitializerTest.testAddInitializerAfterStart", "method_implementation": "{\n    initializer.start();\n    assertThrows(IllegalStateException.class, () -> initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer()), \"Could add initializer after start()!\");\n    initializer.get();\n}", "repo_id": "8", "comment": "/**\n * Tries to add another child initializer after the start() method has been\n * called. This should not be allowed.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1559, "method_signature": "void testAddInitializerAfterStart()", "filename": "MultiBackgroundInitializerTest.testAddInitializerAfterStart.json"}
{"callee_method_ids": [145, 145], "callee_method_names": ["AbstractChildBackgroundInitializer.setExternalExecutor", "MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.start", "MultiBackgroundInitializer.get", "MultiBackgroundInitializer.getActiveExecutor", "ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "MultiBackgroundInitializerTest.testInitializeChildWithExecutor", "method_implementation": "{\n    final String initExec = \"childInitializerWithExecutor\";\n    final ExecutorService exec = Executors.newSingleThreadExecutor();\n    try {\n        final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n        c2.setExternalExecutor(exec);\n        initializer.addInitializer(CHILD_INIT, c1);\n        initializer.addInitializer(initExec, c2);\n        initializer.start();\n        initializer.get();\n        checkChild(c1, initializer.getActiveExecutor());\n        checkChild(c2, exec);\n    } finally {\n        exec.shutdown();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests the behavior of initialize() if a child initializer has a specific\n * executor service. Then this service should not be overridden.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1560, "method_signature": "void testInitializeChildWithExecutor()", "filename": "MultiBackgroundInitializerTest.testInitializeChildWithExecutor.json"}
{"callee_method_ids": [145], "callee_method_names": ["MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.start", "MultiBackgroundInitializer.get", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.isException", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getResultObject", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getException", "ConcurrentException.getCause"], "method_name": "MultiBackgroundInitializerTest.testInitializeEx", "method_implementation": "{\n    final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n    child.ex = new Exception();\n    initializer.addInitializer(CHILD_INIT, child);\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n    assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n    final ConcurrentException cex = res.getException(CHILD_INIT);\n    assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n}", "repo_id": "8", "comment": "/**\n * Tests the behavior of the initializer if one of the child initializers\n * throws a checked exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1561, "method_signature": "void testInitializeEx()", "filename": "MultiBackgroundInitializerTest.testInitializeEx.json"}
{"callee_method_names": ["MultiBackgroundInitializer.getActiveExecutor", "ExecutorService.isShutdown", "ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "MultiBackgroundInitializerTest.testInitializeExternalExec", "method_implementation": "{\n    final ExecutorService exec = Executors.newCachedThreadPool();\n    try {\n        initializer = new MultiBackgroundInitializer(exec);\n        checkInitialize();\n        assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n        assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n    } finally {\n        exec.shutdown();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests background processing if an external executor service is provided.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1562, "method_signature": "void testInitializeExternalExec()", "filename": "MultiBackgroundInitializerTest.testInitializeExternalExec.json"}
{"callee_method_ids": [145, 145, 145], "callee_method_names": ["MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.start", "MultiBackgroundInitializer.get", "MultiBackgroundInitializer.getActiveExecutor", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getInitializer", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getResultObject", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.initializerNames", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.getInitializer", "ExecutorService.isShutdown"], "method_name": "MultiBackgroundInitializerTest.testInitializeNested", "method_implementation": "{\n    final String nameMulti = \"multiChildInitializer\";\n    initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer());\n    final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n    final int count = 3;\n    for (int i = 0; i < count; i++) {\n        mi2.addInitializer(CHILD_INIT + i, createChildBackgroundInitializer());\n    }\n    initializer.addInitializer(nameMulti, mi2);\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    final ExecutorService exec = initializer.getActiveExecutor();\n    checkChild(res.getInitializer(CHILD_INIT), exec);\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res.getResultObject(nameMulti);\n    assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n    for (int i = 0; i < count; i++) {\n        checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n    }\n    assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n}", "repo_id": "8", "comment": "/**\n * Tests whether MultiBackgroundInitializers can be combined in a nested\n * way.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1563, "method_signature": "void testInitializeNested()", "filename": "MultiBackgroundInitializerTest.testInitializeNested.json"}
{"callee_method_names": ["MultiBackgroundInitializer.start", "MultiBackgroundInitializer.get", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.initializerNames", "MultiBackgroundInitializer.getActiveExecutor"], "method_name": "MultiBackgroundInitializerTest.testInitializeNoChildren", "method_implementation": "{\n    assertTrue(initializer.start(), \"Wrong result of start()\");\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n    assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n}", "repo_id": "8", "comment": "/**\n * Tests the background processing if there are no child initializers.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1564, "method_signature": "void testInitializeNoChildren()", "filename": "MultiBackgroundInitializerTest.testInitializeNoChildren.json"}
{"callee_method_ids": [145], "callee_method_names": ["MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.start", "MultiBackgroundInitializer.get", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.isSuccessful"], "method_name": "MultiBackgroundInitializerTest.testInitializeResultsIsSuccessfulFalse", "method_implementation": "{\n    final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n    child.ex = new Exception();\n    initializer.addInitializer(CHILD_INIT, child);\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertFalse(res.isSuccessful(), \"Wrong success flag\");\n}", "repo_id": "8", "comment": "/**\n * Tests the isSuccessful() method of the result object if at least one\n * child initializer has thrown an exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1565, "method_signature": "void testInitializeResultsIsSuccessfulFalse()", "filename": "MultiBackgroundInitializerTest.testInitializeResultsIsSuccessfulFalse.json"}
{"callee_method_ids": [145], "callee_method_names": ["MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.start", "MultiBackgroundInitializer.get", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.isSuccessful"], "method_name": "MultiBackgroundInitializerTest.testInitializeResultsIsSuccessfulTrue", "method_implementation": "{\n    final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n    initializer.addInitializer(CHILD_INIT, child);\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertTrue(res.isSuccessful(), \"Wrong success flag\");\n}", "repo_id": "8", "comment": "/**\n * Tests the isSuccessful() method of the result object if no child\n * initializer has thrown an exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1566, "method_signature": "void testInitializeResultsIsSuccessfulTrue()", "filename": "MultiBackgroundInitializerTest.testInitializeResultsIsSuccessfulTrue.json"}
{"callee_method_ids": [145], "callee_method_names": ["MultiBackgroundInitializer.addInitializer", "MultiBackgroundInitializer.start"], "method_name": "MultiBackgroundInitializerTest.testInitializeRuntimeEx", "method_implementation": "{\n    final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n    child.ex = new RuntimeException();\n    initializer.addInitializer(CHILD_INIT, child);\n    initializer.start();\n    final Exception ex = assertThrows(Exception.class, initializer::get);\n    assertEquals(child.ex, ex, \"Wrong exception\");\n}", "repo_id": "8", "comment": "/**\n * Tests the behavior of the initializer if one of the child initializers\n * throws a runtime exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1567, "method_signature": "void testInitializeRuntimeEx()", "filename": "MultiBackgroundInitializerTest.testInitializeRuntimeEx.json"}
{"callee_method_names": ["MultiBackgroundInitializer.getActiveExecutor"], "method_name": "MultiBackgroundInitializerTest.testInitializeTempExec", "method_implementation": "{\n    checkInitialize();\n    assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n}", "repo_id": "8", "comment": "/**\n * Tests background processing if a temporary executor is used.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1568, "method_signature": "void testInitializeTempExec()", "filename": "MultiBackgroundInitializerTest.testInitializeTempExec.json"}
{"callee_method_names": ["MultiBackgroundInitializer.MultiBackgroundInitializerResults.getException"], "method_name": "MultiBackgroundInitializerTest.testResultGetExceptionUnknown", "method_implementation": "{\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n    assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n}", "repo_id": "8", "comment": "/**\n * Tries to query the exception of an unknown child initializer from the\n * results object. This should cause an exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1569, "method_signature": "void testResultGetExceptionUnknown()", "filename": "MultiBackgroundInitializerTest.testResultGetExceptionUnknown.json"}
{"callee_method_names": ["MultiBackgroundInitializer.MultiBackgroundInitializerResults.getInitializer"], "method_name": "MultiBackgroundInitializerTest.testResultGetInitializerUnknown", "method_implementation": "{\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n    assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n}", "repo_id": "8", "comment": "/**\n * Tries to query an unknown child initializer from the results object. This\n * should cause an exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1570, "method_signature": "void testResultGetInitializerUnknown()", "filename": "MultiBackgroundInitializerTest.testResultGetInitializerUnknown.json"}
{"callee_method_names": ["MultiBackgroundInitializer.MultiBackgroundInitializerResults.getResultObject"], "method_name": "MultiBackgroundInitializerTest.testResultGetResultObjectUnknown", "method_implementation": "{\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n    assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n}", "repo_id": "8", "comment": "/**\n * Tries to query the results of an unknown child initializer from the\n * results object. This should cause an exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1571, "method_signature": "void testResultGetResultObjectUnknown()", "filename": "MultiBackgroundInitializerTest.testResultGetResultObjectUnknown.json"}
{"callee_method_names": ["MultiBackgroundInitializer.get", "MultiBackgroundInitializer.MultiBackgroundInitializerResults.initializerNames", "Iterator<String>.next"], "method_name": "MultiBackgroundInitializerTest.testResultInitializerNamesModify", "method_implementation": "{\n    checkInitialize();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    final Iterator<String> it = res.initializerNames().iterator();\n    it.next();\n    assertThrows(UnsupportedOperationException.class, it::remove);\n}", "repo_id": "8", "comment": "/**\n * Tests that the set with the names of the initializers cannot be modified.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1572, "method_signature": "void testResultInitializerNamesModify()", "filename": "MultiBackgroundInitializerTest.testResultInitializerNamesModify.json"}
{"callee_method_names": ["MultiBackgroundInitializer.MultiBackgroundInitializerResults.isException"], "method_name": "MultiBackgroundInitializerTest.testResultIsExceptionUnknown", "method_implementation": "{\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n    assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n}", "repo_id": "8", "comment": "/**\n * Tries to query the exception flag of an unknown child initializer from\n * the results object. This should cause an exception.\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1573, "method_signature": "void testResultIsExceptionUnknown()", "filename": "MultiBackgroundInitializerTest.testResultIsExceptionUnknown.json"}
{"callee_method_names": [], "method_name": "MultilineRecursiveToStringStyle.resetIndent", "method_implementation": "{\n    setArrayStart(\"{\" + System.lineSeparator() + spacer(spaces));\n    setArraySeparator(\",\" + System.lineSeparator() + spacer(spaces));\n    setArrayEnd(System.lineSeparator() + spacer(spaces - INDENT) + \"}\");\n    setContentStart(\"[\" + System.lineSeparator() + spacer(spaces));\n    setFieldSeparator(\",\" + System.lineSeparator() + spacer(spaces));\n    setContentEnd(System.lineSeparator() + spacer(spaces - INDENT) + \"]\");\n}", "repo_id": "8", "comment": "/**\n * Resets the fields responsible for the line breaks and indenting.\n * Must be invoked after changing the {@link #spaces} value.\n */\n", "repo_name": "commons-lang-master/", "id": 889, "method_signature": "void resetIndent()", "filename": "MultilineRecursiveToStringStyle.resetIndent.json"}
{"callee_method_names": ["StringBuilder.append"], "method_name": "MultilineRecursiveToStringStyle.spacer", "method_implementation": "{\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < spaces; i++) {\n        sb.append(\" \");\n    }\n    return sb;\n}", "repo_id": "8", "comment": "/**\n * Creates a StringBuilder responsible for the indenting.\n *\n * @param spaces how far to indent\n * @return a StringBuilder with {spaces} leading space characters.\n */\n", "repo_name": "commons-lang-master/", "id": 890, "method_signature": "StringBuilder spacer(int)", "filename": "MultilineRecursiveToStringStyle.spacer.json"}
{"callee_method_names": ["String.replace"], "method_name": "MultilineRecursiveToStringStyleTest.getExpectedToString", "method_implementation": "{\n    return getClassPrefix(wa) + BASE_WITH_ARRAYS_TO_STRING.replace(\"#\" + arrayType + \"#\", expectedArrayValue).replaceAll(\"#[A-Z]+#\", \"<null>\");\n}", "repo_id": "8", "comment": "/**\n * Create an expected to String for the given WithArraysInstance\n * @param wa                 Instance\n * @param arrayType          Type - empty used to indicate expect all nulls\n * @param expectedArrayValue Expected value for the array type\n * @return expected toString\n */\n", "repo_name": "commons-lang-master/", "id": 1990, "method_signature": "String getExpectedToString(WithArrays, WithArraysTestType, String)", "filename": "MultilineRecursiveToStringStyleTest.getExpectedToString.json"}
{"callee_method_names": [], "method_name": "MutableBoolean.equals", "method_implementation": "{\n    if (obj instanceof MutableBoolean) {\n        return value == ((MutableBoolean) obj).booleanValue();\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this object to the specified object. The result is {@code true} if and only if the argument is\n * not {@code null} and is an {@link MutableBoolean} object that contains the same\n * {@code boolean} value as this object.\n *\n * @param obj  the object to compare with, null returns false\n * @return {@code true} if the objects are the same; {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 5, "method_signature": "boolean equals(Object)", "filename": "MutableBoolean.equals.json"}
{"callee_method_names": [], "method_name": "MutableByte.equals", "method_implementation": "{\n    if (obj instanceof MutableByte) {\n        return value == ((MutableByte) obj).byteValue();\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this object to the specified object. The result is {@code true} if and only if the argument is\n * not {@code null} and is a {@link MutableByte} object that contains the same {@code byte} value\n * as this object.\n *\n * @param obj  the object to compare with, null returns false\n * @return {@code true} if the objects are the same; {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 23, "method_signature": "boolean equals(Object)", "filename": "MutableByte.equals.json"}
{"callee_method_names": ["Number.byteValue"], "method_name": "MutableByte.getAndAdd", "method_implementation": "{\n    final byte last = value;\n    this.value += operand.byteValue();\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by {@code operand}; this method returns the value associated with the instance\n * immediately prior to the addition operation. This method is not thread safe.\n *\n * @param operand the quantity to add, not null\n * @throws NullPointerException if {@code operand} is null\n * @return the value associated with this instance immediately before the operand was added\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 25, "method_signature": "byte getAndAdd(Number)", "filename": "MutableByte.getAndAdd.json"}
{"callee_method_names": [], "method_name": "MutableByte.getAndDecrement", "method_implementation": "{\n    final byte last = value;\n    value--;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Decrements this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the decrement operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was decremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 26, "method_signature": "byte getAndDecrement()", "filename": "MutableByte.getAndDecrement.json"}
{"callee_method_names": [], "method_name": "MutableByte.getAndIncrement", "method_implementation": "{\n    final byte last = value;\n    value++;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the increment operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was incremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 27, "method_signature": "byte getAndIncrement()", "filename": "MutableByte.getAndIncrement.json"}
{"callee_method_names": [], "method_name": "MutableDouble.equals", "method_implementation": "{\n    return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value);\n}", "repo_id": "8", "comment": "/**\n * Compares this object against the specified object. The result is {@code true} if and only if the argument\n * is not {@code null} and is a {@link Double} object that represents a double that has the identical\n * bit pattern to the bit pattern of the double represented by this object. For this purpose, two\n * {@code double} values are considered to be the same if and only if the method\n * {@link Double#doubleToLongBits(double)}returns the same long value when applied to each.\n * <p>\n * Note that in most cases, for two instances of class {@link Double},{@code d1} and {@code d2},\n * the value of {@code d1.equals(d2)} is {@code true} if and only if <blockquote>\n *\n * <pre>\n *   d1.doubleValue()&nbsp;== d2.doubleValue()\n * </pre>\n *\n * </blockquote>\n * <p>\n * also has the value {@code true}. However, there are two exceptions:\n * <ul>\n * <li>If {@code d1} and {@code d2} both represent {@code Double.NaN}, then the\n * {@code equals} method returns {@code true}, even though {@code Double.NaN==Double.NaN} has\n * the value {@code false}.\n * <li>If {@code d1} represents {@code +0.0} while {@code d2} represents {@code -0.0},\n * or vice versa, the {@code equal} test has the value {@code false}, even though\n * {@code +0.0==-0.0} has the value {@code true}. This allows hashtables to operate properly.\n * </ul>\n *\n * @param obj  the object to compare with, null returns false\n * @return {@code true} if the objects are the same; {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 6, "method_signature": "boolean equals(Object)", "filename": "MutableDouble.equals.json"}
{"callee_method_names": ["Number.doubleValue"], "method_name": "MutableDouble.getAndAdd", "method_implementation": "{\n    final double last = value;\n    this.value += operand.doubleValue();\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by {@code operand}; this method returns the value associated with the instance\n * immediately prior to the addition operation. This method is not thread safe.\n *\n * @param operand the quantity to add, not null\n * @throws NullPointerException if {@code operand} is null\n * @return the value associated with this instance immediately before the operand was added\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 8, "method_signature": "double getAndAdd(Number)", "filename": "MutableDouble.getAndAdd.json"}
{"callee_method_names": [], "method_name": "MutableDouble.getAndDecrement", "method_implementation": "{\n    final double last = value;\n    value--;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Decrements this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the decrement operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was decremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 9, "method_signature": "double getAndDecrement()", "filename": "MutableDouble.getAndDecrement.json"}
{"callee_method_names": [], "method_name": "MutableDouble.getAndIncrement", "method_implementation": "{\n    final double last = value;\n    value++;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the increment operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was incremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 10, "method_signature": "double getAndIncrement()", "filename": "MutableDouble.getAndIncrement.json"}
{"callee_method_names": [], "method_name": "MutableDouble.hashCode", "method_implementation": "{\n    final long bits = Double.doubleToLongBits(value);\n    return (int) (bits ^ bits >>> 32);\n}", "repo_id": "8", "comment": "/**\n * Returns a suitable hash code for this mutable.\n *\n * @return a suitable hash code\n */\n", "repo_name": "commons-lang-master/", "id": 11, "method_signature": "int hashCode()", "filename": "MutableDouble.hashCode.json"}
{"callee_method_names": [], "method_name": "MutableFloat.equals", "method_implementation": "{\n    return obj instanceof MutableFloat && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value);\n}", "repo_id": "8", "comment": "/**\n * Compares this object against some other object. The result is {@code true} if and only if the argument is\n * not {@code null} and is a {@link Float} object that represents a {@code float} that has the\n * identical bit pattern to the bit pattern of the {@code float} represented by this object. For this\n * purpose, two float values are considered to be the same if and only if the method\n * {@link Float#floatToIntBits(float)}returns the same int value when applied to each.\n * <p>\n * Note that in most cases, for two instances of class {@link Float},{@code f1} and {@code f2},\n * the value of {@code f1.equals(f2)} is {@code true} if and only if <blockquote>\n *\n * <pre>\n *   f1.floatValue() == f2.floatValue()\n * </pre>\n *\n * </blockquote>\n * <p>\n * also has the value {@code true}. However, there are two exceptions:\n * <ul>\n * <li>If {@code f1} and {@code f2} both represent {@code Float.NaN}, then the\n * {@code equals} method returns {@code true}, even though {@code Float.NaN==Float.NaN} has\n * the value {@code false}.\n * <li>If {@code f1} represents {@code +0.0f} while {@code f2} represents {@code -0.0f},\n * or vice versa, the {@code equal} test has the value {@code false}, even though\n * {@code 0.0f==-0.0f} has the value {@code true}.\n * </ul>\n * This definition allows hashtables to operate properly.\n *\n * @param obj  the object to compare with, null returns false\n * @return {@code true} if the objects are the same; {@code false} otherwise.\n * @see Float#floatToIntBits(float)\n */\n", "repo_name": "commons-lang-master/", "id": 18, "method_signature": "boolean equals(Object)", "filename": "MutableFloat.equals.json"}
{"callee_method_names": ["Number.floatValue"], "method_name": "MutableFloat.getAndAdd", "method_implementation": "{\n    final float last = value;\n    this.value += operand.floatValue();\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by {@code operand}; this method returns the value associated with the instance\n * immediately prior to the addition operation. This method is not thread safe.\n *\n * @param operand the quantity to add, not null\n * @throws NullPointerException if {@code operand} is null\n * @return the value associated with this instance immediately before the operand was added\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 20, "method_signature": "float getAndAdd(Number)", "filename": "MutableFloat.getAndAdd.json"}
{"callee_method_names": [], "method_name": "MutableFloat.getAndDecrement", "method_implementation": "{\n    final float last = value;\n    value--;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Decrements this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the decrement operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was decremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 21, "method_signature": "float getAndDecrement()", "filename": "MutableFloat.getAndDecrement.json"}
{"callee_method_names": [], "method_name": "MutableFloat.getAndIncrement", "method_implementation": "{\n    final float last = value;\n    value++;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the increment operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was incremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 22, "method_signature": "float getAndIncrement()", "filename": "MutableFloat.getAndIncrement.json"}
{"callee_method_names": [], "method_name": "MutableInt.equals", "method_implementation": "{\n    if (obj instanceof MutableInt) {\n        return value == ((MutableInt) obj).intValue();\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this object to the specified object. The result is {@code true} if and only if the argument is\n * not {@code null} and is a {@link MutableInt} object that contains the same {@code int} value\n * as this object.\n *\n * @param obj  the object to compare with, null returns false\n * @return {@code true} if the objects are the same; {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 33, "method_signature": "boolean equals(Object)", "filename": "MutableInt.equals.json"}
{"callee_method_names": ["Number.intValue"], "method_name": "MutableInt.getAndAdd", "method_implementation": "{\n    final int last = value;\n    this.value += operand.intValue();\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by {@code operand}; this method returns the value associated with the instance\n * immediately prior to the addition operation. This method is not thread safe.\n *\n * @param operand the quantity to add, not null\n * @throws NullPointerException if {@code operand} is null\n * @return the value associated with this instance immediately before the operand was added\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 35, "method_signature": "int getAndAdd(Number)", "filename": "MutableInt.getAndAdd.json"}
{"callee_method_names": [], "method_name": "MutableInt.getAndDecrement", "method_implementation": "{\n    final int last = value;\n    value--;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Decrements this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the decrement operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was decremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 36, "method_signature": "int getAndDecrement()", "filename": "MutableInt.getAndDecrement.json"}
{"callee_method_names": [], "method_name": "MutableInt.getAndIncrement", "method_implementation": "{\n    final int last = value;\n    value++;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the increment operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was incremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 37, "method_signature": "int getAndIncrement()", "filename": "MutableInt.getAndIncrement.json"}
{"callee_method_names": [], "method_name": "MutableIntTest.testEquals", "method_implementation": "{\n    assertEquals(numA, numA);\n    assertEquals(numA, numB);\n    assertEquals(numB, numA);\n    assertEquals(numB, numB);\n    assertNotEquals(numA, numC);\n    assertNotEquals(numB, numC);\n    assertEquals(numC, numC);\n    assertNotEquals(null, numA);\n    assertNotEquals(numA, Integer.valueOf(0));\n    assertNotEquals(\"0\", numA);\n}", "repo_id": "8", "comment": "/**\n * @param numA must not be a 0 Integer; must not equal numC.\n * @param numB must equal numA; must not equal numC.\n * @param numC must not equal numA; must not equal numC.\n */\n", "repo_name": "commons-lang-master/", "id": 1370, "method_signature": "void testEquals(Number, Number, Number)", "filename": "MutableIntTest.testEquals.json"}
{"callee_method_names": [], "method_name": "MutableLong.equals", "method_implementation": "{\n    if (obj instanceof MutableLong) {\n        return value == ((MutableLong) obj).longValue();\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this object to the specified object. The result is {@code true} if and only if the argument\n * is not {@code null} and is a {@link MutableLong} object that contains the same {@code long}\n * value as this object.\n *\n * @param obj  the object to compare with, null returns false\n * @return {@code true} if the objects are the same; {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 12, "method_signature": "boolean equals(Object)", "filename": "MutableLong.equals.json"}
{"callee_method_names": ["Number.longValue"], "method_name": "MutableLong.getAndAdd", "method_implementation": "{\n    final long last = value;\n    this.value += operand.longValue();\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by {@code operand}; this method returns the value associated with the instance\n * immediately prior to the addition operation. This method is not thread safe.\n *\n * @param operand the quantity to add, not null\n * @throws NullPointerException if {@code operand} is null\n * @return the value associated with this instance immediately before the operand was added\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 14, "method_signature": "long getAndAdd(Number)", "filename": "MutableLong.getAndAdd.json"}
{"callee_method_names": [], "method_name": "MutableLong.getAndDecrement", "method_implementation": "{\n    final long last = value;\n    value--;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Decrements this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the decrement operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was decremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 15, "method_signature": "long getAndDecrement()", "filename": "MutableLong.getAndDecrement.json"}
{"callee_method_names": [], "method_name": "MutableLong.getAndIncrement", "method_implementation": "{\n    final long last = value;\n    value++;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the increment operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was incremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 16, "method_signature": "long getAndIncrement()", "filename": "MutableLong.getAndIncrement.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "MutableObject.equals", "method_implementation": "{\n    if (obj == null) {\n        return false;\n    }\n    if (this == obj) {\n        return true;\n    }\n    if (this.getClass() == obj.getClass()) {\n        final MutableObject<?> that = (MutableObject<?>) obj;\n        return Objects.equals(this.value, that.value);\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this object against the specified object. The result is {@code true} if and only if the argument\n * is not {@code null} and is a {@link MutableObject} object that contains the same {@link T}\n * value as this object.\n *\n * @param obj  the object to compare with, {@code null} returns {@code false}\n * @return  {@code true} if the objects are the same;\n *          {@code true} if the objects have equivalent {@code value} fields;\n *          {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 17, "method_signature": "boolean equals(Object)", "filename": "MutableObject.equals.json"}
{"callee_method_names": ["Map.Entry<L,R>.getKey", "Map.Entry<L,R>.getValue"], "method_name": "MutablePair.of", "method_implementation": "{\n    final L left;\n    final R right;\n    if (pair != null) {\n        left = pair.getKey();\n        right = pair.getValue();\n    } else {\n        left = null;\n        right = null;\n    }\n    return new MutablePair<>(left, right);\n}", "repo_id": "8", "comment": "/**\n * Creates a mutable pair from a map entry.\n *\n * <p>This factory allows the pair to be created using inference to\n * obtain the generic types.</p>\n *\n * @param <L> the left element type\n * @param <R> the right element type\n * @param pair the existing map entry.\n * @return a pair formed from the map entry\n */\n", "repo_name": "commons-lang-master/", "id": 1322, "method_signature": "MutablePair<L,R> of(Map.Entry)", "filename": "MutablePair.of.json"}
{"callee_method_names": [], "method_name": "MutablePair.setValue", "method_implementation": "{\n    final R result = getRight();\n    setRight(value);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Sets the {@code Map.Entry} value.\n * This sets the right element of the pair.\n *\n * @param value  the right value to set, not null\n * @return the old value for the right element\n */\n", "repo_name": "commons-lang-master/", "id": 1323, "method_signature": "R setValue(R)", "filename": "MutablePair.setValue.json"}
{"callee_method_names": [], "method_name": "MutableShort.equals", "method_implementation": "{\n    if (obj instanceof MutableShort) {\n        return value == ((MutableShort) obj).shortValue();\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this object to the specified object. The result is {@code true} if and only if the argument\n * is not {@code null} and is a {@link MutableShort} object that contains the same {@code short}\n * value as this object.\n *\n * @param obj  the object to compare with, null returns false\n * @return {@code true} if the objects are the same; {@code false} otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 28, "method_signature": "boolean equals(Object)", "filename": "MutableShort.equals.json"}
{"callee_method_names": [], "method_name": "MutableShort.getAndAdd", "method_implementation": "{\n    final short last = value;\n    this.value += operand;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by {@code operand}; this method returns the value associated with the instance\n * immediately prior to the addition operation. This method is not thread safe.\n *\n * @param operand the quantity to add, not null\n * @return the value associated with this instance immediately before the operand was added\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 30, "method_signature": "short getAndAdd(short)", "filename": "MutableShort.getAndAdd.json"}
{"callee_method_names": [], "method_name": "MutableShort.getAndDecrement", "method_implementation": "{\n    final short last = value;\n    value--;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Decrements this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the decrement operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was decremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 31, "method_signature": "short getAndDecrement()", "filename": "MutableShort.getAndDecrement.json"}
{"callee_method_names": [], "method_name": "MutableShort.getAndIncrement", "method_implementation": "{\n    final short last = value;\n    value++;\n    return last;\n}", "repo_id": "8", "comment": "/**\n * Increments this instance's value by 1; this method returns the value associated with the instance\n * immediately prior to the increment operation. This method is not thread safe.\n *\n * @return the value associated with the instance before it was incremented\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 32, "method_signature": "short getAndIncrement()", "filename": "MutableShort.getAndIncrement.json"}
{"callee_method_names": [], "method_name": "NumberUtils.compare", "method_implementation": "{\n    if (x == y) {\n        return 0;\n    }\n    return x < y ? -1 : 1;\n}", "repo_id": "8", "comment": "/**\n * Compares to {@code short} values numerically. This is the same functionality as provided in Java 7.\n *\n * @param x the first {@code short} to compare\n * @param y the second {@code short} to compare\n * @return the value {@code 0} if {@code x == y};\n *         a value less than {@code 0} if {@code x < y}; and\n *         a value greater than {@code 0} if {@code x > y}\n * @since 3.4\n */\n", "repo_name": "commons-lang-master/", "id": 176, "method_signature": "int compare(short, short)", "filename": "NumberUtils.compare.json"}
{"callee_method_names": [], "method_name": "NumberUtils.createBigDecimal", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    return new BigDecimal(str);\n}", "repo_id": "8", "comment": "/**\n * Creates a {@link BigDecimal} from a {@link String}.\n *\n * <p>Returns {@code null} if the string is {@code null}.</p>\n *\n * @param str  a {@link String} to convert, may be null\n * @return converted {@link BigDecimal} (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "repo_name": "commons-lang-master/", "id": 177, "method_signature": "BigDecimal createBigDecimal(String)", "filename": "NumberUtils.createBigDecimal.json"}
{"callee_method_names": ["String.isEmpty", "String.charAt", "String.startsWith", "String.startsWith", "String.startsWith", "String.startsWith", "String.length", "String.substring", "BigInteger.negate"], "method_name": "NumberUtils.createBigInteger", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        throw new NumberFormatException(\"An empty string is not a valid number\");\n    }\n    // offset within string\n    int pos = 0;\n    int radix = 10;\n    // need to negate later?\n    boolean negate = false;\n    final char char0 = str.charAt(0);\n    if (char0 == '-') {\n        negate = true;\n        pos = 1;\n    } else if (char0 == '+') {\n        pos = 1;\n    }\n    if (str.startsWith(\"0x\", pos) || str.startsWith(\"0X\", pos)) {\n        // hex\n        radix = 16;\n        pos += 2;\n    } else if (str.startsWith(\"#\", pos)) {\n        // alternative hex (allowed by Long/Integer)\n        radix = 16;\n        pos++;\n    } else if (str.startsWith(\"0\", pos) && str.length() > pos + 1) {\n        // octal; so long as there are additional digits\n        radix = 8;\n        pos++;\n    }\n    // default is to treat as decimal\n    final BigInteger value = new BigInteger(str.substring(pos), radix);\n    return negate ? value.negate() : value;\n}", "repo_id": "8", "comment": "/**\n * Creates a {@link BigInteger} from a {@link String}.\n *\n * Handles hexadecimal (0x or #) and octal (0) notations.\n *\n * <p>Returns {@code null} if the string is {@code null}.</p>\n *\n * @param str  a {@link String} to convert, may be null\n * @return converted {@link BigInteger} (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 178, "method_signature": "BigInteger createBigInteger(String)", "filename": "NumberUtils.createBigInteger.json"}
{"callee_method_names": [], "method_name": "NumberUtils.createDouble", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    return Double.valueOf(str);\n}", "repo_id": "8", "comment": "/**\n * Creates a {@link Double} from a {@link String}.\n *\n * <p>Returns {@code null} if the string is {@code null}.</p>\n *\n * @param str  a {@link String} to convert, may be null\n * @return converted {@link Double} (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "repo_name": "commons-lang-master/", "id": 179, "method_signature": "Double createDouble(String)", "filename": "NumberUtils.createDouble.json"}
{"callee_method_names": [], "method_name": "NumberUtils.createFloat", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    return Float.valueOf(str);\n}", "repo_id": "8", "comment": "/**\n * Creates a {@link Float} from a {@link String}.\n *\n * <p>Returns {@code null} if the string is {@code null}.</p>\n *\n * @param str  a {@link String} to convert, may be null\n * @return converted {@link Float} (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "repo_name": "commons-lang-master/", "id": 180, "method_signature": "Float createFloat(String)", "filename": "NumberUtils.createFloat.json"}
{"callee_method_names": [], "method_name": "NumberUtils.createInteger", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    // decode() handles 0xAABD and 0777 (hex and octal) as well.\n    return Integer.decode(str);\n}", "repo_id": "8", "comment": "/**\n * Creates an {@link Integer} from a {@link String}.\n *\n * Handles hexadecimal (0xhhhh) and octal (0dddd) notations.\n * N.B. a leading zero means octal; spaces are not trimmed.\n *\n * <p>Returns {@code null} if the string is {@code null}.</p>\n *\n * @param str  a {@link String} to convert, may be null\n * @return converted {@link Integer} (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "repo_name": "commons-lang-master/", "id": 181, "method_signature": "Integer createInteger(String)", "filename": "NumberUtils.createInteger.json"}
{"callee_method_names": [], "method_name": "NumberUtils.createLong", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    return Long.decode(str);\n}", "repo_id": "8", "comment": "/**\n * Creates a {@link Long} from a {@link String}.\n *\n * Handles hexadecimal (0Xhhhh) and octal (0ddd) notations.\n * N.B. a leading zero means octal; spaces are not trimmed.\n *\n * <p>Returns {@code null} if the string is {@code null}.</p>\n *\n * @param str  a {@link String} to convert, may be null\n * @return converted {@link Long} (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n * @since 3.1\n */\n", "repo_name": "commons-lang-master/", "id": 182, "method_signature": "Long createLong(String)", "filename": "NumberUtils.createLong.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.charAt", "String.startsWith", "String.charAt", "String.charAt", "String.indexOf", "String.indexOf", "String.indexOf", "String.substring", "String.substring", "String.substring", "String.substring", "String.isEmpty", "String.charAt", "String.substring", "Float.isInfinite", "Float.floatValue", "Double.isInfinite", "Double.doubleValue", "String.substring", "Float.isInfinite", "Float.floatValue", "Float.toString", "Double.toString", "Double.isInfinite", "Double.doubleValue", "BigDecimal.compareTo", "Double.doubleValue"], "method_name": "NumberUtils.createNumber", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hexPrefixes = { \"0x\", \"0X\", \"#\" };\n    final int length = str.length();\n    final int offset = str.charAt(0) == '+' || str.charAt(0) == '-' ? 1 : 0;\n    int pfxLen = 0;\n    for (final String pfx : hexPrefixes) {\n        if (str.startsWith(pfx, offset)) {\n            pfxLen += pfx.length() + offset;\n            break;\n        }\n    }\n    if (pfxLen > 0) {\n        // we have a hex number\n        // strip leading zeroes\n        char firstSigDigit = 0;\n        for (int i = pfxLen; i < length; i++) {\n            firstSigDigit = str.charAt(i);\n            if (firstSigDigit != '0') {\n                break;\n            }\n            pfxLen++;\n        }\n        final int hexDigits = length - pfxLen;\n        if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') {\n            // too many for Long\n            return createBigInteger(str);\n        }\n        if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') {\n            // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(length - 1);\n    final String mant;\n    final String dec;\n    final String exp;\n    final int decPos = str.indexOf('.');\n    // assumes both not present\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n    // Detect if the return type has been requested\n    final boolean requestType = !Character.isDigit(lastChar) && lastChar != '.';\n    if (decPos > -1) {\n        // there is a decimal point\n        if (expPos > -1) {\n            // there is an exponent\n            if (expPos <= decPos || expPos > length) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            // No exponent, but there may be a type character to remove\n            dec = str.substring(decPos + 1, requestType ? length - 1 : length);\n        }\n        mant = getMantissa(str, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > length) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = getMantissa(str, expPos);\n        } else {\n            // No decimal, no exponent, but there may be a type character to remove\n            mant = getMantissa(str, requestType ? length - 1 : length);\n        }\n        dec = null;\n    }\n    if (requestType) {\n        if (expPos > -1 && expPos < length - 1) {\n            exp = str.substring(expPos + 1, length - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type.\n        final String numeric = str.substring(0, length - 1);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException ignored) {\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    final Float f = createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() == 0.0F && !isZero(mant, dec))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (final NumberFormatException ignored) {\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            case 'd':\n            case 'D':\n                try {\n                    final Double d = createDouble(str);\n                    if (!(d.isInfinite() || d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException ignored) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException ignored) {\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    //User doesn't have a preference on the return type, so let's start\n    //small and go from there...\n    if (expPos > -1 && expPos < length - 1) {\n        exp = str.substring(expPos + 1);\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) {\n        // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException ignored) {\n            // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException ignored) {\n            // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n    //Must be a Float, Double, BigDecimal\n    try {\n        final Float f = createFloat(str);\n        final Double d = createDouble(str);\n        if (!f.isInfinite() && !(f.floatValue() == 0.0F && !isZero(mant, dec)) && f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n            final BigDecimal b = createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException ignored) {\n        // ignore the bad number\n    }\n    return createBigDecimal(str);\n}", "repo_id": "8", "comment": "/**\n * Creates a {@link Number} from a {@link String}.\n *\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n * </p>\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * {@code 'f', 'F', 'd', 'D', 'l', 'L'}.  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from {@link Integer} to\n * {@link BigInteger} and from {@link Float} to\n * {@link BigDecimal}.</p>\n *\n * <p>\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n * be Integer, Long or BigDecimal as appropriate.\n * </p>\n *\n * <p>Returns {@code null} if the string is {@code null}.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "repo_name": "commons-lang-master/", "id": 183, "method_signature": "Number createNumber(String)", "filename": "NumberUtils.createNumber.json"}
{"callee_method_names": ["String.charAt", "String.length", "String.substring", "String.substring"], "method_name": "NumberUtils.getMantissa", "method_implementation": "{\n    final char firstChar = str.charAt(0);\n    final boolean hasSign = firstChar == '-' || firstChar == '+';\n    final int length = str.length();\n    if (length <= (hasSign ? 1 : 0) || length < stopPos) {\n        throw new NumberFormatException(str + \" is not a valid number.\");\n    }\n    return hasSign ? str.substring(1, stopPos) : str.substring(0, stopPos);\n}", "repo_id": "8", "comment": "/**\n * Utility method for {@link #createNumber(String)}.\n *\n * <p>Returns mantissa of the given number.</p>\n *\n * @param str the string representation of the number\n * @param stopPos the position of the exponent or decimal point\n * @return mantissa of the given number\n * @throws NumberFormatException if no mantissa can be retrieved\n */\n", "repo_name": "commons-lang-master/", "id": 184, "method_signature": "String getMantissa(String, int)", "filename": "NumberUtils.getMantissa.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "NumberUtils.isAllZeros", "method_implementation": "{\n    if (str == null) {\n        return true;\n    }\n    for (int i = str.length() - 1; i >= 0; i--) {\n        if (str.charAt(i) != '0') {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Utility method for {@link #createNumber(java.lang.String)}.\n *\n * <p>Returns {@code true} if s is {@code null} or empty.</p>\n *\n * @param str the String to check\n * @return if it is all zeros or {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 185, "method_signature": "boolean isAllZeros(String)", "filename": "NumberUtils.isAllZeros.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "NumberUtils.isCreatable", "method_implementation": "{\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    final int start = chars[0] == '-' || chars[0] == '+' ? 1 : 0;\n    if (sz > start + 1 && chars[start] == '0' && !StringUtils.contains(str, '.')) {\n        // leading 0, skip if is a decimal number\n        if (chars[start + 1] == 'x' || chars[start + 1] == 'X') {\n            // leading 0x/0X\n            int i = start + 2;\n            if (i == sz) {\n                // str == \"0x\"\n                return false;\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (Character.isDigit(chars[start + 1])) {\n            // leading 0, but not hex, must be octal\n            int i = start + 1;\n            for (; i < chars.length; i++) {\n                if (chars[i] < '0' || chars[i] > '7') {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    // don't want to loop to the last char, check it afterwards\n    sz--;\n    // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || i < sz + 1 && allowSigns && !foundDigit) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            // we need a digit after the E\n            foundDigit = false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return foundDigit;\n        }\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l' || chars[i] == 'L') {\n            // not allowing L with an exponent or decimal point\n            return foundDigit && !hasExp && !hasDecPoint;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}", "repo_id": "8", "comment": "/**\n * Checks whether the String is a valid Java number.\n *\n * <p>Valid numbers include hexadecimal marked with the {@code 0x} or\n * {@code 0X} qualifier, octal numbers, scientific notation and\n * numbers marked with a type qualifier (e.g. 123L).</p>\n *\n * <p>Non-hexadecimal strings beginning with a leading zero are\n * treated as octal values. Thus the string {@code 09} will return\n * {@code false}, since {@code 9} is not a valid octal value.\n * However, numbers beginning with {@code 0.} are treated as decimal.</p>\n *\n * <p>{@code null} and empty/blank {@link String} will return\n * {@code false}.</p>\n *\n * <p>Note, {@link #createNumber(String)} should return a number for every\n * input resulting in {@code true}.</p>\n *\n * @param str  the {@link String} to check\n * @return {@code true} if the string is a correctly formatted number\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 186, "method_signature": "boolean isCreatable(String)", "filename": "NumberUtils.isCreatable.json"}
{"callee_method_names": ["String.charAt", "String.length", "String.charAt", "String.length"], "method_name": "NumberUtils.isParsable", "method_implementation": "{\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    if (str.charAt(str.length() - 1) == '.') {\n        return false;\n    }\n    if (str.charAt(0) == '-') {\n        if (str.length() == 1) {\n            return false;\n        }\n        return withDecimalsParsing(str, 1);\n    }\n    return withDecimalsParsing(str, 0);\n}", "repo_id": "8", "comment": "/**\n * Checks whether the given String is a parsable number.\n *\n * <p>Parsable numbers include those Strings understood by {@link Integer#parseInt(String)},\n * {@link Long#parseLong(String)}, {@link Float#parseFloat(String)} or\n * {@link Double#parseDouble(String)}. This method can be used instead of catching {@link java.text.ParseException}\n * when calling one of those methods.</p>\n *\n * <p>Hexadecimal and scientific notations are <strong>not</strong> considered parsable.\n * See {@link #isCreatable(String)} on those cases.</p>\n *\n * <p>{@code null} and empty String will return {@code false}.</p>\n *\n * @param str the String to check.\n * @return {@code true} if the string is a parsable number.\n * @since 3.4\n */\n", "repo_name": "commons-lang-master/", "id": 187, "method_signature": "boolean isParsable(String)", "filename": "NumberUtils.isParsable.json"}
{"callee_method_names": [], "method_name": "NumberUtils.max", "method_implementation": "{\n    if (b > a) {\n        a = b;\n    }\n    if (c > a) {\n        a = c;\n    }\n    return a;\n}", "repo_id": "8", "comment": "/**\n * Gets the maximum of three {@code short} values.\n *\n * @param a  value 1\n * @param b  value 2\n * @param c  value 3\n * @return  the largest of the values\n */\n", "repo_name": "commons-lang-master/", "id": 197, "method_signature": "short max(short, short, short)", "filename": "NumberUtils.max.json"}
{"callee_method_names": [], "method_name": "NumberUtils.min", "method_implementation": "{\n    if (b < a) {\n        a = b;\n    }\n    if (c < a) {\n        a = c;\n    }\n    return a;\n}", "repo_id": "8", "comment": "/**\n * Gets the minimum of three {@code short} values.\n *\n * @param a  value 1\n * @param b  value 2\n * @param c  value 3\n * @return  the smallest of the values\n */\n", "repo_name": "commons-lang-master/", "id": 207, "method_signature": "short min(short, short, short)", "filename": "NumberUtils.min.json"}
{"callee_method_names": [], "method_name": "NumberUtils.toByte", "method_implementation": "{\n    if (str == null) {\n        return defaultValue;\n    }\n    try {\n        return Byte.parseByte(str);\n    } catch (final NumberFormatException nfe) {\n        return defaultValue;\n    }\n}", "repo_id": "8", "comment": "/**\n * Convert a {@link String} to a {@code byte}, returning a\n * default value if the conversion fails.\n *\n * <p>If the string is {@code null}, the default value is returned.</p>\n *\n * <pre>\n *   NumberUtils.toByte(null, 1) = 1\n *   NumberUtils.toByte(\"\", 1)   = 1\n *   NumberUtils.toByte(\"1\", 0)  = 1\n * </pre>\n *\n * @param str  the string to convert, may be null\n * @param defaultValue  the default value\n * @return the byte represented by the string, or the default if conversion fails\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 208, "method_signature": "byte toByte(String, byte)", "filename": "NumberUtils.toByte.json"}
{"callee_method_names": [], "method_name": "NumberUtils.toDouble", "method_implementation": "{\n    if (str == null) {\n        return defaultValue;\n    }\n    try {\n        return Double.parseDouble(str);\n    } catch (final NumberFormatException nfe) {\n        return defaultValue;\n    }\n}", "repo_id": "8", "comment": "/**\n * Convert a {@link String} to a {@code double}, returning a\n * default value if the conversion fails.\n *\n * <p>If the string {@code str} is {@code null}, the default\n * value is returned.</p>\n *\n * <pre>\n *   NumberUtils.toDouble(null, 1.1d)   = 1.1d\n *   NumberUtils.toDouble(\"\", 1.1d)     = 1.1d\n *   NumberUtils.toDouble(\"1.5\", 0.0d)  = 1.5d\n * </pre>\n *\n * @param str the string to convert, may be {@code null}\n * @param defaultValue the default value\n * @return the double represented by the string, or defaultValue\n *  if conversion fails\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 209, "method_signature": "double toDouble(String, double)", "filename": "NumberUtils.toDouble.json"}
{"callee_method_names": [], "method_name": "NumberUtils.toFloat", "method_implementation": "{\n    if (str == null) {\n        return defaultValue;\n    }\n    try {\n        return Float.parseFloat(str);\n    } catch (final NumberFormatException nfe) {\n        return defaultValue;\n    }\n}", "repo_id": "8", "comment": "/**\n * Convert a {@link String} to a {@code float}, returning a\n * default value if the conversion fails.\n *\n * <p>If the string {@code str} is {@code null}, the default\n * value is returned.</p>\n *\n * <pre>\n *   NumberUtils.toFloat(null, 1.1f)   = 1.0f\n *   NumberUtils.toFloat(\"\", 1.1f)     = 1.1f\n *   NumberUtils.toFloat(\"1.5\", 0.0f)  = 1.5f\n * </pre>\n *\n * @param str the string to convert, may be {@code null}\n * @param defaultValue the default value\n * @return the float represented by the string, or defaultValue\n *  if conversion fails\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 210, "method_signature": "float toFloat(String, float)", "filename": "NumberUtils.toFloat.json"}
{"callee_method_names": [], "method_name": "NumberUtils.toInt", "method_implementation": "{\n    if (str == null) {\n        return defaultValue;\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (final NumberFormatException nfe) {\n        return defaultValue;\n    }\n}", "repo_id": "8", "comment": "/**\n * Convert a {@link String} to an {@code int}, returning a\n * default value if the conversion fails.\n *\n * <p>If the string is {@code null}, the default value is returned.</p>\n *\n * <pre>\n *   NumberUtils.toInt(null, 1) = 1\n *   NumberUtils.toInt(\"\", 1)   = 1\n *   NumberUtils.toInt(\"1\", 0)  = 1\n * </pre>\n *\n * @param str  the string to convert, may be null\n * @param defaultValue  the default value\n * @return the int represented by the string, or the default if conversion fails\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 211, "method_signature": "int toInt(String, int)", "filename": "NumberUtils.toInt.json"}
{"callee_method_names": [], "method_name": "NumberUtils.toLong", "method_implementation": "{\n    if (str == null) {\n        return defaultValue;\n    }\n    try {\n        return Long.parseLong(str);\n    } catch (final NumberFormatException nfe) {\n        return defaultValue;\n    }\n}", "repo_id": "8", "comment": "/**\n * Convert a {@link String} to a {@code long}, returning a\n * default value if the conversion fails.\n *\n * <p>If the string is {@code null}, the default value is returned.</p>\n *\n * <pre>\n *   NumberUtils.toLong(null, 1L) = 1L\n *   NumberUtils.toLong(\"\", 1L)   = 1L\n *   NumberUtils.toLong(\"1\", 0L)  = 1L\n * </pre>\n *\n * @param str  the string to convert, may be null\n * @param defaultValue  the default value\n * @return the long represented by the string, or the default if conversion fails\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 212, "method_signature": "long toLong(String, long)", "filename": "NumberUtils.toLong.json"}
{"callee_method_names": [], "method_name": "NumberUtils.toScaledBigDecimal", "method_implementation": "{\n    if (value == null) {\n        return BigDecimal.ZERO;\n    }\n    return toScaledBigDecimal(createBigDecimal(value), scale, roundingMode);\n}", "repo_id": "8", "comment": "/**\n * Convert a {@link String} to a {@link BigDecimal} whose scale is the\n * specified value with a {@link RoundingMode} applied. If the input {@code value}\n * is {@code null}, we simply return {@code BigDecimal.ZERO}.\n *\n * @param value the {@link String} to convert, may be null.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMode a rounding behavior for numerical operations capable of\n *  discarding precision.\n * @return the scaled, with appropriate rounding, {@link BigDecimal}.\n * @since 3.8\n */\n", "repo_name": "commons-lang-master/", "id": 216, "method_signature": "BigDecimal toScaledBigDecimal(String, int, RoundingMode)", "filename": "NumberUtils.toScaledBigDecimal.json"}
{"callee_method_names": [], "method_name": "NumberUtils.toShort", "method_implementation": "{\n    if (str == null) {\n        return defaultValue;\n    }\n    try {\n        return Short.parseShort(str);\n    } catch (final NumberFormatException nfe) {\n        return defaultValue;\n    }\n}", "repo_id": "8", "comment": "/**\n * Convert a {@link String} to an {@code short}, returning a\n * default value if the conversion fails.\n *\n * <p>If the string is {@code null}, the default value is returned.</p>\n *\n * <pre>\n *   NumberUtils.toShort(null, 1) = 1\n *   NumberUtils.toShort(\"\", 1)   = 1\n *   NumberUtils.toShort(\"1\", 0)  = 1\n * </pre>\n *\n * @param str  the string to convert, may be null\n * @param defaultValue  the default value\n * @return the short represented by the string, or the default if conversion fails\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 217, "method_signature": "short toShort(String, short)", "filename": "NumberUtils.toShort.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testBigIntegerToDoubleBigInteger", "method_implementation": "{\n    assertEquals(0.0d, NumberUtils.toDouble((BigDecimal) null), \"toDouble(BigInteger) 1 failed\");\n    assertEquals(8.5d, NumberUtils.toDouble(BigDecimal.valueOf(8.5d)), \"toDouble(BigInteger) 2 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toDouble(BigDecimal)}\n */\n", "repo_name": "commons-lang-master/", "id": 1671, "method_signature": "void testBigIntegerToDoubleBigInteger()", "filename": "NumberUtilsTest.testBigIntegerToDoubleBigInteger.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testBigIntegerToDoubleBigIntegerD", "method_implementation": "{\n    assertEquals(1.1d, NumberUtils.toDouble((BigDecimal) null, 1.1d), \"toDouble(BigInteger) 1 failed\");\n    assertEquals(8.5d, NumberUtils.toDouble(BigDecimal.valueOf(8.5d), 1.1d), \"toDouble(BigInteger) 2 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toDouble(BigDecimal, double)}\n */\n", "repo_name": "commons-lang-master/", "id": 1672, "method_signature": "void testBigIntegerToDoubleBigIntegerD()", "filename": "NumberUtilsTest.testBigIntegerToDoubleBigIntegerD.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testCompareDouble", "method_implementation": "{\n    assertEquals(0, Double.compare(Double.NaN, Double.NaN));\n    assertEquals(Double.compare(Double.NaN, Double.POSITIVE_INFINITY), +1);\n    assertEquals(Double.compare(Double.NaN, Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(Double.NaN, 1.2d), +1);\n    assertEquals(Double.compare(Double.NaN, 0.0d), +1);\n    assertEquals(Double.compare(Double.NaN, -0.0d), +1);\n    assertEquals(Double.compare(Double.NaN, -1.2d), +1);\n    assertEquals(Double.compare(Double.NaN, -Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(Double.NaN, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, Double.NaN), -1);\n    assertEquals(0, Double.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY));\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, 1.2d), +1);\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, 0.0d), +1);\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, -0.0d), +1);\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, -1.2d), +1);\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(Double.MAX_VALUE, Double.NaN), -1);\n    assertEquals(Double.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY), -1);\n    assertEquals(0, Double.compare(Double.MAX_VALUE, Double.MAX_VALUE));\n    assertEquals(Double.compare(Double.MAX_VALUE, 1.2d), +1);\n    assertEquals(Double.compare(Double.MAX_VALUE, 0.0d), +1);\n    assertEquals(Double.compare(Double.MAX_VALUE, -0.0d), +1);\n    assertEquals(Double.compare(Double.MAX_VALUE, -1.2d), +1);\n    assertEquals(Double.compare(Double.MAX_VALUE, -Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(1.2d, Double.NaN), -1);\n    assertEquals(Double.compare(1.2d, Double.POSITIVE_INFINITY), -1);\n    assertEquals(Double.compare(1.2d, Double.MAX_VALUE), -1);\n    assertEquals(0, Double.compare(1.2d, 1.2d));\n    assertEquals(Double.compare(1.2d, 0.0d), +1);\n    assertEquals(Double.compare(1.2d, -0.0d), +1);\n    assertEquals(Double.compare(1.2d, -1.2d), +1);\n    assertEquals(Double.compare(1.2d, -Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(1.2d, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(0.0d, Double.NaN), -1);\n    assertEquals(Double.compare(0.0d, Double.POSITIVE_INFINITY), -1);\n    assertEquals(Double.compare(0.0d, Double.MAX_VALUE), -1);\n    assertEquals(Double.compare(0.0d, 1.2d), -1);\n    assertEquals(0, Double.compare(0.0d, 0.0d));\n    assertEquals(Double.compare(0.0d, -0.0d), +1);\n    assertEquals(Double.compare(0.0d, -1.2d), +1);\n    assertEquals(Double.compare(0.0d, -Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(0.0d, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(-0.0d, Double.NaN), -1);\n    assertEquals(Double.compare(-0.0d, Double.POSITIVE_INFINITY), -1);\n    assertEquals(Double.compare(-0.0d, Double.MAX_VALUE), -1);\n    assertEquals(Double.compare(-0.0d, 1.2d), -1);\n    assertEquals(Double.compare(-0.0d, 0.0d), -1);\n    assertEquals(0, Double.compare(-0.0d, -0.0d));\n    assertEquals(Double.compare(-0.0d, -1.2d), +1);\n    assertEquals(Double.compare(-0.0d, -Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(-0.0d, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(-1.2d, Double.NaN), -1);\n    assertEquals(Double.compare(-1.2d, Double.POSITIVE_INFINITY), -1);\n    assertEquals(Double.compare(-1.2d, Double.MAX_VALUE), -1);\n    assertEquals(Double.compare(-1.2d, 1.2d), -1);\n    assertEquals(Double.compare(-1.2d, 0.0d), -1);\n    assertEquals(Double.compare(-1.2d, -0.0d), -1);\n    assertEquals(0, Double.compare(-1.2d, -1.2d));\n    assertEquals(Double.compare(-1.2d, -Double.MAX_VALUE), +1);\n    assertEquals(Double.compare(-1.2d, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(-Double.MAX_VALUE, Double.NaN), -1);\n    assertEquals(Double.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY), -1);\n    assertEquals(Double.compare(-Double.MAX_VALUE, Double.MAX_VALUE), -1);\n    assertEquals(Double.compare(-Double.MAX_VALUE, 1.2d), -1);\n    assertEquals(Double.compare(-Double.MAX_VALUE, 0.0d), -1);\n    assertEquals(Double.compare(-Double.MAX_VALUE, -0.0d), -1);\n    assertEquals(Double.compare(-Double.MAX_VALUE, -1.2d), -1);\n    assertEquals(0, Double.compare(-Double.MAX_VALUE, -Double.MAX_VALUE));\n    assertEquals(Double.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY), +1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, Double.NaN), -1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), -1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE), -1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, 1.2d), -1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, 0.0d), -1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, -0.0d), -1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, -1.2d), -1);\n    assertEquals(Double.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE), -1);\n    assertEquals(0, Double.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));\n}", "repo_id": "8", "comment": "// Testing JDK against old Lang functionality\n", "repo_name": "commons-lang-master/", "id": 1673, "method_signature": "void testCompareDouble()", "filename": "NumberUtilsTest.testCompareDouble.json"}
{"callee_method_names": ["Double.toString", "Double.toString"], "method_name": "NumberUtilsTest.testCreateNumberMagnitude", "method_implementation": "{\n    // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type\n    assertEquals(Float.valueOf(Float.MAX_VALUE), NumberUtils.createNumber(\"3.4028235e+38\"));\n    assertEquals(Double.valueOf(3.4028236e+38), NumberUtils.createNumber(\"3.4028236e+38\"));\n    // Test Double.MAX_VALUE\n    assertEquals(Double.valueOf(Double.MAX_VALUE), NumberUtils.createNumber(\"1.7976931348623157e+308\"));\n    // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal)\n    assertEquals(new BigDecimal(\"1.7976931348623159e+308\"), NumberUtils.createNumber(\"1.7976931348623159e+308\"));\n    // Requested type is parsed as zero but the value is not zero\n    final Double nonZero1 = Double.valueOf(((double) Float.MIN_VALUE) / 2);\n    assertEquals(nonZero1, NumberUtils.createNumber(nonZero1.toString()));\n    assertEquals(nonZero1, NumberUtils.createNumber(nonZero1.toString() + \"F\"));\n    // Smallest double is 4.9e-324.\n    // Test a number with zero before and/or after the decimal place to hit edge cases.\n    final BigDecimal nonZero2 = new BigDecimal(\"4.9e-325\");\n    assertEquals(nonZero2, NumberUtils.createNumber(\"4.9e-325\"));\n    assertEquals(nonZero2, NumberUtils.createNumber(\"4.9e-325D\"));\n    final BigDecimal nonZero3 = new BigDecimal(\"1e-325\");\n    assertEquals(nonZero3, NumberUtils.createNumber(\"1e-325\"));\n    assertEquals(nonZero3, NumberUtils.createNumber(\"1e-325D\"));\n    final BigDecimal nonZero4 = new BigDecimal(\"0.1e-325\");\n    assertEquals(nonZero4, NumberUtils.createNumber(\"0.1e-325\"));\n    assertEquals(nonZero4, NumberUtils.createNumber(\"0.1e-325D\"));\n    assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber(\"0x12345678\"));\n    assertEquals(Long.valueOf(0x123456789L), NumberUtils.createNumber(\"0x123456789\"));\n    assertEquals(Long.valueOf(0x7fffffffffffffffL), NumberUtils.createNumber(\"0x7fffffffffffffff\"));\n    // Does not appear to be a way to create a literal BigInteger of this magnitude\n    assertEquals(new BigInteger(\"7fffffffffffffff0\", 16), NumberUtils.createNumber(\"0x7fffffffffffffff0\"));\n    assertEquals(Long.valueOf(0x7fffffffffffffffL), NumberUtils.createNumber(\"#7fffffffffffffff\"));\n    assertEquals(new BigInteger(\"7fffffffffffffff0\", 16), NumberUtils.createNumber(\"#7fffffffffffffff0\"));\n    // 31 bits\n    assertEquals(Integer.valueOf(017777777777), NumberUtils.createNumber(\"017777777777\"));\n    // 32 bits\n    assertEquals(Long.valueOf(037777777777L), NumberUtils.createNumber(\"037777777777\"));\n    // 63 bits\n    assertEquals(Long.valueOf(0777777777777777777777L), NumberUtils.createNumber(\"0777777777777777777777\"));\n    // 64 bits\n    assertEquals(new BigInteger(\"1777777777777777777777\", 8), NumberUtils.createNumber(\"01777777777777777777777\"));\n}", "repo_id": "8", "comment": "// Will probably need to be adjusted if code is changed to check precision (LANG-693)\n", "repo_name": "commons-lang-master/", "id": 1674, "method_signature": "void testCreateNumberMagnitude()", "filename": "NumberUtilsTest.testCreateNumberMagnitude.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testCreateNumberZero", "method_implementation": "{\n    // Handle integers\n    assertEquals(Integer.valueOf(0), NumberUtils.createNumber(\"0\"));\n    assertEquals(Integer.valueOf(0), NumberUtils.createNumber(\"-0\"));\n    assertEquals(Long.valueOf(0), NumberUtils.createNumber(\"0L\"));\n    assertEquals(Long.valueOf(0), NumberUtils.createNumber(\"-0L\"));\n    // Handle floating-point with optional leading sign, trailing exponent (eX)\n    // and format specifier (F or D).\n    // This should allow: 0. ; .0 ; 0.0 ; 0 (if exponent or format specifier is present)\n    // Exponent does not matter for zero\n    final int[] exponents = { -2345, 0, 13 };\n    final String[] zeros = { \"0.\", \".0\", \"0.0\", \"0\" };\n    final Float f0 = Float.valueOf(0);\n    final Float fn0 = Float.valueOf(-0F);\n    final Double d0 = Double.valueOf(0);\n    final Double dn0 = Double.valueOf(-0D);\n    for (final String zero : zeros) {\n        // Assume float if no preference.\n        // This requires a decimal point if there is no exponent.\n        if (zero.indexOf('.') != -1) {\n            assertCreateNumberZero(zero, f0, fn0);\n        }\n        for (final int exp : exponents) {\n            assertCreateNumberZero(zero + \"e\" + exp, f0, fn0);\n        }\n        // Type preference\n        assertCreateNumberZero(zero + \"F\", f0, fn0);\n        assertCreateNumberZero(zero + \"D\", d0, dn0);\n        for (final int exp : exponents) {\n            final String number = zero + \"e\" + exp;\n            assertCreateNumberZero(number + \"F\", f0, fn0);\n            assertCreateNumberZero(number + \"D\", d0, dn0);\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * LANG-1646: Support the requested Number type (Long, Float, Double) of valid zero input.\n */\n", "repo_name": "commons-lang-master/", "id": 1675, "method_signature": "void testCreateNumberZero()", "filename": "NumberUtilsTest.testCreateNumberZero.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testIsCreatable", "method_implementation": "{\n    compareIsCreatableWithCreateNumber(\"12345\", true);\n    compareIsCreatableWithCreateNumber(\"1234.5\", true);\n    compareIsCreatableWithCreateNumber(\".12345\", true);\n    compareIsCreatableWithCreateNumber(\"1234E5\", true);\n    compareIsCreatableWithCreateNumber(\"1234E+5\", true);\n    compareIsCreatableWithCreateNumber(\"1234E-5\", true);\n    compareIsCreatableWithCreateNumber(\"123.4E5\", true);\n    compareIsCreatableWithCreateNumber(\"-1234\", true);\n    compareIsCreatableWithCreateNumber(\"-1234.5\", true);\n    compareIsCreatableWithCreateNumber(\"-.12345\", true);\n    compareIsCreatableWithCreateNumber(\"-1234E5\", true);\n    compareIsCreatableWithCreateNumber(\"0\", true);\n    // LANG-1216\n    compareIsCreatableWithCreateNumber(\"0.1\", true);\n    compareIsCreatableWithCreateNumber(\"-0\", true);\n    compareIsCreatableWithCreateNumber(\"01234\", true);\n    compareIsCreatableWithCreateNumber(\"-01234\", true);\n    compareIsCreatableWithCreateNumber(\"-0xABC123\", true);\n    compareIsCreatableWithCreateNumber(\"-0x0\", true);\n    compareIsCreatableWithCreateNumber(\"123.4E21D\", true);\n    compareIsCreatableWithCreateNumber(\"-221.23F\", true);\n    compareIsCreatableWithCreateNumber(\"22338L\", true);\n    compareIsCreatableWithCreateNumber(null, false);\n    compareIsCreatableWithCreateNumber(\"\", false);\n    compareIsCreatableWithCreateNumber(\" \", false);\n    compareIsCreatableWithCreateNumber(\"\\r\\n\\t\", false);\n    compareIsCreatableWithCreateNumber(\"--2.3\", false);\n    compareIsCreatableWithCreateNumber(\".12.3\", false);\n    compareIsCreatableWithCreateNumber(\"-123E\", false);\n    compareIsCreatableWithCreateNumber(\"-123E+-212\", false);\n    compareIsCreatableWithCreateNumber(\"-123E2.12\", false);\n    compareIsCreatableWithCreateNumber(\"0xGF\", false);\n    compareIsCreatableWithCreateNumber(\"0xFAE-1\", false);\n    compareIsCreatableWithCreateNumber(\".\", false);\n    compareIsCreatableWithCreateNumber(\"-0ABC123\", false);\n    compareIsCreatableWithCreateNumber(\"123.4E-D\", false);\n    compareIsCreatableWithCreateNumber(\"123.4ED\", false);\n    compareIsCreatableWithCreateNumber(\"1234E5l\", false);\n    compareIsCreatableWithCreateNumber(\"11a\", false);\n    compareIsCreatableWithCreateNumber(\"1a\", false);\n    compareIsCreatableWithCreateNumber(\"a\", false);\n    compareIsCreatableWithCreateNumber(\"11g\", false);\n    compareIsCreatableWithCreateNumber(\"11z\", false);\n    compareIsCreatableWithCreateNumber(\"11def\", false);\n    compareIsCreatableWithCreateNumber(\"11d11\", false);\n    compareIsCreatableWithCreateNumber(\"11 11\", false);\n    compareIsCreatableWithCreateNumber(\" 1111\", false);\n    compareIsCreatableWithCreateNumber(\"1111 \", false);\n    // LANG-521\n    compareIsCreatableWithCreateNumber(\"2.\", true);\n    // LANG-664\n    compareIsCreatableWithCreateNumber(\"1.1L\", false);\n    // LANG-1645\n    compareIsCreatableWithCreateNumber(\"+0xF\", true);\n    // LANG-1645\n    compareIsCreatableWithCreateNumber(\"+0xFFFFFFFF\", true);\n    // LANG-1645\n    compareIsCreatableWithCreateNumber(\"+0xFFFFFFFFFFFFFFFF\", true);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\".0\", true);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\"0.\", true);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\"0.D\", true);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\"0e1\", true);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\"0e1D\", true);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\".D\", false);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\".e10\", false);\n    // LANG-1646\n    compareIsCreatableWithCreateNumber(\".e10D\", false);\n}", "repo_id": "8", "comment": "/**\n * Tests isCreatable(String) and tests that createNumber(String) returns a valid number iff isCreatable(String)\n * returns false.\n */\n", "repo_name": "commons-lang-master/", "id": 1676, "method_signature": "void testIsCreatable()", "filename": "NumberUtilsTest.testIsCreatable.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testIsNumber", "method_implementation": "{\n    compareIsNumberWithCreateNumber(\"12345\", true);\n    compareIsNumberWithCreateNumber(\"1234.5\", true);\n    compareIsNumberWithCreateNumber(\".12345\", true);\n    compareIsNumberWithCreateNumber(\"1234E5\", true);\n    compareIsNumberWithCreateNumber(\"1234E+5\", true);\n    compareIsNumberWithCreateNumber(\"1234E-5\", true);\n    compareIsNumberWithCreateNumber(\"123.4E5\", true);\n    compareIsNumberWithCreateNumber(\"-1234\", true);\n    compareIsNumberWithCreateNumber(\"-1234.5\", true);\n    compareIsNumberWithCreateNumber(\"-.12345\", true);\n    compareIsNumberWithCreateNumber(\"-0001.12345\", true);\n    compareIsNumberWithCreateNumber(\"-000.12345\", true);\n    compareIsNumberWithCreateNumber(\"+00.12345\", true);\n    compareIsNumberWithCreateNumber(\"+0002.12345\", true);\n    compareIsNumberWithCreateNumber(\"-1234E5\", true);\n    compareIsNumberWithCreateNumber(\"0\", true);\n    compareIsNumberWithCreateNumber(\"-0\", true);\n    compareIsNumberWithCreateNumber(\"01234\", true);\n    compareIsNumberWithCreateNumber(\"-01234\", true);\n    compareIsNumberWithCreateNumber(\"-0xABC123\", true);\n    compareIsNumberWithCreateNumber(\"-0x0\", true);\n    compareIsNumberWithCreateNumber(\"123.4E21D\", true);\n    compareIsNumberWithCreateNumber(\"-221.23F\", true);\n    compareIsNumberWithCreateNumber(\"22338L\", true);\n    compareIsNumberWithCreateNumber(null, false);\n    compareIsNumberWithCreateNumber(\"\", false);\n    compareIsNumberWithCreateNumber(\" \", false);\n    compareIsNumberWithCreateNumber(\"\\r\\n\\t\", false);\n    compareIsNumberWithCreateNumber(\"--2.3\", false);\n    compareIsNumberWithCreateNumber(\".12.3\", false);\n    compareIsNumberWithCreateNumber(\"-123E\", false);\n    compareIsNumberWithCreateNumber(\"-123E+-212\", false);\n    compareIsNumberWithCreateNumber(\"-123E2.12\", false);\n    compareIsNumberWithCreateNumber(\"0xGF\", false);\n    compareIsNumberWithCreateNumber(\"0xFAE-1\", false);\n    compareIsNumberWithCreateNumber(\".\", false);\n    compareIsNumberWithCreateNumber(\"-0ABC123\", false);\n    compareIsNumberWithCreateNumber(\"123.4E-D\", false);\n    compareIsNumberWithCreateNumber(\"123.4ED\", false);\n    compareIsNumberWithCreateNumber(\"+000E.12345\", false);\n    compareIsNumberWithCreateNumber(\"-000E.12345\", false);\n    compareIsNumberWithCreateNumber(\"1234E5l\", false);\n    compareIsNumberWithCreateNumber(\"11a\", false);\n    compareIsNumberWithCreateNumber(\"1a\", false);\n    compareIsNumberWithCreateNumber(\"a\", false);\n    compareIsNumberWithCreateNumber(\"11g\", false);\n    compareIsNumberWithCreateNumber(\"11z\", false);\n    compareIsNumberWithCreateNumber(\"11def\", false);\n    compareIsNumberWithCreateNumber(\"11d11\", false);\n    compareIsNumberWithCreateNumber(\"11 11\", false);\n    compareIsNumberWithCreateNumber(\" 1111\", false);\n    compareIsNumberWithCreateNumber(\"1111 \", false);\n    // LANG-521\n    compareIsNumberWithCreateNumber(\"2.\", true);\n    // LANG-664\n    compareIsNumberWithCreateNumber(\"1.1L\", false);\n    // LANG-1645\n    compareIsNumberWithCreateNumber(\"+0xF\", true);\n    // LANG-1645\n    compareIsNumberWithCreateNumber(\"+0xFFFFFFFF\", true);\n    // LANG-1645\n    compareIsNumberWithCreateNumber(\"+0xFFFFFFFFFFFFFFFF\", true);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\".0\", true);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\"0.\", true);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\"0.D\", true);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\"0e1\", true);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\"0e1D\", true);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\".D\", false);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\".e10\", false);\n    // LANG-1646\n    compareIsNumberWithCreateNumber(\".e10D\", false);\n}", "repo_id": "8", "comment": "/**\n * Tests isCreatable(String) and tests that createNumber(String) returns a valid number iff isCreatable(String)\n * returns false.\n */\n", "repo_name": "commons-lang-master/", "id": 1677, "method_signature": "void testIsNumber()", "filename": "NumberUtilsTest.testIsNumber.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testStringCreateNumberEnsureNoPrecisionLoss", "method_implementation": "{\n    final String shouldBeFloat = \"1.23\";\n    final String shouldBeDouble = \"3.40282354e+38\";\n    final String shouldBeBigDecimal = \"1.797693134862315759e+308\";\n    assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float);\n    assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double);\n    assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal);\n    // LANG-1060\n    assertTrue(NumberUtils.createNumber(\"001.12\") instanceof Float);\n    assertTrue(NumberUtils.createNumber(\"-001.12\") instanceof Float);\n    assertTrue(NumberUtils.createNumber(\"+001.12\") instanceof Float);\n    assertTrue(NumberUtils.createNumber(\"003.40282354e+38\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(\"-003.40282354e+38\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(\"+003.40282354e+38\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(\"0001.797693134862315759e+308\") instanceof BigDecimal);\n    assertTrue(NumberUtils.createNumber(\"-001.797693134862315759e+308\") instanceof BigDecimal);\n    assertTrue(NumberUtils.createNumber(\"+001.797693134862315759e+308\") instanceof BigDecimal);\n    //LANG-1613\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MIN_NORMAL)) instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MIN_NORMAL) + \"D\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MIN_NORMAL) + \"F\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MIN_VALUE)) instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MIN_VALUE) + \"D\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MIN_VALUE) + \"F\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MAX_VALUE)) instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MAX_VALUE) + \"D\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(Double.toString(Double.MAX_VALUE) + \"F\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(\"4.9e-324D\") instanceof Double);\n    assertTrue(NumberUtils.createNumber(\"4.9e-324F\") instanceof Double);\n}", "repo_id": "8", "comment": "/**\n * Test for {(@link NumberUtils#createNumber(String)}\n */\n", "repo_name": "commons-lang-master/", "id": 1678, "method_signature": "void testStringCreateNumberEnsureNoPrecisionLoss()", "filename": "NumberUtilsTest.testStringCreateNumberEnsureNoPrecisionLoss.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testStringToDoubleString", "method_implementation": "{\n    assertEquals(NumberUtils.toDouble(\"-1.2345\"), -1.2345d, \"toDouble(String) 1 failed\");\n    assertEquals(1.2345d, NumberUtils.toDouble(\"1.2345\"), \"toDouble(String) 2 failed\");\n    assertEquals(0.0d, NumberUtils.toDouble(\"abc\"), \"toDouble(String) 3 failed\");\n    // LANG-1060\n    assertEquals(NumberUtils.toDouble(\"-001.2345\"), -1.2345d, \"toDouble(String) 4 failed\");\n    assertEquals(1.2345d, NumberUtils.toDouble(\"+001.2345\"), \"toDouble(String) 5 failed\");\n    assertEquals(1.2345d, NumberUtils.toDouble(\"001.2345\"), \"toDouble(String) 6 failed\");\n    assertEquals(0d, NumberUtils.toDouble(\"000.00000\"), \"toDouble(String) 7 failed\");\n    assertEquals(NumberUtils.toDouble(Double.MAX_VALUE + \"\"), Double.MAX_VALUE, \"toDouble(Double.MAX_VALUE) failed\");\n    assertEquals(NumberUtils.toDouble(Double.MIN_VALUE + \"\"), Double.MIN_VALUE, \"toDouble(Double.MIN_VALUE) failed\");\n    assertEquals(0.0d, NumberUtils.toDouble(\"\"), \"toDouble(empty) failed\");\n    assertEquals(0.0d, NumberUtils.toDouble((String) null), \"toDouble(null) failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toDouble(String)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1679, "method_signature": "void testStringToDoubleString()", "filename": "NumberUtilsTest.testStringToDoubleString.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testStringToDoubleStringD", "method_implementation": "{\n    assertEquals(1.2345d, NumberUtils.toDouble(\"1.2345\", 5.1d), \"toDouble(String, int) 1 failed\");\n    assertEquals(5.0d, NumberUtils.toDouble(\"a\", 5.0d), \"toDouble(String, int) 2 failed\");\n    // LANG-1060\n    assertEquals(1.2345d, NumberUtils.toDouble(\"001.2345\", 5.1d), \"toDouble(String, int) 3 failed\");\n    assertEquals(NumberUtils.toDouble(\"-001.2345\", 5.1d), -1.2345d, \"toDouble(String, int) 4 failed\");\n    assertEquals(1.2345d, NumberUtils.toDouble(\"+001.2345\", 5.1d), \"toDouble(String, int) 5 failed\");\n    assertEquals(0d, NumberUtils.toDouble(\"000.00\", 5.1d), \"toDouble(String, int) 7 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toDouble(String, double)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1680, "method_signature": "void testStringToDoubleStringD()", "filename": "NumberUtilsTest.testStringToDoubleStringD.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToByteString", "method_implementation": "{\n    assertEquals(123, NumberUtils.toByte(\"123\"), \"toByte(String) 1 failed\");\n    assertEquals(0, NumberUtils.toByte(\"abc\"), \"toByte(String) 2 failed\");\n    assertEquals(0, NumberUtils.toByte(\"\"), \"toByte(empty) failed\");\n    assertEquals(0, NumberUtils.toByte(null), \"toByte(null) failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toByte(String)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1681, "method_signature": "void testToByteString()", "filename": "NumberUtilsTest.testToByteString.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToByteStringI", "method_implementation": "{\n    assertEquals(123, NumberUtils.toByte(\"123\", (byte) 5), \"toByte(String, byte) 1 failed\");\n    assertEquals(5, NumberUtils.toByte(\"12.3\", (byte) 5), \"toByte(String, byte) 2 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toByte(String, byte)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1682, "method_signature": "void testToByteStringI()", "filename": "NumberUtilsTest.testToByteStringI.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToFloatString", "method_implementation": "{\n    assertEquals(NumberUtils.toFloat(\"-1.2345\"), -1.2345f, \"toFloat(String) 1 failed\");\n    assertEquals(1.2345f, NumberUtils.toFloat(\"1.2345\"), \"toFloat(String) 2 failed\");\n    assertEquals(0.0f, NumberUtils.toFloat(\"abc\"), \"toFloat(String) 3 failed\");\n    // LANG-1060\n    assertEquals(NumberUtils.toFloat(\"-001.2345\"), -1.2345f, \"toFloat(String) 4 failed\");\n    assertEquals(1.2345f, NumberUtils.toFloat(\"+001.2345\"), \"toFloat(String) 5 failed\");\n    assertEquals(1.2345f, NumberUtils.toFloat(\"001.2345\"), \"toFloat(String) 6 failed\");\n    assertEquals(0f, NumberUtils.toFloat(\"000.00\"), \"toFloat(String) 7 failed\");\n    assertEquals(NumberUtils.toFloat(Float.MAX_VALUE + \"\"), Float.MAX_VALUE, \"toFloat(Float.MAX_VALUE) failed\");\n    assertEquals(NumberUtils.toFloat(Float.MIN_VALUE + \"\"), Float.MIN_VALUE, \"toFloat(Float.MIN_VALUE) failed\");\n    assertEquals(0.0f, NumberUtils.toFloat(\"\"), \"toFloat(empty) failed\");\n    assertEquals(0.0f, NumberUtils.toFloat(null), \"toFloat(null) failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toFloat(String)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1683, "method_signature": "void testToFloatString()", "filename": "NumberUtilsTest.testToFloatString.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToFloatStringF", "method_implementation": "{\n    assertEquals(1.2345f, NumberUtils.toFloat(\"1.2345\", 5.1f), \"toFloat(String, int) 1 failed\");\n    assertEquals(5.0f, NumberUtils.toFloat(\"a\", 5.0f), \"toFloat(String, int) 2 failed\");\n    // LANG-1060\n    assertEquals(5.0f, NumberUtils.toFloat(\"-001Z.2345\", 5.0f), \"toFloat(String, int) 3 failed\");\n    assertEquals(5.0f, NumberUtils.toFloat(\"+001AB.2345\", 5.0f), \"toFloat(String, int) 4 failed\");\n    assertEquals(5.0f, NumberUtils.toFloat(\"001Z.2345\", 5.0f), \"toFloat(String, int) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toFloat(String, float)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1684, "method_signature": "void testToFloatStringF()", "filename": "NumberUtilsTest.testToFloatStringF.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToIntString", "method_implementation": "{\n    assertEquals(12345, NumberUtils.toInt(\"12345\"), \"toInt(String) 1 failed\");\n    assertEquals(0, NumberUtils.toInt(\"abc\"), \"toInt(String) 2 failed\");\n    assertEquals(0, NumberUtils.toInt(\"\"), \"toInt(empty) failed\");\n    assertEquals(0, NumberUtils.toInt(null), \"toInt(null) failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toInt(String)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1685, "method_signature": "void testToIntString()", "filename": "NumberUtilsTest.testToIntString.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToIntStringI", "method_implementation": "{\n    assertEquals(12345, NumberUtils.toInt(\"12345\", 5), \"toInt(String, int) 1 failed\");\n    assertEquals(5, NumberUtils.toInt(\"1234.5\", 5), \"toInt(String, int) 2 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toInt(String, int)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1686, "method_signature": "void testToIntStringI()", "filename": "NumberUtilsTest.testToIntStringI.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToLongString", "method_implementation": "{\n    assertEquals(12345L, NumberUtils.toLong(\"12345\"), \"toLong(String) 1 failed\");\n    assertEquals(0L, NumberUtils.toLong(\"abc\"), \"toLong(String) 2 failed\");\n    assertEquals(0L, NumberUtils.toLong(\"1L\"), \"toLong(String) 3 failed\");\n    assertEquals(0L, NumberUtils.toLong(\"1l\"), \"toLong(String) 4 failed\");\n    assertEquals(NumberUtils.toLong(Long.MAX_VALUE + \"\"), Long.MAX_VALUE, \"toLong(Long.MAX_VALUE) failed\");\n    assertEquals(NumberUtils.toLong(Long.MIN_VALUE + \"\"), Long.MIN_VALUE, \"toLong(Long.MIN_VALUE) failed\");\n    assertEquals(0L, NumberUtils.toLong(\"\"), \"toLong(empty) failed\");\n    assertEquals(0L, NumberUtils.toLong(null), \"toLong(null) failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toLong(String)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1687, "method_signature": "void testToLongString()", "filename": "NumberUtilsTest.testToLongString.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToLongStringL", "method_implementation": "{\n    assertEquals(12345L, NumberUtils.toLong(\"12345\", 5L), \"toLong(String, long) 1 failed\");\n    assertEquals(5L, NumberUtils.toLong(\"1234.5\", 5L), \"toLong(String, long) 2 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toLong(String, long)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1688, "method_signature": "void testToLongStringL()", "filename": "NumberUtilsTest.testToLongStringL.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalBigDecimal", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(123.456)), BigDecimal.valueOf(123.46), \"toScaledBigDecimal(BigDecimal) 1 failed\");\n    // Test RoundingMode.HALF_EVEN default rounding.\n    assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.515)), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(BigDecimal) 2 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.525)), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(BigDecimal) 3 failed\");\n    assertEquals(\"2352.00\", NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.525)).multiply(BigDecimal.valueOf(100)).toString(), \"toScaledBigDecimal(BigDecimal) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((BigDecimal) null), BigDecimal.ZERO, \"toScaledBigDecimal(BigDecimal) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(BigDecimal)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1689, "method_signature": "void testToScaledBigDecimalBigDecimal()", "filename": "NumberUtilsTest.testToScaledBigDecimalBigDecimal.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalBigDecimalIRM", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(123.456), 1, RoundingMode.CEILING), BigDecimal.valueOf(123.5), \"toScaledBigDecimal(BigDecimal, int, RoundingMode) 1 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.5159), 3, RoundingMode.FLOOR), BigDecimal.valueOf(23.515), \"toScaledBigDecimal(BigDecimal, int, RoundingMode) 2 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.525), 2, RoundingMode.HALF_UP), BigDecimal.valueOf(23.53), \"toScaledBigDecimal(BigDecimal, int, RoundingMode) 3 failed\");\n    assertEquals(\"23521.0000\", NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.521), 4, RoundingMode.HALF_EVEN).multiply(BigDecimal.valueOf(1000)).toString(), \"toScaledBigDecimal(BigDecimal, int, RoundingMode) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((BigDecimal) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO, \"toScaledBigDecimal(BigDecimal, int, RoundingMode) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(BigDecimal, int, RoundingMode)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1690, "method_signature": "void testToScaledBigDecimalBigDecimalIRM()", "filename": "NumberUtilsTest.testToScaledBigDecimalBigDecimalIRM.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalDouble", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(123.456d)), BigDecimal.valueOf(123.46), \"toScaledBigDecimal(Double) 1 failed\");\n    // Test RoundingMode.HALF_EVEN default rounding.\n    assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.515d)), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(Double) 2 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.525d)), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(Double) 3 failed\");\n    assertEquals(\"2352.00\", NumberUtils.toScaledBigDecimal(Double.valueOf(23.525d)).multiply(BigDecimal.valueOf(100)).toString(), \"toScaledBigDecimal(Double) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((Double) null), BigDecimal.ZERO, \"toScaledBigDecimal(Double) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(Double)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1691, "method_signature": "void testToScaledBigDecimalDouble()", "filename": "NumberUtilsTest.testToScaledBigDecimalDouble.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalDoubleIRM", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(123.456d), 1, RoundingMode.CEILING), BigDecimal.valueOf(123.5), \"toScaledBigDecimal(Double, int, RoundingMode) 1 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.5159d), 3, RoundingMode.FLOOR), BigDecimal.valueOf(23.515), \"toScaledBigDecimal(Double, int, RoundingMode) 2 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.525d), 2, RoundingMode.HALF_UP), BigDecimal.valueOf(23.53), \"toScaledBigDecimal(Double, int, RoundingMode) 3 failed\");\n    assertEquals(\"23521.0000\", NumberUtils.toScaledBigDecimal(Double.valueOf(23.521d), 4, RoundingMode.HALF_EVEN).multiply(BigDecimal.valueOf(1000)).toString(), \"toScaledBigDecimal(Double, int, RoundingMode) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((Double) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO, \"toScaledBigDecimal(Double, int, RoundingMode) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(Double, int, RoundingMode)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1692, "method_signature": "void testToScaledBigDecimalDoubleIRM()", "filename": "NumberUtilsTest.testToScaledBigDecimalDoubleIRM.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalFloat", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(123.456f)), BigDecimal.valueOf(123.46), \"toScaledBigDecimal(Float) 1 failed\");\n    // Test RoundingMode.HALF_EVEN default rounding.\n    assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.515f)), BigDecimal.valueOf(23.51), \"toScaledBigDecimal(Float) 2 failed\");\n    // Note. NumberUtils.toScaledBigDecimal(Float.valueOf(23.515f)).equals(BigDecimal.valueOf(23.51))\n    // because of roundoff error. It is ok.\n    assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.525f)), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(Float) 3 failed\");\n    assertEquals(\"2352.00\", NumberUtils.toScaledBigDecimal(Float.valueOf(23.525f)).multiply(BigDecimal.valueOf(100)).toString(), \"toScaledBigDecimal(Float) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((Float) null), BigDecimal.ZERO, \"toScaledBigDecimal(Float) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(Float)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1693, "method_signature": "void testToScaledBigDecimalFloat()", "filename": "NumberUtilsTest.testToScaledBigDecimalFloat.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalFloatIRM", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(123.456f), 1, RoundingMode.CEILING), BigDecimal.valueOf(123.5), \"toScaledBigDecimal(Float, int, RoundingMode) 1 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.5159f), 3, RoundingMode.FLOOR), BigDecimal.valueOf(23.515), \"toScaledBigDecimal(Float, int, RoundingMode) 2 failed\");\n    // The following happens due to roundoff error. We're ok with this.\n    assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.525f), 2, RoundingMode.HALF_UP), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(Float, int, RoundingMode) 3 failed\");\n    assertEquals(\"23521.0000\", NumberUtils.toScaledBigDecimal(Float.valueOf(23.521f), 4, RoundingMode.HALF_EVEN).multiply(BigDecimal.valueOf(1000)).toString(), \"toScaledBigDecimal(Float, int, RoundingMode) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((Float) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO, \"toScaledBigDecimal(Float, int, RoundingMode) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(Float, int, RoundingMode)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1694, "method_signature": "void testToScaledBigDecimalFloatIRM()", "filename": "NumberUtilsTest.testToScaledBigDecimalFloatIRM.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalString", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(\"123.456\"), BigDecimal.valueOf(123.46), \"toScaledBigDecimal(String) 1 failed\");\n    // Test RoundingMode.HALF_EVEN default rounding.\n    assertEquals(NumberUtils.toScaledBigDecimal(\"23.515\"), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(String) 2 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(\"23.525\"), BigDecimal.valueOf(23.52), \"toScaledBigDecimal(String) 3 failed\");\n    assertEquals(\"2352.00\", NumberUtils.toScaledBigDecimal(\"23.525\").multiply(BigDecimal.valueOf(100)).toString(), \"toScaledBigDecimal(String) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((String) null), BigDecimal.ZERO, \"toScaledBigDecimal(String) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(Double)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1695, "method_signature": "void testToScaledBigDecimalString()", "filename": "NumberUtilsTest.testToScaledBigDecimalString.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToScaledBigDecimalStringIRM", "method_implementation": "{\n    assertEquals(NumberUtils.toScaledBigDecimal(\"123.456\", 1, RoundingMode.CEILING), BigDecimal.valueOf(123.5), \"toScaledBigDecimal(String, int, RoundingMode) 1 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(\"23.5159\", 3, RoundingMode.FLOOR), BigDecimal.valueOf(23.515), \"toScaledBigDecimal(String, int, RoundingMode) 2 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal(\"23.525\", 2, RoundingMode.HALF_UP), BigDecimal.valueOf(23.53), \"toScaledBigDecimal(String, int, RoundingMode) 3 failed\");\n    assertEquals(\"23521.0000\", NumberUtils.toScaledBigDecimal(\"23.521\", 4, RoundingMode.HALF_EVEN).multiply(BigDecimal.valueOf(1000)).toString(), \"toScaledBigDecimal(String, int, RoundingMode) 4 failed\");\n    assertEquals(NumberUtils.toScaledBigDecimal((String) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO, \"toScaledBigDecimal(String, int, RoundingMode) 5 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toScaledBigDecimal(Double, int, RoundingMode)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1696, "method_signature": "void testToScaledBigDecimalStringIRM()", "filename": "NumberUtilsTest.testToScaledBigDecimalStringIRM.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToShortString", "method_implementation": "{\n    assertEquals(12345, NumberUtils.toShort(\"12345\"), \"toShort(String) 1 failed\");\n    assertEquals(0, NumberUtils.toShort(\"abc\"), \"toShort(String) 2 failed\");\n    assertEquals(0, NumberUtils.toShort(\"\"), \"toShort(empty) failed\");\n    assertEquals(0, NumberUtils.toShort(null), \"toShort(null) failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toShort(String)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1697, "method_signature": "void testToShortString()", "filename": "NumberUtilsTest.testToShortString.json"}
{"callee_method_names": [], "method_name": "NumberUtilsTest.testToShortStringI", "method_implementation": "{\n    assertEquals(12345, NumberUtils.toShort(\"12345\", (short) 5), \"toShort(String, short) 1 failed\");\n    assertEquals(5, NumberUtils.toShort(\"1234.5\", (short) 5), \"toShort(String, short) 2 failed\");\n}", "repo_id": "8", "comment": "/**\n * Test for {@link NumberUtils#toShort(String, short)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1698, "method_signature": "void testToShortStringI()", "filename": "NumberUtilsTest.testToShortStringI.json"}
{"callee_method_names": ["Writer.write", "Writer.write", "Writer.write"], "method_name": "NumericEntityEscaper.translate", "method_implementation": "{\n    if (between) {\n        if (codePoint < below || codePoint > above) {\n            return false;\n        }\n    } else if (codePoint >= below && codePoint <= above) {\n        return false;\n    }\n    out.write(\"&#\");\n    out.write(Integer.toString(codePoint, 10));\n    out.write(';');\n    return true;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 432, "method_signature": "boolean translate(int, Writer)", "filename": "NumericEntityEscaper.translate.json"}
{"callee_method_ids": [432], "callee_method_names": ["NumericEntityEscaper.translate"], "method_name": "NumericEntityEscaperTest.testSupplementary", "method_implementation": "{\n    final NumericEntityEscaper nee = new NumericEntityEscaper();\n    final String input = \"\\uD803\\uDC22\";\n    final String expected = \"&#68642;\";\n    final String result = nee.translate(input);\n    assertEquals(expected, result, \"Failed to escape numeric entities supplementary characters\");\n}", "repo_id": "8", "comment": "// See LANG-617\n", "repo_name": "commons-lang-master/", "id": 1743, "method_signature": "void testSupplementary()", "filename": "NumericEntityEscaperTest.testSupplementary.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.subSequence", "CharSequence.subSequence", "Writer.write", "Writer.write", "Writer.write"], "method_name": "NumericEntityUnescaper.translate", "method_implementation": "{\n    final int seqEnd = input.length();\n    // Uses -2 to ensure there is something after the &#\n    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n        final char firstChar = input.charAt(start);\n        if (firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n            // Check there's more than just an x after the &#\n            if (start == seqEnd) {\n                return 0;\n            }\n        }\n        int end = start;\n        // Note that this supports character codes without a ; on the end\n        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {\n            end++;\n        }\n        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';\n        if (!semiNext) {\n            if (isSet(OPTION.semiColonRequired)) {\n                return 0;\n            }\n            if (isSet(OPTION.errorIfNoSemiColon)) {\n                throw new IllegalArgumentException(\"Semi-colon required at end of numeric entity\");\n            }\n        }\n        final int entityValue;\n        try {\n            if (isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch (final NumberFormatException nfe) {\n            return 0;\n        }\n        if (entityValue > 0xFFFF) {\n            final char[] chars = Character.toChars(entityValue);\n            out.write(chars[0]);\n            out.write(chars[1]);\n        } else {\n            out.write(entityValue);\n        }\n        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n    }\n    return 0;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 430, "method_signature": "int translate(CharSequence, int, Writer)", "filename": "NumericEntityUnescaper.translate.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.CONST_BYTE", "method_implementation": "{\n    if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {\n        throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -128 and 127: [\" + v + \"]\");\n    }\n    return (byte) v;\n}", "repo_id": "8", "comment": "/**\n * This method returns the provided value unchanged.\n * This can prevent javac from inlining a constant\n * field, e.g.,\n *\n * <pre>\n *     public final static byte MAGIC_BYTE = ObjectUtils.CONST_BYTE(127);\n * </pre>\n *\n * This way any jars that refer to this field do not\n * have to recompile themselves if the field's value\n * changes at some future date.\n *\n * @param v the byte literal (as an int) value to return\n * @throws IllegalArgumentException if the value passed to v\n *         is larger than a byte, that is, smaller than -128 or\n *         larger than 127.\n * @return the byte v, unchanged\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 567, "method_signature": "byte CONST_BYTE(int)", "filename": "ObjectUtils.CONST_BYTE.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.CONST_SHORT", "method_implementation": "{\n    if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {\n        throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -32768 and 32767: [\" + v + \"]\");\n    }\n    return (short) v;\n}", "repo_id": "8", "comment": "/**\n * This method returns the provided value unchanged.\n * This can prevent javac from inlining a constant\n * field, e.g.,\n *\n * <pre>\n *     public final static short MAGIC_SHORT = ObjectUtils.CONST_SHORT(127);\n * </pre>\n *\n * This way any jars that refer to this field do not\n * have to recompile themselves if the field's value\n * changes at some future date.\n *\n * @param v the short literal (as an int) value to return\n * @throws IllegalArgumentException if the value passed to v\n *         is larger than a short, that is, smaller than -32768 or\n *         larger than 32767.\n * @return the byte v, unchanged\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 568, "method_signature": "short CONST_SHORT(int)", "filename": "ObjectUtils.CONST_SHORT.json"}
{"callee_method_names": ["T.getClass", "Class<?>.isPrimitive", "T.getClass", "Method.invoke", "T.getClass", "T.getClass", "T.getClass", "Exception.getCause"], "method_name": "ObjectUtils.clone", "method_implementation": "{\n    if (obj instanceof Cloneable) {\n        final Object result;\n        if (isArray(obj)) {\n            final Class<?> componentType = obj.getClass().getComponentType();\n            if (componentType.isPrimitive()) {\n                int length = Array.getLength(obj);\n                result = Array.newInstance(componentType, length);\n                while (length-- > 0) {\n                    Array.set(result, length, Array.get(obj, length));\n                }\n            } else {\n                result = ((Object[]) obj).clone();\n            }\n        } else {\n            try {\n                final Method clone = obj.getClass().getMethod(\"clone\");\n                result = clone.invoke(obj);\n            } catch (final NoSuchMethodException e) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" has no clone method\", e);\n            } catch (final IllegalAccessException e) {\n                throw new CloneFailedException(\"Cannot clone Cloneable type \" + obj.getClass().getName(), e);\n            } catch (final InvocationTargetException e) {\n                throw new CloneFailedException(\"Exception cloning Cloneable type \" + obj.getClass().getName(), e.getCause());\n            }\n        }\n        // OK because input is of type T\n        @SuppressWarnings(\"unchecked\")\n        final T checked = (T) result;\n        return checked;\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Clone an object.\n *\n * @param <T> the type of the object\n * @param obj  the object to clone, null returns null\n * @return the clone if the object implements {@link Cloneable} otherwise {@code null}\n * @throws CloneFailedException if the object is cloneable and the clone operation fails\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 565, "method_signature": "T clone(T)", "filename": "ObjectUtils.clone.json"}
{"callee_method_names": ["T.compareTo"], "method_name": "ObjectUtils.compare", "method_implementation": "{\n    if (c1 == c2) {\n        return 0;\n    }\n    if (c1 == null) {\n        return nullGreater ? 1 : -1;\n    }\n    if (c2 == null) {\n        return nullGreater ? -1 : 1;\n    }\n    return c1.compareTo(c2);\n}", "repo_id": "8", "comment": "/**\n * Null safe comparison of Comparables.\n * <p>TODO Move to ComparableUtils.</p>\n *\n * @param <T> type of the values processed by this method\n * @param c1  the first comparable, may be null\n * @param c2  the second comparable, may be null\n * @param nullGreater if true {@code null} is considered greater\n *  than a non-{@code null} value or if false {@code null} is\n *  considered less than a Non-{@code null} value\n * @return a negative value if c1 &lt; c2, zero if c1 = c2\n *  and a positive value if c1 &gt; c2\n * @see java.util.Comparator#compare(Object, Object)\n */\n", "repo_name": "commons-lang-master/", "id": 566, "method_signature": "int compare(T, T, boolean)", "filename": "ObjectUtils.compare.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.hashCode", "method_implementation": "{\n    // hashCode(Object) for performance vs. hashCodeMulti(Object[]), as hash code is often critical\n    return Objects.hashCode(obj);\n}", "repo_id": "8", "comment": "/**\n * Gets the hash code of an object returning zero when the\n * object is {@code null}.\n *\n * <pre>\n * ObjectUtils.hashCode(null)   = 0\n * ObjectUtils.hashCode(obj)    = obj.hashCode()\n * </pre>\n *\n * @param obj  the object to obtain the hash code of, may be {@code null}\n * @return the hash code of the object, or zero if null\n * @since 2.1\n * @deprecated this method has been replaced by {@code java.util.Objects.hashCode(Object)} in Java 7 and will be\n * removed in future releases\n */\n", "repo_name": "commons-lang-master/", "id": 569, "method_signature": "int hashCode(Object)", "filename": "ObjectUtils.hashCode.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.hashCodeMulti", "method_implementation": "{\n    int hash = 1;\n    if (objects != null) {\n        for (final Object object : objects) {\n            final int tmpHash = Objects.hashCode(object);\n            hash = hash * 31 + tmpHash;\n        }\n    }\n    return hash;\n}", "repo_id": "8", "comment": "/**\n * Gets the hash code for multiple objects.\n *\n * <p>This allows a hash code to be rapidly calculated for a number of objects.\n * The hash code for a single object is the <em>not</em> same as {@link #hashCode(Object)}.\n * The hash code for multiple objects is the same as that calculated by an\n * {@link ArrayList} containing the specified objects.</p>\n *\n * <pre>\n * ObjectUtils.hashCodeMulti()                 = 1\n * ObjectUtils.hashCodeMulti((Object[]) null)  = 1\n * ObjectUtils.hashCodeMulti(a)                = 31 + a.hashCode()\n * ObjectUtils.hashCodeMulti(a,b)              = (31 + a.hashCode()) * 31 + b.hashCode()\n * ObjectUtils.hashCodeMulti(a,b,c)            = ((31 + a.hashCode()) * 31 + b.hashCode()) * 31 + c.hashCode()\n * </pre>\n *\n * @param objects  the objects to obtain the hash code of, may be {@code null}\n * @return the hash code of the objects, or zero if null\n * @since 3.0\n * @deprecated this method has been replaced by {@code java.util.Objects.hash(Object...)} in Java 7 and will be\n * removed in future releases.\n */\n", "repo_name": "commons-lang-master/", "id": 570, "method_signature": "int hashCodeMulti(Object[])", "filename": "ObjectUtils.hashCodeMulti.json"}
{"callee_method_names": ["Object.getClass", "StringBuilder.ensureCapacity", "StringBuilder.length", "String.length", "String.length", "StringBuilder.append"], "method_name": "ObjectUtils.identityToString", "method_implementation": "{\n    Objects.requireNonNull(object, \"object\");\n    final String name = object.getClass().getName();\n    final String hexString = identityHashCodeHex(object);\n    builder.ensureCapacity(builder.length() + name.length() + 1 + hexString.length());\n    builder.append(name).append(AT_SIGN).append(hexString);\n}", "repo_id": "8", "comment": "/**\n * Appends the toString that would be produced by {@link Object}\n * if a class did not override toString itself. {@code null}\n * will throw a NullPointerException for either of the two parameters.\n *\n * <pre>\n * ObjectUtils.identityToString(builder, \"\")            = builder.append(\"java.lang.String@1e23\")\n * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\")\n * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\")\n * </pre>\n *\n * @param builder  the builder to append to\n * @param object  the object to create a toString for\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 575, "method_signature": "void identityToString(StringBuilder, Object)", "filename": "ObjectUtils.identityToString.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.isEmpty", "method_implementation": "{\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof CharSequence) {\n        return ((CharSequence) object).length() == 0;\n    }\n    if (isArray(object)) {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Optional<?>) {\n        // TODO Java 11 Use Optional#isEmpty()\n        return !((Optional<?>) object).isPresent();\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Tests if an Object is empty or null.\n *\n * The following types are supported:\n * <ul>\n * <li>{@link CharSequence}: Considered empty if its length is zero.</li>\n * <li>{@link Array}: Considered empty if its length is zero.</li>\n * <li>{@link Collection}: Considered empty if it has zero elements.</li>\n * <li>{@link Map}: Considered empty if it has zero key-value mappings.</li>\n * <li>{@link Optional}: Considered empty if {@link Optional#isPresent} returns false, regardless of the \"emptiness\" of the contents.</li>\n * </ul>\n *\n * <pre>\n * ObjectUtils.isEmpty(null)             = true\n * ObjectUtils.isEmpty(\"\")               = true\n * ObjectUtils.isEmpty(\"ab\")             = false\n * ObjectUtils.isEmpty(new int[]{})      = true\n * ObjectUtils.isEmpty(new int[]{1,2,3}) = false\n * ObjectUtils.isEmpty(1234)             = false\n * ObjectUtils.isEmpty(1234)             = false\n * ObjectUtils.isEmpty(Optional.of(\"\"))  = false\n * ObjectUtils.isEmpty(Optional.empty()) = true\n * </pre>\n *\n * @param object  the {@link Object} to test, may be {@code null}\n * @return {@code true} if the object has a supported type and is empty or null,\n * {@code false} otherwise\n * @since 3.9\n */\n", "repo_name": "commons-lang-master/", "id": 576, "method_signature": "boolean isEmpty(Object)", "filename": "ObjectUtils.isEmpty.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.max", "method_implementation": "{\n    T result = null;\n    if (values != null) {\n        for (final T value : values) {\n            if (compare(value, result, false) > 0) {\n                result = value;\n            }\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Null safe comparison of Comparables.\n * <p>TODO Move to ComparableUtils.</p>\n *\n * @param <T> type of the values processed by this method\n * @param values the set of comparable values, may be null\n * @return\n *  <ul>\n *   <li>If any objects are non-null and unequal, the greater object.\n *   <li>If all objects are non-null and equal, the first.\n *   <li>If any of the comparables are null, the greater of the non-null objects.\n *   <li>If all the comparables are null, null is returned.\n *  </ul>\n */\n", "repo_name": "commons-lang-master/", "id": 577, "method_signature": "T max(T[])", "filename": "ObjectUtils.max.json"}
{"callee_method_names": ["TreeSet<T>.toArray", "TreeSet<T>.size"], "method_name": "ObjectUtils.median", "method_implementation": "{\n    Validate.notEmpty(items);\n    Validate.noNullElements(items);\n    final TreeSet<T> sort = new TreeSet<>();\n    Collections.addAll(sort, items);\n    //we know all items added were T instances\n    @SuppressWarnings(\"unchecked\")\n    final T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Find the \"best guess\" middle value among comparables. If there is an even\n * number of total values, the lower of the two middle values will be returned.\n * @param <T> type of values processed by this method\n * @param items to compare\n * @return T at middle position\n * @throws NullPointerException if items is {@code null}\n * @throws IllegalArgumentException if items is empty or contains {@code null} values\n * @since 3.0.1\n */\n", "repo_name": "commons-lang-master/", "id": 579, "method_signature": "T median(T[])", "filename": "ObjectUtils.median.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.min", "method_implementation": "{\n    T result = null;\n    if (values != null) {\n        for (final T value : values) {\n            if (compare(value, result, true) < 0) {\n                result = value;\n            }\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Null safe comparison of Comparables.\n * <p>TODO Move to ComparableUtils.</p>\n *\n * @param <T> type of the values processed by this method\n * @param values the set of comparable values, may be null\n * @return\n *  <ul>\n *   <li>If any objects are non-null and unequal, the lesser object.\n *   <li>If all objects are non-null and equal, the first.\n *   <li>If any of the comparables are null, the lesser of the non-null objects.\n *   <li>If all the comparables are null, null is returned.\n *  </ul>\n */\n", "repo_name": "commons-lang-master/", "id": 580, "method_signature": "T min(T[])", "filename": "ObjectUtils.min.json"}
{"callee_method_names": ["HashMap<T, MutableInt>.get", "HashMap<T, MutableInt>.put", "MutableInt.increment", "HashMap<T, MutableInt>.entrySet", "Exception.getValue", "Exception.getKey"], "method_name": "ObjectUtils.mode", "method_implementation": "{\n    if (ArrayUtils.isNotEmpty(items)) {\n        final HashMap<T, MutableInt> occurrences = new HashMap<>(items.length);\n        for (final T t : items) {\n            final MutableInt count = occurrences.get(t);\n            if (count == null) {\n                occurrences.put(t, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        T result = null;\n        int max = 0;\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final int cmp = e.getValue().intValue();\n            if (cmp == max) {\n                result = null;\n            } else if (cmp > max) {\n                max = cmp;\n                result = e.getKey();\n            }\n        }\n        return result;\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Find the most frequently occurring item.\n *\n * @param <T> type of values processed by this method\n * @param items to check\n * @return most populous T, {@code null} if non-unique or no items supplied\n * @since 3.0.1\n */\n", "repo_name": "commons-lang-master/", "id": 581, "method_signature": "T mode(T[])", "filename": "ObjectUtils.mode.json"}
{"callee_method_names": [], "method_name": "ObjectUtils.requireNonEmpty", "method_implementation": "{\n    // check for null first to give the most precise exception.\n    Objects.requireNonNull(obj, message);\n    if (isEmpty(obj)) {\n        throw new IllegalArgumentException(message);\n    }\n    return obj;\n}", "repo_id": "8", "comment": "/**\n * Checks that the specified object reference is not {@code null} or empty per {@link #isEmpty(Object)}. Use this\n * method for validation, for example:\n *\n * <blockquote>\n *\n * <pre>\n * public Foo(Bar bar) {\n *     this.bar = Objects.requireNonEmpty(bar, \"bar\");\n * }\n * </pre>\n *\n * </blockquote>\n *\n * @param <T> the type of the reference.\n * @param obj the object reference to check for nullity.\n * @param message the exception message.\n * @return {@code obj} if not {@code null}.\n * @throws NullPointerException     if {@code obj} is {@code null}.\n * @throws IllegalArgumentException if {@code obj} is empty per {@link #isEmpty(Object)}.\n * @see #isEmpty(Object)\n * @since 3.12.0\n */\n", "repo_name": "commons-lang-master/", "id": 582, "method_signature": "T requireNonEmpty(T, String)", "filename": "ObjectUtils.requireNonEmpty.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testAllNotNull", "method_implementation": "{\n    assertFalse(ObjectUtils.allNotNull((Object) null));\n    assertFalse(ObjectUtils.allNotNull((Object[]) null));\n    assertFalse(ObjectUtils.allNotNull(null, null, null));\n    assertFalse(ObjectUtils.allNotNull(null, FOO, BAR));\n    assertFalse(ObjectUtils.allNotNull(FOO, BAR, null));\n    assertFalse(ObjectUtils.allNotNull(FOO, BAR, null, FOO, BAR));\n    assertTrue(ObjectUtils.allNotNull());\n    assertTrue(ObjectUtils.allNotNull(FOO));\n    assertTrue(ObjectUtils.allNotNull(FOO, BAR, 1, Boolean.TRUE, new Object(), new Object[] {}));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#allNotNull(Object...)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1413, "method_signature": "void testAllNotNull()", "filename": "ObjectUtilsTest.testAllNotNull.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testAllNull", "method_implementation": "{\n    assertTrue(ObjectUtils.allNull());\n    assertTrue(ObjectUtils.allNull((Object) null));\n    assertTrue(ObjectUtils.allNull((Object[]) null));\n    assertTrue(ObjectUtils.allNull(null, null, null));\n    assertFalse(ObjectUtils.allNull(FOO));\n    assertFalse(ObjectUtils.allNull(null, FOO, null));\n    assertFalse(ObjectUtils.allNull(null, null, null, null, FOO, BAR));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#allNull(Object...)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1414, "method_signature": "void testAllNull()", "filename": "ObjectUtilsTest.testAllNull.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testAnyNotNull", "method_implementation": "{\n    assertFalse(ObjectUtils.anyNotNull());\n    assertFalse(ObjectUtils.anyNotNull((Object) null));\n    assertFalse(ObjectUtils.anyNotNull((Object[]) null));\n    assertFalse(ObjectUtils.anyNotNull(null, null, null));\n    assertTrue(ObjectUtils.anyNotNull(FOO));\n    assertTrue(ObjectUtils.anyNotNull(null, FOO, null));\n    assertTrue(ObjectUtils.anyNotNull(null, null, null, null, FOO, BAR));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#anyNotNull(Object...)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1415, "method_signature": "void testAnyNotNull()", "filename": "ObjectUtilsTest.testAnyNotNull.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testAnyNull", "method_implementation": "{\n    assertTrue(ObjectUtils.anyNull((Object) null));\n    assertTrue(ObjectUtils.anyNull(null, null, null));\n    assertTrue(ObjectUtils.anyNull(null, FOO, BAR));\n    assertTrue(ObjectUtils.anyNull(FOO, BAR, null));\n    assertTrue(ObjectUtils.anyNull(FOO, BAR, null, FOO, BAR));\n    assertFalse(ObjectUtils.anyNull());\n    assertFalse(ObjectUtils.anyNull(FOO));\n    assertFalse(ObjectUtils.anyNull(FOO, BAR, 1, Boolean.TRUE, new Object(), new Object[] {}));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#anyNull(Object...)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1416, "method_signature": "void testAnyNull()", "filename": "ObjectUtilsTest.testAnyNull.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testArray", "method_implementation": "{\n    assertFalse(ObjectUtils.isArray(null));\n    assertFalse(ObjectUtils.isArray(\"\"));\n    assertFalse(ObjectUtils.isArray(\"abg\"));\n    assertFalse(ObjectUtils.isArray(123));\n    assertTrue(ObjectUtils.isArray(NON_EMPTY_ARRAY));\n    assertTrue(ObjectUtils.isArray(new int[] { 1, 2, 3 }));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_BOOLEAN_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_BOOLEAN_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_BYTE_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_CHAR_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_CLASS_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_DOUBLE_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_FIELD_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_FLOAT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_INT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_LONG_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_METHOD_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_SHORT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_STRING_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_THROWABLE_ARRAY));\n    assertTrue(ObjectUtils.isArray(ArrayUtils.EMPTY_TYPE_ARRAY));\n}", "repo_id": "8", "comment": "/**\n * Test for {@link ObjectUtils#isArray(Object)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1417, "method_signature": "void testArray()", "filename": "ObjectUtilsTest.testArray.json"}
{"callee_method_names": ["CloneableString.getValue"], "method_name": "ObjectUtilsTest.testCloneOfCloneable", "method_implementation": "{\n    final CloneableString string = new CloneableString(\"apache\");\n    final CloneableString stringClone = ObjectUtils.clone(string);\n    assertEquals(\"apache\", stringClone.getValue());\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#clone(Object)} with a cloneable object.\n */\n", "repo_name": "commons-lang-master/", "id": 1418, "method_signature": "void testCloneOfCloneable()", "filename": "ObjectUtilsTest.testCloneOfCloneable.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testCloneOfNotCloneable", "method_implementation": "{\n    final String string = \"apache\";\n    assertNull(ObjectUtils.clone(string));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#clone(Object)} with a not cloneable object.\n */\n", "repo_name": "commons-lang-master/", "id": 1419, "method_signature": "void testCloneOfNotCloneable()", "filename": "ObjectUtilsTest.testCloneOfNotCloneable.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testCloneOfStringArray", "method_implementation": "{\n    assertTrue(Arrays.deepEquals(new String[] { \"string\" }, ObjectUtils.clone(new String[] { \"string\" })));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#clone(Object)} with an object array.\n */\n", "repo_name": "commons-lang-master/", "id": 1420, "method_signature": "void testCloneOfStringArray()", "filename": "ObjectUtilsTest.testCloneOfStringArray.json"}
{"callee_method_names": ["CloneFailedException.getCause"], "method_name": "ObjectUtilsTest.testCloneOfUncloneable", "method_implementation": "{\n    final UncloneableString string = new UncloneableString(\"apache\");\n    final CloneFailedException e = assertThrows(CloneFailedException.class, () -> ObjectUtils.clone(string));\n    assertEquals(NoSuchMethodException.class, e.getCause().getClass());\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#clone(Object)} with an uncloneable object.\n */\n", "repo_name": "commons-lang-master/", "id": 1421, "method_signature": "void testCloneOfUncloneable()", "filename": "ObjectUtilsTest.testCloneOfUncloneable.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testCompare", "method_implementation": "{\n    final Integer one = Integer.valueOf(1);\n    final Integer two = Integer.valueOf(2);\n    final Integer nullValue = null;\n    assertEquals(0, ObjectUtils.compare(nullValue, nullValue), \"Null Null false\");\n    assertEquals(0, ObjectUtils.compare(nullValue, nullValue, true), \"Null Null true\");\n    assertEquals(-1, ObjectUtils.compare(nullValue, one), \"Null one false\");\n    assertEquals(1, ObjectUtils.compare(nullValue, one, true), \"Null one true\");\n    assertEquals(1, ObjectUtils.compare(one, nullValue), \"one Null false\");\n    assertEquals(-1, ObjectUtils.compare(one, nullValue, true), \"one Null true\");\n    assertEquals(-1, ObjectUtils.compare(one, two), \"one two false\");\n    assertEquals(-1, ObjectUtils.compare(one, two, true), \"one two true\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#compare(Comparable, Comparable, boolean)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1422, "method_signature": "void testCompare()", "filename": "ObjectUtilsTest.testCompare.json"}
{"callee_method_names": ["CloneableString.getValue"], "method_name": "ObjectUtilsTest.testPossibleCloneOfCloneable", "method_implementation": "{\n    final CloneableString string = new CloneableString(\"apache\");\n    final CloneableString stringClone = ObjectUtils.cloneIfPossible(string);\n    assertEquals(\"apache\", stringClone.getValue());\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a cloneable object.\n */\n", "repo_name": "commons-lang-master/", "id": 1423, "method_signature": "void testPossibleCloneOfCloneable()", "filename": "ObjectUtilsTest.testPossibleCloneOfCloneable.json"}
{"callee_method_names": [], "method_name": "ObjectUtilsTest.testPossibleCloneOfNotCloneable", "method_implementation": "{\n    final String string = \"apache\";\n    assertSame(string, ObjectUtils.cloneIfPossible(string));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a not cloneable object.\n */\n", "repo_name": "commons-lang-master/", "id": 1424, "method_signature": "void testPossibleCloneOfNotCloneable()", "filename": "ObjectUtilsTest.testPossibleCloneOfNotCloneable.json"}
{"callee_method_names": ["CloneFailedException.getCause"], "method_name": "ObjectUtilsTest.testPossibleCloneOfUncloneable", "method_implementation": "{\n    final UncloneableString string = new UncloneableString(\"apache\");\n    final CloneFailedException e = assertThrows(CloneFailedException.class, () -> ObjectUtils.cloneIfPossible(string));\n    assertEquals(NoSuchMethodException.class, e.getCause().getClass());\n}", "repo_id": "8", "comment": "/**\n * Tests {@link ObjectUtils#cloneIfPossible(Object)} with an uncloneable object.\n */\n", "repo_name": "commons-lang-master/", "id": 1425, "method_signature": "void testPossibleCloneOfUncloneable()", "filename": "ObjectUtilsTest.testPossibleCloneOfUncloneable.json"}
{"callee_method_names": ["Supplier<String>.get"], "method_name": "Objects.requireNonNull", "method_implementation": "{\n    if (value == null) {\n        throw new NullPointerException(msgSupplier.get());\n    }\n    return value;\n}", "repo_id": "8", "comment": "/**\n * Checks, whether the given object is non-null. If so, returns the non-null\n * object as a result value. Otherwise, a NullPointerException is thrown.\n * @param <T> The type of parameter {@code value}, also the result type.\n * @param value The value, which is being checked.\n * @param msgSupplier A supplier, which creates the exception message, if the check fails.\n *     This supplier will only be invoked, if necessary.\n * @return The given input value, if it was found to be non-null.\n * @throws NullPointerException The input value was null.\n * @see java.util.Objects#requireNonNull(Object, String)\n * @see #requireNonNull(Object, String)\n */\n", "repo_name": "commons-lang-master/", "id": 1668, "method_signature": "T requireNonNull(T, Supplier)", "filename": "Objects.requireNonNull.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "StringBuilder.append", "CharSequence.charAt", "CharSequence.charAt", "StringBuilder.append", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt", "StringBuilder.append", "CharSequence.charAt", "Writer.write", "StringBuilder.toString", "StringBuilder.length"], "method_name": "OctalUnescaper.translate", "method_implementation": "{\n    // how many characters left, ignoring the first \\\n    final int remaining = input.length() - index - 1;\n    final StringBuilder builder = new StringBuilder();\n    if (input.charAt(index) == '\\\\' && remaining > 0 && isOctalDigit(input.charAt(index + 1))) {\n        final int next = index + 1;\n        final int next2 = index + 2;\n        final int next3 = index + 3;\n        // we know this is good as we checked it in the if block above\n        builder.append(input.charAt(next));\n        if (remaining > 1 && isOctalDigit(input.charAt(next2))) {\n            builder.append(input.charAt(next2));\n            if (remaining > 2 && isZeroToThree(input.charAt(next)) && isOctalDigit(input.charAt(next3))) {\n                builder.append(input.charAt(next3));\n            }\n        }\n        out.write(Integer.parseInt(builder.toString(), 8));\n        return 1 + builder.length();\n    }\n    return 0;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 426, "method_signature": "int translate(CharSequence, int, Writer)", "filename": "OctalUnescaper.translate.json"}
{"callee_method_names": [], "method_name": "PaddedNumberField.appendTo", "method_implementation": "{\n    // Checkstyle complains about redundant qualifier\n    appendFullDigits(buffer, value, size);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 675, "method_signature": "void appendTo(Appendable, int)", "filename": "PaddedNumberField.appendTo.json"}
{"callee_method_names": ["Pair<L,R>.getLeft", "Pair<L,R>.getRight"], "method_name": "Pair.compareTo", "method_implementation": "{\n    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison();\n}", "repo_id": "8", "comment": "/**\n * Compares the pair based on the left element followed by the right element.\n * The types must be {@link Comparable}.\n *\n * @param other  the other pair, not null\n * @return negative if this is less, zero if equal, positive if greater\n */\n", "repo_name": "commons-lang-master/", "id": 1324, "method_signature": "int compareTo(Pair)", "filename": "Pair.compareTo.json"}
{"callee_method_names": ["Map.Entry<?, ?>.getKey", "Map.Entry<?, ?>.getValue"], "method_name": "Pair.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof Map.Entry<?, ?>) {\n        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n        return Objects.equals(getKey(), other.getKey()) && Objects.equals(getValue(), other.getValue());\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this pair to another based on the two elements.\n *\n * @param obj  the object to compare to, null returns false\n * @return true if the elements of the pair are equal\n */\n", "repo_name": "commons-lang-master/", "id": 1325, "method_signature": "boolean equals(Object)", "filename": "Pair.equals.json"}
{"callee_method_names": [], "method_name": "Pair.hashCode", "method_implementation": "{\n    // see Map.Entry API specification\n    return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());\n}", "repo_id": "8", "comment": "/**\n * Returns a suitable hash code.\n * The hash code follows the definition in {@code Map.Entry}.\n *\n * @return the hash code\n */\n", "repo_name": "commons-lang-master/", "id": 1326, "method_signature": "int hashCode()", "filename": "Pair.hashCode.json"}
{"callee_method_names": ["Class<?>.hashCode"], "method_name": "ParameterizedTypeImpl.hashCode", "method_implementation": "{\n    int result = 71 << 4;\n    result |= raw.hashCode();\n    result <<= 4;\n    result |= Objects.hashCode(useOwner);\n    result <<= 8;\n    result |= Arrays.hashCode(typeArguments);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 294, "method_signature": "int hashCode()", "filename": "ParameterizedTypeImpl.hashCode.json"}
{"callee_method_names": ["Method.invoke"], "method_name": "ProxyInvocationHandler.invoke", "method_implementation": "{\n    for (final L listener : listeners) {\n        method.invoke(listener, args);\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Propagates the method call to all registered listeners in place of the proxy listener object.\n *\n * @param unusedProxy the proxy object representing a listener on which the invocation was called; not used\n * @param method the listener method that will be called on all of the listeners.\n * @param args event arguments to propagate to the listeners.\n * @return the result of the method call\n * @throws InvocationTargetException if an error occurs\n * @throws IllegalArgumentException if an error occurs\n * @throws IllegalAccessException if an error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 727, "method_signature": "Object invoke(Object, Method, Object[])", "filename": "ProxyInvocationHandler.invoke.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "RandomStringUtils.random", "method_implementation": "{\n    if (chars == null) {\n        return random(count, 0, 0, false, false, null, random());\n    }\n    return random(count, chars.toCharArray());\n}", "repo_id": "8", "comment": "/**\n * Creates a random string whose length is the number of characters\n * specified.\n *\n * <p>Characters will be chosen from the set of characters\n * specified by the string, must not be empty.\n * If null, the set of all characters is used.</p>\n *\n * @param count  the length of random string to create\n * @param chars  the String containing the set of characters to use,\n *  may be null, but must not be empty\n * @return the random string\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n */\n", "repo_name": "commons-lang-master/", "id": 835, "method_signature": "String random(int, String)", "filename": "RandomStringUtils.random.json"}
{"callee_method_names": [], "method_name": "RandomStringUtilsTest.chiSquare", "method_implementation": "{\n    double sumSq = 0.0d;\n    double dev = 0.0d;\n    for (int i = 0; i < observed.length; i++) {\n        dev = observed[i] - expected[i];\n        sumSq += dev * dev / expected[i];\n    }\n    return sumSq;\n}", "repo_id": "8", "comment": "/**\n * Computes Chi-Square statistic given observed and expected counts\n * @param observed array of observed frequency counts\n * @param expected array of expected frequency counts\n */\n", "repo_name": "commons-lang-master/", "id": 1886, "method_signature": "double chiSquare(int[], int[])", "filename": "RandomStringUtilsTest.chiSquare.json"}
{"callee_method_names": ["String.codePointAt"], "method_name": "RandomStringUtilsTest.testCharOverflow", "method_implementation": "{\n    final int start = Character.MAX_VALUE;\n    final int end = Integer.MAX_VALUE;\n    @SuppressWarnings(\"serial\")\n    final Random fixedRandom = new Random() {\n\n        @Override\n        public int nextInt(final int n) {\n            // Prevents selection of 'start' as the character\n            return super.nextInt(n - 1) + 1;\n        }\n    };\n    final String result = RandomStringUtils.random(2, start, end, false, false, null, fixedRandom);\n    final int c = result.codePointAt(0);\n    assertTrue(c >= start && c < end, String.format(\"Character '%d' not in range [%d,%d).\", c, start, end));\n}", "repo_id": "8", "comment": "/**\n * Test for LANG-1286. Creates situation where old code would\n * overflow a char and result in a code point outside the specified\n * range.\n */\n", "repo_name": "commons-lang-master/", "id": 1887, "method_signature": "void testCharOverflow()", "filename": "RandomStringUtilsTest.testCharOverflow.json"}
{"callee_method_names": ["String.getBytes", "String.length", "String.length", "String.charAt", "String.charAt", "String.length", "String.length"], "method_name": "RandomStringUtilsTest.testLang100", "method_implementation": "{\n    final int size = 5000;\n    final Charset charset = StandardCharsets.UTF_8;\n    final String orig = RandomStringUtils.random(size);\n    final byte[] bytes = orig.getBytes(charset);\n    final String copy = new String(bytes, charset);\n    // for a verbose compare:\n    for (int i = 0; i < orig.length() && i < copy.length(); i++) {\n        final char o = orig.charAt(i);\n        final char c = copy.charAt(i);\n        assertEquals(o, c, \"differs at \" + i + \"(\" + Integer.toHexString(Character.valueOf(o).hashCode()) + \",\" + Integer.toHexString(Character.valueOf(c).hashCode()) + \")\");\n    }\n    // compare length also\n    assertEquals(orig.length(), copy.length());\n    // just to be complete\n    assertEquals(orig, copy);\n}", "repo_id": "8", "comment": "/**\n * Checks if the string got by {@link RandomStringUtils#random(int)}\n * can be converted to UTF-8 and back without loss.\n *\n * @see <a href=\"https://issues.apache.org/jira/browse/LANG-100\">LANG-100</a>\n */\n", "repo_name": "commons-lang-master/", "id": 1888, "method_signature": "void testLang100()", "filename": "RandomStringUtilsTest.testLang100.json"}
{"callee_method_names": ["String.indexOf"], "method_name": "RandomStringUtilsTest.testRandomAlphaNumeric", "method_implementation": "{\n    final char[] testChars = { 'a', 'z', 'A', 'Z', '0', '9' };\n    final boolean[] found = { false, false, false, false, false, false };\n    for (int i = 0; i < LOOP_COUNT; i++) {\n        final String randString = RandomStringUtils.randomAlphanumeric(10);\n        for (int j = 0; j < testChars.length; j++) {\n            if (randString.indexOf(testChars[j]) > 0) {\n                found[j] = true;\n            }\n        }\n    }\n    for (int i = 0; i < testChars.length; i++) {\n        assertTrue(found[i], \"alphanumeric character not generated in 1000 attempts: \" + testChars[i] + \" -- repeated failures indicate a problem \");\n    }\n}", "repo_id": "8", "comment": "/**\n * Make sure boundary alphanumeric characters are generated by randomAlphaNumeric\n * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7\n */\n", "repo_name": "commons-lang-master/", "id": 1890, "method_signature": "void testRandomAlphaNumeric()", "filename": "RandomStringUtilsTest.testRandomAlphaNumeric.json"}
{"callee_method_names": ["String.indexOf"], "method_name": "RandomStringUtilsTest.testRandomAlphabetic", "method_implementation": "{\n    final char[] testChars = { 'a', 'z', 'A', 'Z' };\n    final boolean[] found = { false, false, false, false };\n    for (int i = 0; i < LOOP_COUNT; i++) {\n        final String randString = RandomStringUtils.randomAlphabetic(10);\n        for (int j = 0; j < testChars.length; j++) {\n            if (randString.indexOf(testChars[j]) > 0) {\n                found[j] = true;\n            }\n        }\n    }\n    for (int i = 0; i < testChars.length; i++) {\n        assertTrue(found[i], \"alphanumeric character not generated in 1000 attempts: \" + testChars[i] + \" -- repeated failures indicate a problem \");\n    }\n}", "repo_id": "8", "comment": "/**\n * Make sure boundary alpha characters are generated by randomAlphabetic\n * This test will fail randomly with probability = 4 * (51/52)**1000 ~ 1.58E-8\n */\n", "repo_name": "commons-lang-master/", "id": 1889, "method_signature": "void testRandomAlphabetic()", "filename": "RandomStringUtilsTest.testRandomAlphabetic.json"}
{"callee_method_names": ["String.indexOf"], "method_name": "RandomStringUtilsTest.testRandomAscii", "method_implementation": "{\n    final char[] testChars = { (char) 32, (char) 126 };\n    final boolean[] found = { false, false };\n    // Test failures have been observed on GitHub builds with a 100 limit.\n    for (int i = 0; i < LOOP_COUNT; i++) {\n        final String randString = RandomStringUtils.randomAscii(10);\n        for (int j = 0; j < testChars.length; j++) {\n            if (randString.indexOf(testChars[j]) > 0) {\n                found[j] = true;\n            }\n        }\n    }\n    for (int i = 0; i < testChars.length; i++) {\n        assertTrue(found[i], \"ascii character not generated in 1000 attempts: \" + (int) testChars[i] + \" -- repeated failures indicate a problem\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Make sure 32 and 127 are generated by randomNumeric\n * This test will fail randomly with probability = 2*(95/96)**1000 ~ 5.7E-5\n */\n", "repo_name": "commons-lang-master/", "id": 1891, "method_signature": "void testRandomAscii()", "filename": "RandomStringUtilsTest.testRandomAscii.json"}
{"callee_method_names": ["String.indexOf"], "method_name": "RandomStringUtilsTest.testRandomNumeric", "method_implementation": "{\n    final char[] testChars = { '0', '9' };\n    final boolean[] found = { false, false };\n    for (int i = 0; i < LOOP_COUNT; i++) {\n        final String randString = RandomStringUtils.randomNumeric(10);\n        for (int j = 0; j < testChars.length; j++) {\n            if (randString.indexOf(testChars[j]) > 0) {\n                found[j] = true;\n            }\n        }\n    }\n    for (int i = 0; i < testChars.length; i++) {\n        assertTrue(found[i], \"digit not generated in 1000 attempts: \" + testChars[i] + \" -- repeated failures indicate a problem \");\n    }\n}", "repo_id": "8", "comment": "/**\n * Make sure '0' and '9' are generated by randomNumeric\n * This test will fail randomly with probability = 2 * (9/10)**1000 ~ 3.5E-46\n */\n", "repo_name": "commons-lang-master/", "id": 1892, "method_signature": "void testRandomNumeric()", "filename": "RandomStringUtilsTest.testRandomNumeric.json"}
{"callee_method_names": ["String.length", "String.length", "String.equals", "String.length", "String.length", "String.charAt", "String.equals", "String.length", "String.length", "String.charAt", "String.charAt", "String.equals", "String.length", "String.length", "String.charAt", "String.equals", "String.length", "String.length", "String.charAt", "String.charAt", "String.equals", "String.length", "String.length", "String.charAt", "String.charAt", "String.equals", "String.length", "String.length", "String.charAt", "String.charAt", "String.equals", "String.length", "String.length", "String.indexOf", "String.charAt", "String.equals", "String.length", "String.length", "String.equals", "String.toCharArray", "String.length", "String.length", "String.indexOf", "String.charAt", "String.equals", "String.length", "String.length", "String.equals"], "method_name": "RandomStringUtilsTest.testRandomStringUtils", "method_implementation": "{\n    String r1 = RandomStringUtils.random(50);\n    assertEquals(50, r1.length(), \"random(50) length\");\n    String r2 = RandomStringUtils.random(50);\n    assertEquals(50, r2.length(), \"random(50) length\");\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.randomAscii(50);\n    assertEquals(50, r1.length(), \"randomAscii(50) length\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertThat(\"char >= 32 && <= 127\", ((int) r1.charAt(i)), allOf(greaterThanOrEqualTo(32), lessThanOrEqualTo(127)));\n    }\n    r2 = RandomStringUtils.randomAscii(50);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.randomAlphabetic(50);\n    assertEquals(50, r1.length(), \"randomAlphabetic(50)\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertTrue(Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)), \"r1 contains alphabetic\");\n    }\n    r2 = RandomStringUtils.randomAlphabetic(50);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.randomAlphanumeric(50);\n    assertEquals(50, r1.length(), \"randomAlphanumeric(50)\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertTrue(Character.isLetterOrDigit(r1.charAt(i)), \"r1 contains alphanumeric\");\n    }\n    r2 = RandomStringUtils.randomAlphabetic(50);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.randomGraph(50);\n    assertEquals(50, r1.length(), \"randomGraph(50) length\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertTrue(r1.charAt(i) >= 33 && r1.charAt(i) <= 126, \"char between 33 and 126\");\n    }\n    r2 = RandomStringUtils.randomGraph(50);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.randomNumeric(50);\n    assertEquals(50, r1.length(), \"randomNumeric(50)\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertTrue(Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)), \"r1 contains numeric\");\n    }\n    r2 = RandomStringUtils.randomNumeric(50);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.randomPrint(50);\n    assertEquals(50, r1.length(), \"randomPrint(50) length\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertTrue(r1.charAt(i) >= 32 && r1.charAt(i) <= 126, \"char between 32 and 126\");\n    }\n    r2 = RandomStringUtils.randomPrint(50);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    String set = \"abcdefg\";\n    r1 = RandomStringUtils.random(50, set);\n    assertEquals(50, r1.length(), \"random(50, \\\"abcdefg\\\")\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertTrue(set.indexOf(r1.charAt(i)) > -1, \"random char in set\");\n    }\n    r2 = RandomStringUtils.random(50, set);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.random(50, (String) null);\n    assertEquals(50, r1.length(), \"random(50) length\");\n    r2 = RandomStringUtils.random(50, (String) null);\n    assertEquals(50, r2.length(), \"random(50) length\");\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    set = \"stuvwxyz\";\n    r1 = RandomStringUtils.random(50, set.toCharArray());\n    assertEquals(50, r1.length(), \"random(50, \\\"stuvwxyz\\\")\");\n    for (int i = 0; i < r1.length(); i++) {\n        assertTrue(set.indexOf(r1.charAt(i)) > -1, \"random char in set\");\n    }\n    r2 = RandomStringUtils.random(50, set);\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    r1 = RandomStringUtils.random(50, (char[]) null);\n    assertEquals(50, r1.length(), \"random(50) length\");\n    r2 = RandomStringUtils.random(50, (char[]) null);\n    assertEquals(50, r2.length(), \"random(50) length\");\n    assertFalse(r1.equals(r2), \"!r1.equals(r2)\");\n    final long seedMillis = System.currentTimeMillis();\n    r1 = RandomStringUtils.random(50, 0, 0, true, true, null, new Random(seedMillis));\n    r2 = RandomStringUtils.random(50, 0, 0, true, true, null, new Random(seedMillis));\n    assertEquals(r1, r2, \"r1.equals(r2)\");\n    r1 = RandomStringUtils.random(0);\n    assertEquals(\"\", r1, \"random(0).equals(\\\"\\\")\");\n}", "repo_id": "8", "comment": "/**\n * Test the implementation\n */\n", "repo_name": "commons-lang-master/", "id": 1893, "method_signature": "void testRandomStringUtils()", "filename": "RandomStringUtilsTest.testRandomStringUtils.json"}
{"callee_method_names": ["String.toCharArray", "String.charAt"], "method_name": "RandomStringUtilsTest.testRandomStringUtilsHomog", "method_implementation": "{\n    final String set = \"abc\";\n    final char[] chars = set.toCharArray();\n    String gen = \"\";\n    final int[] counts = { 0, 0, 0 };\n    final int[] expected = { 200, 200, 200 };\n    for (int i = 0; i < 100; i++) {\n        gen = RandomStringUtils.random(6, chars);\n        for (int j = 0; j < 6; j++) {\n            switch(gen.charAt(j)) {\n                case 'a':\n                    {\n                        counts[0]++;\n                        break;\n                    }\n                case 'b':\n                    {\n                        counts[1]++;\n                        break;\n                    }\n                case 'c':\n                    {\n                        counts[2]++;\n                        break;\n                    }\n                default:\n                    {\n                        fail(\"generated character not in set\");\n                    }\n            }\n        }\n    }\n    // Perform chi-square test with degrees of freedom = 3-1 = 2, testing at 1e-5 level.\n    // This expects a failure rate of 1 in 100,000.\n    // critical value: from scipy.stats import chi2; chi2(2).isf(1e-5)\n    assertThat(\"test homogeneity -- will fail about 1 in 100,000 times\", chiSquare(expected, counts), lessThan(23.025850929940457d));\n}", "repo_id": "8", "comment": "/**\n * Test homogeneity of random strings generated --\n * i.e., test that characters show up with expected frequencies\n * in generated strings.  Will fail randomly about 1 in 100,000 times.\n * Repeated failures indicate a problem.\n */\n", "repo_name": "commons-lang-master/", "id": 1894, "method_signature": "void testRandomStringUtilsHomog()", "filename": "RandomStringUtilsTest.testRandomStringUtilsHomog.json"}
{"callee_method_names": [], "method_name": "RandomUtils.nextBytes", "method_implementation": "{\n    Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n    final byte[] result = new byte[count];\n    random().nextBytes(result);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Generates an array of random bytes.\n *\n * @param count\n *            the size of the returned array\n * @return the random byte array\n * @throws IllegalArgumentException if {@code count} is negative\n */\n", "repo_name": "commons-lang-master/", "id": 1316, "method_signature": "byte[] nextBytes(int)", "filename": "RandomUtils.nextBytes.json"}
{"callee_method_names": [], "method_name": "RandomUtils.nextDouble", "method_implementation": "{\n    Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + ((endExclusive - startInclusive) * random().nextDouble());\n}", "repo_id": "8", "comment": "/**\n * Generates a random double within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random double\n */\n", "repo_name": "commons-lang-master/", "id": 1317, "method_signature": "double nextDouble(double, double)", "filename": "RandomUtils.nextDouble.json"}
{"callee_method_names": [], "method_name": "RandomUtils.nextFloat", "method_implementation": "{\n    Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + ((endExclusive - startInclusive) * random().nextFloat());\n}", "repo_id": "8", "comment": "/**\n * Generates a random float within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random float\n */\n", "repo_name": "commons-lang-master/", "id": 1318, "method_signature": "float nextFloat(float, float)", "filename": "RandomUtils.nextFloat.json"}
{"callee_method_names": [], "method_name": "RandomUtils.nextInt", "method_implementation": "{\n    Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + random().nextInt(endExclusive - startInclusive);\n}", "repo_id": "8", "comment": "/**\n * Generates a random integer within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random integer\n */\n", "repo_name": "commons-lang-master/", "id": 1319, "method_signature": "int nextInt(int, int)", "filename": "RandomUtils.nextInt.json"}
{"callee_method_names": [], "method_name": "RandomUtils.nextLong", "method_implementation": "{\n    Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + nextLong(endExclusive - startInclusive);\n}", "repo_id": "8", "comment": "/**\n * Generates a random long within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random long\n */\n", "repo_name": "commons-lang-master/", "id": 1321, "method_signature": "long nextLong(long, long)", "filename": "RandomUtils.nextLong.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testBoolean", "method_implementation": "{\n    final boolean result = RandomUtils.nextBoolean();\n    assertTrue(result || !result);\n}", "repo_id": "8", "comment": "/**\n * Tests next boolean\n */\n", "repo_name": "commons-lang-master/", "id": 1871, "method_signature": "void testBoolean()", "filename": "RandomUtilsTest.testBoolean.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testExtremeRangeDouble", "method_implementation": "{\n    final double result = RandomUtils.nextDouble(0, Double.MAX_VALUE);\n    // TODO: should be <max?\n    assertTrue(result >= 0 && result <= Double.MAX_VALUE);\n}", "repo_id": "8", "comment": "/**\n * Tests extreme range.\n */\n", "repo_name": "commons-lang-master/", "id": 1872, "method_signature": "void testExtremeRangeDouble()", "filename": "RandomUtilsTest.testExtremeRangeDouble.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testExtremeRangeFloat", "method_implementation": "{\n    final float result = RandomUtils.nextFloat(0, Float.MAX_VALUE);\n    // TODO: should be <max?\n    assertTrue(result >= 0f && result <= Float.MAX_VALUE);\n}", "repo_id": "8", "comment": "/**\n * Tests extreme range.\n */\n", "repo_name": "commons-lang-master/", "id": 1873, "method_signature": "void testExtremeRangeFloat()", "filename": "RandomUtilsTest.testExtremeRangeFloat.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testExtremeRangeInt", "method_implementation": "{\n    final int result = RandomUtils.nextInt(0, Integer.MAX_VALUE);\n    assertThat(\"result >= 0 && result < Integer.MAX_VALUE\", result, allOf(greaterThanOrEqualTo(0), lessThan(Integer.MAX_VALUE)));\n}", "repo_id": "8", "comment": "/**\n * Tests extreme range.\n */\n", "repo_name": "commons-lang-master/", "id": 1874, "method_signature": "void testExtremeRangeInt()", "filename": "RandomUtilsTest.testExtremeRangeInt.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testExtremeRangeLong", "method_implementation": "{\n    final long result = RandomUtils.nextLong(0, Long.MAX_VALUE);\n    assertThat(\"result >= 0 && result < Long.MAX_VALUE\", result, allOf(greaterThanOrEqualTo(0L), lessThan(Long.MAX_VALUE)));\n}", "repo_id": "8", "comment": "/**\n * Tests extreme range.\n */\n", "repo_name": "commons-lang-master/", "id": 1875, "method_signature": "void testExtremeRangeLong()", "filename": "RandomUtilsTest.testExtremeRangeLong.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testLargeValueRangeLong", "method_implementation": "{\n    final long startInclusive = 12900000000001L;\n    final long endExclusive = 12900000000016L;\n    // Note: The method using 'return (long) nextDouble(startInclusive, endExclusive)'\n    // takes thousands of calls to generate an error. This size loop fails most\n    // of the time with the previous method.\n    final int n = (int) (endExclusive - startInclusive) * 1000;\n    for (int i = 0; i < n; i++) {\n        assertNotEquals(endExclusive, RandomUtils.nextLong(startInclusive, endExclusive));\n    }\n}", "repo_id": "8", "comment": "/**\n * Test a large value for long. A previous implementation using\n * {@link RandomUtils#nextDouble(double, double)} could generate a value equal\n * to the upper limit.\n *\n * <pre>\n * return (long) nextDouble(startInclusive, endExclusive);\n * </pre>\n *\n * <p>See LANG-1592.</p>\n */\n", "repo_name": "commons-lang-master/", "id": 1876, "method_signature": "void testLargeValueRangeLong()", "filename": "RandomUtilsTest.testLargeValueRangeLong.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextBytes", "method_implementation": "{\n    final byte[] result = RandomUtils.nextBytes(20);\n    assertEquals(20, result.length);\n}", "repo_id": "8", "comment": "/**\n * Tests random byte array.\n */\n", "repo_name": "commons-lang-master/", "id": 1877, "method_signature": "void testNextBytes()", "filename": "RandomUtilsTest.testNextBytes.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextDouble", "method_implementation": "{\n    final double result = RandomUtils.nextDouble(33d, 42d);\n    assertThat(\"result >= 33d && result < 42d\", result, allOf(greaterThanOrEqualTo(33d), lessThan(42d)));\n}", "repo_id": "8", "comment": "/**\n * Tests next double range.\n */\n", "repo_name": "commons-lang-master/", "id": 1878, "method_signature": "void testNextDouble()", "filename": "RandomUtilsTest.testNextDouble.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextDoubleRandomResult", "method_implementation": "{\n    final double randomResult = RandomUtils.nextDouble();\n    assertThat(\"randomResult >= 0 0 && randomResult < Double.MAX_VALUE\", randomResult, allOf(greaterThanOrEqualTo(0d), lessThan(Double.MAX_VALUE)));\n}", "repo_id": "8", "comment": "/**\n * Tests next double range, random result.\n */\n", "repo_name": "commons-lang-master/", "id": 1879, "method_signature": "void testNextDoubleRandomResult()", "filename": "RandomUtilsTest.testNextDoubleRandomResult.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextFloat", "method_implementation": "{\n    final float result = RandomUtils.nextFloat(33f, 42f);\n    assertThat(\"result >= 33f && result < 42f\", result, allOf(greaterThanOrEqualTo(33f), lessThan(42f)));\n}", "repo_id": "8", "comment": "/**\n * Tests next float range.\n */\n", "repo_name": "commons-lang-master/", "id": 1880, "method_signature": "void testNextFloat()", "filename": "RandomUtilsTest.testNextFloat.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextFloatRandomResult", "method_implementation": "{\n    final float randomResult = RandomUtils.nextFloat();\n    assertThat(\"randomResult >= 0 && randomResult < Double.MAX_VALUE\", randomResult, allOf(greaterThanOrEqualTo(0f), lessThan(Float.MAX_VALUE)));\n}", "repo_id": "8", "comment": "/**\n * Tests next float range, random result.\n */\n", "repo_name": "commons-lang-master/", "id": 1881, "method_signature": "void testNextFloatRandomResult()", "filename": "RandomUtilsTest.testNextFloatRandomResult.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextInt", "method_implementation": "{\n    final int result = RandomUtils.nextInt(33, 42);\n    assertThat(\"result >= 33 && result < 42\", result, allOf(greaterThanOrEqualTo(33), lessThan(42)));\n}", "repo_id": "8", "comment": "/**\n * Tests next int range.\n */\n", "repo_name": "commons-lang-master/", "id": 1882, "method_signature": "void testNextInt()", "filename": "RandomUtilsTest.testNextInt.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextIntRandomResult", "method_implementation": "{\n    final int randomResult = RandomUtils.nextInt();\n    assertTrue(randomResult > 0);\n    assertTrue(randomResult < Integer.MAX_VALUE);\n}", "repo_id": "8", "comment": "/**\n * Tests next int range, random result.\n */\n", "repo_name": "commons-lang-master/", "id": 1883, "method_signature": "void testNextIntRandomResult()", "filename": "RandomUtilsTest.testNextIntRandomResult.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextLong", "method_implementation": "{\n    final long result = RandomUtils.nextLong(33L, 42L);\n    assertThat(\"result >= 33L && result < 42L\", result, allOf(greaterThanOrEqualTo(33L), lessThan(42L)));\n}", "repo_id": "8", "comment": "/**\n * Tests next long range.\n */\n", "repo_name": "commons-lang-master/", "id": 1884, "method_signature": "void testNextLong()", "filename": "RandomUtilsTest.testNextLong.json"}
{"callee_method_names": [], "method_name": "RandomUtilsTest.testNextLongRandomResult", "method_implementation": "{\n    final long randomResult = RandomUtils.nextLong();\n    assertThat(\"randomResult >= 0 && randomResult < Long.MAX_VALUE\", randomResult, allOf(greaterThanOrEqualTo(0L), lessThan(Long.MAX_VALUE)));\n}", "repo_id": "8", "comment": "/**\n * Tests next long range, random result.\n */\n", "repo_name": "commons-lang-master/", "id": 1885, "method_signature": "void testNextLongRandomResult()", "filename": "RandomUtilsTest.testNextLongRandomResult.json"}
{"callee_method_names": ["Comparator<T>.compare", "Comparator<T>.compare"], "method_name": "Range.contains", "method_implementation": "{\n    if (element == null) {\n        return false;\n    }\n    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;\n}", "repo_id": "8", "comment": "/**\n * Checks whether the specified element occurs within this range.\n *\n * @param element  the element to check for, null returns false\n * @return true if the specified element occurs within this range\n */\n", "repo_name": "commons-lang-master/", "id": 818, "method_signature": "boolean contains(T)", "filename": "Range.contains.json"}
{"callee_method_names": [], "method_name": "Range.containsRange", "method_implementation": "{\n    if (otherRange == null) {\n        return false;\n    }\n    return contains(otherRange.minimum) && contains(otherRange.maximum);\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range contains all the elements of the specified range.\n *\n * <p>This method may fail if the ranges have two different comparators or element types.</p>\n *\n * @param otherRange  the range to check, null returns false\n * @return true if this range contains the specified range\n * @throws RuntimeException if ranges cannot be compared\n */\n", "repo_name": "commons-lang-master/", "id": 819, "method_signature": "boolean containsRange(Range)", "filename": "Range.containsRange.json"}
{"callee_method_names": [], "method_name": "Range.elementCompareTo", "method_implementation": "{\n    // Comparable API says throw NPE on null\n    Objects.requireNonNull(element, \"element\");\n    if (isAfter(element)) {\n        return -1;\n    }\n    if (isBefore(element)) {\n        return 1;\n    }\n    return 0;\n}", "repo_id": "8", "comment": "/**\n * Checks where the specified element occurs relative to this range.\n *\n * <p>The API is reminiscent of the Comparable interface returning {@code -1} if\n * the element is before the range, {@code 0} if contained within the range and\n * {@code 1} if the element is after the range.</p>\n *\n * @param element  the element to check for, not null\n * @return -1, 0 or +1 depending on the element's location relative to the range\n * @throws NullPointerException if {@code element} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 820, "method_signature": "int elementCompareTo(T)", "filename": "Range.elementCompareTo.json"}
{"callee_method_names": ["Object.getClass", "T.equals", "T.equals"], "method_name": "Range.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj == null || obj.getClass() != getClass()) {\n        return false;\n    }\n    // OK because we checked the class above\n    @SuppressWarnings(\"unchecked\")\n    final Range<T> range = (Range<T>) obj;\n    return minimum.equals(range.minimum) && maximum.equals(range.maximum);\n}", "repo_id": "8", "comment": "/**\n * Compares this range to another object to test if they are equal..\n *\n * <p>To be equal, the minimum and maximum values must be equal, which\n * ignores any differences in the comparator.</p>\n *\n * @param obj the reference object with which to compare\n * @return true if this object is equal\n */\n", "repo_name": "commons-lang-master/", "id": 821, "method_signature": "boolean equals(Object)", "filename": "Range.equals.json"}
{"callee_method_names": [], "method_name": "Range.fit", "method_implementation": "{\n    // Comparable API says throw NPE on null\n    Objects.requireNonNull(element, \"element\");\n    if (isAfter(element)) {\n        return minimum;\n    }\n    if (isBefore(element)) {\n        return maximum;\n    }\n    return element;\n}", "repo_id": "8", "comment": "/**\n * Fits the given element into this range by returning the given element or, if out of bounds, the range minimum if\n * below, or the range maximum if above.\n *\n * <pre>\n * Range&lt;Integer&gt; range = Range.between(16, 64);\n * range.fit(-9) --&gt;  16\n * range.fit(0)  --&gt;  16\n * range.fit(15) --&gt;  16\n * range.fit(16) --&gt;  16\n * range.fit(17) --&gt;  17\n * ...\n * range.fit(63) --&gt;  63\n * range.fit(64) --&gt;  64\n * range.fit(99) --&gt;  64\n * </pre>\n * @param element the element to check for, not null\n * @return the minimum, the element, or the maximum depending on the element's location relative to the range\n * @throws NullPointerException if {@code element} is {@code null}\n * @since 3.10\n */\n", "repo_name": "commons-lang-master/", "id": 822, "method_signature": "T fit(T)", "filename": "Range.fit.json"}
{"callee_method_names": ["T.hashCode", "T.hashCode"], "method_name": "Range.hashCode", "method_implementation": "{\n    int result = hashCode;\n    if (hashCode == 0) {\n        result = 17;\n        result = 37 * result + getClass().hashCode();\n        result = 37 * result + minimum.hashCode();\n        result = 37 * result + maximum.hashCode();\n        hashCode = result;\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Gets a suitable hash code for the range.\n *\n * @return a hash code value for this object\n */\n", "repo_name": "commons-lang-master/", "id": 823, "method_signature": "int hashCode()", "filename": "Range.hashCode.json"}
{"callee_method_names": [], "method_name": "Range.intersectionWith", "method_implementation": "{\n    if (!this.isOverlappedBy(other)) {\n        throw new IllegalArgumentException(String.format(\"Cannot calculate intersection with non-overlapping range %s\", other));\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n    final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;\n    return of(min, max, getComparator());\n}", "repo_id": "8", "comment": "/**\n * Calculate the intersection of {@code this} and an overlapping Range.\n * @param other overlapping Range\n * @return range representing the intersection of {@code this} and {@code other} ({@code this} if equal)\n * @throws IllegalArgumentException if {@code other} does not overlap {@code this}\n * @since 3.0.1\n */\n", "repo_name": "commons-lang-master/", "id": 824, "method_signature": "Range<T> intersectionWith(Range)", "filename": "Range.intersectionWith.json"}
{"callee_method_names": ["Comparator<T>.compare"], "method_name": "Range.isAfter", "method_implementation": "{\n    if (element == null) {\n        return false;\n    }\n    return comparator.compare(element, minimum) < 0;\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range is after the specified element.\n *\n * @param element  the element to check for, null returns false\n * @return true if this range is entirely after the specified element\n */\n", "repo_name": "commons-lang-master/", "id": 825, "method_signature": "boolean isAfter(T)", "filename": "Range.isAfter.json"}
{"callee_method_names": [], "method_name": "Range.isAfterRange", "method_implementation": "{\n    if (otherRange == null) {\n        return false;\n    }\n    return isAfter(otherRange.maximum);\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range is completely after the specified range.\n *\n * <p>This method may fail if the ranges have two different comparators or element types.</p>\n *\n * @param otherRange  the range to check, null returns false\n * @return true if this range is completely after the specified range\n * @throws RuntimeException if ranges cannot be compared\n */\n", "repo_name": "commons-lang-master/", "id": 826, "method_signature": "boolean isAfterRange(Range)", "filename": "Range.isAfterRange.json"}
{"callee_method_names": ["Comparator<T>.compare"], "method_name": "Range.isBefore", "method_implementation": "{\n    if (element == null) {\n        return false;\n    }\n    return comparator.compare(element, maximum) > 0;\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range is before the specified element.\n *\n * @param element  the element to check for, null returns false\n * @return true if this range is entirely before the specified element\n */\n", "repo_name": "commons-lang-master/", "id": 827, "method_signature": "boolean isBefore(T)", "filename": "Range.isBefore.json"}
{"callee_method_names": [], "method_name": "Range.isBeforeRange", "method_implementation": "{\n    if (otherRange == null) {\n        return false;\n    }\n    return isBefore(otherRange.minimum);\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range is completely before the specified range.\n *\n * <p>This method may fail if the ranges have two different comparators or element types.</p>\n *\n * @param otherRange  the range to check, null returns false\n * @return true if this range is completely before the specified range\n * @throws RuntimeException if ranges cannot be compared\n */\n", "repo_name": "commons-lang-master/", "id": 828, "method_signature": "boolean isBeforeRange(Range)", "filename": "Range.isBeforeRange.json"}
{"callee_method_names": ["Comparator<T>.compare"], "method_name": "Range.isEndedBy", "method_implementation": "{\n    if (element == null) {\n        return false;\n    }\n    return comparator.compare(element, maximum) == 0;\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range ends with the specified element.\n *\n * @param element  the element to check for, null returns false\n * @return true if the specified element occurs within this range\n */\n", "repo_name": "commons-lang-master/", "id": 829, "method_signature": "boolean isEndedBy(T)", "filename": "Range.isEndedBy.json"}
{"callee_method_names": ["Range<T>.contains", "Range<T>.contains"], "method_name": "Range.isOverlappedBy", "method_implementation": "{\n    if (otherRange == null) {\n        return false;\n    }\n    return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum);\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range is overlapped by the specified range.\n *\n * <p>Two ranges overlap if there is at least one element in common.</p>\n *\n * <p>This method may fail if the ranges have two different comparators or element types.</p>\n *\n * @param otherRange  the range to test, null returns false\n * @return true if the specified range overlaps with this\n *  range; otherwise, {@code false}\n * @throws RuntimeException if ranges cannot be compared\n */\n", "repo_name": "commons-lang-master/", "id": 830, "method_signature": "boolean isOverlappedBy(Range)", "filename": "Range.isOverlappedBy.json"}
{"callee_method_names": ["Comparator<T>.compare"], "method_name": "Range.isStartedBy", "method_implementation": "{\n    if (element == null) {\n        return false;\n    }\n    return comparator.compare(element, minimum) == 0;\n}", "repo_id": "8", "comment": "/**\n * Checks whether this range starts with the specified element.\n *\n * @param element  the element to check for, null returns false\n * @return true if the specified element occurs within this range\n */\n", "repo_name": "commons-lang-master/", "id": 831, "method_signature": "boolean isStartedBy(T)", "filename": "Range.isStartedBy.json"}
{"callee_method_names": [], "method_name": "Range.toString", "method_implementation": "{\n    if (toString == null) {\n        toString = \"[\" + minimum + \"..\" + maximum + \"]\";\n    }\n    return toString;\n}", "repo_id": "8", "comment": "/**\n * Gets the range as a {@link String}.\n *\n * <p>The format of the String is '[<i>min</i>..<i>max</i>]'.</p>\n *\n * @return the {@link String} representation of this range\n */\n", "repo_name": "commons-lang-master/", "id": 832, "method_signature": "String toString()", "filename": "Range.toString.json"}
{"callee_method_names": [], "method_name": "Reflection.getUnchecked", "method_implementation": "{\n    try {\n        return Objects.requireNonNull(field, \"field\").get(obj);\n    } catch (IllegalAccessException e) {\n        throw new IllegalArgumentException(e);\n    }\n}", "repo_id": "8", "comment": "/**\n * Delegates to {@link Field#get(Object)} and rethrows {@link IllegalAccessException} as {@link IllegalArgumentException}.\n *\n * @param field The receiver of the get call.\n * @param obj   The argument of the get call.\n * @return The result of the get call.\n * @throws IllegalArgumentException Thrown after catching {@link IllegalAccessException}.\n */\n", "repo_name": "commons-lang-master/", "id": 901, "method_signature": "Object getUnchecked(Field, Object)", "filename": "Reflection.getUnchecked.json"}
{"callee_method_names": [], "method_name": "ReflectionDiffBuilder.setExcludeFieldNames", "method_implementation": "{\n    this.excludeFieldNames = toExcludeFieldNames(excludeFieldNames);\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the field names to exclude.\n *\n * @param excludeFieldNames The field names to exclude from the diff or {@code null}.\n * @return {@code this}\n * @since 3.13.0\n * @deprecated Use {@link Builder#setExcludeFieldNames(String[])}.\n */\n", "repo_name": "commons-lang-master/", "id": 836, "method_signature": "ReflectionDiffBuilder<T> setExcludeFieldNames(String[])", "filename": "ReflectionDiffBuilder.setExcludeFieldNames.json"}
{"callee_method_names": ["Field.getName", "Field.getModifiers", "Field.getModifiers", "Field.getName", "Field.getName", "Field.isAnnotationPresent"], "method_name": "ReflectionToStringBuilder.accept", "method_implementation": "{\n    if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n        // Reject field from inner class.\n        return false;\n    }\n    if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n        // Reject transient fields.\n        return false;\n    }\n    if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n        // Reject static fields.\n        return false;\n    }\n    if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n        // Reject fields from the getExcludeFieldNames list.\n        return false;\n    }\n    if (ArrayUtils.isNotEmpty(includeFieldNames)) {\n        // Accept fields from the getIncludeFieldNames list. {@code null} or empty means all fields are included. All fields are included by default.\n        return Arrays.binarySearch(this.includeFieldNames, field.getName()) >= 0;\n    }\n    return !field.isAnnotationPresent(ToStringExclude.class);\n}", "repo_id": "8", "comment": "/**\n * Returns whether or not to append the given {@link Field}.\n * <ul>\n * <li>Transient fields are appended only if {@link #isAppendTransients()} returns {@code true}.\n * <li>Static fields are appended only if {@link #isAppendStatics()} returns {@code true}.\n * <li>Inner class fields are not appended.</li>\n * </ul>\n *\n * @param field\n *            The Field to test.\n * @return Whether or not to append the given {@link Field}.\n */\n", "repo_name": "commons-lang-master/", "id": 894, "method_signature": "boolean accept(Field)", "filename": "ReflectionToStringBuilder.accept.json"}
{"callee_method_names": ["Class<?>.isArray", "Class<?>.getDeclaredFields", "Field.getName", "Field.isAnnotationPresent"], "method_name": "ReflectionToStringBuilder.appendFieldsIn", "method_implementation": "{\n    if (clazz.isArray()) {\n        this.reflectionAppendArray(this.getObject());\n        return;\n    }\n    // The elements in the returned array are not sorted and are not in any particular order.\n    final Field[] fields = ArraySorter.sort(clazz.getDeclaredFields(), Comparator.comparing(Field::getName));\n    AccessibleObject.setAccessible(fields, true);\n    for (final Field field : fields) {\n        final String fieldName = field.getName();\n        if (this.accept(field)) {\n            try {\n                // Warning: Field.get(Object) creates wrappers objects\n                // for primitive types.\n                final Object fieldValue = this.getValue(field);\n                if (!excludeNullValues || fieldValue != null) {\n                    this.append(fieldName, fieldValue, !field.isAnnotationPresent(ToStringSummary.class));\n                }\n            } catch (final IllegalAccessException e) {\n                // this can't happen. Would get a Security exception instead throw a runtime exception in case the\n                // impossible happens.\n                throw new IllegalStateException(e);\n            }\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends the fields and values defined by the given object of the given Class.\n *\n * <p>\n * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n * {@code Object.toString()} had been called and not implemented by the object.\n * </p>\n *\n * @param clazz\n *            The class of object parameter\n */\n", "repo_name": "commons-lang-master/", "id": 895, "method_signature": "void appendFieldsIn(Class)", "filename": "ReflectionToStringBuilder.appendFieldsIn.json"}
{"callee_method_names": [], "method_name": "ReflectionToStringBuilder.setExcludeFieldNames", "method_implementation": "{\n    if (excludeFieldNamesParam == null) {\n        this.excludeFieldNames = null;\n    } else {\n        // clone and remove nulls\n        this.excludeFieldNames = ArraySorter.sort(toNoNullStringArray(excludeFieldNamesParam));\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the field names to exclude.\n *\n * @param excludeFieldNamesParam\n *            The excludeFieldNames to excluding from toString or {@code null}.\n * @return {@code this}\n */\n", "repo_name": "commons-lang-master/", "id": 896, "method_signature": "ReflectionToStringBuilder setExcludeFieldNames(String[])", "filename": "ReflectionToStringBuilder.setExcludeFieldNames.json"}
{"callee_method_names": [], "method_name": "ReflectionToStringBuilder.setIncludeFieldNames", "method_implementation": "{\n    if (includeFieldNamesParam == null) {\n        this.includeFieldNames = null;\n    } else {\n        // clone and remove nulls\n        this.includeFieldNames = ArraySorter.sort(toNoNullStringArray(includeFieldNamesParam));\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the field names to include. {@code null} or empty means all fields are included. All fields are included by default. This method will override the default behavior.\n *\n * @param includeFieldNamesParam\n *            The includeFieldNames that must be on toString or {@code null}.\n * @return {@code this}\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 897, "method_signature": "ReflectionToStringBuilder setIncludeFieldNames(String[])", "filename": "ReflectionToStringBuilder.setIncludeFieldNames.json"}
{"callee_method_names": ["Class<?>.isInstance"], "method_name": "ReflectionToStringBuilder.setUpToClass", "method_implementation": "{\n    if (clazz != null) {\n        final Object object = getObject();\n        if (object != null && !clazz.isInstance(object)) {\n            throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n        }\n    }\n    this.upToClass = clazz;\n}", "repo_id": "8", "comment": "/**\n * Sets the last super class to stop appending fields for.\n *\n * @param clazz\n *            The last super class to stop appending fields for.\n */\n", "repo_name": "commons-lang-master/", "id": 898, "method_signature": "void setUpToClass(Class)", "filename": "ReflectionToStringBuilder.setUpToClass.json"}
{"callee_method_names": ["Collection<String>.toArray"], "method_name": "ReflectionToStringBuilder.toNoNullStringArray", "method_implementation": "{\n    if (collection == null) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    return toNoNullStringArray(collection.toArray());\n}", "repo_id": "8", "comment": "/**\n * Converts the given Collection into an array of Strings. The returned array does not contain {@code null}\n * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\n * is {@code null}.\n *\n * @param collection\n *            The collection to convert\n * @return A new array of Strings.\n */\n", "repo_name": "commons-lang-master/", "id": 891, "method_signature": "String[] toNoNullStringArray(Collection)", "filename": "ReflectionToStringBuilder.toNoNullStringArray.json"}
{"callee_method_names": ["Class<?>.getSuperclass", "Class<?>.getSuperclass"], "method_name": "ReflectionToStringBuilder.toString", "method_implementation": "{\n    if (this.getObject() == null) {\n        return this.getStyle().getNullText();\n    }\n    validate();\n    Class<?> clazz = this.getObject().getClass();\n    this.appendFieldsIn(clazz);\n    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n        clazz = clazz.getSuperclass();\n        this.appendFieldsIn(clazz);\n    }\n    return super.toString();\n}", "repo_id": "8", "comment": "/**\n * Gets the String built by this builder.\n *\n * @return the built string\n */\n", "repo_name": "commons-lang-master/", "id": 899, "method_signature": "String toString()", "filename": "ReflectionToStringBuilder.toString.json"}
{"callee_method_names": [], "method_name": "ReflectionToStringBuilder.validate", "method_implementation": "{\n    if (ArrayUtils.containsAny(this.excludeFieldNames, (Object[]) this.includeFieldNames)) {\n        ToStringStyle.unregister(this.getObject());\n        throw new IllegalStateException(\"includeFieldNames and excludeFieldNames must not intersect\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Validates that include and exclude names do not intersect.\n */\n", "repo_name": "commons-lang-master/", "id": 900, "method_signature": "void validate()", "filename": "ReflectionToStringBuilder.validate.json"}
{"callee_method_names": ["String.replaceAll"], "method_name": "RegExUtils.replaceAll", "method_implementation": "{\n    if (ObjectUtils.anyNull(text, regex, replacement)) {\n        return text;\n    }\n    return text.replaceAll(regex, replacement);\n}", "repo_id": "8", "comment": "/**\n * Replaces each substring of the text String that matches the given regular expression\n * with the given replacement.\n *\n * This method is a {@code null} safe equivalent to:\n * <ul>\n *  <li>{@code text.replaceAll(regex, replacement)}</li>\n *  <li>{@code Pattern.compile(regex).matcher(text).replaceAll(replacement)}</li>\n * </ul>\n *\n * <p>A {@code null} reference passed to this method is a no-op.</p>\n *\n * <p>Unlike in the {@link #replacePattern(String, String, String)} method, the {@link Pattern#DOTALL} option\n * is NOT automatically added.\n * To use the DOTALL option prepend {@code \"(?s)\"} to the regex.\n * DOTALL is also known as single-line mode in Perl.</p>\n *\n * <pre>\n * StringUtils.replaceAll(null, *, *)       = null\n * StringUtils.replaceAll(\"any\", (String) null, *)   = \"any\"\n * StringUtils.replaceAll(\"any\", *, null)   = \"any\"\n * StringUtils.replaceAll(\"\", \"\", \"zzz\")    = \"zzz\"\n * StringUtils.replaceAll(\"\", \".*\", \"zzz\")  = \"zzz\"\n * StringUtils.replaceAll(\"\", \".+\", \"zzz\")  = \"\"\n * StringUtils.replaceAll(\"abc\", \"\", \"ZZ\")  = \"ZZaZZbZZcZZ\"\n * StringUtils.replaceAll(\"&lt;__&gt;\\n&lt;__&gt;\", \"&lt;.*&gt;\", \"z\")      = \"z\\nz\"\n * StringUtils.replaceAll(\"&lt;__&gt;\\n&lt;__&gt;\", \"(?s)&lt;.*&gt;\", \"z\")  = \"z\"\n * StringUtils.replaceAll(\"ABCabc123\", \"[a-z]\", \"_\")       = \"ABC___123\"\n * StringUtils.replaceAll(\"ABCabc123\", \"[^A-Z0-9]+\", \"_\")  = \"ABC_123\"\n * StringUtils.replaceAll(\"ABCabc123\", \"[^A-Z0-9]+\", \"\")   = \"ABC123\"\n * StringUtils.replaceAll(\"Lorem ipsum  dolor   sit\", \"( +)([a-z]+)\", \"_$2\")  = \"Lorem_ipsum_dolor_sit\"\n * </pre>\n *\n * @param text  text to search and replace in, may be null\n * @param regex  the regular expression to which this string is to be matched\n * @param replacement  the string to be substituted for each match\n * @return  the text with any replacements processed,\n *              {@code null} if null String input\n *\n * @throws  java.util.regex.PatternSyntaxException\n *              if the regular expression's syntax is invalid\n *\n * @see #replacePattern(String, String, String)\n * @see String#replaceAll(String, String)\n * @see java.util.regex.Pattern\n * @see java.util.regex.Pattern#DOTALL\n */\n", "repo_name": "commons-lang-master/", "id": 1, "method_signature": "String replaceAll(String, String, String)", "filename": "RegExUtils.replaceAll.json"}
{"callee_method_names": ["String.replaceFirst"], "method_name": "RegExUtils.replaceFirst", "method_implementation": "{\n    if (text == null || regex == null || replacement == null) {\n        return text;\n    }\n    return text.replaceFirst(regex, replacement);\n}", "repo_id": "8", "comment": "/**\n * Replaces the first substring of the text string that matches the given regular expression\n * with the given replacement.\n *\n * This method is a {@code null} safe equivalent to:\n * <ul>\n *  <li>{@code text.replaceFirst(regex, replacement)}</li>\n *  <li>{@code Pattern.compile(regex).matcher(text).replaceFirst(replacement)}</li>\n * </ul>\n *\n * <p>A {@code null} reference passed to this method is a no-op.</p>\n *\n * <p>The {@link Pattern#DOTALL} option is NOT automatically added.\n * To use the DOTALL option prepend {@code \"(?s)\"} to the regex.\n * DOTALL is also known as single-line mode in Perl.</p>\n *\n * <pre>\n * StringUtils.replaceFirst(null, *, *)       = null\n * StringUtils.replaceFirst(\"any\", (String) null, *)   = \"any\"\n * StringUtils.replaceFirst(\"any\", *, null)   = \"any\"\n * StringUtils.replaceFirst(\"\", \"\", \"zzz\")    = \"zzz\"\n * StringUtils.replaceFirst(\"\", \".*\", \"zzz\")  = \"zzz\"\n * StringUtils.replaceFirst(\"\", \".+\", \"zzz\")  = \"\"\n * StringUtils.replaceFirst(\"abc\", \"\", \"ZZ\")  = \"ZZabc\"\n * StringUtils.replaceFirst(\"&lt;__&gt;\\n&lt;__&gt;\", \"&lt;.*&gt;\", \"z\")      = \"z\\n&lt;__&gt;\"\n * StringUtils.replaceFirst(\"&lt;__&gt;\\n&lt;__&gt;\", \"(?s)&lt;.*&gt;\", \"z\")  = \"z\"\n * StringUtils.replaceFirst(\"ABCabc123\", \"[a-z]\", \"_\")          = \"ABC_bc123\"\n * StringUtils.replaceFirst(\"ABCabc123abc\", \"[^A-Z0-9]+\", \"_\")  = \"ABC_123abc\"\n * StringUtils.replaceFirst(\"ABCabc123abc\", \"[^A-Z0-9]+\", \"\")   = \"ABC123abc\"\n * StringUtils.replaceFirst(\"Lorem ipsum  dolor   sit\", \"( +)([a-z]+)\", \"_$2\")  = \"Lorem_ipsum  dolor   sit\"\n * </pre>\n *\n * @param text  text to search and replace in, may be null\n * @param regex  the regular expression to which this string is to be matched\n * @param replacement  the string to be substituted for the first match\n * @return  the text with the first replacement processed,\n *              {@code null} if null String input\n *\n * @throws  java.util.regex.PatternSyntaxException\n *              if the regular expression's syntax is invalid\n *\n * @see String#replaceFirst(String, String)\n * @see java.util.regex.Pattern\n * @see java.util.regex.Pattern#DOTALL\n */\n", "repo_name": "commons-lang-master/", "id": 3, "method_signature": "String replaceFirst(String, String, String)", "filename": "RegExUtils.replaceFirst.json"}
{"callee_method_names": [], "method_name": "RegExUtils.replacePattern", "method_implementation": "{\n    if (ObjectUtils.anyNull(text, regex, replacement)) {\n        return text;\n    }\n    return dotAllMatcher(regex, text).replaceAll(replacement);\n}", "repo_id": "8", "comment": "/**\n * Replaces each substring of the source String that matches the given regular expression with the given\n * replacement using the {@link Pattern#DOTALL} option. DOTALL is also known as single-line mode in Perl.\n *\n * This call is a {@code null} safe equivalent to:\n * <ul>\n * <li>{@code text.replaceAll(&quot;(?s)&quot; + regex, replacement)}</li>\n * <li>{@code Pattern.compile(regex, Pattern.DOTALL).matcher(text).replaceAll(replacement)}</li>\n * </ul>\n *\n * <p>A {@code null} reference passed to this method is a no-op.</p>\n *\n * <pre>\n * StringUtils.replacePattern(null, *, *)       = null\n * StringUtils.replacePattern(\"any\", (String) null, *)   = \"any\"\n * StringUtils.replacePattern(\"any\", *, null)   = \"any\"\n * StringUtils.replacePattern(\"\", \"\", \"zzz\")    = \"zzz\"\n * StringUtils.replacePattern(\"\", \".*\", \"zzz\")  = \"zzz\"\n * StringUtils.replacePattern(\"\", \".+\", \"zzz\")  = \"\"\n * StringUtils.replacePattern(\"&lt;__&gt;\\n&lt;__&gt;\", \"&lt;.*&gt;\", \"z\")       = \"z\"\n * StringUtils.replacePattern(\"ABCabc123\", \"[a-z]\", \"_\")       = \"ABC___123\"\n * StringUtils.replacePattern(\"ABCabc123\", \"[^A-Z0-9]+\", \"_\")  = \"ABC_123\"\n * StringUtils.replacePattern(\"ABCabc123\", \"[^A-Z0-9]+\", \"\")   = \"ABC123\"\n * StringUtils.replacePattern(\"Lorem ipsum  dolor   sit\", \"( +)([a-z]+)\", \"_$2\")  = \"Lorem_ipsum_dolor_sit\"\n * </pre>\n *\n * @param text\n *            the source string\n * @param regex\n *            the regular expression to which this string is to be matched\n * @param replacement\n *            the string to be substituted for each match\n * @return The resulting {@link String}\n * @see #replaceAll(String, String, String)\n * @see String#replaceAll(String, String)\n * @see Pattern#DOTALL\n */\n", "repo_name": "commons-lang-master/", "id": 4, "method_signature": "String replacePattern(String, String, String)", "filename": "RegExUtils.replacePattern.json"}
{"callee_method_ids": [126], "callee_method_names": ["TimedSemaphore.acquire", "CountDownLatch.countDown"], "method_name": "SemaphoreThread.run", "method_implementation": "{\n    try {\n        for (int i = 0; i < count; i++) {\n            semaphore.acquire();\n            if (i < latchCount) {\n                latch.countDown();\n            }\n        }\n    } catch (final InterruptedException iex) {\n        Thread.currentThread().interrupt();\n    }\n}", "repo_id": "8", "comment": "/**\n * Calls acquire() on the semaphore for the specified number of times.\n * Optionally the latch will also be triggered to synchronize with the\n * main test thread.\n */\n", "repo_name": "commons-lang-master/", "id": 1486, "method_signature": "void run()", "filename": "SemaphoreThread.run.json"}
{"callee_method_names": ["Class<T>.getClassLoader", "Class<T>.cast", "ExecutionException.getClass"], "method_name": "SerializationUtils.clone", "method_implementation": "{\n    if (object == null) {\n        return null;\n    }\n    final byte[] objectData = serialize(object);\n    final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    final Class<T> cls = ObjectUtils.getClass(object);\n    try (ClassLoaderAwareObjectInputStream in = new ClassLoaderAwareObjectInputStream(bais, cls.getClassLoader())) {\n        /*\n             * when we serialize and deserialize an object, it is reasonable to assume the deserialized object is of the\n             * same type as the original serialized object\n             */\n        return cls.cast(in.readObject());\n    } catch (final ClassNotFoundException | IOException ex) {\n        throw new SerializationException(String.format(\"%s while reading cloned object data\", ex.getClass().getSimpleName()), ex);\n    }\n}", "repo_id": "8", "comment": "/**\n * Deep clone an {@link Object} using serialization.\n *\n * <p>This is many times slower than writing clone methods by hand\n * on all objects in your object graph. However, for complex object\n * graphs, or for those that don't support deep cloning this can\n * be a simple alternative implementation. Of course all the objects\n * must be {@link Serializable}.</p>\n *\n * @param <T> the type of the object involved\n * @param object  the {@link Serializable} object to clone\n * @return the cloned object\n * @throws SerializationException (runtime) if the serialization fails\n */\n", "repo_name": "commons-lang-master/", "id": 532, "method_signature": "T clone(T)", "filename": "SerializationUtils.clone.json"}
{"callee_method_names": [], "method_name": "SerializationUtils.deserialize", "method_implementation": "{\n    Objects.requireNonNull(inputStream, \"inputStream\");\n    try (ObjectInputStream in = new ObjectInputStream(inputStream)) {\n        @SuppressWarnings(\"unchecked\")\n        final T obj = (T) in.readObject();\n        return obj;\n    } catch (final ClassNotFoundException | IOException | NegativeArraySizeException ex) {\n        throw new SerializationException(ex);\n    }\n}", "repo_id": "8", "comment": "/**\n * Deserializes an {@link Object} from the specified stream.\n *\n * <p>\n * The stream will be closed once the object is written. This avoids the need for a finally clause, and maybe also\n * exception handling, in the application code.\n * </p>\n *\n * <p>\n * The stream passed in is not buffered internally within this method. This is the responsibility of your\n * application if desired.\n * </p>\n *\n * <p>\n * If the call site incorrectly types the return value, a {@link ClassCastException} is thrown from the call site.\n * Without Generics in this declaration, the call site must type cast and can cause the same ClassCastException.\n * Note that in both cases, the ClassCastException is in the call site, not in this method.\n * </p>\n *\n * @param <T>  the object type to be deserialized\n * @param inputStream\n *            the serialized object input stream, must not be null\n * @return the deserialized object\n * @throws NullPointerException if {@code inputStream} is {@code null}\n * @throws SerializationException (runtime) if the serialization fails\n */\n", "repo_name": "commons-lang-master/", "id": 533, "method_signature": "T deserialize(InputStream)", "filename": "SerializationUtils.deserialize.json"}
{"callee_method_names": ["ObjectStreamClass.getName", "HashMap.get"], "method_name": "SerializationUtils.resolveClass", "method_implementation": "{\n    final String name = desc.getName();\n    try {\n        return Class.forName(name, false, classLoader);\n    } catch (final ClassNotFoundException ex) {\n        try {\n            return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n        } catch (final ClassNotFoundException cnfe) {\n            final Class<?> cls = primitiveTypes.get(name);\n            if (cls != null) {\n                return cls;\n            }\n            throw cnfe;\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Overridden version that uses the parameterized {@link ClassLoader} or the {@link ClassLoader}\n * of the current {@link Thread} to resolve the class.\n * @param desc An instance of class {@link ObjectStreamClass}.\n * @return A {@link Class} object corresponding to {@code desc}.\n * @throws IOException Any of the usual Input/Output exceptions.\n * @throws ClassNotFoundException If class of a serialized object cannot be found.\n */\n", "repo_name": "commons-lang-master/", "id": 531, "method_signature": "Class<?> resolveClass(ObjectStreamClass)", "filename": "SerializationUtils.resolveClass.json"}
{"callee_method_names": ["Writer.writeObject"], "method_name": "SerializationUtils.serialize", "method_implementation": "{\n    Objects.requireNonNull(outputStream, \"outputStream\");\n    try (ObjectOutputStream out = new ObjectOutputStream(outputStream)) {\n        out.writeObject(obj);\n    } catch (final IOException ex) {\n        throw new SerializationException(ex);\n    }\n}", "repo_id": "8", "comment": "/**\n * Serializes an {@link Object} to the specified stream.\n *\n * <p>The stream will be closed once the object is written.\n * This avoids the need for a finally clause, and maybe also exception\n * handling, in the application code.</p>\n *\n * <p>The stream passed in is not buffered internally within this method.\n * This is the responsibility of your application if desired.</p>\n *\n * @param obj  the object to serialize to bytes, may be null\n * @param outputStream  the stream to write to, must not be null\n * @throws NullPointerException if {@code outputStream} is {@code null}\n * @throws SerializationException (runtime) if the serialization fails\n */\n", "repo_name": "commons-lang-master/", "id": 535, "method_signature": "void serialize(Serializable, OutputStream)", "filename": "SerializationUtils.serialize.json"}
{"callee_method_names": ["CheckIntervalData.getEventCount", "EventCountCircuitBreaker.getOpeningThreshold"], "method_name": "StateStrategyClosed.isStateTransition", "method_implementation": "{\n    return nextData.getEventCount() > breaker.getOpeningThreshold();\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 142, "method_signature": "boolean isStateTransition(EventCountCircuitBreaker, CheckIntervalData, CheckIntervalData)", "filename": "StateStrategyClosed.isStateTransition.json"}
{"callee_method_names": ["CheckIntervalData.getCheckIntervalStart", "CheckIntervalData.getCheckIntervalStart", "CheckIntervalData.getEventCount", "EventCountCircuitBreaker.getClosingThreshold"], "method_name": "StateStrategyOpen.isStateTransition", "method_implementation": "{\n    return nextData.getCheckIntervalStart() != currentData.getCheckIntervalStart() && currentData.getEventCount() < breaker.getClosingThreshold();\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 143, "method_signature": "boolean isStateTransition(EventCountCircuitBreaker, CheckIntervalData, CheckIntervalData)", "filename": "StateStrategyOpen.isStateTransition.json"}
{"callee_method_ids": [636], "callee_method_names": ["StopWatch.start"], "method_name": "StopWatch.createStarted", "method_implementation": "{\n    final StopWatch sw = new StopWatch();\n    sw.start();\n    return sw;\n}", "repo_id": "8", "comment": "/**\n * Creates and starts a StopWatch.\n *\n * @return StopWatch a started StopWatch.\n *\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 629, "method_signature": "StopWatch createStarted()", "filename": "StopWatch.createStarted.json"}
{"callee_method_names": [], "method_name": "StopWatch.getNanoTime", "method_implementation": "{\n    if (this.runningState == State.STOPPED || this.runningState == State.SUSPENDED) {\n        return this.stopTimeNanos - this.startTimeNanos;\n    }\n    if (this.runningState == State.UNSTARTED) {\n        return 0;\n    }\n    if (this.runningState == State.RUNNING) {\n        return System.nanoTime() - this.startTimeNanos;\n    }\n    throw new IllegalStateException(\"Illegal running state has occurred.\");\n}", "repo_id": "8", "comment": "/**\n * Gets the <em>elapsed</em> time in nanoseconds.\n *\n * <p>\n * This is either the time between the start and the moment this method is called, or the amount of time between start and stop.\n * </p>\n *\n * @return the <em>elapsed</em> time in nanoseconds.\n * @see System#nanoTime()\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 630, "method_signature": "long getNanoTime()", "filename": "StopWatch.getNanoTime.json"}
{"callee_method_names": [], "method_name": "StopWatch.getSplitNanoTime", "method_implementation": "{\n    if (this.splitState != SplitState.SPLIT) {\n        throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n    }\n    return this.stopTimeNanos - this.startTimeNanos;\n}", "repo_id": "8", "comment": "/**\n * Gets the split time in nanoseconds.\n *\n * <p>\n * This is the time between start and latest split.\n * </p>\n *\n * @return the split time in nanoseconds\n *\n * @throws IllegalStateException if the StopWatch has not yet been split.\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 631, "method_signature": "long getSplitNanoTime()", "filename": "StopWatch.getSplitNanoTime.json"}
{"callee_method_names": [], "method_name": "StopWatch.getStartTime", "method_implementation": "{\n    if (this.runningState == State.UNSTARTED) {\n        throw new IllegalStateException(\"Stopwatch has not been started\");\n    }\n    // stopTimeNanos stores System.nanoTime() for elapsed time\n    return this.startTimeMillis;\n}", "repo_id": "8", "comment": "/**\n * Gets the time this StopWatch was started in milliseconds, between the current time and midnight, January 1, 1970 UTC.\n *\n * @return the time this StopWatch was started in milliseconds, between the current time and midnight, January 1, 1970 UTC.\n * @throws IllegalStateException if this StopWatch has not been started\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 632, "method_signature": "long getStartTime()", "filename": "StopWatch.getStartTime.json"}
{"callee_method_names": [], "method_name": "StopWatch.getStopTime", "method_implementation": "{\n    if (this.runningState == State.UNSTARTED) {\n        throw new IllegalStateException(\"Stopwatch has not been started\");\n    }\n    // stopTimeNanos stores System.nanoTime() for elapsed time\n    return this.stopTimeMillis;\n}", "repo_id": "8", "comment": "/**\n * Gets the time this StopWatch was stopped in milliseconds, between the current time and midnight, January 1, 1970 UTC.\n *\n * @return the time this StopWatch was started in milliseconds, between the current time and midnight, January 1, 1970 UTC.\n * @throws IllegalStateException if this StopWatch has not been started\n * @since 3.12.0\n */\n", "repo_name": "commons-lang-master/", "id": 633, "method_signature": "long getStopTime()", "filename": "StopWatch.getStopTime.json"}
{"callee_method_names": [], "method_name": "StopWatch.resume", "method_implementation": "{\n    if (this.runningState != State.SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n    }\n    this.startTimeNanos += System.nanoTime() - this.stopTimeNanos;\n    this.runningState = State.RUNNING;\n}", "repo_id": "8", "comment": "/**\n * Resumes the StopWatch after a suspend.\n *\n * <p>\n * This method resumes the watch after it was suspended. The watch will not include time between the suspend and resume calls in the total time.\n * </p>\n *\n * @throws IllegalStateException if the StopWatch has not been suspended.\n */\n", "repo_name": "commons-lang-master/", "id": 634, "method_signature": "void resume()", "filename": "StopWatch.resume.json"}
{"callee_method_names": [], "method_name": "StopWatch.split", "method_implementation": "{\n    if (this.runningState != State.RUNNING) {\n        throw new IllegalStateException(\"Stopwatch is not running. \");\n    }\n    this.stopTimeNanos = System.nanoTime();\n    this.splitState = SplitState.SPLIT;\n}", "repo_id": "8", "comment": "/**\n * Splits the time.\n *\n * <p>\n * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected, enabling {@link #unsplit()} to continue the\n * timing from the original start point.\n * </p>\n *\n * @throws IllegalStateException if the StopWatch is not running.\n */\n", "repo_name": "commons-lang-master/", "id": 635, "method_signature": "void split()", "filename": "StopWatch.split.json"}
{"callee_method_names": [], "method_name": "StopWatch.start", "method_implementation": "{\n    if (this.runningState == State.STOPPED) {\n        throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n    }\n    if (this.runningState != State.UNSTARTED) {\n        throw new IllegalStateException(\"Stopwatch already started. \");\n    }\n    this.startTimeNanos = System.nanoTime();\n    this.startTimeMillis = System.currentTimeMillis();\n    this.runningState = State.RUNNING;\n}", "repo_id": "8", "comment": "/**\n * Starts the StopWatch.\n *\n * <p>\n * This method starts a new timing session, clearing any previous values.\n * </p>\n *\n * @throws IllegalStateException if the StopWatch is already running.\n */\n", "repo_name": "commons-lang-master/", "id": 636, "method_signature": "void start()", "filename": "StopWatch.start.json"}
{"callee_method_names": [], "method_name": "StopWatch.stop", "method_implementation": "{\n    if (this.runningState != State.RUNNING && this.runningState != State.SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch is not running. \");\n    }\n    if (this.runningState == State.RUNNING) {\n        this.stopTimeNanos = System.nanoTime();\n        this.stopTimeMillis = System.currentTimeMillis();\n    }\n    this.runningState = State.STOPPED;\n}", "repo_id": "8", "comment": "/**\n * Stops the StopWatch.\n *\n * <p>\n * This method ends a new timing session, allowing the time to be retrieved.\n * </p>\n *\n * @throws IllegalStateException if the StopWatch is not running.\n */\n", "repo_name": "commons-lang-master/", "id": 637, "method_signature": "void stop()", "filename": "StopWatch.stop.json"}
{"callee_method_names": [], "method_name": "StopWatch.suspend", "method_implementation": "{\n    if (this.runningState != State.RUNNING) {\n        throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n    }\n    this.stopTimeNanos = System.nanoTime();\n    this.stopTimeMillis = System.currentTimeMillis();\n    this.runningState = State.SUSPENDED;\n}", "repo_id": "8", "comment": "/**\n * Suspends the StopWatch for later resumption.\n *\n * <p>\n * This method suspends the watch until it is resumed. The watch will not include time between the suspend and resume calls in the total time.\n * </p>\n *\n * @throws IllegalStateException if the StopWatch is not currently running.\n */\n", "repo_name": "commons-lang-master/", "id": 638, "method_signature": "void suspend()", "filename": "StopWatch.suspend.json"}
{"callee_method_names": ["String.isEmpty"], "method_name": "StopWatch.toSplitString", "method_implementation": "{\n    final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n    final String formattedTime = formatSplitTime();\n    return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n}", "repo_id": "8", "comment": "/**\n * Gets a summary of the split time that the StopWatch recorded as a string.\n *\n * <p>\n * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n * </p>\n *\n * @return the split time as a String\n * @since 2.1\n * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n */\n", "repo_name": "commons-lang-master/", "id": 639, "method_signature": "String toSplitString()", "filename": "StopWatch.toSplitString.json"}
{"callee_method_names": ["String.isEmpty"], "method_name": "StopWatch.toString", "method_implementation": "{\n    final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n    final String formattedTime = formatTime();\n    return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n}", "repo_id": "8", "comment": "/**\n * Gets a summary of the time that the StopWatch recorded as a string.\n *\n * <p>\n * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n * </p>\n *\n * @return the time as a String\n * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n */\n", "repo_name": "commons-lang-master/", "id": 640, "method_signature": "String toString()", "filename": "StopWatch.toString.json"}
{"callee_method_names": [], "method_name": "StopWatch.unsplit", "method_implementation": "{\n    if (this.splitState != SplitState.SPLIT) {\n        throw new IllegalStateException(\"Stopwatch has not been split. \");\n    }\n    this.splitState = SplitState.UNSPLIT;\n}", "repo_id": "8", "comment": "/**\n * Removes a split.\n *\n * <p>\n * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to continue.\n * </p>\n *\n * @throws IllegalStateException if the StopWatch has not been split.\n */\n", "repo_name": "commons-lang-master/", "id": 641, "method_signature": "void unsplit()", "filename": "StopWatch.unsplit.json"}
{"callee_method_ids": [638], "callee_method_names": ["StopWatch.suspend"], "method_name": "StopWatchTest.createMockStopWatch", "method_implementation": "{\n    final StopWatch watch = StopWatch.createStarted();\n    watch.suspend();\n    try {\n        final long currentNanos = System.nanoTime();\n        FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n        FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n    } catch (final IllegalAccessException e) {\n        return null;\n    }\n    return watch;\n}", "repo_id": "8", "comment": "/**\n * <p>\n * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n * nanoseconds.\n * <p>\n * <p>\n *\n * <pre>\n * // Create a mock StopWatch with a time of 2:59:01.999\n * final long nanos = TimeUnit.HOURS.toNanos(2)\n *         + TimeUnit.MINUTES.toNanos(59)\n *         + TimeUnit.SECONDS.toNanos(1)\n *         + TimeUnit.MILLISECONDS.toNanos(999);\n * final StopWatch watch = createMockStopWatch(nanos);\n * </pre>\n *\n * @param nanos Time in nanoseconds to have elapsed on the stop watch\n * @return StopWatch in a suspended state with the elapsed time\n */\n", "repo_name": "commons-lang-master/", "id": 1829, "method_signature": "StopWatch createMockStopWatch(long)", "filename": "StopWatchTest.createMockStopWatch.json"}
{"callee_method_ids": [636, 637], "callee_method_names": ["StopWatch.start", "StopWatch.stop"], "method_name": "StopWatchTest.testBadStates", "method_implementation": "{\n    final StopWatch watch = new StopWatch();\n    assertThrows(IllegalStateException.class, watch::stop, \"Calling stop on an unstarted StopWatch should throw an exception. \");\n    assertThrows(IllegalStateException.class, watch::suspend, \"Calling suspend on an unstarted StopWatch should throw an exception. \");\n    assertThrows(IllegalStateException.class, watch::split, \"Calling split on a non-running StopWatch should throw an exception. \");\n    assertThrows(IllegalStateException.class, watch::unsplit, \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n    assertThrows(IllegalStateException.class, watch::resume, \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n    watch.start();\n    assertThrows(IllegalStateException.class, watch::start, \"Calling start on a started StopWatch should throw an exception. \");\n    assertThrows(IllegalStateException.class, watch::unsplit, \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n    assertThrows(IllegalStateException.class, watch::getSplitTime, \"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n    assertThrows(IllegalStateException.class, watch::resume, \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n    watch.stop();\n    assertThrows(IllegalStateException.class, watch::start, \"Calling start on a stopped StopWatch should throw an exception as it needs to be reset. \");\n}", "repo_id": "8", "comment": "// test bad states\n", "repo_name": "commons-lang-master/", "id": 1830, "method_signature": "void testBadStates()", "filename": "StopWatchTest.testBadStates.json"}
{"callee_method_names": ["StringBuilder.length", "StringBuilder.length", "StringBuilder.getChars"], "method_name": "StrBuilder.append", "method_implementation": "{\n    if (str == null) {\n        return appendNull();\n    }\n    if (startIndex < 0 || startIndex > str.length()) {\n        throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n    }\n    if (length < 0 || startIndex + length > str.length()) {\n        throw new StringIndexOutOfBoundsException(\"length must be valid\");\n    }\n    if (length > 0) {\n        final int len = length();\n        ensureCapacity(len + length);\n        str.getChars(startIndex, startIndex + length, buffer, len);\n        size += length;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends part of a StringBuilder to this string builder.\n * Appending null will call {@link #appendNull()}.\n *\n * @param str the StringBuilder to append\n * @param startIndex the start index, inclusive, must be valid\n * @param length the length to append, must be valid\n * @return this, to enable chaining\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 459, "method_signature": "StrBuilder append(StringBuilder, int, int)", "filename": "StrBuilder.append.json"}
{"callee_method_names": [], "method_name": "StrBuilder.appendAll", "method_implementation": "{\n    /*\n         * @SuppressWarnings used to hide warning about vararg usage. We cannot\n         * use @SafeVarargs, since this method is not final. Using @SuppressWarnings\n         * is fine, because it isn't inherited by subclasses, so each subclass must\n         * vouch for itself whether its use of 'array' is safe.\n         */\n    if (ArrayUtils.isNotEmpty(array)) {\n        for (final Object element : array) {\n            append(element);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends each item in an array to the builder without any separators.\n * Appending a null array will have no effect.\n * Each object is appended using {@link #append(Object)}.\n *\n * @param <T>  the element type\n * @param array  the array to append\n * @return this, to enable chaining\n * @since 2.3\n */\n", "repo_name": "commons-lang-master/", "id": 462, "method_signature": "StrBuilder appendAll(T[])", "filename": "StrBuilder.appendAll.json"}
{"callee_method_names": ["String.length", "String.getChars", "String.getChars"], "method_name": "StrBuilder.appendFixedWidthPadLeft", "method_implementation": "{\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = ObjectUtils.toString(obj, this::getNullText);\n        if (str == null) {\n            str = StringUtils.EMPTY;\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends an object to the builder padding on the left to a fixed width.\n * The {@code toString} of the object is used.\n * If the object is larger than the length, the left-hand side side is lost.\n * If the object is null, the null text value is used.\n *\n * @param obj  the object to append, null uses null text\n * @param width  the fixed field width, zero or negative has no effect\n * @param padChar  the pad character to use\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 463, "method_signature": "StrBuilder appendFixedWidthPadLeft(Object, int, char)", "filename": "StrBuilder.appendFixedWidthPadLeft.json"}
{"callee_method_names": ["String.length", "String.getChars", "String.getChars"], "method_name": "StrBuilder.appendFixedWidthPadRight", "method_implementation": "{\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = ObjectUtils.toString(obj, this::getNullText);\n        if (str == null) {\n            str = StringUtils.EMPTY;\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends an object to the builder padding on the right to a fixed length.\n * The {@code toString} of the object is used.\n * If the object is larger than the length, the right-hand side side is lost.\n * If the object is null, null text value is used.\n *\n * @param obj  the object to append, null uses null text\n * @param width  the fixed field width, zero or negative has no effect\n * @param padChar  the pad character to use\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 464, "method_signature": "StrBuilder appendFixedWidthPadRight(Object, int, char)", "filename": "StrBuilder.appendFixedWidthPadRight.json"}
{"callee_method_names": [], "method_name": "StrBuilder.appendNewLine", "method_implementation": "{\n    if (newLine == null) {\n        append(System.lineSeparator());\n        return this;\n    }\n    return append(newLine);\n}", "repo_id": "8", "comment": "/**\n * Appends the new line string to this string builder.\n * <p>\n * The new line string can be altered using {@link #setNewLineText(String)}.\n * This might be used to force the output to always use Unix line endings\n * even when on Windows.\n * </p>\n *\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 465, "method_signature": "StrBuilder appendNewLine()", "filename": "StrBuilder.appendNewLine.json"}
{"callee_method_names": [], "method_name": "StrBuilder.appendNull", "method_implementation": "{\n    if (nullText == null) {\n        return this;\n    }\n    return append(nullText);\n}", "repo_id": "8", "comment": "/**\n * Appends the text representing {@code null} to this string builder.\n *\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 466, "method_signature": "StrBuilder appendNull()", "filename": "StrBuilder.appendNull.json"}
{"callee_method_names": [], "method_name": "StrBuilder.appendPadding", "method_implementation": "{\n    if (length >= 0) {\n        ensureCapacity(size + length);\n        for (int i = 0; i < length; i++) {\n            buffer[size++] = padChar;\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends the pad character to the builder the specified number of times.\n *\n * @param length  the length to append, negative means no append\n * @param padChar  the character to append\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 467, "method_signature": "StrBuilder appendPadding(int, char)", "filename": "StrBuilder.appendPadding.json"}
{"callee_method_names": [], "method_name": "StrBuilder.appendSeparator", "method_implementation": "{\n    final String str = isEmpty() ? defaultIfEmpty : standard;\n    if (str != null) {\n        append(str);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends one of both separators to the StrBuilder.\n * If the builder is currently empty it will append the defaultIfEmpty-separator\n * Otherwise it will append the standard-separator\n *\n * Appending a null separator will have no effect.\n * The separator is appended using {@link #append(String)}.\n * <p>\n * This method is for example useful for constructing queries\n * </p>\n * <pre>\n * StrBuilder whereClause = new StrBuilder();\n * if (searchCommand.getPriority() != null) {\n *  whereClause.appendSeparator(\" and\", \" where\");\n *  whereClause.append(\" priority = ?\")\n * }\n * if (searchCommand.getComponent() != null) {\n *  whereClause.appendSeparator(\" and\", \" where\");\n *  whereClause.append(\" component = ?\")\n * }\n * selectClause.append(whereClause)\n * </pre>\n *\n * @param standard the separator if builder is not empty, null means no separator\n * @param defaultIfEmpty the separator if builder is empty, null means no separator\n * @return this, to enable chaining\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 472, "method_signature": "StrBuilder appendSeparator(String, String)", "filename": "StrBuilder.appendSeparator.json"}
{"callee_method_names": ["Appendable.append"], "method_name": "StrBuilder.appendTo", "method_implementation": "{\n    if (appendable instanceof Writer) {\n        ((Writer) appendable).write(buffer, 0, size);\n    } else if (appendable instanceof StringBuilder) {\n        ((StringBuilder) appendable).append(buffer, 0, size);\n    } else if (appendable instanceof StringBuffer) {\n        ((StringBuffer) appendable).append(buffer, 0, size);\n    } else if (appendable instanceof CharBuffer) {\n        ((CharBuffer) appendable).put(buffer, 0, size);\n    } else {\n        appendable.append(this);\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends current contents of this {@link StrBuilder} to the\n * provided {@link Appendable}.\n * <p>\n * This method tries to avoid doing any extra copies of contents.\n * </p>\n *\n * @param appendable  the appendable to append data to\n * @throws IOException  if an I/O error occurs\n *\n * @since 3.4\n * @see #readFrom(Readable)\n */\n", "repo_name": "commons-lang-master/", "id": 473, "method_signature": "void appendTo(Appendable)", "filename": "StrBuilder.appendTo.json"}
{"callee_method_names": [], "method_name": "StrBuilder.appendWithSeparators", "method_implementation": "{\n    if (array != null && array.length > 0) {\n        final String sep = Objects.toString(separator, \"\");\n        append(array[0]);\n        for (int i = 1; i < array.length; i++) {\n            append(sep);\n            append(array[i]);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Appends an array placing separators between each value, but\n * not before the first or after the last.\n * Appending a null array will have no effect.\n * Each object is appended using {@link #append(Object)}.\n *\n * @param array  the array to append\n * @param separator  the separator to use, null means no separator\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 476, "method_signature": "StrBuilder appendWithSeparators(Object[], String)", "filename": "StrBuilder.appendWithSeparators.json"}
{"callee_method_names": [], "method_name": "StrBuilder.charAt", "method_implementation": "{\n    if (index < 0 || index >= length()) {\n        throw new StringIndexOutOfBoundsException(index);\n    }\n    return buffer[index];\n}", "repo_id": "8", "comment": "/**\n * Gets the character at the specified index.\n *\n * @see #setCharAt(int, char)\n * @see #deleteCharAt(int)\n * @param index  the index to retrieve, must be valid\n * @return the character at the index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 477, "method_signature": "char charAt(int)", "filename": "StrBuilder.charAt.json"}
{"callee_method_names": [], "method_name": "StrBuilder.contains", "method_implementation": "{\n    final char[] thisBuf = buffer;\n    for (int i = 0; i < this.size; i++) {\n        if (thisBuf[i] == ch) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Checks if the string builder contains the specified char.\n *\n * @param ch  the character to find\n * @return true if the builder contains the character\n */\n", "repo_name": "commons-lang-master/", "id": 478, "method_signature": "boolean contains(char)", "filename": "StrBuilder.contains.json"}
{"callee_method_names": [], "method_name": "StrBuilder.delete", "method_implementation": "{\n    endIndex = validateRange(startIndex, endIndex);\n    final int len = endIndex - startIndex;\n    if (len > 0) {\n        deleteImpl(startIndex, endIndex, len);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Deletes the characters between the two specified indices.\n *\n * @param startIndex  the start index, inclusive, must be valid\n * @param endIndex  the end index, exclusive, must be valid except\n *  that if too large it is treated as end of string\n * @return this, to enable chaining\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 479, "method_signature": "StrBuilder delete(int, int)", "filename": "StrBuilder.delete.json"}
{"callee_method_names": [], "method_name": "StrBuilder.deleteAll", "method_implementation": "{\n    final int len = StringUtils.length(str);\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Deletes the string wherever it occurs in the builder.\n *\n * @param str  the string to delete, null causes no action\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 481, "method_signature": "StrBuilder deleteAll(String)", "filename": "StrBuilder.deleteAll.json"}
{"callee_method_names": [], "method_name": "StrBuilder.deleteCharAt", "method_implementation": "{\n    if (index < 0 || index >= size) {\n        throw new StringIndexOutOfBoundsException(index);\n    }\n    deleteImpl(index, index + 1, 1);\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Deletes the character at the specified index.\n *\n * @see #charAt(int)\n * @see #setCharAt(int, char)\n * @param index  the index to delete\n * @return this, to enable chaining\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 482, "method_signature": "StrBuilder deleteCharAt(int)", "filename": "StrBuilder.deleteCharAt.json"}
{"callee_method_names": [], "method_name": "StrBuilder.deleteFirst", "method_implementation": "{\n    final int len = StringUtils.length(str);\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Deletes the string wherever it occurs in the builder.\n *\n * @param str  the string to delete, null causes no action\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 484, "method_signature": "StrBuilder deleteFirst(String)", "filename": "StrBuilder.deleteFirst.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "StrBuilder.endsWith", "method_implementation": "{\n    if (str == null) {\n        return false;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return true;\n    }\n    if (len > size) {\n        return false;\n    }\n    int pos = size - len;\n    for (int i = 0; i < len; i++, pos++) {\n        if (buffer[pos] != str.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks whether this builder ends with the specified string.\n * <p>\n * Note that this method handles null input quietly, unlike String.\n * </p>\n *\n * @param str  the string to search for, null returns false\n * @return true if the builder ends with the string\n */\n", "repo_name": "commons-lang-master/", "id": 485, "method_signature": "boolean endsWith(String)", "filename": "StrBuilder.endsWith.json"}
{"callee_method_names": [], "method_name": "StrBuilder.ensureCapacity", "method_implementation": "{\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Checks the capacity and ensures that it is at least the size specified.\n *\n * @param capacity  the capacity to ensure\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 486, "method_signature": "StrBuilder ensureCapacity(int)", "filename": "StrBuilder.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "StrBuilder.equals", "method_implementation": "{\n    if (this == other) {\n        return true;\n    }\n    if (other == null) {\n        return false;\n    }\n    if (this.size != other.size) {\n        return false;\n    }\n    final char[] thisBuf = this.buffer;\n    final char[] otherBuf = other.buffer;\n    for (int i = size - 1; i >= 0; i--) {\n        if (thisBuf[i] != otherBuf[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks the contents of this builder against another to see if they\n * contain the same character content.\n *\n * @param other  the object to check, null returns false\n * @return true if the builders contain the same characters in the same order\n */\n", "repo_name": "commons-lang-master/", "id": 487, "method_signature": "boolean equals(StrBuilder)", "filename": "StrBuilder.equals.json"}
{"callee_method_names": [], "method_name": "StrBuilder.equalsIgnoreCase", "method_implementation": "{\n    if (this == other) {\n        return true;\n    }\n    if (this.size != other.size) {\n        return false;\n    }\n    final char[] thisBuf = this.buffer;\n    final char[] otherBuf = other.buffer;\n    for (int i = size - 1; i >= 0; i--) {\n        final char c1 = thisBuf[i];\n        final char c2 = otherBuf[i];\n        if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks the contents of this builder against another to see if they\n * contain the same character content ignoring case.\n *\n * @param other  the object to check, null returns false\n * @return true if the builders contain the same characters in the same order\n */\n", "repo_name": "commons-lang-master/", "id": 488, "method_signature": "boolean equalsIgnoreCase(StrBuilder)", "filename": "StrBuilder.equalsIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StrBuilder.getChars", "method_implementation": "{\n    if (startIndex < 0) {\n        throw new StringIndexOutOfBoundsException(startIndex);\n    }\n    if (endIndex < 0 || endIndex > length()) {\n        throw new StringIndexOutOfBoundsException(endIndex);\n    }\n    if (startIndex > endIndex) {\n        throw new StringIndexOutOfBoundsException(\"end < start\");\n    }\n    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n}", "repo_id": "8", "comment": "/**\n * Copies the character array into the specified array.\n *\n * @param startIndex  first index to copy, inclusive, must be valid\n * @param endIndex  last index, exclusive, must be valid\n * @param destination  the destination array, must not be null or too small\n * @param destinationIndex  the index to start copying in destination\n * @throws NullPointerException if the array is null\n * @throws IndexOutOfBoundsException if any index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 490, "method_signature": "void getChars(int, int, char[], int)", "filename": "StrBuilder.getChars.json"}
{"callee_method_names": [], "method_name": "StrBuilder.getContent", "method_implementation": "{\n    final String str = super.getContent();\n    if (str == null) {\n        return StrBuilder.this.toString();\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 441, "method_signature": "String getContent()", "filename": "StrBuilder.getContent.json"}
{"callee_method_names": [], "method_name": "StrBuilder.hashCode", "method_implementation": "{\n    final char[] buf = buffer;\n    int hash = 0;\n    for (int i = size - 1; i >= 0; i--) {\n        hash = 31 * hash + buf[i];\n    }\n    return hash;\n}", "repo_id": "8", "comment": "/**\n * Gets a suitable hash code for this builder.\n *\n * @return a hash code\n */\n", "repo_name": "commons-lang-master/", "id": 491, "method_signature": "int hashCode()", "filename": "StrBuilder.hashCode.json"}
{"callee_method_ids": [378], "callee_method_names": ["StrMatcher.isMatch"], "method_name": "StrBuilder.indexOf", "method_implementation": "{\n    startIndex = Math.max(startIndex, 0);\n    if (matcher == null || startIndex >= size) {\n        return -1;\n    }\n    final int len = size;\n    final char[] buf = buffer;\n    for (int i = startIndex; i < len; i++) {\n        if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "8", "comment": "/**\n * Searches the string builder using the matcher to find the first\n * match searching from the given index.\n * <p>\n * Matchers can be used to perform advanced searching behavior.\n * For example you could write a matcher to find the character 'a'\n * followed by a number.\n * </p>\n *\n * @param matcher  the matcher to use, null returns -1\n * @param startIndex  the index to start at, invalid index rounded to edge\n * @return the first index matched, or -1 if not found\n */\n", "repo_name": "commons-lang-master/", "id": 493, "method_signature": "int indexOf(StrMatcher, int)", "filename": "StrBuilder.indexOf.json"}
{"callee_method_names": ["String.length", "String.getChars"], "method_name": "StrBuilder.insert", "method_implementation": "{\n    validateIndex(index);\n    if (str == null) {\n        str = nullText;\n    }\n    if (str != null) {\n        final int strLen = str.length();\n        if (strLen > 0) {\n            final int newSize = size + strLen;\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n            size = newSize;\n            str.getChars(0, strLen, buffer, index);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Inserts the string into this builder.\n * Inserting null will use the stored null text value.\n *\n * @param index  the index to add at, must be valid\n * @param str  the string to insert\n * @return this, to enable chaining\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 499, "method_signature": "StrBuilder insert(int, String)", "filename": "StrBuilder.insert.json"}
{"callee_method_ids": [378], "callee_method_names": ["StrMatcher.isMatch"], "method_name": "StrBuilder.lastIndexOf", "method_implementation": "{\n    startIndex = startIndex >= size ? size - 1 : startIndex;\n    if (matcher == null || startIndex < 0) {\n        return -1;\n    }\n    final char[] buf = buffer;\n    final int endIndex = startIndex + 1;\n    for (int i = startIndex; i >= 0; i--) {\n        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "8", "comment": "/**\n * Searches the string builder using the matcher to find the last\n * match searching from the given index.\n * <p>\n * Matchers can be used to perform advanced searching behavior.\n * For example you could write a matcher to find the character 'a'\n * followed by a number.\n * </p>\n *\n * @param matcher  the matcher to use, null returns -1\n * @param startIndex  the index to start at, invalid index rounded to edge\n * @return the last index matched, or -1 if not found\n */\n", "repo_name": "commons-lang-master/", "id": 501, "method_signature": "int lastIndexOf(StrMatcher, int)", "filename": "StrBuilder.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "StrBuilder.leftString", "method_implementation": "{\n    if (length <= 0) {\n        return StringUtils.EMPTY;\n    }\n    if (length >= size) {\n        return new String(buffer, 0, size);\n    }\n    return new String(buffer, 0, length);\n}", "repo_id": "8", "comment": "/**\n * Extracts the leftmost characters from the string builder without\n * throwing an exception.\n * <p>\n * This method extracts the left {@code length} characters from\n * the builder. If this many characters are not available, the whole\n * builder is returned. Thus the returned string may be shorter than the\n * length requested.\n * </p>\n *\n * @param length  the number of characters to extract, negative returns empty string\n * @return the new string\n */\n", "repo_name": "commons-lang-master/", "id": 502, "method_signature": "String leftString(int)", "filename": "StrBuilder.leftString.json"}
{"callee_method_names": [], "method_name": "StrBuilder.midString", "method_implementation": "{\n    if (index < 0) {\n        index = 0;\n    }\n    if (length <= 0 || index >= size) {\n        return StringUtils.EMPTY;\n    }\n    if (size <= index + length) {\n        return new String(buffer, index, size - index);\n    }\n    return new String(buffer, index, length);\n}", "repo_id": "8", "comment": "/**\n * Extracts some characters from the middle of the string builder without\n * throwing an exception.\n * <p>\n * This method extracts {@code length} characters from the builder\n * at the specified index.\n * If the index is negative it is treated as zero.\n * If the index is greater than the builder size, it is treated as the builder size.\n * If the length is negative, the empty string is returned.\n * If insufficient characters are available in the builder, as much as possible is returned.\n * Thus the returned string may be shorter than the length requested.\n * </p>\n *\n * @param index  the index to start at, negative means zero\n * @param length  the number of characters to extract, negative returns empty string\n * @return the new string\n */\n", "repo_name": "commons-lang-master/", "id": 503, "method_signature": "String midString(int, int)", "filename": "StrBuilder.midString.json"}
{"callee_method_names": [], "method_name": "StrBuilder.minimizeCapacity", "method_implementation": "{\n    if (buffer.length > length()) {\n        final char[] old = buffer;\n        buffer = new char[length()];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Minimizes the capacity to the actual length of the string.\n *\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 504, "method_signature": "StrBuilder minimizeCapacity()", "filename": "StrBuilder.minimizeCapacity.json"}
{"callee_method_names": [], "method_name": "StrBuilder.read", "method_implementation": "{\n    if (off < 0 || len < 0 || off > b.length || off + len > b.length || off + len < 0) {\n        throw new IndexOutOfBoundsException();\n    }\n    if (len == 0) {\n        return 0;\n    }\n    if (pos >= StrBuilder.this.size()) {\n        return -1;\n    }\n    if (pos + len > size()) {\n        len = StrBuilder.this.size() - pos;\n    }\n    StrBuilder.this.getChars(pos, pos + len, b, off);\n    pos += len;\n    return len;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 439, "method_signature": "int read(char[], int, int)", "filename": "StrBuilder.read.json"}
{"callee_method_names": ["Reader.read", "CharBuffer.remaining", "CharBuffer.get", "Readable.read"], "method_name": "StrBuilder.readFrom", "method_implementation": "{\n    final int oldSize = size;\n    if (readable instanceof Reader) {\n        final Reader r = (Reader) readable;\n        ensureCapacity(size + 1);\n        int read;\n        while ((read = r.read(buffer, size, buffer.length - size)) != -1) {\n            size += read;\n            ensureCapacity(size + 1);\n        }\n    } else if (readable instanceof CharBuffer) {\n        final CharBuffer cb = (CharBuffer) readable;\n        final int remaining = cb.remaining();\n        ensureCapacity(size + remaining);\n        cb.get(buffer, size, remaining);\n        size += remaining;\n    } else {\n        while (true) {\n            ensureCapacity(size + 1);\n            final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n            final int read = readable.read(buf);\n            if (read == -1) {\n                break;\n            }\n            size += read;\n        }\n    }\n    return size - oldSize;\n}", "repo_id": "8", "comment": "/**\n * If possible, reads chars from the provided {@link Readable} directly into underlying\n * character buffer without making extra copies.\n *\n * @param readable  object to read from\n * @return the number of characters read\n * @throws IOException if an I/O error occurs.\n *\n * @since 3.4\n * @see #appendTo(Appendable)\n */\n", "repo_name": "commons-lang-master/", "id": 505, "method_signature": "int readFrom(Readable)", "filename": "StrBuilder.readFrom.json"}
{"callee_method_names": [], "method_name": "StrBuilder.replace", "method_implementation": "{\n    endIndex = validateRange(startIndex, endIndex);\n    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n}", "repo_id": "8", "comment": "/**\n * Advanced search and replaces within the builder using a matcher.\n * <p>\n * Matchers can be used to perform advanced behavior.\n * For example you could write a matcher to delete all occurrences\n * where the character 'a' is followed by a number.\n * </p>\n *\n * @param matcher  the matcher to use to find the deletion, null causes no action\n * @param replaceStr  the string to replace the match with, null is a delete\n * @param startIndex  the start index, inclusive, must be valid\n * @param endIndex  the end index, exclusive, must be valid except\n *  that if too large it is treated as end of string\n * @param replaceCount  the number of times to replace, -1 for replace all\n * @return this, to enable chaining\n * @throws IndexOutOfBoundsException if start index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 507, "method_signature": "StrBuilder replace(StrMatcher, String, int, int, int)", "filename": "StrBuilder.replace.json"}
{"callee_method_names": [], "method_name": "StrBuilder.replaceAll", "method_implementation": "{\n    final int searchLen = StringUtils.length(searchStr);\n    if (searchLen > 0) {\n        final int replaceLen = StringUtils.length(replaceStr);\n        int index = indexOf(searchStr, 0);\n        while (index >= 0) {\n            replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            index = indexOf(searchStr, index + replaceLen);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Replaces the search string with the replace string throughout the builder.\n *\n * @param searchStr  the search string, null causes no action to occur\n * @param replaceStr  the replace string, null is equivalent to an empty string\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 509, "method_signature": "StrBuilder replaceAll(String, String)", "filename": "StrBuilder.replaceAll.json"}
{"callee_method_names": [], "method_name": "StrBuilder.replaceFirst", "method_implementation": "{\n    final int searchLen = StringUtils.length(searchStr);\n    if (searchLen > 0) {\n        final int index = indexOf(searchStr, 0);\n        if (index >= 0) {\n            final int replaceLen = StringUtils.length(replaceStr);\n            replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Replaces the first instance of the search string with the replace string.\n *\n * @param searchStr  the search string, null causes no action to occur\n * @param replaceStr  the replace string, null is equivalent to an empty string\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 511, "method_signature": "StrBuilder replaceFirst(String, String)", "filename": "StrBuilder.replaceFirst.json"}
{"callee_method_ids": [378], "callee_method_names": ["StrMatcher.isMatch"], "method_name": "StrBuilder.replaceImpl", "method_implementation": "{\n    if (matcher == null || size == 0) {\n        return this;\n    }\n    final int replaceLen = StringUtils.length(replaceStr);\n    for (int i = from; i < to && replaceCount != 0; i++) {\n        final char[] buf = buffer;\n        final int removeLen = matcher.isMatch(buf, i, from, to);\n        if (removeLen > 0) {\n            replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n            to = to - removeLen + replaceLen;\n            i = i + replaceLen - 1;\n            if (replaceCount > 0) {\n                replaceCount--;\n            }\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Replaces within the builder using a matcher.\n * <p>\n * Matchers can be used to perform advanced behavior.\n * For example you could write a matcher to delete all occurrences\n * where the character 'a' is followed by a number.\n * </p>\n *\n * @param matcher  the matcher to use to find the deletion, null causes no action\n * @param replaceStr  the string to replace the match with, null is a delete\n * @param from  the start index, must be valid\n * @param to  the end index (exclusive), must be valid\n * @param replaceCount  the number of times to replace, -1 for replace all\n * @return this, to enable chaining\n * @throws IndexOutOfBoundsException if any index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 513, "method_signature": "StrBuilder replaceImpl(StrMatcher, String, int, int, int)", "filename": "StrBuilder.replaceImpl.json"}
{"callee_method_names": [], "method_name": "StrBuilder.reverse", "method_implementation": "{\n    if (size == 0) {\n        return this;\n    }\n    final int half = size / 2;\n    final char[] buf = buffer;\n    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {\n        final char swap = buf[leftIdx];\n        buf[leftIdx] = buf[rightIdx];\n        buf[rightIdx] = swap;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Reverses the string builder placing each character in the opposite index.\n *\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 514, "method_signature": "StrBuilder reverse()", "filename": "StrBuilder.reverse.json"}
{"callee_method_names": [], "method_name": "StrBuilder.rightString", "method_implementation": "{\n    if (length <= 0) {\n        return StringUtils.EMPTY;\n    }\n    if (length >= size) {\n        return new String(buffer, 0, size);\n    }\n    return new String(buffer, size - length, length);\n}", "repo_id": "8", "comment": "/**\n * Extracts the rightmost characters from the string builder without\n * throwing an exception.\n * <p>\n * This method extracts the right {@code length} characters from\n * the builder. If this many characters are not available, the whole\n * builder is returned. Thus the returned string may be shorter than the\n * length requested.\n * </p>\n *\n * @param length  the number of characters to extract, negative returns empty string\n * @return the new string\n */\n", "repo_name": "commons-lang-master/", "id": 515, "method_signature": "String rightString(int)", "filename": "StrBuilder.rightString.json"}
{"callee_method_names": [], "method_name": "StrBuilder.setCharAt", "method_implementation": "{\n    if (index < 0 || index >= length()) {\n        throw new StringIndexOutOfBoundsException(index);\n    }\n    buffer[index] = ch;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the character at the specified index.\n *\n * @see #charAt(int)\n * @see #deleteCharAt(int)\n * @param index  the index to set\n * @param ch  the new character\n * @return this, to enable chaining\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 516, "method_signature": "StrBuilder setCharAt(int, char)", "filename": "StrBuilder.setCharAt.json"}
{"callee_method_names": [], "method_name": "StrBuilder.setLength", "method_implementation": "{\n    if (length < 0) {\n        throw new StringIndexOutOfBoundsException(length);\n    }\n    if (length < size) {\n        size = length;\n    } else if (length > size) {\n        ensureCapacity(length);\n        final int oldEnd = size;\n        size = length;\n        for (int i = oldEnd; i < length; i++) {\n            buffer[i] = CharUtils.NUL;\n        }\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Updates the length of the builder by either dropping the last characters\n * or adding filler of Unicode zero.\n *\n * @param length  the length to set to, must be zero or positive\n * @return this, to enable chaining\n * @throws IndexOutOfBoundsException if the length is negative\n */\n", "repo_name": "commons-lang-master/", "id": 517, "method_signature": "StrBuilder setLength(int)", "filename": "StrBuilder.setLength.json"}
{"callee_method_names": [], "method_name": "StrBuilder.setNullText", "method_implementation": "{\n    if (StringUtils.isEmpty(nullText)) {\n        nullText = null;\n    }\n    this.nullText = nullText;\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the text to be appended when null is added.\n *\n * @param nullText  the null text, null means no append\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 518, "method_signature": "StrBuilder setNullText(String)", "filename": "StrBuilder.setNullText.json"}
{"callee_method_names": [], "method_name": "StrBuilder.skip", "method_implementation": "{\n    if (pos + n > StrBuilder.this.size()) {\n        n = StrBuilder.this.size() - pos;\n    }\n    if (n < 0) {\n        return 0;\n    }\n    pos = Math.addExact(pos, Math.toIntExact(n));\n    return n;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 440, "method_signature": "long skip(long)", "filename": "StrBuilder.skip.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "StrBuilder.startsWith", "method_implementation": "{\n    if (str == null) {\n        return false;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return true;\n    }\n    if (len > size) {\n        return false;\n    }\n    for (int i = 0; i < len; i++) {\n        if (buffer[i] != str.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks whether this builder starts with the specified string.\n * <p>\n * Note that this method handles null input quietly, unlike String.\n * </p>\n *\n * @param str  the string to search for, null returns false\n * @return true if the builder starts with the string\n */\n", "repo_name": "commons-lang-master/", "id": 519, "method_signature": "boolean startsWith(String)", "filename": "StrBuilder.startsWith.json"}
{"callee_method_names": [], "method_name": "StrBuilder.subSequence", "method_implementation": "{\n    if (startIndex < 0) {\n        throw new StringIndexOutOfBoundsException(startIndex);\n    }\n    if (endIndex > size) {\n        throw new StringIndexOutOfBoundsException(endIndex);\n    }\n    if (startIndex > endIndex) {\n        throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n    }\n    return substring(startIndex, endIndex);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 520, "method_signature": "CharSequence subSequence(int, int)", "filename": "StrBuilder.subSequence.json"}
{"callee_method_names": [], "method_name": "StrBuilder.toCharArray", "method_implementation": "{\n    endIndex = validateRange(startIndex, endIndex);\n    final int len = endIndex - startIndex;\n    if (len == 0) {\n        return ArrayUtils.EMPTY_CHAR_ARRAY;\n    }\n    final char[] chars = new char[len];\n    System.arraycopy(buffer, startIndex, chars, 0, len);\n    return chars;\n}", "repo_id": "8", "comment": "/**\n * Copies part of the builder's character array into a new character array.\n *\n * @param startIndex  the start index, inclusive, must be valid\n * @param endIndex  the end index, exclusive, must be valid except that\n *  if too large it is treated as end of string\n * @return a new array that holds part of the contents of the builder\n * @throws IndexOutOfBoundsException if startIndex is invalid,\n *  or if endIndex is invalid (but endIndex greater than size is valid)\n */\n", "repo_name": "commons-lang-master/", "id": 522, "method_signature": "char[] toCharArray(int, int)", "filename": "StrBuilder.toCharArray.json"}
{"callee_method_names": [], "method_name": "StrBuilder.tokenize", "method_implementation": "{\n    if (chars == null) {\n        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n    }\n    return super.tokenize(chars, offset, count);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 442, "method_signature": "List<String> tokenize(char[], int, int)", "filename": "StrBuilder.tokenize.json"}
{"callee_method_names": [], "method_name": "StrBuilder.trim", "method_implementation": "{\n    if (size == 0) {\n        return this;\n    }\n    int len = size;\n    final char[] buf = buffer;\n    int pos = 0;\n    while (pos < len && buf[pos] <= ' ') {\n        pos++;\n    }\n    while (pos < len && buf[len - 1] <= ' ') {\n        len--;\n    }\n    if (len < size) {\n        delete(len, size);\n    }\n    if (pos > 0) {\n        delete(0, pos);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Trims the builder by removing characters less than or equal to a space\n * from the beginning and end.\n *\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 523, "method_signature": "StrBuilder trim()", "filename": "StrBuilder.trim.json"}
{"callee_method_names": [], "method_name": "StrBuilder.validateIndex", "method_implementation": "{\n    if (index < 0 || index > size) {\n        throw new StringIndexOutOfBoundsException(index);\n    }\n}", "repo_id": "8", "comment": "/**\n * Validates parameters defining a single index in the builder.\n *\n * @param index  the index, must be valid\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 524, "method_signature": "void validateIndex(int)", "filename": "StrBuilder.validateIndex.json"}
{"callee_method_names": [], "method_name": "StrBuilder.validateRange", "method_implementation": "{\n    if (startIndex < 0) {\n        throw new StringIndexOutOfBoundsException(startIndex);\n    }\n    if (endIndex > size) {\n        endIndex = size;\n    }\n    if (startIndex > endIndex) {\n        throw new StringIndexOutOfBoundsException(\"end < start\");\n    }\n    return endIndex;\n}", "repo_id": "8", "comment": "/**\n * Validates parameters defining a range of the builder.\n *\n * @param startIndex  the start index, inclusive, must be valid\n * @param endIndex  the end index, exclusive, must be valid except\n *  that if too large it is treated as end of string\n * @return the new string\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "commons-lang-master/", "id": 525, "method_signature": "int validateRange(int, int)", "filename": "StrBuilder.validateRange.json"}
{"callee_method_ids": [464], "callee_method_names": ["StrBuilder.appendFixedWidthPadRight", "StrBuilder.toString"], "method_name": "StrBuilderAppendInsertTest.testLang299", "method_implementation": "{\n    final StrBuilder sb = new StrBuilder(1);\n    sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n    assertEquals(\"f\", sb.toString());\n}", "repo_id": "8", "comment": "// See: https://issues.apache.org/jira/browse/LANG-299\n", "repo_name": "commons-lang-master/", "id": 1748, "method_signature": "void testLang299()", "filename": "StrBuilderAppendInsertTest.testLang299.json"}
{"callee_method_names": [], "method_name": "StrBuilderReader.read", "method_implementation": "{\n    if (off < 0 || len < 0 || off > b.length || off + len > b.length || off + len < 0) {\n        throw new IndexOutOfBoundsException();\n    }\n    if (len == 0) {\n        return 0;\n    }\n    if (pos >= StrBuilder.this.size()) {\n        return -1;\n    }\n    if (pos + len > size()) {\n        len = StrBuilder.this.size() - pos;\n    }\n    StrBuilder.this.getChars(pos, pos + len, b, off);\n    pos += len;\n    return len;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 527, "method_signature": "int read(char[], int, int)", "filename": "StrBuilderReader.read.json"}
{"callee_method_names": [], "method_name": "StrBuilderReader.skip", "method_implementation": "{\n    if (pos + n > StrBuilder.this.size()) {\n        n = StrBuilder.this.size() - pos;\n    }\n    if (n < 0) {\n        return 0;\n    }\n    pos = Math.addExact(pos, Math.toIntExact(n));\n    return n;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 528, "method_signature": "long skip(long)", "filename": "StrBuilderReader.skip.json"}
{"callee_method_names": [], "method_name": "StrBuilderTokenizer.getContent", "method_implementation": "{\n    final String str = super.getContent();\n    if (str == null) {\n        return StrBuilder.this.toString();\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 529, "method_signature": "String getContent()", "filename": "StrBuilderTokenizer.getContent.json"}
{"callee_method_names": [], "method_name": "StrBuilderTokenizer.tokenize", "method_implementation": "{\n    if (chars == null) {\n        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n    }\n    return super.tokenize(chars, offset, count);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 530, "method_signature": "List<String> tokenize(char[], int, int)", "filename": "StrBuilderTokenizer.tokenize.json"}
{"callee_method_names": ["Map<String, V>.get"], "method_name": "StrLookup.lookup", "method_implementation": "{\n    if (map == null) {\n        return null;\n    }\n    return Objects.toString(map.get(key), null);\n}", "repo_id": "8", "comment": "/**\n * Looks up a String key to a String value using the map.\n * <p>\n * If the map is null, then null is returned.\n * The map result object is converted to a string using toString().\n * </p>\n *\n * @param key  the key to be looked up, may be null\n * @return the matching value, null if no match\n */\n", "repo_name": "commons-lang-master/", "id": 383, "method_signature": "String lookup(String)", "filename": "StrLookup.lookup.json"}
{"callee_method_names": ["Properties.getProperty", "Properties.setProperty", "StrLookup<String>.lookup"], "method_name": "StrLookupTest.testSystemPropertiesLookupReplacedProperties", "method_implementation": "{\n    final Properties oldProperties = System.getProperties();\n    final String osName = \"os.name\";\n    final String newOsName = oldProperties.getProperty(osName) + \"_changed\";\n    final StrLookup<String> sysLookup = StrLookup.systemPropertiesLookup();\n    final Properties newProps = new Properties();\n    newProps.setProperty(osName, newOsName);\n    System.setProperties(newProps);\n    try {\n        assertEquals(newOsName, sysLookup.lookup(osName), \"Changed properties not detected\");\n    } finally {\n        System.setProperties(oldProperties);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that a lookup object for system properties can deal with a full\n * replacement of the system properties object. This test is related to\n * LANG-1055.\n */\n", "repo_name": "commons-lang-master/", "id": 1749, "method_signature": "void testSystemPropertiesLookupReplacedProperties()", "filename": "StrLookupTest.testSystemPropertiesLookupReplacedProperties.json"}
{"callee_method_names": ["StrLookup<String>.lookup"], "method_name": "StrLookupTest.testSystemPropertiesLookupUpdatedProperty", "method_implementation": "{\n    final String osName = \"os.name\";\n    final String oldOs = System.getProperty(osName);\n    final String newOsName = oldOs + \"_changed\";\n    final StrLookup<String> sysLookup = StrLookup.systemPropertiesLookup();\n    System.setProperty(osName, newOsName);\n    try {\n        assertEquals(newOsName, sysLookup.lookup(osName), \"Changed properties not detected\");\n    } finally {\n        System.setProperty(osName, oldOs);\n    }\n}", "repo_id": "8", "comment": "/**\n * Tests that a lookup object for system properties sees changes on system\n * properties. This test is related to LANG-1141.\n */\n", "repo_name": "commons-lang-master/", "id": 1750, "method_signature": "void testSystemPropertiesLookupUpdatedProperty()", "filename": "StrLookupTest.testSystemPropertiesLookupUpdatedProperty.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.toCharArray"], "method_name": "StrMatcher.charSetMatcher", "method_implementation": "{\n    if (StringUtils.isEmpty(chars)) {\n        return NONE_MATCHER;\n    }\n    if (chars.length() == 1) {\n        return new CharMatcher(chars.charAt(0));\n    }\n    return new CharSetMatcher(chars.toCharArray());\n}", "repo_id": "8", "comment": "/**\n * Constructor that creates a matcher from a string representing a set of characters.\n *\n * @param chars  the characters to match, null or empty matches nothing\n * @return a new Matcher for the given characters\n */\n", "repo_name": "commons-lang-master/", "id": 380, "method_signature": "StrMatcher charSetMatcher(String)", "filename": "StrMatcher.charSetMatcher.json"}
{"callee_method_names": [], "method_name": "StrMatcher.isMatch", "method_implementation": "{\n    final int len = chars.length;\n    if (pos + len > bufferEnd) {\n        return 0;\n    }\n    for (int i = 0; i < chars.length; i++, pos++) {\n        if (chars[i] != buffer[pos]) {\n            return 0;\n        }\n    }\n    return len;\n}", "repo_id": "8", "comment": "/**\n * Returns whether or not the given text matches the stored string.\n *\n * @param buffer  the text content to match against, do not change\n * @param pos  the starting position for the match, valid for buffer\n * @param bufferStart  the first active index in the buffer, valid for buffer\n * @param bufferEnd  the end index of the active buffer, valid for buffer\n * @return the number of matching characters, zero for no match\n */\n", "repo_name": "commons-lang-master/", "id": 378, "method_signature": "int isMatch(char[], int, int, int)", "filename": "StrMatcher.isMatch.json"}
{"callee_method_names": [], "method_name": "StrMatcher.stringMatcher", "method_implementation": "{\n    if (StringUtils.isEmpty(str)) {\n        return NONE_MATCHER;\n    }\n    return new StringMatcher(str);\n}", "repo_id": "8", "comment": "/**\n * Constructor that creates a matcher from a string.\n *\n * @param str  the string to match, null or empty matches nothing\n * @return a new Matcher for the given String\n */\n", "repo_name": "commons-lang-master/", "id": 381, "method_signature": "StrMatcher stringMatcher(String)", "filename": "StrMatcher.stringMatcher.json"}
{"callee_method_ids": [459, 459, 459, 476], "callee_method_names": ["List<String>.contains", "StrBuilder.append", "StrBuilder.append", "List<String>.remove", "StrBuilder.append", "StrBuilder.appendWithSeparators", "StrBuilder.toString"], "method_name": "StrSubstitutor.checkCyclicSubstitution", "method_implementation": "{\n    if (!priorVariables.contains(varName)) {\n        return;\n    }\n    final StrBuilder buf = new StrBuilder(256);\n    buf.append(\"Infinite loop in property interpolation of \");\n    buf.append(priorVariables.remove(0));\n    buf.append(\": \");\n    buf.appendWithSeparators(priorVariables, \"->\");\n    throw new IllegalStateException(buf.toString());\n}", "repo_id": "8", "comment": "/**\n * Checks if the specified variable is already in the stack (list) of variables.\n *\n * @param varName  the variable name to check\n * @param priorVariables  the list of prior variables\n */\n", "repo_name": "commons-lang-master/", "id": 349, "method_signature": "void checkCyclicSubstitution(String, List)", "filename": "StrSubstitutor.checkCyclicSubstitution.json"}
{"callee_method_names": ["StrBuilder.toString"], "method_name": "StrSubstitutor.replace", "method_implementation": "{\n    if (source == null) {\n        return null;\n    }\n    final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n    substitute(buf, 0, length);\n    return buf.toString();\n}", "repo_id": "8", "comment": "/**\n * Replaces all the occurrences of variables with their matching values\n * from the resolver using the given source buffer as a template.\n * The buffer is not altered by this method.\n * <p>\n * Only the specified portion of the buffer will be processed.\n * The rest of the buffer is not processed, and is not returned.\n * </p>\n *\n * @param source  the buffer to use as a template, not changed, null returns null\n * @param offset  the start offset within the array, must be valid\n * @param length  the length within the array to be processed, must be valid\n * @return the result of the replace operation\n */\n", "repo_name": "commons-lang-master/", "id": 360, "method_signature": "String replace(StringBuffer, int, int)", "filename": "StrSubstitutor.replace.json"}
{"callee_method_names": ["StringBuilder.replace", "StrBuilder.toString"], "method_name": "StrSubstitutor.replaceIn", "method_implementation": "{\n    if (source == null) {\n        return false;\n    }\n    final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n    if (!substitute(buf, 0, length)) {\n        return false;\n    }\n    source.replace(offset, offset + length, buf.toString());\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Replaces all the occurrences of variables within the given source builder\n * with their matching values from the resolver.\n * The builder is updated with the result.\n * <p>\n * Only the specified portion of the buffer will be processed.\n * The rest of the buffer is not processed, but it is not deleted.\n * </p>\n *\n * @param source  the buffer to replace in, updated, null returns zero\n * @param offset  the start offset within the array, must be valid\n * @param length  the length within the buffer to be processed, must be valid\n * @return true if altered\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 366, "method_signature": "boolean replaceIn(StringBuilder, int, int)", "filename": "StrSubstitutor.replaceIn.json"}
{"callee_method_names": ["StrLookup<?>.lookup"], "method_name": "StrSubstitutor.resolveVariable", "method_implementation": "{\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.lookup(variableName);\n}", "repo_id": "8", "comment": "/**\n * Internal method that resolves the value of a variable.\n * <p>\n * Most users of this class do not need to call this method. This method is\n * called automatically by the substitution process.\n * </p>\n * <p>\n * Writers of subclasses can override this method if they need to alter\n * how each substitution occurs. The method is passed the variable's name\n * and must return the corresponding value. This implementation uses the\n * {@link #getVariableResolver()} with the variable's name as the key.\n * </p>\n *\n * @param variableName  the name of the variable, not null\n * @param buf  the buffer where the substitution is occurring, not null\n * @param startPos  the start position of the variable including the prefix, valid\n * @param endPos  the end position of the variable including the suffix, valid\n * @return the variable's value or <b>null</b> if the variable is unknown\n */\n", "repo_name": "commons-lang-master/", "id": 367, "method_signature": "String resolveVariable(String, StrBuilder, int, int)", "filename": "StrSubstitutor.resolveVariable.json"}
{"callee_method_names": [], "method_name": "StrSubstitutor.setValueDelimiter", "method_implementation": "{\n    if (StringUtils.isEmpty(valueDelimiter)) {\n        setValueDelimiterMatcher(null);\n        return this;\n    }\n    return setValueDelimiterMatcher(StrMatcher.stringMatcher(valueDelimiter));\n}", "repo_id": "8", "comment": "/**\n * Sets the variable default value delimiter to use.\n * <p>\n * The variable default value delimiter is the character or characters that delimit the\n * variable name and the variable default value. This method allows a string\n * variable default value delimiter to be easily set.\n * </p>\n * <p>\n * If the {@code valueDelimiter} is null or empty string, then the variable default\n * value resolution becomes disabled.\n * </p>\n *\n * @param valueDelimiter  the variable default value delimiter string to use, may be null or empty\n * @return this, to enable chaining\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 368, "method_signature": "StrSubstitutor setValueDelimiter(String)", "filename": "StrSubstitutor.setValueDelimiter.json"}
{"callee_method_ids": [378, 482, 378, 378, 378, 378, 507], "callee_method_names": ["StrMatcher.isMatch", "StrBuilder.deleteCharAt", "StrMatcher.isMatch", "StrMatcher.isMatch", "StrBuilder.length", "StrBuilder.toString", "String.toCharArray", "StrMatcher.isMatch", "StrMatcher.isMatch", "String.substring", "String.substring", "List<String>.add", "List<String>.add", "String.length", "StrBuilder.replace", "List<String>.remove", "List<String>.size"], "method_name": "StrSubstitutor.substitute", "method_implementation": "{\n    final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n    final StrMatcher suffMatcher = getVariableSuffixMatcher();\n    final char escape = getEscapeChar();\n    final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n    final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n    final boolean top = priorVariables == null;\n    boolean altered = false;\n    int lengthChange = 0;\n    char[] chars = buf.buffer;\n    int bufEnd = offset + length;\n    int pos = offset;\n    while (pos < bufEnd) {\n        final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen == 0) {\n            pos++;\n        } else // found variable start marker\n        if (pos > offset && chars[pos - 1] == escape) {\n            // escaped\n            if (preserveEscapes) {\n                pos++;\n                continue;\n            }\n            buf.deleteCharAt(pos - 1);\n            // in case buffer was altered\n            chars = buf.buffer;\n            lengthChange--;\n            altered = true;\n            bufEnd--;\n        } else {\n            // find suffix\n            final int startPos = pos;\n            pos += startMatchLen;\n            int endMatchLen;\n            int nestedVarCount = 0;\n            while (pos < bufEnd) {\n                if (substitutionInVariablesEnabled && (endMatchLen = pfxMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) {\n                    // found a nested variable start\n                    nestedVarCount++;\n                    pos += endMatchLen;\n                    continue;\n                }\n                endMatchLen = suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                if (endMatchLen == 0) {\n                    pos++;\n                } else {\n                    // found variable end marker\n                    if (nestedVarCount == 0) {\n                        String varNameExpr = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                        if (substitutionInVariablesEnabled) {\n                            final StrBuilder bufName = new StrBuilder(varNameExpr);\n                            substitute(bufName, 0, bufName.length());\n                            varNameExpr = bufName.toString();\n                        }\n                        pos += endMatchLen;\n                        final int endPos = pos;\n                        String varName = varNameExpr;\n                        String varDefaultValue = null;\n                        if (valueDelimMatcher != null) {\n                            final char[] varNameExprChars = varNameExpr.toCharArray();\n                            int valueDelimiterMatchLen;\n                            for (int i = 0; i < varNameExprChars.length; i++) {\n                                // if there's any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                if (!substitutionInVariablesEnabled && pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) != 0) {\n                                    break;\n                                }\n                                if ((valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i)) != 0) {\n                                    varName = varNameExpr.substring(0, i);\n                                    varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                    break;\n                                }\n                            }\n                        }\n                        // on the first call initialize priorVariables\n                        if (priorVariables == null) {\n                            priorVariables = new ArrayList<>();\n                            priorVariables.add(new String(chars, offset, length));\n                        }\n                        // handle cyclic substitution\n                        checkCyclicSubstitution(varName, priorVariables);\n                        priorVariables.add(varName);\n                        // resolve the variable\n                        String varValue = resolveVariable(varName, buf, startPos, endPos);\n                        if (varValue == null) {\n                            varValue = varDefaultValue;\n                        }\n                        if (varValue != null) {\n                            // recursive replace\n                            final int varLen = varValue.length();\n                            buf.replace(startPos, endPos, varValue);\n                            altered = true;\n                            int change = substitute(buf, startPos, varLen, priorVariables);\n                            change = change + varLen - (endPos - startPos);\n                            pos += change;\n                            bufEnd += change;\n                            lengthChange += change;\n                            // in case buffer was\n                            chars = buf.buffer;\n                            // altered\n                        }\n                        // remove variable from the cyclic stack\n                        priorVariables.remove(priorVariables.size() - 1);\n                        break;\n                    }\n                    nestedVarCount--;\n                    pos += endMatchLen;\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}", "repo_id": "8", "comment": "/**\n * Recursive handler for multiple levels of interpolation. This is the main\n * interpolation method, which resolves the values of all variable references\n * contained in the passed-in text.\n *\n * @param buf  the string builder to substitute into, not null\n * @param offset  the start offset within the builder, must be valid\n * @param length  the length within the builder to be processed, must be valid\n * @param priorVariables  the stack keeping track of the replaced variables, may be null\n * @return the length change that occurs, unless priorVariables is null when the int\n *  represents a boolean flag as to whether any change occurred.\n */\n", "repo_name": "commons-lang-master/", "id": 369, "method_signature": "int substitute(StrBuilder, int, int, List)", "filename": "StrSubstitutor.substitute.json"}
{"callee_method_ids": [360, 360], "callee_method_names": ["Map<String, String>.put", "StrSubstitutor.replace", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testConstructorMapFull", "method_implementation": "{\n    final Map<String, String> map = new HashMap<>();\n    map.put(\"name\", \"commons\");\n    StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\", '!');\n    assertEquals(\"Hi < commons\", sub.replace(\"Hi !< <name>\"));\n    sub = new StrSubstitutor(map, \"<\", \">\", '!', \"||\");\n    assertEquals(\"Hi < commons\", sub.replace(\"Hi !< <name2||commons>\"));\n}", "repo_id": "8", "comment": "/**\n * Tests constructor.\n */\n", "repo_name": "commons-lang-master/", "id": 1716, "method_signature": "void testConstructorMapFull()", "filename": "StrSubstitutorTest.testConstructorMapFull.json"}
{"callee_method_ids": [360], "callee_method_names": ["Map<String, String>.put", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testConstructorMapPrefixSuffix", "method_implementation": "{\n    final Map<String, String> map = new HashMap<>();\n    map.put(\"name\", \"commons\");\n    final StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\");\n    assertEquals(\"Hi < commons\", sub.replace(\"Hi $< <name>\"));\n}", "repo_id": "8", "comment": "/**\n * Tests constructor.\n */\n", "repo_name": "commons-lang-master/", "id": 1717, "method_signature": "void testConstructorMapPrefixSuffix()", "filename": "StrSubstitutorTest.testConstructorMapPrefixSuffix.json"}
{"callee_method_ids": [360], "callee_method_names": ["StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testConstructorNoArgs", "method_implementation": "{\n    final StrSubstitutor sub = new StrSubstitutor();\n    assertEquals(\"Hi ${name}\", sub.replace(\"Hi ${name}\"));\n}", "repo_id": "8", "comment": "/**\n * Tests constructor.\n */\n", "repo_name": "commons-lang-master/", "id": 1718, "method_signature": "void testConstructorNoArgs()", "filename": "StrSubstitutorTest.testConstructorNoArgs.json"}
{"callee_method_ids": [360, 360], "callee_method_names": ["Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "StrSubstitutor.replace", "Map<String, String>.put", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testCyclicReplacement", "method_implementation": "{\n    final Map<String, String> map = new HashMap<>();\n    map.put(\"animal\", \"${critter}\");\n    map.put(\"target\", \"${pet}\");\n    map.put(\"pet\", \"${petCharacteristic} dog\");\n    map.put(\"petCharacteristic\", \"lazy\");\n    map.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n    map.put(\"critterSpeed\", \"quick\");\n    map.put(\"critterColor\", \"brown\");\n    map.put(\"critterType\", \"${animal}\");\n    final StrSubstitutor sub = new StrSubstitutor(map);\n    assertThrows(IllegalStateException.class, () -> sub.replace(\"The ${animal} jumps over the ${target}.\"), \"Cyclic replacement was not detected!\");\n    // also check even when default value is set.\n    map.put(\"critterType\", \"${animal:-fox}\");\n    final StrSubstitutor sub2 = new StrSubstitutor(map);\n    assertThrows(IllegalStateException.class, () -> sub2.replace(\"The ${animal} jumps over the ${target}.\"), \"Cyclic replacement was not detected!\");\n}", "repo_id": "8", "comment": "/**\n * Tests a cyclic replace operation.\n * The cycle should be detected and cause an exception to be thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 1719, "method_signature": "void testCyclicReplacement()", "filename": "StrSubstitutorTest.testCyclicReplacement.json"}
{"callee_method_names": ["StrSubstitutor.getEscapeChar", "StrSubstitutor.setEscapeChar", "StrSubstitutor.getEscapeChar"], "method_name": "StrSubstitutorTest.testGetSetEscape", "method_implementation": "{\n    final StrSubstitutor sub = new StrSubstitutor();\n    assertEquals('$', sub.getEscapeChar());\n    sub.setEscapeChar('<');\n    assertEquals('<', sub.getEscapeChar());\n}", "repo_id": "8", "comment": "/**\n * Tests get set.\n */\n", "repo_name": "commons-lang-master/", "id": 1720, "method_signature": "void testGetSetEscape()", "filename": "StrSubstitutorTest.testGetSetEscape.json"}
{"callee_method_names": ["StrSubstitutor.getVariablePrefixMatcher", "StrSubstitutor.setVariablePrefix", "StrSubstitutor.getVariablePrefixMatcher", "StrSubstitutor.setVariablePrefix", "StrSubstitutor.getVariablePrefixMatcher", "StrSubstitutor.setVariablePrefix", "StrSubstitutor.getVariablePrefixMatcher", "StrSubstitutor.setVariablePrefixMatcher", "StrSubstitutor.getVariablePrefixMatcher", "StrSubstitutor.setVariablePrefixMatcher", "StrSubstitutor.getVariablePrefixMatcher"], "method_name": "StrSubstitutorTest.testGetSetPrefix", "method_implementation": "{\n    final StrSubstitutor sub = new StrSubstitutor();\n    assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n    sub.setVariablePrefix('<');\n    assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher);\n    sub.setVariablePrefix(\"<<\");\n    assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n    assertThrows(NullPointerException.class, () -> sub.setVariablePrefix(null));\n    assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n    final StrMatcher matcher = StrMatcher.commaMatcher();\n    sub.setVariablePrefixMatcher(matcher);\n    assertSame(matcher, sub.getVariablePrefixMatcher());\n    assertThrows(NullPointerException.class, () -> sub.setVariablePrefixMatcher(null));\n    assertSame(matcher, sub.getVariablePrefixMatcher());\n}", "repo_id": "8", "comment": "/**\n * Tests get set.\n */\n", "repo_name": "commons-lang-master/", "id": 1721, "method_signature": "void testGetSetPrefix()", "filename": "StrSubstitutorTest.testGetSetPrefix.json"}
{"callee_method_names": ["StrSubstitutor.getVariableSuffixMatcher", "StrSubstitutor.setVariableSuffix", "StrSubstitutor.getVariableSuffixMatcher", "StrSubstitutor.setVariableSuffix", "StrSubstitutor.getVariableSuffixMatcher", "StrSubstitutor.setVariableSuffix", "StrSubstitutor.getVariableSuffixMatcher", "StrSubstitutor.setVariableSuffixMatcher", "StrSubstitutor.getVariableSuffixMatcher", "StrSubstitutor.setVariableSuffixMatcher", "StrSubstitutor.getVariableSuffixMatcher"], "method_name": "StrSubstitutorTest.testGetSetSuffix", "method_implementation": "{\n    final StrSubstitutor sub = new StrSubstitutor();\n    assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n    sub.setVariableSuffix('<');\n    assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher);\n    sub.setVariableSuffix(\"<<\");\n    assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n    assertThrows(NullPointerException.class, () -> sub.setVariableSuffix(null));\n    assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n    final StrMatcher matcher = StrMatcher.commaMatcher();\n    sub.setVariableSuffixMatcher(matcher);\n    assertSame(matcher, sub.getVariableSuffixMatcher());\n    assertThrows(NullPointerException.class, () -> sub.setVariableSuffixMatcher(null));\n    assertSame(matcher, sub.getVariableSuffixMatcher());\n}", "repo_id": "8", "comment": "/**\n * Tests get set.\n */\n", "repo_name": "commons-lang-master/", "id": 1722, "method_signature": "void testGetSetSuffix()", "filename": "StrSubstitutorTest.testGetSetSuffix.json"}
{"callee_method_ids": [368, 368, 368], "callee_method_names": ["StrSubstitutor.getValueDelimiterMatcher", "StrSubstitutor.setValueDelimiter", "StrSubstitutor.getValueDelimiterMatcher", "StrSubstitutor.setValueDelimiter", "StrSubstitutor.getValueDelimiterMatcher", "StrSubstitutor.setValueDelimiter", "StrSubstitutor.getValueDelimiterMatcher", "StrSubstitutor.setValueDelimiterMatcher", "StrSubstitutor.getValueDelimiterMatcher", "StrSubstitutor.setValueDelimiterMatcher", "StrSubstitutor.getValueDelimiterMatcher"], "method_name": "StrSubstitutorTest.testGetSetValueDelimiter", "method_implementation": "{\n    final StrSubstitutor sub = new StrSubstitutor();\n    assertTrue(sub.getValueDelimiterMatcher() instanceof StrMatcher.StringMatcher);\n    sub.setValueDelimiter(':');\n    assertTrue(sub.getValueDelimiterMatcher() instanceof StrMatcher.CharMatcher);\n    sub.setValueDelimiter(\"||\");\n    assertTrue(sub.getValueDelimiterMatcher() instanceof StrMatcher.StringMatcher);\n    sub.setValueDelimiter(null);\n    assertNull(sub.getValueDelimiterMatcher());\n    final StrMatcher matcher = StrMatcher.commaMatcher();\n    sub.setValueDelimiterMatcher(matcher);\n    assertSame(matcher, sub.getValueDelimiterMatcher());\n    sub.setValueDelimiterMatcher(null);\n    assertNull(sub.getValueDelimiterMatcher());\n}", "repo_id": "8", "comment": "/**\n * Tests get set.\n */\n", "repo_name": "commons-lang-master/", "id": 1723, "method_signature": "void testGetSetValueDelimiter()", "filename": "StrSubstitutorTest.testGetSetValueDelimiter.json"}
{"callee_method_names": [], "method_name": "StrSubstitutorTest.testLANG1055", "method_implementation": "{\n    System.setProperty(\"test_key\", \"test_value\");\n    final String expected = StrSubstitutor.replace(\"test_key=${test_key}\", System.getProperties());\n    final String actual = StrSubstitutor.replaceSystemProperties(\"test_key=${test_key}\");\n    assertEquals(expected, actual);\n}", "repo_id": "8", "comment": "/**\n * Test for LANG-1055: StrSubstitutor.replaceSystemProperties does not work consistently\n */\n", "repo_name": "commons-lang-master/", "id": 1724, "method_signature": "void testLANG1055()", "filename": "StrSubstitutorTest.testLANG1055.json"}
{"callee_method_ids": [360], "callee_method_names": ["Map<String, String>.put", "Map<String, String>.put", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testReplaceAdjacentAtEnd", "method_implementation": "{\n    values.put(\"code\", \"GBP\");\n    values.put(\"amount\", \"12.50\");\n    final StrSubstitutor sub = new StrSubstitutor(values);\n    assertEquals(\"Amount is GBP12.50\", sub.replace(\"Amount is ${code}${amount}\"));\n}", "repo_id": "8", "comment": "/**\n * Tests adjacent keys.\n */\n", "repo_name": "commons-lang-master/", "id": 1725, "method_signature": "void testReplaceAdjacentAtEnd()", "filename": "StrSubstitutorTest.testReplaceAdjacentAtEnd.json"}
{"callee_method_ids": [360], "callee_method_names": ["Map<String, String>.put", "Map<String, String>.put", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testReplaceAdjacentAtStart", "method_implementation": "{\n    values.put(\"code\", \"GBP\");\n    values.put(\"amount\", \"12.50\");\n    final StrSubstitutor sub = new StrSubstitutor(values);\n    assertEquals(\"GBP12.50 charged\", sub.replace(\"${code}${amount} charged\"));\n}", "repo_id": "8", "comment": "/**\n * Tests adjacent keys.\n */\n", "repo_name": "commons-lang-master/", "id": 1726, "method_signature": "void testReplaceAdjacentAtStart()", "filename": "StrSubstitutorTest.testReplaceAdjacentAtStart.json"}
{"callee_method_ids": [360], "callee_method_names": ["Map<String, String>.put", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testReplaceChangedMap", "method_implementation": "{\n    final StrSubstitutor sub = new StrSubstitutor(values);\n    values.put(\"target\", \"moon\");\n    assertEquals(\"The quick brown fox jumps over the moon.\", sub.replace(\"The ${animal} jumps over the ${target}.\"));\n}", "repo_id": "8", "comment": "/**\n * Tests key replace changing map after initialization (not recommended).\n */\n", "repo_name": "commons-lang-master/", "id": 1727, "method_signature": "void testReplaceChangedMap()", "filename": "StrSubstitutorTest.testReplaceChangedMap.json"}
{"callee_method_names": [], "method_name": "StrSubstitutorTest.testReplaceComplexEscaping", "method_implementation": "{\n    doTestReplace(\"The ${quick brown fox} jumps over the lazy dog.\", \"The $${${animal}} jumps over the ${target}.\", true);\n    doTestReplace(\"The ${quick brown fox} jumps over the lazy dog. ${1234567890}.\", \"The $${${animal}} jumps over the ${target}. $${${undefined.number:-1234567890}}.\", true);\n}", "repo_id": "8", "comment": "/**\n * Tests complex escaping.\n */\n", "repo_name": "commons-lang-master/", "id": 1728, "method_signature": "void testReplaceComplexEscaping()", "filename": "StrSubstitutorTest.testReplaceComplexEscaping.json"}
{"callee_method_names": [], "method_name": "StrSubstitutorTest.testReplaceEmptyKeys", "method_implementation": "{\n    doTestReplace(\"The ${} jumps over the lazy dog.\", \"The ${} jumps over the ${target}.\", true);\n    doTestReplace(\"The animal jumps over the lazy dog.\", \"The ${:-animal} jumps over the ${target}.\", true);\n}", "repo_id": "8", "comment": "/**\n * Tests when no variable name.\n */\n", "repo_name": "commons-lang-master/", "id": 1729, "method_signature": "void testReplaceEmptyKeys()", "filename": "StrSubstitutorTest.testReplaceEmptyKeys.json"}
{"callee_method_ids": [360, 360, 360], "callee_method_names": ["Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "StrSubstitutor.setEnableSubstitutionInVariables", "StrSubstitutor.replace", "Map<String, String>.put", "StrSubstitutor.replace", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testReplaceInVariable", "method_implementation": "{\n    values.put(\"animal.1\", \"fox\");\n    values.put(\"animal.2\", \"mouse\");\n    values.put(\"species\", \"2\");\n    final StrSubstitutor sub = new StrSubstitutor(values);\n    sub.setEnableSubstitutionInVariables(true);\n    assertEquals(\"The mouse jumps over the lazy dog.\", sub.replace(\"The ${animal.${species}} jumps over the ${target}.\"), \"Wrong result (1)\");\n    values.put(\"species\", \"1\");\n    assertEquals(\"The fox jumps over the lazy dog.\", sub.replace(\"The ${animal.${species}} jumps over the ${target}.\"), \"Wrong result (2)\");\n    assertEquals(\"The fox jumps over the lazy dog.\", sub.replace(\"The ${unknown.animal.${unknown.species:-1}:-fox} jumps over the ${unknown.target:-lazy dog}.\"), \"Wrong result (3)\");\n}", "repo_id": "8", "comment": "/**\n * Tests whether a variable can be replaced in a variable name.\n */\n", "repo_name": "commons-lang-master/", "id": 1730, "method_signature": "void testReplaceInVariable()", "filename": "StrSubstitutorTest.testReplaceInVariable.json"}
{"callee_method_ids": [360, 360], "callee_method_names": ["Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "StrSubstitutor.replace", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testReplaceInVariableDisabled", "method_implementation": "{\n    values.put(\"animal.1\", \"fox\");\n    values.put(\"animal.2\", \"mouse\");\n    values.put(\"species\", \"2\");\n    final StrSubstitutor sub = new StrSubstitutor(values);\n    assertEquals(\"The ${animal.${species}} jumps over the lazy dog.\", sub.replace(\"The ${animal.${species}} jumps over the ${target}.\"), \"Wrong result (1)\");\n    assertEquals(\"The ${animal.${species:-1}} jumps over the lazy dog.\", sub.replace(\"The ${animal.${species:-1}} jumps over the ${target}.\"), \"Wrong result (2)\");\n}", "repo_id": "8", "comment": "/**\n * Tests whether substitution in variable names is disabled per default.\n */\n", "repo_name": "commons-lang-master/", "id": 1731, "method_signature": "void testReplaceInVariableDisabled()", "filename": "StrSubstitutorTest.testReplaceInVariableDisabled.json"}
{"callee_method_ids": [360, 360], "callee_method_names": ["Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "StrSubstitutor.setEnableSubstitutionInVariables", "StrSubstitutor.replace", "StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testReplaceInVariableRecursive", "method_implementation": "{\n    values.put(\"animal.2\", \"brown fox\");\n    values.put(\"animal.1\", \"white mouse\");\n    values.put(\"color\", \"white\");\n    values.put(\"species.white\", \"1\");\n    values.put(\"species.brown\", \"2\");\n    final StrSubstitutor sub = new StrSubstitutor(values);\n    sub.setEnableSubstitutionInVariables(true);\n    assertEquals(\"The white mouse jumps over the lazy dog.\", sub.replace(\"The ${animal.${species.${color}}} jumps over the ${target}.\"), \"Wrong result (1)\");\n    assertEquals(\"The brown fox jumps over the lazy dog.\", sub.replace(\"The ${animal.${species.${unknownColor:-brown}}} jumps over the ${target}.\"), \"Wrong result (2)\");\n}", "repo_id": "8", "comment": "/**\n * Tests complex and recursive substitution in variable names.\n */\n", "repo_name": "commons-lang-master/", "id": 1732, "method_signature": "void testReplaceInVariableRecursive()", "filename": "StrSubstitutorTest.testReplaceInVariableRecursive.json"}
{"callee_method_ids": [360], "callee_method_names": ["StrSubstitutor.replace"], "method_name": "StrSubstitutorTest.testReplacePartialString_noReplace", "method_implementation": "{\n    final StrSubstitutor sub = new StrSubstitutor();\n    assertEquals(\"${animal} jumps\", sub.replace(\"The ${animal} jumps over the ${target}.\", 4, 15));\n}", "repo_id": "8", "comment": "/**\n * Tests simple key replace.\n */\n", "repo_name": "commons-lang-master/", "id": 1733, "method_signature": "void testReplacePartialString_noReplace()", "filename": "StrSubstitutorTest.testReplacePartialString_noReplace.json"}
{"callee_method_names": ["Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put"], "method_name": "StrSubstitutorTest.testReplaceRecursive", "method_implementation": "{\n    values.put(\"animal\", \"${critter}\");\n    values.put(\"target\", \"${pet}\");\n    values.put(\"pet\", \"${petCharacteristic} dog\");\n    values.put(\"petCharacteristic\", \"lazy\");\n    values.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n    values.put(\"critterSpeed\", \"quick\");\n    values.put(\"critterColor\", \"brown\");\n    values.put(\"critterType\", \"fox\");\n    doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n    values.put(\"pet\", \"${petCharacteristicUnknown:-lazy} dog\");\n    doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n}", "repo_id": "8", "comment": "/**\n * Tests simple recursive replace.\n */\n", "repo_name": "commons-lang-master/", "id": 1734, "method_signature": "void testReplaceRecursive()", "filename": "StrSubstitutorTest.testReplaceRecursive.json"}
{"callee_method_names": ["Map<String, String>.put", "Map<String, String>.put"], "method_name": "StrSubstitutorTest.testReplaceToIdentical", "method_implementation": "{\n    values.put(\"animal\", \"$${${thing}}\");\n    values.put(\"thing\", \"animal\");\n    doTestReplace(\"The ${animal} jumps.\", \"The ${animal} jumps.\", true);\n}", "repo_id": "8", "comment": "/**\n * Tests replace creates output same as input.\n */\n", "repo_name": "commons-lang-master/", "id": 1735, "method_signature": "void testReplaceToIdentical()", "filename": "StrSubstitutorTest.testReplaceToIdentical.json"}
{"callee_method_names": [], "method_name": "StrSubstitutorTest.testReplaceUnknownKey", "method_implementation": "{\n    doTestReplace(\"The ${person} jumps over the lazy dog.\", \"The ${person} jumps over the ${target}.\", true);\n    doTestReplace(\"The ${person} jumps over the lazy dog. 1234567890.\", \"The ${person} jumps over the ${target}. ${undefined.number:-1234567890}.\", true);\n}", "repo_id": "8", "comment": "/**\n * Tests unknown key replace.\n */\n", "repo_name": "commons-lang-master/", "id": 1736, "method_signature": "void testReplaceUnknownKey()", "filename": "StrSubstitutorTest.testReplaceUnknownKey.json"}
{"callee_method_names": [], "method_name": "StrSubstitutorTest.testReplaceWeirdPattens", "method_implementation": "{\n    doTestNoReplace(\"\");\n    doTestNoReplace(\"${}\");\n    doTestNoReplace(\"${ }\");\n    doTestNoReplace(\"${\\t}\");\n    doTestNoReplace(\"${\\n}\");\n    doTestNoReplace(\"${\\b}\");\n    doTestNoReplace(\"${\");\n    doTestNoReplace(\"$}\");\n    doTestNoReplace(\"}\");\n    doTestNoReplace(\"${}$\");\n    doTestNoReplace(\"${${\");\n    doTestNoReplace(\"${${}}\");\n    doTestNoReplace(\"${$${}}\");\n    doTestNoReplace(\"${$$${}}\");\n    doTestNoReplace(\"${$$${$}}\");\n    doTestNoReplace(\"${${}}\");\n    doTestNoReplace(\"${${ }}\");\n}", "repo_id": "8", "comment": "/**\n * Tests interpolation with weird boundary patterns.\n */\n", "repo_name": "commons-lang-master/", "id": 1737, "method_signature": "void testReplaceWeirdPattens()", "filename": "StrSubstitutorTest.testReplaceWeirdPattens.json"}
{"callee_method_ids": [366], "callee_method_names": ["Map<String, String>.put", "StrSubstitutor.replaceIn", "StrBuilder.toString"], "method_name": "StrSubstitutorTest.testResolveVariable", "method_implementation": "{\n    final StrBuilder builder = new StrBuilder(\"Hi ${name}!\");\n    final Map<String, String> map = new HashMap<>();\n    map.put(\"name\", \"commons\");\n    final StrSubstitutor sub = new StrSubstitutor(map) {\n\n        @Override\n        protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {\n            assertEquals(\"name\", variableName);\n            assertSame(builder, buf);\n            assertEquals(3, startPos);\n            assertEquals(10, endPos);\n            return \"jakarta\";\n        }\n    };\n    sub.replaceIn(builder);\n    assertEquals(\"Hi jakarta!\", builder.toString());\n}", "repo_id": "8", "comment": "/**\n * Tests protected.\n */\n", "repo_name": "commons-lang-master/", "id": 1738, "method_signature": "void testResolveVariable()", "filename": "StrSubstitutorTest.testResolveVariable.json"}
{"callee_method_names": ["Map<String, String>.put"], "method_name": "StrSubstitutorTest.testStaticReplace", "method_implementation": "{\n    final Map<String, String> map = new HashMap<>();\n    map.put(\"name\", \"commons\");\n    assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi ${name}!\", map));\n}", "repo_id": "8", "comment": "/**\n * Tests static.\n */\n", "repo_name": "commons-lang-master/", "id": 1739, "method_signature": "void testStaticReplace()", "filename": "StrSubstitutorTest.testStaticReplace.json"}
{"callee_method_names": ["Map<String, String>.put"], "method_name": "StrSubstitutorTest.testStaticReplacePrefixSuffix", "method_implementation": "{\n    final Map<String, String> map = new HashMap<>();\n    map.put(\"name\", \"commons\");\n    assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi <name>!\", map, \"<\", \">\"));\n}", "repo_id": "8", "comment": "/**\n * Tests static.\n */\n", "repo_name": "commons-lang-master/", "id": 1740, "method_signature": "void testStaticReplacePrefixSuffix()", "filename": "StrSubstitutorTest.testStaticReplacePrefixSuffix.json"}
{"callee_method_ids": [459, 459, 459, 459, 459], "callee_method_names": ["StrBuilder.append", "StrBuilder.append", "StrBuilder.append", "StrBuilder.append", "StrBuilder.append", "StrBuilder.toString"], "method_name": "StrSubstitutorTest.testStaticReplaceSystemProperties", "method_implementation": "{\n    final StrBuilder buf = new StrBuilder();\n    buf.append(\"Hi \").append(System.getProperty(\"user.name\"));\n    buf.append(\", you are working with \");\n    buf.append(System.getProperty(\"os.name\"));\n    buf.append(\", your home directory is \");\n    buf.append(System.getProperty(\"user.home\")).append('.');\n    assertEquals(buf.toString(), StrSubstitutor.replaceSystemProperties(\"Hi ${user.name}, you are \" + \"working with ${os.name}, your home \" + \"directory is ${user.home}.\"));\n}", "repo_id": "8", "comment": "/**\n * Tests interpolation with system properties.\n */\n", "repo_name": "commons-lang-master/", "id": 1741, "method_signature": "void testStaticReplaceSystemProperties()", "filename": "StrSubstitutorTest.testStaticReplaceSystemProperties.json"}
{"callee_method_names": [], "method_name": "StrSubstitutorTest.testSubstituteDefaultProperties", "method_implementation": "{\n    final String org = \"${doesnotwork}\";\n    System.setProperty(\"doesnotwork\", \"It works!\");\n    // create a new Properties object with the System.getProperties as default\n    final Properties props = new Properties(System.getProperties());\n    assertEquals(\"It works!\", StrSubstitutor.replace(org, props));\n}", "repo_id": "8", "comment": "/**\n * Test the replace of a properties object\n */\n", "repo_name": "commons-lang-master/", "id": 1742, "method_signature": "void testSubstituteDefaultProperties()", "filename": "StrSubstitutorTest.testSubstituteDefaultProperties.json"}
{"callee_method_names": ["List<String>.add"], "method_name": "StrTokenizer.addToken", "method_implementation": "{\n    if (StringUtils.isEmpty(tok)) {\n        if (isIgnoreEmptyTokens()) {\n            return;\n        }\n        if (isEmptyTokenAsNull()) {\n            tok = null;\n        }\n    }\n    list.add(tok);\n}", "repo_id": "8", "comment": "/**\n * Adds a token to a list, paying attention to the parameters we've set.\n *\n * @param list  the list to add to\n * @param tok  the token to add\n */\n", "repo_name": "commons-lang-master/", "id": 399, "method_signature": "void addToken(List, String)", "filename": "StrTokenizer.addToken.json"}
{"callee_method_names": ["List<String>.toArray", "List<String>.toArray"], "method_name": "StrTokenizer.checkTokenized", "method_implementation": "{\n    if (tokens == null) {\n        if (chars == null) {\n            // still call tokenize as subclass may do some work\n            final List<String> split = tokenize(null, 0, 0);\n            tokens = split.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n        } else {\n            final List<String> split = tokenize(chars, 0, chars.length);\n            tokens = split.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Checks if tokenization has been done, and if not then do it.\n */\n", "repo_name": "commons-lang-master/", "id": 400, "method_signature": "void checkTokenized()", "filename": "StrTokenizer.checkTokenized.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.clone", "method_implementation": "{\n    try {\n        return cloneReset();\n    } catch (final CloneNotSupportedException ex) {\n        return null;\n    }\n}", "repo_id": "8", "comment": "/**\n * Creates a new instance of this Tokenizer. The new instance is reset so\n * that it will be at the start of the token list.\n * If a {@link CloneNotSupportedException} is caught, return {@code null}.\n *\n * @return a new instance of this Tokenizer which has been reset.\n */\n", "repo_name": "commons-lang-master/", "id": 401, "method_signature": "Object clone()", "filename": "StrTokenizer.clone.json"}
{"callee_method_ids": [401, 416], "callee_method_names": ["StrTokenizer.clone", "StrTokenizer.reset"], "method_name": "StrTokenizer.cloneReset", "method_implementation": "{\n    // this method exists to enable 100% test coverage\n    final StrTokenizer cloned = (StrTokenizer) super.clone();\n    if (cloned.chars != null) {\n        cloned.chars = cloned.chars.clone();\n    }\n    cloned.reset();\n    return cloned;\n}", "repo_id": "8", "comment": "/**\n * Creates a new instance of this Tokenizer. The new instance is reset so that\n * it will be at the start of the token list.\n *\n * @return a new instance of this Tokenizer which has been reset.\n * @throws CloneNotSupportedException if there is a problem cloning\n */\n", "repo_name": "commons-lang-master/", "id": 402, "method_signature": "Object cloneReset()", "filename": "StrTokenizer.cloneReset.json"}
{"callee_method_ids": [416], "callee_method_names": ["StrTokenizer.reset"], "method_name": "StrTokenizer.getCSVInstance", "method_implementation": "{\n    final StrTokenizer tok = getCSVClone();\n    tok.reset(input);\n    return tok;\n}", "repo_id": "8", "comment": "/**\n * Gets a new tokenizer instance which parses Comma Separated Value strings\n * initializing it with the given input.  The default for CSV processing\n * will be trim whitespace from both ends (which can be overridden with\n * the setTrimmer method).\n *\n * @param input  the text to parse\n * @return a new tokenizer instance which parses Comma Separated Value strings\n */\n", "repo_name": "commons-lang-master/", "id": 396, "method_signature": "StrTokenizer getCSVInstance(String)", "filename": "StrTokenizer.getCSVInstance.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.getContent", "method_implementation": "{\n    if (chars == null) {\n        return null;\n    }\n    return new String(chars);\n}", "repo_id": "8", "comment": "/**\n * Gets the String content that the tokenizer is parsing.\n *\n * @return the string content being parsed\n */\n", "repo_name": "commons-lang-master/", "id": 403, "method_signature": "String getContent()", "filename": "StrTokenizer.getContent.json"}
{"callee_method_ids": [416], "callee_method_names": ["StrTokenizer.reset"], "method_name": "StrTokenizer.getTSVInstance", "method_implementation": "{\n    final StrTokenizer tok = getTSVClone();\n    tok.reset(input);\n    return tok;\n}", "repo_id": "8", "comment": "/**\n * Gets a new tokenizer instance which parses Tab Separated Value strings.\n * The default for CSV processing will be trim whitespace from both ends\n * (which can be overridden with the setTrimmer method).\n * @param input  the string to parse\n * @return a new tokenizer instance which parses Tab Separated Value strings.\n */\n", "repo_name": "commons-lang-master/", "id": 398, "method_signature": "StrTokenizer getTSVInstance(String)", "filename": "StrTokenizer.getTSVInstance.json"}
{"callee_method_names": ["List<String>.addAll"], "method_name": "StrTokenizer.getTokenList", "method_implementation": "{\n    checkTokenized();\n    final List<String> list = new ArrayList<>(tokens.length);\n    list.addAll(Arrays.asList(tokens));\n    return list;\n}", "repo_id": "8", "comment": "/**\n * Gets a copy of the full token list as an independent modifiable list.\n *\n * @return the tokens as a String array\n */\n", "repo_name": "commons-lang-master/", "id": 404, "method_signature": "List<String> getTokenList()", "filename": "StrTokenizer.getTokenList.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.hasNext", "method_implementation": "{\n    checkTokenized();\n    return tokenPos < tokens.length;\n}", "repo_id": "8", "comment": "/**\n * Checks whether there are any more tokens.\n *\n * @return true if there are more tokens\n */\n", "repo_name": "commons-lang-master/", "id": 405, "method_signature": "boolean hasNext()", "filename": "StrTokenizer.hasNext.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.hasPrevious", "method_implementation": "{\n    checkTokenized();\n    return tokenPos > 0;\n}", "repo_id": "8", "comment": "/**\n * Checks whether there are any previous tokens that can be iterated to.\n *\n * @return true if there are previous tokens\n */\n", "repo_name": "commons-lang-master/", "id": 406, "method_signature": "boolean hasPrevious()", "filename": "StrTokenizer.hasPrevious.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.isQuote", "method_implementation": "{\n    for (int i = 0; i < quoteLen; i++) {\n        if (pos + i >= len || srcChars[pos + i] != srcChars[quoteStart + i]) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the characters at the index specified match the quote\n * already matched in readNextToken().\n *\n * @param srcChars  the character array being tokenized\n * @param pos  the position to check for a quote\n * @param len  the length of the character array being tokenized\n * @param quoteStart  the start position of the matched quote, 0 if no quoting\n * @param quoteLen  the length of the matched quote, 0 if no quoting\n * @return true if a quote is matched\n */\n", "repo_name": "commons-lang-master/", "id": 407, "method_signature": "boolean isQuote(char[], int, int, int, int)", "filename": "StrTokenizer.isQuote.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.next", "method_implementation": "{\n    if (hasNext()) {\n        return tokens[tokenPos++];\n    }\n    throw new NoSuchElementException();\n}", "repo_id": "8", "comment": "/**\n * Gets the next token.\n *\n * @return the next String token\n * @throws NoSuchElementException if there are no more elements\n */\n", "repo_name": "commons-lang-master/", "id": 408, "method_signature": "String next()", "filename": "StrTokenizer.next.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.nextToken", "method_implementation": "{\n    if (hasNext()) {\n        return tokens[tokenPos++];\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Gets the next token from the String.\n * Equivalent to {@link #next()} except it returns null rather than\n * throwing {@link NoSuchElementException} when no tokens remain.\n *\n * @return the next sequential token, or null when no more tokens are found\n */\n", "repo_name": "commons-lang-master/", "id": 409, "method_signature": "String nextToken()", "filename": "StrTokenizer.nextToken.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.previous", "method_implementation": "{\n    if (hasPrevious()) {\n        return tokens[--tokenPos];\n    }\n    throw new NoSuchElementException();\n}", "repo_id": "8", "comment": "/**\n * Gets the token previous to the last returned token.\n *\n * @return the previous token\n */\n", "repo_name": "commons-lang-master/", "id": 410, "method_signature": "String previous()", "filename": "StrTokenizer.previous.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.previousToken", "method_implementation": "{\n    if (hasPrevious()) {\n        return tokens[--tokenPos];\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Gets the previous token from the String.\n *\n * @return the previous sequential token, or null when no more tokens are found\n */\n", "repo_name": "commons-lang-master/", "id": 411, "method_signature": "String previousToken()", "filename": "StrTokenizer.previousToken.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.readNextToken", "method_implementation": "{\n    // skip all leading whitespace, unless it is the\n    // field delimiter or the quote character\n    while (start < len) {\n        final int removeLen = Math.max(getIgnoredMatcher().isMatch(srcChars, start, start, len), getTrimmerMatcher().isMatch(srcChars, start, start, len));\n        if (removeLen == 0 || getDelimiterMatcher().isMatch(srcChars, start, start, len) > 0 || getQuoteMatcher().isMatch(srcChars, start, start, len) > 0) {\n            break;\n        }\n        start += removeLen;\n    }\n    // handle reaching end\n    if (start >= len) {\n        addToken(tokenList, StringUtils.EMPTY);\n        return -1;\n    }\n    // handle empty token\n    final int delimLen = getDelimiterMatcher().isMatch(srcChars, start, start, len);\n    if (delimLen > 0) {\n        addToken(tokenList, StringUtils.EMPTY);\n        return start + delimLen;\n    }\n    // handle found token\n    final int quoteLen = getQuoteMatcher().isMatch(srcChars, start, start, len);\n    if (quoteLen > 0) {\n        return readWithQuotes(srcChars, start + quoteLen, len, workArea, tokenList, start, quoteLen);\n    }\n    return readWithQuotes(srcChars, start, len, workArea, tokenList, 0, 0);\n}", "repo_id": "8", "comment": "/**\n * Reads character by character through the String to get the next token.\n *\n * @param srcChars  the character array being tokenized\n * @param start  the first character of field\n * @param len  the length of the character array being tokenized\n * @param workArea  a temporary work area\n * @param tokenList  the list of parsed tokens\n * @return the starting position of the next field (the character\n *  immediately after the delimiter), or -1 if end of string found\n */\n", "repo_name": "commons-lang-master/", "id": 412, "method_signature": "int readNextToken(char[], int, int, StrBuilder, List)", "filename": "StrTokenizer.readNextToken.json"}
{"callee_method_ids": [459, 459, 459], "callee_method_names": ["StrBuilder.clear", "StrBuilder.append", "StrBuilder.size", "StrBuilder.substring", "StrBuilder.append", "StrBuilder.append", "StrBuilder.size", "StrBuilder.substring"], "method_name": "StrTokenizer.readWithQuotes", "method_implementation": "{\n    // Loop until we've found the end of the quoted\n    // string or the end of the input\n    workArea.clear();\n    int pos = start;\n    boolean quoting = quoteLen > 0;\n    int trimStart = 0;\n    while (pos < len) {\n        // quoting mode can occur several times throughout a string\n        // we must switch between quoting and non-quoting until we\n        // encounter a non-quoted delimiter, or end of string\n        if (quoting) {\n            // In quoting mode\n            // If we've found a quote character, see if it's\n            // followed by a second quote.  If so, then we need\n            // to actually put the quote character into the token\n            // rather than end the token.\n            if (isQuote(srcChars, pos, len, quoteStart, quoteLen)) {\n                if (isQuote(srcChars, pos + quoteLen, len, quoteStart, quoteLen)) {\n                    // matched pair of quotes, thus an escaped quote\n                    workArea.append(srcChars, pos, quoteLen);\n                    pos += quoteLen * 2;\n                    trimStart = workArea.size();\n                    continue;\n                }\n                // end of quoting\n                quoting = false;\n                pos += quoteLen;\n                continue;\n            }\n        } else {\n            // Not in quoting mode\n            // check for delimiter, and thus end of token\n            final int delimLen = getDelimiterMatcher().isMatch(srcChars, pos, start, len);\n            if (delimLen > 0) {\n                // return condition when end of token found\n                addToken(tokenList, workArea.substring(0, trimStart));\n                return pos + delimLen;\n            }\n            // check for quote, and thus back into quoting mode\n            if (quoteLen > 0 && isQuote(srcChars, pos, len, quoteStart, quoteLen)) {\n                quoting = true;\n                pos += quoteLen;\n                continue;\n            }\n            // check for ignored (outside quotes), and ignore\n            final int ignoredLen = getIgnoredMatcher().isMatch(srcChars, pos, start, len);\n            if (ignoredLen > 0) {\n                pos += ignoredLen;\n                continue;\n            }\n            // check for trimmed character\n            // don't yet know if it's at the end, so copy to workArea\n            // use trimStart to keep track of trim at the end\n            final int trimmedLen = getTrimmerMatcher().isMatch(srcChars, pos, start, len);\n            if (trimmedLen > 0) {\n                workArea.append(srcChars, pos, trimmedLen);\n                pos += trimmedLen;\n                continue;\n            }\n        }\n        // copy regular character from inside quotes\n        workArea.append(srcChars[pos++]);\n        trimStart = workArea.size();\n    }\n    // return condition when end of string found\n    addToken(tokenList, workArea.substring(0, trimStart));\n    return -1;\n}", "repo_id": "8", "comment": "/**\n * Reads a possibly quoted string token.\n *\n * @param srcChars  the character array being tokenized\n * @param start  the first character of field\n * @param len  the length of the character array being tokenized\n * @param workArea  a temporary work area\n * @param tokenList  the list of parsed tokens\n * @param quoteStart  the start position of the matched quote, 0 if no quoting\n * @param quoteLen  the length of the matched quote, 0 if no quoting\n * @return the starting position of the next field (the character\n *  immediately after the delimiter, or if end of string found,\n *  then the length of string\n */\n", "repo_name": "commons-lang-master/", "id": 413, "method_signature": "int readWithQuotes(char[], int, int, StrBuilder, List, int, int)", "filename": "StrTokenizer.readWithQuotes.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "StrTokenizer.reset", "method_implementation": "{\n    reset();\n    if (input != null) {\n        this.chars = input.toCharArray();\n    } else {\n        this.chars = null;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Reset this tokenizer, giving it a new input string to parse.\n * In this manner you can re-use a tokenizer with the same settings\n * on multiple input lines.\n *\n * @param input  the new string to tokenize, null sets no text to parse\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 416, "method_signature": "StrTokenizer reset(String)", "filename": "StrTokenizer.reset.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.setDelimiterMatcher", "method_implementation": "{\n    if (delim == null) {\n        this.delimMatcher = StrMatcher.noneMatcher();\n    } else {\n        this.delimMatcher = delim;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the field delimiter matcher.\n * <p>\n * The delimiter is used to separate one token from another.\n * </p>\n *\n * @param delim  the delimiter matcher to use\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 417, "method_signature": "StrTokenizer setDelimiterMatcher(StrMatcher)", "filename": "StrTokenizer.setDelimiterMatcher.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.setIgnoredMatcher", "method_implementation": "{\n    if (ignored != null) {\n        this.ignoredMatcher = ignored;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the matcher for characters to ignore.\n * <p>\n * These characters are ignored when parsing the String, unless they are\n * within a quoted region.\n * </p>\n *\n * @param ignored  the ignored matcher to use, null ignored\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 418, "method_signature": "StrTokenizer setIgnoredMatcher(StrMatcher)", "filename": "StrTokenizer.setIgnoredMatcher.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.setQuoteMatcher", "method_implementation": "{\n    if (quote != null) {\n        this.quoteMatcher = quote;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the quote matcher to use.\n * <p>\n * The quote character is used to wrap data between the tokens.\n * This enables delimiters to be entered as data.\n * </p>\n *\n * @param quote  the quote matcher to use, null ignored\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 419, "method_signature": "StrTokenizer setQuoteMatcher(StrMatcher)", "filename": "StrTokenizer.setQuoteMatcher.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.setTrimmerMatcher", "method_implementation": "{\n    if (trimmer != null) {\n        this.trimmerMatcher = trimmer;\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Sets the matcher for characters to trim.\n * <p>\n * These characters are trimmed off on each side of the delimiter\n * until the token or quote is found.\n * </p>\n *\n * @param trimmer  the trimmer matcher to use, null ignored\n * @return this, to enable chaining\n */\n", "repo_name": "commons-lang-master/", "id": 420, "method_signature": "StrTokenizer setTrimmerMatcher(StrMatcher)", "filename": "StrTokenizer.setTrimmerMatcher.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.toString", "method_implementation": "{\n    if (tokens == null) {\n        return \"StrTokenizer[not tokenized yet]\";\n    }\n    return \"StrTokenizer\" + getTokenList();\n}", "repo_id": "8", "comment": "/**\n * Gets the String content that the tokenizer is parsing.\n *\n * @return the string content being parsed\n */\n", "repo_name": "commons-lang-master/", "id": 422, "method_signature": "String toString()", "filename": "StrTokenizer.toString.json"}
{"callee_method_names": [], "method_name": "StrTokenizer.tokenize", "method_implementation": "{\n    if (ArrayUtils.isEmpty(srcChars)) {\n        return Collections.emptyList();\n    }\n    final StrBuilder buf = new StrBuilder();\n    final List<String> tokenList = new ArrayList<>();\n    int pos = offset;\n    // loop around the entire buffer\n    while (pos >= 0 && pos < count) {\n        // find next token\n        pos = readNextToken(srcChars, pos, count, buf, tokenList);\n        // handle case where end of string is a delimiter\n        if (pos >= count) {\n            addToken(tokenList, StringUtils.EMPTY);\n        }\n    }\n    return tokenList;\n}", "repo_id": "8", "comment": "/**\n * Internal method to performs the tokenization.\n * <p>\n * Most users of this class do not need to call this method. This method\n * will be called automatically by other (public) methods when required.\n * </p>\n * <p>\n * This method exists to allow subclasses to add code before or after the\n * tokenization. For example, a subclass could alter the character array,\n * offset or count to be parsed, or call the tokenizer multiple times on\n * multiple strings. It is also be possible to filter the results.\n * </p>\n * <p>\n * {@link StrTokenizer} will always pass a zero offset and a count\n * equal to the length of the array to this method, however a subclass\n * may pass other values, or even an entirely different array.\n * </p>\n *\n * @param srcChars  the character array being tokenized, may be null\n * @param offset  the start position within the character array, must be valid\n * @param count  the number of characters to tokenize, must be valid\n * @return the modifiable list of String tokens, unmodifiable if null array or zero count\n */\n", "repo_name": "commons-lang-master/", "id": 421, "method_signature": "List<String> tokenize(char[], int, int)", "filename": "StrTokenizer.tokenize.json"}
{"callee_method_names": [], "method_name": "StrTokenizerTest.testCloneNotSupportedException", "method_implementation": "{\n    final Object notCloned = new StrTokenizer() {\n\n        @Override\n        Object cloneReset() throws CloneNotSupportedException {\n            throw new CloneNotSupportedException(\"test\");\n        }\n    }.clone();\n    assertNull(notCloned);\n}", "repo_id": "8", "comment": "/**\n * Tests that the {@link StrTokenizer#clone()} clone method catches {@link CloneNotSupportedException} and returns\n * {@code null}.\n */\n", "repo_name": "commons-lang-master/", "id": 1703, "method_signature": "void testCloneNotSupportedException()", "filename": "StrTokenizerTest.testCloneNotSupportedException.json"}
{"callee_method_names": [], "method_name": "Streams.assertNotTerminated", "method_implementation": "{\n    if (terminated) {\n        throw new IllegalStateException(\"This stream is already terminated.\");\n    }\n}", "repo_id": "8", "comment": "/**\n * Throws IllegalStateException if this stream is already terminated.\n *\n * @throws IllegalStateException if this stream is already terminated.\n */\n", "repo_name": "commons-lang-master/", "id": 976, "method_signature": "void assertNotTerminated()", "filename": "Streams.assertNotTerminated.json"}
{"callee_method_names": ["Stream<O>.filter"], "method_name": "Streams.filter", "method_implementation": "{\n    assertNotTerminated();\n    stream = stream.filter(Functions.asPredicate(predicate));\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Returns a FailableStream consisting of the elements of this stream that match\n * the given FailablePredicate.\n *\n * <p>\n * This is an intermediate operation.\n * </p>\n *\n * @param predicate a non-interfering, stateless predicate to apply to each\n * element to determine if it should be included.\n * @return the new stream\n */\n", "repo_name": "commons-lang-master/", "id": 977, "method_signature": "FailableStream<O> filter(FailablePredicate)", "filename": "Streams.filter.json"}
{"callee_method_names": [], "method_name": "StringEscapeUtilsTest.testEscapeHiragana", "method_implementation": "{\n    // Some random Japanese Unicode characters\n    final String original = \"\\u304B\\u304C\\u3068\";\n    final String escaped = StringEscapeUtils.escapeHtml4(original);\n    assertEquals(original, escaped, \"Hiragana character Unicode behavior should not be being escaped by escapeHtml4\");\n    final String unescaped = StringEscapeUtils.unescapeHtml4(escaped);\n    assertEquals(escaped, unescaped, \"Hiragana character Unicode behavior has changed - expected no unescaping\");\n}", "repo_id": "8", "comment": "/**\n * Tests https://issues.apache.org/jira/browse/LANG-339\n */\n", "repo_name": "commons-lang-master/", "id": 2018, "method_signature": "void testEscapeHiragana()", "filename": "StringEscapeUtilsTest.testEscapeHiragana.json"}
{"callee_method_names": [], "method_name": "StringEscapeUtilsTest.testEscapeHtmlHighUnicode", "method_implementation": "{\n    // this is the utf8 representation of the character:\n    // COUNTING ROD UNIT DIGIT THREE\n    // in Unicode\n    // code point: U+1D362\n    final byte[] data = { (byte) 0xF0, (byte) 0x9D, (byte) 0x8D, (byte) 0xA2 };\n    final String original = new String(data, StandardCharsets.UTF_8);\n    final String escaped = StringEscapeUtils.escapeHtml4(original);\n    assertEquals(original, escaped, \"High Unicode should not have been escaped\");\n    final String unescaped = StringEscapeUtils.unescapeHtml4(escaped);\n    assertEquals(original, unescaped, \"High Unicode should have been unchanged\");\n    // TODO: I think this should hold, needs further investigation\n    //        String unescapedFromEntity = StringEscapeUtils.unescapeHtml4( \"&#119650;\" );\n    //        assertEquals( \"High Unicode should have been unescaped\", original, unescapedFromEntity);\n}", "repo_id": "8", "comment": "/**\n * Tests // https://issues.apache.org/jira/browse/LANG-480\n */\n", "repo_name": "commons-lang-master/", "id": 2019, "method_signature": "void testEscapeHtmlHighUnicode()", "filename": "StringEscapeUtilsTest.testEscapeHtmlHighUnicode.json"}
{"callee_method_names": [], "method_name": "StringEscapeUtilsTest.testEscapeJavaWithSlash", "method_implementation": "{\n    final String input = \"String with a slash (/) in it\";\n    final String expected = input;\n    final String actual = StringEscapeUtils.escapeJava(input);\n    /*\n         * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters, which are not a valid character to escape\n         * in a Java string.\n         */\n    assertEquals(expected, actual);\n}", "repo_id": "8", "comment": "/**\n * Tests https://issues.apache.org/jira/browse/LANG-421\n */\n", "repo_name": "commons-lang-master/", "id": 2020, "method_signature": "void testEscapeJavaWithSlash()", "filename": "StringEscapeUtilsTest.testEscapeJavaWithSlash.json"}
{"callee_method_ids": [424, 424], "callee_method_names": ["CharSequenceTranslator.translate", "CharSequenceTranslator.translate"], "method_name": "StringEscapeUtilsTest.testEscapeXmlSupplementaryCharacters", "method_implementation": "{\n    final CharSequenceTranslator escapeXml = StringEscapeUtils.ESCAPE_XML.with(NumericEntityEscaper.between(0x7f, Integer.MAX_VALUE));\n    assertEquals(\"&#144308;\", escapeXml.translate(\"\\uD84C\\uDFB4\"), \"Supplementary character must be represented using a single escape\");\n    assertEquals(\"a b c &#144308;\", escapeXml.translate(\"a b c \\uD84C\\uDFB4\"), \"Supplementary characters mixed with basic characters should be encoded correctly\");\n}", "repo_id": "8", "comment": "/**\n * Tests Supplementary characters.\n * <p>\n * From https://www.w3.org/International/questions/qa-escapes\n * </p>\n * <blockquote>\n * Supplementary characters are those Unicode characters that have code points higher than the characters in\n * the Basic Multilingual Plane (BMP). In UTF-16 a supplementary character is encoded using two 16-bit surrogate code points from the\n * BMP. Because of this, some people think that supplementary characters need to be represented using two escapes, but this is incorrect\n * - you must use the single, code point value for that character. For example, use &amp;&#35;x233B4&#59; rather than\n * &amp;&#35;xD84C&#59;&amp;&#35;xDFB4&#59;.\n * </blockquote>\n * @see <a href=\"https://www.w3.org/International/questions/qa-escapes\">Using character escapes in markup and CSS</a>\n * @see <a href=\"https://issues.apache.org/jira/browse/LANG-728\">LANG-728</a>\n */\n", "repo_name": "commons-lang-master/", "id": 2021, "method_signature": "void testEscapeXmlSupplementaryCharacters()", "filename": "StringEscapeUtilsTest.testEscapeXmlSupplementaryCharacters.json"}
{"callee_method_names": ["String.endsWith", "String.endsWith"], "method_name": "StringEscapeUtilsTest.testLang708", "method_implementation": "{\n    final byte[] inputBytes = Files.readAllBytes(Paths.get(\"src/test/resources/lang-708-input.txt\"));\n    final String input = new String(inputBytes, StandardCharsets.UTF_8);\n    final String escaped = StringEscapeUtils.escapeEcmaScript(input);\n    // just the end:\n    assertTrue(escaped.endsWith(\"}]\"), escaped);\n    // a little more:\n    assertTrue(escaped.endsWith(\"\\\"valueCode\\\\\\\":\\\\\\\"\\\\\\\"}]\"), escaped);\n}", "repo_id": "8", "comment": "/**\n * Tests https://issues.apache.org/jira/browse/LANG-708\n *\n * @throws IOException\n *             if an I/O error occurs\n */\n", "repo_name": "commons-lang-master/", "id": 2022, "method_signature": "void testLang708()", "filename": "StringEscapeUtilsTest.testLang708.json"}
{"callee_method_names": [], "method_name": "StringEscapeUtilsTest.testLang720", "method_implementation": "{\n    final String input = \"\\ud842\\udfb7\" + \"A\";\n    final String escaped = StringEscapeUtils.escapeXml(input);\n    assertEquals(input, escaped);\n}", "repo_id": "8", "comment": "/**\n * Tests https://issues.apache.org/jira/browse/LANG-720\n */\n", "repo_name": "commons-lang-master/", "id": 2023, "method_signature": "void testLang720()", "filename": "StringEscapeUtilsTest.testLang720.json"}
{"callee_method_names": [], "method_name": "StringEscapeUtilsTest.testLang911", "method_implementation": "{\n    final String bellsTest = \"\\ud83d\\udc80\\ud83d\\udd14\";\n    final String value = StringEscapeUtils.escapeJava(bellsTest);\n    final String valueTest = StringEscapeUtils.unescapeJava(value);\n    assertEquals(bellsTest, valueTest);\n}", "repo_id": "8", "comment": "/**\n * Tests https://issues.apache.org/jira/browse/LANG-911\n */\n", "repo_name": "commons-lang-master/", "id": 2024, "method_signature": "void testLang911()", "filename": "StringEscapeUtilsTest.testLang911.json"}
{"callee_method_names": [], "method_name": "StringEscapeUtilsTest.testStandaloneAmphersand", "method_implementation": "{\n    assertEquals(\"<P&O>\", StringEscapeUtils.unescapeHtml4(\"&lt;P&O&gt;\"));\n    assertEquals(\"test & <\", StringEscapeUtils.unescapeHtml4(\"test & &lt;\"));\n    assertEquals(\"<P&O>\", StringEscapeUtils.unescapeXml(\"&lt;P&O&gt;\"));\n    assertEquals(\"test & <\", StringEscapeUtils.unescapeXml(\"test & &lt;\"));\n}", "repo_id": "8", "comment": "// https://issues.apache.org/jira/browse/LANG-150\n", "repo_name": "commons-lang-master/", "id": 2025, "method_signature": "void testStandaloneAmphersand()", "filename": "StringEscapeUtilsTest.testStandaloneAmphersand.json"}
{"callee_method_names": [], "method_name": "StringEscapeUtilsTest.testUnescapeXmlSupplementaryCharacters", "method_implementation": "{\n    assertEquals(\"\\uD84C\\uDFB4\", StringEscapeUtils.unescapeXml(\"&#144308;\"), \"Supplementary character must be represented using a single escape\");\n    assertEquals(\"a b c \\uD84C\\uDFB4\", StringEscapeUtils.unescapeXml(\"a b c &#144308;\"), \"Supplementary characters mixed with basic characters should be decoded correctly\");\n}", "repo_id": "8", "comment": "/**\n * Reverse of the above.\n *\n * @see <a href=\"https://issues.apache.org/jira/browse/LANG-729\">LANG-729</a>\n */\n", "repo_name": "commons-lang-master/", "id": 2026, "method_signature": "void testUnescapeXmlSupplementaryCharacters()", "filename": "StringEscapeUtilsTest.testUnescapeXmlSupplementaryCharacters.json"}
{"callee_method_names": [], "method_name": "StringMatcher.isMatch", "method_implementation": "{\n    final int len = chars.length;\n    if (pos + len > bufferEnd) {\n        return 0;\n    }\n    for (int i = 0; i < chars.length; i++, pos++) {\n        if (chars[i] != buffer[pos]) {\n            return 0;\n        }\n    }\n    return len;\n}", "repo_id": "8", "comment": "/**\n * Returns whether or not the given text matches the stored string.\n *\n * @param buffer  the text content to match against, do not change\n * @param pos  the starting position for the match, valid for buffer\n * @param bufferStart  the first active index in the buffer, valid for buffer\n * @param bufferEnd  the end index of the active buffer, valid for buffer\n * @return the number of matching characters, zero for no match\n */\n", "repo_name": "commons-lang-master/", "id": 382, "method_signature": "int isMatch(char[], int, int, int)", "filename": "StringMatcher.isMatch.json"}
{"callee_method_names": ["String.equals", "String.length", "String.length", "String.substring", "String.substring", "String.substring"], "method_name": "StringUtils.abbreviate", "method_implementation": "{\n    if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {\n        return substring(str, 0, maxWidth);\n    }\n    if (isAnyEmpty(str, abbrevMarker)) {\n        return str;\n    }\n    final int abbrevMarkerLength = abbrevMarker.length();\n    final int minAbbrevWidth = abbrevMarkerLength + 1;\n    final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;\n    if (maxWidth < minAbbrevWidth) {\n        throw new IllegalArgumentException(String.format(\"Minimum abbreviation width is %d\", minAbbrevWidth));\n    }\n    final int strLen = str.length();\n    if (strLen <= maxWidth) {\n        return str;\n    }\n    if (offset > strLen) {\n        offset = strLen;\n    }\n    if (strLen - offset < maxWidth - abbrevMarkerLength) {\n        offset = strLen - (maxWidth - abbrevMarkerLength);\n    }\n    if (offset <= abbrevMarkerLength + 1) {\n        return str.substring(0, maxWidth - abbrevMarkerLength) + abbrevMarker;\n    }\n    if (maxWidth < minAbbrevWidthOffset) {\n        throw new IllegalArgumentException(String.format(\"Minimum abbreviation width with offset is %d\", minAbbrevWidthOffset));\n    }\n    if (offset + maxWidth - abbrevMarkerLength < strLen) {\n        return abbrevMarker + abbreviate(str.substring(offset), abbrevMarker, maxWidth - abbrevMarkerLength);\n    }\n    return abbrevMarker + str.substring(strLen - (maxWidth - abbrevMarkerLength));\n}", "repo_id": "8", "comment": "/**\n * Abbreviates a String using a given replacement marker. This will turn\n * \"Now is the time for all good men\" into \"...is the time for...\" if \"...\" was defined\n * as the replacement marker.\n *\n * <p>Works like {@code abbreviate(String, String, int)}, but allows you to specify\n * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n * be the leftmost character in the result, or the first character following the\n * replacement marker, but it will appear somewhere in the result.\n *\n * <p>In no case will it return a String of length greater than {@code maxWidth}.</p>\n *\n * <pre>\n * StringUtils.abbreviate(null, null, *, *)                 = null\n * StringUtils.abbreviate(\"abcdefghijklmno\", null, *, *)    = \"abcdefghijklmno\"\n * StringUtils.abbreviate(\"\", \"...\", 0, 4)                  = \"\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \"---\", -1, 10) = \"abcdefg---\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \",\", 0, 10)    = \"abcdefghi,\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \",\", 1, 10)    = \"abcdefghi,\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \",\", 2, 10)    = \"abcdefghi,\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \"::\", 4, 10)   = \"::efghij::\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \"...\", 6, 10)  = \"...ghij...\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \"*\", 9, 10)    = \"*ghijklmno\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \"'\", 10, 10)   = \"'ghijklmno\"\n * StringUtils.abbreviate(\"abcdefghijklmno\", \"!\", 12, 10)   = \"!ghijklmno\"\n * StringUtils.abbreviate(\"abcdefghij\", \"abra\", 0, 4)       = IllegalArgumentException\n * StringUtils.abbreviate(\"abcdefghij\", \"...\", 5, 6)        = IllegalArgumentException\n * </pre>\n *\n * @param str  the String to check, may be null\n * @param abbrevMarker  the String used as replacement marker\n * @param offset  left edge of source String\n * @param maxWidth  maximum length of result String, must be at least 4\n * @return abbreviated String, {@code null} if null String input\n * @throws IllegalArgumentException if the width is too small\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 980, "method_signature": "String abbreviate(String, String, int, int)", "filename": "StringUtils.abbreviate.json"}
{"callee_method_names": ["String.length", "String.length", "String.length", "String.length", "String.substring", "String.substring"], "method_name": "StringUtils.abbreviateMiddle", "method_implementation": "{\n    if (isAnyEmpty(str, middle) || length >= str.length() || length < middle.length() + 2) {\n        return str;\n    }\n    final int targetSting = length - middle.length();\n    final int startOffset = targetSting / 2 + targetSting % 2;\n    final int endOffset = str.length() - targetSting / 2;\n    return str.substring(0, startOffset) + middle + str.substring(endOffset);\n}", "repo_id": "8", "comment": "/**\n * Abbreviates a String to the length passed, replacing the middle characters with the supplied\n * replacement String.\n *\n * <p>This abbreviation only occurs if the following criteria is met:</p>\n * <ul>\n * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>\n * <li>The length to truncate to is less than the length of the supplied String</li>\n * <li>The length to truncate to is greater than 0</li>\n * <li>The abbreviated String will have enough room for the length supplied replacement String\n * and the first and last characters of the supplied String for abbreviation</li>\n * </ul>\n * <p>Otherwise, the returned String will be the same as the supplied String for abbreviation.\n * </p>\n *\n * <pre>\n * StringUtils.abbreviateMiddle(null, null, 0)      = null\n * StringUtils.abbreviateMiddle(\"abc\", null, 0)      = \"abc\"\n * StringUtils.abbreviateMiddle(\"abc\", \".\", 0)      = \"abc\"\n * StringUtils.abbreviateMiddle(\"abc\", \".\", 3)      = \"abc\"\n * StringUtils.abbreviateMiddle(\"abcdef\", \".\", 4)     = \"ab.f\"\n * </pre>\n *\n * @param str  the String to abbreviate, may be null\n * @param middle the String to replace the middle characters with, may be null\n * @param length the length to abbreviate {@code str} to.\n * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 981, "method_signature": "String abbreviateMiddle(String, String, int)", "filename": "StringUtils.abbreviateMiddle.json"}
{"callee_method_names": ["CharSequence.toString"], "method_name": "StringUtils.appendIfMissing", "method_implementation": "{\n    if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) {\n        return str;\n    }\n    if (ArrayUtils.isNotEmpty(suffixes)) {\n        for (final CharSequence s : suffixes) {\n            if (endsWith(str, s, ignoreCase)) {\n                return str;\n            }\n        }\n    }\n    return str + suffix.toString();\n}", "repo_id": "8", "comment": "/**\n * Appends the suffix to the end of the string if the string does not\n * already end with the suffix.\n *\n * @param str The string.\n * @param suffix The suffix to append to the end of the string.\n * @param ignoreCase Indicates whether the compare should ignore case.\n * @param suffixes Additional suffixes that are valid terminators (optional).\n *\n * @return A new String if suffix was appended, the same string otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 982, "method_signature": "String appendIfMissing(String, CharSequence, boolean, CharSequence[])", "filename": "StringUtils.appendIfMissing.json"}
{"callee_method_names": ["String.codePointAt", "String.codePointAt"], "method_name": "StringUtils.capitalize", "method_implementation": "{\n    final int strLen = length(str);\n    if (strLen == 0) {\n        return str;\n    }\n    final int firstCodepoint = str.codePointAt(0);\n    final int newCodePoint = Character.toTitleCase(firstCodepoint);\n    if (firstCodepoint == newCodePoint) {\n        // already capitalized\n        return str;\n    }\n    // cannot be longer than the char array\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    // copy the first code point\n    newCodePoints[outOffset++] = newCodePoint;\n    for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; ) {\n        final int codePoint = str.codePointAt(inOffset);\n        // copy the remaining ones\n        newCodePoints[outOffset++] = codePoint;\n        inOffset += Character.charCount(codePoint);\n    }\n    return new String(newCodePoints, 0, outOffset);\n}", "repo_id": "8", "comment": "/**\n * Capitalizes a String changing the first character to title case as\n * per {@link Character#toTitleCase(int)}. No other characters are changed.\n *\n * <p>For a word based algorithm, see {@link org.apache.commons.text.WordUtils#capitalize(String)}.\n * A {@code null} input String returns {@code null}.</p>\n *\n * <pre>\n * StringUtils.capitalize(null)  = null\n * StringUtils.capitalize(\"\")    = \"\"\n * StringUtils.capitalize(\"cat\") = \"Cat\"\n * StringUtils.capitalize(\"cAt\") = \"CAt\"\n * StringUtils.capitalize(\"'cat'\") = \"'cat'\"\n * </pre>\n *\n * @param str the String to capitalize, may be null\n * @return the capitalized String, {@code null} if null String input\n * @see org.apache.commons.text.WordUtils#capitalize(String)\n * @see #uncapitalize(String)\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 983, "method_signature": "String capitalize(String)", "filename": "StringUtils.capitalize.json"}
{"callee_method_names": ["String.length"], "method_name": "StringUtils.center", "method_implementation": "{\n    if (str == null || size <= 0) {\n        return str;\n    }\n    if (isEmpty(padStr)) {\n        padStr = SPACE;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padStr);\n    str = rightPad(str, size, padStr);\n    return str;\n}", "repo_id": "8", "comment": "/**\n * Centers a String in a larger String of size {@code size}.\n * Uses a supplied String as the value to pad the String with.\n *\n * <p>If the size is less than the String length, the String is returned.\n * A {@code null} String returns {@code null}.\n * A negative size is treated as zero.</p>\n *\n * <pre>\n * StringUtils.center(null, *, *)     = null\n * StringUtils.center(\"\", 4, \" \")     = \"    \"\n * StringUtils.center(\"ab\", -1, \" \")  = \"ab\"\n * StringUtils.center(\"ab\", 4, \" \")   = \" ab \"\n * StringUtils.center(\"abcd\", 2, \" \") = \"abcd\"\n * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n * StringUtils.center(\"a\", 4, \"yz\")   = \"yayz\"\n * StringUtils.center(\"abc\", 7, null) = \"  abc  \"\n * StringUtils.center(\"abc\", 7, \"\")   = \"  abc  \"\n * </pre>\n *\n * @param str  the String to center, may be null\n * @param size  the int size of new String, negative treated as zero\n * @param padStr  the String to pad the new String with, must not be null or empty\n * @return centered String, {@code null} if null String input\n * @throws IllegalArgumentException if padStr is {@code null} or empty\n */\n", "repo_name": "commons-lang-master/", "id": 985, "method_signature": "String center(String, int, String)", "filename": "StringUtils.center.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.length", "String.charAt", "String.charAt", "String.substring"], "method_name": "StringUtils.chomp", "method_implementation": "{\n    if (isEmpty(str)) {\n        return str;\n    }\n    if (str.length() == 1) {\n        final char ch = str.charAt(0);\n        if (ch == CharUtils.CR || ch == CharUtils.LF) {\n            return EMPTY;\n        }\n        return str;\n    }\n    int lastIdx = str.length() - 1;\n    final char last = str.charAt(lastIdx);\n    if (last == CharUtils.LF) {\n        if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n            lastIdx--;\n        }\n    } else if (last != CharUtils.CR) {\n        lastIdx++;\n    }\n    return str.substring(0, lastIdx);\n}", "repo_id": "8", "comment": "/**\n * Removes one newline from end of a String if it's there,\n * otherwise leave it alone.  A newline is &quot;{@code \\n}&quot;,\n * &quot;{@code \\r}&quot;, or &quot;{@code \\r\\n}&quot;.\n *\n * <p>NOTE: This method changed in 2.0.\n * It now more closely matches Perl chomp.</p>\n *\n * <pre>\n * StringUtils.chomp(null)          = null\n * StringUtils.chomp(\"\")            = \"\"\n * StringUtils.chomp(\"abc \\r\")      = \"abc \"\n * StringUtils.chomp(\"abc\\n\")       = \"abc\"\n * StringUtils.chomp(\"abc\\r\\n\")     = \"abc\"\n * StringUtils.chomp(\"abc\\r\\n\\r\\n\") = \"abc\\r\\n\"\n * StringUtils.chomp(\"abc\\n\\r\")     = \"abc\\n\"\n * StringUtils.chomp(\"abc\\n\\rabc\")  = \"abc\\n\\rabc\"\n * StringUtils.chomp(\"\\r\")          = \"\"\n * StringUtils.chomp(\"\\n\")          = \"\"\n * StringUtils.chomp(\"\\r\\n\")        = \"\"\n * </pre>\n *\n * @param str  the String to chomp a newline from, may be null\n * @return String without newline, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 986, "method_signature": "String chomp(String)", "filename": "StringUtils.chomp.json"}
{"callee_method_names": ["String.length", "String.substring", "String.charAt", "String.charAt", "String.substring"], "method_name": "StringUtils.chop", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen < 2) {\n        return EMPTY;\n    }\n    final int lastIdx = strLen - 1;\n    final String ret = str.substring(0, lastIdx);\n    final char last = str.charAt(lastIdx);\n    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {\n        return ret.substring(0, lastIdx - 1);\n    }\n    return ret;\n}", "repo_id": "8", "comment": "/**\n * Remove the last character from a String.\n *\n * <p>If the String ends in {@code \\r\\n}, then remove both\n * of them.</p>\n *\n * <pre>\n * StringUtils.chop(null)          = null\n * StringUtils.chop(\"\")            = \"\"\n * StringUtils.chop(\"abc \\r\")      = \"abc \"\n * StringUtils.chop(\"abc\\n\")       = \"abc\"\n * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n * StringUtils.chop(\"abc\")         = \"ab\"\n * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n * StringUtils.chop(\"a\")           = \"\"\n * StringUtils.chop(\"\\r\")          = \"\"\n * StringUtils.chop(\"\\n\")          = \"\"\n * StringUtils.chop(\"\\r\\n\")        = \"\"\n * </pre>\n *\n * @param str  the String to chop last character from, may be null\n * @return String without last character, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 987, "method_signature": "String chop(String)", "filename": "StringUtils.chop.json"}
{"callee_method_names": ["String.compareTo"], "method_name": "StringUtils.compare", "method_implementation": "{\n    if (str1 == str2) {\n        // NOSONARLINT this intentionally uses == to allow for both null\n        return 0;\n    }\n    if (str1 == null) {\n        return nullIsLess ? -1 : 1;\n    }\n    if (str2 == null) {\n        return nullIsLess ? 1 : -1;\n    }\n    return str1.compareTo(str2);\n}", "repo_id": "8", "comment": "/**\n * Compare two Strings lexicographically, as per {@link String#compareTo(String)}, returning :\n * <ul>\n *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>\n *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>\n *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>\n * </ul>\n *\n * <p>This is a {@code null} safe version of :</p>\n * <blockquote><pre>str1.compareTo(str2)</pre></blockquote>\n *\n * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.\n * Two {@code null} references are considered equal.</p>\n *\n * <pre>\n * StringUtils.compare(null, null, *)     = 0\n * StringUtils.compare(null , \"a\", true)  &lt; 0\n * StringUtils.compare(null , \"a\", false) &gt; 0\n * StringUtils.compare(\"a\", null, true)   &gt; 0\n * StringUtils.compare(\"a\", null, false)  &lt; 0\n * StringUtils.compare(\"abc\", \"abc\", *)   = 0\n * StringUtils.compare(\"a\", \"b\", *)       &lt; 0\n * StringUtils.compare(\"b\", \"a\", *)       &gt; 0\n * StringUtils.compare(\"a\", \"B\", *)       &gt; 0\n * StringUtils.compare(\"ab\", \"abc\", *)    &lt; 0\n * </pre>\n *\n * @see String#compareTo(String)\n * @param str1  the String to compare from\n * @param str2  the String to compare to\n * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value\n * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 988, "method_signature": "int compare(String, String, boolean)", "filename": "StringUtils.compare.json"}
{"callee_method_names": ["String.compareToIgnoreCase"], "method_name": "StringUtils.compareIgnoreCase", "method_implementation": "{\n    if (str1 == str2) {\n        // NOSONARLINT this intentionally uses == to allow for both null\n        return 0;\n    }\n    if (str1 == null) {\n        return nullIsLess ? -1 : 1;\n    }\n    if (str2 == null) {\n        return nullIsLess ? 1 : -1;\n    }\n    return str1.compareToIgnoreCase(str2);\n}", "repo_id": "8", "comment": "/**\n * Compare two Strings lexicographically, ignoring case differences,\n * as per {@link String#compareToIgnoreCase(String)}, returning :\n * <ul>\n *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>\n *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>\n *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>\n * </ul>\n *\n * <p>This is a {@code null} safe version of :</p>\n * <blockquote><pre>str1.compareToIgnoreCase(str2)</pre></blockquote>\n *\n * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.\n * Two {@code null} references are considered equal.\n * Comparison is case insensitive.</p>\n *\n * <pre>\n * StringUtils.compareIgnoreCase(null, null, *)     = 0\n * StringUtils.compareIgnoreCase(null , \"a\", true)  &lt; 0\n * StringUtils.compareIgnoreCase(null , \"a\", false) &gt; 0\n * StringUtils.compareIgnoreCase(\"a\", null, true)   &gt; 0\n * StringUtils.compareIgnoreCase(\"a\", null, false)  &lt; 0\n * StringUtils.compareIgnoreCase(\"abc\", \"abc\", *)   = 0\n * StringUtils.compareIgnoreCase(\"abc\", \"ABC\", *)   = 0\n * StringUtils.compareIgnoreCase(\"a\", \"b\", *)       &lt; 0\n * StringUtils.compareIgnoreCase(\"b\", \"a\", *)       &gt; 0\n * StringUtils.compareIgnoreCase(\"a\", \"B\", *)       &lt; 0\n * StringUtils.compareIgnoreCase(\"A\", \"b\", *)       &lt; 0\n * StringUtils.compareIgnoreCase(\"ab\", \"abc\", *)    &lt; 0\n * </pre>\n *\n * @see String#compareToIgnoreCase(String)\n * @param str1  the String to compare from\n * @param str2  the String to compare to\n * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value\n * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2},\n *          ignoring case differences.\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 989, "method_signature": "int compareIgnoreCase(String, String, boolean)", "filename": "StringUtils.compareIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtils.contains", "method_implementation": "{\n    if (isEmpty(seq)) {\n        return false;\n    }\n    return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;\n}", "repo_id": "8", "comment": "/**\n * Checks if CharSequence contains a search character, handling {@code null}.\n * This method uses {@link String#indexOf(int)} if possible.\n *\n * <p>A {@code null} or empty (\"\") CharSequence will return {@code false}.</p>\n *\n * <pre>\n * StringUtils.contains(null, *)    = false\n * StringUtils.contains(\"\", *)      = false\n * StringUtils.contains(\"abc\", 'a') = true\n * StringUtils.contains(\"abc\", 'z') = false\n * </pre>\n *\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @return true if the CharSequence contains the search character,\n *  false if not or {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)\n */\n", "repo_name": "commons-lang-master/", "id": 991, "method_signature": "boolean contains(CharSequence, int)", "filename": "StringUtils.contains.json"}
{"callee_method_names": ["ToBooleanBiFunction<CharSequence,CharSequence>.applyAsBoolean"], "method_name": "StringUtils.containsAny", "method_implementation": "{\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchCharSequences)) {\n        return false;\n    }\n    for (final CharSequence searchCharSequence : searchCharSequences) {\n        if (test.applyAsBoolean(cs, searchCharSequence)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains any of the CharSequences in the given array.\n *\n * <p>\n * A {@code null} {@code cs} CharSequence will return {@code false}. A {@code null} or zero length search array will\n * return {@code false}.\n * </p>\n *\n * @param cs The CharSequence to check, may be null\n * @param searchCharSequences The array of CharSequences to search for, may be null. Individual CharSequences may be\n *        null as well.\n * @return {@code true} if any of the search CharSequences are found, {@code false} otherwise\n * @since 3.12.0\n */\n", "repo_name": "commons-lang-master/", "id": 994, "method_signature": "boolean containsAny(ToBooleanBiFunction, CharSequence, CharSequence[])", "filename": "StringUtils.containsAny.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.containsIgnoreCase", "method_implementation": "{\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    final int len = searchStr.length();\n    final int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Checks if CharSequence contains a search CharSequence irrespective of case,\n * handling {@code null}. Case-insensitivity is defined as by\n * {@link String#equalsIgnoreCase(String)}.\n *\n * <p>A {@code null} CharSequence will return {@code false}.\n *\n * <pre>\n * StringUtils.containsIgnoreCase(null, *) = false\n * StringUtils.containsIgnoreCase(*, null) = false\n * StringUtils.containsIgnoreCase(\"\", \"\") = true\n * StringUtils.containsIgnoreCase(\"abc\", \"\") = true\n * StringUtils.containsIgnoreCase(\"abc\", \"a\") = true\n * StringUtils.containsIgnoreCase(\"abc\", \"z\") = false\n * StringUtils.containsIgnoreCase(\"abc\", \"A\") = true\n * StringUtils.containsIgnoreCase(\"abc\", \"Z\") = false\n * </pre>\n *\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @return true if the CharSequence contains the search CharSequence irrespective of\n * case or false if not or {@code null} string input\n * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 995, "method_signature": "boolean containsIgnoreCase(CharSequence, CharSequence)", "filename": "StringUtils.containsIgnoreCase.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "StringUtils.containsNone", "method_implementation": "{\n    if (invalidChars == null) {\n        return true;\n    }\n    return containsNone(cs, invalidChars.toCharArray());\n}", "repo_id": "8", "comment": "/**\n * Checks that the CharSequence does not contain certain characters.\n *\n * <p>A {@code null} CharSequence will return {@code true}.\n * A {@code null} invalid character array will return {@code true}.\n * An empty String (\"\") always returns true.</p>\n *\n * <pre>\n * StringUtils.containsNone(null, *)       = true\n * StringUtils.containsNone(*, null)       = true\n * StringUtils.containsNone(\"\", *)         = true\n * StringUtils.containsNone(\"ab\", \"\")      = true\n * StringUtils.containsNone(\"abab\", \"xyz\") = true\n * StringUtils.containsNone(\"ab1\", \"xyz\")  = true\n * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @param invalidChars  a String of invalid chars, may be null\n * @return true if it contains none of the invalid chars, or is null\n * @since 2.0\n * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)\n */\n", "repo_name": "commons-lang-master/", "id": 997, "method_signature": "boolean containsNone(CharSequence, String)", "filename": "StringUtils.containsNone.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "StringUtils.containsOnly", "method_implementation": "{\n    if (cs == null || validChars == null) {\n        return false;\n    }\n    return containsOnly(cs, validChars.toCharArray());\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only certain characters.\n *\n * <p>A {@code null} CharSequence will return {@code false}.\n * A {@code null} valid character String will return {@code false}.\n * An empty String (length()=0) always returns {@code true}.</p>\n *\n * <pre>\n * StringUtils.containsOnly(null, *)       = false\n * StringUtils.containsOnly(*, null)       = false\n * StringUtils.containsOnly(\"\", *)         = true\n * StringUtils.containsOnly(\"ab\", \"\")      = false\n * StringUtils.containsOnly(\"abab\", \"abc\") = true\n * StringUtils.containsOnly(\"ab1\", \"abc\")  = false\n * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @param validChars  a String of valid chars, may be null\n * @return true if it only contains valid chars and is non-null\n * @since 2.0\n * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)\n */\n", "repo_name": "commons-lang-master/", "id": 999, "method_signature": "boolean containsOnly(CharSequence, String)", "filename": "StringUtils.containsOnly.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.containsWhitespace", "method_implementation": "{\n    if (isEmpty(seq)) {\n        return false;\n    }\n    final int strLen = seq.length();\n    for (int i = 0; i < strLen; i++) {\n        if (Character.isWhitespace(seq.charAt(i))) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "// From org.springframework.util.StringUtils, under Apache License 2.0\n", "repo_name": "commons-lang-master/", "id": 1000, "method_signature": "boolean containsWhitespace(CharSequence)", "filename": "StringUtils.containsWhitespace.json"}
{"callee_method_names": ["CharSequence.length"], "method_name": "StringUtils.countMatches", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(sub)) {\n        return 0;\n    }\n    int count = 0;\n    int idx = 0;\n    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {\n        count++;\n        idx += sub.length();\n    }\n    return count;\n}", "repo_id": "8", "comment": "/**\n * Counts how many times the substring appears in the larger string.\n * Note that the code only counts non-overlapping matches.\n *\n * <p>A {@code null} or empty (\"\") String input returns {@code 0}.</p>\n *\n * <pre>\n * StringUtils.countMatches(null, *)       = 0\n * StringUtils.countMatches(\"\", *)         = 0\n * StringUtils.countMatches(\"abba\", null)  = 0\n * StringUtils.countMatches(\"abba\", \"\")    = 0\n * StringUtils.countMatches(\"abba\", \"a\")   = 2\n * StringUtils.countMatches(\"abba\", \"ab\")  = 1\n * StringUtils.countMatches(\"abba\", \"xxx\") = 0\n * StringUtils.countMatches(\"ababa\", \"aba\") = 1\n * </pre>\n *\n * @param str  the CharSequence to check, may be null\n * @param sub  the substring to count, may be null\n * @return the number of occurrences, 0 if either CharSequence is {@code null}\n * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1002, "method_signature": "int countMatches(CharSequence, CharSequence)", "filename": "StringUtils.countMatches.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.charAt"], "method_name": "StringUtils.deleteWhitespace", "method_implementation": "{\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    if (count == 0) {\n        return EMPTY;\n    }\n    return new String(chs, 0, count);\n}", "repo_id": "8", "comment": "/**\n * Deletes all whitespaces from a String as defined by\n * {@link Character#isWhitespace(char)}.\n *\n * <pre>\n * StringUtils.deleteWhitespace(null)         = null\n * StringUtils.deleteWhitespace(\"\")           = \"\"\n * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n * </pre>\n *\n * @param str  the String to delete whitespace from, may be null\n * @return the String without whitespaces, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1003, "method_signature": "String deleteWhitespace(String)", "filename": "StringUtils.deleteWhitespace.json"}
{"callee_method_names": ["String.substring"], "method_name": "StringUtils.difference", "method_implementation": "{\n    if (str1 == null) {\n        return str2;\n    }\n    if (str2 == null) {\n        return str1;\n    }\n    final int at = indexOfDifference(str1, str2);\n    if (at == INDEX_NOT_FOUND) {\n        return EMPTY;\n    }\n    return str2.substring(at);\n}", "repo_id": "8", "comment": "/**\n * Compares two Strings, and returns the portion where they differ.\n * More precisely, return the remainder of the second String,\n * starting from where it's different from the first. This means that\n * the difference between \"abc\" and \"ab\" is the empty String and not \"c\".\n *\n * <p>For example,\n * {@code difference(\"i am a machine\", \"i am a robot\") -> \"robot\"}.</p>\n *\n * <pre>\n * StringUtils.difference(null, null) = null\n * StringUtils.difference(\"\", \"\") = \"\"\n * StringUtils.difference(\"\", \"abc\") = \"abc\"\n * StringUtils.difference(\"abc\", \"\") = \"\"\n * StringUtils.difference(\"abc\", \"abc\") = \"\"\n * StringUtils.difference(\"abc\", \"ab\") = \"\"\n * StringUtils.difference(\"ab\", \"abxyz\") = \"xyz\"\n * StringUtils.difference(\"abcde\", \"abxyz\") = \"xyz\"\n * StringUtils.difference(\"abcde\", \"xyz\") = \"xyz\"\n * </pre>\n *\n * @param str1  the first String, may be null\n * @param str2  the second String, may be null\n * @return the portion of str2 where it differs from str1; returns the\n * empty String if they are equal\n * @see #indexOfDifference(CharSequence,CharSequence)\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1004, "method_signature": "String difference(String, String)", "filename": "StringUtils.difference.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.length", "CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.endsWith", "method_implementation": "{\n    if (str == null || suffix == null) {\n        return str == suffix;\n    }\n    if (suffix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - suffix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "repo_id": "8", "comment": "/**\n * Check if a CharSequence ends with a specified suffix (optionally case insensitive).\n *\n * @see String#endsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase indicates whether the compare should ignore case\n *  (case-insensitive) or not.\n * @return {@code true} if the CharSequence starts with the prefix or\n *  both {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 1005, "method_signature": "boolean endsWith(CharSequence, CharSequence, boolean)", "filename": "StringUtils.endsWith.json"}
{"callee_method_names": [], "method_name": "StringUtils.endsWithAny", "method_implementation": "{\n    if (isEmpty(sequence) || ArrayUtils.isEmpty(searchStrings)) {\n        return false;\n    }\n    for (final CharSequence searchString : searchStrings) {\n        if (endsWith(sequence, searchString)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Check if a CharSequence ends with any of the provided case-sensitive suffixes.\n *\n * <pre>\n * StringUtils.endsWithAny(null, null)      = false\n * StringUtils.endsWithAny(null, new String[] {\"abc\"})  = false\n * StringUtils.endsWithAny(\"abcxyz\", null)     = false\n * StringUtils.endsWithAny(\"abcxyz\", new String[] {\"\"}) = true\n * StringUtils.endsWithAny(\"abcxyz\", new String[] {\"xyz\"}) = true\n * StringUtils.endsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n * StringUtils.endsWithAny(\"abcXYZ\", \"def\", \"XYZ\") = true\n * StringUtils.endsWithAny(\"abcXYZ\", \"def\", \"xyz\") = false\n * </pre>\n *\n * @param sequence  the CharSequence to check, may be null\n * @param searchStrings the case-sensitive CharSequences to find, may be empty or contain {@code null}\n * @see StringUtils#endsWith(CharSequence, CharSequence)\n * @return {@code true} if the input {@code sequence} is {@code null} AND no {@code searchStrings} are provided, or\n *   the input {@code sequence} ends in any of the provided case-sensitive {@code searchStrings}.\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1006, "method_signature": "boolean endsWithAny(CharSequence, CharSequence[])", "filename": "StringUtils.endsWithAny.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.equals", "CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "StringUtils.equals", "method_implementation": "{\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1.length() != cs2.length()) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    // Step-wise comparison\n    final int length = cs1.length();\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i) != cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Compares two CharSequences, returning {@code true} if they represent\n * equal sequences of characters.\n *\n * <p>{@code null}s are handled without exceptions. Two {@code null}\n * references are considered to be equal. The comparison is <strong>case-sensitive</strong>.</p>\n *\n * <pre>\n * StringUtils.equals(null, null)   = true\n * StringUtils.equals(null, \"abc\")  = false\n * StringUtils.equals(\"abc\", null)  = false\n * StringUtils.equals(\"abc\", \"abc\") = true\n * StringUtils.equals(\"abc\", \"ABC\") = false\n * </pre>\n *\n * @param cs1  the first CharSequence, may be {@code null}\n * @param cs2  the second CharSequence, may be {@code null}\n * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n * @see Object#equals(Object)\n * @see #equalsIgnoreCase(CharSequence, CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1007, "method_signature": "boolean equals(CharSequence, CharSequence)", "filename": "StringUtils.equals.json"}
{"callee_method_names": [], "method_name": "StringUtils.equalsAny", "method_implementation": "{\n    if (ArrayUtils.isNotEmpty(searchStrings)) {\n        for (final CharSequence next : searchStrings) {\n            if (equals(string, next)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares given {@code string} to a CharSequences vararg of {@code searchStrings},\n * returning {@code true} if the {@code string} is equal to any of the {@code searchStrings}.\n *\n * <pre>\n * StringUtils.equalsAny(null, (CharSequence[]) null) = false\n * StringUtils.equalsAny(null, null, null)    = true\n * StringUtils.equalsAny(null, \"abc\", \"def\")  = false\n * StringUtils.equalsAny(\"abc\", null, \"def\")  = false\n * StringUtils.equalsAny(\"abc\", \"abc\", \"def\") = true\n * StringUtils.equalsAny(\"abc\", \"ABC\", \"DEF\") = false\n * </pre>\n *\n * @param string to compare, may be {@code null}.\n * @param searchStrings a vararg of strings, may be {@code null}.\n * @return {@code true} if the string is equal (case-sensitive) to any other element of {@code searchStrings};\n * {@code false} if {@code searchStrings} is null or contains no matches.\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1008, "method_signature": "boolean equalsAny(CharSequence, CharSequence[])", "filename": "StringUtils.equalsAny.json"}
{"callee_method_names": [], "method_name": "StringUtils.equalsAnyIgnoreCase", "method_implementation": "{\n    if (ArrayUtils.isNotEmpty(searchStrings)) {\n        for (final CharSequence next : searchStrings) {\n            if (equalsIgnoreCase(string, next)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares given {@code string} to a CharSequences vararg of {@code searchStrings},\n * returning {@code true} if the {@code string} is equal to any of the {@code searchStrings}, ignoring case.\n *\n * <pre>\n * StringUtils.equalsAnyIgnoreCase(null, (CharSequence[]) null) = false\n * StringUtils.equalsAnyIgnoreCase(null, null, null)    = true\n * StringUtils.equalsAnyIgnoreCase(null, \"abc\", \"def\")  = false\n * StringUtils.equalsAnyIgnoreCase(\"abc\", null, \"def\")  = false\n * StringUtils.equalsAnyIgnoreCase(\"abc\", \"abc\", \"def\") = true\n * StringUtils.equalsAnyIgnoreCase(\"abc\", \"ABC\", \"DEF\") = true\n * </pre>\n *\n * @param string to compare, may be {@code null}.\n * @param searchStrings a vararg of strings, may be {@code null}.\n * @return {@code true} if the string is equal (case-insensitive) to any other element of {@code searchStrings};\n * {@code false} if {@code searchStrings} is null or contains no matches.\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1009, "method_signature": "boolean equalsAnyIgnoreCase(CharSequence, CharSequence[])", "filename": "StringUtils.equalsAnyIgnoreCase.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.equalsIgnoreCase", "method_implementation": "{\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1.length() != cs2.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, cs1.length());\n}", "repo_id": "8", "comment": "/**\n * Compares two CharSequences, returning {@code true} if they represent\n * equal sequences of characters, ignoring case.\n *\n * <p>{@code null}s are handled without exceptions. Two {@code null}\n * references are considered equal. The comparison is <strong>case insensitive</strong>.</p>\n *\n * <pre>\n * StringUtils.equalsIgnoreCase(null, null)   = true\n * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n * </pre>\n *\n * @param cs1  the first CharSequence, may be {@code null}\n * @param cs2  the second CharSequence, may be {@code null}\n * @return {@code true} if the CharSequences are equal (case-insensitive), or both {@code null}\n * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)\n * @see #equals(CharSequence, CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1010, "method_signature": "boolean equalsIgnoreCase(CharSequence, CharSequence)", "filename": "StringUtils.equalsIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtils.firstNonBlank", "method_implementation": "{\n    if (values != null) {\n        for (final T val : values) {\n            if (isNotBlank(val)) {\n                return val;\n            }\n        }\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Returns the first value in the array which is not empty (\"\"),\n * {@code null} or whitespace only.\n *\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <p>If all values are blank or the array is {@code null}\n * or empty then {@code null} is returned.</p>\n *\n * <pre>\n * StringUtils.firstNonBlank(null, null, null)     = null\n * StringUtils.firstNonBlank(null, \"\", \" \")        = null\n * StringUtils.firstNonBlank(\"abc\")                = \"abc\"\n * StringUtils.firstNonBlank(null, \"xyz\")          = \"xyz\"\n * StringUtils.firstNonBlank(null, \"\", \" \", \"xyz\") = \"xyz\"\n * StringUtils.firstNonBlank(null, \"xyz\", \"abc\")   = \"xyz\"\n * StringUtils.firstNonBlank()                     = null\n * </pre>\n *\n * @param <T> the specific kind of CharSequence\n * @param values  the values to test, may be {@code null} or empty\n * @return the first value from {@code values} which is not blank,\n *  or {@code null} if there are no non-blank values\n * @since 3.8\n */\n", "repo_name": "commons-lang-master/", "id": 1011, "method_signature": "T firstNonBlank(T[])", "filename": "StringUtils.firstNonBlank.json"}
{"callee_method_names": [], "method_name": "StringUtils.firstNonEmpty", "method_implementation": "{\n    if (values != null) {\n        for (final T val : values) {\n            if (isNotEmpty(val)) {\n                return val;\n            }\n        }\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Returns the first value in the array which is not empty.\n *\n * <p>If all values are empty or the array is {@code null}\n * or empty then {@code null} is returned.</p>\n *\n * <pre>\n * StringUtils.firstNonEmpty(null, null, null)   = null\n * StringUtils.firstNonEmpty(null, null, \"\")     = null\n * StringUtils.firstNonEmpty(null, \"\", \" \")      = \" \"\n * StringUtils.firstNonEmpty(\"abc\")              = \"abc\"\n * StringUtils.firstNonEmpty(null, \"xyz\")        = \"xyz\"\n * StringUtils.firstNonEmpty(\"\", \"xyz\")          = \"xyz\"\n * StringUtils.firstNonEmpty(null, \"xyz\", \"abc\") = \"xyz\"\n * StringUtils.firstNonEmpty()                   = null\n * </pre>\n *\n * @param <T> the specific kind of CharSequence\n * @param values  the values to test, may be {@code null} or empty\n * @return the first value from {@code values} which is not empty,\n *  or {@code null} if there are no non-empty values\n * @since 3.8\n */\n", "repo_name": "commons-lang-master/", "id": 1012, "method_signature": "T firstNonEmpty(T[])", "filename": "StringUtils.firstNonEmpty.json"}
{"callee_method_names": ["String.substring"], "method_name": "StringUtils.getCommonPrefix", "method_implementation": "{\n    if (ArrayUtils.isEmpty(strs)) {\n        return EMPTY;\n    }\n    final int smallestIndexOfDiff = indexOfDifference(strs);\n    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {\n        // all strings were identical\n        if (strs[0] == null) {\n            return EMPTY;\n        }\n        return strs[0];\n    }\n    if (smallestIndexOfDiff == 0) {\n        // there were no common initial characters\n        return EMPTY;\n    }\n    // we found a common initial character sequence\n    return strs[0].substring(0, smallestIndexOfDiff);\n}", "repo_id": "8", "comment": "/**\n * Compares all Strings in an array and returns the initial sequence of\n * characters that is common to all of them.\n *\n * <p>For example,\n * {@code getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) -&gt; \"i am a \"}</p>\n *\n * <pre>\n * StringUtils.getCommonPrefix(null) = \"\"\n * StringUtils.getCommonPrefix(new String[] {}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"abc\"}) = \"abc\"\n * StringUtils.getCommonPrefix(new String[] {null, null}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"\", \"\"}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"\", null}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}) = \"abc\"\n * StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}) = \"a\"\n * StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}) = \"ab\"\n * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}) = \"ab\"\n * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}) = \"\"\n * StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) = \"i am a \"\n * </pre>\n *\n * @param strs  array of String objects, entries may be null\n * @return the initial sequence of characters that are common to all Strings\n * in the array; empty String if the array is null, the elements are all null\n * or if there is no common prefix.\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1013, "method_signature": "String getCommonPrefix(String[])", "filename": "StringUtils.getCommonPrefix.json"}
{"callee_method_names": ["String.length", "String.charAt", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StringUtils.getDigits", "method_implementation": "{\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final StringBuilder strDigits = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        final char tempChar = str.charAt(i);\n        if (Character.isDigit(tempChar)) {\n            strDigits.append(tempChar);\n        }\n    }\n    return strDigits.toString();\n}", "repo_id": "8", "comment": "/**\n * Checks if a String {@code str} contains Unicode digits,\n * if yes then concatenate all the digits in {@code str} and return it as a String.\n *\n * <p>An empty (\"\") String will be returned if no digits found in {@code str}.</p>\n *\n * <pre>\n * StringUtils.getDigits(null)  = null\n * StringUtils.getDigits(\"\")    = \"\"\n * StringUtils.getDigits(\"abc\") = \"\"\n * StringUtils.getDigits(\"1000$\") = \"1000\"\n * StringUtils.getDigits(\"1123~45\") = \"112345\"\n * StringUtils.getDigits(\"(541) 754-3010\") = \"5417543010\"\n * StringUtils.getDigits(\"\\u0967\\u0968\\u0969\") = \"\\u0967\\u0968\\u0969\"\n * </pre>\n *\n * @param str the String to extract digits from, may be null\n * @return String with only digits,\n *           or an empty (\"\") String if no digits found,\n *           or {@code null} String if {@code str} is null\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1014, "method_signature": "String getDigits(String)", "filename": "StringUtils.getDigits.json"}
{"callee_method_names": ["CharSequence.toString", "CharSequence.toString", "String.length", "String.charAt", "String.length", "String.charAt"], "method_name": "StringUtils.getFuzzyDistance", "method_implementation": "{\n    if (term == null || query == null) {\n        throw new IllegalArgumentException(\"Strings must not be null\");\n    }\n    if (locale == null) {\n        throw new IllegalArgumentException(\"Locale must not be null\");\n    }\n    // fuzzy logic is case-insensitive. We normalize the Strings to lower\n    // case right from the start. Turning characters to lower case\n    // via Character.toLowerCase(char) is unfortunately insufficient\n    // as it does not accept a locale.\n    final String termLowerCase = term.toString().toLowerCase(locale);\n    final String queryLowerCase = query.toString().toLowerCase(locale);\n    // the resulting score\n    int score = 0;\n    // the position in the term which will be scanned next for potential\n    // query character matches\n    int termIndex = 0;\n    // index of the previously matched character in the term\n    int previousMatchingCharacterIndex = Integer.MIN_VALUE;\n    for (int queryIndex = 0; queryIndex < queryLowerCase.length(); queryIndex++) {\n        final char queryChar = queryLowerCase.charAt(queryIndex);\n        boolean termCharacterMatchFound = false;\n        for (; termIndex < termLowerCase.length() && !termCharacterMatchFound; termIndex++) {\n            final char termChar = termLowerCase.charAt(termIndex);\n            if (queryChar == termChar) {\n                // simple character matches result in one point\n                score++;\n                // subsequent character matches further improve\n                // the score.\n                if (previousMatchingCharacterIndex + 1 == termIndex) {\n                    score += 2;\n                }\n                previousMatchingCharacterIndex = termIndex;\n                // we can leave the nested loop. Every character in the\n                // query can match at most one character in the term.\n                termCharacterMatchFound = true;\n            }\n        }\n    }\n    return score;\n}", "repo_id": "8", "comment": "/**\n * Find the Fuzzy Distance which indicates the similarity score between two Strings.\n *\n * <p>This string matching algorithm is similar to the algorithms of editors such as Sublime Text,\n * TextMate, Atom and others. One point is given for every matched character. Subsequent\n * matches yield two bonus points. A higher score indicates a higher similarity.</p>\n *\n * <pre>\n * StringUtils.getFuzzyDistance(null, null, null)                                    = IllegalArgumentException\n * StringUtils.getFuzzyDistance(\"\", \"\", Locale.ENGLISH)                              = 0\n * StringUtils.getFuzzyDistance(\"Workshop\", \"b\", Locale.ENGLISH)                     = 0\n * StringUtils.getFuzzyDistance(\"Room\", \"o\", Locale.ENGLISH)                         = 1\n * StringUtils.getFuzzyDistance(\"Workshop\", \"w\", Locale.ENGLISH)                     = 1\n * StringUtils.getFuzzyDistance(\"Workshop\", \"ws\", Locale.ENGLISH)                    = 2\n * StringUtils.getFuzzyDistance(\"Workshop\", \"wo\", Locale.ENGLISH)                    = 4\n * StringUtils.getFuzzyDistance(\"Apache Software Foundation\", \"asf\", Locale.ENGLISH) = 3\n * </pre>\n *\n * @param term a full term that should be matched against, must not be null\n * @param query the query that will be matched against a term, must not be null\n * @param locale This string matching logic is case-insensitive. A locale is necessary to normalize\n *  both Strings to lower case.\n * @return result score\n * @throws IllegalArgumentException if either String input {@code null} or Locale input {@code null}\n * @since 3.4\n * @deprecated As of 3.6, use Apache Commons Text\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/FuzzyScore.html\">\n * FuzzyScore</a> instead\n */\n", "repo_name": "commons-lang-master/", "id": 1015, "method_signature": "int getFuzzyDistance(CharSequence, CharSequence, Locale)", "filename": "StringUtils.getFuzzyDistance.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.getJaroWinklerDistance", "method_implementation": "{\n    final double DEFAULT_SCALING_FACTOR = 0.1;\n    if (first == null || second == null) {\n        throw new IllegalArgumentException(\"Strings must not be null\");\n    }\n    final int[] mtp = matches(first, second);\n    final double m = mtp[0];\n    if (m == 0) {\n        return 0D;\n    }\n    final double j = (m / first.length() + m / second.length() + (m - mtp[1]) / m) / 3;\n    final double jw = j < 0.7D ? j : j + Math.min(DEFAULT_SCALING_FACTOR, 1D / mtp[3]) * mtp[2] * (1D - j);\n    return Math.round(jw * 100.0D) / 100.0D;\n}", "repo_id": "8", "comment": "/**\n * Find the Jaro Winkler Distance which indicates the similarity score between two Strings.\n *\n * <p>The Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.\n * Winkler increased this measure for matching initial characters.</p>\n *\n * <p>This implementation is based on the Jaro Winkler similarity algorithm\n * from <a href=\"https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\">https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>.</p>\n *\n * <pre>\n * StringUtils.getJaroWinklerDistance(null, null)          = IllegalArgumentException\n * StringUtils.getJaroWinklerDistance(\"\", \"\")              = 0.0\n * StringUtils.getJaroWinklerDistance(\"\", \"a\")             = 0.0\n * StringUtils.getJaroWinklerDistance(\"aaapppp\", \"\")       = 0.0\n * StringUtils.getJaroWinklerDistance(\"frog\", \"fog\")       = 0.93\n * StringUtils.getJaroWinklerDistance(\"fly\", \"ant\")        = 0.0\n * StringUtils.getJaroWinklerDistance(\"elephant\", \"hippo\") = 0.44\n * StringUtils.getJaroWinklerDistance(\"hippo\", \"elephant\") = 0.44\n * StringUtils.getJaroWinklerDistance(\"hippo\", \"zzzzzzzz\") = 0.0\n * StringUtils.getJaroWinklerDistance(\"hello\", \"hallo\")    = 0.88\n * StringUtils.getJaroWinklerDistance(\"ABC Corporation\", \"ABC Corp\") = 0.93\n * StringUtils.getJaroWinklerDistance(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.95\n * StringUtils.getJaroWinklerDistance(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.92\n * StringUtils.getJaroWinklerDistance(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.88\n * </pre>\n *\n * @param first the first String, must not be null\n * @param second the second String, must not be null\n * @return result distance\n * @throws IllegalArgumentException if either String input {@code null}\n * @since 3.3\n * @deprecated As of 3.6, use Apache Commons Text\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/JaroWinklerDistance.html\">\n * JaroWinklerDistance</a> instead\n */\n", "repo_name": "commons-lang-master/", "id": 1016, "method_signature": "double getJaroWinklerDistance(CharSequence, CharSequence)", "filename": "StringUtils.getJaroWinklerDistance.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "StringUtils.getLevenshteinDistance", "method_implementation": "{\n    if (s == null || t == null) {\n        throw new IllegalArgumentException(\"Strings must not be null\");\n    }\n    if (threshold < 0) {\n        throw new IllegalArgumentException(\"Threshold must not be negative\");\n    }\n    /*\n        This implementation only computes the distance if it's less than or equal to the\n        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded\n        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only\n        computing a diagonal stripe of width 2k + 1 of the cost table.\n        It is also possible to use this to compute the unbounded Levenshtein distance by starting\n        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where\n        d is the distance.\n\n        One subtlety comes from needing to ignore entries on the border of our stripe\n        eg.\n        p[] = |#|#|#|*\n        d[] =  *|#|#|#|\n        We must ignore the entry to the left of the leftmost member\n        We must ignore the entry above the rightmost member\n\n        Another subtlety comes from our stripe running off the matrix if the strings aren't\n        of the same size.  Since string s is always swapped to be the shorter of the two,\n        the stripe will always run off to the upper right instead of the lower left of the matrix.\n\n        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.\n        In this case we're going to walk a stripe of length 3.  The matrix would look like so:\n\n           1 2 3 4 5\n        1 |#|#| | | |\n        2 |#|#|#| | |\n        3 | |#|#|#| |\n        4 | | |#|#|#|\n        5 | | | |#|#|\n        6 | | | | |#|\n        7 | | | | | |\n\n        Note how the stripe leads off the table as there is no possible way to turn a string of length 5\n        into one of length 7 in edit distance of 1.\n\n        Additionally, this implementation decreases memory usage by using two\n        single-dimensional arrays and swapping them back and forth instead of allocating\n        an entire n by m matrix.  This requires a few minor changes, such as immediately returning\n        when it's detected that the stripe has run off the matrix and initially filling the arrays with\n        large values so that entries we don't compute are ignored.\n\n        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.\n         */\n    // length of s\n    int n = s.length();\n    // length of t\n    int m = t.length();\n    // if one string is empty, the edit distance is necessarily the length of the other\n    if (n == 0) {\n        return m <= threshold ? m : -1;\n    }\n    if (m == 0) {\n        return n <= threshold ? n : -1;\n    }\n    if (Math.abs(n - m) > threshold) {\n        // no need to calculate the distance if the length difference is greater than the threshold\n        return -1;\n    }\n    if (n > m) {\n        // swap the two strings to consume less memory\n        final CharSequence tmp = s;\n        s = t;\n        t = tmp;\n        n = m;\n        m = t.length();\n    }\n    // 'previous' cost array, horizontally\n    int[] p = new int[n + 1];\n    // cost array, horizontally\n    int[] d = new int[n + 1];\n    // placeholder to assist in swapping p and d\n    int[] tmp;\n    // fill in starting table values\n    final int boundary = Math.min(n, threshold) + 1;\n    for (int i = 0; i < boundary; i++) {\n        p[i] = i;\n    }\n    // these fills ensure that the value above the rightmost entry of our\n    // stripe will be ignored in following loop iterations\n    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n    Arrays.fill(d, Integer.MAX_VALUE);\n    // iterates through t\n    for (int j = 1; j <= m; j++) {\n        // jth character of t\n        final char jOfT = t.charAt(j - 1);\n        d[0] = j;\n        // compute stripe indices, constrain to array size\n        final int min = Math.max(1, j - threshold);\n        final int max = j > Integer.MAX_VALUE - threshold ? n : Math.min(n, j + threshold);\n        // the stripe may lead off of the table if s and t are of different sizes\n        if (min > max) {\n            return -1;\n        }\n        // ignore entry left of leftmost\n        if (min > 1) {\n            d[min - 1] = Integer.MAX_VALUE;\n        }\n        // iterates through [min, max] in s\n        for (int i = min; i <= max; i++) {\n            if (s.charAt(i - 1) == jOfT) {\n                // diagonally left and up\n                d[i] = p[i - 1];\n            } else {\n                // 1 + minimum of cell to the left, to the top, diagonally left and up\n                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n            }\n        }\n        // copy current distance counts to 'previous row' distance counts\n        tmp = p;\n        p = d;\n        d = tmp;\n    }\n    // if p[n] is greater than the threshold, there's no guarantee on it being the correct\n    // distance\n    if (p[n] <= threshold) {\n        return p[n];\n    }\n    return -1;\n}", "repo_id": "8", "comment": "/**\n * Find the Levenshtein distance between two Strings if it's less than or equal to a given\n * threshold.\n *\n * <p>This is the number of changes needed to change one String into\n * another, where each change is a single character modification (deletion,\n * insertion or substitution).</p>\n *\n * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield\n * and Chas Emerick's implementation of the Levenshtein distance algorithm from\n * <a href=\"https://web.archive.org/web/20120212021906/http%3A//www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n *\n * <pre>\n * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException\n * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException\n * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException\n * StringUtils.getLevenshteinDistance(\"\", \"\", 0)              = 0\n * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 8)       = 7\n * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 7)       = 7\n * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 6))      = -1\n * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\", 7) = 7\n * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\", 6) = -1\n * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\", 7) = 7\n * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\", 6) = -1\n * </pre>\n *\n * @param s  the first String, must not be null\n * @param t  the second String, must not be null\n * @param threshold the target threshold, must not be negative\n * @return result distance, or {@code -1} if the distance would be greater than the threshold\n * @throws IllegalArgumentException if either String input {@code null} or negative threshold\n * @deprecated As of 3.6, use Apache Commons Text\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/LevenshteinDistance.html\">\n * LevenshteinDistance</a> instead\n */\n", "repo_name": "commons-lang-master/", "id": 1018, "method_signature": "int getLevenshteinDistance(CharSequence, CharSequence, int)", "filename": "StringUtils.getLevenshteinDistance.json"}
{"callee_method_names": [], "method_name": "StringUtils.indexOf", "method_implementation": "{\n    if (isEmpty(seq)) {\n        return INDEX_NOT_FOUND;\n    }\n    return CharSequenceUtils.indexOf(seq, searchChar, startPos);\n}", "repo_id": "8", "comment": "/**\n * Returns the index within {@code seq} of the first occurrence of the\n * specified character, starting the search at the specified index.\n * <p>\n * If a character with value {@code searchChar} occurs in the\n * character sequence represented by the {@code seq} {@link CharSequence}\n * object at an index no smaller than {@code startPos}, then\n * the index of the first such occurrence is returned. For values\n * of {@code searchChar} in the range from 0 to 0xFFFF (inclusive),\n * this is the smallest value <i>k</i> such that:\n * <blockquote><pre>\n * (this.charAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &gt;= startPos)\n * </pre></blockquote>\n * is true. For other values of {@code searchChar}, it is the\n * smallest value <i>k</i> such that:\n * <blockquote><pre>\n * (this.codePointAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &gt;= startPos)\n * </pre></blockquote>\n * is true. In either case, if no such character occurs in {@code seq}\n * at or after position {@code startPos}, then\n * {@code -1} is returned.\n *\n * <p>\n * There is no restriction on the value of {@code startPos}. If it\n * is negative, it has the same effect as if it were zero: this entire\n * string may be searched. If it is greater than the length of this\n * string, it has the same effect as if it were equal to the length of\n * this string: {@code (INDEX_NOT_FOUND) -1} is returned. Furthermore, a\n * {@code null} or empty (\"\") CharSequence will\n * return {@code (INDEX_NOT_FOUND) -1}.\n *\n * <p>All indices are specified in {@code char} values\n * (Unicode code units).\n *\n * <pre>\n * StringUtils.indexOf(null, *, *)          = -1\n * StringUtils.indexOf(\"\", *, *)            = -1\n * StringUtils.indexOf(\"aabaabaa\", 'b', 0)  = 2\n * StringUtils.indexOf(\"aabaabaa\", 'b', 3)  = 5\n * StringUtils.indexOf(\"aabaabaa\", 'b', 9)  = -1\n * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n * </pre>\n *\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search character (always &ge; startPos),\n *  -1 if no match or {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)\n * @since 3.6 Updated {@link CharSequenceUtils} call to behave more like {@link String}\n */\n", "repo_name": "commons-lang-master/", "id": 1022, "method_signature": "int indexOf(CharSequence, int, int)", "filename": "StringUtils.indexOf.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "StringUtils.indexOfAny", "method_implementation": "{\n    if (isEmpty(cs) || isEmpty(searchChars)) {\n        return INDEX_NOT_FOUND;\n    }\n    return indexOfAny(cs, searchChars.toCharArray());\n}", "repo_id": "8", "comment": "/**\n * Search a CharSequence to find the first index of any\n * character in the given set of characters.\n *\n * <p>A {@code null} String will return {@code -1}.\n * A {@code null} search string will return {@code -1}.</p>\n *\n * <pre>\n * StringUtils.indexOfAny(null, *)            = -1\n * StringUtils.indexOfAny(\"\", *)              = -1\n * StringUtils.indexOfAny(*, null)            = -1\n * StringUtils.indexOfAny(*, \"\")              = -1\n * StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") = 0\n * StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") = 3\n * StringUtils.indexOfAny(\"aba\", \"z\")         = -1\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)\n */\n", "repo_name": "commons-lang-master/", "id": 1025, "method_signature": "int indexOfAny(CharSequence, String)", "filename": "StringUtils.indexOfAny.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "StringUtils.indexOfAnyBut", "method_implementation": "{\n    if (isEmpty(seq) || isEmpty(searchChars)) {\n        return INDEX_NOT_FOUND;\n    }\n    final int strLen = seq.length();\n    for (int i = 0; i < strLen; i++) {\n        final char ch = seq.charAt(i);\n        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;\n        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n            final char ch2 = seq.charAt(i + 1);\n            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {\n                return i;\n            }\n        } else if (!chFound) {\n            return i;\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Search a CharSequence to find the first index of any\n * character not in the given set of characters.\n *\n * <p>A {@code null} CharSequence will return {@code -1}.\n * A {@code null} or empty search string will return {@code -1}.</p>\n *\n * <pre>\n * StringUtils.indexOfAnyBut(null, *)            = -1\n * StringUtils.indexOfAnyBut(\"\", *)              = -1\n * StringUtils.indexOfAnyBut(*, null)            = -1\n * StringUtils.indexOfAnyBut(*, \"\")              = -1\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = -1\n * StringUtils.indexOfAnyBut(\"aba\", \"ab\")        = -1\n * </pre>\n *\n * @param seq  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1027, "method_signature": "int indexOfAnyBut(CharSequence, CharSequence)", "filename": "StringUtils.indexOfAnyBut.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.indexOfDifference", "method_implementation": "{\n    if (cs1 == cs2) {\n        return INDEX_NOT_FOUND;\n    }\n    if (cs1 == null || cs2 == null) {\n        return 0;\n    }\n    int i;\n    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n        if (cs1.charAt(i) != cs2.charAt(i)) {\n            break;\n        }\n    }\n    if (i < cs2.length() || i < cs1.length()) {\n        return i;\n    }\n    return INDEX_NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Compares two CharSequences, and returns the index at which the\n * CharSequences begin to differ.\n *\n * <p>For example,\n * {@code indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7}</p>\n *\n * <pre>\n * StringUtils.indexOfDifference(null, null) = -1\n * StringUtils.indexOfDifference(\"\", \"\") = -1\n * StringUtils.indexOfDifference(\"\", \"abc\") = 0\n * StringUtils.indexOfDifference(\"abc\", \"\") = 0\n * StringUtils.indexOfDifference(\"abc\", \"abc\") = -1\n * StringUtils.indexOfDifference(\"ab\", \"abxyz\") = 2\n * StringUtils.indexOfDifference(\"abcde\", \"abxyz\") = 2\n * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n * </pre>\n *\n * @param cs1  the first CharSequence, may be null\n * @param cs2  the second CharSequence, may be null\n * @return the index where cs1 and cs2 begin to differ; -1 if they are equal\n * @since 2.0\n * @since 3.0 Changed signature from indexOfDifference(String, String) to\n * indexOfDifference(CharSequence, CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1029, "method_signature": "int indexOfDifference(CharSequence, CharSequence)", "filename": "StringUtils.indexOfDifference.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.indexOfIgnoreCase", "method_implementation": "{\n    if (str == null || searchStr == null) {\n        return INDEX_NOT_FOUND;\n    }\n    if (startPos < 0) {\n        startPos = 0;\n    }\n    final int endLimit = str.length() - searchStr.length() + 1;\n    if (startPos > endLimit) {\n        return INDEX_NOT_FOUND;\n    }\n    if (searchStr.length() == 0) {\n        return startPos;\n    }\n    for (int i = startPos; i < endLimit; i++) {\n        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n            return i;\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Case in-sensitive find of the first index within a CharSequence\n * from the specified position.\n *\n * <p>A {@code null} CharSequence will return {@code -1}.\n * A negative start position is treated as zero.\n * An empty (\"\") search CharSequence always matches.\n * A start position greater than the string length only matches\n * an empty search CharSequence.</p>\n *\n * <pre>\n * StringUtils.indexOfIgnoreCase(null, *, *)          = -1\n * StringUtils.indexOfIgnoreCase(*, null, *)          = -1\n * StringUtils.indexOfIgnoreCase(\"\", \"\", 0)           = 0\n * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = 2\n * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"AB\", 0) = 1\n * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 3)  = 5\n * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = -1\n * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = 2\n * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"\", 2)   = 2\n * StringUtils.indexOfIgnoreCase(\"abc\", \"\", 9)        = -1\n * </pre>\n *\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @param startPos  the start position, negative treated as zero\n * @return the first index of the search CharSequence (always &ge; startPos),\n *  -1 if no match or {@code null} string input\n * @since 2.5\n * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)\n */\n", "repo_name": "commons-lang-master/", "id": 1030, "method_signature": "int indexOfIgnoreCase(CharSequence, CharSequence, int)", "filename": "StringUtils.indexOfIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtils.isAllBlank", "method_implementation": "{\n    if (ArrayUtils.isEmpty(css)) {\n        return true;\n    }\n    for (final CharSequence cs : css) {\n        if (isNotBlank(cs)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if all of the CharSequences are empty (\"\"), null or whitespace only.\n *\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <pre>\n * StringUtils.isAllBlank(null)             = true\n * StringUtils.isAllBlank(null, \"foo\")      = false\n * StringUtils.isAllBlank(null, null)       = true\n * StringUtils.isAllBlank(\"\", \"bar\")        = false\n * StringUtils.isAllBlank(\"bob\", \"\")        = false\n * StringUtils.isAllBlank(\"  bob  \", null)  = false\n * StringUtils.isAllBlank(\" \", \"bar\")       = false\n * StringUtils.isAllBlank(\"foo\", \"bar\")     = false\n * StringUtils.isAllBlank(new String[] {})  = true\n * </pre>\n *\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if all of the CharSequences are empty or null or whitespace only\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1031, "method_signature": "boolean isAllBlank(CharSequence[])", "filename": "StringUtils.isAllBlank.json"}
{"callee_method_names": [], "method_name": "StringUtils.isAllEmpty", "method_implementation": "{\n    if (ArrayUtils.isEmpty(css)) {\n        return true;\n    }\n    for (final CharSequence cs : css) {\n        if (isNotEmpty(cs)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if all of the CharSequences are empty (\"\") or null.\n *\n * <pre>\n * StringUtils.isAllEmpty(null)             = true\n * StringUtils.isAllEmpty(null, \"\")         = true\n * StringUtils.isAllEmpty(new String[] {})  = true\n * StringUtils.isAllEmpty(null, \"foo\")      = false\n * StringUtils.isAllEmpty(\"\", \"bar\")        = false\n * StringUtils.isAllEmpty(\"bob\", \"\")        = false\n * StringUtils.isAllEmpty(\"  bob  \", null)  = false\n * StringUtils.isAllEmpty(\" \", \"bar\")       = false\n * StringUtils.isAllEmpty(\"foo\", \"bar\")     = false\n * </pre>\n *\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if all of the CharSequences are empty or null\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1032, "method_signature": "boolean isAllEmpty(CharSequence[])", "filename": "StringUtils.isAllEmpty.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isAllLowerCase", "method_implementation": "{\n    if (isEmpty(cs)) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isLowerCase(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only lowercase characters.\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code false}.</p>\n *\n * <pre>\n * StringUtils.isAllLowerCase(null)   = false\n * StringUtils.isAllLowerCase(\"\")     = false\n * StringUtils.isAllLowerCase(\"  \")   = false\n * StringUtils.isAllLowerCase(\"abc\")  = true\n * StringUtils.isAllLowerCase(\"abC\")  = false\n * StringUtils.isAllLowerCase(\"ab c\") = false\n * StringUtils.isAllLowerCase(\"ab1c\") = false\n * StringUtils.isAllLowerCase(\"ab/c\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains lowercase characters, and is non-null\n * @since 2.5\n * @since 3.0 Changed signature from isAllLowerCase(String) to isAllLowerCase(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1033, "method_signature": "boolean isAllLowerCase(CharSequence)", "filename": "StringUtils.isAllLowerCase.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isAllUpperCase", "method_implementation": "{\n    if (isEmpty(cs)) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isUpperCase(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only uppercase characters.\n *\n * <p>{@code null} will return {@code false}.\n * An empty String (length()=0) will return {@code false}.</p>\n *\n * <pre>\n * StringUtils.isAllUpperCase(null)   = false\n * StringUtils.isAllUpperCase(\"\")     = false\n * StringUtils.isAllUpperCase(\"  \")   = false\n * StringUtils.isAllUpperCase(\"ABC\")  = true\n * StringUtils.isAllUpperCase(\"aBC\")  = false\n * StringUtils.isAllUpperCase(\"A C\")  = false\n * StringUtils.isAllUpperCase(\"A1C\")  = false\n * StringUtils.isAllUpperCase(\"A/C\")  = false\n * </pre>\n *\n * @param cs the CharSequence to check, may be null\n * @return {@code true} if only contains uppercase characters, and is non-null\n * @since 2.5\n * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1034, "method_signature": "boolean isAllUpperCase(CharSequence)", "filename": "StringUtils.isAllUpperCase.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isAlpha", "method_implementation": "{\n    if (isEmpty(cs)) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isLetter(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only Unicode letters.\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code false}.</p>\n *\n * <pre>\n * StringUtils.isAlpha(null)   = false\n * StringUtils.isAlpha(\"\")     = false\n * StringUtils.isAlpha(\"  \")   = false\n * StringUtils.isAlpha(\"abc\")  = true\n * StringUtils.isAlpha(\"ab2c\") = false\n * StringUtils.isAlpha(\"ab-c\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters, and is non-null\n * @since 3.0 Changed signature from isAlpha(String) to isAlpha(CharSequence)\n * @since 3.0 Changed \"\" to return false and not true\n */\n", "repo_name": "commons-lang-master/", "id": 1035, "method_signature": "boolean isAlpha(CharSequence)", "filename": "StringUtils.isAlpha.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isAlphaSpace", "method_implementation": "{\n    if (cs == null) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        final char nowChar = cs.charAt(i);\n        if (nowChar != ' ' && !Character.isLetter(nowChar)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only Unicode letters and\n * space (' ').\n *\n * <p>{@code null} will return {@code false}\n * An empty CharSequence (length()=0) will return {@code true}.</p>\n *\n * <pre>\n * StringUtils.isAlphaSpace(null)   = false\n * StringUtils.isAlphaSpace(\"\")     = true\n * StringUtils.isAlphaSpace(\"  \")   = true\n * StringUtils.isAlphaSpace(\"abc\")  = true\n * StringUtils.isAlphaSpace(\"ab c\") = true\n * StringUtils.isAlphaSpace(\"ab2c\") = false\n * StringUtils.isAlphaSpace(\"ab-c\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters and space,\n *  and is non-null\n * @since 3.0 Changed signature from isAlphaSpace(String) to isAlphaSpace(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1038, "method_signature": "boolean isAlphaSpace(CharSequence)", "filename": "StringUtils.isAlphaSpace.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isAlphanumeric", "method_implementation": "{\n    if (isEmpty(cs)) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isLetterOrDigit(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only Unicode letters or digits.\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code false}.</p>\n *\n * <pre>\n * StringUtils.isAlphanumeric(null)   = false\n * StringUtils.isAlphanumeric(\"\")     = false\n * StringUtils.isAlphanumeric(\"  \")   = false\n * StringUtils.isAlphanumeric(\"abc\")  = true\n * StringUtils.isAlphanumeric(\"ab c\") = false\n * StringUtils.isAlphanumeric(\"ab2c\") = true\n * StringUtils.isAlphanumeric(\"ab-c\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters or digits,\n *  and is non-null\n * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)\n * @since 3.0 Changed \"\" to return false and not true\n */\n", "repo_name": "commons-lang-master/", "id": 1036, "method_signature": "boolean isAlphanumeric(CharSequence)", "filename": "StringUtils.isAlphanumeric.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isAlphanumericSpace", "method_implementation": "{\n    if (cs == null) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        final char nowChar = cs.charAt(i);\n        if (nowChar != ' ' && !Character.isLetterOrDigit(nowChar)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only Unicode letters, digits\n * or space ({@code ' '}).\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code true}.</p>\n *\n * <pre>\n * StringUtils.isAlphanumericSpace(null)   = false\n * StringUtils.isAlphanumericSpace(\"\")     = true\n * StringUtils.isAlphanumericSpace(\"  \")   = true\n * StringUtils.isAlphanumericSpace(\"abc\")  = true\n * StringUtils.isAlphanumericSpace(\"ab c\") = true\n * StringUtils.isAlphanumericSpace(\"ab2c\") = true\n * StringUtils.isAlphanumericSpace(\"ab-c\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains letters, digits or space,\n *  and is non-null\n * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1037, "method_signature": "boolean isAlphanumericSpace(CharSequence)", "filename": "StringUtils.isAlphanumericSpace.json"}
{"callee_method_names": [], "method_name": "StringUtils.isAnyBlank", "method_implementation": "{\n    if (ArrayUtils.isEmpty(css)) {\n        return false;\n    }\n    for (final CharSequence cs : css) {\n        if (isBlank(cs)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Checks if any of the CharSequences are empty (\"\") or null or whitespace only.\n *\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <pre>\n * StringUtils.isAnyBlank((String) null)    = true\n * StringUtils.isAnyBlank((String[]) null)  = false\n * StringUtils.isAnyBlank(null, \"foo\")      = true\n * StringUtils.isAnyBlank(null, null)       = true\n * StringUtils.isAnyBlank(\"\", \"bar\")        = true\n * StringUtils.isAnyBlank(\"bob\", \"\")        = true\n * StringUtils.isAnyBlank(\"  bob  \", null)  = true\n * StringUtils.isAnyBlank(\" \", \"bar\")       = true\n * StringUtils.isAnyBlank(new String[] {})  = false\n * StringUtils.isAnyBlank(new String[]{\"\"}) = true\n * StringUtils.isAnyBlank(\"foo\", \"bar\")     = false\n * </pre>\n *\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if any of the CharSequences are empty or null or whitespace only\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 1039, "method_signature": "boolean isAnyBlank(CharSequence[])", "filename": "StringUtils.isAnyBlank.json"}
{"callee_method_names": [], "method_name": "StringUtils.isAnyEmpty", "method_implementation": "{\n    if (ArrayUtils.isEmpty(css)) {\n        return false;\n    }\n    for (final CharSequence cs : css) {\n        if (isEmpty(cs)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Checks if any of the CharSequences are empty (\"\") or null.\n *\n * <pre>\n * StringUtils.isAnyEmpty((String) null)    = true\n * StringUtils.isAnyEmpty((String[]) null)  = false\n * StringUtils.isAnyEmpty(null, \"foo\")      = true\n * StringUtils.isAnyEmpty(\"\", \"bar\")        = true\n * StringUtils.isAnyEmpty(\"bob\", \"\")        = true\n * StringUtils.isAnyEmpty(\"  bob  \", null)  = true\n * StringUtils.isAnyEmpty(\" \", \"bar\")       = false\n * StringUtils.isAnyEmpty(\"foo\", \"bar\")     = false\n * StringUtils.isAnyEmpty(new String[]{})   = false\n * StringUtils.isAnyEmpty(new String[]{\"\"}) = true\n * </pre>\n *\n * @param css  the CharSequences to check, may be null or empty\n * @return {@code true} if any of the CharSequences are empty or null\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 1040, "method_signature": "boolean isAnyEmpty(CharSequence[])", "filename": "StringUtils.isAnyEmpty.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isAsciiPrintable", "method_implementation": "{\n    if (cs == null) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        if (!CharUtils.isAsciiPrintable(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only ASCII printable characters.\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code true}.</p>\n *\n * <pre>\n * StringUtils.isAsciiPrintable(null)     = false\n * StringUtils.isAsciiPrintable(\"\")       = true\n * StringUtils.isAsciiPrintable(\" \")      = true\n * StringUtils.isAsciiPrintable(\"Ceki\")   = true\n * StringUtils.isAsciiPrintable(\"ab2c\")   = true\n * StringUtils.isAsciiPrintable(\"!ab-c~\") = true\n * StringUtils.isAsciiPrintable(\"\\u0020\") = true\n * StringUtils.isAsciiPrintable(\"\\u0021\") = true\n * StringUtils.isAsciiPrintable(\"\\u007e\") = true\n * StringUtils.isAsciiPrintable(\"\\u007f\") = false\n * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n * </pre>\n *\n * @param cs the CharSequence to check, may be null\n * @return {@code true} if every character is in the range\n *  32 through 126\n * @since 2.1\n * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1041, "method_signature": "boolean isAsciiPrintable(CharSequence)", "filename": "StringUtils.isAsciiPrintable.json"}
{"callee_method_names": ["CharSequence.charAt"], "method_name": "StringUtils.isBlank", "method_implementation": "{\n    final int strLen = length(cs);\n    if (strLen == 0) {\n        return true;\n    }\n    for (int i = 0; i < strLen; i++) {\n        if (!Character.isWhitespace(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if a CharSequence is empty (\"\"), null or whitespace only.\n *\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <pre>\n * StringUtils.isBlank(null)      = true\n * StringUtils.isBlank(\"\")        = true\n * StringUtils.isBlank(\" \")       = true\n * StringUtils.isBlank(\"bob\")     = false\n * StringUtils.isBlank(\"  bob  \") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if the CharSequence is null, empty or whitespace only\n * @since 2.0\n * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1042, "method_signature": "boolean isBlank(CharSequence)", "filename": "StringUtils.isBlank.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isMixedCase", "method_implementation": "{\n    if (isEmpty(cs) || cs.length() == 1) {\n        return false;\n    }\n    boolean containsUppercase = false;\n    boolean containsLowercase = false;\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        final char nowChar = cs.charAt(i);\n        if (Character.isUpperCase(nowChar)) {\n            containsUppercase = true;\n        } else if (Character.isLowerCase(nowChar)) {\n            containsLowercase = true;\n        }\n        if (containsUppercase && containsLowercase) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains mixed casing of both uppercase and lowercase characters.\n *\n * <p>{@code null} will return {@code false}. An empty CharSequence ({@code length()=0}) will return\n * {@code false}.</p>\n *\n * <pre>\n * StringUtils.isMixedCase(null)    = false\n * StringUtils.isMixedCase(\"\")      = false\n * StringUtils.isMixedCase(\" \")     = false\n * StringUtils.isMixedCase(\"ABC\")   = false\n * StringUtils.isMixedCase(\"abc\")   = false\n * StringUtils.isMixedCase(\"aBc\")   = true\n * StringUtils.isMixedCase(\"A c\")   = true\n * StringUtils.isMixedCase(\"A1c\")   = true\n * StringUtils.isMixedCase(\"a/C\")   = true\n * StringUtils.isMixedCase(\"aC\\t\")  = true\n * </pre>\n *\n * @param cs the CharSequence to check, may be null\n * @return {@code true} if the CharSequence contains both uppercase and lowercase characters\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1043, "method_signature": "boolean isMixedCase(CharSequence)", "filename": "StringUtils.isMixedCase.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isNumeric", "method_implementation": "{\n    if (isEmpty(cs)) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isDigit(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only Unicode digits.\n * A decimal point is not a Unicode digit and returns false.\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code false}.</p>\n *\n * <p>Note that the method does not allow for a leading sign, either positive or negative.\n * Also, if a String passes the numeric test, it may still generate a NumberFormatException\n * when parsed by Integer.parseInt or Long.parseLong, e.g. if the value is outside the range\n * for int or long respectively.</p>\n *\n * <pre>\n * StringUtils.isNumeric(null)   = false\n * StringUtils.isNumeric(\"\")     = false\n * StringUtils.isNumeric(\"  \")   = false\n * StringUtils.isNumeric(\"123\")  = true\n * StringUtils.isNumeric(\"\\u0967\\u0968\\u0969\")  = true\n * StringUtils.isNumeric(\"12 3\") = false\n * StringUtils.isNumeric(\"ab2c\") = false\n * StringUtils.isNumeric(\"12-3\") = false\n * StringUtils.isNumeric(\"12.3\") = false\n * StringUtils.isNumeric(\"-123\") = false\n * StringUtils.isNumeric(\"+123\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains digits, and is non-null\n * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)\n * @since 3.0 Changed \"\" to return false and not true\n */\n", "repo_name": "commons-lang-master/", "id": 1044, "method_signature": "boolean isNumeric(CharSequence)", "filename": "StringUtils.isNumeric.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isNumericSpace", "method_implementation": "{\n    if (cs == null) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        final char nowChar = cs.charAt(i);\n        if (nowChar != ' ' && !Character.isDigit(nowChar)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only Unicode digits or space\n * ({@code ' '}).\n * A decimal point is not a Unicode digit and returns false.\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code true}.</p>\n *\n * <pre>\n * StringUtils.isNumericSpace(null)   = false\n * StringUtils.isNumericSpace(\"\")     = true\n * StringUtils.isNumericSpace(\"  \")   = true\n * StringUtils.isNumericSpace(\"123\")  = true\n * StringUtils.isNumericSpace(\"12 3\") = true\n * StringUtils.isNumericSpace(\"\\u0967\\u0968\\u0969\")  = true\n * StringUtils.isNumericSpace(\"\\u0967\\u0968 \\u0969\")  = true\n * StringUtils.isNumericSpace(\"ab2c\") = false\n * StringUtils.isNumericSpace(\"12-3\") = false\n * StringUtils.isNumericSpace(\"12.3\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains digits or space,\n *  and is non-null\n * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1045, "method_signature": "boolean isNumericSpace(CharSequence)", "filename": "StringUtils.isNumericSpace.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.isWhitespace", "method_implementation": "{\n    if (cs == null) {\n        return false;\n    }\n    final int sz = cs.length();\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the CharSequence contains only whitespace.\n *\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <p>{@code null} will return {@code false}.\n * An empty CharSequence (length()=0) will return {@code true}.</p>\n *\n * <pre>\n * StringUtils.isWhitespace(null)   = false\n * StringUtils.isWhitespace(\"\")     = true\n * StringUtils.isWhitespace(\"  \")   = true\n * StringUtils.isWhitespace(\"abc\")  = false\n * StringUtils.isWhitespace(\"ab2c\") = false\n * StringUtils.isWhitespace(\"ab-c\") = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if only contains whitespace, and is non-null\n * @since 2.0\n * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1046, "method_signature": "boolean isWhitespace(CharSequence)", "filename": "StringUtils.isWhitespace.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.substring", "StringBuilder.length"], "method_name": "StringUtils.join", "method_implementation": "{\n    if (array == null) {\n        return null;\n    }\n    if (endIndex - startIndex <= 0) {\n        return EMPTY;\n    }\n    final StringBuilder stringBuilder = new StringBuilder();\n    for (int i = startIndex; i < endIndex; i++) {\n        stringBuilder.append(array[i]).append(delimiter);\n    }\n    return stringBuilder.substring(0, stringBuilder.length() - 1);\n}", "repo_id": "8", "comment": "/**\n * Joins the elements of the provided array into a single String containing the provided list of elements.\n *\n * <p>\n * No delimiter is added before or after the list. Null objects or empty strings within the array are represented\n * by empty strings.\n * </p>\n *\n * <pre>\n * StringUtils.join(null, *)               = null\n * StringUtils.join([], *)                 = \"\"\n * StringUtils.join([null], *)             = \"\"\n * StringUtils.join([1, 2, 3], ';')  = \"1;2;3\"\n * StringUtils.join([1, 2, 3], null) = \"123\"\n * </pre>\n *\n * @param array\n *            the array of values to join together, may be null\n * @param delimiter\n *            the separator character to use\n * @param startIndex\n *            the first index to start joining from. It is an error to pass in a start index past the end of the\n *            array\n * @param endIndex\n *            the index to stop joining from (exclusive). It is an error to pass in an end index past the end of\n *            the array\n * @return the joined String, {@code null} if null array input\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 1067, "method_signature": "String join(short[], char, int, int)", "filename": "StringUtils.join.json"}
{"callee_method_names": [], "method_name": "StringUtils.joinWith", "method_implementation": "{\n    if (array == null) {\n        throw new IllegalArgumentException(\"Object varargs must not be null\");\n    }\n    return join(array, delimiter);\n}", "repo_id": "8", "comment": "/**\n * Joins the elements of the provided varargs into a\n * single String containing the provided elements.\n *\n * <p>No delimiter is added before or after the list.\n * {@code null} elements and separator are treated as empty Strings (\"\").</p>\n *\n * <pre>\n * StringUtils.joinWith(\",\", {\"a\", \"b\"})        = \"a,b\"\n * StringUtils.joinWith(\",\", {\"a\", \"b\",\"\"})     = \"a,b,\"\n * StringUtils.joinWith(\",\", {\"a\", null, \"b\"})  = \"a,,b\"\n * StringUtils.joinWith(null, {\"a\", \"b\"})       = \"ab\"\n * </pre>\n *\n * @param delimiter the separator character to use, null treated as \"\"\n * @param array the varargs providing the values to join together. {@code null} elements are treated as \"\"\n * @return the joined String.\n * @throws IllegalArgumentException if a null varargs is provided\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1068, "method_signature": "String joinWith(String, Object[])", "filename": "StringUtils.joinWith.json"}
{"callee_method_names": [], "method_name": "StringUtils.lastIndexOf", "method_implementation": "{\n    if (isEmpty(seq)) {\n        return INDEX_NOT_FOUND;\n    }\n    return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);\n}", "repo_id": "8", "comment": "/**\n * Returns the index within {@code seq} of the last occurrence of\n * the specified character, searching backward starting at the\n * specified index. For values of {@code searchChar} in the range\n * from 0 to 0xFFFF (inclusive), the index returned is the largest\n * value <i>k</i> such that:\n * <blockquote><pre>\n * (this.charAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= startPos)\n * </pre></blockquote>\n * is true. For other values of {@code searchChar}, it is the\n * largest value <i>k</i> such that:\n * <blockquote><pre>\n * (this.codePointAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= startPos)\n * </pre></blockquote>\n * is true. In either case, if no such character occurs in {@code seq}\n * at or before position {@code startPos}, then\n * {@code -1} is returned. Furthermore, a {@code null} or empty (\"\")\n * {@link CharSequence} will return {@code -1}. A start position greater\n * than the string length searches the whole string.\n * The search starts at the {@code startPos} and works backwards;\n * matches starting after the start position are ignored.\n *\n * <p>All indices are specified in {@code char} values\n * (Unicode code units).\n *\n * <pre>\n * StringUtils.lastIndexOf(null, *, *)          = -1\n * StringUtils.lastIndexOf(\"\", *,  *)           = -1\n * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8)  = 5\n * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 4)  = 2\n * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 0)  = -1\n * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9)  = 5\n * StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1) = -1\n * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n * </pre>\n *\n * @param seq  the CharSequence to check, may be null\n * @param searchChar  the character to find\n * @param startPos  the start position\n * @return the last index of the search character (always &le; startPos),\n *  -1 if no match or {@code null} string input\n * @since 2.0\n * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)\n */\n", "repo_name": "commons-lang-master/", "id": 1071, "method_signature": "int lastIndexOf(CharSequence, int, int)", "filename": "StringUtils.lastIndexOf.json"}
{"callee_method_names": ["CharSequence.length"], "method_name": "StringUtils.lastIndexOfAny", "method_implementation": "{\n    if (str == null || searchStrs == null) {\n        return INDEX_NOT_FOUND;\n    }\n    int ret = INDEX_NOT_FOUND;\n    int tmp;\n    for (final CharSequence search : searchStrs) {\n        if (search == null) {\n            continue;\n        }\n        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());\n        if (tmp > ret) {\n            ret = tmp;\n        }\n    }\n    return ret;\n}", "repo_id": "8", "comment": "/**\n * Find the latest index of any substring in a set of potential substrings.\n *\n * <p>A {@code null} CharSequence will return {@code -1}.\n * A {@code null} search array will return {@code -1}.\n * A {@code null} or zero length search array entry will be ignored,\n * but a search array containing \"\" will return the length of {@code str}\n * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>\n *\n * <pre>\n * StringUtils.lastIndexOfAny(null, *)                    = -1\n * StringUtils.lastIndexOfAny(*, null)                    = -1\n * StringUtils.lastIndexOfAny(*, [])                      = -1\n * StringUtils.lastIndexOfAny(*, [null])                  = -1\n * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\", \"cd\"]) = 6\n * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\", \"ab\"]) = 6\n * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\", \"op\"]) = -1\n * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\", \"op\"]) = -1\n * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\", \"\"])   = 10\n * </pre>\n *\n * @param str  the CharSequence to check, may be null\n * @param searchStrs  the CharSequences to search for, may be null\n * @return the last index of any of the CharSequences, -1 if no match\n * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)\n */\n", "repo_name": "commons-lang-master/", "id": 1072, "method_signature": "int lastIndexOfAny(CharSequence, CharSequence[])", "filename": "StringUtils.lastIndexOfAny.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.lastIndexOfIgnoreCase", "method_implementation": "{\n    if (str == null || searchStr == null) {\n        return INDEX_NOT_FOUND;\n    }\n    final int searchStrLength = searchStr.length();\n    final int strLength = str.length();\n    if (startPos > strLength - searchStrLength) {\n        startPos = strLength - searchStrLength;\n    }\n    if (startPos < 0) {\n        return INDEX_NOT_FOUND;\n    }\n    if (searchStrLength == 0) {\n        return startPos;\n    }\n    for (int i = startPos; i >= 0; i--) {\n        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStrLength)) {\n            return i;\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "repo_id": "8", "comment": "/**\n * Case in-sensitive find of the last index within a CharSequence\n * from the specified position.\n *\n * <p>A {@code null} CharSequence will return {@code -1}.\n * A negative start position returns {@code -1}.\n * An empty (\"\") search CharSequence always matches unless the start position is negative.\n * A start position greater than the string length searches the whole string.\n * The search starts at the startPos and works backwards; matches starting after the start\n * position are ignored.\n * </p>\n *\n * <pre>\n * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1\n * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1\n * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 8)  = 7\n * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 8)  = 5\n * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\", 8) = 4\n * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = 5\n * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = -1\n * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = -1\n * </pre>\n *\n * @param str  the CharSequence to check, may be null\n * @param searchStr  the CharSequence to find, may be null\n * @param startPos  the start position\n * @return the last index of the search CharSequence (always &le; startPos),\n *  -1 if no match or {@code null} input\n * @since 2.5\n * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)\n */\n", "repo_name": "commons-lang-master/", "id": 1074, "method_signature": "int lastIndexOfIgnoreCase(CharSequence, CharSequence, int)", "filename": "StringUtils.lastIndexOfIgnoreCase.json"}
{"callee_method_names": ["String.length", "String.substring"], "method_name": "StringUtils.left", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (len < 0) {\n        return EMPTY;\n    }\n    if (str.length() <= len) {\n        return str;\n    }\n    return str.substring(0, len);\n}", "repo_id": "8", "comment": "/**\n * Gets the leftmost {@code len} characters of a String.\n *\n * <p>If {@code len} characters are not available, or the\n * String is {@code null}, the String will be returned without\n * an exception. An empty String is returned if len is negative.</p>\n *\n * <pre>\n * StringUtils.left(null, *)    = null\n * StringUtils.left(*, -ve)     = \"\"\n * StringUtils.left(\"\", *)      = \"\"\n * StringUtils.left(\"abc\", 0)   = \"\"\n * StringUtils.left(\"abc\", 2)   = \"ab\"\n * StringUtils.left(\"abc\", 4)   = \"abc\"\n * </pre>\n *\n * @param str  the String to get the leftmost characters from, may be null\n * @param len  the length of the required String\n * @return the leftmost characters, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1075, "method_signature": "String left(String, int)", "filename": "StringUtils.left.json"}
{"callee_method_names": ["String.length", "String.length", "String.charAt", "String.concat", "String.substring", "String.toCharArray"], "method_name": "StringUtils.leftPad", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (isEmpty(padStr)) {\n        padStr = SPACE;\n    }\n    final int padLen = padStr.length();\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        // returns original String when possible\n        return str;\n    }\n    if (padLen == 1 && pads <= PAD_LIMIT) {\n        return leftPad(str, size, padStr.charAt(0));\n    }\n    if (pads == padLen) {\n        return padStr.concat(str);\n    }\n    if (pads < padLen) {\n        return padStr.substring(0, pads).concat(str);\n    }\n    final char[] padding = new char[pads];\n    final char[] padChars = padStr.toCharArray();\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChars[i % padLen];\n    }\n    return new String(padding).concat(str);\n}", "repo_id": "8", "comment": "/**\n * Left pad a String with a specified String.\n *\n * <p>Pad to a size of {@code size}.</p>\n *\n * <pre>\n * StringUtils.leftPad(null, *, *)      = null\n * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n * </pre>\n *\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padStr  the String to pad with, null or empty treated as single space\n * @return left padded String or original String if no padding is necessary,\n *  {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1077, "method_signature": "String leftPad(String, int, String)", "filename": "StringUtils.leftPad.json"}
{"callee_method_names": ["String.toLowerCase"], "method_name": "StringUtils.lowerCase", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    return str.toLowerCase(LocaleUtils.toLocale(locale));\n}", "repo_id": "8", "comment": "/**\n * Converts a String to lower case as per {@link String#toLowerCase(Locale)}.\n *\n * <p>A {@code null} input String returns {@code null}.</p>\n *\n * <pre>\n * StringUtils.lowerCase(null, Locale.ENGLISH)  = null\n * StringUtils.lowerCase(\"\", Locale.ENGLISH)    = \"\"\n * StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) = \"abc\"\n * </pre>\n *\n * @param str  the String to lower case, may be null\n * @param locale  the locale that defines the case transformation rules, must not be null\n * @return the lower cased String, {@code null} if null String input\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 1079, "method_signature": "String lowerCase(String, Locale)", "filename": "StringUtils.lowerCase.json"}
{"callee_method_names": ["String.length", "String.length", "String.substring", "String.substring"], "method_name": "StringUtils.mid", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (len < 0 || pos > str.length()) {\n        return EMPTY;\n    }\n    if (pos < 0) {\n        pos = 0;\n    }\n    if (str.length() <= pos + len) {\n        return str.substring(pos);\n    }\n    return str.substring(pos, pos + len);\n}", "repo_id": "8", "comment": "/**\n * Gets {@code len} characters from the middle of a String.\n *\n * <p>If {@code len} characters are not available, the remainder\n * of the String will be returned without an exception. If the\n * String is {@code null}, {@code null} will be returned.\n * An empty String is returned if len is negative or exceeds the\n * length of {@code str}.</p>\n *\n * <pre>\n * StringUtils.mid(null, *, *)    = null\n * StringUtils.mid(*, *, -ve)     = \"\"\n * StringUtils.mid(\"\", 0, *)      = \"\"\n * StringUtils.mid(\"abc\", 0, 2)   = \"ab\"\n * StringUtils.mid(\"abc\", 0, 4)   = \"abc\"\n * StringUtils.mid(\"abc\", 2, 4)   = \"c\"\n * StringUtils.mid(\"abc\", 4, 2)   = \"\"\n * StringUtils.mid(\"abc\", -2, 2)  = \"ab\"\n * </pre>\n *\n * @param str  the String to get the characters from, may be null\n * @param pos  the position to start from, negative treated as zero\n * @param len  the length of the required String\n * @return the middle characters, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1080, "method_signature": "String mid(String, int, int)", "filename": "StringUtils.mid.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.charAt"], "method_name": "StringUtils.normalizeSpace", "method_implementation": "{\n    // LANG-1020: Improved performance significantly by normalizing manually instead of using regex\n    // See https://github.com/librucha/commons-lang-normalizespaces-benchmark for performance test\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int size = str.length();\n    final char[] newChars = new char[size];\n    int count = 0;\n    int whitespacesCount = 0;\n    boolean startWhitespaces = true;\n    for (int i = 0; i < size; i++) {\n        final char actualChar = str.charAt(i);\n        final boolean isWhitespace = Character.isWhitespace(actualChar);\n        if (isWhitespace) {\n            if (whitespacesCount == 0 && !startWhitespaces) {\n                newChars[count++] = SPACE.charAt(0);\n            }\n            whitespacesCount++;\n        } else {\n            startWhitespaces = false;\n            newChars[count++] = actualChar == 160 ? 32 : actualChar;\n            whitespacesCount = 0;\n        }\n    }\n    if (startWhitespaces) {\n        return EMPTY;\n    }\n    return new String(newChars, 0, count - (whitespacesCount > 0 ? 1 : 0)).trim();\n}", "repo_id": "8", "comment": "/**\n * Similar to <a\n * href=\"https://www.w3.org/TR/xpath/#function-normalize-space\">https://www.w3.org/TR/xpath/#function-normalize\n * -space</a>\n *\n * <p>\n * The function returns the argument string with whitespace normalized by using\n * {@code {@link #trim(String)}} to remove leading and trailing whitespace\n * and then replacing sequences of whitespace characters by a single space.\n * </p>\n * In XML Whitespace characters are the same as those allowed by the <a\n * href=\"https://www.w3.org/TR/REC-xml/#NT-S\">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+\n * <p>\n * Java's regexp pattern \\s defines whitespace as [ \\t\\n\\x0B\\f\\r]\n *\n * <p>For reference:</p>\n * <ul>\n * <li>\\x0B = vertical tab</li>\n * <li>\\f = #xC = form feed</li>\n * <li>#x20 = space</li>\n * <li>#x9 = \\t</li>\n * <li>#xA = \\n</li>\n * <li>#xD = \\r</li>\n * </ul>\n *\n * <p>\n * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also\n * normalize. Additionally {@code {@link #trim(String)}} removes control characters (char &lt;= 32) from both\n * ends of this String.\n * </p>\n *\n * @see Pattern\n * @see #trim(String)\n * @see <a\n *      href=\"https://www.w3.org/TR/xpath/#function-normalize-space\">https://www.w3.org/TR/xpath/#function-normalize-space</a>\n * @param str the source String to normalize whitespaces from, may be null\n * @return the modified string with whitespace normalized, {@code null} if null String input\n *\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 1081, "method_signature": "String normalizeSpace(String)", "filename": "StringUtils.normalizeSpace.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.ordinalIndexOf", "method_implementation": "{\n    if (str == null || searchStr == null || ordinal <= 0) {\n        return INDEX_NOT_FOUND;\n    }\n    if (searchStr.length() == 0) {\n        return lastIndex ? str.length() : 0;\n    }\n    int found = 0;\n    // set the initial index beyond the end of the string\n    // this is to allow for the initial index decrement/increment\n    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n    do {\n        if (lastIndex) {\n            // step backwards through string\n            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);\n        } else {\n            // step forwards through string\n            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);\n        }\n        if (index < 0) {\n            return index;\n        }\n        found++;\n    } while (found < ordinal);\n    return index;\n}", "repo_id": "8", "comment": "// Shared code between ordinalIndexOf(String, String, int) and lastOrdinalIndexOf(String, String, int)\n", "repo_name": "commons-lang-master/", "id": 1082, "method_signature": "int ordinalIndexOf(CharSequence, CharSequence, int, boolean)", "filename": "StringUtils.ordinalIndexOf.json"}
{"callee_method_names": ["String.length", "String.substring", "String.substring"], "method_name": "StringUtils.overlay", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (overlay == null) {\n        overlay = EMPTY;\n    }\n    final int len = str.length();\n    if (start < 0) {\n        start = 0;\n    }\n    if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end = 0;\n    }\n    if (end > len) {\n        end = len;\n    }\n    if (start > end) {\n        final int temp = start;\n        start = end;\n        end = temp;\n    }\n    return str.substring(0, start) + overlay + str.substring(end);\n}", "repo_id": "8", "comment": "/**\n * Overlays part of a String with another String.\n *\n * <p>A {@code null} string input returns {@code null}.\n * A negative index is treated as zero.\n * An index greater than the string length is treated as the string length.\n * The start index is always the smaller of the two indices.</p>\n *\n * <pre>\n * StringUtils.overlay(null, *, *, *)            = null\n * StringUtils.overlay(\"\", \"abc\", 0, 0)          = \"abc\"\n * StringUtils.overlay(\"abcdef\", null, 2, 4)     = \"abef\"\n * StringUtils.overlay(\"abcdef\", \"\", 2, 4)       = \"abef\"\n * StringUtils.overlay(\"abcdef\", \"\", 4, 2)       = \"abef\"\n * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   = \"abzzzzef\"\n * StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   = \"abzzzzef\"\n * StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  = \"zzzzef\"\n * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   = \"abzzzz\"\n * StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) = \"zzzzabcdef\"\n * StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  = \"abcdefzzzz\"\n * </pre>\n *\n * @param str  the String to do overlaying in, may be null\n * @param overlay  the String to overlay, may be null\n * @param start  the position to start overlaying at\n * @param end  the position to stop overlaying before\n * @return overlayed String, {@code null} if null String input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1083, "method_signature": "String overlay(String, String, int, int)", "filename": "StringUtils.overlay.json"}
{"callee_method_names": ["CharSequence.toString"], "method_name": "StringUtils.prependIfMissing", "method_implementation": "{\n    if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) {\n        return str;\n    }\n    if (ArrayUtils.isNotEmpty(prefixes)) {\n        for (final CharSequence p : prefixes) {\n            if (startsWith(str, p, ignoreCase)) {\n                return str;\n            }\n        }\n    }\n    return prefix.toString() + str;\n}", "repo_id": "8", "comment": "/**\n * Prepends the prefix to the start of the string if the string does not\n * already start with any of the prefixes.\n *\n * @param str The string.\n * @param prefix The prefix to prepend to the start of the string.\n * @param ignoreCase Indicates whether the compare should ignore case.\n * @param prefixes Additional prefixes that are valid (optional).\n *\n * @return A new String if prefix was prepended, the same string otherwise.\n */\n", "repo_name": "commons-lang-master/", "id": 1084, "method_signature": "String prependIfMissing(String, CharSequence, boolean, CharSequence[])", "filename": "StringUtils.prependIfMissing.json"}
{"callee_method_names": [], "method_name": "StringUtils.remove", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(remove)) {\n        return str;\n    }\n    return replace(str, remove, EMPTY, -1);\n}", "repo_id": "8", "comment": "/**\n * Removes all occurrences of a substring from within the source string.\n *\n * <p>A {@code null} source string will return {@code null}.\n * An empty (\"\") source string will return the empty string.\n * A {@code null} remove string will return the source string.\n * An empty (\"\") remove string will return the source string.</p>\n *\n * <pre>\n * StringUtils.remove(null, *)        = null\n * StringUtils.remove(\"\", *)          = \"\"\n * StringUtils.remove(*, null)        = *\n * StringUtils.remove(*, \"\")          = *\n * StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n * StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n * </pre>\n *\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,\n *  {@code null} if null String input\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 1086, "method_signature": "String remove(String, String)", "filename": "StringUtils.remove.json"}
{"callee_method_names": ["String.endsWith", "String.substring", "String.length", "String.length"], "method_name": "StringUtils.removeEnd", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(remove)) {\n        return str;\n    }\n    if (str.endsWith(remove)) {\n        return str.substring(0, str.length() - remove.length());\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * Removes a substring only if it is at the end of a source string,\n * otherwise returns the source string.\n *\n * <p>A {@code null} source string will return {@code null}.\n * An empty (\"\") source string will return the empty string.\n * A {@code null} search string will return the source string.</p>\n *\n * <pre>\n * StringUtils.removeEnd(null, *)      = null\n * StringUtils.removeEnd(\"\", *)        = \"\"\n * StringUtils.removeEnd(*, null)      = *\n * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n * </pre>\n *\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,\n *  {@code null} if null String input\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 1087, "method_signature": "String removeEnd(String, String)", "filename": "StringUtils.removeEnd.json"}
{"callee_method_names": ["String.substring", "String.length", "String.length"], "method_name": "StringUtils.removeEndIgnoreCase", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(remove)) {\n        return str;\n    }\n    if (endsWithIgnoreCase(str, remove)) {\n        return str.substring(0, str.length() - remove.length());\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * Case insensitive removal of a substring if it is at the end of a source string,\n * otherwise returns the source string.\n *\n * <p>A {@code null} source string will return {@code null}.\n * An empty (\"\") source string will return the empty string.\n * A {@code null} search string will return the source string.</p>\n *\n * <pre>\n * StringUtils.removeEndIgnoreCase(null, *)      = null\n * StringUtils.removeEndIgnoreCase(\"\", *)        = \"\"\n * StringUtils.removeEndIgnoreCase(*, null)      = *\n * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com\")   = \"www.domain\"\n * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n * StringUtils.removeEndIgnoreCase(\"abc\", \"\")    = \"abc\"\n * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".COM\") = \"www.domain\")\n * StringUtils.removeEndIgnoreCase(\"www.domain.COM\", \".com\") = \"www.domain\")\n * </pre>\n *\n * @param str  the source String to search, may be null\n * @param remove  the String to search for (case-insensitive) and remove, may be null\n * @return the substring with the string removed if found,\n *  {@code null} if null String input\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1088, "method_signature": "String removeEndIgnoreCase(String, String)", "filename": "StringUtils.removeEndIgnoreCase.json"}
{"callee_method_names": ["String.startsWith", "String.substring", "String.length"], "method_name": "StringUtils.removeStart", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(remove)) {\n        return str;\n    }\n    if (str.startsWith(remove)) {\n        return str.substring(remove.length());\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * Removes a substring only if it is at the beginning of a source string,\n * otherwise returns the source string.\n *\n * <p>A {@code null} source string will return {@code null}.\n * An empty (\"\") source string will return the empty string.\n * A {@code null} search string will return the source string.</p>\n *\n * <pre>\n * StringUtils.removeStart(null, *)      = null\n * StringUtils.removeStart(\"\", *)        = \"\"\n * StringUtils.removeStart(*, null)      = *\n * StringUtils.removeStart(\"www.domain.com\", \"www.\")   = \"domain.com\"\n * StringUtils.removeStart(\"domain.com\", \"www.\")       = \"domain.com\"\n * StringUtils.removeStart(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n * StringUtils.removeStart(\"abc\", \"\")    = \"abc\"\n * </pre>\n *\n * @param str  the source String to search, may be null\n * @param remove  the String to search for and remove, may be null\n * @return the substring with the string removed if found,\n *  {@code null} if null String input\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 1090, "method_signature": "String removeStart(String, String)", "filename": "StringUtils.removeStart.json"}
{"callee_method_names": ["String.substring"], "method_name": "StringUtils.removeStartIgnoreCase", "method_implementation": "{\n    if (str != null && startsWithIgnoreCase(str, remove)) {\n        return str.substring(length(remove));\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * Case insensitive removal of a substring if it is at the beginning of a source string,\n * otherwise returns the source string.\n *\n * <p>A {@code null} source string will return {@code null}.\n * An empty (\"\") source string will return the empty string.\n * A {@code null} search string will return the source string.</p>\n *\n * <pre>\n * StringUtils.removeStartIgnoreCase(null, *)      = null\n * StringUtils.removeStartIgnoreCase(\"\", *)        = \"\"\n * StringUtils.removeStartIgnoreCase(*, null)      = *\n * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\")   = \"domain.com\"\n * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")   = \"domain.com\"\n * StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\")       = \"domain.com\"\n * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n * StringUtils.removeStartIgnoreCase(\"abc\", \"\")    = \"abc\"\n * </pre>\n *\n * @param str  the source String to search, may be null\n * @param remove  the String to search for (case-insensitive) and remove, may be null\n * @return the substring with the string removed if found,\n *  {@code null} if null String input\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1091, "method_signature": "String removeStartIgnoreCase(String, String)", "filename": "StringUtils.removeStartIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtils.repeat", "method_implementation": "{\n    if (str == null || separator == null) {\n        return repeat(str, repeat);\n    }\n    // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n    final String result = repeat(str + separator, repeat);\n    return removeEnd(result, separator);\n}", "repo_id": "8", "comment": "/**\n * Repeat a String {@code repeat} times to form a\n * new String, with a String separator injected each time.\n *\n * <pre>\n * StringUtils.repeat(null, null, 2) = null\n * StringUtils.repeat(null, \"x\", 2)  = null\n * StringUtils.repeat(\"\", null, 0)   = \"\"\n * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n * StringUtils.repeat(\"\", \"x\", 3)    = \"xx\"\n * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n * </pre>\n *\n * @param str        the String to repeat, may be null\n * @param separator  the String to inject, may be null\n * @param repeat     number of times to repeat str, negative treated as zero\n * @return a new String consisting of the original String repeated,\n *  {@code null} if null String input\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 1094, "method_signature": "String repeat(String, String, int)", "filename": "StringUtils.repeat.json"}
{"callee_method_names": ["String.toLowerCase", "String.length", "String.length", "String.length", "StringBuilder.append", "StringBuilder.append", "String.length", "StringBuilder.toString"], "method_name": "StringUtils.replace", "method_implementation": "{\n    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n        return text;\n    }\n    if (ignoreCase) {\n        searchString = searchString.toLowerCase();\n    }\n    int start = 0;\n    int end = ignoreCase ? indexOfIgnoreCase(text, searchString, start) : indexOf(text, searchString, start);\n    if (end == INDEX_NOT_FOUND) {\n        return text;\n    }\n    final int replLength = searchString.length();\n    int increase = Math.max(replacement.length() - replLength, 0);\n    increase *= max < 0 ? 16 : Math.min(max, 64);\n    final StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (end != INDEX_NOT_FOUND) {\n        buf.append(text, start, end).append(replacement);\n        start = end + replLength;\n        if (--max == 0) {\n            break;\n        }\n        end = ignoreCase ? indexOfIgnoreCase(text, searchString, start) : indexOf(text, searchString, start);\n    }\n    buf.append(text, start, text.length());\n    return buf.toString();\n}", "repo_id": "8", "comment": "/**\n * Replaces a String with another String inside a larger String,\n * for the first {@code max} values of the search String,\n * case-sensitively/insensitively based on {@code ignoreCase} value.\n *\n * <p>A {@code null} reference passed to this method is a no-op.</p>\n *\n * <pre>\n * StringUtils.replace(null, *, *, *, false)         = null\n * StringUtils.replace(\"\", *, *, *, false)           = \"\"\n * StringUtils.replace(\"any\", null, *, *, false)     = \"any\"\n * StringUtils.replace(\"any\", *, null, *, false)     = \"any\"\n * StringUtils.replace(\"any\", \"\", *, *, false)       = \"any\"\n * StringUtils.replace(\"any\", *, *, 0, false)        = \"any\"\n * StringUtils.replace(\"abaa\", \"a\", null, -1, false) = \"abaa\"\n * StringUtils.replace(\"abaa\", \"a\", \"\", -1, false)   = \"b\"\n * StringUtils.replace(\"abaa\", \"a\", \"z\", 0, false)   = \"abaa\"\n * StringUtils.replace(\"abaa\", \"A\", \"z\", 1, false)   = \"abaa\"\n * StringUtils.replace(\"abaa\", \"A\", \"z\", 1, true)   = \"zbaa\"\n * StringUtils.replace(\"abAa\", \"a\", \"z\", 2, true)   = \"zbza\"\n * StringUtils.replace(\"abAa\", \"a\", \"z\", -1, true)  = \"zbzz\"\n * </pre>\n *\n * @param text  text to search and replace in, may be null\n * @param searchString  the String to search for (case-insensitive), may be null\n * @param replacement  the String to replace it with, may be null\n * @param max  maximum number of values to replace, or {@code -1} if no maximum\n * @param ignoreCase if true replace is case-insensitive, otherwise case-sensitive\n * @return the text with any replacements processed,\n *  {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1095, "method_signature": "String replace(String, String, String, int, boolean)", "filename": "StringUtils.replace.json"}
{"callee_method_names": ["String.length", "String.length", "String.charAt", "String.indexOf", "StringBuilder.append", "String.charAt", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StringUtils.replaceChars", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(searchChars)) {\n        return str;\n    }\n    if (replaceChars == null) {\n        replaceChars = EMPTY;\n    }\n    boolean modified = false;\n    final int replaceCharsLength = replaceChars.length();\n    final int strLength = str.length();\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        final int index = searchChars.indexOf(ch);\n        if (index >= 0) {\n            modified = true;\n            if (index < replaceCharsLength) {\n                buf.append(replaceChars.charAt(index));\n            }\n        } else {\n            buf.append(ch);\n        }\n    }\n    if (modified) {\n        return buf.toString();\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * Replaces multiple characters in a String in one go.\n * This method can also be used to delete characters.\n *\n * <p>For example:<br>\n * {@code replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly}.</p>\n *\n * <p>A {@code null} string input returns {@code null}.\n * An empty (\"\") string input returns an empty string.\n * A null or empty set of search characters returns the input string.</p>\n *\n * <p>The length of the search characters should normally equal the length\n * of the replace characters.\n * If the search characters is longer, then the extra search characters\n * are deleted.\n * If the search characters is shorter, then the extra replace characters\n * are ignored.</p>\n *\n * <pre>\n * StringUtils.replaceChars(null, *, *)           = null\n * StringUtils.replaceChars(\"\", *, *)             = \"\"\n * StringUtils.replaceChars(\"abc\", null, *)       = \"abc\"\n * StringUtils.replaceChars(\"abc\", \"\", *)         = \"abc\"\n * StringUtils.replaceChars(\"abc\", \"b\", null)     = \"ac\"\n * StringUtils.replaceChars(\"abc\", \"b\", \"\")       = \"ac\"\n * StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  = \"ayzya\"\n * StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   = \"ayya\"\n * StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") = \"ayzya\"\n * </pre>\n *\n * @param str  String to replace characters in, may be null\n * @param searchChars  a set of characters to search for, may be null\n * @param replaceChars  a set of characters to replace, may be null\n * @return modified String, {@code null} if null string input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1097, "method_signature": "String replaceChars(String, String, String)", "filename": "StringUtils.replaceChars.json"}
{"callee_method_names": ["Set<String>.retainAll", "Set<String>.isEmpty", "String.indexOf", "String[].length", "String[].length", "String.length", "String.length", "StringBuilder.append", "String.charAt", "StringBuilder.append", "String[].length", "String.indexOf", "String.length", "StringBuilder.append", "String.charAt", "StringBuilder.toString"], "method_name": "StringUtils.replaceEach", "method_implementation": "{\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    // if recursing, this shouldn't be less than 0\n    if (timeToLive < 0) {\n        final Set<String> searchSet = new HashSet<>(Arrays.asList(searchList));\n        final Set<String> replacementSet = new HashSet<>(Arrays.asList(replacementList));\n        searchSet.retainAll(replacementSet);\n        if (!searchSet.isEmpty()) {\n            throw new IllegalStateException(\"Aborting to protect against StackOverflowError - \" + \"output of one loop is the input of another\");\n        }\n    }\n    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList) || ArrayUtils.isNotEmpty(searchList) && timeToLive == -1) {\n        return text;\n    }\n    final int searchLength = searchList.length;\n    final int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || isEmpty(searchList[i]) || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else if (textIndex == -1 || tempIndex < textIndex) {\n            textIndex = tempIndex;\n            replaceIndex = i;\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        final int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    final StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || isEmpty(searchList[i]) || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n        // NOTE: logic duplicated above END\n    }\n    final int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    final String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "repo_id": "8", "comment": "/**\n * Replace all occurrences of Strings within another String.\n * This is a private recursive helper method for {@link #replaceEachRepeatedly(String, String[], String[])} and\n * {@link #replaceEach(String, String[], String[])}\n *\n * <p>\n * A {@code null} reference passed to this method is a no-op, or if\n * any \"search string\" or \"string to replace\" is null, that replace will be\n * ignored.\n * </p>\n *\n * <pre>\n *  StringUtils.replaceEach(null, *, *, *, *) = null\n *  StringUtils.replaceEach(\"\", *, *, *, *) = \"\"\n *  StringUtils.replaceEach(\"aba\", null, null, *, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[0], null, *, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", null, new String[0], *, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *, >=0) = \"b\"\n *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *, >=0) = \"aba\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *, >=0) = \"wcte\"\n *  (example of how it repeats)\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false, >=0) = \"dcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true, >=2) = \"tcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *, *) = IllegalStateException\n * </pre>\n *\n * @param text\n *            text to search and replace in, no-op if null\n * @param searchList\n *            the Strings to search for, no-op if null\n * @param replacementList\n *            the Strings to replace them with, no-op if null\n * @param repeat if true, then replace repeatedly\n *       until there are no more possible replacements or timeToLive < 0\n * @param timeToLive\n *            if less than 0 then there is a circular reference and endless\n *            loop\n * @return the text with any replacements processed, {@code null} if\n *         null String input\n * @throws IllegalStateException\n *             if the search is repeating and there is an endless loop due\n *             to outputs of one being inputs to another\n * @throws IllegalArgumentException\n *             if the lengths of the arrays are not the same (null is ok,\n *             and/or size 0)\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1098, "method_signature": "String replaceEach(String, String[], String[], boolean, int)", "filename": "StringUtils.replaceEach.json"}
{"callee_method_names": [], "method_name": "StringUtils.reverse", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    return new StringBuilder(str).reverse().toString();\n}", "repo_id": "8", "comment": "/**\n * Reverses a String as per {@link StringBuilder#reverse()}.\n *\n * <p>A {@code null} String returns {@code null}.</p>\n *\n * <pre>\n * StringUtils.reverse(null)  = null\n * StringUtils.reverse(\"\")    = \"\"\n * StringUtils.reverse(\"bat\") = \"tab\"\n * </pre>\n *\n * @param str  the String to reverse, may be null\n * @return the reversed String, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1099, "method_signature": "String reverse(String)", "filename": "StringUtils.reverse.json"}
{"callee_method_names": [], "method_name": "StringUtils.reverseDelimited", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    // could implement manually, but simple way is to reuse other,\n    // probably slower, methods.\n    final String[] strs = split(str, separatorChar);\n    ArrayUtils.reverse(strs);\n    return join(strs, separatorChar);\n}", "repo_id": "8", "comment": "/**\n * Reverses a String that is delimited by a specific character.\n *\n * <p>The Strings between the delimiters are not reversed.\n * Thus java.lang.String becomes String.lang.java (if the delimiter\n * is {@code '.'}).</p>\n *\n * <pre>\n * StringUtils.reverseDelimited(null, *)      = null\n * StringUtils.reverseDelimited(\"\", *)        = \"\"\n * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n * </pre>\n *\n * @param str  the String to reverse, may be null\n * @param separatorChar  the separator character to use\n * @return the reversed String, {@code null} if null String input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1100, "method_signature": "String reverseDelimited(String, char)", "filename": "StringUtils.reverseDelimited.json"}
{"callee_method_names": ["String.length", "String.substring", "String.length"], "method_name": "StringUtils.right", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (len < 0) {\n        return EMPTY;\n    }\n    if (str.length() <= len) {\n        return str;\n    }\n    return str.substring(str.length() - len);\n}", "repo_id": "8", "comment": "/**\n * Gets the rightmost {@code len} characters of a String.\n *\n * <p>If {@code len} characters are not available, or the String\n * is {@code null}, the String will be returned without an\n * an exception. An empty String is returned if len is negative.</p>\n *\n * <pre>\n * StringUtils.right(null, *)    = null\n * StringUtils.right(*, -ve)     = \"\"\n * StringUtils.right(\"\", *)      = \"\"\n * StringUtils.right(\"abc\", 0)   = \"\"\n * StringUtils.right(\"abc\", 2)   = \"bc\"\n * StringUtils.right(\"abc\", 4)   = \"abc\"\n * </pre>\n *\n * @param str  the String to get the rightmost characters from, may be null\n * @param len  the length of the required String\n * @return the rightmost characters, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1101, "method_signature": "String right(String, int)", "filename": "StringUtils.right.json"}
{"callee_method_names": ["String.length", "String.length", "String.charAt", "String.concat", "String.concat", "String.substring", "String.toCharArray", "String.concat"], "method_name": "StringUtils.rightPad", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (isEmpty(padStr)) {\n        padStr = SPACE;\n    }\n    final int padLen = padStr.length();\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        // returns original String when possible\n        return str;\n    }\n    if (padLen == 1 && pads <= PAD_LIMIT) {\n        return rightPad(str, size, padStr.charAt(0));\n    }\n    if (pads == padLen) {\n        return str.concat(padStr);\n    }\n    if (pads < padLen) {\n        return str.concat(padStr.substring(0, pads));\n    }\n    final char[] padding = new char[pads];\n    final char[] padChars = padStr.toCharArray();\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChars[i % padLen];\n    }\n    return str.concat(new String(padding));\n}", "repo_id": "8", "comment": "/**\n * Right pad a String with a specified String.\n *\n * <p>The String is padded to the size of {@code size}.</p>\n *\n * <pre>\n * StringUtils.rightPad(null, *, *)      = null\n * StringUtils.rightPad(\"\", 3, \"z\")      = \"zzz\"\n * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n * StringUtils.rightPad(\"bat\", 5, null)  = \"bat  \"\n * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n * </pre>\n *\n * @param str  the String to pad out, may be null\n * @param size  the size to pad to\n * @param padStr  the String to pad with, null or empty treated as single space\n * @return right padded String or original String if no padding is necessary,\n *  {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1103, "method_signature": "String rightPad(String, int, String)", "filename": "StringUtils.rightPad.json"}
{"callee_method_names": ["String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StringUtils.rotate", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (shift == 0 || strLen == 0 || shift % strLen == 0) {\n        return str;\n    }\n    final StringBuilder builder = new StringBuilder(strLen);\n    final int offset = -(shift % strLen);\n    builder.append(substring(str, offset));\n    builder.append(substring(str, 0, offset));\n    return builder.toString();\n}", "repo_id": "8", "comment": "/**\n * Rotate (circular shift) a String of {@code shift} characters.\n * <ul>\n *  <li>If {@code shift > 0}, right circular shift (ex : ABCDEF =&gt; FABCDE)</li>\n *  <li>If {@code shift < 0}, left circular shift (ex : ABCDEF =&gt; BCDEFA)</li>\n * </ul>\n *\n * <pre>\n * StringUtils.rotate(null, *)        = null\n * StringUtils.rotate(\"\", *)          = \"\"\n * StringUtils.rotate(\"abcdefg\", 0)   = \"abcdefg\"\n * StringUtils.rotate(\"abcdefg\", 2)   = \"fgabcde\"\n * StringUtils.rotate(\"abcdefg\", -2)  = \"cdefgab\"\n * StringUtils.rotate(\"abcdefg\", 7)   = \"abcdefg\"\n * StringUtils.rotate(\"abcdefg\", -7)  = \"abcdefg\"\n * StringUtils.rotate(\"abcdefg\", 9)   = \"fgabcde\"\n * StringUtils.rotate(\"abcdefg\", -9)  = \"cdefgab\"\n * </pre>\n *\n * @param str  the String to rotate, may be null\n * @param shift  number of time to shift (positive : right shift, negative : left shift)\n * @return the rotated String,\n *          or the original String if {@code shift == 0},\n *          or {@code null} if null String input\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1104, "method_signature": "String rotate(String, int)", "filename": "StringUtils.rotate.json"}
{"callee_method_names": ["String.isEmpty", "String.toCharArray", "List<String>.add", "List<String>.add", "List<String>.add", "List<String>.toArray"], "method_name": "StringUtils.splitByCharacterType", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}", "repo_id": "8", "comment": "/**\n * <p>Splits a String by Character type as returned by\n * {@code java.lang.Character.getType(char)}. Groups of contiguous\n * characters of the same type are returned as complete tokens, with the\n * following exception: if {@code camelCase} is {@code true},\n * the character of type {@code Character.UPPERCASE_LETTER}, if any,\n * immediately preceding a token of type {@code Character.LOWERCASE_LETTER}\n * will belong to the following token rather than to the preceding, if any,\n * {@code Character.UPPERCASE_LETTER} token.\n * @param str the String to split, may be {@code null}\n * @param camelCase whether to use so-called \"camel-case\" for letter types\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1105, "method_signature": "String[] splitByCharacterType(String, boolean)", "filename": "StringUtils.splitByCharacterType.json"}
{"callee_method_names": ["String.length", "String.equals", "String.length", "String.indexOf", "ArrayList<String>.add", "String.substring", "ArrayList<String>.add", "String.substring", "ArrayList<String>.add", "String.substring", "ArrayList<String>.add", "ArrayList<String>.add", "String.substring", "ArrayList<String>.toArray"], "method_name": "StringUtils.splitByWholeSeparatorWorker", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    if (separator == null || EMPTY.equals(separator)) {\n        // Split on whitespace.\n        return splitWorker(str, null, max, preserveAllTokens);\n    }\n    final int separatorLength = separator.length();\n    final ArrayList<String> substrings = new ArrayList<>();\n    int numberOfSubstrings = 0;\n    int beg = 0;\n    int end = 0;\n    while (end < len) {\n        end = str.indexOf(separator, beg);\n        if (end > -1) {\n            if (end > beg) {\n                numberOfSubstrings += 1;\n                if (numberOfSubstrings == max) {\n                    end = len;\n                    substrings.add(str.substring(beg));\n                } else {\n                    // The following is OK, because String.substring( beg, end ) excludes\n                    // the character at the position 'end'.\n                    substrings.add(str.substring(beg, end));\n                    // Set the starting point for the next search.\n                    // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                    // which is the right calculation:\n                    beg = end + separatorLength;\n                }\n            } else {\n                // We found a consecutive occurrence of the separator, so skip it.\n                if (preserveAllTokens) {\n                    numberOfSubstrings += 1;\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        substrings.add(EMPTY);\n                    }\n                }\n                beg = end + separatorLength;\n            }\n        } else {\n            // String.substring( beg ) goes from 'beg' to the end of the String.\n            substrings.add(str.substring(beg));\n            end = len;\n        }\n    }\n    return substrings.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}", "repo_id": "8", "comment": "/**\n * Performs the logic for the {@code splitByWholeSeparatorPreserveAllTokens} methods.\n *\n * @param str  the String to parse, may be {@code null}\n * @param separator  String containing the String to be used as a delimiter,\n *  {@code null} splits on whitespace\n * @param max  the maximum number of elements to include in the returned\n *  array. A zero or negative value implies no limit.\n * @param preserveAllTokens if {@code true}, adjacent separators are\n * treated as empty token separators; if {@code false}, adjacent\n * separators are treated as one separator.\n * @return an array of parsed Strings, {@code null} if null String input\n * @since 2.4\n */\n", "repo_name": "commons-lang-master/", "id": 1106, "method_signature": "String[] splitByWholeSeparatorWorker(String, String, int, boolean)", "filename": "StringUtils.splitByWholeSeparatorWorker.json"}
{"callee_method_names": ["String.length", "String.charAt", "List<String>.add", "String.substring", "String.length", "String.charAt", "String.charAt", "List<String>.add", "String.substring", "String.indexOf", "String.charAt", "List<String>.add", "String.substring", "List<String>.add", "String.substring", "List<String>.toArray"], "method_name": "StringUtils.splitWorker", "method_implementation": "{\n    // Performance tuned for 2.0 (JDK1.4)\n    // Direct code is quicker than StringTokenizer.\n    // Also, StringTokenizer uses isSpace() not isWhitespace()\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<>();\n    int sizePlus1 = 1;\n    int i = 0;\n    int start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    if (separatorChars == null) {\n        // Null separator means use whitespace\n        while (i < len) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                if (match || preserveAllTokens) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n    } else if (separatorChars.length() == 1) {\n        // Optimise 1 character case\n        final char sep = separatorChars.charAt(0);\n        while (i < len) {\n            if (str.charAt(i) == sep) {\n                if (match || preserveAllTokens) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n    } else {\n        // standard case\n        while (i < len) {\n            if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                if (match || preserveAllTokens) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}", "repo_id": "8", "comment": "/**\n * Performs the logic for the {@code split} and\n * {@code splitPreserveAllTokens} methods that return a maximum array\n * length.\n *\n * @param str  the String to parse, may be {@code null}\n * @param separatorChars the separate character\n * @param max  the maximum number of elements to include in the\n *  array. A zero or negative value implies no limit.\n * @param preserveAllTokens if {@code true}, adjacent separators are\n * treated as empty token separators; if {@code false}, adjacent\n * separators are treated as one separator.\n * @return an array of parsed Strings, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1108, "method_signature": "String[] splitWorker(String, String, int, boolean)", "filename": "StringUtils.splitWorker.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length"], "method_name": "StringUtils.startsWith", "method_implementation": "{\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    // Get length once instead of twice in the unlikely case that it changes.\n    final int preLen = prefix.length();\n    if (preLen > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, preLen);\n}", "repo_id": "8", "comment": "/**\n * Check if a CharSequence starts with a specified prefix (optionally case insensitive).\n *\n * @see String#startsWith(String)\n * @param str  the CharSequence to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase indicates whether the compare should ignore case\n *  (case-insensitive) or not.\n * @return {@code true} if the CharSequence starts with the prefix or\n *  both {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 1109, "method_signature": "boolean startsWith(CharSequence, CharSequence, boolean)", "filename": "StringUtils.startsWith.json"}
{"callee_method_names": [], "method_name": "StringUtils.startsWithAny", "method_implementation": "{\n    if (isEmpty(sequence) || ArrayUtils.isEmpty(searchStrings)) {\n        return false;\n    }\n    for (final CharSequence searchString : searchStrings) {\n        if (startsWith(sequence, searchString)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Check if a CharSequence starts with any of the provided case-sensitive prefixes.\n *\n * <pre>\n * StringUtils.startsWithAny(null, null)      = false\n * StringUtils.startsWithAny(null, new String[] {\"abc\"})  = false\n * StringUtils.startsWithAny(\"abcxyz\", null)     = false\n * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"\"}) = true\n * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}) = true\n * StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n * StringUtils.startsWithAny(\"abcxyz\", null, \"xyz\", \"ABCX\") = false\n * StringUtils.startsWithAny(\"ABCXYZ\", null, \"xyz\", \"abc\") = false\n * </pre>\n *\n * @param sequence the CharSequence to check, may be null\n * @param searchStrings the case-sensitive CharSequence prefixes, may be empty or contain {@code null}\n * @see StringUtils#startsWith(CharSequence, CharSequence)\n * @return {@code true} if the input {@code sequence} is {@code null} AND no {@code searchStrings} are provided, or\n *   the input {@code sequence} begins with any of the provided case-sensitive {@code searchStrings}.\n * @since 2.5\n * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)\n */\n", "repo_name": "commons-lang-master/", "id": 1110, "method_signature": "boolean startsWithAny(CharSequence, CharSequence[])", "filename": "StringUtils.startsWithAny.json"}
{"callee_method_names": ["Pattern.matcher"], "method_name": "StringUtils.stripAccents", "method_implementation": "{\n    if (input == null) {\n        return null;\n    }\n    final StringBuilder decomposed = new StringBuilder(Normalizer.normalize(input, Normalizer.Form.NFD));\n    convertRemainingAccentCharacters(decomposed);\n    // Note that this doesn't correctly remove ligatures...\n    return STRIP_ACCENTS_PATTERN.matcher(decomposed).replaceAll(EMPTY);\n}", "repo_id": "8", "comment": "// See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommitted bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).\n", "repo_name": "commons-lang-master/", "id": 1111, "method_signature": "String stripAccents(String)", "filename": "StringUtils.stripAccents.json"}
{"callee_method_names": [], "method_name": "StringUtils.stripAll", "method_implementation": "{\n    final int strsLen = ArrayUtils.getLength(strs);\n    if (strsLen == 0) {\n        return strs;\n    }\n    final String[] newArr = new String[strsLen];\n    Arrays.setAll(newArr, i -> strip(strs[i], stripChars));\n    return newArr;\n}", "repo_id": "8", "comment": "/**\n * Strips any of a set of characters from the start and end of every\n * String in an array.\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <p>A new array is returned each time, except for length zero.\n * A {@code null} array will return {@code null}.\n * An empty array will return itself.\n * A {@code null} array entry will be ignored.\n * A {@code null} stripChars will strip whitespace as defined by\n * {@link Character#isWhitespace(char)}.</p>\n *\n * <pre>\n * StringUtils.stripAll(null, *)                = null\n * StringUtils.stripAll([], *)                  = []\n * StringUtils.stripAll([\"abc\", \"  abc\"], null) = [\"abc\", \"abc\"]\n * StringUtils.stripAll([\"abc  \", null], null)  = [\"abc\", null]\n * StringUtils.stripAll([\"abc  \", null], \"yz\")  = [\"abc  \", null]\n * StringUtils.stripAll([\"yabcz\", null], \"yz\")  = [\"abc\", null]\n * </pre>\n *\n * @param strs  the array to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped Strings, {@code null} if null array input\n */\n", "repo_name": "commons-lang-master/", "id": 1112, "method_signature": "String[] stripAll(String[], String)", "filename": "StringUtils.stripAll.json"}
{"callee_method_names": ["String.charAt", "String.isEmpty", "String.indexOf", "String.charAt", "String.substring"], "method_name": "StringUtils.stripEnd", "method_implementation": "{\n    int end = length(str);\n    if (end == 0) {\n        return str;\n    }\n    if (stripChars == null) {\n        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n    } else if (stripChars.isEmpty()) {\n        return str;\n    } else {\n        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {\n            end--;\n        }\n    }\n    return str.substring(0, end);\n}", "repo_id": "8", "comment": "/**\n * Strips any of a set of characters from the end of a String.\n *\n * <p>A {@code null} input String returns {@code null}.\n * An empty string (\"\") input returns the empty string.</p>\n *\n * <p>If the stripChars String is {@code null}, whitespace is\n * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <pre>\n * StringUtils.stripEnd(null, *)          = null\n * StringUtils.stripEnd(\"\", *)            = \"\"\n * StringUtils.stripEnd(\"abc\", \"\")        = \"abc\"\n * StringUtils.stripEnd(\"abc\", null)      = \"abc\"\n * StringUtils.stripEnd(\"  abc\", null)    = \"  abc\"\n * StringUtils.stripEnd(\"abc  \", null)    = \"abc\"\n * StringUtils.stripEnd(\" abc \", null)    = \" abc\"\n * StringUtils.stripEnd(\"  abcyx\", \"xyz\") = \"  abc\"\n * StringUtils.stripEnd(\"120.00\", \".0\")   = \"12\"\n * </pre>\n *\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the set of characters to remove, null treated as whitespace\n * @return the stripped String, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1113, "method_signature": "String stripEnd(String, String)", "filename": "StringUtils.stripEnd.json"}
{"callee_method_names": ["String.charAt", "String.isEmpty", "String.indexOf", "String.charAt", "String.substring"], "method_name": "StringUtils.stripStart", "method_implementation": "{\n    final int strLen = length(str);\n    if (strLen == 0) {\n        return str;\n    }\n    int start = 0;\n    if (stripChars == null) {\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n    } else if (stripChars.isEmpty()) {\n        return str;\n    } else {\n        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {\n            start++;\n        }\n    }\n    return str.substring(start);\n}", "repo_id": "8", "comment": "/**\n * Strips any of a set of characters from the start of a String.\n *\n * <p>A {@code null} input String returns {@code null}.\n * An empty string (\"\") input returns the empty string.</p>\n *\n * <p>If the stripChars String is {@code null}, whitespace is\n * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <pre>\n * StringUtils.stripStart(null, *)          = null\n * StringUtils.stripStart(\"\", *)            = \"\"\n * StringUtils.stripStart(\"abc\", \"\")        = \"abc\"\n * StringUtils.stripStart(\"abc\", null)      = \"abc\"\n * StringUtils.stripStart(\"  abc\", null)    = \"abc\"\n * StringUtils.stripStart(\"abc  \", null)    = \"abc  \"\n * StringUtils.stripStart(\" abc \", null)    = \"abc \"\n * StringUtils.stripStart(\"yxabc  \", \"xyz\") = \"abc  \"\n * </pre>\n *\n * @param str  the String to remove characters from, may be null\n * @param stripChars  the characters to remove, null treated as whitespace\n * @return the stripped String, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1114, "method_signature": "String stripStart(String, String)", "filename": "StringUtils.stripStart.json"}
{"callee_method_names": ["String.isEmpty"], "method_name": "StringUtils.stripToNull", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    str = strip(str, null);\n    // NOSONARLINT str cannot be null here\n    return str.isEmpty() ? null : str;\n}", "repo_id": "8", "comment": "/**\n * Strips whitespace from the start and end of a String  returning\n * {@code null} if the String is empty (\"\") after the strip.\n *\n * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.\n * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n *\n * <pre>\n * StringUtils.stripToNull(null)     = null\n * StringUtils.stripToNull(\"\")       = null\n * StringUtils.stripToNull(\"   \")    = null\n * StringUtils.stripToNull(\"abc\")    = \"abc\"\n * StringUtils.stripToNull(\"  abc\")  = \"abc\"\n * StringUtils.stripToNull(\"abc  \")  = \"abc\"\n * StringUtils.stripToNull(\" abc \")  = \"abc\"\n * StringUtils.stripToNull(\" ab c \") = \"ab c\"\n * </pre>\n *\n * @param str  the String to be stripped, may be null\n * @return the stripped String,\n *  {@code null} if whitespace, empty or null String input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1115, "method_signature": "String stripToNull(String)", "filename": "StringUtils.stripToNull.json"}
{"callee_method_names": ["String.length", "String.length", "String.length", "String.length", "String.substring"], "method_name": "StringUtils.substring", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    // handle negatives\n    if (end < 0) {\n        // remember end is negative\n        end = str.length() + end;\n    }\n    if (start < 0) {\n        // remember start is negative\n        start = str.length() + start;\n    }\n    // check length next\n    if (end > str.length()) {\n        end = str.length();\n    }\n    // if start is greater than end, return \"\"\n    if (start > end) {\n        return EMPTY;\n    }\n    if (start < 0) {\n        start = 0;\n    }\n    if (end < 0) {\n        end = 0;\n    }\n    return str.substring(start, end);\n}", "repo_id": "8", "comment": "/**\n * Gets a substring from the specified String avoiding exceptions.\n *\n * <p>A negative start position can be used to start/end {@code n}\n * characters from the end of the String.</p>\n *\n * <p>The returned substring starts with the character in the {@code start}\n * position and ends before the {@code end} position. All position counting is\n * zero-based -- i.e., to start at the beginning of the string use\n * {@code start = 0}. Negative start and end positions can be used to\n * specify offsets relative to the end of the String.</p>\n *\n * <p>If {@code start} is not strictly to the left of {@code end}, \"\"\n * is returned.</p>\n *\n * <pre>\n * StringUtils.substring(null, *, *)    = null\n * StringUtils.substring(\"\", * ,  *)    = \"\";\n * StringUtils.substring(\"abc\", 0, 2)   = \"ab\"\n * StringUtils.substring(\"abc\", 2, 0)   = \"\"\n * StringUtils.substring(\"abc\", 2, 4)   = \"c\"\n * StringUtils.substring(\"abc\", 4, 6)   = \"\"\n * StringUtils.substring(\"abc\", 2, 2)   = \"\"\n * StringUtils.substring(\"abc\", -2, -1) = \"b\"\n * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n * </pre>\n *\n * @param str  the String to get the substring from, may be null\n * @param start  the position to start from, negative means\n *  count back from the end of the String by this many characters\n * @param end  the position to end at (exclusive), negative means\n *  count back from the end of the String by this many characters\n * @return substring from start position to end position,\n *  {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1117, "method_signature": "String substring(String, int, int)", "filename": "StringUtils.substring.json"}
{"callee_method_names": ["String.indexOf", "String.substring", "String.length"], "method_name": "StringUtils.substringAfter", "method_implementation": "{\n    if (isEmpty(str)) {\n        return str;\n    }\n    if (separator == null) {\n        return EMPTY;\n    }\n    final int pos = str.indexOf(separator);\n    if (pos == INDEX_NOT_FOUND) {\n        return EMPTY;\n    }\n    return str.substring(pos + separator.length());\n}", "repo_id": "8", "comment": "/**\n * Gets the substring after the first occurrence of a separator.\n * The separator is not returned.\n *\n * <p>A {@code null} string input will return {@code null}.\n * An empty (\"\") string input will return the empty string.\n * A {@code null} separator will return the empty string if the\n * input string is not {@code null}.</p>\n *\n * <p>If nothing is found, the empty string is returned.</p>\n *\n * <pre>\n * StringUtils.substringAfter(null, *)      = null\n * StringUtils.substringAfter(\"\", *)        = \"\"\n * StringUtils.substringAfter(*, null)      = \"\"\n * StringUtils.substringAfter(\"abc\", \"a\")   = \"bc\"\n * StringUtils.substringAfter(\"abcba\", \"b\") = \"cba\"\n * StringUtils.substringAfter(\"abc\", \"c\")   = \"\"\n * StringUtils.substringAfter(\"abc\", \"d\")   = \"\"\n * StringUtils.substringAfter(\"abc\", \"\")    = \"abc\"\n * </pre>\n *\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring after the first occurrence of the separator,\n *  {@code null} if null String input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1119, "method_signature": "String substringAfter(String, String)", "filename": "StringUtils.substringAfter.json"}
{"callee_method_names": ["String.lastIndexOf", "String.length", "String.length", "String.substring", "String.length"], "method_name": "StringUtils.substringAfterLast", "method_implementation": "{\n    if (isEmpty(str)) {\n        return str;\n    }\n    if (isEmpty(separator)) {\n        return EMPTY;\n    }\n    final int pos = str.lastIndexOf(separator);\n    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {\n        return EMPTY;\n    }\n    return str.substring(pos + separator.length());\n}", "repo_id": "8", "comment": "/**\n * Gets the substring after the last occurrence of a separator.\n * The separator is not returned.\n *\n * <p>A {@code null} string input will return {@code null}.\n * An empty (\"\") string input will return the empty string.\n * An empty or {@code null} separator will return the empty string if\n * the input string is not {@code null}.</p>\n *\n * <p>If nothing is found, the empty string is returned.</p>\n *\n * <pre>\n * StringUtils.substringAfterLast(null, *)      = null\n * StringUtils.substringAfterLast(\"\", *)        = \"\"\n * StringUtils.substringAfterLast(*, \"\")        = \"\"\n * StringUtils.substringAfterLast(*, null)      = \"\"\n * StringUtils.substringAfterLast(\"abc\", \"a\")   = \"bc\"\n * StringUtils.substringAfterLast(\"abcba\", \"b\") = \"a\"\n * StringUtils.substringAfterLast(\"abc\", \"c\")   = \"\"\n * StringUtils.substringAfterLast(\"a\", \"a\")     = \"\"\n * StringUtils.substringAfterLast(\"a\", \"z\")     = \"\"\n * </pre>\n *\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring after the last occurrence of the separator,\n *  {@code null} if null String input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1121, "method_signature": "String substringAfterLast(String, String)", "filename": "StringUtils.substringAfterLast.json"}
{"callee_method_names": ["String.isEmpty", "String.indexOf", "String.substring"], "method_name": "StringUtils.substringBefore", "method_implementation": "{\n    if (isEmpty(str) || separator == null) {\n        return str;\n    }\n    if (separator.isEmpty()) {\n        return EMPTY;\n    }\n    final int pos = str.indexOf(separator);\n    if (pos == INDEX_NOT_FOUND) {\n        return str;\n    }\n    return str.substring(0, pos);\n}", "repo_id": "8", "comment": "/**\n * Gets the substring before the first occurrence of a separator.\n * The separator is not returned.\n *\n * <p>A {@code null} string input will return {@code null}.\n * An empty (\"\") string input will return the empty string.\n * A {@code null} separator will return the input string.</p>\n *\n * <p>If nothing is found, the string input is returned.</p>\n *\n * <pre>\n * StringUtils.substringBefore(null, *)      = null\n * StringUtils.substringBefore(\"\", *)        = \"\"\n * StringUtils.substringBefore(\"abc\", \"a\")   = \"\"\n * StringUtils.substringBefore(\"abcba\", \"b\") = \"a\"\n * StringUtils.substringBefore(\"abc\", \"c\")   = \"ab\"\n * StringUtils.substringBefore(\"abc\", \"d\")   = \"abc\"\n * StringUtils.substringBefore(\"abc\", \"\")    = \"\"\n * StringUtils.substringBefore(\"abc\", null)  = \"abc\"\n * </pre>\n *\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring before the first occurrence of the separator,\n *  {@code null} if null String input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1123, "method_signature": "String substringBefore(String, String)", "filename": "StringUtils.substringBefore.json"}
{"callee_method_names": ["String.lastIndexOf", "String.substring"], "method_name": "StringUtils.substringBeforeLast", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(separator)) {\n        return str;\n    }\n    final int pos = str.lastIndexOf(separator);\n    if (pos == INDEX_NOT_FOUND) {\n        return str;\n    }\n    return str.substring(0, pos);\n}", "repo_id": "8", "comment": "/**\n * Gets the substring before the last occurrence of a separator.\n * The separator is not returned.\n *\n * <p>A {@code null} string input will return {@code null}.\n * An empty (\"\") string input will return the empty string.\n * An empty or {@code null} separator will return the input string.</p>\n *\n * <p>If nothing is found, the string input is returned.</p>\n *\n * <pre>\n * StringUtils.substringBeforeLast(null, *)      = null\n * StringUtils.substringBeforeLast(\"\", *)        = \"\"\n * StringUtils.substringBeforeLast(\"abcba\", \"b\") = \"abc\"\n * StringUtils.substringBeforeLast(\"abc\", \"c\")   = \"ab\"\n * StringUtils.substringBeforeLast(\"a\", \"a\")     = \"\"\n * StringUtils.substringBeforeLast(\"a\", \"z\")     = \"a\"\n * StringUtils.substringBeforeLast(\"a\", null)    = \"a\"\n * StringUtils.substringBeforeLast(\"a\", \"\")      = \"a\"\n * </pre>\n *\n * @param str  the String to get a substring from, may be null\n * @param separator  the String to search for, may be null\n * @return the substring before the last occurrence of the separator,\n *  {@code null} if null String input\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1124, "method_signature": "String substringBeforeLast(String, String)", "filename": "StringUtils.substringBeforeLast.json"}
{"callee_method_names": ["String.indexOf", "String.indexOf", "String.length", "String.substring", "String.length"], "method_name": "StringUtils.substringBetween", "method_implementation": "{\n    if (!ObjectUtils.allNotNull(str, open, close)) {\n        return null;\n    }\n    final int start = str.indexOf(open);\n    if (start != INDEX_NOT_FOUND) {\n        final int end = str.indexOf(close, start + open.length());\n        if (end != INDEX_NOT_FOUND) {\n            return str.substring(start + open.length(), end);\n        }\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Gets the String that is nested in between two Strings.\n * Only the first match is returned.\n *\n * <p>A {@code null} input String returns {@code null}.\n * A {@code null} open/close returns {@code null} (no match).\n * An empty (\"\") open and close returns an empty string.</p>\n *\n * <pre>\n * StringUtils.substringBetween(\"wx[b]yz\", \"[\", \"]\") = \"b\"\n * StringUtils.substringBetween(null, *, *)          = null\n * StringUtils.substringBetween(*, null, *)          = null\n * StringUtils.substringBetween(*, *, null)          = null\n * StringUtils.substringBetween(\"\", \"\", \"\")          = \"\"\n * StringUtils.substringBetween(\"\", \"\", \"]\")         = null\n * StringUtils.substringBetween(\"\", \"[\", \"]\")        = null\n * StringUtils.substringBetween(\"yabcz\", \"\", \"\")     = \"\"\n * StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   = \"abc\"\n * StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n * </pre>\n *\n * @param str  the String containing the substring, may be null\n * @param open  the String before the substring, may be null\n * @param close  the String after the substring, may be null\n * @return the substring, {@code null} if no match\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1125, "method_signature": "String substringBetween(String, String, String)", "filename": "StringUtils.substringBetween.json"}
{"callee_method_names": ["String.length", "String.length", "String.length", "String.indexOf", "String.indexOf", "List<String>.add", "String.substring", "List<String>.isEmpty", "List<String>.toArray"], "method_name": "StringUtils.substringsBetween", "method_implementation": "{\n    if (str == null || isEmpty(open) || isEmpty(close)) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int closeLen = close.length();\n    final int openLen = open.length();\n    final List<String> list = new ArrayList<>();\n    int pos = 0;\n    while (pos < strLen - closeLen) {\n        int start = str.indexOf(open, pos);\n        if (start < 0) {\n            break;\n        }\n        start += openLen;\n        final int end = str.indexOf(close, start);\n        if (end < 0) {\n            break;\n        }\n        list.add(str.substring(start, end));\n        pos = end + closeLen;\n    }\n    if (list.isEmpty()) {\n        return null;\n    }\n    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}", "repo_id": "8", "comment": "/**\n * Searches a String for substrings delimited by a start and end tag,\n * returning all matching substrings in an array.\n *\n * <p>A {@code null} input String returns {@code null}.\n * A {@code null} open/close returns {@code null} (no match).\n * An empty (\"\") open/close returns {@code null} (no match).</p>\n *\n * <pre>\n * StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\") = [\"a\",\"b\",\"c\"]\n * StringUtils.substringsBetween(null, *, *)            = null\n * StringUtils.substringsBetween(*, null, *)            = null\n * StringUtils.substringsBetween(*, *, null)            = null\n * StringUtils.substringsBetween(\"\", \"[\", \"]\")          = []\n * </pre>\n *\n * @param str  the String containing the substrings, null returns null, empty returns empty\n * @param open  the String identifying the start of the substring, empty returns null\n * @param close  the String identifying the end of the substring, empty returns null\n * @return a String Array of substrings, or {@code null} if no match\n * @since 2.3\n */\n", "repo_name": "commons-lang-master/", "id": 1126, "method_signature": "String[] substringsBetween(String, String, String)", "filename": "StringUtils.substringsBetween.json"}
{"callee_method_names": ["String.length", "String.codePointAt"], "method_name": "StringUtils.swapCase", "method_implementation": "{\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    // cannot be longer than the char array\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int i = 0; i < strLen; ) {\n        final int oldCodepoint = str.codePointAt(i);\n        final int newCodePoint;\n        if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {\n            newCodePoint = Character.toLowerCase(oldCodepoint);\n        } else if (Character.isLowerCase(oldCodepoint)) {\n            newCodePoint = Character.toUpperCase(oldCodepoint);\n        } else {\n            newCodePoint = oldCodepoint;\n        }\n        newCodePoints[outOffset++] = newCodePoint;\n        i += Character.charCount(newCodePoint);\n    }\n    return new String(newCodePoints, 0, outOffset);\n}", "repo_id": "8", "comment": "/**\n * Swaps the case of a String changing upper and title case to\n * lower case, and lower case to upper case.\n *\n * <ul>\n *  <li>Upper case character converts to Lower case</li>\n *  <li>Title case character converts to Lower case</li>\n *  <li>Lower case character converts to Upper case</li>\n * </ul>\n *\n * <p>For a word based algorithm, see {@link org.apache.commons.text.WordUtils#swapCase(String)}.\n * A {@code null} input String returns {@code null}.</p>\n *\n * <pre>\n * StringUtils.swapCase(null)                 = null\n * StringUtils.swapCase(\"\")                   = \"\"\n * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n * </pre>\n *\n * <p>NOTE: This method changed in Lang version 2.0.\n * It no longer performs a word based algorithm.\n * If you only use ASCII, you will notice no change.\n * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>\n *\n * @param str  the String to swap case, may be null\n * @return the changed String, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 1127, "method_signature": "String swapCase(String)", "filename": "StringUtils.swapCase.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.toString", "String.codePointCount", "String.length", "String.codePointAt"], "method_name": "StringUtils.toCodePoints", "method_implementation": "{\n    if (cs == null) {\n        return null;\n    }\n    if (cs.length() == 0) {\n        return ArrayUtils.EMPTY_INT_ARRAY;\n    }\n    final String s = cs.toString();\n    final int[] result = new int[s.codePointCount(0, s.length())];\n    int index = 0;\n    for (int i = 0; i < result.length; i++) {\n        result[i] = s.codePointAt(index);\n        index += Character.charCount(result[i]);\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Converts a {@link CharSequence} into an array of code points.\n *\n * <p>Valid pairs of surrogate code units will be converted into a single supplementary\n * code point. Isolated surrogate code units (i.e. a high surrogate not followed by a low surrogate or\n * a low surrogate not preceded by a high surrogate) will be returned as-is.</p>\n *\n * <pre>\n * StringUtils.toCodePoints(null)   =  null\n * StringUtils.toCodePoints(\"\")     =  []  // empty array\n * </pre>\n *\n * @param cs the character sequence to convert\n * @return an array of code points\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1128, "method_signature": "int[] toCodePoints(CharSequence)", "filename": "StringUtils.toCodePoints.json"}
{"callee_method_names": ["String.length", "String.length", "String.length", "String.substring", "String.substring"], "method_name": "StringUtils.truncate", "method_implementation": "{\n    if (offset < 0) {\n        throw new IllegalArgumentException(\"offset cannot be negative\");\n    }\n    if (maxWidth < 0) {\n        throw new IllegalArgumentException(\"maxWith cannot be negative\");\n    }\n    if (str == null) {\n        return null;\n    }\n    if (offset > str.length()) {\n        return EMPTY;\n    }\n    if (str.length() > maxWidth) {\n        final int ix = Math.min(offset + maxWidth, str.length());\n        return str.substring(offset, ix);\n    }\n    return str.substring(offset);\n}", "repo_id": "8", "comment": "/**\n * Truncates a String. This will turn\n * \"Now is the time for all good men\" into \"is the time for all\".\n *\n * <p>Works like {@code truncate(String, int)}, but allows you to specify\n * a \"left edge\" offset.\n *\n * <p>Specifically:</p>\n * <ul>\n *   <li>If {@code str} is less than {@code maxWidth} characters\n *       long, return it.</li>\n *   <li>Else truncate it to {@code substring(str, offset, maxWidth)}.</li>\n *   <li>If {@code maxWidth} is less than {@code 0}, throw an\n *       {@link IllegalArgumentException}.</li>\n *   <li>If {@code offset} is less than {@code 0}, throw an\n *       {@link IllegalArgumentException}.</li>\n *   <li>In no case will it return a String of length greater than\n *       {@code maxWidth}.</li>\n * </ul>\n *\n * <pre>\n * StringUtils.truncate(null, 0, 0) = null\n * StringUtils.truncate(null, 2, 4) = null\n * StringUtils.truncate(\"\", 0, 10) = \"\"\n * StringUtils.truncate(\"\", 2, 10) = \"\"\n * StringUtils.truncate(\"abcdefghij\", 0, 3) = \"abc\"\n * StringUtils.truncate(\"abcdefghij\", 5, 6) = \"fghij\"\n * StringUtils.truncate(\"raspberry peach\", 10, 15) = \"peach\"\n * StringUtils.truncate(\"abcdefghijklmno\", 0, 10) = \"abcdefghij\"\n * StringUtils.truncate(\"abcdefghijklmno\", -1, 10) = throws an IllegalArgumentException\n * StringUtils.truncate(\"abcdefghijklmno\", Integer.MIN_VALUE, 10) = throws an IllegalArgumentException\n * StringUtils.truncate(\"abcdefghijklmno\", Integer.MIN_VALUE, Integer.MAX_VALUE) = throws an IllegalArgumentException\n * StringUtils.truncate(\"abcdefghijklmno\", 0, Integer.MAX_VALUE) = \"abcdefghijklmno\"\n * StringUtils.truncate(\"abcdefghijklmno\", 1, 10) = \"bcdefghijk\"\n * StringUtils.truncate(\"abcdefghijklmno\", 2, 10) = \"cdefghijkl\"\n * StringUtils.truncate(\"abcdefghijklmno\", 3, 10) = \"defghijklm\"\n * StringUtils.truncate(\"abcdefghijklmno\", 4, 10) = \"efghijklmn\"\n * StringUtils.truncate(\"abcdefghijklmno\", 5, 10) = \"fghijklmno\"\n * StringUtils.truncate(\"abcdefghijklmno\", 5, 5) = \"fghij\"\n * StringUtils.truncate(\"abcdefghijklmno\", 5, 3) = \"fgh\"\n * StringUtils.truncate(\"abcdefghijklmno\", 10, 3) = \"klm\"\n * StringUtils.truncate(\"abcdefghijklmno\", 10, Integer.MAX_VALUE) = \"klmno\"\n * StringUtils.truncate(\"abcdefghijklmno\", 13, 1) = \"n\"\n * StringUtils.truncate(\"abcdefghijklmno\", 13, Integer.MAX_VALUE) = \"no\"\n * StringUtils.truncate(\"abcdefghijklmno\", 14, 1) = \"o\"\n * StringUtils.truncate(\"abcdefghijklmno\", 14, Integer.MAX_VALUE) = \"o\"\n * StringUtils.truncate(\"abcdefghijklmno\", 15, 1) = \"\"\n * StringUtils.truncate(\"abcdefghijklmno\", 15, Integer.MAX_VALUE) = \"\"\n * StringUtils.truncate(\"abcdefghijklmno\", Integer.MAX_VALUE, Integer.MAX_VALUE) = \"\"\n * StringUtils.truncate(\"abcdefghij\", 3, -1) = throws an IllegalArgumentException\n * StringUtils.truncate(\"abcdefghij\", -2, 4) = throws an IllegalArgumentException\n * </pre>\n *\n * @param str  the String to truncate, may be null\n * @param offset  left edge of source String\n * @param maxWidth  maximum length of result String, must be positive\n * @return truncated String, {@code null} if null String input\n * @throws IllegalArgumentException If {@code offset} or {@code maxWidth} is less than {@code 0}\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1129, "method_signature": "String truncate(String, int, int)", "filename": "StringUtils.truncate.json"}
{"callee_method_names": ["String.codePointAt", "String.codePointAt"], "method_name": "StringUtils.uncapitalize", "method_implementation": "{\n    final int strLen = length(str);\n    if (strLen == 0) {\n        return str;\n    }\n    final int firstCodePoint = str.codePointAt(0);\n    final int newCodePoint = Character.toLowerCase(firstCodePoint);\n    if (firstCodePoint == newCodePoint) {\n        // already capitalized\n        return str;\n    }\n    // cannot be longer than the char array\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    // copy the first code point\n    newCodePoints[outOffset++] = newCodePoint;\n    for (int inOffset = Character.charCount(firstCodePoint); inOffset < strLen; ) {\n        final int codePoint = str.codePointAt(inOffset);\n        // copy the remaining ones\n        newCodePoints[outOffset++] = codePoint;\n        inOffset += Character.charCount(codePoint);\n    }\n    return new String(newCodePoints, 0, outOffset);\n}", "repo_id": "8", "comment": "/**\n * Uncapitalizes a String, changing the first character to lower case as\n * per {@link Character#toLowerCase(int)}. No other characters are changed.\n *\n * <p>For a word based algorithm, see {@link org.apache.commons.text.WordUtils#uncapitalize(String)}.\n * A {@code null} input String returns {@code null}.</p>\n *\n * <pre>\n * StringUtils.uncapitalize(null)  = null\n * StringUtils.uncapitalize(\"\")    = \"\"\n * StringUtils.uncapitalize(\"cat\") = \"cat\"\n * StringUtils.uncapitalize(\"Cat\") = \"cat\"\n * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n * </pre>\n *\n * @param str the String to uncapitalize, may be null\n * @return the uncapitalized String, {@code null} if null String input\n * @see org.apache.commons.text.WordUtils#uncapitalize(String)\n * @see #capitalize(String)\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 1130, "method_signature": "String uncapitalize(String)", "filename": "StringUtils.uncapitalize.json"}
{"callee_method_names": ["String.length", "String.length", "String.substring", "String.length", "String.lastIndexOf"], "method_name": "StringUtils.unwrap", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(wrapToken) || str.length() < 2 * wrapToken.length()) {\n        return str;\n    }\n    if (startsWith(str, wrapToken) && endsWith(str, wrapToken)) {\n        return str.substring(wrapToken.length(), str.lastIndexOf(wrapToken));\n    }\n    return str;\n}", "repo_id": "8", "comment": "/**\n * Unwraps a given string from another string.\n *\n * <pre>\n * StringUtils.unwrap(null, null)         = null\n * StringUtils.unwrap(null, \"\")           = null\n * StringUtils.unwrap(null, \"1\")          = null\n * StringUtils.unwrap(\"a\", \"a\")           = \"a\"\n * StringUtils.unwrap(\"aa\", \"a\")          = \"\"\n * StringUtils.unwrap(\"\\'abc\\'\", \"\\'\")    = \"abc\"\n * StringUtils.unwrap(\"\\\"abc\\\"\", \"\\\"\")    = \"abc\"\n * StringUtils.unwrap(\"AABabcBAA\", \"AA\")  = \"BabcB\"\n * StringUtils.unwrap(\"A\", \"#\")           = \"A\"\n * StringUtils.unwrap(\"#A\", \"#\")          = \"#A\"\n * StringUtils.unwrap(\"A#\", \"#\")          = \"A#\"\n * </pre>\n *\n * @param str\n *          the String to be unwrapped, can be null\n * @param wrapToken\n *          the String used to unwrap\n * @return unwrapped String or the original string\n *          if it is not quoted properly with the wrapToken\n * @since 3.6\n */\n", "repo_name": "commons-lang-master/", "id": 1132, "method_signature": "String unwrap(String, String)", "filename": "StringUtils.unwrap.json"}
{"callee_method_names": ["String.toUpperCase"], "method_name": "StringUtils.upperCase", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    return str.toUpperCase(LocaleUtils.toLocale(locale));\n}", "repo_id": "8", "comment": "/**\n * Converts a String to upper case as per {@link String#toUpperCase(Locale)}.\n *\n * <p>A {@code null} input String returns {@code null}.</p>\n *\n * <pre>\n * StringUtils.upperCase(null, Locale.ENGLISH)  = null\n * StringUtils.upperCase(\"\", Locale.ENGLISH)    = \"\"\n * StringUtils.upperCase(\"aBc\", Locale.ENGLISH) = \"ABC\"\n * </pre>\n *\n * @param str  the String to upper case, may be null\n * @param locale  the locale that defines the case transformation rules, must not be null\n * @return the upper-cased String, {@code null} if null String input\n * @since 2.5\n */\n", "repo_name": "commons-lang-master/", "id": 1134, "method_signature": "String upperCase(String, Locale)", "filename": "StringUtils.upperCase.json"}
{"callee_method_names": ["String.concat"], "method_name": "StringUtils.wrap", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(wrapWith)) {\n        return str;\n    }\n    return wrapWith.concat(str).concat(wrapWith);\n}", "repo_id": "8", "comment": "/**\n * Wraps a String with another String.\n *\n * <p>\n * A {@code null} input String returns {@code null}.\n * </p>\n *\n * <pre>\n * StringUtils.wrap(null, *)         = null\n * StringUtils.wrap(\"\", *)           = \"\"\n * StringUtils.wrap(\"ab\", null)      = \"ab\"\n * StringUtils.wrap(\"ab\", \"x\")       = \"xabx\"\n * StringUtils.wrap(\"ab\", \"\\\"\")      = \"\\\"ab\\\"\"\n * StringUtils.wrap(\"\\\"ab\\\"\", \"\\\"\")  = \"\\\"\\\"ab\\\"\\\"\"\n * StringUtils.wrap(\"ab\", \"'\")       = \"'ab'\"\n * StringUtils.wrap(\"'abcd'\", \"'\")   = \"''abcd''\"\n * StringUtils.wrap(\"\\\"abcd\\\"\", \"'\") = \"'\\\"abcd\\\"'\"\n * StringUtils.wrap(\"'abcd'\", \"\\\"\")  = \"\\\"'abcd'\\\"\"\n * </pre>\n *\n * @param str\n *            the String to be wrapper, may be null\n * @param wrapWith\n *            the String that will wrap str\n * @return wrapped String, {@code null} if null String input\n * @since 3.4\n */\n", "repo_name": "commons-lang-master/", "id": 1136, "method_signature": "String wrap(String, String)", "filename": "StringUtils.wrap.json"}
{"callee_method_names": ["String.startsWith", "String.endsWith", "String.length", "String.length", "String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StringUtils.wrapIfMissing", "method_implementation": "{\n    if (isEmpty(str) || isEmpty(wrapWith)) {\n        return str;\n    }\n    final boolean wrapStart = !str.startsWith(wrapWith);\n    final boolean wrapEnd = !str.endsWith(wrapWith);\n    if (!wrapStart && !wrapEnd) {\n        return str;\n    }\n    final StringBuilder builder = new StringBuilder(str.length() + wrapWith.length() + wrapWith.length());\n    if (wrapStart) {\n        builder.append(wrapWith);\n    }\n    builder.append(str);\n    if (wrapEnd) {\n        builder.append(wrapWith);\n    }\n    return builder.toString();\n}", "repo_id": "8", "comment": "/**\n * Wraps a string with a string if that string is missing from the start or end of the given string.\n *\n * <p>A new {@link String} will not be created if {@code str} is already wrapped.</p>\n *\n * <pre>\n * StringUtils.wrapIfMissing(null, *)         = null\n * StringUtils.wrapIfMissing(\"\", *)           = \"\"\n * StringUtils.wrapIfMissing(\"ab\", null)      = \"ab\"\n * StringUtils.wrapIfMissing(\"ab\", \"x\")       = \"xabx\"\n * StringUtils.wrapIfMissing(\"ab\", \"\\\"\")      = \"\\\"ab\\\"\"\n * StringUtils.wrapIfMissing(\"\\\"ab\\\"\", \"\\\"\")  = \"\\\"ab\\\"\"\n * StringUtils.wrapIfMissing(\"ab\", \"'\")       = \"'ab'\"\n * StringUtils.wrapIfMissing(\"'abcd'\", \"'\")   = \"'abcd'\"\n * StringUtils.wrapIfMissing(\"\\\"abcd\\\"\", \"'\") = \"'\\\"abcd\\\"'\"\n * StringUtils.wrapIfMissing(\"'abcd'\", \"\\\"\")  = \"\\\"'abcd'\\\"\"\n * StringUtils.wrapIfMissing(\"/\", \"/\")  = \"/\"\n * StringUtils.wrapIfMissing(\"a/b/c\", \"/\")  = \"/a/b/c/\"\n * StringUtils.wrapIfMissing(\"/a/b/c\", \"/\")  = \"/a/b/c/\"\n * StringUtils.wrapIfMissing(\"a/b/c/\", \"/\")  = \"/a/b/c/\"\n * </pre>\n *\n * @param str\n *            the string to be wrapped, may be {@code null}\n * @param wrapWith\n *            the string that will wrap {@code str}\n * @return the wrapped string, or {@code null} if {@code str==null}\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 1138, "method_signature": "String wrapIfMissing(String, String)", "filename": "StringUtils.wrapIfMissing.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsAny_StringCharArrayWithBadSupplementaryChars", "method_implementation": "{\n    // Test edge case: 1/2 of a (broken) supplementary char\n    assertFalse(StringUtils.containsAny(CharUSuppCharHigh, CharU20001.toCharArray()));\n    assertFalse(StringUtils.containsAny(\"abc\" + CharUSuppCharHigh + \"xyz\", CharU20001.toCharArray()));\n    assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n    assertFalse(StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray()));\n    assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh.toCharArray()));\n    assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n    assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharLow.toCharArray()));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1759, "method_signature": "void testContainsAny_StringCharArrayWithBadSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsAny_StringCharArrayWithBadSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsAny_StringCharArrayWithSupplementaryChars", "method_implementation": "{\n    assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n    assertTrue(StringUtils.containsAny(\"a\" + CharU20000 + CharU20001, \"a\".toCharArray()));\n    assertTrue(StringUtils.containsAny(CharU20000 + \"a\" + CharU20001, \"a\".toCharArray()));\n    assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + \"a\", \"a\".toCharArray()));\n    assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n    assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray()));\n    // Sanity check:\n    assertEquals(-1, CharU20000.indexOf(CharU20001));\n    assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n    assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n    // Test:\n    assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray()));\n    assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray()));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1760, "method_signature": "void testContainsAny_StringCharArrayWithSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsAny_StringCharArrayWithSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsAny_StringWithBadSupplementaryChars", "method_implementation": "{\n    // Test edge case: 1/2 of a (broken) supplementary char\n    assertFalse(StringUtils.containsAny(CharUSuppCharHigh, CharU20001));\n    assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n    assertFalse(StringUtils.containsAny(CharUSuppCharLow, CharU20001));\n    assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh));\n    assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n    assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharLow));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1761, "method_signature": "void testContainsAny_StringWithBadSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsAny_StringWithBadSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsAny_StringWithSupplementaryChars", "method_implementation": "{\n    assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000));\n    assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001));\n    assertTrue(StringUtils.containsAny(CharU20000, CharU20000));\n    // Sanity check:\n    assertEquals(-1, CharU20000.indexOf(CharU20001));\n    assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n    assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n    // Test:\n    assertFalse(StringUtils.containsAny(CharU20000, CharU20001));\n    assertFalse(StringUtils.containsAny(CharU20001, CharU20000));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1762, "method_signature": "void testContainsAny_StringWithSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsAny_StringWithSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsNone_CharArrayWithBadSupplementaryChars", "method_implementation": "{\n    // Test edge case: 1/2 of a (broken) supplementary char\n    assertTrue(StringUtils.containsNone(CharUSuppCharHigh, CharU20001.toCharArray()));\n    assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n    assertTrue(StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray()));\n    assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n    assertTrue(StringUtils.containsNone(CharU20001, CharUSuppCharHigh.toCharArray()));\n    assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n    assertFalse(StringUtils.containsNone(CharU20001, CharUSuppCharLow.toCharArray()));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1763, "method_signature": "void testContainsNone_CharArrayWithBadSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsNone_CharArrayWithBadSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsNone_CharArrayWithSupplementaryChars", "method_implementation": "{\n    assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000.toCharArray()));\n    assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001.toCharArray()));\n    assertFalse(StringUtils.containsNone(CharU20000, CharU20000.toCharArray()));\n    // Sanity check:\n    assertEquals(-1, CharU20000.indexOf(CharU20001));\n    assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n    assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n    // Test:\n    assertTrue(StringUtils.containsNone(CharU20000, CharU20001.toCharArray()));\n    assertTrue(StringUtils.containsNone(CharU20001, CharU20000.toCharArray()));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1764, "method_signature": "void testContainsNone_CharArrayWithSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsNone_CharArrayWithSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsNone_StringWithBadSupplementaryChars", "method_implementation": "{\n    // Test edge case: 1/2 of a (broken) supplementary char\n    assertTrue(StringUtils.containsNone(CharUSuppCharHigh, CharU20001));\n    assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n    assertTrue(StringUtils.containsNone(CharUSuppCharLow, CharU20001));\n    assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n    assertTrue(StringUtils.containsNone(CharU20001, CharUSuppCharHigh));\n    assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n    assertFalse(StringUtils.containsNone(CharU20001, CharUSuppCharLow));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1765, "method_signature": "void testContainsNone_StringWithBadSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsNone_StringWithBadSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContainsNone_StringWithSupplementaryChars", "method_implementation": "{\n    assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000));\n    assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001));\n    assertFalse(StringUtils.containsNone(CharU20000, CharU20000));\n    // Sanity check:\n    assertEquals(-1, CharU20000.indexOf(CharU20001));\n    assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n    assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n    // Test:\n    assertTrue(StringUtils.containsNone(CharU20000, CharU20001));\n    assertTrue(StringUtils.containsNone(CharU20001, CharU20000));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1766, "method_signature": "void testContainsNone_StringWithSupplementaryChars()", "filename": "StringUtilsContainsTest.testContainsNone_StringWithSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContains_StringWithBadSupplementaryChars", "method_implementation": "{\n    // Test edge case: 1/2 of a (broken) supplementary char\n    assertFalse(StringUtils.contains(CharUSuppCharHigh, CharU20001));\n    assertFalse(StringUtils.contains(CharUSuppCharLow, CharU20001));\n    assertFalse(StringUtils.contains(CharU20001, CharUSuppCharHigh));\n    assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n    assertTrue(StringUtils.contains(CharU20001, CharUSuppCharLow));\n    assertTrue(StringUtils.contains(CharU20001 + CharUSuppCharLow + \"a\", \"a\"));\n    assertTrue(StringUtils.contains(CharU20001 + CharUSuppCharHigh + \"a\", \"a\"));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1757, "method_signature": "void testContains_StringWithBadSupplementaryChars()", "filename": "StringUtilsContainsTest.testContains_StringWithBadSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsContainsTest.testContains_StringWithSupplementaryChars", "method_implementation": "{\n    assertTrue(StringUtils.contains(CharU20000 + CharU20001, CharU20000));\n    assertTrue(StringUtils.contains(CharU20000 + CharU20001, CharU20001));\n    assertTrue(StringUtils.contains(CharU20000, CharU20000));\n    assertFalse(StringUtils.contains(CharU20000, CharU20001));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1758, "method_signature": "void testContains_StringWithSupplementaryChars()", "filename": "StringUtilsContainsTest.testContains_StringWithSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsEqualsIndexOfTest.testIndexOfAny_StringCharArrayWithSupplementaryChars", "method_implementation": "{\n    assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n    assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n    assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000.toCharArray()));\n    assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray()));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1869, "method_signature": "void testIndexOfAny_StringCharArrayWithSupplementaryChars()", "filename": "StringUtilsEqualsIndexOfTest.testIndexOfAny_StringCharArrayWithSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsEqualsIndexOfTest.testIndexOfAny_StringStringWithSupplementaryChars", "method_implementation": "{\n    assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000));\n    assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001));\n    assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000));\n    assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001));\n}", "repo_id": "8", "comment": "/**\n * See https://www.oracle.com/technical-resources/articles/javase/supplementary.html\n */\n", "repo_name": "commons-lang-master/", "id": 1870, "method_signature": "void testIndexOfAny_StringStringWithSupplementaryChars()", "filename": "StringUtilsEqualsIndexOfTest.testIndexOfAny_StringStringWithSupplementaryChars.json"}
{"callee_method_names": [], "method_name": "StringUtilsStartsEndsWithTest.testEndsWith", "method_implementation": "{\n    assertTrue(StringUtils.endsWith(null, null), \"endsWith(null, null)\");\n    assertFalse(StringUtils.endsWith(FOOBAR, null), \"endsWith(FOOBAR, null)\");\n    assertFalse(StringUtils.endsWith(null, FOO), \"endsWith(null, FOO)\");\n    assertTrue(StringUtils.endsWith(FOOBAR, \"\"), \"endsWith(FOOBAR, \\\"\\\")\");\n    assertFalse(StringUtils.endsWith(foobar, foo), \"endsWith(foobar, foo)\");\n    assertFalse(StringUtils.endsWith(FOOBAR, FOO), \"endsWith(FOOBAR, FOO)\");\n    assertFalse(StringUtils.endsWith(foobar, FOO), \"endsWith(foobar, FOO)\");\n    assertFalse(StringUtils.endsWith(FOOBAR, foo), \"endsWith(FOOBAR, foo)\");\n    assertFalse(StringUtils.endsWith(foo, foobar), \"endsWith(foo, foobar)\");\n    assertFalse(StringUtils.endsWith(bar, foobar), \"endsWith(foo, foobar)\");\n    assertTrue(StringUtils.endsWith(foobar, bar), \"endsWith(foobar, bar)\");\n    assertTrue(StringUtils.endsWith(FOOBAR, BAR), \"endsWith(FOOBAR, BAR)\");\n    assertFalse(StringUtils.endsWith(foobar, BAR), \"endsWith(foobar, BAR)\");\n    assertFalse(StringUtils.endsWith(FOOBAR, bar), \"endsWith(FOOBAR, bar)\");\n    // \"alpha, beta, gamma, delta\".endsWith(\"delta\")\n    assertTrue(StringUtils.endsWith(\"\\u03B1\\u03B2\\u03B3\\u03B4\", \"\\u03B4\"), \"endsWith(\\u03B1\\u03B2\\u03B3\\u03B4, \\u03B4)\");\n    // \"alpha, beta, gamma, delta\".endsWith(\"gamma, DELTA\")\n    assertFalse(StringUtils.endsWith(\"\\u03B1\\u03B2\\u03B3\\u03B4\", \"\\u03B3\\u0394\"), \"endsWith(\\u03B1\\u03B2\\u03B3\\u03B4, \\u03B3\\u0394)\");\n}", "repo_id": "8", "comment": "/**\n * Test StringUtils.endsWith()\n */\n", "repo_name": "commons-lang-master/", "id": 1426, "method_signature": "void testEndsWith()", "filename": "StringUtilsStartsEndsWithTest.testEndsWith.json"}
{"callee_method_names": [], "method_name": "StringUtilsStartsEndsWithTest.testEndsWithIgnoreCase", "method_implementation": "{\n    assertTrue(StringUtils.endsWithIgnoreCase(null, null), \"endsWithIgnoreCase(null, null)\");\n    assertFalse(StringUtils.endsWithIgnoreCase(FOOBAR, null), \"endsWithIgnoreCase(FOOBAR, null)\");\n    assertFalse(StringUtils.endsWithIgnoreCase(null, FOO), \"endsWithIgnoreCase(null, FOO)\");\n    assertTrue(StringUtils.endsWithIgnoreCase(FOOBAR, \"\"), \"endsWithIgnoreCase(FOOBAR, \\\"\\\")\");\n    assertFalse(StringUtils.endsWithIgnoreCase(foobar, foo), \"endsWithIgnoreCase(foobar, foo)\");\n    assertFalse(StringUtils.endsWithIgnoreCase(FOOBAR, FOO), \"endsWithIgnoreCase(FOOBAR, FOO)\");\n    assertFalse(StringUtils.endsWithIgnoreCase(foobar, FOO), \"endsWithIgnoreCase(foobar, FOO)\");\n    assertFalse(StringUtils.endsWithIgnoreCase(FOOBAR, foo), \"endsWithIgnoreCase(FOOBAR, foo)\");\n    assertFalse(StringUtils.endsWithIgnoreCase(foo, foobar), \"endsWithIgnoreCase(foo, foobar)\");\n    assertFalse(StringUtils.endsWithIgnoreCase(bar, foobar), \"endsWithIgnoreCase(foo, foobar)\");\n    assertTrue(StringUtils.endsWithIgnoreCase(foobar, bar), \"endsWithIgnoreCase(foobar, bar)\");\n    assertTrue(StringUtils.endsWithIgnoreCase(FOOBAR, BAR), \"endsWithIgnoreCase(FOOBAR, BAR)\");\n    assertTrue(StringUtils.endsWithIgnoreCase(foobar, BAR), \"endsWithIgnoreCase(foobar, BAR)\");\n    assertTrue(StringUtils.endsWithIgnoreCase(FOOBAR, bar), \"endsWithIgnoreCase(FOOBAR, bar)\");\n    // javadoc\n    assertTrue(StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\"));\n    assertTrue(StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\"));\n    assertFalse(StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\"));\n    // \"alpha, beta, gamma, delta\".endsWith(\"DELTA\")\n    assertTrue(StringUtils.endsWithIgnoreCase(\"\\u03B1\\u03B2\\u03B3\\u03B4\", \"\\u0394\"), \"endsWith(\\u03B1\\u03B2\\u03B3\\u03B4, \\u0394)\");\n    // \"alpha, beta, gamma, delta\".endsWith(\"GAMMA\")\n    assertFalse(StringUtils.endsWithIgnoreCase(\"\\u03B1\\u03B2\\u03B3\\u03B4\", \"\\u0393\"), \"endsWith(\\u03B1\\u03B2\\u03B3\\u03B4, \\u0393)\");\n}", "repo_id": "8", "comment": "/**\n * Test StringUtils.endsWithIgnoreCase()\n */\n", "repo_name": "commons-lang-master/", "id": 1427, "method_signature": "void testEndsWithIgnoreCase()", "filename": "StringUtilsStartsEndsWithTest.testEndsWithIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtilsStartsEndsWithTest.testStartsWith", "method_implementation": "{\n    assertTrue(StringUtils.startsWith(null, null), \"startsWith(null, null)\");\n    assertFalse(StringUtils.startsWith(FOOBAR, null), \"startsWith(FOOBAR, null)\");\n    assertFalse(StringUtils.startsWith(null, FOO), \"startsWith(null, FOO)\");\n    assertTrue(StringUtils.startsWith(FOOBAR, \"\"), \"startsWith(FOOBAR, \\\"\\\")\");\n    assertTrue(StringUtils.startsWith(foobar, foo), \"startsWith(foobar, foo)\");\n    assertTrue(StringUtils.startsWith(FOOBAR, FOO), \"startsWith(FOOBAR, FOO)\");\n    assertFalse(StringUtils.startsWith(foobar, FOO), \"startsWith(foobar, FOO)\");\n    assertFalse(StringUtils.startsWith(FOOBAR, foo), \"startsWith(FOOBAR, foo)\");\n    assertFalse(StringUtils.startsWith(foo, foobar), \"startsWith(foo, foobar)\");\n    assertFalse(StringUtils.startsWith(bar, foobar), \"startsWith(foo, foobar)\");\n    assertFalse(StringUtils.startsWith(foobar, bar), \"startsWith(foobar, bar)\");\n    assertFalse(StringUtils.startsWith(FOOBAR, BAR), \"startsWith(FOOBAR, BAR)\");\n    assertFalse(StringUtils.startsWith(foobar, BAR), \"startsWith(foobar, BAR)\");\n    assertFalse(StringUtils.startsWith(FOOBAR, bar), \"startsWith(FOOBAR, bar)\");\n}", "repo_id": "8", "comment": "/**\n * Test StringUtils.startsWith()\n */\n", "repo_name": "commons-lang-master/", "id": 1428, "method_signature": "void testStartsWith()", "filename": "StringUtilsStartsEndsWithTest.testStartsWith.json"}
{"callee_method_names": [], "method_name": "StringUtilsStartsEndsWithTest.testStartsWithIgnoreCase", "method_implementation": "{\n    assertTrue(StringUtils.startsWithIgnoreCase(null, null), \"startsWithIgnoreCase(null, null)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(FOOBAR, null), \"startsWithIgnoreCase(FOOBAR, null)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(null, FOO), \"startsWithIgnoreCase(null, FOO)\");\n    assertTrue(StringUtils.startsWithIgnoreCase(FOOBAR, \"\"), \"startsWithIgnoreCase(FOOBAR, \\\"\\\")\");\n    assertTrue(StringUtils.startsWithIgnoreCase(foobar, foo), \"startsWithIgnoreCase(foobar, foo)\");\n    assertTrue(StringUtils.startsWithIgnoreCase(FOOBAR, FOO), \"startsWithIgnoreCase(FOOBAR, FOO)\");\n    assertTrue(StringUtils.startsWithIgnoreCase(foobar, FOO), \"startsWithIgnoreCase(foobar, FOO)\");\n    assertTrue(StringUtils.startsWithIgnoreCase(FOOBAR, foo), \"startsWithIgnoreCase(FOOBAR, foo)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(foo, foobar), \"startsWithIgnoreCase(foo, foobar)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(bar, foobar), \"startsWithIgnoreCase(foo, foobar)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(foobar, bar), \"startsWithIgnoreCase(foobar, bar)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(FOOBAR, BAR), \"startsWithIgnoreCase(FOOBAR, BAR)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(foobar, BAR), \"startsWithIgnoreCase(foobar, BAR)\");\n    assertFalse(StringUtils.startsWithIgnoreCase(FOOBAR, bar), \"startsWithIgnoreCase(FOOBAR, bar)\");\n}", "repo_id": "8", "comment": "/**\n * Test StringUtils.testStartsWithIgnoreCase()\n */\n", "repo_name": "commons-lang-master/", "id": 1429, "method_signature": "void testStartsWithIgnoreCase()", "filename": "StringUtilsStartsEndsWithTest.testStartsWithIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtilsSubstringTest.testSubstringsBetween_StringStringString", "method_implementation": "{\n    String[] results = StringUtils.substringsBetween(\"[one], [two], [three]\", \"[\", \"]\");\n    assertEquals(3, results.length);\n    assertEquals(\"one\", results[0]);\n    assertEquals(\"two\", results[1]);\n    assertEquals(\"three\", results[2]);\n    results = StringUtils.substringsBetween(\"[one], [two], three\", \"[\", \"]\");\n    assertEquals(2, results.length);\n    assertEquals(\"one\", results[0]);\n    assertEquals(\"two\", results[1]);\n    results = StringUtils.substringsBetween(\"[one], [two], three]\", \"[\", \"]\");\n    assertEquals(2, results.length);\n    assertEquals(\"one\", results[0]);\n    assertEquals(\"two\", results[1]);\n    results = StringUtils.substringsBetween(\"[one], two], three]\", \"[\", \"]\");\n    assertEquals(1, results.length);\n    assertEquals(\"one\", results[0]);\n    results = StringUtils.substringsBetween(\"one], two], [three]\", \"[\", \"]\");\n    assertEquals(1, results.length);\n    assertEquals(\"three\", results[0]);\n    // 'ab hello ba' will match, but 'ab non ba' won't\n    // this is because the 'a' is shared between the two and can't be matched twice\n    results = StringUtils.substringsBetween(\"aabhellobabnonba\", \"ab\", \"ba\");\n    assertEquals(1, results.length);\n    assertEquals(\"hello\", results[0]);\n    results = StringUtils.substringsBetween(\"one, two, three\", \"[\", \"]\");\n    assertNull(results);\n    results = StringUtils.substringsBetween(\"[one, two, three\", \"[\", \"]\");\n    assertNull(results);\n    results = StringUtils.substringsBetween(\"one, two, three]\", \"[\", \"]\");\n    assertNull(results);\n    results = StringUtils.substringsBetween(\"[one], [two], [three]\", \"[\", null);\n    assertNull(results);\n    results = StringUtils.substringsBetween(\"[one], [two], [three]\", null, \"]\");\n    assertNull(results);\n    results = StringUtils.substringsBetween(\"[one], [two], [three]\", \"\", \"\");\n    assertNull(results);\n    results = StringUtils.substringsBetween(null, \"[\", \"]\");\n    assertNull(results);\n    results = StringUtils.substringsBetween(\"\", \"[\", \"]\");\n    assertEquals(0, results.length);\n}", "repo_id": "8", "comment": "/**\n * Tests the substringsBetween method that returns a String Array of substrings.\n */\n", "repo_name": "commons-lang-master/", "id": 2027, "method_signature": "void testSubstringsBetween_StringStringString()", "filename": "StringUtilsSubstringTest.testSubstringsBetween_StringStringString.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testAbbreviateMarkerWithEmptyString", "method_implementation": "{\n    final String greaterThanMaxTest = \"much too long text\";\n    assertEquals(\"much too long\", StringUtils.abbreviate(greaterThanMaxTest, \"\", 13));\n}", "repo_id": "8", "comment": "//Fixed LANG-1463\n", "repo_name": "commons-lang-master/", "id": 1767, "method_signature": "void testAbbreviateMarkerWithEmptyString()", "filename": "StringUtilsTest.testAbbreviateMarkerWithEmptyString.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testAppendIfMissing", "method_implementation": "{\n    assertNull(StringUtils.appendIfMissing(null, null), \"appendIfMissing(null,null)\");\n    assertEquals(\"abc\", StringUtils.appendIfMissing(\"abc\", null), \"appendIfMissing(abc,null)\");\n    assertEquals(\"xyz\", StringUtils.appendIfMissing(\"\", \"xyz\"), \"appendIfMissing(\\\"\\\",xyz)\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissing(\"abc\", \"xyz\"), \"appendIfMissing(abc,xyz)\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissing(\"abcxyz\", \"xyz\"), \"appendIfMissing(abcxyz,xyz)\");\n    assertEquals(\"aXYZxyz\", StringUtils.appendIfMissing(\"aXYZ\", \"xyz\"), \"appendIfMissing(aXYZ,xyz)\");\n    assertNull(StringUtils.appendIfMissing(null, null, (CharSequence[]) null), \"appendIfMissing(null,null,null)\");\n    assertEquals(\"abc\", StringUtils.appendIfMissing(\"abc\", null, (CharSequence[]) null), \"appendIfMissing(abc,null,null)\");\n    assertEquals(\"xyz\", StringUtils.appendIfMissing(\"\", \"xyz\", (CharSequence[]) null), \"appendIfMissing(\\\"\\\",xyz,null))\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissing(\"abc\", \"xyz\", null), \"appendIfMissing(abc,xyz,{null})\");\n    assertEquals(\"abc\", StringUtils.appendIfMissing(\"abc\", \"xyz\", \"\"), \"appendIfMissing(abc,xyz,\\\"\\\")\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissing(\"abc\", \"xyz\", \"mno\"), \"appendIfMissing(abc,xyz,mno)\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissing(\"abcxyz\", \"xyz\", \"mno\"), \"appendIfMissing(abcxyz,xyz,mno)\");\n    assertEquals(\"abcmno\", StringUtils.appendIfMissing(\"abcmno\", \"xyz\", \"mno\"), \"appendIfMissing(abcmno,xyz,mno)\");\n    assertEquals(\"abcXYZxyz\", StringUtils.appendIfMissing(\"abcXYZ\", \"xyz\", \"mno\"), \"appendIfMissing(abcXYZ,xyz,mno)\");\n    assertEquals(\"abcMNOxyz\", StringUtils.appendIfMissing(\"abcMNO\", \"xyz\", \"mno\"), \"appendIfMissing(abcMNO,xyz,mno)\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@code appendIfMissing}.\n */\n", "repo_name": "commons-lang-master/", "id": 1768, "method_signature": "void testAppendIfMissing()", "filename": "StringUtilsTest.testAppendIfMissing.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testAppendIfMissingIgnoreCase", "method_implementation": "{\n    assertNull(StringUtils.appendIfMissingIgnoreCase(null, null), \"appendIfMissingIgnoreCase(null,null)\");\n    assertEquals(\"abc\", StringUtils.appendIfMissingIgnoreCase(\"abc\", null), \"appendIfMissingIgnoreCase(abc,null)\");\n    assertEquals(\"xyz\", StringUtils.appendIfMissingIgnoreCase(\"\", \"xyz\"), \"appendIfMissingIgnoreCase(\\\"\\\",xyz)\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\"), \"appendIfMissingIgnoreCase(abc,xyz)\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissingIgnoreCase(\"abcxyz\", \"xyz\"), \"appendIfMissingIgnoreCase(abcxyz,xyz)\");\n    assertEquals(\"abcXYZ\", StringUtils.appendIfMissingIgnoreCase(\"abcXYZ\", \"xyz\"), \"appendIfMissingIgnoreCase(abcXYZ,xyz)\");\n    assertNull(StringUtils.appendIfMissingIgnoreCase(null, null, (CharSequence[]) null), \"appendIfMissingIgnoreCase(null,null,null)\");\n    assertEquals(\"abc\", StringUtils.appendIfMissingIgnoreCase(\"abc\", null, (CharSequence[]) null), \"appendIfMissingIgnoreCase(abc,null,null)\");\n    assertEquals(\"xyz\", StringUtils.appendIfMissingIgnoreCase(\"\", \"xyz\", (CharSequence[]) null), \"appendIfMissingIgnoreCase(\\\"\\\",xyz,null)\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\", null), \"appendIfMissingIgnoreCase(abc,xyz,{null})\");\n    assertEquals(\"abc\", StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\", \"\"), \"appendIfMissingIgnoreCase(abc,xyz,\\\"\\\")\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissingIgnoreCase(\"abc\", \"xyz\", \"mno\"), \"appendIfMissingIgnoreCase(abc,xyz,mno)\");\n    assertEquals(\"abcxyz\", StringUtils.appendIfMissingIgnoreCase(\"abcxyz\", \"xyz\", \"mno\"), \"appendIfMissingIgnoreCase(abcxyz,xyz,mno)\");\n    assertEquals(\"abcmno\", StringUtils.appendIfMissingIgnoreCase(\"abcmno\", \"xyz\", \"mno\"), \"appendIfMissingIgnoreCase(abcmno,xyz,mno)\");\n    assertEquals(\"abcXYZ\", StringUtils.appendIfMissingIgnoreCase(\"abcXYZ\", \"xyz\", \"mno\"), \"appendIfMissingIgnoreCase(abcXYZ,xyz,mno)\");\n    assertEquals(\"abcMNO\", StringUtils.appendIfMissingIgnoreCase(\"abcMNO\", \"xyz\", \"mno\"), \"appendIfMissingIgnoreCase(abcMNO,xyz,mno)\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@code appendIfMissingIgnoreCase}.\n */\n", "repo_name": "commons-lang-master/", "id": 1769, "method_signature": "void testAppendIfMissingIgnoreCase()", "filename": "StringUtilsTest.testAppendIfMissingIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testEMPTY", "method_implementation": "{\n    assertNotNull(StringUtils.EMPTY);\n    assertEquals(\"\", StringUtils.EMPTY);\n    assertEquals(0, StringUtils.EMPTY.length());\n}", "repo_id": "8", "comment": "/**\n * A sanity check for {@link StringUtils#EMPTY}.\n */\n", "repo_name": "commons-lang-master/", "id": 1770, "method_signature": "void testEMPTY()", "filename": "StringUtilsTest.testEMPTY.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testEscapeSurrogatePairsLang858", "method_implementation": "{\n    //fail LANG-858\n    assertEquals(\"\\\\uDBFF\\\\uDFFD\", StringEscapeUtils.escapeJava(\"\\uDBFF\\uDFFD\"));\n    //fail LANG-858\n    assertEquals(\"\\\\uDBFF\\\\uDFFD\", StringEscapeUtils.escapeEcmaScript(\"\\uDBFF\\uDFFD\"));\n}", "repo_id": "8", "comment": "/**\n * Tests LANG-858.\n */\n", "repo_name": "commons-lang-master/", "id": 1771, "method_signature": "void testEscapeSurrogatePairsLang858()", "filename": "StringUtilsTest.testEscapeSurrogatePairsLang858.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testIsAllLowerCase", "method_implementation": "{\n    assertFalse(StringUtils.isAllLowerCase(null));\n    assertFalse(StringUtils.isAllLowerCase(StringUtils.EMPTY));\n    assertFalse(StringUtils.isAllLowerCase(\"  \"));\n    assertTrue(StringUtils.isAllLowerCase(\"abc\"));\n    assertFalse(StringUtils.isAllLowerCase(\"abc \"));\n    assertFalse(StringUtils.isAllLowerCase(\"abc\\n\"));\n    assertFalse(StringUtils.isAllLowerCase(\"abC\"));\n    assertFalse(StringUtils.isAllLowerCase(\"ab c\"));\n    assertFalse(StringUtils.isAllLowerCase(\"ab1c\"));\n    assertFalse(StringUtils.isAllLowerCase(\"ab/c\"));\n}", "repo_id": "8", "comment": "/**\n * Test for {@link StringUtils#isAllLowerCase(CharSequence)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1772, "method_signature": "void testIsAllLowerCase()", "filename": "StringUtilsTest.testIsAllLowerCase.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testIsAllUpperCase", "method_implementation": "{\n    assertFalse(StringUtils.isAllUpperCase(null));\n    assertFalse(StringUtils.isAllUpperCase(StringUtils.EMPTY));\n    assertFalse(StringUtils.isAllUpperCase(\"  \"));\n    assertTrue(StringUtils.isAllUpperCase(\"ABC\"));\n    assertFalse(StringUtils.isAllUpperCase(\"ABC \"));\n    assertFalse(StringUtils.isAllUpperCase(\"ABC\\n\"));\n    assertFalse(StringUtils.isAllUpperCase(\"aBC\"));\n    assertFalse(StringUtils.isAllUpperCase(\"A C\"));\n    assertFalse(StringUtils.isAllUpperCase(\"A1C\"));\n    assertFalse(StringUtils.isAllUpperCase(\"A/C\"));\n}", "repo_id": "8", "comment": "/**\n * Test for {@link StringUtils#isAllUpperCase(CharSequence)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1773, "method_signature": "void testIsAllUpperCase()", "filename": "StringUtilsTest.testIsAllUpperCase.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testIsMixedCase", "method_implementation": "{\n    assertFalse(StringUtils.isMixedCase(null));\n    assertFalse(StringUtils.isMixedCase(StringUtils.EMPTY));\n    assertFalse(StringUtils.isMixedCase(\" \"));\n    assertFalse(StringUtils.isMixedCase(\"A\"));\n    assertFalse(StringUtils.isMixedCase(\"a\"));\n    assertFalse(StringUtils.isMixedCase(\"/\"));\n    assertFalse(StringUtils.isMixedCase(\"A/\"));\n    assertFalse(StringUtils.isMixedCase(\"/b\"));\n    assertFalse(StringUtils.isMixedCase(\"abc\"));\n    assertFalse(StringUtils.isMixedCase(\"ABC\"));\n    assertTrue(StringUtils.isMixedCase(\"aBc\"));\n    assertTrue(StringUtils.isMixedCase(\"aBc \"));\n    assertTrue(StringUtils.isMixedCase(\"A c\"));\n    assertTrue(StringUtils.isMixedCase(\"aBc\\n\"));\n    assertTrue(StringUtils.isMixedCase(\"A1c\"));\n    assertTrue(StringUtils.isMixedCase(\"a/C\"));\n}", "repo_id": "8", "comment": "/**\n * Test for {@link StringUtils#isMixedCase(CharSequence)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1774, "method_signature": "void testIsMixedCase()", "filename": "StringUtilsTest.testIsMixedCase.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testPrependIfMissing", "method_implementation": "{\n    assertNull(StringUtils.prependIfMissing(null, null), \"prependIfMissing(null,null)\");\n    assertEquals(\"abc\", StringUtils.prependIfMissing(\"abc\", null), \"prependIfMissing(abc,null)\");\n    assertEquals(\"xyz\", StringUtils.prependIfMissing(\"\", \"xyz\"), \"prependIfMissing(\\\"\\\",xyz)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissing(\"abc\", \"xyz\"), \"prependIfMissing(abc,xyz)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissing(\"xyzabc\", \"xyz\"), \"prependIfMissing(xyzabc,xyz)\");\n    assertEquals(\"xyzXYZabc\", StringUtils.prependIfMissing(\"XYZabc\", \"xyz\"), \"prependIfMissing(XYZabc,xyz)\");\n    assertNull(StringUtils.prependIfMissing(null, null, (CharSequence[]) null), \"prependIfMissing(null,null null)\");\n    assertEquals(\"abc\", StringUtils.prependIfMissing(\"abc\", null, (CharSequence[]) null), \"prependIfMissing(abc,null,null)\");\n    assertEquals(\"xyz\", StringUtils.prependIfMissing(\"\", \"xyz\", (CharSequence[]) null), \"prependIfMissing(\\\"\\\",xyz,null)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissing(\"abc\", \"xyz\", null), \"prependIfMissing(abc,xyz,{null})\");\n    assertEquals(\"abc\", StringUtils.prependIfMissing(\"abc\", \"xyz\", \"\"), \"prependIfMissing(abc,xyz,\\\"\\\")\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissing(\"abc\", \"xyz\", \"mno\"), \"prependIfMissing(abc,xyz,mno)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissing(\"xyzabc\", \"xyz\", \"mno\"), \"prependIfMissing(xyzabc,xyz,mno)\");\n    assertEquals(\"mnoabc\", StringUtils.prependIfMissing(\"mnoabc\", \"xyz\", \"mno\"), \"prependIfMissing(mnoabc,xyz,mno)\");\n    assertEquals(\"xyzXYZabc\", StringUtils.prependIfMissing(\"XYZabc\", \"xyz\", \"mno\"), \"prependIfMissing(XYZabc,xyz,mno)\");\n    assertEquals(\"xyzMNOabc\", StringUtils.prependIfMissing(\"MNOabc\", \"xyz\", \"mno\"), \"prependIfMissing(MNOabc,xyz,mno)\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@code prependIfMissing}.\n */\n", "repo_name": "commons-lang-master/", "id": 1775, "method_signature": "void testPrependIfMissing()", "filename": "StringUtilsTest.testPrependIfMissing.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testPrependIfMissingIgnoreCase", "method_implementation": "{\n    assertNull(StringUtils.prependIfMissingIgnoreCase(null, null), \"prependIfMissingIgnoreCase(null,null)\");\n    assertEquals(\"abc\", StringUtils.prependIfMissingIgnoreCase(\"abc\", null), \"prependIfMissingIgnoreCase(abc,null)\");\n    assertEquals(\"xyz\", StringUtils.prependIfMissingIgnoreCase(\"\", \"xyz\"), \"prependIfMissingIgnoreCase(\\\"\\\",xyz)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\"), \"prependIfMissingIgnoreCase(abc,xyz)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissingIgnoreCase(\"xyzabc\", \"xyz\"), \"prependIfMissingIgnoreCase(xyzabc,xyz)\");\n    assertEquals(\"XYZabc\", StringUtils.prependIfMissingIgnoreCase(\"XYZabc\", \"xyz\"), \"prependIfMissingIgnoreCase(XYZabc,xyz)\");\n    assertNull(StringUtils.prependIfMissingIgnoreCase(null, null, (CharSequence[]) null), \"prependIfMissingIgnoreCase(null,null null)\");\n    assertEquals(\"abc\", StringUtils.prependIfMissingIgnoreCase(\"abc\", null, (CharSequence[]) null), \"prependIfMissingIgnoreCase(abc,null,null)\");\n    assertEquals(\"xyz\", StringUtils.prependIfMissingIgnoreCase(\"\", \"xyz\", (CharSequence[]) null), \"prependIfMissingIgnoreCase(\\\"\\\",xyz,null)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\", null), \"prependIfMissingIgnoreCase(abc,xyz,{null})\");\n    assertEquals(\"abc\", StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\", \"\"), \"prependIfMissingIgnoreCase(abc,xyz,\\\"\\\")\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissingIgnoreCase(\"abc\", \"xyz\", \"mno\"), \"prependIfMissingIgnoreCase(abc,xyz,mno)\");\n    assertEquals(\"xyzabc\", StringUtils.prependIfMissingIgnoreCase(\"xyzabc\", \"xyz\", \"mno\"), \"prependIfMissingIgnoreCase(xyzabc,xyz,mno)\");\n    assertEquals(\"mnoabc\", StringUtils.prependIfMissingIgnoreCase(\"mnoabc\", \"xyz\", \"mno\"), \"prependIfMissingIgnoreCase(mnoabc,xyz,mno)\");\n    assertEquals(\"XYZabc\", StringUtils.prependIfMissingIgnoreCase(\"XYZabc\", \"xyz\", \"mno\"), \"prependIfMissingIgnoreCase(XYZabc,xyz,mno)\");\n    assertEquals(\"MNOabc\", StringUtils.prependIfMissingIgnoreCase(\"MNOabc\", \"xyz\", \"mno\"), \"prependIfMissingIgnoreCase(MNOabc,xyz,mno)\");\n}", "repo_id": "8", "comment": "/**\n * Tests {@code prependIfMissingIgnoreCase}.\n */\n", "repo_name": "commons-lang-master/", "id": 1776, "method_signature": "void testPrependIfMissingIgnoreCase()", "filename": "StringUtilsTest.testPrependIfMissingIgnoreCase.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testReplace_StringStringArrayStringArray", "method_implementation": "{\n    //JAVADOC TESTS START\n    assertNull(StringUtils.replaceEach(null, new String[] { \"a\" }, new String[] { \"b\" }));\n    assertEquals(StringUtils.replaceEach(\"\", new String[] { \"a\" }, new String[] { \"b\" }), \"\");\n    assertEquals(StringUtils.replaceEach(\"aba\", null, null), \"aba\");\n    assertEquals(StringUtils.replaceEach(\"aba\", new String[0], null), \"aba\");\n    assertEquals(StringUtils.replaceEach(\"aba\", null, new String[0]), \"aba\");\n    assertEquals(StringUtils.replaceEach(\"aba\", new String[] { \"a\" }, null), \"aba\");\n    assertEquals(StringUtils.replaceEach(\"aba\", new String[] { \"a\" }, new String[] { \"\" }), \"b\");\n    assertEquals(StringUtils.replaceEach(\"aba\", new String[] { null }, new String[] { \"a\" }), \"aba\");\n    assertEquals(StringUtils.replaceEach(\"abcde\", new String[] { \"ab\", \"d\" }, new String[] { \"w\", \"t\" }), \"wcte\");\n    assertEquals(StringUtils.replaceEach(\"abcde\", new String[] { \"ab\", \"d\" }, new String[] { \"d\", \"t\" }), \"dcte\");\n    //JAVADOC TESTS END\n    assertEquals(\"bcc\", StringUtils.replaceEach(\"abc\", new String[] { \"a\", \"b\" }, new String[] { \"b\", \"c\" }));\n    assertEquals(\"q651.506bera\", StringUtils.replaceEach(\"d216.102oren\", new String[] { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\" }, new String[] { \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\" }));\n    // Test null safety inside arrays - LANG-552\n    assertEquals(StringUtils.replaceEach(\"aba\", new String[] { \"a\" }, new String[] { null }), \"aba\");\n    assertEquals(StringUtils.replaceEach(\"aba\", new String[] { \"a\", \"b\" }, new String[] { \"c\", null }), \"cbc\");\n    assertThrows(IllegalArgumentException.class, () -> StringUtils.replaceEach(\"abba\", new String[] { \"a\" }, new String[] { \"b\", \"a\" }), \"StringUtils.replaceEach(String, String[], String[]) expecting IllegalArgumentException\");\n}", "repo_id": "8", "comment": "/**\n * Test method for 'StringUtils.replaceEach(String, String[], String[])'\n */\n", "repo_name": "commons-lang-master/", "id": 1777, "method_signature": "void testReplace_StringStringArrayStringArray()", "filename": "StringUtilsTest.testReplace_StringStringArrayStringArray.json"}
{"callee_method_names": [], "method_name": "StringUtilsTest.testReplace_StringStringArrayStringArrayBoolean", "method_implementation": "{\n    //JAVADOC TESTS START\n    assertNull(StringUtils.replaceEachRepeatedly(null, new String[] { \"a\" }, new String[] { \"b\" }));\n    assertEquals(\"\", StringUtils.replaceEachRepeatedly(\"\", new String[] { \"a\" }, new String[] { \"b\" }));\n    assertEquals(\"aba\", StringUtils.replaceEachRepeatedly(\"aba\", null, null));\n    assertEquals(\"aba\", StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null));\n    assertEquals(\"aba\", StringUtils.replaceEachRepeatedly(\"aba\", null, new String[0]));\n    assertEquals(\"aba\", StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null));\n    assertEquals(\"b\", StringUtils.replaceEachRepeatedly(\"aba\", new String[] { \"a\" }, new String[] { \"\" }));\n    assertEquals(\"aba\", StringUtils.replaceEachRepeatedly(\"aba\", new String[] { null }, new String[] { \"a\" }));\n    assertEquals(\"wcte\", StringUtils.replaceEachRepeatedly(\"abcde\", new String[] { \"ab\", \"d\" }, new String[] { \"w\", \"t\" }));\n    assertEquals(\"tcte\", StringUtils.replaceEachRepeatedly(\"abcde\", new String[] { \"ab\", \"d\" }, new String[] { \"d\", \"t\" }));\n    assertEquals(\"blaan\", StringUtils.replaceEachRepeatedly(\"blllaan\", new String[] { \"llaan\" }, new String[] { \"laan\" }));\n    assertThrows(IllegalStateException.class, () -> StringUtils.replaceEachRepeatedly(\"abcde\", new String[] { \"ab\", \"d\" }, new String[] { \"d\", \"ab\" }), \"Should be a circular reference\");\n    //JAVADOC TESTS END\n}", "repo_id": "8", "comment": "/**\n * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])'\n */\n", "repo_name": "commons-lang-master/", "id": 1778, "method_signature": "void testReplace_StringStringArrayStringArrayBoolean()", "filename": "StringUtilsTest.testReplace_StringStringArrayStringArrayBoolean.json"}
{"callee_method_names": ["Class<StringUtils>.getMethods", "int.toString", "int.getReturnType", "int.getReturnType", "int.getParameterTypes", "int.getParameterTypes"], "method_name": "StringUtilsTest.testStringUtilsCharSequenceContract", "method_implementation": "{\n    final Class<StringUtils> c = StringUtils.class;\n    // Methods that are expressly excluded from testStringUtilsCharSequenceContract()\n    final String[] excludeMethods = { \"public static int org.apache.commons.lang3.StringUtils.compare(java.lang.String,java.lang.String)\", \"public static int org.apache.commons.lang3.StringUtils.compare(java.lang.String,java.lang.String,boolean)\", \"public static int org.apache.commons.lang3.StringUtils.compareIgnoreCase(java.lang.String,java.lang.String)\", \"public static int org.apache.commons.lang3.StringUtils.compareIgnoreCase(java.lang.String,java.lang.String,boolean)\", \"public static byte[] org.apache.commons.lang3.StringUtils.getBytes(java.lang.String,java.nio.charset.Charset)\", \"public static byte[] org.apache.commons.lang3.StringUtils.getBytes(java.lang.String,java.lang.String) throws java.io.UnsupportedEncodingException\" };\n    final Method[] methods = c.getMethods();\n    for (final Method m : methods) {\n        final String methodStr = m.toString();\n        if (m.getReturnType() == String.class || m.getReturnType() == String[].class) {\n            // Assume this is mutable and ensure the first parameter is not CharSequence.\n            // It may be String or it may be something else (String[], Object, Object[]) so\n            // don't actively test for that.\n            final Class<?>[] params = m.getParameterTypes();\n            if (params.length > 0 && (params[0] == CharSequence.class || params[0] == CharSequence[].class)) {\n                assertFalse(ArrayUtils.contains(excludeMethods, methodStr), \"The method \\\"\" + methodStr + \"\\\" appears to be mutable in spirit and therefore must not accept a CharSequence\");\n            }\n        } else {\n            // Assume this is immutable in spirit and ensure the first parameter is not String.\n            // As above, it may be something other than CharSequence.\n            final Class<?>[] params = m.getParameterTypes();\n            if (params.length > 0 && (params[0] == String.class || params[0] == String[].class)) {\n                assertTrue(ArrayUtils.contains(excludeMethods, methodStr), \"The method \\\"\" + methodStr + \"\\\" appears to be immutable in spirit and therefore must not accept a String\");\n            }\n        }\n    }\n}", "repo_id": "8", "comment": "// This test enforces that this is done.\n", "repo_name": "commons-lang-master/", "id": 1779, "method_signature": "void testStringUtilsCharSequenceContract()", "filename": "StringUtilsTest.testStringUtilsCharSequenceContract.json"}
{"callee_method_names": ["String.getBytes", "String.getBytes", "String.getBytes"], "method_name": "StringUtilsTest.testToEncodedString", "method_implementation": "{\n    final String expectedString = \"The quick brown fox jumps over the lazy dog.\";\n    String encoding = SystemUtils.FILE_ENCODING;\n    byte[] expectedBytes = expectedString.getBytes(Charset.defaultCharset());\n    // sanity check start\n    assertArrayEquals(expectedBytes, expectedString.getBytes());\n    // sanity check end\n    assertEquals(expectedString, StringUtils.toEncodedString(expectedBytes, Charset.defaultCharset()));\n    assertEquals(expectedString, StringUtils.toEncodedString(expectedBytes, Charset.forName(encoding)));\n    encoding = StandardCharsets.UTF_16.name();\n    expectedBytes = expectedString.getBytes(Charset.forName(encoding));\n    assertEquals(expectedString, StringUtils.toEncodedString(expectedBytes, Charset.forName(encoding)));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link StringUtils#toEncodedString(byte[], Charset)}\n *\n * @see StringUtils#toEncodedString(byte[], Charset)\n */\n", "repo_name": "commons-lang-master/", "id": 1780, "method_signature": "void testToEncodedString()", "filename": "StringUtilsTest.testToEncodedString.json"}
{"callee_method_names": ["String.getBytes", "String.getBytes", "String.getBytes"], "method_name": "StringUtilsTest.testToString", "method_implementation": "{\n    final String expectedString = \"The quick brown fox jumps over the lazy dog.\";\n    byte[] expectedBytes = expectedString.getBytes(Charset.defaultCharset());\n    // sanity check start\n    assertArrayEquals(expectedBytes, expectedString.getBytes());\n    // sanity check end\n    assertEquals(expectedString, StringUtils.toString(expectedBytes, null));\n    assertEquals(expectedString, StringUtils.toString(expectedBytes, SystemUtils.FILE_ENCODING));\n    final String encoding = StandardCharsets.UTF_16.name();\n    expectedBytes = expectedString.getBytes(Charset.forName(encoding));\n    assertEquals(expectedString, StringUtils.toString(expectedBytes, encoding));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link StringUtils#toString(byte[], String)}\n *\n * @throws java.io.UnsupportedEncodingException because the method under test max throw it\n * @see StringUtils#toString(byte[], String)\n */\n", "repo_name": "commons-lang-master/", "id": 1781, "method_signature": "void testToString()", "filename": "StringUtilsTest.testToString.json"}
{"callee_method_names": [], "method_name": "SuppliersTest.testGet", "method_implementation": "{\n    assertNull(Suppliers.get(null));\n    assertNull(Suppliers.get(() -> null));\n    assertNull(Suppliers.get(Suppliers.nul()));\n    assertEquals(\"foo\", Suppliers.get(() -> \"foo\"));\n}", "repo_id": "8", "comment": "/**\n * Tests {@link Suppliers#get(Supplier)}.\n */\n", "repo_name": "commons-lang-master/", "id": 1588, "method_signature": "void testGet()", "filename": "SuppliersTest.testGet.json"}
{"callee_method_names": ["Supplier<String>.get", "Supplier<String>.get"], "method_name": "SystemProperties.getProperty", "method_implementation": "{\n    try {\n        if (StringUtils.isEmpty(property)) {\n            return defaultValue.get();\n        }\n        final String value = System.getProperty(property);\n        return StringUtils.getIfEmpty(value, defaultValue);\n    } catch (final SecurityException ignore) {\n        // We are not allowed to look at this property.\n        //\n        // System.err.println(\"Caught a SecurityException reading the system property '\" + property\n        // + \"'; the SystemUtils property value will default to null.\");\n        return defaultValue.get();\n    }\n}", "repo_id": "8", "comment": "/**\n * Gets a System property, defaulting to {@code null} if the property cannot be read.\n * <p>\n * If a {@link SecurityException} is caught, the return value is {@code null}.\n * </p>\n *\n * @param property        the system property name.\n * @param defaultValue get this Supplier when the property is empty or throws SecurityException.\n * @return the system property value or {@code null} if a security problem occurs\n */\n", "repo_name": "commons-lang-master/", "id": 721, "method_signature": "String getProperty(String, Supplier)", "filename": "SystemProperties.getProperty.json"}
{"callee_method_names": [], "method_name": "SystemUtils.getEnvironmentVariable", "method_implementation": "{\n    try {\n        final String value = System.getenv(name);\n        return value == null ? defaultValue : value;\n    } catch (final SecurityException ex) {\n        // we are not allowed to look at this property\n        // System.err.println(\"Caught a SecurityException reading the environment variable '\" + name + \"'.\");\n        return defaultValue;\n    }\n}", "repo_id": "8", "comment": "/**\n * Gets an environment variable, defaulting to {@code defaultValue} if the variable cannot be read.\n *\n * <p>\n * If a {@link SecurityException} is caught, the return value is {@code defaultValue} and a message is written to\n * {@code System.err}.\n * </p>\n *\n * @param name\n *            the environment variable name\n * @param defaultValue\n *            the default value\n * @return the environment variable value or {@code defaultValue} if a security problem occurs\n * @since 3.8\n */\n", "repo_name": "commons-lang-master/", "id": 152, "method_signature": "String getEnvironmentVariable(String, String)", "filename": "SystemUtils.getEnvironmentVariable.json"}
{"callee_method_names": ["String.startsWith"], "method_name": "SystemUtils.isJavaVersionMatch", "method_implementation": "{\n    if (version == null) {\n        return false;\n    }\n    return version.startsWith(versionPrefix);\n}", "repo_id": "8", "comment": "/**\n * Decides if the Java version matches.\n *\n * <p>\n * This method is package private instead of private to support unit test invocation.\n * </p>\n *\n * @param version the actual Java version\n * @param versionPrefix the prefix for the expected Java version\n * @return true if matches, or false if not or can't determine\n */\n", "repo_name": "commons-lang-master/", "id": 153, "method_signature": "boolean isJavaVersionMatch(String, String)", "filename": "SystemUtils.isJavaVersionMatch.json"}
{"callee_method_names": [], "method_name": "SystemUtils.isOSMatch", "method_implementation": "{\n    if (osName == null || osVersion == null) {\n        return false;\n    }\n    return isOSNameMatch(osName, osNamePrefix) && isOSVersionMatch(osVersion, osVersionPrefix);\n}", "repo_id": "8", "comment": "/**\n * Decides if the operating system matches.\n * <p>\n * This method is package private instead of private to support unit test invocation.\n * </p>\n *\n * @param osName the actual OS name\n * @param osVersion the actual OS version\n * @param osNamePrefix the prefix for the expected OS name\n * @param osVersionPrefix the prefix for the expected OS version\n * @return true if matches, or false if not or can't determine\n */\n", "repo_name": "commons-lang-master/", "id": 154, "method_signature": "boolean isOSMatch(String, String, String, String)", "filename": "SystemUtils.isOSMatch.json"}
{"callee_method_names": ["String.startsWith"], "method_name": "SystemUtils.isOSNameMatch", "method_implementation": "{\n    if (osName == null) {\n        return false;\n    }\n    return osName.startsWith(osNamePrefix);\n}", "repo_id": "8", "comment": "/**\n * Decides if the operating system matches.\n * <p>\n * This method is package private instead of private to support unit test invocation.\n * </p>\n *\n * @param osName the actual OS name\n * @param osNamePrefix the prefix for the expected OS name\n * @return true if matches, or false if not or can't determine\n */\n", "repo_name": "commons-lang-master/", "id": 155, "method_signature": "boolean isOSNameMatch(String, String)", "filename": "SystemUtils.isOSNameMatch.json"}
{"callee_method_names": ["String.split", "String.split", "String[].equals"], "method_name": "SystemUtils.isOSVersionMatch", "method_implementation": "{\n    if (StringUtils.isEmpty(osVersion)) {\n        return false;\n    }\n    // Compare parts of the version string instead of using String.startsWith(String) because otherwise\n    // osVersionPrefix 10.1 would also match osVersion 10.10\n    final String[] versionPrefixParts = osVersionPrefix.split(\"\\\\.\");\n    final String[] versionParts = osVersion.split(\"\\\\.\");\n    for (int i = 0; i < Math.min(versionPrefixParts.length, versionParts.length); i++) {\n        if (!versionPrefixParts[i].equals(versionParts[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Decides if the operating system version matches.\n * <p>\n * This method is package private instead of private to support unit test invocation.\n * </p>\n *\n * @param osVersion the actual OS version\n * @param osVersionPrefix the prefix for the expected OS version\n * @return true if matches, or false if not or can't determine\n */\n", "repo_name": "commons-lang-master/", "id": 156, "method_signature": "boolean isOSVersionMatch(String, String)", "filename": "SystemUtils.isOSVersionMatch.json"}
{"callee_method_names": ["Field.getName", "Field.getName"], "method_name": "SystemUtilsTest.getLastSupportedJavaVersion", "method_implementation": "{\n    int lastSupportedVersion = 0;\n    for (Field field : SystemUtils.class.getFields()) {\n        if (field.getName().matches(\"IS_JAVA_\\\\d+\")) {\n            lastSupportedVersion = Math.max(lastSupportedVersion, Integer.parseInt(field.getName().substring(8)));\n        }\n    }\n    return lastSupportedVersion;\n}", "repo_id": "8", "comment": "/**\n * Returns the last supported version with the SystemUtils.IS_JAVA_X fields.\n */\n", "repo_name": "commons-lang-master/", "id": 1751, "method_signature": "int getLastSupportedJavaVersion()", "filename": "SystemUtilsTest.getLastSupportedJavaVersion.json"}
{"callee_method_names": ["File.exists"], "method_name": "SystemUtilsTest.testGetJavaHome", "method_implementation": "{\n    final File dir = SystemUtils.getJavaHome();\n    assertNotNull(dir);\n    assertTrue(dir.exists());\n}", "repo_id": "8", "comment": "/**\n * Assumes no security manager exists.\n */\n", "repo_name": "commons-lang-master/", "id": 1752, "method_signature": "void testGetJavaHome()", "filename": "SystemUtilsTest.testGetJavaHome.json"}
{"callee_method_names": ["File.exists"], "method_name": "SystemUtilsTest.testGetJavaIoTmpDir", "method_implementation": "{\n    final File dir = SystemUtils.getJavaIoTmpDir();\n    assertNotNull(dir);\n    assertTrue(dir.exists());\n}", "repo_id": "8", "comment": "/**\n * Assumes no security manager exists.\n */\n", "repo_name": "commons-lang-master/", "id": 1753, "method_signature": "void testGetJavaIoTmpDir()", "filename": "SystemUtilsTest.testGetJavaIoTmpDir.json"}
{"callee_method_names": ["File.exists"], "method_name": "SystemUtilsTest.testGetUserDir", "method_implementation": "{\n    final File dir = SystemUtils.getUserDir();\n    assertNotNull(dir);\n    assertTrue(dir.exists());\n}", "repo_id": "8", "comment": "/**\n * Assumes no security manager exists.\n */\n", "repo_name": "commons-lang-master/", "id": 1754, "method_signature": "void testGetUserDir()", "filename": "SystemUtilsTest.testGetUserDir.json"}
{"callee_method_names": ["File.exists"], "method_name": "SystemUtilsTest.testGetUserHome", "method_implementation": "{\n    final File dir = SystemUtils.getUserHome();\n    assertNotNull(dir);\n    assertTrue(dir.exists());\n}", "repo_id": "8", "comment": "/**\n * Assumes no security manager exists.\n */\n", "repo_name": "commons-lang-master/", "id": 1755, "method_signature": "void testGetUserHome()", "filename": "SystemUtilsTest.testGetUserHome.json"}
{"callee_method_names": [], "method_name": "SystemUtilsTest.testGetUserName", "method_implementation": "{\n    assertEquals(System.getProperty(\"user.name\"), SystemUtils.getUserName());\n    // Don't overwrite the system property in this test in case something goes awfully wrong.\n    assertEquals(System.getProperty(\"user.name\", \"foo\"), SystemUtils.getUserName(\"foo\"));\n}", "repo_id": "8", "comment": "/**\n * Assumes no security manager exists.\n */\n", "repo_name": "commons-lang-master/", "id": 1756, "method_signature": "void testGetUserName()", "filename": "SystemUtilsTest.testGetUserName.json"}
{"callee_method_names": [], "method_name": "TestCallable.call", "method_implementation": "{\n    callCount++;\n    return RESULT;\n}", "repo_id": "8", "comment": "/**\n * Records this invocation and returns the test result.\n */\n", "repo_name": "commons-lang-master/", "id": 1554, "method_signature": "Integer call()", "filename": "TestCallable.call.json"}
{"callee_method_names": ["String[].length"], "method_name": "TextField.estimateLength", "method_implementation": "{\n    int max = 0;\n    for (int i = values.length; --i >= 0; ) {\n        final int len = values[i].length();\n        if (len > max) {\n            max = len;\n        }\n    }\n    return max;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 676, "method_signature": "int estimateLength()", "filename": "TextField.estimateLength.json"}
{"callee_method_names": ["ThreadGroup.equals", "Thread.getThreadGroup"], "method_name": "ThreadUtils.findThreadById", "method_implementation": "{\n    Objects.requireNonNull(threadGroup, \"threadGroup\");\n    final Thread thread = findThreadById(threadId);\n    if (thread != null && threadGroup.equals(thread.getThreadGroup())) {\n        return thread;\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Finds the active thread with the specified id if it belongs to the specified thread group.\n *\n * @param threadId The thread id\n * @param threadGroup The thread group\n * @return The thread which belongs to a specified thread group and the thread's id match the specified id.\n * {@code null} is returned if no such thread exists\n * @throws NullPointerException if {@code threadGroup == null}\n * @throws IllegalArgumentException if the specified id is zero or negative\n * @throws  SecurityException\n *          if the current thread cannot access the system thread group\n *\n * @throws  SecurityException  if the current thread cannot modify\n *          thread groups from this thread's thread group up to the system thread group\n */\n", "repo_name": "commons-lang-master/", "id": 738, "method_signature": "Thread findThreadById(long, ThreadGroup)", "filename": "ThreadUtils.findThreadById.json"}
{"callee_method_names": ["ThreadGroup.activeGroupCount", "ThreadGroup.enumerate"], "method_name": "ThreadUtils.findThreadGroups", "method_implementation": "{\n    Objects.requireNonNull(threadGroup, \"threadGroup\");\n    Objects.requireNonNull(predicate, \"predicate\");\n    int count = threadGroup.activeGroupCount();\n    ThreadGroup[] threadGroups;\n    do {\n        //slightly grow the array size\n        threadGroups = new ThreadGroup[count + count / 2 + 1];\n        count = threadGroup.enumerate(threadGroups, recurse);\n        //return value of enumerate() must be strictly less than the array size according to Javadoc\n    } while (count >= threadGroups.length);\n    return Collections.unmodifiableCollection(Stream.of(threadGroups).limit(count).filter(predicate).collect(Collectors.toList()));\n}", "repo_id": "8", "comment": "/**\n * Finds all active thread groups which match the given predicate and which is a subgroup of the given thread group (or one of its subgroups).\n *\n * @param threadGroup the thread group\n * @param recurse if {@code true} then evaluate the predicate recursively on all thread groups in all subgroups of the given group\n * @param predicate the predicate\n * @return An unmodifiable {@link Collection} of active thread groups which match the given predicate and which is a subgroup of the given thread group\n * @throws NullPointerException if the given group or predicate is null\n * @throws  SecurityException  if the current thread cannot modify\n *          thread groups from this thread's thread group up to the system thread group\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 739, "method_signature": "Collection<ThreadGroup> findThreadGroups(ThreadGroup, boolean, Predicate)", "filename": "ThreadUtils.findThreadGroups.json"}
{"callee_method_names": ["ThreadGroup.activeCount", "ThreadGroup.enumerate"], "method_name": "ThreadUtils.findThreads", "method_implementation": "{\n    Objects.requireNonNull(threadGroup, \"The group must not be null\");\n    Objects.requireNonNull(predicate, \"The predicate must not be null\");\n    int count = threadGroup.activeCount();\n    Thread[] threads;\n    do {\n        //slightly grow the array size\n        threads = new Thread[count + count / 2 + 1];\n        count = threadGroup.enumerate(threads, recurse);\n        //return value of enumerate() must be strictly less than the array size according to javadoc\n    } while (count >= threads.length);\n    return Collections.unmodifiableCollection(Stream.of(threads).limit(count).filter(predicate).collect(Collectors.toList()));\n}", "repo_id": "8", "comment": "/**\n * Finds all active threads which match the given predicate and which belongs to the given thread group (or one of its subgroups).\n *\n * @param threadGroup the thread group\n * @param recurse if {@code true} then evaluate the predicate recursively on all threads in all subgroups of the given group\n * @param predicate the predicate\n * @return An unmodifiable {@link Collection} of active threads which match the given predicate and which belongs to the given thread group\n * @throws NullPointerException if the given group or predicate is null\n * @throws  SecurityException  if the current thread cannot modify\n *          thread groups from this thread's thread group up to the system thread group\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 740, "method_signature": "Collection<Thread> findThreads(ThreadGroup, boolean, Predicate)", "filename": "ThreadUtils.findThreads.json"}
{"callee_method_names": [], "method_name": "ThreadUtils.findThreadsByName", "method_implementation": "{\n    Objects.requireNonNull(threadName, \"threadName\");\n    Objects.requireNonNull(threadGroupName, \"threadGroupName\");\n    return Collections.unmodifiableCollection(findThreadGroups(predicateThreadGroup(threadGroupName)).stream().flatMap(group -> findThreads(group, false, predicateThread(threadName)).stream()).collect(Collectors.toList()));\n}", "repo_id": "8", "comment": "/**\n * Finds active threads with the specified name if they belong to a thread group with the specified group name.\n *\n * @param threadName The thread name\n * @param threadGroupName The thread group name\n * @return The threads which belongs to a thread group with the specified group name and the thread's name match the specified name,\n * An empty collection is returned if no such thread exists. The collection returned is always unmodifiable.\n * @throws NullPointerException if the specified thread name or group name is null\n * @throws  SecurityException\n *          if the current thread cannot access the system thread group\n *\n * @throws  SecurityException  if the current thread cannot modify\n *          thread groups from this thread's thread group up to the system thread group\n */\n", "repo_name": "commons-lang-master/", "id": 741, "method_signature": "Collection<Thread> findThreadsByName(String, String)", "filename": "ThreadUtils.findThreadsByName.json"}
{"callee_method_names": ["ThreadGroup.getParent", "ThreadGroup.getParent"], "method_name": "ThreadUtils.getSystemThreadGroup", "method_implementation": "{\n    ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();\n    while (threadGroup != null && threadGroup.getParent() != null) {\n        threadGroup = threadGroup.getParent();\n    }\n    return threadGroup;\n}", "repo_id": "8", "comment": "/**\n * Gets the system thread group (sometimes also referred as \"root thread group\").\n * <p>\n * This method returns null if this thread has died (been stopped).\n * </p>\n *\n * @return the system thread group\n * @throws SecurityException if the current thread cannot modify thread groups from this thread's thread group up to the\n *         system thread group\n */\n", "repo_name": "commons-lang-master/", "id": 742, "method_signature": "ThreadGroup getSystemThreadGroup()", "filename": "ThreadUtils.getSystemThreadGroup.json"}
{"callee_method_names": [], "method_name": "ThreadUtils.sleepQuietly", "method_implementation": "{\n    try {\n        sleep(duration);\n    } catch (final InterruptedException e) {\n        // be quiet.\n    }\n}", "repo_id": "8", "comment": "/**\n * Sleeps for the given duration while ignoring {@link InterruptedException}.\n * <p>\n * The sleep duration may be shorter than duration if we catch a {@link InterruptedException}.\n * </p>\n *\n * @param duration the length of time to sleep.\n * @since 3.13.0\n */\n", "repo_name": "commons-lang-master/", "id": 743, "method_signature": "void sleepQuietly(Duration)", "filename": "ThreadUtils.sleepQuietly.json"}
{"callee_method_names": [], "method_name": "ThresholdCircuitBreaker.close", "method_implementation": "{\n    super.close();\n    this.used.set(INITIAL_COUNT);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Resets the internal counter back to its initial value (zero).</p>\n */\n", "repo_name": "commons-lang-master/", "id": 88, "method_signature": "void close()", "filename": "ThresholdCircuitBreaker.close.json"}
{"callee_method_names": [], "method_name": "ThresholdCircuitBreaker.incrementAndCheckState", "method_implementation": "{\n    if (threshold == 0) {\n        open();\n    }\n    final long used = this.used.addAndGet(increment);\n    if (used > threshold) {\n        open();\n    }\n    return checkState();\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If the threshold is zero, the circuit breaker will be in a permanent <em>open</em> state.</p>\n */\n", "repo_name": "commons-lang-master/", "id": 89, "method_signature": "boolean incrementAndCheckState(Long)", "filename": "ThresholdCircuitBreaker.incrementAndCheckState.json"}
{"callee_method_ids": [89, 88, 89], "callee_method_names": ["ThresholdCircuitBreaker.incrementAndCheckState", "ThresholdCircuitBreaker.close", "ThresholdCircuitBreaker.incrementAndCheckState"], "method_name": "ThresholdCircuitBreakerTest.testClosingThresholdCircuitBreaker", "method_implementation": "{\n    final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);\n    circuit.incrementAndCheckState(9L);\n    circuit.close();\n    // now the internal counter is back at zero, not 9 anymore. So it is safe to increment 9 again\n    assertTrue(circuit.incrementAndCheckState(9L), \"Internal counter was not reset back to zero\");\n}", "repo_id": "8", "comment": "/**\n * Tests that closing a {@code ThresholdCircuitBreaker} resets the internal counter.\n */\n", "repo_name": "commons-lang-master/", "id": 1575, "method_signature": "void testClosingThresholdCircuitBreaker()", "filename": "ThresholdCircuitBreakerTest.testClosingThresholdCircuitBreaker.json"}
{"callee_method_names": ["ThresholdCircuitBreaker.getThreshold"], "method_name": "ThresholdCircuitBreakerTest.testGettingThreshold", "method_implementation": "{\n    final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);\n    assertEquals(Long.valueOf(threshold), Long.valueOf(circuit.getThreshold()), \"Wrong value of threshold\");\n}", "repo_id": "8", "comment": "/**\n * Tests that we can get the threshold value correctly.\n */\n", "repo_name": "commons-lang-master/", "id": 1576, "method_signature": "void testGettingThreshold()", "filename": "ThresholdCircuitBreakerTest.testGettingThreshold.json"}
{"callee_method_ids": [89, 89], "callee_method_names": ["ThresholdCircuitBreaker.incrementAndCheckState", "ThresholdCircuitBreaker.incrementAndCheckState"], "method_name": "ThresholdCircuitBreakerTest.testThreshold", "method_implementation": "{\n    final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);\n    circuit.incrementAndCheckState(9L);\n    assertTrue(circuit.incrementAndCheckState(1L), \"Circuit opened before reaching the threshold\");\n}", "repo_id": "8", "comment": "/**\n * Tests that the threshold is working as expected when incremented and no exception is thrown.\n */\n", "repo_name": "commons-lang-master/", "id": 1577, "method_signature": "void testThreshold()", "filename": "ThresholdCircuitBreakerTest.testThreshold.json"}
{"callee_method_ids": [89, 89], "callee_method_names": ["ThresholdCircuitBreaker.incrementAndCheckState", "ThresholdCircuitBreaker.incrementAndCheckState"], "method_name": "ThresholdCircuitBreakerTest.testThresholdCircuitBreakingException", "method_implementation": "{\n    final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);\n    circuit.incrementAndCheckState(9L);\n    assertFalse(circuit.incrementAndCheckState(2L), \"The circuit was supposed to be open after increment above the threshold\");\n}", "repo_id": "8", "comment": "/**\n * Tests that exceeding the threshold raises an exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1578, "method_signature": "void testThresholdCircuitBreakingException()", "filename": "ThresholdCircuitBreakerTest.testThresholdCircuitBreakingException.json"}
{"callee_method_ids": [89], "callee_method_names": ["ThresholdCircuitBreaker.incrementAndCheckState"], "method_name": "ThresholdCircuitBreakerTest.testThresholdEqualsZero", "method_implementation": "{\n    final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(zeroThreshold);\n    assertFalse(circuit.incrementAndCheckState(0L), \"When the threshold is zero, the circuit is supposed to be always open\");\n}", "repo_id": "8", "comment": "/**\n * Test that when threshold is zero, the circuit breaker is always open.\n */\n", "repo_name": "commons-lang-master/", "id": 1579, "method_signature": "void testThresholdEqualsZero()", "filename": "ThresholdCircuitBreakerTest.testThresholdEqualsZero.json"}
{"callee_method_names": ["TimeZone.equals", "Locale.equals"], "method_name": "TimeZoneDisplayKey.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof TimeZoneDisplayKey) {\n        final TimeZoneDisplayKey other = (TimeZoneDisplayKey) obj;\n        return timeZone.equals(other.timeZone) && style == other.style && locale.equals(other.locale);\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 677, "method_signature": "boolean equals(Object)", "filename": "TimeZoneDisplayKey.equals.json"}
{"callee_method_names": ["Calendar.getTimeZone", "Calendar.get", "Appendable.append", "Appendable.append"], "method_name": "TimeZoneNameRule.appendTo", "method_implementation": "{\n    final TimeZone zone = calendar.getTimeZone();\n    if (calendar.get(Calendar.DST_OFFSET) == 0) {\n        buffer.append(getTimeZoneDisplay(zone, false, style, locale));\n    } else {\n        buffer.append(getTimeZoneDisplay(zone, true, style, locale));\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 678, "method_signature": "void appendTo(Appendable, Calendar)", "filename": "TimeZoneNameRule.appendTo.json"}
{"callee_method_names": ["String.length", "String.length"], "method_name": "TimeZoneNameRule.estimateLength", "method_implementation": "{\n    // We have no access to the Calendar object that will be passed to\n    // appendTo so base estimate on the TimeZone passed to the\n    // constructor\n    return Math.max(standard.length(), daylight.length());\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 679, "method_signature": "int estimateLength()", "filename": "TimeZoneNameRule.estimateLength.json"}
{"callee_method_names": ["Calendar.get", "Calendar.get", "Appendable.append", "Appendable.append", "Appendable.append"], "method_name": "TimeZoneNumberRule.appendTo", "method_implementation": "{\n    int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n    if (offset < 0) {\n        buffer.append('-');\n        offset = -offset;\n    } else {\n        buffer.append('+');\n    }\n    final int hours = offset / (60 * 60 * 1000);\n    appendDigits(buffer, hours);\n    if (colon) {\n        buffer.append(':');\n    }\n    final int minutes = offset / (60 * 1000) - 60 * hours;\n    appendDigits(buffer, minutes);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 680, "method_signature": "void appendTo(Appendable, Calendar)", "filename": "TimeZoneNumberRule.appendTo.json"}
{"callee_method_names": ["Calendar.setTimeZone", "String.toLowerCase", "HashMap.get", "HashMap.get", "Calendar.set", "Calendar.set", "TzInfo.getRawOffset"], "method_name": "TimeZoneStrategy.setCalendar", "method_implementation": "{\n    final TimeZone tz = FastTimeZone.getGmtTimeZone(timeZone);\n    if (tz != null) {\n        calendar.setTimeZone(tz);\n    } else {\n        final String lowerCase = timeZone.toLowerCase(locale);\n        TzInfo tzInfo = tzNames.get(lowerCase);\n        if (tzInfo == null) {\n            // match missing the optional trailing period\n            tzInfo = tzNames.get(lowerCase + '.');\n        }\n        calendar.set(Calendar.DST_OFFSET, tzInfo.dstOffset);\n        calendar.set(Calendar.ZONE_OFFSET, tzInfo.zone.getRawOffset());\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 628, "method_signature": "void setCalendar(FastDateParser, Calendar, String)", "filename": "TimeZoneStrategy.setCalendar.json"}
{"callee_method_names": [], "method_name": "TimedSemaphore.acquire", "method_implementation": "{\n    prepareAcquire();\n    boolean canPass;\n    do {\n        canPass = acquirePermit();\n        if (!canPass) {\n            wait();\n        }\n    } while (!canPass);\n}", "repo_id": "8", "comment": "/**\n * Acquires a permit from this semaphore. This method will block if\n * the limit for the current period has already been reached. If\n * {@link #shutdown()} has already been invoked, calling this method will\n * cause an exception. The very first call of this method starts the timer\n * task which monitors the time period set for this {@link TimedSemaphore}.\n * From now on the semaphore is active.\n *\n * @throws InterruptedException if the thread gets interrupted\n * @throws IllegalStateException if this semaphore is already shut down\n */\n", "repo_name": "commons-lang-master/", "id": 126, "method_signature": "void acquire()", "filename": "TimedSemaphore.acquire.json"}
{"callee_method_names": [], "method_name": "TimedSemaphore.acquirePermit", "method_implementation": "{\n    if (getLimit() <= NO_LIMIT || acquireCount < getLimit()) {\n        acquireCount++;\n        return true;\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Internal helper method for acquiring a permit. This method checks whether currently\n * a permit can be acquired and - if so - increases the internal counter. The return\n * value indicates whether a permit could be acquired. This method must be called with\n * the lock of this object held.\n *\n * @return a flag whether a permit could be acquired\n */\n", "repo_name": "commons-lang-master/", "id": 127, "method_signature": "boolean acquirePermit()", "filename": "TimedSemaphore.acquirePermit.json"}
{"callee_method_names": [], "method_name": "TimedSemaphore.endOfPeriod", "method_implementation": "{\n    lastCallsPerPeriod = acquireCount;\n    totalAcquireCount += acquireCount;\n    periodCount++;\n    acquireCount = 0;\n    notifyAll();\n}", "repo_id": "8", "comment": "/**\n * The current time period is finished. This method is called by the timer\n * used internally to monitor the time period. It resets the counter and\n * releases the threads waiting for this barrier.\n */\n", "repo_name": "commons-lang-master/", "id": 128, "method_signature": "void endOfPeriod()", "filename": "TimedSemaphore.endOfPeriod.json"}
{"callee_method_names": [], "method_name": "TimedSemaphore.prepareAcquire", "method_implementation": "{\n    if (isShutdown()) {\n        throw new IllegalStateException(\"TimedSemaphore is shut down!\");\n    }\n    if (task == null) {\n        task = startTimer();\n    }\n}", "repo_id": "8", "comment": "/**\n * Prepares an acquire operation. Checks for the current state and starts the internal\n * timer if necessary. This method must be called with the lock of this object held.\n */\n", "repo_name": "commons-lang-master/", "id": 129, "method_signature": "void prepareAcquire()", "filename": "TimedSemaphore.prepareAcquire.json"}
{"callee_method_names": ["ScheduledFuture<?>.cancel"], "method_name": "TimedSemaphore.shutdown", "method_implementation": "{\n    if (!shutdown) {\n        if (ownExecutor) {\n            // if the executor was created by this instance, it has\n            // to be shutdown\n            getExecutorService().shutdownNow();\n        }\n        if (task != null) {\n            task.cancel(false);\n        }\n        shutdown = true;\n    }\n}", "repo_id": "8", "comment": "/**\n * Initializes a shutdown. After that the object cannot be used anymore.\n * This method can be invoked an arbitrary number of times. All invocations\n * after the first one do not have any effect.\n */\n", "repo_name": "commons-lang-master/", "id": 130, "method_signature": "void shutdown()", "filename": "TimedSemaphore.shutdown.json"}
{"callee_method_names": ["CountDownLatch.countDown"], "method_name": "TimedSemaphoreTest.acquire", "method_implementation": "{\n    super.acquire();\n    if (latch != null) {\n        latch.countDown();\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes the latch if one is set.\n *\n * @throws InterruptedException because it is declared that way in TimedSemaphore\n */\n", "repo_name": "commons-lang-master/", "id": 1466, "method_signature": "void acquire()", "filename": "TimedSemaphoreTest.acquire.json"}
{"callee_method_names": [], "method_name": "TimedSemaphoreTest.endOfPeriod", "method_implementation": "{\n    super.endOfPeriod();\n    periodEnds++;\n}", "repo_id": "8", "comment": "/**\n * Counts the number of invocations.\n */\n", "repo_name": "commons-lang-master/", "id": 1467, "method_signature": "void endOfPeriod()", "filename": "TimedSemaphoreTest.endOfPeriod.json"}
{"callee_method_names": [], "method_name": "TimedSemaphoreTest.getPeriodEnds", "method_implementation": "{\n    synchronized (this) {\n        return periodEnds;\n    }\n}", "repo_id": "8", "comment": "/**\n * Returns the number of invocations of the endOfPeriod() method.\n *\n * @return the endOfPeriod() invocations\n */\n", "repo_name": "commons-lang-master/", "id": 1468, "method_signature": "int getPeriodEnds()", "filename": "TimedSemaphoreTest.getPeriodEnds.json"}
{"callee_method_names": ["ScheduledExecutorService.scheduleAtFixedRate"], "method_name": "TimedSemaphoreTest.prepareStartTimer", "method_implementation": "{\n    service.scheduleAtFixedRate((Runnable) EasyMock.anyObject(), EasyMock.eq(PERIOD_MILLIS), EasyMock.eq(PERIOD_MILLIS), EasyMock.eq(UNIT));\n    EasyMock.expectLastCall().andReturn(future);\n}", "repo_id": "8", "comment": "/**\n * Prepares an executor service mock to expect the start of the timer.\n *\n * @param service the mock\n * @param future the future\n */\n", "repo_name": "commons-lang-master/", "id": 1469, "method_signature": "void prepareStartTimer(ScheduledExecutorService, ScheduledFuture)", "filename": "TimedSemaphoreTest.prepareStartTimer.json"}
{"callee_method_ids": [126], "callee_method_names": ["TimedSemaphore.acquire", "CountDownLatch.countDown"], "method_name": "TimedSemaphoreTest.run", "method_implementation": "{\n    try {\n        for (int i = 0; i < count; i++) {\n            semaphore.acquire();\n            if (i < latchCount) {\n                latch.countDown();\n            }\n        }\n    } catch (final InterruptedException iex) {\n        Thread.currentThread().interrupt();\n    }\n}", "repo_id": "8", "comment": "/**\n * Calls acquire() on the semaphore for the specified number of times.\n * Optionally the latch will also be triggered to synchronize with the\n * main test thread.\n */\n", "repo_name": "commons-lang-master/", "id": 1465, "method_signature": "void run()", "filename": "TimedSemaphoreTest.run.json"}
{"callee_method_ids": [128], "callee_method_names": ["TimedSemaphore.setLimit", "SemaphoreThread.start", "CountDownLatch.await", "TimedSemaphore.getAcquireCount", "TimedSemaphore.endOfPeriod", "SemaphoreThread.join", "TimedSemaphore.getAcquireCount", "TimedSemaphore.getLastAcquiresPerPeriod"], "method_name": "TimedSemaphoreTest.testAcquireLimit", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n    prepareStartTimer(service, future);\n    EasyMock.replay(service, future);\n    final int count = 10;\n    final CountDownLatch latch = new CountDownLatch(count - 1);\n    final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD_MILLIS, UNIT, 1);\n    final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count - 1);\n    semaphore.setLimit(count - 1);\n    // start a thread that calls the semaphore count times\n    t.start();\n    latch.await();\n    // now the semaphore's limit should be reached and the thread blocked\n    assertEquals(count - 1, semaphore.getAcquireCount(), \"Wrong semaphore count\");\n    // this wakes up the thread, it should call the semaphore once more\n    semaphore.endOfPeriod();\n    t.join();\n    assertEquals(1, semaphore.getAcquireCount(), \"Wrong semaphore count (2)\");\n    assertEquals(count - 1, semaphore.getLastAcquiresPerPeriod(), \"Wrong acquire() count\");\n    EasyMock.verify(service, future);\n}", "repo_id": "8", "comment": "/**\n * Tests the acquire() method if a limit is set.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1470, "method_signature": "void testAcquireLimit()", "filename": "TimedSemaphoreTest.testAcquireLimit.json"}
{"callee_method_ids": [1489], "callee_method_names": ["TimedSemaphoreTestImpl.setLimit", "SemaphoreThread.start", "CountDownLatch.await", "TimedSemaphoreTestImpl.shutdown", "TimedSemaphoreTestImpl.getPeriodEnds"], "method_name": "TimedSemaphoreTest.testAcquireMultiplePeriods", "method_implementation": "{\n    final int count = 1000;\n    final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD_MILLIS / 10, TimeUnit.MILLISECONDS, 1);\n    semaphore.setLimit(count / 4);\n    final CountDownLatch latch = new CountDownLatch(count);\n    final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n    t.start();\n    latch.await();\n    semaphore.shutdown();\n    assertTrue(semaphore.getPeriodEnds() > 0, \"End of period not reached\");\n}", "repo_id": "8", "comment": "/**\n * Tests a bigger number of invocations that span multiple periods. The\n * period is set to a very short time. A background thread calls the\n * semaphore a large number of times. While it runs at last one end of a\n * period should be reached.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1471, "method_signature": "void testAcquireMultiplePeriods()", "filename": "TimedSemaphoreTest.testAcquireMultiplePeriods.json"}
{"callee_method_ids": [1488], "callee_method_names": ["SemaphoreThread[].start", "TimedSemaphoreTestImpl.await", "TimedSemaphoreTestImpl.getAcquireCount", "TimedSemaphoreTestImpl.endOfPeriod", "TimedSemaphoreTestImpl.getLastAcquiresPerPeriod", "SemaphoreThread[].join"], "method_name": "TimedSemaphoreTest.testAcquireMultipleThreads", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n    prepareStartTimer(service, future);\n    EasyMock.replay(service, future);\n    final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD_MILLIS, UNIT, 1);\n    semaphore.latch = new CountDownLatch(1);\n    final int count = 10;\n    final SemaphoreThread[] threads = new SemaphoreThread[count];\n    for (int i = 0; i < count; i++) {\n        threads[i] = new SemaphoreThread(semaphore, null, 1, 0);\n        threads[i].start();\n    }\n    for (int i = 0; i < count; i++) {\n        semaphore.latch.await();\n        assertEquals(1, semaphore.getAcquireCount(), \"Wrong count\");\n        semaphore.latch = new CountDownLatch(1);\n        semaphore.endOfPeriod();\n        assertEquals(1, semaphore.getLastAcquiresPerPeriod(), \"Wrong acquire count\");\n    }\n    for (int i = 0; i < count; i++) {\n        threads[i].join();\n    }\n    EasyMock.verify(service, future);\n}", "repo_id": "8", "comment": "/**\n * Tests the acquire() method if more threads are involved than the limit.\n * This method starts a number of threads that all invoke the semaphore. The\n * semaphore's limit is set to 1, so in each period only a single thread can\n * acquire the semaphore.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1472, "method_signature": "void testAcquireMultipleThreads()", "filename": "TimedSemaphoreTest.testAcquireMultipleThreads.json"}
{"callee_method_names": ["SemaphoreThread.start", "CountDownLatch.await"], "method_name": "TimedSemaphoreTest.testAcquireNoLimit", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n    prepareStartTimer(service, future);\n    EasyMock.replay(service, future);\n    final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD_MILLIS, UNIT, TimedSemaphore.NO_LIMIT);\n    final int count = 1000;\n    final CountDownLatch latch = new CountDownLatch(count);\n    final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n    t.start();\n    latch.await();\n    EasyMock.verify(service, future);\n}", "repo_id": "8", "comment": "/**\n * Tests the acquire() method if no limit is set. A test thread is started\n * that calls the semaphore a large number of times. Even if the semaphore's\n * period does not end, the thread should never block.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1473, "method_signature": "void testAcquireNoLimit()", "filename": "TimedSemaphoreTest.testAcquireNoLimit.json"}
{"callee_method_ids": [126, 128], "callee_method_names": ["TimedSemaphore.getAvailablePermits", "TimedSemaphore.acquire", "TimedSemaphore.endOfPeriod", "TimedSemaphore.getAvailablePermits"], "method_name": "TimedSemaphoreTest.testGetAvailablePermits", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n    prepareStartTimer(service, future);\n    EasyMock.replay(service, future);\n    final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD_MILLIS, UNIT, LIMIT);\n    for (int i = 0; i < LIMIT; i++) {\n        assertEquals(LIMIT - i, semaphore.getAvailablePermits(), \"Wrong available count at \" + i);\n        semaphore.acquire();\n    }\n    semaphore.endOfPeriod();\n    assertEquals(LIMIT, semaphore.getAvailablePermits(), \"Wrong available count in new period\");\n    EasyMock.verify(service, future);\n}", "repo_id": "8", "comment": "/**\n * Tests whether the available non-blocking calls can be queried.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1474, "method_signature": "void testGetAvailablePermits()", "filename": "TimedSemaphoreTest.testGetAvailablePermits.json"}
{"callee_method_ids": [126, 128, 126, 126, 128], "callee_method_names": ["TimedSemaphore.acquire", "TimedSemaphore.endOfPeriod", "TimedSemaphore.getAverageCallsPerPeriod", "TimedSemaphore.acquire", "TimedSemaphore.acquire", "TimedSemaphore.endOfPeriod", "TimedSemaphore.getAverageCallsPerPeriod"], "method_name": "TimedSemaphoreTest.testGetAverageCallsPerPeriod", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n    prepareStartTimer(service, future);\n    EasyMock.replay(service, future);\n    final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD_MILLIS, UNIT, LIMIT);\n    semaphore.acquire();\n    semaphore.endOfPeriod();\n    assertEquals(1.0, semaphore.getAverageCallsPerPeriod(), .005, \"Wrong average (1)\");\n    semaphore.acquire();\n    semaphore.acquire();\n    semaphore.endOfPeriod();\n    assertEquals(1.5, semaphore.getAverageCallsPerPeriod(), .005, \"Wrong average (2)\");\n    EasyMock.verify(service, future);\n}", "repo_id": "8", "comment": "/**\n * Tests the methods for statistics.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1475, "method_signature": "void testGetAverageCallsPerPeriod()", "filename": "TimedSemaphoreTest.testGetAverageCallsPerPeriod.json"}
{"callee_method_names": ["TimedSemaphore.getExecutorService", "TimedSemaphore.getPeriod", "TimedSemaphore.getUnit", "TimedSemaphore.getLastAcquiresPerPeriod", "TimedSemaphore.getAverageCallsPerPeriod", "TimedSemaphore.isShutdown", "TimedSemaphore.getLimit"], "method_name": "TimedSemaphoreTest.testInit", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    EasyMock.replay(service);\n    final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD_MILLIS, UNIT, LIMIT);\n    EasyMock.verify(service);\n    assertEquals(service, semaphore.getExecutorService(), \"Wrong service\");\n    assertEquals(PERIOD_MILLIS, semaphore.getPeriod(), \"Wrong period\");\n    assertEquals(UNIT, semaphore.getUnit(), \"Wrong unit\");\n    assertEquals(0, semaphore.getLastAcquiresPerPeriod(), \"Statistic available\");\n    assertEquals(0.0, semaphore.getAverageCallsPerPeriod(), .05, \"Average available\");\n    assertFalse(semaphore.isShutdown(), \"Already shutdown\");\n    assertEquals(LIMIT, semaphore.getLimit(), \"Wrong limit\");\n}", "repo_id": "8", "comment": "/**\n * Tests creating a new instance.\n */\n", "repo_name": "commons-lang-master/", "id": 1476, "method_signature": "void testInit()", "filename": "TimedSemaphoreTest.testInit.json"}
{"callee_method_ids": [130], "callee_method_names": ["TimedSemaphore.getExecutorService", "ScheduledThreadPoolExecutor.getContinueExistingPeriodicTasksAfterShutdownPolicy", "ScheduledThreadPoolExecutor.getExecuteExistingDelayedTasksAfterShutdownPolicy", "ScheduledThreadPoolExecutor.isShutdown", "TimedSemaphore.shutdown"], "method_name": "TimedSemaphoreTest.testInitDefaultService", "method_implementation": "{\n    final TimedSemaphore semaphore = new TimedSemaphore(PERIOD_MILLIS, UNIT, LIMIT);\n    final ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor) semaphore.getExecutorService();\n    assertFalse(exec.getContinueExistingPeriodicTasksAfterShutdownPolicy(), \"Wrong periodic task policy\");\n    assertFalse(exec.getExecuteExistingDelayedTasksAfterShutdownPolicy(), \"Wrong delayed task policy\");\n    assertFalse(exec.isShutdown(), \"Already shutdown\");\n    semaphore.shutdown();\n}", "repo_id": "8", "comment": "/**\n * Tests whether a default executor service is created if no service is\n * provided.\n */\n", "repo_name": "commons-lang-master/", "id": 1477, "method_signature": "void testInitDefaultService()", "filename": "TimedSemaphoreTest.testInitDefaultService.json"}
{"callee_method_ids": [130], "callee_method_names": ["TimedSemaphore.shutdown"], "method_name": "TimedSemaphoreTest.testPassAfterShutdown", "method_implementation": "{\n    final TimedSemaphore semaphore = new TimedSemaphore(PERIOD_MILLIS, UNIT, LIMIT);\n    semaphore.shutdown();\n    assertThrows(IllegalStateException.class, semaphore::acquire);\n}", "repo_id": "8", "comment": "/**\n * Tries to call acquire() after shutdown(). This should cause an exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1478, "method_signature": "void testPassAfterShutdown()", "filename": "TimedSemaphoreTest.testPassAfterShutdown.json"}
{"callee_method_ids": [1487], "callee_method_names": ["ScheduledFuture<?>.cancel", "TimedSemaphoreTestImpl.acquire", "TimedSemaphoreTestImpl.shutdown"], "method_name": "TimedSemaphoreTest.testShutdownMultipleTimes", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n    prepareStartTimer(service, future);\n    EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE);\n    EasyMock.replay(service, future);\n    final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD_MILLIS, UNIT, LIMIT);\n    semaphore.acquire();\n    for (int i = 0; i < 10; i++) {\n        semaphore.shutdown();\n    }\n    EasyMock.verify(service, future);\n}", "repo_id": "8", "comment": "/**\n * Tests multiple invocations of the shutdown() method.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1479, "method_signature": "void testShutdownMultipleTimes()", "filename": "TimedSemaphoreTest.testShutdownMultipleTimes.json"}
{"callee_method_ids": [130], "callee_method_names": ["TimedSemaphore.shutdown", "TimedSemaphore.isShutdown", "TimedSemaphore.getExecutorService"], "method_name": "TimedSemaphoreTest.testShutdownOwnExecutor", "method_implementation": "{\n    final TimedSemaphore semaphore = new TimedSemaphore(PERIOD_MILLIS, UNIT, LIMIT);\n    semaphore.shutdown();\n    assertTrue(semaphore.isShutdown(), \"Not shutdown\");\n    assertTrue(semaphore.getExecutorService().isShutdown(), \"Executor not shutdown\");\n}", "repo_id": "8", "comment": "/**\n * Tests the shutdown() method if the executor belongs to the semaphore. In\n * this case it has to be shut down.\n */\n", "repo_name": "commons-lang-master/", "id": 1480, "method_signature": "void testShutdownOwnExecutor()", "filename": "TimedSemaphoreTest.testShutdownOwnExecutor.json"}
{"callee_method_ids": [130], "callee_method_names": ["TimedSemaphore.shutdown", "TimedSemaphore.isShutdown"], "method_name": "TimedSemaphoreTest.testShutdownSharedExecutorNoTask", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    EasyMock.replay(service);\n    final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD_MILLIS, UNIT, LIMIT);\n    semaphore.shutdown();\n    assertTrue(semaphore.isShutdown(), \"Not shutdown\");\n    EasyMock.verify(service);\n}", "repo_id": "8", "comment": "/**\n * Tests the shutdown() method for a shared executor service before a task\n * was started. This should do pretty much nothing.\n */\n", "repo_name": "commons-lang-master/", "id": 1481, "method_signature": "void testShutdownSharedExecutorNoTask()", "filename": "TimedSemaphoreTest.testShutdownSharedExecutorNoTask.json"}
{"callee_method_ids": [1487], "callee_method_names": ["ScheduledFuture<?>.cancel", "TimedSemaphoreTestImpl.acquire", "TimedSemaphoreTestImpl.shutdown", "TimedSemaphoreTestImpl.isShutdown"], "method_name": "TimedSemaphoreTest.testShutdownSharedExecutorTask", "method_implementation": "{\n    final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class);\n    final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n    prepareStartTimer(service, future);\n    EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE);\n    EasyMock.replay(service, future);\n    final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD_MILLIS, UNIT, LIMIT);\n    semaphore.acquire();\n    semaphore.shutdown();\n    assertTrue(semaphore.isShutdown(), \"Not shutdown\");\n    EasyMock.verify(service, future);\n}", "repo_id": "8", "comment": "/**\n * Tests the shutdown() method for a shared executor after the task was\n * started. In this case the task must be canceled.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1482, "method_signature": "void testShutdownSharedExecutorTask()", "filename": "TimedSemaphoreTest.testShutdownSharedExecutorTask.json"}
{"callee_method_ids": [1489], "callee_method_names": ["TimedSemaphoreTestImpl.startTimer", "TimedSemaphoreTestImpl.getPeriodEnds", "TimedSemaphoreTestImpl.shutdown"], "method_name": "TimedSemaphoreTest.testStartTimer", "method_implementation": "{\n    final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD_MILLIS, UNIT, LIMIT);\n    final ScheduledFuture<?> future = semaphore.startTimer();\n    assertNotNull(future, \"No future returned\");\n    ThreadUtils.sleepQuietly(DURATION);\n    final int trials = 10;\n    int count = 0;\n    do {\n        Thread.sleep(PERIOD_MILLIS);\n        assertFalse(count++ > trials, \"endOfPeriod() not called!\");\n    } while (semaphore.getPeriodEnds() <= 0);\n    semaphore.shutdown();\n}", "repo_id": "8", "comment": "/**\n * Tests starting the timer.\n *\n * @throws InterruptedException so we don't have to catch it\n */\n", "repo_name": "commons-lang-master/", "id": 1483, "method_signature": "void testStartTimer()", "filename": "TimedSemaphoreTest.testStartTimer.json"}
{"callee_method_names": ["TryAcquireThread[].start", "CountDownLatch.countDown", "SemaphoreThread.join"], "method_name": "TimedSemaphoreTest.testTryAcquire", "method_implementation": "{\n    final TimedSemaphore semaphore = new TimedSemaphore(PERIOD_MILLIS, TimeUnit.SECONDS, LIMIT);\n    final TryAcquireThread[] threads = new TryAcquireThread[3 * LIMIT];\n    final CountDownLatch latch = new CountDownLatch(1);\n    for (int i = 0; i < threads.length; i++) {\n        threads[i] = new TryAcquireThread(semaphore, latch);\n        threads[i].start();\n    }\n    latch.countDown();\n    int permits = 0;\n    for (final TryAcquireThread t : threads) {\n        t.join();\n        if (t.acquired) {\n            permits++;\n        }\n    }\n    assertEquals(LIMIT, permits, \"Wrong number of permits granted\");\n}", "repo_id": "8", "comment": "/**\n * Tests the tryAcquire() method. It is checked whether the semaphore can be acquired\n * by a bunch of threads the expected number of times and not more.\n */\n", "repo_name": "commons-lang-master/", "id": 1484, "method_signature": "void testTryAcquire()", "filename": "TimedSemaphoreTest.testTryAcquire.json"}
{"callee_method_ids": [130], "callee_method_names": ["TimedSemaphore.shutdown"], "method_name": "TimedSemaphoreTest.testTryAcquireAfterShutdown", "method_implementation": "{\n    final TimedSemaphore semaphore = new TimedSemaphore(PERIOD_MILLIS, UNIT, LIMIT);\n    semaphore.shutdown();\n    assertThrows(IllegalStateException.class, semaphore::tryAcquire);\n}", "repo_id": "8", "comment": "/**\n * Tries to call tryAcquire() after shutdown(). This should cause an exception.\n */\n", "repo_name": "commons-lang-master/", "id": 1485, "method_signature": "void testTryAcquireAfterShutdown()", "filename": "TimedSemaphoreTest.testTryAcquireAfterShutdown.json"}
{"callee_method_names": ["CountDownLatch.countDown"], "method_name": "TimedSemaphoreTestImpl.acquire", "method_implementation": "{\n    super.acquire();\n    if (latch != null) {\n        latch.countDown();\n    }\n}", "repo_id": "8", "comment": "/**\n * Invokes the latch if one is set.\n *\n * @throws InterruptedException because it is declared that way in TimedSemaphore\n */\n", "repo_name": "commons-lang-master/", "id": 1487, "method_signature": "void acquire()", "filename": "TimedSemaphoreTestImpl.acquire.json"}
{"callee_method_names": [], "method_name": "TimedSemaphoreTestImpl.endOfPeriod", "method_implementation": "{\n    super.endOfPeriod();\n    periodEnds++;\n}", "repo_id": "8", "comment": "/**\n * Counts the number of invocations.\n */\n", "repo_name": "commons-lang-master/", "id": 1488, "method_signature": "void endOfPeriod()", "filename": "TimedSemaphoreTestImpl.endOfPeriod.json"}
{"callee_method_names": [], "method_name": "TimedSemaphoreTestImpl.getPeriodEnds", "method_implementation": "{\n    synchronized (this) {\n        return periodEnds;\n    }\n}", "repo_id": "8", "comment": "/**\n * Returns the number of invocations of the endOfPeriod() method.\n *\n * @return the endOfPeriod() invocations\n */\n", "repo_name": "commons-lang-master/", "id": 1489, "method_signature": "int getPeriodEnds()", "filename": "TimedSemaphoreTestImpl.getPeriodEnds.json"}
{"callee_method_names": ["ToStringStyle.appendSuper"], "method_name": "ToStringBuilder.appendSuper", "method_implementation": "{\n    if (superToString != null) {\n        style.appendSuper(buffer, superToString);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Append the {@code toString} from the superclass.\n *\n * <p>This method assumes that the superclass uses the same {@link ToStringStyle}\n * as this one.</p>\n *\n * <p>If {@code superToString} is {@code null}, no change is made.</p>\n *\n * @param superToString  the result of {@code super.toString()}\n * @return this\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 957, "method_signature": "ToStringBuilder appendSuper(String)", "filename": "ToStringBuilder.appendSuper.json"}
{"callee_method_ids": [940], "callee_method_names": ["ToStringStyle.appendToString"], "method_name": "ToStringBuilder.appendToString", "method_implementation": "{\n    if (toString != null) {\n        style.appendToString(buffer, toString);\n    }\n    return this;\n}", "repo_id": "8", "comment": "/**\n * Append the {@code toString} from another object.\n *\n * <p>This method is useful where a class delegates most of the implementation of\n * its properties to another class. You can then call {@code toString()} on\n * the other class and pass the result into this method.</p>\n *\n * <pre>\n *   private AnotherObject delegate;\n *   private String fieldInThisClass;\n *\n *   public String toString() {\n *     return new ToStringBuilder(this).\n *       appendToString(delegate.toString()).\n *       append(fieldInThisClass).\n *       toString();\n *   }</pre>\n *\n * <p>This method assumes that the other object uses the same {@link ToStringStyle}\n * as this one.</p>\n *\n * <p>If the {@code toString} is {@code null}, no change is made.</p>\n *\n * @param toString  the result of {@code toString()} on another object\n * @return this\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 958, "method_signature": "ToStringBuilder appendToString(String)", "filename": "ToStringBuilder.appendToString.json"}
{"callee_method_names": [], "method_name": "ToStringBuilder.reflectionToString", "method_implementation": "{\n    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n}", "repo_id": "8", "comment": "/**\n * Uses {@link ReflectionToStringBuilder} to generate a\n * {@code toString} for the specified object.\n *\n * @param <T> the type of the object\n * @param object  the Object to be output\n * @param style  the style of the {@code toString} to create, may be {@code null}\n * @param outputTransients  whether to include transient fields\n * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be {@code null}\n * @return the String result\n * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,boolean,Class)\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 956, "method_signature": "String reflectionToString(T, ToStringStyle, boolean, Class)", "filename": "ToStringBuilder.reflectionToString.json"}
{"callee_method_ids": [933], "callee_method_names": ["ToStringStyle.appendEnd"], "method_name": "ToStringBuilder.toString", "method_implementation": "{\n    if (this.getObject() == null) {\n        this.getStringBuffer().append(this.getStyle().getNullText());\n    } else {\n        style.appendEnd(this.getStringBuffer(), this.getObject());\n    }\n    return this.getStringBuffer().toString();\n}", "repo_id": "8", "comment": "/**\n * Returns the built {@code toString}.\n *\n * <p>This method appends the end of data indicator, and can only be called once.\n * Use {@link #getStringBuffer} to get the current string state.</p>\n *\n * <p>If the object is {@code null}, return the style's {@code nullText}</p>\n *\n * @return the String {@code toString}\n */\n", "repo_name": "commons-lang-master/", "id": 959, "method_signature": "String toString()", "filename": "ToStringBuilder.toString.json"}
{"callee_method_names": [], "method_name": "ToStringBuilderTest.testInheritedReflectionStatics", "method_implementation": "{\n    final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();\n    assertEquals(this.toBaseString(instance1) + \"[staticInt2=67890,staticString2=staticString2]\", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class));\n    assertEquals(this.toBaseString(instance1) + \"[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]\", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n    assertEquals(this.toBaseString(instance1) + \"[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]\", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n    assertEquals(this.toBaseString(instance1) + \"[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]\", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n}", "repo_id": "8", "comment": "/**\n * Tests ReflectionToStringBuilder.toString() for statics.\n */\n", "repo_name": "commons-lang-master/", "id": 1975, "method_signature": "void testInheritedReflectionStatics()", "filename": "ToStringBuilderTest.testInheritedReflectionStatics.json"}
{"callee_method_names": [], "method_name": "ToStringBuilderTest.testReflectionArrayAndObjectCycle", "method_implementation": "{\n    final Object[] objects = new Object[1];\n    final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n    objects[0] = simple;\n    assertEquals(this.toBaseString(objects) + \"[{\" + this.toBaseString(simple) + \"[o=\" + this.toBaseString(objects) + \"]\" + \"}]\", ToStringBuilder.reflectionToString(objects));\n    assertEquals(this.toBaseString(simple) + \"[o={\" + this.toBaseString(simple) + \"}]\", ToStringBuilder.reflectionToString(simple));\n}", "repo_id": "8", "comment": "/**\n * Test a nasty combination of arrays and Objects pointing to each other.\n * objects[0] -&gt; SimpleReflectionTestFixture[ o -&gt; objects ]\n */\n", "repo_name": "commons-lang-master/", "id": 1976, "method_signature": "void testReflectionArrayAndObjectCycle()", "filename": "ToStringBuilderTest.testReflectionArrayAndObjectCycle.json"}
{"callee_method_names": [], "method_name": "ToStringBuilderTest.testReflectionArrayCycle", "method_implementation": "{\n    final Object[] objects = new Object[1];\n    objects[0] = objects;\n    assertEquals(this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\", ToStringBuilder.reflectionToString(objects));\n}", "repo_id": "8", "comment": "/**\n * Test an array element pointing to its container.\n */\n", "repo_name": "commons-lang-master/", "id": 1977, "method_signature": "void testReflectionArrayCycle()", "filename": "ToStringBuilderTest.testReflectionArrayCycle.json"}
{"callee_method_names": [], "method_name": "ToStringBuilderTest.testReflectionArrayCycleLevel2", "method_implementation": "{\n    final Object[] objects = new Object[1];\n    final Object[] objectsLevel2 = new Object[1];\n    objects[0] = objectsLevel2;\n    objectsLevel2[0] = objects;\n    assertEquals(this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\", ToStringBuilder.reflectionToString(objects));\n    assertEquals(this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\", ToStringBuilder.reflectionToString(objectsLevel2));\n}", "repo_id": "8", "comment": "/**\n * Test an array element pointing to its container.\n */\n", "repo_name": "commons-lang-master/", "id": 1978, "method_signature": "void testReflectionArrayCycleLevel2()", "filename": "ToStringBuilderTest.testReflectionArrayCycleLevel2.json"}
{"callee_method_names": [], "method_name": "ToStringBuilderTest.testReflectionBoolean", "method_implementation": "{\n    Boolean b;\n    b = Boolean.TRUE;\n    assertEquals(this.toBaseString(b) + \"[value=true]\", ToStringBuilder.reflectionToString(b));\n    b = Boolean.FALSE;\n    assertEquals(this.toBaseString(b) + \"[value=false]\", ToStringBuilder.reflectionToString(b));\n}", "repo_id": "8", "comment": "/**\n * Test wrapper for char boolean.\n */\n", "repo_name": "commons-lang-master/", "id": 1979, "method_signature": "void testReflectionBoolean()", "filename": "ToStringBuilderTest.testReflectionBoolean.json"}
{"callee_method_names": [], "method_name": "ToStringBuilderTest.testReflectionCharacter", "method_implementation": "{\n    final Character c = 'A';\n    assertEquals(this.toBaseString(c) + \"[value=A]\", ToStringBuilder.reflectionToString(c));\n}", "repo_id": "8", "comment": "/**\n * Test wrapper for char primitive.\n */\n", "repo_name": "commons-lang-master/", "id": 1980, "method_signature": "void testReflectionCharacter()", "filename": "ToStringBuilderTest.testReflectionCharacter.json"}
{"callee_method_names": ["String.equals", "String.equals"], "method_name": "ToStringBuilderTest.testReflectionHierarchyArrayList", "method_implementation": "{\n    // LANG-1337 without this, the generated string can differ depending on the JVM version/vendor\n    final List<Object> list = new ArrayList<>(ARRAYLIST_INITIAL_CAPACITY);\n    final String baseString = this.toBaseString(list);\n    final String expectedWithTransients = baseString + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\";\n    final String toStringWithTransients = ToStringBuilder.reflectionToString(list, null, true);\n    if (!expectedWithTransients.equals(toStringWithTransients)) {\n        assertEquals(expectedWithTransients, toStringWithTransients);\n    }\n    final String expectedWithoutTransients = baseString + \"[size=0]\";\n    final String toStringWithoutTransients = ToStringBuilder.reflectionToString(list, null, false);\n    if (!expectedWithoutTransients.equals(toStringWithoutTransients)) {\n        assertEquals(expectedWithoutTransients, toStringWithoutTransients);\n    }\n}", "repo_id": "8", "comment": "// Reflection hierarchy tests\n", "repo_name": "commons-lang-master/", "id": 1981, "method_signature": "void testReflectionHierarchyArrayList()", "filename": "ToStringBuilderTest.testReflectionHierarchyArrayList.json"}
{"callee_method_names": ["ReflectionTestCycleA.toString"], "method_name": "ToStringBuilderTest.testReflectionObjectCycle", "method_implementation": "{\n    final ReflectionTestCycleA a = new ReflectionTestCycleA();\n    final ReflectionTestCycleB b = new ReflectionTestCycleB();\n    a.b = b;\n    b.a = a;\n    assertEquals(this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\", a.toString());\n}", "repo_id": "8", "comment": "/**\n * Test Objects pointing to each other.\n */\n", "repo_name": "commons-lang-master/", "id": 1982, "method_signature": "void testReflectionObjectCycle()", "filename": "ToStringBuilderTest.testReflectionObjectCycle.json"}
{"callee_method_names": [], "method_name": "ToStringBuilderTest.testReflectionStatics", "method_implementation": "{\n    final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();\n    assertEquals(this.toBaseString(instance1) + \"[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]\", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class));\n    assertEquals(this.toBaseString(instance1) + \"[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString,staticTransientInt=54321,staticTransientString=staticTransientString,transientInt=98765,transientString=transientString]\", ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class));\n    assertEquals(this.toBaseString(instance1) + \"[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]\", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));\n    assertEquals(this.toBaseString(instance1) + \"[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]\", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));\n}", "repo_id": "8", "comment": "/**\n * Tests ReflectionToStringBuilder.toString() for statics.\n */\n", "repo_name": "commons-lang-master/", "id": 1983, "method_signature": "void testReflectionStatics()", "filename": "ToStringBuilderTest.testReflectionStatics.json"}
{"callee_method_names": ["SelfInstanceTwoVarsReflectionTestFixture.getOtherType", "SelfInstanceTwoVarsReflectionTestFixture.toString"], "method_name": "ToStringBuilderTest.testSelfInstanceTwoVarsReflectionObjectCycle", "method_implementation": "{\n    final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n    assertEquals(this.toBaseString(test) + \"[otherType=\" + test.getOtherType().toString() + \",typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n}", "repo_id": "8", "comment": "/**\n * Test a class that defines an ivar pointing to itself.  This test was\n * created to show that handling cyclical object resulted in a missing endFieldSeparator call.\n */\n", "repo_name": "commons-lang-master/", "id": 1984, "method_signature": "void testSelfInstanceTwoVarsReflectionObjectCycle()", "filename": "ToStringBuilderTest.testSelfInstanceTwoVarsReflectionObjectCycle.json"}
{"callee_method_names": ["SelfInstanceVarReflectionTestFixture.toString"], "method_name": "ToStringBuilderTest.testSelfInstanceVarReflectionObjectCycle", "method_implementation": "{\n    final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n    assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n}", "repo_id": "8", "comment": "/**\n * Test a class that defines an ivar pointing to itself.\n */\n", "repo_name": "commons-lang-master/", "id": 1985, "method_signature": "void testSelfInstanceVarReflectionObjectCycle()", "filename": "ToStringBuilderTest.testSelfInstanceVarReflectionObjectCycle.json"}
{"callee_method_names": ["SimpleReflectionTestFixture.toString"], "method_name": "ToStringBuilderTest.testSimpleReflectionObjectCycle", "method_implementation": "{\n    final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n    simple.o = simple;\n    assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n}", "repo_id": "8", "comment": "/**\n * Test an Object pointing to itself, the simplest test.\n */\n", "repo_name": "commons-lang-master/", "id": 1986, "method_signature": "void testSimpleReflectionObjectCycle()", "filename": "ToStringBuilderTest.testSimpleReflectionObjectCycle.json"}
{"callee_method_ids": [898, 899], "callee_method_names": ["ReflectionToStringBuilder.setUpToClass", "ReflectionToStringBuilder.toString"], "method_name": "ToStringBuilderTest.test_setUpToClass_invalid", "method_implementation": "{\n    final Integer val = Integer.valueOf(5);\n    final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n    assertThrows(IllegalArgumentException.class, () -> test.setUpToClass(String.class));\n    test.toString();\n}", "repo_id": "8", "comment": "/**\n * Tests ReflectionToStringBuilder setUpToClass().\n */\n", "repo_name": "commons-lang-master/", "id": 1973, "method_signature": "void test_setUpToClass_invalid()", "filename": "ToStringBuilderTest.test_setUpToClass_invalid.json"}
{"callee_method_ids": [898, 899], "callee_method_names": ["ReflectionToStringBuilder.setUpToClass", "ReflectionToStringBuilder.toString"], "method_name": "ToStringBuilderTest.test_setUpToClass_valid", "method_implementation": "{\n    final Integer val = Integer.valueOf(5);\n    final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n    test.setUpToClass(Number.class);\n    test.toString();\n}", "repo_id": "8", "comment": "/**\n * Tests ReflectionToStringBuilder setUpToClass().\n */\n", "repo_name": "commons-lang-master/", "id": 1974, "method_signature": "void test_setUpToClass_valid()", "filename": "ToStringBuilderTest.test_setUpToClass_valid.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.append", "method_implementation": "{\n    appendFieldStart(buffer, fieldName);\n    if (array == null) {\n        appendNullText(buffer, fieldName);\n    } else if (isFullDetail(fullDetail)) {\n        appendDetail(buffer, fieldName, array);\n    } else {\n        appendSummary(buffer, fieldName, array);\n    }\n    appendFieldEnd(buffer, fieldName);\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} a {@code short}\n * array.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param fieldName  the field name\n * @param array  the array to add to the {@code toString}\n * @param fullDetail  {@code true} for detail, {@code false}\n *  for summary info, {@code null} for style decides\n */\n", "repo_name": "commons-lang-master/", "id": 921, "method_signature": "void append(StringBuffer, String, short[], Boolean)", "filename": "ToStringStyle.append.json"}
{"callee_method_names": ["StringBuffer.append", "Object.getClass", "StringBuffer.append", "Object.getClass"], "method_name": "ToStringStyle.appendClassName", "method_implementation": "{\n    if (useClassName && object != null) {\n        register(object);\n        if (useShortClassName) {\n            buffer.append(getShortClassName(object.getClass()));\n        } else {\n            buffer.append(object.getClass().getName());\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} the class name.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param object  the {@link Object} whose name to output\n */\n", "repo_name": "commons-lang-master/", "id": 922, "method_signature": "void appendClassName(StringBuffer, Object)", "filename": "ToStringStyle.appendClassName.json"}
{"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append"], "method_name": "ToStringStyle.appendDetail", "method_implementation": "{\n    buffer.append(arrayStart);\n    for (int i = 0; i < array.length; i++) {\n        if (i > 0) {\n            buffer.append(arraySeparator);\n        }\n        appendDetail(buffer, fieldName, array[i]);\n    }\n    buffer.append(arrayEnd);\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} the detail of a\n * {@code short} array.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the {@code toString},\n *  not {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 932, "method_signature": "void appendDetail(StringBuffer, String, short[])", "filename": "ToStringStyle.appendDetail.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.appendEnd", "method_implementation": "{\n    if (!this.fieldSeparatorAtEnd) {\n        removeLastFieldSeparator(buffer);\n    }\n    appendContentEnd(buffer);\n    unregister(object);\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} the end of data indicator.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param object  the {@link Object} to build a\n *  {@code toString} for.\n */\n", "repo_name": "commons-lang-master/", "id": 933, "method_signature": "void appendEnd(StringBuffer, Object)", "filename": "ToStringStyle.appendEnd.json"}
{"callee_method_names": ["StringBuffer.append", "StringBuffer.append"], "method_name": "ToStringStyle.appendFieldStart", "method_implementation": "{\n    if (useFieldNames && fieldName != null) {\n        buffer.append(fieldName);\n        buffer.append(fieldNameValueSeparator);\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} the field start.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param fieldName  the field name\n */\n", "repo_name": "commons-lang-master/", "id": 934, "method_signature": "void appendFieldStart(StringBuffer, String)", "filename": "ToStringStyle.appendFieldStart.json"}
{"callee_method_names": ["StringBuffer.append", "StringBuffer.append"], "method_name": "ToStringStyle.appendIdentityHashCode", "method_implementation": "{\n    if (this.isUseIdentityHashCode() && object != null) {\n        register(object);\n        buffer.append('@');\n        buffer.append(ObjectUtils.identityHashCodeHex(object));\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends the {@link System#identityHashCode(java.lang.Object)}.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param object  the {@link Object} whose id to output\n */\n", "repo_name": "commons-lang-master/", "id": 935, "method_signature": "void appendIdentityHashCode(StringBuffer, Object)", "filename": "ToStringStyle.appendIdentityHashCode.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.appendInternal", "method_implementation": "{\n    if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n        appendCyclicObject(buffer, fieldName, value);\n        return;\n    }\n    register(value);\n    try {\n        if (value instanceof Collection<?>) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (Collection<?>) value);\n            } else {\n                appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n            }\n        } else if (value instanceof Map<?, ?>) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (Map<?, ?>) value);\n            } else {\n                appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n            }\n        } else if (value instanceof long[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (long[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (long[]) value);\n            }\n        } else if (value instanceof int[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (int[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (int[]) value);\n            }\n        } else if (value instanceof short[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (short[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (short[]) value);\n            }\n        } else if (value instanceof byte[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (byte[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (byte[]) value);\n            }\n        } else if (value instanceof char[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (char[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (char[]) value);\n            }\n        } else if (value instanceof double[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (double[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (double[]) value);\n            }\n        } else if (value instanceof float[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (float[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (float[]) value);\n            }\n        } else if (value instanceof boolean[]) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (boolean[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (boolean[]) value);\n            }\n        } else if (ObjectUtils.isArray(value)) {\n            if (detail) {\n                appendDetail(buffer, fieldName, (Object[]) value);\n            } else {\n                appendSummary(buffer, fieldName, (Object[]) value);\n            }\n        } else if (detail) {\n            appendDetail(buffer, fieldName, value);\n        } else {\n            appendSummary(buffer, fieldName, value);\n        }\n    } finally {\n        unregister(value);\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} an {@link Object},\n * correctly interpreting its type.\n *\n * <p>This method performs the main lookup by Class type to correctly\n * route arrays, {@link Collection}s, {@link Map}s and\n * {@link Objects} to the appropriate method.</p>\n *\n * <p>Either detail or summary views can be specified.</p>\n *\n * <p>If a cycle is detected, an object will be appended with the\n * {@code Object.toString()} format.</p>\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param value  the value to add to the {@code toString},\n *  not {@code null}\n * @param detail  output detail or not\n */\n", "repo_name": "commons-lang-master/", "id": 936, "method_signature": "void appendInternal(StringBuffer, String, Object, boolean)", "filename": "ToStringStyle.appendInternal.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.appendStart", "method_implementation": "{\n    if (object != null) {\n        appendClassName(buffer, object);\n        appendIdentityHashCode(buffer, object);\n        appendContentStart(buffer);\n        if (fieldSeparatorAtStart) {\n            appendFieldSeparator(buffer);\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} the start of data indicator.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param object  the {@link Object} to build a {@code toString} for\n */\n", "repo_name": "commons-lang-master/", "id": 937, "method_signature": "void appendStart(StringBuffer, Object)", "filename": "ToStringStyle.appendStart.json"}
{"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "Object.getClass", "StringBuffer.append"], "method_name": "ToStringStyle.appendSummary", "method_implementation": "{\n    buffer.append(summaryObjectStartText);\n    buffer.append(getShortClassName(value.getClass()));\n    buffer.append(summaryObjectEndText);\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} an {@link Object}\n * value, printing a summary of the {@link Object}.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param value  the value to add to the {@code toString},\n *  not {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 938, "method_signature": "void appendSummary(StringBuffer, String, Object)", "filename": "ToStringStyle.appendSummary.json"}
{"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append"], "method_name": "ToStringStyle.appendSummarySize", "method_implementation": "{\n    buffer.append(sizeStartText);\n    buffer.append(size);\n    buffer.append(sizeEndText);\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} a size summary.\n *\n * <p>The size summary is used to summarize the contents of\n * {@link Collection}s, {@link Map}s and arrays.</p>\n *\n * <p>The output consists of a prefix, the passed in size\n * and a suffix.</p>\n *\n * <p>The default format is {@code '&lt;size=n&gt;'}.</p>\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param size  the size to append\n */\n", "repo_name": "commons-lang-master/", "id": 939, "method_signature": "void appendSummarySize(StringBuffer, String, int)", "filename": "ToStringStyle.appendSummarySize.json"}
{"callee_method_names": ["String.indexOf", "String.length", "String.lastIndexOf", "StringBuffer.append"], "method_name": "ToStringStyle.appendToString", "method_implementation": "{\n    if (toString != null) {\n        final int pos1 = toString.indexOf(contentStart) + contentStart.length();\n        final int pos2 = toString.lastIndexOf(contentEnd);\n        if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {\n            if (fieldSeparatorAtStart) {\n                removeLastFieldSeparator(buffer);\n            }\n            buffer.append(toString, pos1, pos2);\n            appendFieldSeparator(buffer);\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} another toString.\n * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle.</p>\n *\n * <p>A {@code null} {@code toString} is ignored.</p>\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param toString  the additional {@code toString}\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 940, "method_signature": "void appendToString(StringBuffer, String)", "filename": "ToStringStyle.appendToString.json"}
{"callee_method_names": ["Boolean.booleanValue"], "method_name": "ToStringStyle.isFullDetail", "method_implementation": "{\n    if (fullDetailRequest == null) {\n        return defaultFullDetail;\n    }\n    return fullDetailRequest.booleanValue();\n}", "repo_id": "8", "comment": "/**\n * Is this field to be output in full detail.\n *\n * <p>This method converts a detail request into a detail level.\n * The calling code may request full detail ({@code true}),\n * but a subclass might ignore that and always return\n * {@code false}. The calling code may pass in\n * {@code null} indicating that it doesn't care about\n * the detail level. In this case the default detail level is\n * used.</p>\n *\n * @param fullDetailRequest  the detail level requested\n * @return whether full detail is to be shown\n */\n", "repo_name": "commons-lang-master/", "id": 941, "method_signature": "boolean isFullDetail(Boolean)", "filename": "ToStringStyle.isFullDetail.json"}
{"callee_method_names": ["StringBuffer.append", "StringBuffer.append"], "method_name": "ToStringStyle.reflectionAppendArrayDetail", "method_implementation": "{\n    buffer.append(arrayStart);\n    final int length = Array.getLength(array);\n    for (int i = 0; i < length; i++) {\n        appendDetail(buffer, fieldName, i, Array.get(array, i));\n    }\n    buffer.append(arrayEnd);\n}", "repo_id": "8", "comment": "/**\n * Appends to the {@code toString} the detail of an array type.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the {@code toString},\n *  not {@code null}\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 942, "method_signature": "void reflectionAppendArrayDetail(StringBuffer, String, Object)", "filename": "ToStringStyle.reflectionAppendArrayDetail.json"}
{"callee_method_names": ["ThreadLocal.set"], "method_name": "ToStringStyle.register", "method_implementation": "{\n    if (value != null) {\n        final Map<Object, Object> m = getRegistry();\n        if (m == null) {\n            REGISTRY.set(new WeakHashMap<>());\n        }\n        getRegistry().put(value, null);\n    }\n}", "repo_id": "8", "comment": "/**\n * Registers the given object. Used by the reflection methods to avoid\n * infinite loops.\n *\n * @param value\n *                  The object to register.\n */\n", "repo_name": "commons-lang-master/", "id": 902, "method_signature": "void register(Object)", "filename": "ToStringStyle.register.json"}
{"callee_method_names": ["StringBuffer.setLength", "StringBuffer.length", "String.length"], "method_name": "ToStringStyle.removeLastFieldSeparator", "method_implementation": "{\n    if (StringUtils.endsWith(buffer, fieldSeparator)) {\n        buffer.setLength(buffer.length() - fieldSeparator.length());\n    }\n}", "repo_id": "8", "comment": "/**\n * Remove the last field separator from the buffer.\n *\n * @param buffer  the {@link StringBuffer} to populate\n * @since 2.0\n */\n", "repo_name": "commons-lang-master/", "id": 943, "method_signature": "void removeLastFieldSeparator(StringBuffer)", "filename": "ToStringStyle.removeLastFieldSeparator.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setArrayEnd", "method_implementation": "{\n    if (arrayEnd == null) {\n        arrayEnd = StringUtils.EMPTY;\n    }\n    this.arrayEnd = arrayEnd;\n}", "repo_id": "8", "comment": "/**\n * Sets the array end text.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param arrayEnd  the new array end text\n */\n", "repo_name": "commons-lang-master/", "id": 944, "method_signature": "void setArrayEnd(String)", "filename": "ToStringStyle.setArrayEnd.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setArraySeparator", "method_implementation": "{\n    if (arraySeparator == null) {\n        arraySeparator = StringUtils.EMPTY;\n    }\n    this.arraySeparator = arraySeparator;\n}", "repo_id": "8", "comment": "/**\n * Sets the array separator text.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param arraySeparator  the new array separator text\n */\n", "repo_name": "commons-lang-master/", "id": 945, "method_signature": "void setArraySeparator(String)", "filename": "ToStringStyle.setArraySeparator.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setArrayStart", "method_implementation": "{\n    if (arrayStart == null) {\n        arrayStart = StringUtils.EMPTY;\n    }\n    this.arrayStart = arrayStart;\n}", "repo_id": "8", "comment": "/**\n * Sets the array start text.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param arrayStart  the new array start text\n */\n", "repo_name": "commons-lang-master/", "id": 946, "method_signature": "void setArrayStart(String)", "filename": "ToStringStyle.setArrayStart.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setContentEnd", "method_implementation": "{\n    if (contentEnd == null) {\n        contentEnd = StringUtils.EMPTY;\n    }\n    this.contentEnd = contentEnd;\n}", "repo_id": "8", "comment": "/**\n * Sets the content end text.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param contentEnd  the new content end text\n */\n", "repo_name": "commons-lang-master/", "id": 947, "method_signature": "void setContentEnd(String)", "filename": "ToStringStyle.setContentEnd.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setContentStart", "method_implementation": "{\n    if (contentStart == null) {\n        contentStart = StringUtils.EMPTY;\n    }\n    this.contentStart = contentStart;\n}", "repo_id": "8", "comment": "/**\n * Sets the content start text.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param contentStart  the new content start text\n */\n", "repo_name": "commons-lang-master/", "id": 948, "method_signature": "void setContentStart(String)", "filename": "ToStringStyle.setContentStart.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setFieldNameValueSeparator", "method_implementation": "{\n    if (fieldNameValueSeparator == null) {\n        fieldNameValueSeparator = StringUtils.EMPTY;\n    }\n    this.fieldNameValueSeparator = fieldNameValueSeparator;\n}", "repo_id": "8", "comment": "/**\n * Sets the field name value separator text.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param fieldNameValueSeparator  the new field name value separator text\n */\n", "repo_name": "commons-lang-master/", "id": 949, "method_signature": "void setFieldNameValueSeparator(String)", "filename": "ToStringStyle.setFieldNameValueSeparator.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setFieldSeparator", "method_implementation": "{\n    if (fieldSeparator == null) {\n        fieldSeparator = StringUtils.EMPTY;\n    }\n    this.fieldSeparator = fieldSeparator;\n}", "repo_id": "8", "comment": "/**\n * Sets the field separator text.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param fieldSeparator  the new field separator text\n */\n", "repo_name": "commons-lang-master/", "id": 950, "method_signature": "void setFieldSeparator(String)", "filename": "ToStringStyle.setFieldSeparator.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setNullText", "method_implementation": "{\n    if (nullText == null) {\n        nullText = StringUtils.EMPTY;\n    }\n    this.nullText = nullText;\n}", "repo_id": "8", "comment": "/**\n * Sets the text to output when {@code null} found.\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param nullText  the new text to output when null found\n */\n", "repo_name": "commons-lang-master/", "id": 951, "method_signature": "void setNullText(String)", "filename": "ToStringStyle.setNullText.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setSizeEndText", "method_implementation": "{\n    if (sizeEndText == null) {\n        sizeEndText = StringUtils.EMPTY;\n    }\n    this.sizeEndText = sizeEndText;\n}", "repo_id": "8", "comment": "/**\n * Sets the end text to output when a {@link Collection},\n * {@link Map} or array size is output.\n *\n * <p>This is output after the size value.</p>\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param sizeEndText  the new end of size text\n */\n", "repo_name": "commons-lang-master/", "id": 952, "method_signature": "void setSizeEndText(String)", "filename": "ToStringStyle.setSizeEndText.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setSizeStartText", "method_implementation": "{\n    if (sizeStartText == null) {\n        sizeStartText = StringUtils.EMPTY;\n    }\n    this.sizeStartText = sizeStartText;\n}", "repo_id": "8", "comment": "/**\n * Sets the start text to output when a {@link Collection},\n * {@link Map} or array size is output.\n *\n * <p>This is output before the size value.</p>\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param sizeStartText  the new start of size text\n */\n", "repo_name": "commons-lang-master/", "id": 953, "method_signature": "void setSizeStartText(String)", "filename": "ToStringStyle.setSizeStartText.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setSummaryObjectEndText", "method_implementation": "{\n    if (summaryObjectEndText == null) {\n        summaryObjectEndText = StringUtils.EMPTY;\n    }\n    this.summaryObjectEndText = summaryObjectEndText;\n}", "repo_id": "8", "comment": "/**\n * Sets the end text to output when an {@link Object} is\n * output in summary mode.\n *\n * <p>This is output after the size value.</p>\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param summaryObjectEndText  the new end of summary text\n */\n", "repo_name": "commons-lang-master/", "id": 954, "method_signature": "void setSummaryObjectEndText(String)", "filename": "ToStringStyle.setSummaryObjectEndText.json"}
{"callee_method_names": [], "method_name": "ToStringStyle.setSummaryObjectStartText", "method_implementation": "{\n    if (summaryObjectStartText == null) {\n        summaryObjectStartText = StringUtils.EMPTY;\n    }\n    this.summaryObjectStartText = summaryObjectStartText;\n}", "repo_id": "8", "comment": "/**\n * Sets the start text to output when an {@link Object} is\n * output in summary mode.\n *\n * <p>This is output before the size value.</p>\n *\n * <p>{@code null} is accepted, but will be converted to\n * an empty String.</p>\n *\n * @param summaryObjectStartText  the new start of summary text\n */\n", "repo_name": "commons-lang-master/", "id": 955, "method_signature": "void setSummaryObjectStartText(String)", "filename": "ToStringStyle.setSummaryObjectStartText.json"}
{"callee_method_names": ["Map<Object, Object>.remove", "Map<Object, Object>.isEmpty", "ThreadLocal.remove"], "method_name": "ToStringStyle.unregister", "method_implementation": "{\n    if (value != null) {\n        final Map<Object, Object> m = getRegistry();\n        if (m != null) {\n            m.remove(value);\n            if (m.isEmpty()) {\n                REGISTRY.remove();\n            }\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Unregisters the given object.\n *\n * <p>\n * Used by the reflection methods to avoid infinite loops.\n * </p>\n *\n * @param value\n *                  The object to unregister.\n */\n", "repo_name": "commons-lang-master/", "id": 903, "method_signature": "void unregister(Object)", "filename": "ToStringStyle.unregister.json"}
{"callee_method_names": ["Token.getClass", "Token.toString"], "method_name": "Token.equals", "method_implementation": "{\n    if (obj2 instanceof Token) {\n        final Token tok2 = (Token) obj2;\n        if (this.value.getClass() != tok2.value.getClass()) {\n            return false;\n        }\n        if (this.count != tok2.count) {\n            return false;\n        }\n        if (this.value instanceof StringBuilder) {\n            return this.value.toString().equals(tok2.value.toString());\n        }\n        if (this.value instanceof Number) {\n            return this.value.equals(tok2.value);\n        }\n        return this.value == tok2.value;\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Supports equality of this Token to another Token.\n *\n * @param obj2 Object to consider equality of\n * @return boolean {@code true} if equal\n */\n", "repo_name": "commons-lang-master/", "id": 612, "method_signature": "boolean equals(Object)", "filename": "Token.equals.json"}
{"callee_method_names": ["TriConsumer<? super T,? super U,? super V>.accept"], "method_name": "TriConsumer.andThen", "method_implementation": "{\n    Objects.requireNonNull(after);\n    return (t, u, v) -> {\n        accept(t, u, v);\n        after.accept(t, u, v);\n    };\n}", "repo_id": "8", "comment": "/**\n * Returns a composed {@link TriConsumer} that performs, in sequence, this operation followed by the {@code after}\n * operation. If performing either operation throws an exception, it is relayed to the caller of the composed\n * operation. If performing this operation throws an exception, the {@code after} operation will not be performed.\n *\n * @param after the operation to perform after this operation.\n * @return a composed {@link TriConsumer} that performs in sequence this operation followed by the {@code after}\n *         operation.\n * @throws NullPointerException if {@code after} is null.\n */\n", "repo_name": "commons-lang-master/", "id": 173, "method_signature": "TriConsumer<T,U,V> andThen(TriConsumer)", "filename": "TriConsumer.andThen.json"}
{"callee_method_names": ["Triple<L,M,R>.getLeft", "Triple<L,M,R>.getMiddle", "Triple<L,M,R>.getRight"], "method_name": "Triple.compareTo", "method_implementation": "{\n    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison();\n}", "repo_id": "8", "comment": "/**\n * Compares the triple based on the left element, followed by the middle element,\n * finally the right element.\n * The types must be {@link Comparable}.\n *\n * @param other  the other triple, not null\n * @return negative if this is less, zero if equal, positive if greater\n */\n", "repo_name": "commons-lang-master/", "id": 1327, "method_signature": "int compareTo(Triple)", "filename": "Triple.compareTo.json"}
{"callee_method_names": ["Triple<?, ?, ?>.getLeft", "Triple<?, ?, ?>.getMiddle", "Triple<?, ?, ?>.getRight"], "method_name": "Triple.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof Triple<?, ?, ?>) {\n        final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj;\n        return Objects.equals(getLeft(), other.getLeft()) && Objects.equals(getMiddle(), other.getMiddle()) && Objects.equals(getRight(), other.getRight());\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Compares this triple to another based on the three elements.\n *\n * @param obj  the object to compare to, null returns false\n * @return true if the elements of the triple are equal\n */\n", "repo_name": "commons-lang-master/", "id": 1328, "method_signature": "boolean equals(Object)", "filename": "Triple.equals.json"}
{"callee_method_names": ["Calendar.get", "Calendar.getLeastMaximum", "NumberRule.appendTo"], "method_name": "TwelveHourField.appendTo", "method_implementation": "{\n    int value = calendar.get(Calendar.HOUR);\n    if (value == 0) {\n        value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n    }\n    rule.appendTo(buffer, value);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 681, "method_signature": "void appendTo(Appendable, Calendar)", "filename": "TwelveHourField.appendTo.json"}
{"callee_method_names": ["Calendar.get", "Calendar.getMaximum", "NumberRule.appendTo"], "method_name": "TwentyFourHourField.appendTo", "method_implementation": "{\n    int value = calendar.get(Calendar.HOUR_OF_DAY);\n    if (value == 0) {\n        value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n    }\n    rule.appendTo(buffer, value);\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 682, "method_signature": "void appendTo(Appendable, Calendar)", "filename": "TwentyFourHourField.appendTo.json"}
{"callee_method_names": [], "method_name": "TwoDigitNumberField.appendTo", "method_implementation": "{\n    if (value < 100) {\n        appendDigits(buffer, value);\n    } else {\n        appendFullDigits(buffer, value, 2);\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 683, "method_signature": "void appendTo(Appendable, int)", "filename": "TwoDigitNumberField.appendTo.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append"], "method_name": "TypeUtils.appendAllTo", "method_implementation": "{\n    Validate.notEmpty(Validate.noNullElements(types));\n    if (types.length > 0) {\n        builder.append(toString(types[0]));\n        for (int i = 1; i < types.length; i++) {\n            builder.append(sep).append(toString(types[i]));\n        }\n    }\n    return builder;\n}", "repo_id": "8", "comment": "/**\n * Appends {@code types} to {@code builder} with separator {@code sep}.\n *\n * @param builder destination\n * @param sep separator\n * @param types to append\n * @return {@code builder}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 252, "method_signature": "StringBuilder appendAllTo(StringBuilder, String, T[])", "filename": "TypeUtils.appendAllTo.json"}
{"callee_method_names": ["Class<?>.isArray", "Class<?>.getComponentType", "Class<?>.getEnclosingClass", "StringBuilder.append", "Class<?>.getEnclosingClass", "Class<?>.getSimpleName", "StringBuilder.append", "Class<?>.getName", "Class<?>.getTypeParameters", "StringBuilder.append", "Class<?>.getTypeParameters", "StringBuilder.append", "StringBuilder.toString"], "method_name": "TypeUtils.classToString", "method_implementation": "{\n    if (cls.isArray()) {\n        return toString(cls.getComponentType()) + \"[]\";\n    }\n    final StringBuilder buf = new StringBuilder();\n    if (cls.getEnclosingClass() != null) {\n        buf.append(classToString(cls.getEnclosingClass())).append('.').append(cls.getSimpleName());\n    } else {\n        buf.append(cls.getName());\n    }\n    if (cls.getTypeParameters().length > 0) {\n        buf.append('<');\n        appendAllTo(buf, \", \", cls.getTypeParameters());\n        buf.append('>');\n    }\n    return buf.toString();\n}", "repo_id": "8", "comment": "/**\n * Formats a {@link Class} as a {@link String}.\n *\n * @param cls {@link Class} to format\n * @return String\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 253, "method_signature": "String classToString(Class)", "filename": "TypeUtils.classToString.json"}
{"callee_method_names": [], "method_name": "TypeUtils.containsTypeVariables", "method_implementation": "{\n    if (type instanceof TypeVariable<?>) {\n        return true;\n    }\n    if (type instanceof Class<?>) {\n        return ((Class<?>) type).getTypeParameters().length > 0;\n    }\n    if (type instanceof ParameterizedType) {\n        for (final Type arg : ((ParameterizedType) type).getActualTypeArguments()) {\n            if (containsTypeVariables(arg)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (type instanceof WildcardType) {\n        final WildcardType wild = (WildcardType) type;\n        return containsTypeVariables(getImplicitLowerBounds(wild)[0]) || containsTypeVariables(getImplicitUpperBounds(wild)[0]);\n    }\n    if (type instanceof GenericArrayType) {\n        return containsTypeVariables(((GenericArrayType) type).getGenericComponentType());\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Tests, recursively, whether any of the type parameters associated with {@code type} are bound to variables.\n *\n * @param type the type to check for type variables\n * @return boolean\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 254, "method_signature": "boolean containsTypeVariables(Type)", "filename": "TypeUtils.containsTypeVariables.json"}
{"callee_method_names": ["Class<?>.equals"], "method_name": "TypeUtils.determineTypeArguments", "method_implementation": "{\n    Objects.requireNonNull(cls, \"cls\");\n    Objects.requireNonNull(superParameterizedType, \"superParameterizedType\");\n    final Class<?> superClass = getRawType(superParameterizedType);\n    // compatibility check\n    if (!isAssignable(cls, superClass)) {\n        return null;\n    }\n    if (cls.equals(superClass)) {\n        return getTypeArguments(superParameterizedType, superClass, null);\n    }\n    // get the next class in the inheritance hierarchy\n    final Type midType = getClosestParentType(cls, superClass);\n    // can only be a class or a parameterized type\n    if (midType instanceof Class<?>) {\n        return determineTypeArguments((Class<?>) midType, superParameterizedType);\n    }\n    final ParameterizedType midParameterizedType = (ParameterizedType) midType;\n    final Class<?> midClass = getRawType(midParameterizedType);\n    // get the type variables of the mid class that map to the type\n    // arguments of the super class\n    final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superParameterizedType);\n    // map the arguments of the mid type to the class type variables\n    mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);\n    return typeVarAssigns;\n}", "repo_id": "8", "comment": "/**\n * Tries to determine the type arguments of a class/interface based on a\n * super parameterized type's type arguments. This method is the inverse of\n * {@link #getTypeArguments(Type, Class)} which gets a class/interface's\n * type arguments based on a subtype. It is far more limited in determining\n * the type arguments for the subject class's type variables in that it can\n * only determine those parameters that map from the subject {@link Class}\n * object to the supertype.\n *\n * <p>\n * Example: {@link java.util.TreeSet\n * TreeSet} sets its parameter as the parameter for\n * {@link java.util.NavigableSet NavigableSet}, which in turn sets the\n * parameter of {@link java.util.SortedSet}, which in turn sets the\n * parameter of {@link Set}, which in turn sets the parameter of\n * {@link java.util.Collection}, which in turn sets the parameter of\n * {@link Iterable}. Since {@link TreeSet}'s parameter maps\n * (indirectly) to {@link Iterable}'s parameter, it will be able to\n * determine that based on the super type {@code Iterable<? extends\n * Map<Integer, ? extends Collection<?>>>}, the parameter of\n * {@link TreeSet} is {@code ? extends Map<Integer, ? extends\n * Collection<?>>}.\n * </p>\n *\n * @param cls the class whose type parameters are to be determined, not {@code null}\n * @param superParameterizedType the super type from which {@code cls}'s type\n * arguments are to be determined, not {@code null}\n * @return a {@link Map} of the type assignments that could be determined\n * for the type variables in each type in the inheritance hierarchy from\n * {@code type} to {@code toClass} inclusive.\n * @throws NullPointerException if either {@code cls} or {@code superParameterizedType} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 255, "method_signature": "Map<TypeVariable<?>,Type> determineTypeArguments(Class, ParameterizedType)", "filename": "TypeUtils.determineTypeArguments.json"}
{"callee_method_names": [], "method_name": "TypeUtils.equals", "method_implementation": "{\n    if (type instanceof WildcardType) {\n        final WildcardType other = (WildcardType) type;\n        return equals(getImplicitLowerBounds(wildcardType), getImplicitLowerBounds(other)) && equals(getImplicitUpperBounds(wildcardType), getImplicitUpperBounds(other));\n    }\n    return false;\n}", "repo_id": "8", "comment": "/**\n * Tests whether {@code t} equals {@code w}.\n *\n * @param wildcardType LHS\n * @param type RHS\n * @return boolean\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 259, "method_signature": "boolean equals(WildcardType, Type)", "filename": "TypeUtils.equals.json"}
{"callee_method_names": ["Map<TypeVariable<?>,Type>.containsKey", "Map<TypeVariable<?>,Type>.get"], "method_name": "TypeUtils.extractTypeArgumentsFrom", "method_implementation": "{\n    final Type[] result = new Type[variables.length];\n    int index = 0;\n    for (final TypeVariable<?> var : variables) {\n        Validate.isTrue(mappings.containsKey(var), \"missing argument mapping for %s\", toString(var));\n        result[index++] = mappings.get(var);\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Helper method to establish the formal parameters for a parameterized type.\n *\n * @param mappings map containing the assignments\n * @param variables expected map keys\n * @return array of map values corresponding to specified keys\n */\n", "repo_name": "commons-lang-master/", "id": 260, "method_signature": "Type[] extractTypeArgumentsFrom(Map, TypeVariable<?>[])", "filename": "TypeUtils.extractTypeArgumentsFrom.json"}
{"callee_method_names": ["Class<?>.isArray", "Class<?>.getComponentType"], "method_name": "TypeUtils.getArrayComponentType", "method_implementation": "{\n    if (type instanceof Class<?>) {\n        final Class<?> cls = (Class<?>) type;\n        return cls.isArray() ? cls.getComponentType() : null;\n    }\n    if (type instanceof GenericArrayType) {\n        return ((GenericArrayType) type).getGenericComponentType();\n    }\n    return null;\n}", "repo_id": "8", "comment": "/**\n * Gets the array component type of {@code type}.\n *\n * @param type the type to be checked\n * @return component type or null if type is not an array type\n */\n", "repo_name": "commons-lang-master/", "id": 261, "method_signature": "Type getArrayComponentType(Type)", "filename": "TypeUtils.getArrayComponentType.json"}
{"callee_method_names": ["Class<?>.isInterface", "Class<?>.getGenericInterfaces", "Class<?>.getGenericSuperclass"], "method_name": "TypeUtils.getClosestParentType", "method_implementation": "{\n    // only look at the interfaces if the super class is also an interface\n    if (superClass.isInterface()) {\n        // get the generic interfaces of the subject class\n        final Type[] interfaceTypes = cls.getGenericInterfaces();\n        // will hold the best generic interface match found\n        Type genericInterface = null;\n        // find the interface closest to the super class\n        for (final Type midType : interfaceTypes) {\n            final Class<?> midClass;\n            if (midType instanceof ParameterizedType) {\n                midClass = getRawType((ParameterizedType) midType);\n            } else if (midType instanceof Class<?>) {\n                midClass = (Class<?>) midType;\n            } else {\n                throw new IllegalStateException(\"Unexpected generic\" + \" interface type found: \" + midType);\n            }\n            // check if this interface is further up the inheritance chain\n            // than the previously found match\n            if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) {\n                genericInterface = midType;\n            }\n        }\n        // found a match?\n        if (genericInterface != null) {\n            return genericInterface;\n        }\n    }\n    // none of the interfaces were descendants of the target class, so the\n    // super class has to be one, instead\n    return cls.getGenericSuperclass();\n}", "repo_id": "8", "comment": "/**\n * Gets the closest parent type to the\n * super class specified by {@code superClass}.\n *\n * @param cls the class in question\n * @param superClass the super class\n * @return the closes parent type\n */\n", "repo_name": "commons-lang-master/", "id": 262, "method_signature": "Type getClosestParentType(Class, Class)", "filename": "TypeUtils.getClosestParentType.json"}
{"callee_method_names": ["TypeVariable<?>.getBounds"], "method_name": "TypeUtils.getImplicitBounds", "method_implementation": "{\n    Objects.requireNonNull(typeVariable, \"typeVariable\");\n    final Type[] bounds = typeVariable.getBounds();\n    return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n}", "repo_id": "8", "comment": "/**\n * Gets an array containing the sole type of {@link Object} if\n * {@link TypeVariable#getBounds()} returns an empty array. Otherwise, it\n * returns the result of {@link TypeVariable#getBounds()} passed into\n * {@link #normalizeUpperBounds}.\n *\n * @param typeVariable the subject type variable, not {@code null}\n * @return a non-empty array containing the bounds of the type variable.\n * @throws NullPointerException if {@code typeVariable} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 263, "method_signature": "Type[] getImplicitBounds(TypeVariable)", "filename": "TypeUtils.getImplicitBounds.json"}
{"callee_method_names": ["WildcardType.getLowerBounds"], "method_name": "TypeUtils.getImplicitLowerBounds", "method_implementation": "{\n    Objects.requireNonNull(wildcardType, \"wildcardType\");\n    final Type[] bounds = wildcardType.getLowerBounds();\n    return bounds.length == 0 ? new Type[] { null } : bounds;\n}", "repo_id": "8", "comment": "/**\n * Gets an array containing a single value of {@code null} if\n * {@link WildcardType#getLowerBounds()} returns an empty array. Otherwise,\n * it returns the result of {@link WildcardType#getLowerBounds()}.\n *\n * @param wildcardType the subject wildcard type, not {@code null}\n * @return a non-empty array containing the lower bounds of the wildcard\n * type.\n * @throws NullPointerException if {@code wildcardType} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 264, "method_signature": "Type[] getImplicitLowerBounds(WildcardType)", "filename": "TypeUtils.getImplicitLowerBounds.json"}
{"callee_method_names": ["WildcardType.getUpperBounds"], "method_name": "TypeUtils.getImplicitUpperBounds", "method_implementation": "{\n    Objects.requireNonNull(wildcardType, \"wildcardType\");\n    final Type[] bounds = wildcardType.getUpperBounds();\n    return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n}", "repo_id": "8", "comment": "/**\n * Gets an array containing the sole value of {@link Object} if\n * {@link WildcardType#getUpperBounds()} returns an empty array. Otherwise,\n * it returns the result of {@link WildcardType#getUpperBounds()}\n * passed into {@link #normalizeUpperBounds}.\n *\n * @param wildcardType the subject wildcard type, not {@code null}\n * @return a non-empty array containing the upper bounds of the wildcard\n * type.\n * @throws NullPointerException if {@code wildcardType} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 265, "method_signature": "Type[] getImplicitUpperBounds(WildcardType)", "filename": "TypeUtils.getImplicitUpperBounds.json"}
{"callee_method_names": ["Map<TypeVariable<?>, Type>.get"], "method_name": "TypeUtils.getRawType", "method_implementation": "{\n    if (type instanceof Class<?>) {\n        // it is raw, no problem\n        return (Class<?>) type;\n    }\n    if (type instanceof ParameterizedType) {\n        // simple enough to get the raw type of a ParameterizedType\n        return getRawType((ParameterizedType) type);\n    }\n    if (type instanceof TypeVariable<?>) {\n        if (assigningType == null) {\n            return null;\n        }\n        // get the entity declaring this type variable\n        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n        // can't get the raw type of a method- or constructor-declared type\n        // variable\n        if (!(genericDeclaration instanceof Class<?>)) {\n            return null;\n        }\n        // get the type arguments for the declaring class/interface based\n        // on the enclosing type\n        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);\n        // enclosingType has to be a subclass (or subinterface) of the\n        // declaring type\n        if (typeVarAssigns == null) {\n            return null;\n        }\n        // get the argument assigned to this type variable\n        final Type typeArgument = typeVarAssigns.get(type);\n        if (typeArgument == null) {\n            return null;\n        }\n        // get the argument for this type variable\n        return getRawType(typeArgument, assigningType);\n    }\n    if (type instanceof GenericArrayType) {\n        // get raw component type\n        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);\n        // create array type from raw component type and return its class\n        return rawComponentType != null ? Array.newInstance(rawComponentType, 0).getClass() : null;\n    }\n    // (hand-waving) this is not the method you're looking for\n    if (type instanceof WildcardType) {\n        return null;\n    }\n    throw new IllegalArgumentException(\"unknown type: \" + type);\n}", "repo_id": "8", "comment": "/**\n * Gets the raw type of a Java type, given its context. Primarily for use\n * with {@link TypeVariable}s and {@link GenericArrayType}s, or when you do\n * not know the runtime type of {@code type}: if you know you have a\n * {@link Class} instance, it is already raw; if you know you have a\n * {@link ParameterizedType}, its raw type is only a method call away.\n *\n * @param type to resolve\n * @param assigningType type to be resolved against\n * @return the resolved {@link Class} object or {@code null} if\n * the type could not be resolved\n */\n", "repo_name": "commons-lang-master/", "id": 267, "method_signature": "Class<?> getRawType(Type, Type)", "filename": "TypeUtils.getRawType.json"}
{"callee_method_names": ["Class<?>.isArray", "Class<?>.getComponentType"], "method_name": "TypeUtils.getTypeArguments", "method_implementation": "{\n    if (type instanceof Class<?>) {\n        return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n    }\n    if (type instanceof ParameterizedType) {\n        return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n    }\n    if (type instanceof GenericArrayType) {\n        return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n    }\n    // since wildcard types are not assignable to classes, should this just\n    // return null?\n    if (type instanceof WildcardType) {\n        for (final Type bound : getImplicitUpperBounds((WildcardType) type)) {\n            // find the first bound that is assignable to the target class\n            if (isAssignable(bound, toClass)) {\n                return getTypeArguments(bound, toClass, subtypeVarAssigns);\n            }\n        }\n        return null;\n    }\n    if (type instanceof TypeVariable<?>) {\n        for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n            // find the first bound that is assignable to the target class\n            if (isAssignable(bound, toClass)) {\n                return getTypeArguments(bound, toClass, subtypeVarAssigns);\n            }\n        }\n        return null;\n    }\n    throw new IllegalStateException(\"found an unhandled type: \" + type);\n}", "repo_id": "8", "comment": "/**\n * Gets a map of the type arguments of {@code type} in the context of {@code toClass}.\n *\n * @param type the type in question\n * @param toClass the class\n * @param subtypeVarAssigns a map with type variables\n * @return the {@link Map} with type arguments\n */\n", "repo_name": "commons-lang-master/", "id": 270, "method_signature": "Map<TypeVariable<?>,Type> getTypeArguments(Type, Class, Map)", "filename": "TypeUtils.getTypeArguments.json"}
{"callee_method_names": [], "method_name": "TypeUtils.hashCode", "method_implementation": "{\n    int result = 73 << 8;\n    result |= Arrays.hashCode(upperBounds);\n    result <<= 8;\n    result |= Arrays.hashCode(lowerBounds);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 251, "method_signature": "int hashCode()", "filename": "TypeUtils.hashCode.json"}
{"callee_method_names": ["WildcardType.equals"], "method_name": "TypeUtils.isAssignable", "method_implementation": "{\n    if (type == null) {\n        return true;\n    }\n    // only a null type can be assigned to null type which\n    // would have cause the previous to return true\n    if (toWildcardType == null) {\n        return false;\n    }\n    // all types are assignable to themselves\n    if (toWildcardType.equals(type)) {\n        return true;\n    }\n    final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\n    final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n    if (type instanceof WildcardType) {\n        final WildcardType wildcardType = (WildcardType) type;\n        final Type[] upperBounds = getImplicitUpperBounds(wildcardType);\n        final Type[] lowerBounds = getImplicitLowerBounds(wildcardType);\n        for (Type toBound : toUpperBounds) {\n            // if there are assignments for unresolved type variables,\n            // now's the time to substitute them.\n            toBound = substituteTypeVariables(toBound, typeVarAssigns);\n            // each upper bound of the subject type has to be assignable to\n            // each\n            // upper bound of the target type\n            for (final Type bound : upperBounds) {\n                if (!isAssignable(bound, toBound, typeVarAssigns)) {\n                    return false;\n                }\n            }\n        }\n        for (Type toBound : toLowerBounds) {\n            // if there are assignments for unresolved type variables,\n            // now's the time to substitute them.\n            toBound = substituteTypeVariables(toBound, typeVarAssigns);\n            // each lower bound of the target type has to be assignable to\n            // each\n            // lower bound of the subject type\n            for (final Type bound : lowerBounds) {\n                if (!isAssignable(toBound, bound, typeVarAssigns)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    for (final Type toBound : toUpperBounds) {\n        // if there are assignments for unresolved type variables,\n        // now's the time to substitute them.\n        if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) {\n            return false;\n        }\n    }\n    for (final Type toBound : toLowerBounds) {\n        // if there are assignments for unresolved type variables,\n        // now's the time to substitute them.\n        if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Tests if the subject type may be implicitly cast to the target\n * wildcard type following the Java generics rules.\n *\n * @param type the subject type to be assigned to the target type\n * @param toWildcardType the target wildcard type\n * @param typeVarAssigns a map with type variables\n * @return {@code true} if {@code type} is assignable to\n * {@code toWildcardType}.\n */\n", "repo_name": "commons-lang-master/", "id": 276, "method_signature": "boolean isAssignable(Type, WildcardType, Map)", "filename": "TypeUtils.isAssignable.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "TypeUtils.isInstance", "method_implementation": "{\n    if (type == null) {\n        return false;\n    }\n    return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null);\n}", "repo_id": "8", "comment": "/**\n * Tests if the given value can be assigned to the target type\n * following the Java generics rules.\n *\n * @param value the value to be checked\n * @param type the target type\n * @return {@code true} if {@code value} is an instance of {@code type}.\n */\n", "repo_name": "commons-lang-master/", "id": 277, "method_signature": "boolean isInstance(Object, Type)", "filename": "TypeUtils.isInstance.json"}
{"callee_method_names": ["ParameterizedType.getOwnerType", "ParameterizedType.getActualTypeArguments", "Class<T>.getTypeParameters", "List<TypeVariable<Class<T>>>.contains", "Map<TypeVariable<?>,Type>.containsKey", "Map<TypeVariable<?>,Type>.put", "Map<TypeVariable<?>,Type>.get"], "method_name": "TypeUtils.mapTypeVariablesToArguments", "method_implementation": "{\n    // capture the type variables from the owner type that have assignments\n    final Type ownerType = parameterizedType.getOwnerType();\n    if (ownerType instanceof ParameterizedType) {\n        // recursion to make sure the owner's owner type gets processed\n        mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns);\n    }\n    // parameterizedType is a generic interface/class (or it's in the owner\n    // hierarchy of said interface/class) implemented/extended by the class\n    // cls. Find out which type variables of cls are type arguments of\n    // parameterizedType:\n    final Type[] typeArgs = parameterizedType.getActualTypeArguments();\n    // of the cls's type variables that are arguments of parameterizedType,\n    // find out which ones can be determined from the super type's arguments\n    final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters();\n    // use List view of type parameters of cls so the contains() method can be used:\n    final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters());\n    for (int i = 0; i < typeArgs.length; i++) {\n        final TypeVariable<?> typeVar = typeVars[i];\n        final Type typeArg = typeArgs[i];\n        // argument of parameterizedType is a type variable of cls\n        if (typeVarList.contains(typeArg) && // type variable of parameterizedType has an assignment in\n        // the super type.\n        typeVarAssigns.containsKey(typeVar)) {\n            // map the assignment to the cls's type variable\n            typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar));\n        }\n    }\n}", "repo_id": "8", "comment": "/**\n * Maps type variables.\n *\n * @param <T> the generic type of the class in question\n * @param cls the class in question\n * @param parameterizedType the parameterized type\n * @param typeVarAssigns the map to be filled\n */\n", "repo_name": "commons-lang-master/", "id": 278, "method_signature": "void mapTypeVariablesToArguments(Class, ParameterizedType, Map)", "filename": "TypeUtils.mapTypeVariablesToArguments.json"}
{"callee_method_names": ["Set<Type>.add", "Set<Type>.toArray"], "method_name": "TypeUtils.normalizeUpperBounds", "method_implementation": "{\n    Objects.requireNonNull(bounds, \"bounds\");\n    // don't bother if there's only one (or none) type\n    if (bounds.length < 2) {\n        return bounds;\n    }\n    final Set<Type> types = new HashSet<>(bounds.length);\n    for (final Type type1 : bounds) {\n        boolean subtypeFound = false;\n        for (final Type type2 : bounds) {\n            if (type1 != type2 && isAssignable(type2, type1, null)) {\n                subtypeFound = true;\n                break;\n            }\n        }\n        if (!subtypeFound) {\n            types.add(type1);\n        }\n    }\n    return types.toArray(ArrayUtils.EMPTY_TYPE_ARRAY);\n}", "repo_id": "8", "comment": "/**\n * Strips out the redundant upper bound types in type\n * variable types and wildcard types (or it would with wildcard types if\n * multiple upper bounds were allowed).\n *\n * <p>\n * Example, with the variable type declaration:\n * </p>\n *\n * <pre>&lt;K extends java.util.Collection&lt;String&gt; &amp;\n * java.util.List&lt;String&gt;&gt;</pre>\n *\n * <p>\n * since {@link List} is a subinterface of {@link Collection},\n * this method will return the bounds as if the declaration had been:\n * </p>\n *\n * <pre>&lt;K extends java.util.List&lt;String&gt;&gt;</pre>\n *\n * @param bounds an array of types representing the upper bounds of either\n * {@link WildcardType} or {@link TypeVariable}, not {@code null}.\n * @return an array containing the values from {@code bounds} minus the\n * redundant types.\n * @throws NullPointerException if {@code bounds} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 279, "method_signature": "Type[] normalizeUpperBounds(Type[])", "filename": "TypeUtils.normalizeUpperBounds.json"}
{"callee_method_names": ["Class<?>.getTypeParameters"], "method_name": "TypeUtils.parameterize", "method_implementation": "{\n    Objects.requireNonNull(rawClass, \"rawClass\");\n    Objects.requireNonNull(typeVariableMap, \"typeVariableMap\");\n    return parameterizeWithOwner(null, rawClass, extractTypeArgumentsFrom(typeVariableMap, rawClass.getTypeParameters()));\n}", "repo_id": "8", "comment": "/**\n * Creates a parameterized type instance.\n *\n * @param rawClass the raw class to create a parameterized type instance for\n * @param typeVariableMap the map used for parameterization\n * @return {@link ParameterizedType}\n * @throws NullPointerException if either {@code rawClass} or {@code typeVariableMap} is {@code null}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 280, "method_signature": "ParameterizedType parameterize(Class, Map)", "filename": "TypeUtils.parameterize.json"}
{"callee_method_names": ["Class<?>.getEnclosingClass", "Class<?>.getEnclosingClass", "Class<?>.getEnclosingClass", "Class<?>.getTypeParameters", "Class<?>.getTypeParameters"], "method_name": "TypeUtils.parameterizeWithOwner", "method_implementation": "{\n    Objects.requireNonNull(rawClass, \"rawClass\");\n    final Type useOwner;\n    if (rawClass.getEnclosingClass() == null) {\n        Validate.isTrue(owner == null, \"no owner allowed for top-level %s\", rawClass);\n        useOwner = null;\n    } else if (owner == null) {\n        useOwner = rawClass.getEnclosingClass();\n    } else {\n        Validate.isTrue(isAssignable(owner, rawClass.getEnclosingClass()), \"%s is invalid owner type for parameterized %s\", owner, rawClass);\n        useOwner = owner;\n    }\n    Validate.noNullElements(typeArguments, \"null type argument at index %s\");\n    Validate.isTrue(rawClass.getTypeParameters().length == typeArguments.length, \"invalid number of type parameters specified: expected %d, got %d\", rawClass.getTypeParameters().length, typeArguments.length);\n    return new ParameterizedTypeImpl(rawClass, useOwner, typeArguments);\n}", "repo_id": "8", "comment": "/**\n * Creates a parameterized type instance.\n *\n * @param owner the owning type\n * @param rawClass the raw class to create a parameterized type instance for\n * @param typeArguments the types used for parameterization\n *\n * @return {@link ParameterizedType}\n * @throws NullPointerException if {@code rawClass} is {@code null}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 283, "method_signature": "ParameterizedType parameterizeWithOwner(Type, Class, Type[])", "filename": "TypeUtils.parameterizeWithOwner.json"}
{"callee_method_names": ["ParameterizedType.getOwnerType", "ParameterizedType.getRawType", "StringBuilder.append", "Class<?>.getName", "StringBuilder.append", "StringBuilder.append", "Type.toString", "StringBuilder.append", "Class<?>.getSimpleName", "ParameterizedType.getActualTypeArguments", "StringBuilder.append", "ParameterizedType.getActualTypeArguments", "StringBuilder.toString"], "method_name": "TypeUtils.parameterizedTypeToString", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    final Type useOwner = parameterizedType.getOwnerType();\n    final Class<?> raw = (Class<?>) parameterizedType.getRawType();\n    if (useOwner == null) {\n        builder.append(raw.getName());\n    } else {\n        if (useOwner instanceof Class<?>) {\n            builder.append(((Class<?>) useOwner).getName());\n        } else {\n            builder.append(useOwner.toString());\n        }\n        builder.append('.').append(raw.getSimpleName());\n    }\n    final int[] recursiveTypeIndexes = findRecursiveTypes(parameterizedType);\n    if (recursiveTypeIndexes.length > 0) {\n        appendRecursiveTypes(builder, recursiveTypeIndexes, parameterizedType.getActualTypeArguments());\n    } else {\n        appendAllTo(builder.append('<'), \", \", parameterizedType.getActualTypeArguments()).append('>');\n    }\n    return builder.toString();\n}", "repo_id": "8", "comment": "/**\n * Formats a {@link ParameterizedType} as a {@link String}.\n *\n * @param parameterizedType {@link ParameterizedType} to format\n * @return String\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 281, "method_signature": "String parameterizedTypeToString(ParameterizedType)", "filename": "TypeUtils.parameterizedTypeToString.json"}
{"callee_method_names": ["Map<TypeVariable<?>,Type>.get"], "method_name": "TypeUtils.substituteTypeVariables", "method_implementation": "{\n    if (type instanceof TypeVariable<?> && typeVarAssigns != null) {\n        final Type replacementType = typeVarAssigns.get(type);\n        if (replacementType == null) {\n            throw new IllegalArgumentException(\"missing assignment type for type variable \" + type);\n        }\n        return replacementType;\n    }\n    return type;\n}", "repo_id": "8", "comment": "/**\n * Finds the mapping for {@code type} in {@code typeVarAssigns}.\n *\n * @param type the type to be replaced\n * @param typeVarAssigns the map with type variables\n * @return the replaced type\n * @throws IllegalArgumentException if the type cannot be substituted\n */\n", "repo_name": "commons-lang-master/", "id": 284, "method_signature": "Type substituteTypeVariables(Type, Map)", "filename": "TypeUtils.substituteTypeVariables.json"}
{"callee_method_names": ["TypeVariable<?>.getGenericDeclaration", "Class<?>.getEnclosingClass", "StringBuilder.insert", "Class<?>.getName", "StringBuilder.insert", "Class<?>.getSimpleName", "Class<?>.getEnclosingClass", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "TypeUtils.toLongString", "method_implementation": "{\n    Objects.requireNonNull(typeVariable, \"typeVariable\");\n    final StringBuilder buf = new StringBuilder();\n    final GenericDeclaration d = typeVariable.getGenericDeclaration();\n    if (d instanceof Class<?>) {\n        Class<?> c = (Class<?>) d;\n        while (true) {\n            if (c.getEnclosingClass() == null) {\n                buf.insert(0, c.getName());\n                break;\n            }\n            buf.insert(0, c.getSimpleName()).insert(0, '.');\n            c = c.getEnclosingClass();\n        }\n    } else if (d instanceof Type) {\n        // not possible as of now\n        buf.append(toString((Type) d));\n    } else {\n        buf.append(d);\n    }\n    return buf.append(':').append(typeVariableToString(typeVariable)).toString();\n}", "repo_id": "8", "comment": "/**\n * Formats a {@link TypeVariable} including its {@link GenericDeclaration}.\n *\n * @param typeVariable the type variable to create a String representation for, not {@code null}\n * @return String\n * @throws NullPointerException if {@code typeVariable} is {@code null}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 285, "method_signature": "String toLongString(TypeVariable)", "filename": "TypeUtils.toLongString.json"}
{"callee_method_names": [], "method_name": "TypeUtils.toString", "method_implementation": "{\n    Objects.requireNonNull(type, \"type\");\n    if (type instanceof Class<?>) {\n        return classToString((Class<?>) type);\n    }\n    if (type instanceof ParameterizedType) {\n        return parameterizedTypeToString((ParameterizedType) type);\n    }\n    if (type instanceof WildcardType) {\n        return wildcardTypeToString((WildcardType) type);\n    }\n    if (type instanceof TypeVariable<?>) {\n        return typeVariableToString((TypeVariable<?>) type);\n    }\n    if (type instanceof GenericArrayType) {\n        return genericArrayTypeToString((GenericArrayType) type);\n    }\n    throw new IllegalArgumentException(ObjectUtils.identityToString(type));\n}", "repo_id": "8", "comment": "/**\n * Formats a given type as a Java-esque String.\n *\n * @param type the type to create a String representation for, not {@code null}\n * @return String\n * @throws NullPointerException if {@code type} is {@code null}\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 286, "method_signature": "String toString(Type)", "filename": "TypeUtils.toString.json"}
{"callee_method_names": ["TypeVariable<?>.getName", "TypeVariable<?>.getBounds", "StringBuilder.append", "TypeVariable<?>.getBounds", "StringBuilder.toString"], "method_name": "TypeUtils.typeVariableToString", "method_implementation": "{\n    final StringBuilder buf = new StringBuilder(typeVariable.getName());\n    final Type[] bounds = typeVariable.getBounds();\n    if (bounds.length > 0 && !(bounds.length == 1 && Object.class.equals(bounds[0]))) {\n        buf.append(\" extends \");\n        appendAllTo(buf, \" & \", typeVariable.getBounds());\n    }\n    return buf.toString();\n}", "repo_id": "8", "comment": "/**\n * Formats a {@link TypeVariable} as a {@link String}.\n *\n * @param typeVariable {@link TypeVariable} to format\n * @return String\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 288, "method_signature": "String typeVariableToString(TypeVariable)", "filename": "TypeUtils.typeVariableToString.json"}
{"callee_method_names": ["Map<TypeVariable<?>,Type>.entrySet"], "method_name": "TypeUtils.typesSatisfyVariables", "method_implementation": "{\n    Objects.requireNonNull(typeVariableMap, \"typeVariableMap\");\n    // all types must be assignable to all the bounds of their mapped\n    // type variable.\n    for (final Map.Entry<TypeVariable<?>, Type> entry : typeVariableMap.entrySet()) {\n        final TypeVariable<?> typeVar = entry.getKey();\n        final Type type = entry.getValue();\n        for (final Type bound : getImplicitBounds(typeVar)) {\n            if (!isAssignable(type, substituteTypeVariables(bound, typeVariableMap), typeVariableMap)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Determines whether or not specified types satisfy the bounds of their\n * mapped type variables. When a type parameter extends another (such as\n * {@code <T, S extends T>}), uses another as a type parameter (such as\n * {@code <T, S extends Comparable>>}), or otherwise depends on\n * another type variable to be specified, the dependencies must be included\n * in {@code typeVarAssigns}.\n *\n * @param typeVariableMap specifies the potential types to be assigned to the\n * type variables, not {@code null}.\n * @return whether or not the types can be assigned to their respective type\n * variables.\n * @throws NullPointerException if {@code typeVariableMap} is {@code null}\n */\n", "repo_name": "commons-lang-master/", "id": 287, "method_signature": "boolean typesSatisfyVariables(Map)", "filename": "TypeUtils.typesSatisfyVariables.json"}
{"callee_method_names": [], "method_name": "TypeUtils.unrollBounds", "method_implementation": "{\n    Type[] result = bounds;\n    int i = 0;\n    for (; i < result.length; i++) {\n        final Type unrolled = unrollVariables(typeArguments, result[i]);\n        if (unrolled == null) {\n            result = ArrayUtils.remove(result, i--);\n        } else {\n            result[i] = unrolled;\n        }\n    }\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Unrolls variables in a type bounds array.\n *\n * @param typeArguments assignments {@link Map}\n * @param bounds in which to expand variables\n * @return {@code bounds} with any variables reassigned\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 289, "method_signature": "Type[] unrollBounds(Map, Type[])", "filename": "TypeUtils.unrollBounds.json"}
{"callee_method_names": ["Map<TypeVariable<?>,Type>.get", "Type.equals"], "method_name": "TypeUtils.unrollVariableAssignments", "method_implementation": "{\n    Type result;\n    do {\n        result = typeVarAssigns.get(typeVariable);\n        if (!(result instanceof TypeVariable<?>) || result.equals(typeVariable)) {\n            break;\n        }\n        typeVariable = (TypeVariable<?>) result;\n    } while (true);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * Looks up {@code typeVariable} in {@code typeVarAssigns} <em>transitively</em>, i.e. keep looking until the value\n * found is <em>not</em> a type variable.\n *\n * @param typeVariable the type variable to look up\n * @param typeVarAssigns the map used for the look-up\n * @return Type or {@code null} if some variable was not in the map\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 290, "method_signature": "Type unrollVariableAssignments(TypeVariable, Map)", "filename": "TypeUtils.unrollVariableAssignments.json"}
{"callee_method_names": ["Map<TypeVariable<?>,Type>.get", "ParameterizedType.getOwnerType", "Map<TypeVariable<?>, Type>.putAll", "ParameterizedType.getActualTypeArguments", "ParameterizedType.getOwnerType", "ParameterizedType.getRawType", "WildcardType.getUpperBounds", "WildcardType.getLowerBounds"], "method_name": "TypeUtils.unrollVariables", "method_implementation": "{\n    if (typeArguments == null) {\n        typeArguments = Collections.emptyMap();\n    }\n    if (containsTypeVariables(type)) {\n        if (type instanceof TypeVariable<?>) {\n            return unrollVariables(typeArguments, typeArguments.get(type));\n        }\n        if (type instanceof ParameterizedType) {\n            final ParameterizedType p = (ParameterizedType) type;\n            final Map<TypeVariable<?>, Type> parameterizedTypeArguments;\n            if (p.getOwnerType() == null) {\n                parameterizedTypeArguments = typeArguments;\n            } else {\n                parameterizedTypeArguments = new HashMap<>(typeArguments);\n                parameterizedTypeArguments.putAll(getTypeArguments(p));\n            }\n            final Type[] args = p.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                final Type unrolled = unrollVariables(parameterizedTypeArguments, args[i]);\n                if (unrolled != null) {\n                    args[i] = unrolled;\n                }\n            }\n            return parameterizeWithOwner(p.getOwnerType(), (Class<?>) p.getRawType(), args);\n        }\n        if (type instanceof WildcardType) {\n            final WildcardType wild = (WildcardType) type;\n            return wildcardType().withUpperBounds(unrollBounds(typeArguments, wild.getUpperBounds())).withLowerBounds(unrollBounds(typeArguments, wild.getLowerBounds())).build();\n        }\n    }\n    return type;\n}", "repo_id": "8", "comment": "/**\n * Gets a type representing {@code type} with variable assignments \"unrolled.\"\n *\n * @param typeArguments as from {@link TypeUtils#getTypeArguments(Type, Class)}\n * @param type the type to unroll variable assignments for\n * @return Type\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 291, "method_signature": "Type unrollVariables(Map, Type)", "filename": "TypeUtils.unrollVariables.json"}
{"callee_method_names": ["WildcardType.getLowerBounds", "WildcardType.getUpperBounds", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "TypeUtils.wildcardTypeToString", "method_implementation": "{\n    final StringBuilder buf = new StringBuilder().append('?');\n    final Type[] lowerBounds = wildcardType.getLowerBounds();\n    final Type[] upperBounds = wildcardType.getUpperBounds();\n    if (lowerBounds.length > 1 || lowerBounds.length == 1 && lowerBounds[0] != null) {\n        appendAllTo(buf.append(\" super \"), \" & \", lowerBounds);\n    } else if (upperBounds.length > 1 || upperBounds.length == 1 && !Object.class.equals(upperBounds[0])) {\n        appendAllTo(buf.append(\" extends \"), \" & \", upperBounds);\n    }\n    return buf.toString();\n}", "repo_id": "8", "comment": "/**\n * Formats a {@link WildcardType} as a {@link String}.\n *\n * @param wildcardType {@link WildcardType} to format\n * @return String\n * @since 3.2\n */\n", "repo_name": "commons-lang-master/", "id": 292, "method_signature": "String wildcardTypeToString(WildcardType)", "filename": "TypeUtils.wildcardTypeToString.json"}
{"callee_method_names": [], "method_name": "TypeUtilsTest.testGetRawType_LANG_1697", "method_implementation": "{\n    assertEquals(int[].class, TypeUtils.getRawType(TypeUtils.genericArrayType(Integer.TYPE), Integer.TYPE));\n    // LANG-1697:\n    assertNull(TypeUtils.getRawType(TypeUtils.genericArrayType(TypeUtils.WILDCARD_ALL), null));\n    // TODO: Is this correct?\n    assertNull(TypeUtils.getRawType(TypeUtils.genericArrayType(TypeUtils.WILDCARD_ALL), TypeUtils.WILDCARD_ALL));\n    // TODO: Is this correct?\n    assertNull(TypeUtils.getRawType(TypeUtils.genericArrayType(TypeUtils.WILDCARD_ALL), Integer.TYPE));\n}", "repo_id": "8", "comment": "/**\n * Tests https://issues.apache.org/jira/browse/LANG-1697\n */\n", "repo_name": "commons-lang-master/", "id": 1700, "method_signature": "void testGetRawType_LANG_1697()", "filename": "TypeUtilsTest.testGetRawType_LANG_1697.json"}
{"callee_method_names": ["int.getName", "ParameterizedType.getRawType", "ParameterizedType.getActualTypeArguments"], "method_name": "TypeUtilsTest.test_LANG_1698", "method_implementation": "{\n    // SO on Java 17\n    assumeTrue(SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_16));\n    final ParameterizedType comparing = (ParameterizedType) Arrays.stream(Comparator.class.getDeclaredMethods()).filter(k -> k.getName().equals(\"comparing\")).findFirst().orElse(Comparator.class.getDeclaredMethods()[0]).getGenericParameterTypes()[0];\n    final String typeName = TypeUtils.parameterize((Class<?>) comparing.getRawType(), comparing.getActualTypeArguments()).getTypeName();\n    assertEquals(\"java.util.function.Function<? super T, ? extends U>\", typeName);\n}", "repo_id": "8", "comment": "/**\n * <pre>{@code\n * java.lang.StackOverflowError\n *    at org.apache.commons.lang3.reflect.TypeUtils.typeVariableToString(TypeUtils.java:1785)\n *    at org.apache.commons.lang3.reflect.TypeUtils.toString(TypeUtils.java:1737)\n *    at org.apache.commons.lang3.reflect.TypeUtils.toString(TypeUtils.java:1714)\n *    at org.apache.commons.lang3.reflect.TypeUtils.appendAllTo(TypeUtils.java:302)\n *    at org.apache.commons.lang3.reflect.TypeUtils.wildcardTypeToString(TypeUtils.java:1902)\n *    at org.apache.commons.lang3.reflect.TypeUtils.toString(TypeUtils.java:1734)\n *    at org.apache.commons.lang3.reflect.TypeUtils.toString(TypeUtils.java:1714)\n *    at org.apache.commons.lang3.reflect.TypeUtils.appendAllTo(TypeUtils.java:302)\n *    at org.apache.commons.lang3.reflect.TypeUtils.parameterizedTypeToString(TypeUtils.java:1604)\n *    at org.apache.commons.lang3.reflect.TypeUtils.toString(TypeUtils.java:1731)\n *    at org.apache.commons.lang3.reflect.TypeUtils.toString(TypeUtils.java:1714)\n *    at org.apache.commons.lang3.reflect.TypeUtils.appendAllTo(TypeUtils.java:302)\n *    at org.apache.commons.lang3.reflect.TypeUtils.typeVariableToString(TypeUtils.java:1789)\n * }\n * </pre>\n */\n", "repo_name": "commons-lang-master/", "id": 1699, "method_signature": "void test_LANG_1698()", "filename": "TypeUtilsTest.test_LANG_1698.json"}
{"callee_method_names": ["Writer.write", "Writer.write", "Writer.write", "Writer.write", "Writer.write", "Writer.write"], "method_name": "UnicodeEscaper.translate", "method_implementation": "{\n    if (between) {\n        if (codePoint < below || codePoint > above) {\n            return false;\n        }\n    } else if (codePoint >= below && codePoint <= above) {\n        return false;\n    }\n    // TODO: Handle potential + sign per various Unicode escape implementations\n    if (codePoint > 0xffff) {\n        out.write(toUtf16Escape(codePoint));\n    } else {\n        out.write(\"\\\\u\");\n        out.write(HEX_DIGITS[(codePoint >> 12) & 15]);\n        out.write(HEX_DIGITS[(codePoint >> 8) & 15]);\n        out.write(HEX_DIGITS[(codePoint >> 4) & 15]);\n        out.write(HEX_DIGITS[(codePoint) & 15]);\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 434, "method_signature": "boolean translate(int, Writer)", "filename": "UnicodeEscaper.translate.json"}
{"callee_method_names": ["CharSequence.charAt", "CharSequence.length", "CharSequence.charAt", "CharSequence.length", "CharSequence.charAt", "CharSequence.length", "CharSequence.charAt", "CharSequence.length", "CharSequence.subSequence", "CharSequence.toString", "Writer.write", "CharSequence.subSequence", "CharSequence.length"], "method_name": "UnicodeUnescaper.translate", "method_implementation": "{\n    if (input.charAt(index) == '\\\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {\n        // consume optional additional 'u' chars\n        int i = 2;\n        while (index + i < input.length() && input.charAt(index + i) == 'u') {\n            i++;\n        }\n        if (index + i < input.length() && input.charAt(index + i) == '+') {\n            i++;\n        }\n        if (index + i + 4 <= input.length()) {\n            // Get 4 hex digits\n            final CharSequence unicode = input.subSequence(index + i, index + i + 4);\n            try {\n                final int value = Integer.parseInt(unicode.toString(), 16);\n                out.write((char) value);\n            } catch (final NumberFormatException nfe) {\n                throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n            }\n            return i + 4;\n        }\n        throw new IllegalArgumentException(\"Less than 4 hex digits in unicode value: '\" + input.subSequence(index, input.length()) + \"' due to end of CharSequence\");\n    }\n    return 0;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 427, "method_signature": "int translate(CharSequence, int, Writer)", "filename": "UnicodeUnescaper.translate.json"}
{"callee_method_ids": [427], "callee_method_names": ["UnicodeUnescaper.translate"], "method_name": "UnicodeUnescaperTest.testUPlus", "method_implementation": "{\n    final UnicodeUnescaper uu = new UnicodeUnescaper();\n    final String input = \"\\\\u+0047\";\n    assertEquals(\"G\", uu.translate(input), \"Failed to unescape Unicode characters with 'u+' notation\");\n}", "repo_id": "8", "comment": "// Requested in LANG-507\n", "repo_name": "commons-lang-master/", "id": 1745, "method_signature": "void testUPlus()", "filename": "UnicodeUnescaperTest.testUPlus.json"}
{"callee_method_names": [], "method_name": "UnicodeUnpairedSurrogateRemover.translate", "method_implementation": "{\n    // true: It's a surrogate. Write nothing and say we've translated.\n    return codePoint >= Character.MIN_SURROGATE && codePoint <= Character.MAX_SURROGATE;\n    // It's not a surrogate. Don't translate it.\n}", "repo_id": "8", "comment": "/**\n * Implementation of translate that throws out unpaired surrogates.\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 431, "method_signature": "boolean translate(int, Writer)", "filename": "UnicodeUnpairedSurrogateRemover.translate.json"}
{"callee_method_names": ["Appendable.append"], "method_name": "UnpaddedMonthField.appendTo", "method_implementation": "{\n    if (value < 10) {\n        buffer.append((char) (value + '0'));\n    } else {\n        appendDigits(buffer, value);\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 684, "method_signature": "void appendTo(Appendable, int)", "filename": "UnpaddedMonthField.appendTo.json"}
{"callee_method_names": ["Appendable.append"], "method_name": "UnpaddedNumberField.appendTo", "method_implementation": "{\n    if (value < 10) {\n        buffer.append((char) (value + '0'));\n    } else if (value < 100) {\n        appendDigits(buffer, value);\n    } else {\n        appendFullDigits(buffer, value, 1);\n    }\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 685, "method_signature": "void appendTo(Appendable, int)", "filename": "UnpaddedNumberField.appendTo.json"}
{"callee_method_names": ["Comparable<T>.compareTo", "Comparable<T>.compareTo"], "method_name": "Validate.exclusiveBetween", "method_implementation": "{\n    // TODO when breaking BC, consider returning value\n    if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validate that the specified argument object fall between the two\n * exclusive values specified; otherwise, throws an exception with the\n * specified message.\n *\n * <pre>Validate.exclusiveBetween(0, 2, 1, \"Not in boundaries\");</pre>\n *\n * @param <T> the type of the argument object\n * @param start  the exclusive start value, not null\n * @param end  the exclusive end value, not null\n * @param value  the object to validate, not null\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @see #exclusiveBetween(Object, Object, Comparable)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 43, "method_signature": "void exclusiveBetween(T, T, Comparable, String, Object[])", "filename": "Validate.exclusiveBetween.json"}
{"callee_method_names": [], "method_name": "Validate.finite", "method_implementation": "{\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validates that the specified argument is not infinite or Not-a-Number (NaN);\n * otherwise throwing an exception with the specified message.\n *\n * <pre>Validate.finite(myDouble, \"The argument must contain a numeric value\");</pre>\n *\n * @param value the value to validate\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if the value is infinite or Not-a-Number (NaN)\n * @see #finite(double)\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 44, "method_signature": "void finite(double, String, Object[])", "filename": "Validate.finite.json"}
{"callee_method_names": ["Comparable<T>.compareTo", "Comparable<T>.compareTo"], "method_name": "Validate.inclusiveBetween", "method_implementation": "{\n    // TODO when breaking BC, consider returning value\n    if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validate that the specified argument object fall between the two\n * inclusive values specified; otherwise, throws an exception with the\n * specified message.\n *\n * <pre>Validate.inclusiveBetween(0, 2, 1, \"Not in boundaries\");</pre>\n *\n * @param <T> the type of the argument object\n * @param start  the inclusive start value, not null\n * @param end  the inclusive end value, not null\n * @param value  the object to validate, not null\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if the value falls outside the boundaries\n * @see #inclusiveBetween(Object, Object, Comparable)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 50, "method_signature": "void inclusiveBetween(T, T, Comparable, String, Object[])", "filename": "Validate.inclusiveBetween.json"}
{"callee_method_names": ["Class<?>.isAssignableFrom"], "method_name": "Validate.isAssignableFrom", "method_implementation": "{\n    // TODO when breaking BC, consider returning type\n    if (!superType.isAssignableFrom(type)) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validates that the argument can be converted to the specified class, if not throws an exception.\n *\n * <p>This method is useful when validating if there will be no casting errors.</p>\n *\n * <pre>Validate.isAssignableFrom(SuperClass.class, object.getClass());</pre>\n *\n * <p>The message of the exception is &quot;The validated object can not be converted to the&quot;\n * followed by the name of the class and &quot;class&quot;</p>\n *\n * @param superType  the class must be validated against, not null\n * @param type  the class to check, not null\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if argument can not be converted to the specified class\n * @see #isAssignableFrom(Class, Class)\n */\n", "repo_name": "commons-lang-master/", "id": 52, "method_signature": "void isAssignableFrom(Class, Class, String, Object[])", "filename": "Validate.isAssignableFrom.json"}
{"callee_method_names": ["Class<?>.isInstance"], "method_name": "Validate.isInstanceOf", "method_implementation": "{\n    // TODO when breaking BC, consider returning obj\n    if (!type.isInstance(obj)) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validate that the argument is an instance of the specified class; otherwise\n * throwing an exception with the specified message. This method is useful when\n * validating according to an arbitrary class\n *\n * <pre>Validate.isInstanceOf(OkClass.class, object, \"Wrong class, object is of class %s\",\n *   object.getClass().getName());</pre>\n *\n * @param type  the class the object must be validated against, not null\n * @param obj  the object to check, null throws an exception\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if argument is not of specified class\n * @see #isInstanceOf(Class, Object)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 54, "method_signature": "void isInstanceOf(Class, Object, String, Object[])", "filename": "Validate.isInstanceOf.json"}
{"callee_method_names": [], "method_name": "Validate.isTrue", "method_implementation": "{\n    if (!expression) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validate that the argument condition is {@code true}; otherwise\n * throwing an exception with the specified message. This method is useful when\n * validating according to an arbitrary boolean expression, such as validating a\n * primitive number or using your own custom validation expression.\n *\n * <pre>\n * Validate.isTrue(i &gt;= min &amp;&amp; i &lt;= max, \"The value must be between &#37;d and &#37;d\", min, max);</pre>\n *\n * @param expression  the boolean expression to check\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if expression is {@code false}\n * @see #isTrue(boolean)\n * @see #isTrue(boolean, String, long)\n * @see #isTrue(boolean, String, double)\n */\n", "repo_name": "commons-lang-master/", "id": 58, "method_signature": "void isTrue(boolean, String, Object[])", "filename": "Validate.isTrue.json"}
{"callee_method_names": [], "method_name": "Validate.matchesPattern", "method_implementation": "{\n    // TODO when breaking BC, consider returning input\n    if (!Pattern.matches(pattern, input)) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validate that the specified argument character sequence matches the specified regular\n * expression pattern; otherwise throwing an exception with the specified message.\n *\n * <pre>Validate.matchesPattern(\"hi\", \"[a-z]*\", \"%s does not match %s\", \"hi\" \"[a-z]*\");</pre>\n *\n * <p>The syntax of the pattern is the one used in the {@link Pattern} class.</p>\n *\n * @param input  the character sequence to validate, not null\n * @param pattern  the regular expression pattern, not null\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalArgumentException if the character sequence does not match the pattern\n * @see #matchesPattern(CharSequence, String)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 60, "method_signature": "void matchesPattern(CharSequence, String, String, Object[])", "filename": "Validate.matchesPattern.json"}
{"callee_method_names": [], "method_name": "Validate.noNullElements", "method_implementation": "{\n    Objects.requireNonNull(array, \"array\");\n    for (int i = 0; i < array.length; i++) {\n        if (array[i] == null) {\n            final Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));\n            throw new IllegalArgumentException(getMessage(message, values2));\n        }\n    }\n    return array;\n}", "repo_id": "8", "comment": "/**\n * Validate that the specified argument array is neither\n * {@code null} nor contains any elements that are {@code null};\n * otherwise throwing an exception with the specified message.\n *\n * <pre>Validate.noNullElements(myArray, \"The array contain null at position %d\");</pre>\n *\n * <p>If the array is {@code null}, then the message in the exception\n * is &quot;The validated object is null&quot;.\n *\n * <p>If the array has a {@code null} element, then the iteration\n * index of the invalid element is appended to the {@code values}\n * argument.</p>\n *\n * @param <T> the array type\n * @param array  the array to check, validated not null by this method\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated array (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if an element is {@code null}\n * @see #noNullElements(Object[])\n */\n", "repo_name": "commons-lang-master/", "id": 62, "method_signature": "T[] noNullElements(T[], String, Object[])", "filename": "Validate.noNullElements.json"}
{"callee_method_names": [], "method_name": "Validate.notBlank", "method_implementation": "{\n    Objects.requireNonNull(chars, toSupplier(message, values));\n    if (StringUtils.isBlank(chars)) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n    return chars;\n}", "repo_id": "8", "comment": "/**\n * Validate that the specified argument character sequence is\n * neither {@code null}, a length of zero (no characters), empty\n * nor whitespace; otherwise throwing an exception with the specified\n * message.\n *\n * <pre>Validate.notBlank(myString, \"The string must not be blank\");</pre>\n *\n * @param <T> the character sequence type\n * @param chars  the character sequence to check, validated not null by this method\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated character sequence (never {@code null} method for chaining)\n * @throws NullPointerException if the character sequence is {@code null}\n * @throws IllegalArgumentException if the character sequence is blank\n * @see #notBlank(CharSequence)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 63, "method_signature": "T notBlank(T, String, Object[])", "filename": "Validate.notBlank.json"}
{"callee_method_names": [], "method_name": "Validate.notEmpty", "method_implementation": "{\n    Objects.requireNonNull(array, toSupplier(message, values));\n    if (array.length == 0) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n    return array;\n}", "repo_id": "8", "comment": "/**\n * <p>Validate that the specified argument array is neither {@code null}\n * nor a length of zero (no elements); otherwise throwing an exception\n * with the specified message.\n *\n * <pre>Validate.notEmpty(myArray, \"The array must not be empty\");</pre>\n *\n * @param <T> the array type\n * @param array  the array to check, validated not null by this method\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated array (never {@code null} method for chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IllegalArgumentException if the array is empty\n * @see #notEmpty(Object[])\n */\n", "repo_name": "commons-lang-master/", "id": 67, "method_signature": "T[] notEmpty(T[], String, Object[])", "filename": "Validate.notEmpty.json"}
{"callee_method_names": [], "method_name": "Validate.notNaN", "method_implementation": "{\n    if (Double.isNaN(value)) {\n        throw new IllegalArgumentException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validates that the specified argument is not Not-a-Number (NaN); otherwise\n * throwing an exception with the specified message.\n *\n * <pre>Validate.notNaN(myDouble, \"The value must be a number\");</pre>\n *\n * @param value  the value to validate\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message\n * @throws IllegalArgumentException if the value is not a number\n * @see #notNaN(double)\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 68, "method_signature": "void notNaN(double, String, Object[])", "filename": "Validate.notNaN.json"}
{"callee_method_names": [], "method_name": "Validate.validIndex", "method_implementation": "{\n    Objects.requireNonNull(array, \"array\");\n    if (index < 0 || index >= array.length) {\n        throw new IndexOutOfBoundsException(getMessage(message, values));\n    }\n    return array;\n}", "repo_id": "8", "comment": "/**\n * Validates that the index is within the bounds of the argument\n * array; otherwise throwing an exception with the specified message.\n *\n * <pre>Validate.validIndex(myArray, 2, \"The array index is invalid: \");</pre>\n *\n * <p>If the array is {@code null}, then the message of the exception\n * is &quot;The validated object is null&quot;.</p>\n *\n * @param <T> the array type\n * @param array  the array to check, validated not null by this method\n * @param index  the index to check\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @return the validated array (never {@code null} for method chaining)\n * @throws NullPointerException if the array is {@code null}\n * @throws IndexOutOfBoundsException if the index is invalid\n * @see #validIndex(Object[], int)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 71, "method_signature": "T[] validIndex(T[], int, String, Object[])", "filename": "Validate.validIndex.json"}
{"callee_method_names": [], "method_name": "Validate.validState", "method_implementation": "{\n    if (!expression) {\n        throw new IllegalStateException(getMessage(message, values));\n    }\n}", "repo_id": "8", "comment": "/**\n * Validate that the stateful condition is {@code true}; otherwise\n * throwing an exception with the specified message. This method is useful when\n * validating according to an arbitrary boolean expression, such as validating a\n * primitive number or using your own custom validation expression.\n *\n * <pre>Validate.validState(this.isOk(), \"The state is not OK: %s\", myObject);</pre>\n *\n * @param expression  the boolean expression to check\n * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null\n * @param values  the optional values for the formatted exception message, null array not recommended\n * @throws IllegalStateException if expression is {@code false}\n * @see #validState(boolean)\n * @since 3.0\n */\n", "repo_name": "commons-lang-master/", "id": 73, "method_signature": "void validState(boolean, String, Object[])", "filename": "Validate.validState.json"}
{"callee_method_names": [], "method_name": "WildcardTypeImpl.hashCode", "method_implementation": "{\n    int result = 73 << 8;\n    result |= Arrays.hashCode(upperBounds);\n    result <<= 8;\n    result |= Arrays.hashCode(lowerBounds);\n    return result;\n}", "repo_id": "8", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "commons-lang-master/", "id": 295, "method_signature": "int hashCode()", "filename": "WildcardTypeImpl.hashCode.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "WordUtils.capitalize", "method_implementation": "{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}", "repo_id": "8", "comment": "/**\n * Capitalizes all the delimiter separated words in a String.\n * Only the first character of each word is changed. To convert the\n * rest of each word to lowercase at the same time,\n * use {@link #capitalizeFully(String, char[])}.\n *\n * <p>The delimiters represent a set of characters understood to separate words.\n * The first string character and the first non-delimiter character after a\n * delimiter will be capitalized.</p>\n *\n * <p>A {@code null} input String returns {@code null}.\n * Capitalization uses the Unicode title case, normally equivalent to\n * upper case.</p>\n *\n * <pre>\n * WordUtils.capitalize(null, *)            = null\n * WordUtils.capitalize(\"\", *)              = \"\"\n * WordUtils.capitalize(*, new char[0])     = *\n * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n * </pre>\n *\n * @param str  the String to capitalize, may be null\n * @param delimiters  set of characters to determine capitalization, null means whitespace\n * @return capitalized String, {@code null} if null String input\n * @see #uncapitalize(String)\n * @see #capitalizeFully(String)\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 371, "method_signature": "String capitalize(String, char[])", "filename": "WordUtils.capitalize.json"}
{"callee_method_names": ["String.toLowerCase"], "method_name": "WordUtils.capitalizeFully", "method_implementation": "{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    return capitalize(str.toLowerCase(), delimiters);\n}", "repo_id": "8", "comment": "/**\n * Converts all the delimiter separated words in a String into capitalized words,\n * that is each word is made up of a titlecase character and then a series of\n * lowercase characters.\n *\n * <p>The delimiters represent a set of characters understood to separate words.\n * The first string character and the first non-delimiter character after a\n * delimiter will be capitalized.</p>\n *\n * <p>A {@code null} input String returns {@code null}.\n * Capitalization uses the Unicode title case, normally equivalent to\n * upper case.</p>\n *\n * <pre>\n * WordUtils.capitalizeFully(null, *)            = null\n * WordUtils.capitalizeFully(\"\", *)              = \"\"\n * WordUtils.capitalizeFully(*, null)            = *\n * WordUtils.capitalizeFully(*, new char[0])     = *\n * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n * </pre>\n *\n * @param str  the String to capitalize, may be null\n * @param delimiters  set of characters to determine capitalization, null means whitespace\n * @return capitalized String, {@code null} if null String input\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 372, "method_signature": "String capitalizeFully(String, char[])", "filename": "WordUtils.capitalizeFully.json"}
{"callee_method_names": ["Pattern.matcher"], "method_name": "WordUtils.containsAllWords", "method_implementation": "{\n    if (StringUtils.isEmpty(word) || ArrayUtils.isEmpty(words)) {\n        return false;\n    }\n    for (final CharSequence w : words) {\n        if (StringUtils.isBlank(w)) {\n            return false;\n        }\n        final Pattern p = Pattern.compile(\".*\\\\b\" + w + \"\\\\b.*\");\n        if (!p.matcher(word).matches()) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "8", "comment": "/**\n * Checks if the String contains all words in the given array.\n *\n * <p>\n * A {@code null} String will return {@code false}. A {@code null}, zero\n * length search array or if one element of array is null will return {@code false}.\n * </p>\n *\n * <pre>\n * WordUtils.containsAllWords(null, *)            = false\n * WordUtils.containsAllWords(\"\", *)              = false\n * WordUtils.containsAllWords(*, null)            = false\n * WordUtils.containsAllWords(*, [])              = false\n * WordUtils.containsAllWords(\"abcd\", \"ab\", \"cd\") = false\n * WordUtils.containsAllWords(\"abc def\", \"def\", \"abc\") = true\n * </pre>\n *\n * @param word The CharSequence to check, may be null\n * @param words The array of String words to search for, may be null\n * @return {@code true} if all search words are found, {@code false} otherwise\n * @since 3.5\n */\n", "repo_name": "commons-lang-master/", "id": 373, "method_signature": "boolean containsAllWords(CharSequence, CharSequence[])", "filename": "WordUtils.containsAllWords.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "WordUtils.initials", "method_implementation": "{\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return StringUtils.EMPTY;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n            continue;\n        }\n    }\n    return new String(buf, 0, count);\n}", "repo_id": "8", "comment": "/**\n * Extracts the initial characters from each word in the String.\n *\n * <p>All first characters after the defined delimiters are returned as a new string.\n * Their case is not changed.</p>\n *\n * <p>If the delimiters array is null, then Whitespace is used.\n * Whitespace is defined by {@link Character#isWhitespace(char)}.\n * A {@code null} input String returns {@code null}.\n * An empty delimiter array returns an empty String.</p>\n *\n * <pre>\n * WordUtils.initials(null, *)                = null\n * WordUtils.initials(\"\", *)                  = \"\"\n * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n * WordUtils.initials(*, new char[0])         = \"\"\n * </pre>\n *\n * @param str  the String to get initials from, may be null\n * @param delimiters  set of characters to determine words, null means whitespace\n * @return String of initial characters, {@code null} if null String input\n * @see #initials(String)\n * @since 2.2\n */\n", "repo_name": "commons-lang-master/", "id": 374, "method_signature": "String initials(String, char[])", "filename": "WordUtils.initials.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "WordUtils.swapCase", "method_implementation": "{\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch) || Character.isTitleCase(ch)) {\n            buffer[i] = Character.toLowerCase(ch);\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace) {\n                buffer[i] = Character.toTitleCase(ch);\n                whitespace = false;\n            } else {\n                buffer[i] = Character.toUpperCase(ch);\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return new String(buffer);\n}", "repo_id": "8", "comment": "/**\n * Swaps the case of a String using a word based algorithm.\n *\n * <ul>\n *  <li>Upper case character converts to Lower case</li>\n *  <li>Title case character converts to Lower case</li>\n *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n *  <li>Other Lower case character converts to Upper case</li>\n * </ul>\n *\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n * A {@code null} input String returns {@code null}.</p>\n *\n * <pre>\n * StringUtils.swapCase(null)                 = null\n * StringUtils.swapCase(\"\")                   = \"\"\n * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n * </pre>\n *\n * @param str  the String to swap case, may be null\n * @return the changed String, {@code null} if null String input\n */\n", "repo_name": "commons-lang-master/", "id": 375, "method_signature": "String swapCase(String)", "filename": "WordUtils.swapCase.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "WordUtils.uncapitalize", "method_implementation": "{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}", "repo_id": "8", "comment": "/**\n * Uncapitalizes all the whitespace separated words in a String.\n * Only the first character of each word is changed.\n *\n * <p>The delimiters represent a set of characters understood to separate words.\n * The first string character and the first non-delimiter character after a\n * delimiter will be uncapitalized.</p>\n *\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n * A {@code null} input String returns {@code null}.</p>\n *\n * <pre>\n * WordUtils.uncapitalize(null, *)            = null\n * WordUtils.uncapitalize(\"\", *)              = \"\"\n * WordUtils.uncapitalize(*, null)            = *\n * WordUtils.uncapitalize(*, new char[0])     = *\n * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n * </pre>\n *\n * @param str  the String to uncapitalize, may be null\n * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n * @return uncapitalized String, {@code null} if null String input\n * @see #capitalize(String)\n * @since 2.1\n */\n", "repo_name": "commons-lang-master/", "id": 376, "method_signature": "String uncapitalize(String, char[])", "filename": "WordUtils.uncapitalize.json"}
{"callee_method_names": ["String.length", "Pattern.matcher", "String.substring", "Matcher.find", "Matcher.start", "Matcher.end", "Matcher.start", "Matcher.find", "Matcher.start", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Pattern.matcher", "String.substring", "Matcher.find", "Matcher.start", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "String.length", "StringBuilder.append", "String.length", "StringBuilder.toString"], "method_name": "WordUtils.wrap", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    if (newLineStr == null) {\n        newLineStr = System.lineSeparator();\n    }\n    if (wrapLength < 1) {\n        wrapLength = 1;\n    }\n    if (StringUtils.isBlank(wrapOn)) {\n        wrapOn = \" \";\n    }\n    final Pattern patternToWrapOn = Pattern.compile(wrapOn);\n    final int inputLineLength = str.length();\n    int offset = 0;\n    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n    while (offset < inputLineLength) {\n        int spaceToWrapAt = -1;\n        Matcher matcher = patternToWrapOn.matcher(str.substring(offset, Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n        if (matcher.find()) {\n            if (matcher.start() == 0) {\n                offset += matcher.end();\n                continue;\n            }\n            spaceToWrapAt = matcher.start() + offset;\n        }\n        // only last line without leading spaces is left\n        if (inputLineLength - offset <= wrapLength) {\n            break;\n        }\n        while (matcher.find()) {\n            spaceToWrapAt = matcher.start() + offset;\n        }\n        if (spaceToWrapAt >= offset) {\n            // normal case\n            wrappedLine.append(str, offset, spaceToWrapAt);\n            wrappedLine.append(newLineStr);\n            offset = spaceToWrapAt + 1;\n        } else // really long word or URL\n        if (wrapLongWords) {\n            // wrap really long word one line at a time\n            wrappedLine.append(str, offset, wrapLength + offset);\n            wrappedLine.append(newLineStr);\n            offset += wrapLength;\n        } else {\n            // do not wrap really long word, just extend beyond limit\n            matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n            if (matcher.find()) {\n                spaceToWrapAt = matcher.start() + offset + wrapLength;\n            }\n            if (spaceToWrapAt >= 0) {\n                wrappedLine.append(str, offset, spaceToWrapAt);\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n            } else {\n                wrappedLine.append(str, offset, str.length());\n                offset = inputLineLength;\n            }\n        }\n    }\n    // Whatever is left in line is short enough to just pass through\n    wrappedLine.append(str, offset, str.length());\n    return wrappedLine.toString();\n}", "repo_id": "8", "comment": "/**\n * Wraps a single line of text, identifying words by {@code wrapOn}.\n *\n * <p>Leading spaces on a new line are stripped.\n * Trailing spaces are not stripped.</p>\n *\n * <table border=\"1\">\n *  <caption>Examples</caption>\n *  <tr>\n *   <th>input</th>\n *   <th>wrapLength</th>\n *   <th>newLineString</th>\n *   <th>wrapLongWords</th>\n *   <th>wrapOn</th>\n *   <th>result</th>\n *  </tr>\n *  <tr>\n *   <td>null</td>\n *   <td>*</td>\n *   <td>*</td>\n *   <td>true/false</td>\n *   <td>*</td>\n *   <td>null</td>\n *  </tr>\n *  <tr>\n *   <td>\"\"</td>\n *   <td>*</td>\n *   <td>*</td>\n *   <td>true/false</td>\n *   <td>*</td>\n *   <td>\"\"</td>\n *  </tr>\n *  <tr>\n *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n *   <td>20</td>\n *   <td>\"\\n\"</td>\n *   <td>true/false</td>\n *   <td>\" \"</td>\n *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n *  </tr>\n *  <tr>\n *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n *   <td>20</td>\n *   <td>\"&lt;br /&gt;\"</td>\n *   <td>true/false</td>\n *   <td>\" \"</td>\n *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;br /&gt;to be wrapped after&lt;br /&gt;20 columns.\"</td>\n *  </tr>\n *  <tr>\n *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n *   <td>20</td>\n *   <td>null</td>\n *   <td>true/false</td>\n *   <td>\" \"</td>\n *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\" + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n *  </tr>\n *  <tr>\n *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n *   <td>20</td>\n *   <td>\"\\n\"</td>\n *   <td>false</td>\n *   <td>\" \"</td>\n *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n *  </tr>\n *  <tr>\n *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n *   <td>20</td>\n *   <td>\"\\n\"</td>\n *   <td>true</td>\n *   <td>\" \"</td>\n *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apach\\ne.org\"</td>\n *  </tr>\n *  <tr>\n *   <td>\"flammable/inflammable\"</td>\n *   <td>20</td>\n *   <td>\"\\n\"</td>\n *   <td>true</td>\n *   <td>\"/\"</td>\n *   <td>\"flammable\\ninflammable\"</td>\n *  </tr>\n * </table>\n * @param str  the String to be word wrapped, may be null\n * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n * @param newLineStr  the string to insert for a new line,\n *  {@code null} uses the system property line separator\n * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n * @param wrapOn regex expression to be used as a breakable characters,\n *               if blank string is provided a space character will be used\n * @return a line with newlines inserted, {@code null} if null input\n */\n", "repo_name": "commons-lang-master/", "id": 377, "method_signature": "String wrap(String, int, String, boolean, String)", "filename": "WordUtils.wrap.json"}
