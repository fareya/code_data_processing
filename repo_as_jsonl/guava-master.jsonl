{"callee_method_names": ["EndpointPair<?>.nodeU", "EndpointPair<?>.nodeU", "EndpointPair<?>.nodeV"], "method_name": "AbstractBaseGraph.contains", "method_implementation": "{\n    if (!(obj instanceof EndpointPair)) {\n        return false;\n    }\n    EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n    return isOrderingCompatible(endpointPair) && nodes().contains(endpointPair.nodeU()) && successors((N) endpointPair.nodeU()).contains(endpointPair.nodeV());\n}", "repo_id": "5", "comment": "// Graph<LinkedList>.\n", "repo_name": "guava-master/", "id": 6762, "method_signature": "boolean contains(Object)", "filename": "AbstractBaseGraph.contains.json"}
{"callee_method_names": [], "method_name": "AbstractBaseGraph.edgeCount", "method_implementation": "{\n    long degreeSum = 0L;\n    for (N node : nodes()) {\n        degreeSum += degree(node);\n    }\n    // According to the degree sum formula, this is equal to twice the number of edges.\n    checkState((degreeSum & 1) == 0);\n    return degreeSum >>> 1;\n}", "repo_id": "5", "comment": "/**\n * Returns the number of edges in this graph; used to calculate the size of {@link Graph#edges()}.\n * This implementation requires O(|N|) time. Classes extending this one may manually keep track of\n * the number of edges as the graph is updated, and override this method for better performance.\n */\n", "repo_name": "guava-master/", "id": 6760, "method_signature": "long edgeCount()", "filename": "AbstractBaseGraph.edgeCount.json"}
{"callee_method_names": ["EndpointPair<?>.nodeU", "EndpointPair<?>.nodeU", "EndpointPair<?>.nodeV"], "method_name": "AbstractBaseGraph.edges", "method_implementation": "{\n    return new AbstractSet<EndpointPair<N>>() {\n\n        @Override\n        public UnmodifiableIterator<EndpointPair<N>> iterator() {\n            return EndpointPairIterator.of(AbstractBaseGraph.this);\n        }\n\n        @Override\n        public int size() {\n            return Ints.saturatedCast(edgeCount());\n        }\n\n        @Override\n        public boolean remove(@CheckForNull Object o) {\n            throw new UnsupportedOperationException();\n        }\n\n        // Mostly safe: We check contains(u) before calling successors(u), so we perform unsafe\n        // operations only in weird cases like checking for an EndpointPair<ArrayList> in a\n        // Graph<LinkedList>.\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(@CheckForNull Object obj) {\n            if (!(obj instanceof EndpointPair)) {\n                return false;\n            }\n            EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n            return isOrderingCompatible(endpointPair) && nodes().contains(endpointPair.nodeU()) && successors((N) endpointPair.nodeU()).contains(endpointPair.nodeV());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link BaseGraph#edges()} defined in terms of {@link Graph#nodes()} and\n * {@link #successors(Object)}.\n */\n", "repo_name": "guava-master/", "id": 6761, "method_signature": "Set<EndpointPair<N>> edges()", "filename": "AbstractBaseGraph.edges.json"}
{"callee_method_names": [], "method_name": "AbstractBiMap.checkKey", "method_implementation": "{\n    return key;\n}", "repo_id": "5", "comment": "/**\n * Returns its input, or throws an exception if this is not a valid key.\n */\n", "repo_name": "guava-master/", "id": 6156, "method_signature": "K checkKey(K)", "filename": "AbstractBiMap.checkKey.json"}
{"callee_method_names": [], "method_name": "AbstractBiMap.checkValue", "method_implementation": "{\n    return value;\n}", "repo_id": "5", "comment": "/**\n * Returns its input, or throws an exception if this is not a valid value.\n */\n", "repo_name": "guava-master/", "id": 6157, "method_signature": "V checkValue(V)", "filename": "AbstractBiMap.checkValue.json"}
{"callee_method_names": ["Map<K,V>.isEmpty", "Map<V,K>.isEmpty"], "method_name": "AbstractBiMap.setDelegates", "method_implementation": "{\n    checkState(delegate == null);\n    checkState(inverse == null);\n    checkArgument(forward.isEmpty());\n    checkArgument(backward.isEmpty());\n    checkArgument(forward != backward);\n    delegate = forward;\n    inverse = makeInverse(backward);\n}", "repo_id": "5", "comment": "/**\n * Specifies the delegate maps going in each direction. Called by the constructor and by\n * subclasses during deserialization.\n */\n", "repo_name": "guava-master/", "id": 6158, "method_signature": "void setDelegates(Map, Map)", "filename": "AbstractBiMap.setDelegates.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject"], "method_name": "AbstractBiMap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(inverse());\n}", "repo_id": "5", "comment": "/**\n * @serialData the forward bimap\n */\n", "repo_name": "guava-master/", "id": 6159, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "AbstractBiMap.writeObject.json"}
{"callee_method_names": ["BiMap<Integer, String>.put", "BiMap<Integer, String>.put", "BiMap<Integer, String>.put", "BiMap<Integer, String>.keySet", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.remove", "Iterator<Integer>.next", "Iterator<Integer>.remove", "BiMap<Integer, String>.size", "BiMap<Integer, String>.inverse"], "method_name": "AbstractBiMapTest.testIdentityKeySetIteratorRemove", "method_implementation": "{\n    BiMap<Integer, String> bimap = new AbstractBiMap<Integer, String>(new IdentityHashMap<Integer, String>(), new IdentityHashMap<String, Integer>()) {\n    };\n    bimap.put(1, \"one\");\n    bimap.put(2, \"two\");\n    bimap.put(3, \"three\");\n    Iterator<Integer> iterator = bimap.keySet().iterator();\n    iterator.next();\n    iterator.next();\n    iterator.remove();\n    iterator.next();\n    iterator.remove();\n    assertEquals(1, bimap.size());\n    assertEquals(1, bimap.inverse().size());\n}", "repo_id": "5", "comment": "// removed, since IdentityHashMap throws an exception when that occurs.\n", "repo_name": "guava-master/", "id": 3951, "method_signature": "void testIdentityKeySetIteratorRemove()", "filename": "AbstractBiMapTest.testIdentityKeySetIteratorRemove.json"}
{"callee_method_names": ["ByteBuffer.array"], "method_name": "AbstractByteHasher.update", "method_implementation": "{\n    try {\n        update(scratch.array(), 0, bytes);\n    } finally {\n        Java8Compatibility.clear(scratch);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Updates the sink with the given number of bytes from the buffer.\n */\n", "repo_name": "guava-master/", "id": 5221, "method_signature": "Hasher update(int)", "filename": "AbstractByteHasher.update.json"}
{"callee_method_names": ["Map<K, V>.containsKey", "Map<K, V>.put"], "method_name": "AbstractCache.getAllPresent", "method_implementation": "{\n    Map<K, V> result = Maps.newLinkedHashMap();\n    for (Object key : keys) {\n        if (!result.containsKey(key)) {\n            @SuppressWarnings(\"unchecked\")\n            K castKey = (K) key;\n            V value = getIfPresent(key);\n            if (value != null) {\n                result.put(castKey, value);\n            }\n        }\n    }\n    return ImmutableMap.copyOf(result);\n}", "repo_id": "5", "comment": "/*\n   * <? extends Object> is mostly the same as <?> to plain Java. But to nullness checkers, they\n   * differ: <? extends Object> means \"non-null types,\" while <?> means \"all types.\"\n   */\n", "repo_name": "guava-master/", "id": 4896, "method_signature": "ImmutableMap<K,V> getAllPresent(Iterable)", "filename": "AbstractCache.getAllPresent.json"}
{"callee_method_names": ["StatsCounter.snapshot", "LongAddable.add", "CacheStats.hitCount", "LongAddable.add", "CacheStats.missCount", "LongAddable.add", "CacheStats.loadSuccessCount", "LongAddable.add", "CacheStats.loadExceptionCount", "LongAddable.add", "CacheStats.totalLoadTime", "LongAddable.add", "CacheStats.evictionCount"], "method_name": "AbstractCache.incrementBy", "method_implementation": "{\n    CacheStats otherStats = other.snapshot();\n    hitCount.add(otherStats.hitCount());\n    missCount.add(otherStats.missCount());\n    loadSuccessCount.add(otherStats.loadSuccessCount());\n    loadExceptionCount.add(otherStats.loadExceptionCount());\n    totalLoadTime.add(otherStats.totalLoadTime());\n    evictionCount.add(otherStats.evictionCount());\n}", "repo_id": "5", "comment": "/**\n * Increments all counters by the values in {@code other}.\n */\n", "repo_name": "guava-master/", "id": 4899, "method_signature": "void incrementBy(StatsCounter)", "filename": "AbstractCache.incrementBy.json"}
{"callee_method_names": [], "method_name": "AbstractCache.invalidateAll", "method_implementation": "{\n    for (Object key : keys) {\n        invalidate(key);\n    }\n}", "repo_id": "5", "comment": "/**\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4898, "method_signature": "void invalidateAll(Iterable)", "filename": "AbstractCache.invalidateAll.json"}
{"callee_method_names": ["Map<? extends K,? extends V>.entrySet", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue"], "method_name": "AbstractCache.putAll", "method_implementation": "{\n    for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\n        put(entry.getKey(), entry.getValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 4897, "method_signature": "void putAll(Map)", "filename": "AbstractCache.putAll.json"}
{"callee_method_names": ["ClosingFuture<?>.finishToFuture", "ClosingFuture<?>.finishToValueAndCloser"], "method_name": "AbstractClosingFutureTest.assertFinalStepThrowsIllegalStateException", "method_implementation": "{\n    try {\n        closingFuture.finishToFuture();\n        fail();\n    } catch (IllegalStateException expected) {\n    }\n    try {\n        closingFuture.finishToValueAndCloser(new NoOpValueAndCloserConsumer<>(), executor);\n        fail();\n    } catch (IllegalStateException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Asserts that marking this step a final step throws {@link IllegalStateException}.\n */\n", "repo_name": "guava-master/", "id": 3790, "method_signature": "void assertFinalStepThrowsIllegalStateException(ClosingFuture)", "filename": "AbstractClosingFutureTest.assertFinalStepThrowsIllegalStateException.json"}
{"callee_method_ids": [5418], "callee_method_names": ["DeferredCloser.eventuallyClose"], "method_name": "AbstractClosingFutureTest.testCloseThrowsRejectedExecutionException", "method_implementation": "{\n    doThrow(new RejectedExecutionException()).when(mockCloseable).close();\n    ClosingFuture<Closeable> closingFuture = ClosingFuture.submit(new ClosingCallable<Closeable>() {\n\n        @Override\n        public Closeable call(DeferredCloser closer) throws Exception {\n            return closer.eventuallyClose(mockCloseable, directExecutor());\n        }\n    }, executor);\n    assertThat(getFinalValue(closingFuture)).isEqualTo(mockCloseable);\n    waitUntilClosed(closingFuture);\n    verify(mockCloseable, timeout(1000)).close();\n}", "repo_id": "5", "comment": "// is closed using the direct executor.\n", "repo_name": "guava-master/", "id": 3791, "method_signature": "void testCloseThrowsRejectedExecutionException()", "filename": "AbstractClosingFutureTest.testCloseThrowsRejectedExecutionException.json"}
{"callee_method_names": [], "method_name": "AbstractCollectionTestSuiteBuilder.getTesters", "method_implementation": "{\n    return Arrays.<Class<? extends AbstractTester>>asList(CollectionAddAllTester.class, CollectionAddTester.class, CollectionClearTester.class, CollectionContainsAllTester.class, CollectionContainsTester.class, CollectionCreationTester.class, CollectionEqualsTester.class, CollectionIsEmptyTester.class, CollectionIteratorTester.class, CollectionRemoveAllTester.class, CollectionRemoveTester.class, CollectionRetainAllTester.class, CollectionSerializationTester.class, CollectionSizeTester.class, CollectionToArrayTester.class, CollectionToStringTester.class);\n}", "repo_id": "5", "comment": "// Class parameters must be raw.\n", "repo_name": "guava-master/", "id": 4195, "method_signature": "List<Class<? extends AbstractTester>> getTesters()", "filename": "AbstractCollectionTestSuiteBuilder.getTesters.json"}
{"callee_method_names": [], "method_name": "AbstractCollectionTester.createArrayWithNullElement", "method_implementation": "{\n    E[] array = createSamplesArray();\n    array[getNullLocation()] = null;\n    return array;\n}", "repo_id": "5", "comment": "/**\n * @return an array of the proper size with {@code null} inserted into the middle element.\n */\n", "repo_name": "guava-master/", "id": 4185, "method_signature": "E[] createArrayWithNullElement()", "filename": "AbstractCollectionTester.createArrayWithNullElement.json"}
{"callee_method_names": [], "method_name": "AbstractCollectionTester.expectNullMissingWhenNullUnsupported", "method_implementation": "{\n    try {\n        assertFalse(message, actualContents().contains(null));\n    } catch (NullPointerException tolerated) {\n        // Tolerated\n    }\n}", "repo_id": "5", "comment": "/**\n * Equivalent to {@link #expectMissing(Object[]) expectMissing}{@code (null)} except that the call\n * to {@code contains(null)} is permitted to throw a {@code NullPointerException}.\n *\n * @param message message to use upon assertion failure\n */\n", "repo_name": "guava-master/", "id": 4186, "method_signature": "void expectNullMissingWhenNullUnsupported(String)", "filename": "AbstractCollectionTester.expectNullMissingWhenNullUnsupported.json"}
{"callee_method_names": [], "method_name": "AbstractCollectionTester.resetContainer", "method_implementation": "{\n    collection = super.resetContainer(newContents);\n    return collection;\n}", "repo_id": "5", "comment": "// TODO: dispose of this once collection is encapsulated.\n", "repo_name": "guava-master/", "id": 4184, "method_signature": "Collection<E> resetContainer(Collection)", "filename": "AbstractCollectionTester.resetContainer.json"}
{"callee_method_names": [], "method_name": "AbstractContainerTester.createArrayWithDuplicateElement", "method_implementation": "{\n    E[] elements = createSamplesArray();\n    E duplicate = elements[(elements.length / 2) - 1];\n    elements[(elements.length / 2) + 1] = duplicate;\n    return new ArrayWithDuplicate<>(elements, duplicate);\n}", "repo_id": "5", "comment": "/**\n * @return an array of the proper size with a duplicate element. The size must be at least three.\n */\n", "repo_name": "guava-master/", "id": 4220, "method_signature": "ArrayWithDuplicate<E> createArrayWithDuplicateElement()", "filename": "AbstractContainerTester.createArrayWithDuplicateElement.json"}
{"callee_method_names": ["List<E>.addAll"], "method_name": "AbstractContainerTester.expectAdded", "method_implementation": "{\n    List<E> expected = Helpers.copyToList(getSampleElements());\n    expected.addAll(Arrays.asList(elements));\n    expectContents(expected);\n}", "repo_id": "5", "comment": "/**\n * Asserts that the collection under test contains exactly the elements it was initialized with\n * plus the given elements, according to {@link #expectContents(java.util.Collection)}. In other\n * words, for the default {@code expectContents()} implementation, the number of occurrences of\n * each given element has increased by one since the test collection was created, and the number\n * of occurrences of all other elements has not changed.\n *\n * <p>Note: This means that a test like the following will fail if {@code collection} is a {@code\n * Set}:\n *\n * <pre>\n * collection.add(existingElement);\n * expectAdded(existingElement);</pre>\n *\n * <p>In this case, {@code collection} was not modified as a result of the {@code add()} call, and\n * the test will fail because the number of occurrences of {@code existingElement} is unchanged.\n *\n * @param elements expected additional contents of {@link #container}\n */\n", "repo_name": "guava-master/", "id": 4218, "method_signature": "void expectAdded(E[])", "filename": "AbstractContainerTester.expectAdded.json"}
{"callee_method_names": [], "method_name": "AbstractContainerTester.expectMissing", "method_implementation": "{\n    for (E element : elements) {\n        assertFalse(\"Should not contain \" + element, actualContents().contains(element));\n    }\n}", "repo_id": "5", "comment": "/*\n   * TODO: if we're testing a list, we could check indexOf(). (Doing it in\n   * AbstractListTester isn't enough because many tests that run on lists don't\n   * extends AbstractListTester.) We could also iterate over all elements to\n   * verify absence\n   */\n", "repo_name": "guava-master/", "id": 4219, "method_signature": "void expectMissing(E[])", "filename": "AbstractContainerTester.expectMissing.json"}
{"callee_method_names": ["List<E>.add"], "method_name": "AbstractContainerTester.getOrderedElements", "method_implementation": "{\n    List<E> list = new ArrayList<>();\n    for (E e : getSubjectGenerator().order(new ArrayList<E>(getSampleElements()))) {\n        list.add(e);\n    }\n    return Collections.unmodifiableList(list);\n}", "repo_id": "5", "comment": "/**\n * Returns the {@linkplain #getSampleElements() sample elements} as ordered by {@link\n * TestContainerGenerator#order(List)}. Tests should use this method only if they declare\n * requirement {@link com.google.common.collect.testing.features.CollectionFeature#KNOWN_ORDER}.\n */\n", "repo_name": "guava-master/", "id": 4221, "method_signature": "List<E> getOrderedElements()", "filename": "AbstractContainerTester.getOrderedElements.json"}
{"callee_method_names": [], "method_name": "AbstractContainerTester.resetContainer", "method_implementation": "{\n    container = newValue;\n    return container;\n}", "repo_id": "5", "comment": "/**\n * Replaces the existing container under test with a new container. This is useful when a single\n * test method needs to create multiple containers while retaining the ability to use {@link\n * #expectContents(Object[]) expectContents(E...)} and other convenience methods. The creation of\n * multiple containers in a single method is discouraged in most cases, but it is vital to the\n * iterator tests.\n *\n * @return the new container instance\n * @param newValue the new container instance\n */\n", "repo_name": "guava-master/", "id": 4217, "method_signature": "C resetContainer(C)", "filename": "AbstractContainerTester.resetContainer.json"}
{"callee_method_names": ["Multiset.Entry<?>.getCount", "Multiset.Entry<?>.getElement"], "method_name": "AbstractEntry.equals", "method_implementation": "{\n    if (object instanceof Multiset.Entry) {\n        Multiset.Entry<?> that = (Multiset.Entry<?>) object;\n        return this.getCount() == that.getCount() && Objects.equal(this.getElement(), that.getElement());\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Indicates whether an object equals this entry, following the behavior specified in {@link\n * Multiset.Entry#equals}.\n */\n", "repo_name": "guava-master/", "id": 6215, "method_signature": "boolean equals(Object)", "filename": "AbstractEntry.equals.json"}
{"callee_method_names": ["E.hashCode"], "method_name": "AbstractEntry.hashCode", "method_implementation": "{\n    E e = getElement();\n    return ((e == null) ? 0 : e.hashCode()) ^ getCount();\n}", "repo_id": "5", "comment": "/**\n * Return this entry's hash code, following the behavior specified in {@link\n * Multiset.Entry#hashCode}.\n */\n", "repo_name": "guava-master/", "id": 6216, "method_signature": "int hashCode()", "filename": "AbstractEntry.hashCode.json"}
{"callee_method_names": [], "method_name": "AbstractEntry.toString", "method_implementation": "{\n    String text = String.valueOf(getElement());\n    int n = getCount();\n    return (n == 1) ? text : (text + \" x \" + n);\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this multiset entry. The string representation consists of\n * the associated element if the associated count is one, and otherwise the associated element\n * followed by the characters \" x \" (space, x and space) followed by the count. Elements and\n * counts are converted to strings as by {@code String.valueOf}.\n */\n", "repo_name": "guava-master/", "id": 6217, "method_signature": "String toString()", "filename": "AbstractEntry.toString.json"}
{"callee_method_names": ["AbstractService.startAsync"], "method_name": "AbstractExecutionThreadService.startAsync", "method_implementation": "{\n    delegate.startAsync();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5316, "method_signature": "Service startAsync()", "filename": "AbstractExecutionThreadService.startAsync.json"}
{"callee_method_names": ["AbstractService.stopAsync"], "method_name": "AbstractExecutionThreadService.stopAsync", "method_implementation": "{\n    delegate.stopAsync();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5317, "method_signature": "Service stopAsync()", "filename": "AbstractExecutionThreadService.stopAsync.json"}
{"callee_method_names": ["AtomicHelper.casListeners"], "method_name": "AbstractFuture.addListener", "method_implementation": "{\n    checkNotNull(listener, \"Runnable was null.\");\n    checkNotNull(executor, \"Executor was null.\");\n    // Checking isDone and listeners != TOMBSTONE may seem redundant, but our contract for\n    // addListener says that listeners execute 'immediate' if the future isDone(). However, our\n    // protocol for completing a future is to assign the value field (which sets isDone to true) and\n    // then to release waiters, followed by executing afterDone(), followed by releasing listeners.\n    // That means that it is possible to observe that the future isDone and that your listeners\n    // don't execute 'immediately'.  By checking isDone here we avoid that.\n    // A corollary to all that is that we don't need to check isDone inside the loop because if we\n    // get into the loop we know that we weren't done when we entered and therefore we aren't under\n    // an obligation to execute 'immediately'.\n    if (!isDone()) {\n        Listener oldHead = listeners;\n        if (oldHead != Listener.TOMBSTONE) {\n            Listener newNode = new Listener(listener, executor);\n            do {\n                newNode.next = oldHead;\n                if (ATOMIC_HELPER.casListeners(this, oldHead, newNode)) {\n                    return;\n                }\n                // re-read\n                oldHead = listeners;\n            } while (oldHead != Listener.TOMBSTONE);\n        }\n    }\n    // If we get here then the Listener TOMBSTONE was set, which means the future is done, call\n    // the listener.\n    executeListener(listener, executor);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5290, "method_signature": "void addListener(Runnable, Executor)", "filename": "AbstractFuture.addListener.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Object.getClass"], "method_name": "AbstractFuture.appendResultObject", "method_implementation": "{\n    if (o == null) {\n        builder.append(\"null\");\n    } else if (o == this) {\n        builder.append(\"this future\");\n    } else {\n        builder.append(o.getClass().getName()).append(\"@\").append(Integer.toHexString(System.identityHashCode(o)));\n    }\n}", "repo_id": "5", "comment": "/**\n * Any object can be the result of a Future, and not every object has a reasonable toString()\n * implementation. Using a reconstruction of the default Object.toString() prevents OOMs and stack\n * overflows, and helps avoid sensitive data inadvertently ending up in exception messages.\n */\n", "repo_name": "guava-master/", "id": 5303, "method_signature": "void appendResultObject(StringBuilder, Object)", "filename": "AbstractFuture.appendResultObject.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Entry<?, ?>.getClass"], "method_name": "AbstractFuture.appendUserObject", "method_implementation": "{\n    // This is some basic recursion detection for when people create cycles via set/setFuture or\n    // when deep chains of futures exist resulting in a StackOverflowException. We could detect\n    // arbitrary cycles using a thread local but this should be a good enough solution (it is also\n    // what jdk collections do in these cases)\n    try {\n        if (o == this) {\n            builder.append(\"this future\");\n        } else {\n            builder.append(o);\n        }\n    } catch (Exception | StackOverflowError e) {\n        // Any Exception is either a RuntimeException or sneaky checked exception.\n        //\n        // Don't call getMessage or toString() on the exception, in case the exception thrown by the\n        // user object is implemented with bugs similar to the user object.\n        builder.append(\"Exception thrown from implementation: \").append(e.getClass());\n    }\n}", "repo_id": "5", "comment": "/**\n * Helper for printing user supplied objects into our toString method.\n */\n", "repo_name": "guava-master/", "id": 5304, "method_signature": "void appendUserObject(StringBuilder, Object)", "filename": "AbstractFuture.appendUserObject.json"}
{"callee_method_names": ["AtomicHelper.casValue", "ListenableFuture<?>.cancel"], "method_name": "AbstractFuture.cancel", "method_implementation": "{\n    Object localValue = value;\n    boolean rValue = false;\n    if (localValue == null | localValue instanceof SetFuture) {\n        // Try to delay allocating the exception. At this point we may still lose the CAS, but it is\n        // certainly less likely.\n        Object valueToSet = GENERATE_CANCELLATION_CAUSES ? new Cancellation(mayInterruptIfRunning, new CancellationException(\"Future.cancel() was called.\")) : /*\n               * requireNonNull is safe because we've initialized these if\n               * !GENERATE_CANCELLATION_CAUSES.\n               *\n               * TODO(cpovirk): Maybe it would be cleaner to define a CancellationSupplier interface\n               * with two implementations, one that contains causeless Cancellation instances and\n               * the other of which creates new Cancellation instances each time it's called? Yet\n               * another alternative is to fill in a non-null value for each of the fields no matter\n               * what and to just not use it if !GENERATE_CANCELLATION_CAUSES.\n               */\n        requireNonNull(mayInterruptIfRunning ? Cancellation.CAUSELESS_INTERRUPTED : Cancellation.CAUSELESS_CANCELLED);\n        AbstractFuture<?> abstractFuture = this;\n        while (true) {\n            if (ATOMIC_HELPER.casValue(abstractFuture, localValue, valueToSet)) {\n                rValue = true;\n                complete(abstractFuture, mayInterruptIfRunning);\n                if (localValue instanceof SetFuture) {\n                    // propagate cancellation to the future set in setfuture, this is racy, and we don't\n                    // care if we are successful or not.\n                    ListenableFuture<?> futureToPropagateTo = ((SetFuture) localValue).future;\n                    if (futureToPropagateTo instanceof Trusted) {\n                        // If the future is a TrustedFuture then we specifically avoid calling cancel()\n                        // this has 2 benefits\n                        // 1. for long chains of futures strung together with setFuture we consume less stack\n                        // 2. we avoid allocating Cancellation objects at every level of the cancellation\n                        //    chain\n                        // We can only do this for TrustedFuture, because TrustedFuture.cancel is final and\n                        // does nothing but delegate to this method.\n                        AbstractFuture<?> trusted = (AbstractFuture<?>) futureToPropagateTo;\n                        localValue = trusted.value;\n                        if (localValue == null | localValue instanceof SetFuture) {\n                            abstractFuture = trusted;\n                            // loop back up and try to complete the new future\n                            continue;\n                        }\n                    } else {\n                        // not a TrustedFuture, call cancel directly.\n                        futureToPropagateTo.cancel(mayInterruptIfRunning);\n                    }\n                }\n                break;\n            }\n            // obj changed, reread\n            localValue = abstractFuture.value;\n            if (!(localValue instanceof SetFuture)) {\n                // obj cannot be null at this point, because value can only change from null to non-null.\n                // So if value changed (and it did since we lost the CAS), then it cannot be null and\n                // since it isn't a SetFuture, then the future must be done and we should exit the loop\n                break;\n            }\n        }\n    }\n    return rValue;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If a cancellation attempt succeeds on a {@code Future} that had previously been {@linkplain\n * #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate\n * {@code Future} that was supplied in the {@code setFuture} call.\n *\n * <p>Rather than override this method to perform additional cancellation work or cleanup,\n * subclasses should override {@link #afterDone}, consulting {@link #isCancelled} and {@link\n * #wasInterrupted} as necessary. This ensures that the work is done even if the future is\n * cancelled without a call to {@code cancel}, such as by calling {@code\n * setFuture(cancelledFuture)}.\n *\n * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or\n * acquire other locks, risking deadlocks.\n */\n", "repo_name": "guava-master/", "id": 5289, "method_signature": "boolean cancel(boolean)", "filename": "AbstractFuture.cancel.json"}
{"callee_method_names": ["sun.misc.Unsafe.compareAndSwapObject"], "method_name": "AbstractFuture.casWaiters", "method_implementation": "{\n    return UNSAFE.compareAndSwapObject(future, WAITERS_OFFSET, expect, update);\n}", "repo_id": "5", "comment": "/**\n * Performs a CAS operation on the {@link #waiters} field.\n */\n", "repo_name": "guava-master/", "id": 5306, "method_signature": "boolean casWaiters(AbstractFuture, Waiter, Waiter)", "filename": "AbstractFuture.casWaiters.json"}
{"callee_method_names": ["AtomicHelper.gasListeners"], "method_name": "AbstractFuture.clearListeners", "method_implementation": "{\n    // We need to\n    // 1. atomically swap the listeners with TOMBSTONE, this is because addListener uses that\n    //    to synchronize with us\n    // 2. reverse the linked list, because despite our rather clear contract, people depend on us\n    //    executing listeners in the order they were added\n    // 3. push all the items onto 'onto' and return the new head of the stack\n    Listener head = ATOMIC_HELPER.gasListeners(this, Listener.TOMBSTONE);\n    Listener reversedList = onto;\n    while (head != null) {\n        Listener tmp = head;\n        head = head.next;\n        tmp.next = reversedList;\n        reversedList = tmp;\n    }\n    return reversedList;\n}", "repo_id": "5", "comment": "/**\n * Clears the {@link #listeners} list and prepends its contents to {@code onto}, least recently\n * added first.\n */\n", "repo_name": "guava-master/", "id": 5300, "method_signature": "Listener clearListeners(Listener)", "filename": "AbstractFuture.clearListeners.json"}
{"callee_method_names": ["AbstractFuture<?>.releaseWaiters", "AbstractFuture<?>.interruptTask", "AbstractFuture<?>.afterDone", "AbstractFuture<?>.clearListeners", "AtomicHelper.casValue"], "method_name": "AbstractFuture.complete", "method_implementation": "{\n    // Declare a \"true\" local variable so that the Checker Framework will infer nullness.\n    AbstractFuture<?> future = param;\n    Listener next = null;\n    outer: while (true) {\n        future.releaseWaiters();\n        /*\n       * We call interruptTask() immediately before afterDone() so that migrating between the two\n       * can be a no-op.\n       */\n        if (callInterruptTask) {\n            future.interruptTask();\n            /*\n         * Interruption doesn't propagate through a SetFuture chain (see getFutureValue), so don't\n         * invoke interruptTask on any subsequent futures.\n         */\n            callInterruptTask = false;\n        }\n        // We call this before the listeners in order to avoid needing to manage a separate stack data\n        // structure for them.  Also, some implementations rely on this running prior to listeners\n        // so that the cleanup work is visible to listeners.\n        // afterDone() should be generally fast and only used for cleanup work... but in theory can\n        // also be recursive and create StackOverflowErrors\n        future.afterDone();\n        // push the current set of listeners onto next\n        next = future.clearListeners(next);\n        future = null;\n        while (next != null) {\n            Listener curr = next;\n            next = next.next;\n            /*\n         * requireNonNull is safe because the listener stack never contains TOMBSTONE until after\n         * clearListeners.\n         */\n            Runnable task = requireNonNull(curr.task);\n            if (task instanceof SetFuture) {\n                SetFuture<?> setFuture = (SetFuture<?>) task;\n                // We unwind setFuture specifically to avoid StackOverflowErrors in the case of long\n                // chains of SetFutures\n                // Handling this special case is important because there is no way to pass an executor to\n                // setFuture, so a user couldn't break the chain by doing this themselves.  It is also\n                // potentially common if someone writes a recursive Futures.transformAsync transformer.\n                future = setFuture.owner;\n                if (future.value == setFuture) {\n                    Object valueToSet = getFutureValue(setFuture.future);\n                    if (ATOMIC_HELPER.casValue(future, setFuture, valueToSet)) {\n                        continue outer;\n                    }\n                }\n                // otherwise the future we were trying to set is already done.\n            } else {\n                /*\n           * requireNonNull is safe because the listener stack never contains TOMBSTONE until after\n           * clearListeners.\n           */\n                executeListener(task, requireNonNull(curr.executor));\n            }\n        }\n        break;\n    }\n}", "repo_id": "5", "comment": "/**\n * Unblocks all threads and runs all listeners.\n */\n", "repo_name": "guava-master/", "id": 5296, "method_signature": "void complete(AbstractFuture, boolean)", "filename": "AbstractFuture.complete.json"}
{"callee_method_names": ["Executor.execute", "LazyLogger.get"], "method_name": "AbstractFuture.executeListener", "method_implementation": "{\n    try {\n        executor.execute(runnable);\n    } catch (Exception e) {\n        // sneaky checked exception\n        // Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if\n        // we're given a bad one. We only catch RuntimeException because we want Errors to propagate\n        // up.\n        log.get().log(Level.SEVERE, \"RuntimeException while executing runnable \" + runnable + \" with executor \" + executor, e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Submits the given runnable to the given {@link Executor} catching and logging all {@linkplain\n * RuntimeException runtime exceptions} thrown by the executor.\n */\n", "repo_name": "guava-master/", "id": 5305, "method_signature": "void executeListener(Runnable, Executor)", "filename": "AbstractFuture.executeListener.json"}
{"callee_method_names": [], "method_name": "AbstractFuture.gasListeners", "method_implementation": "{\n    synchronized (future) {\n        Listener old = future.listeners;\n        if (old != update) {\n            future.listeners = update;\n        }\n        return old;\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs a GAS operation on the {@link #listeners} field.\n */\n", "repo_name": "guava-master/", "id": 5309, "method_signature": "Listener gasListeners(AbstractFuture, Listener)", "filename": "AbstractFuture.gasListeners.json"}
{"callee_method_names": [], "method_name": "AbstractFuture.gasWaiters", "method_implementation": "{\n    synchronized (future) {\n        Waiter old = future.waiters;\n        if (old != update) {\n            future.waiters = update;\n        }\n        return old;\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs a GAS operation on the {@link #waiters} field.\n */\n", "repo_name": "guava-master/", "id": 5310, "method_signature": "Waiter gasWaiters(AbstractFuture, Waiter)", "filename": "AbstractFuture.gasWaiters.json"}
{"callee_method_names": ["State.maybeThrowOnGet"], "method_name": "AbstractFuture.get", "method_implementation": "{\n    state.maybeThrowOnGet(throwable);\n    return value;\n}", "repo_id": "5", "comment": "/*\n   * ForwardingFluentFuture needs to override those methods, so they are not final.\n   */\n", "repo_name": "guava-master/", "id": 6817, "method_signature": "V get()", "filename": "AbstractFuture.get.json"}
{"callee_method_names": [], "method_name": "AbstractFuture.getDoneValue", "method_implementation": "{\n    // While this seems like it might be too branch-y, simple benchmarking proves it to be\n    // unmeasurable (comparing done AbstractFutures with immediateFuture)\n    if (obj instanceof Cancellation) {\n        throw cancellationExceptionWithCause(\"Task was cancelled.\", ((Cancellation) obj).cause);\n    } else if (obj instanceof Failure) {\n        throw new ExecutionException(((Failure) obj).exception);\n    } else if (obj == NULL) {\n        /*\n       * It's safe to return null because we would only have stored it in the first place if it were\n       * a valid value for V.\n       */\n        return uncheckedNull();\n    } else {\n        // this is the only other option\n        @SuppressWarnings(\"unchecked\")\n        V asV = (V) obj;\n        return asV;\n    }\n}", "repo_id": "5", "comment": "/**\n * Unboxes {@code obj}. Assumes that obj is not {@code null} or a {@link SetFuture}.\n */\n", "repo_name": "guava-master/", "id": 5288, "method_signature": "V getDoneValue(Object)", "filename": "AbstractFuture.getDoneValue.json"}
{"callee_method_names": ["ListenableFuture<?>.isCancelled", "Throwable.getCause"], "method_name": "AbstractFuture.getFutureValue", "method_implementation": "{\n    if (future instanceof Trusted) {\n        // Break encapsulation for TrustedFuture instances since we know that subclasses cannot\n        // override .get() (since it is final) and therefore this is equivalent to calling .get()\n        // and unpacking the exceptions like we do below (just much faster because it is a single\n        // field read instead of a read, several branches and possibly creating exceptions).\n        Object v = ((AbstractFuture<?>) future).value;\n        if (v instanceof Cancellation) {\n            // If the other future was interrupted, clear the interrupted bit while preserving the cause\n            // this will make it consistent with how non-trustedfutures work which cannot propagate the\n            // wasInterrupted bit\n            Cancellation c = (Cancellation) v;\n            if (c.wasInterrupted) {\n                v = c.cause != null ? new Cancellation(/* wasInterrupted= */\n                false, c.cause) : Cancellation.CAUSELESS_CANCELLED;\n            }\n        }\n        // requireNonNull is safe as long as we call this method only on completed futures.\n        return requireNonNull(v);\n    }\n    if (future instanceof InternalFutureFailureAccess) {\n        Throwable throwable = InternalFutures.tryInternalFastPathGetFailure((InternalFutureFailureAccess) future);\n        if (throwable != null) {\n            return new Failure(throwable);\n        }\n    }\n    boolean wasCancelled = future.isCancelled();\n    // Don't allocate a CancellationException if it's not necessary\n    if (!GENERATE_CANCELLATION_CAUSES & wasCancelled) {\n        /*\n       * requireNonNull is safe because we've initialized CAUSELESS_CANCELLED if\n       * !GENERATE_CANCELLATION_CAUSES.\n       */\n        return requireNonNull(Cancellation.CAUSELESS_CANCELLED);\n    }\n    // Otherwise calculate the value by calling .get()\n    try {\n        Object v = getUninterruptibly(future);\n        if (wasCancelled) {\n            return new Cancellation(false, new IllegalArgumentException(\"get() did not throw CancellationException, despite reporting \" + \"isCancelled() == true: \" + future));\n        }\n        return v == null ? NULL : v;\n    } catch (ExecutionException exception) {\n        if (wasCancelled) {\n            return new Cancellation(false, new IllegalArgumentException(\"get() did not throw CancellationException, despite reporting \" + \"isCancelled() == true: \" + future, exception));\n        }\n        return new Failure(exception.getCause());\n    } catch (CancellationException cancellation) {\n        if (!wasCancelled) {\n            return new Failure(new IllegalArgumentException(\"get() threw CancellationException, despite reporting isCancelled() == false: \" + future, cancellation));\n        }\n        return new Cancellation(false, cancellation);\n    } catch (Exception | Error t) {\n        // sneaky checked exception\n        return new Failure(t);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a value that satisfies the contract of the {@link #value} field based on the state of\n * given future.\n *\n * <p>This is approximately the inverse of {@link #getDoneValue(Object)}\n */\n", "repo_name": "guava-master/", "id": 5294, "method_signature": "Object getFutureValue(ListenableFuture)", "filename": "AbstractFuture.getFutureValue.json"}
{"callee_method_names": ["Future<V>.get"], "method_name": "AbstractFuture.getUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        while (true) {\n            try {\n                return future.get();\n            } catch (InterruptedException e) {\n                interrupted = true;\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * An inlined private copy of {@link Uninterruptibles#getUninterruptibly} used to break an\n * internal dependency on other /util/concurrent classes.\n */\n", "repo_name": "guava-master/", "id": 5295, "method_signature": "V getUninterruptibly(Future)", "filename": "AbstractFuture.getUninterruptibly.json"}
{"callee_method_names": ["Future<?>.cancel"], "method_name": "AbstractFuture.maybePropagateCancellationTo", "method_implementation": "{\n    if (related != null & isCancelled()) {\n        related.cancel(wasInterrupted());\n    }\n}", "repo_id": "5", "comment": "/**\n * If this future has been cancelled (and possibly interrupted), cancels (and possibly interrupts)\n * the given future (if available).\n */\n", "repo_name": "guava-master/", "id": 5298, "method_signature": "void maybePropagateCancellationTo(Future)", "filename": "AbstractFuture.maybePropagateCancellationTo.json"}
{"callee_method_names": [], "method_name": "AbstractFuture.pendingToString", "method_implementation": "{\n    if (state == State.DELEGATED) {\n        return \"setFuture=[\" + delegate + \"]\";\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Provide a human-readable explanation of why this future has not yet completed.\n *\n * @return null if an explanation cannot be provided because the future is done.\n */\n", "repo_name": "guava-master/", "id": 6818, "method_signature": "String pendingToString()", "filename": "AbstractFuture.pendingToString.json"}
{"callee_method_names": ["AtomicHelper.gasWaiters"], "method_name": "AbstractFuture.releaseWaiters", "method_implementation": "{\n    Waiter head = ATOMIC_HELPER.gasWaiters(this, Waiter.TOMBSTONE);\n    for (Waiter currentWaiter = head; currentWaiter != null; currentWaiter = currentWaiter.next) {\n        currentWaiter.unpark();\n    }\n}", "repo_id": "5", "comment": "/**\n * Releases all threads in the {@link #waiters} list, and clears the list.\n */\n", "repo_name": "guava-master/", "id": 5299, "method_signature": "void releaseWaiters()", "filename": "AbstractFuture.releaseWaiters.json"}
{"callee_method_names": ["AtomicHelper.casWaiters"], "method_name": "AbstractFuture.removeWaiter", "method_implementation": "{\n    // mark as 'deleted'\n    node.thread = null;\n    restart: while (true) {\n        Waiter pred = null;\n        Waiter curr = waiters;\n        if (curr == Waiter.TOMBSTONE) {\n            // give up if someone is calling complete\n            return;\n        }\n        Waiter succ;\n        while (curr != null) {\n            succ = curr.next;\n            if (curr.thread != null) {\n                // we aren't unlinking this node, update pred.\n                pred = curr;\n            } else if (pred != null) {\n                // We are unlinking this node and it has a predecessor.\n                pred.next = succ;\n                if (pred.thread == null) {\n                    // We raced with another node that unlinked pred. Restart.\n                    continue restart;\n                }\n            } else if (!ATOMIC_HELPER.casWaiters(this, curr, succ)) {\n                // We are unlinking head\n                // We raced with an add or complete\n                continue restart;\n            }\n            curr = succ;\n        }\n        break;\n    }\n}", "repo_id": "5", "comment": "/**\n * Marks the given node as 'deleted' (null waiter) and then scans the list to unlink all deleted\n * nodes. This is an O(n) operation in the common case (and O(n^2) in the worst), but we are saved\n * by two things.\n *\n * <ul>\n *   <li>This is only called when a waiting thread times out or is interrupted. Both of which\n *       should be rare.\n *   <li>The waiters list should be very short.\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 5285, "method_signature": "void removeWaiter(Waiter)", "filename": "AbstractFuture.removeWaiter.json"}
{"callee_method_names": ["AtomicHelper.casValue"], "method_name": "AbstractFuture.set", "method_implementation": "{\n    Object valueToSet = value == null ? NULL : value;\n    if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {\n        complete(this, /*callInterruptTask=*/\n        false);\n        return true;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Sets the result of this {@code Future} unless this {@code Future} has already been cancelled or\n * set (including {@linkplain #setFuture set asynchronously}). When a call to this method returns,\n * the {@code Future} is guaranteed to be {@linkplain #isDone done} <b>only if</b> the call was\n * accepted (in which case it returns {@code true}). If it returns {@code false}, the {@code\n * Future} may have previously been set asynchronously, in which case its result may not be known\n * yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}\n * method, only by a call to {@link #cancel}.\n *\n * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or\n * acquire other locks, risking deadlocks.\n *\n * @param value the value to be used as the result\n * @return true if the attempt was accepted, completing the {@code Future}\n */\n", "repo_name": "guava-master/", "id": 5291, "method_signature": "boolean set(V)", "filename": "AbstractFuture.set.json"}
{"callee_method_names": ["AtomicHelper.casValue"], "method_name": "AbstractFuture.setException", "method_implementation": "{\n    Object valueToSet = new Failure(checkNotNull(throwable));\n    if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {\n        complete(this, /*callInterruptTask=*/\n        false);\n        return true;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Sets the failed result of this {@code Future} unless this {@code Future} has already been\n * cancelled or set (including {@linkplain #setFuture set asynchronously}). When a call to this\n * method returns, the {@code Future} is guaranteed to be {@linkplain #isDone done} <b>only if</b>\n * the call was accepted (in which case it returns {@code true}). If it returns {@code false}, the\n * {@code Future} may have previously been set asynchronously, in which case its result may not be\n * known yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}\n * method, only by a call to {@link #cancel}.\n *\n * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or\n * acquire other locks, risking deadlocks.\n *\n * @param throwable the exception to be used as the failed result\n * @return true if the attempt was accepted, completing the {@code Future}\n */\n", "repo_name": "guava-master/", "id": 5292, "method_signature": "boolean setException(Throwable)", "filename": "AbstractFuture.setException.json"}
{"callee_method_names": ["ListenableFuture<? extends V>.isDone", "AtomicHelper.casValue", "AtomicHelper.casValue", "ListenableFuture<? extends V>.addListener", "AtomicHelper.casValue", "ListenableFuture<? extends V>.cancel"], "method_name": "AbstractFuture.setFuture", "method_implementation": "{\n    checkNotNull(future);\n    Object localValue = value;\n    if (localValue == null) {\n        if (future.isDone()) {\n            Object value = getFutureValue(future);\n            if (ATOMIC_HELPER.casValue(this, null, value)) {\n                complete(this, /*\n               * Interruption doesn't propagate through a SetFuture chain (see getFutureValue), so\n               * don't invoke interruptTask.\n               */\n                false);\n                return true;\n            }\n            return false;\n        }\n        SetFuture<V> valueToSet = new SetFuture<V>(this, future);\n        if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {\n            // the listener is responsible for calling completeWithFuture, directExecutor is appropriate\n            // since all we are doing is unpacking a completed future which should be fast.\n            try {\n                future.addListener(valueToSet, DirectExecutor.INSTANCE);\n            } catch (Throwable t) {\n                // Any Exception is either a RuntimeException or sneaky checked exception.\n                //\n                // addListener has thrown an exception! SetFuture.run can't throw any exceptions so this\n                // must have been caused by addListener itself. The most likely explanation is a\n                // misconfigured mock. Try to switch to Failure.\n                Failure failure;\n                try {\n                    failure = new Failure(t);\n                } catch (Exception | Error oomMostLikely) {\n                    // sneaky checked exception\n                    failure = Failure.FALLBACK_INSTANCE;\n                }\n                // Note: The only way this CAS could fail is if cancel() has raced with us. That is ok.\n                boolean unused = ATOMIC_HELPER.casValue(this, valueToSet, failure);\n            }\n            return true;\n        }\n        // we lost the cas, fall through and maybe cancel\n        localValue = value;\n    }\n    // The future has already been set to something. If it is cancellation we should cancel the\n    // incoming future.\n    if (localValue instanceof Cancellation) {\n        // we don't care if it fails, this is best-effort.\n        future.cancel(((Cancellation) localValue).wasInterrupted);\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Sets the result of this {@code Future} to match the supplied input {@code Future} once the\n * supplied {@code Future} is done, unless this {@code Future} has already been cancelled or set\n * (including \"set asynchronously,\" defined below).\n *\n * <p>If the supplied future is {@linkplain #isDone done} when this method is called and the call\n * is accepted, then this future is guaranteed to have been completed with the supplied future by\n * the time this method returns. If the supplied future is not done and the call is accepted, then\n * the future will be <i>set asynchronously</i>. Note that such a result, though not yet known,\n * cannot be overridden by a call to a {@code set*} method, only by a call to {@link #cancel}.\n *\n * <p>If the call {@code setFuture(delegate)} is accepted and this {@code Future} is later\n * cancelled, cancellation will be propagated to {@code delegate}. Additionally, any call to\n * {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code\n * Future}.\n *\n * <p>Note that, even if the supplied future is cancelled and it causes this future to complete,\n * it will never trigger interruption behavior. In particular, it will not cause this future to\n * invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not\n * return {@code true}.\n *\n * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or\n * acquire other locks, risking deadlocks.\n *\n * @param future the future to delegate to\n * @return true if the attempt was accepted, indicating that the {@code Future} was not previously\n *     cancelled or set.\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 5293, "method_signature": "boolean setFuture(ListenableFuture)", "filename": "AbstractFuture.setFuture.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "AbstractFuture.toString", "method_implementation": "{\n    // TODO(cpovirk): Presize to something plausible?\n    StringBuilder builder = new StringBuilder();\n    if (getClass().getName().startsWith(\"com.google.common.util.concurrent.\")) {\n        builder.append(getClass().getSimpleName());\n    } else {\n        builder.append(getClass().getName());\n    }\n    builder.append('@').append(toHexString(identityHashCode(this))).append(\"[status=\");\n    if (isCancelled()) {\n        builder.append(\"CANCELLED\");\n    } else if (isDone()) {\n        addDoneString(builder);\n    } else {\n        // delegates to addDoneString if future completes midway\n        addPendingString(builder);\n    }\n    return builder.append(\"]\").toString();\n}", "repo_id": "5", "comment": "// TODO(user): move parts into a default method on ListenableFuture?\n", "repo_name": "guava-master/", "id": 5301, "method_signature": "String toString()", "filename": "AbstractFuture.toString.json"}
{"callee_method_names": [], "method_name": "AbstractFuture.tryInternalFastPathGetFailure", "method_implementation": "{\n    if (this instanceof Trusted) {\n        Object obj = value;\n        if (obj instanceof Failure) {\n            return ((Failure) obj).exception;\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Usually returns {@code null} but, if this {@code Future} has failed, may <i>optionally</i>\n * return the cause of the failure. \"Failure\" means specifically \"completed with an exception\"; it\n * does not include \"was cancelled.\" To be explicit: If this method returns a non-null value,\n * then:\n *\n * <ul>\n *   <li>{@code isDone()} must return {@code true}\n *   <li>{@code isCancelled()} must return {@code false}\n *   <li>{@code get()} must not block, and it must throw an {@code ExecutionException} with the\n *       return value of this method as its cause\n * </ul>\n *\n * <p>This method is {@code protected} so that classes like {@code\n * com.google.common.util.concurrent.SettableFuture} do not expose it to their users as an\n * instance method. In the unlikely event that you need to call this method, call {@link\n * InternalFutures#tryInternalFastPathGetFailure(InternalFutureFailureAccess)}.\n *\n * @since 27.0\n */\n", "repo_name": "guava-master/", "id": 5297, "method_signature": "Throwable tryInternalFastPathGetFailure()", "filename": "AbstractFuture.tryInternalFastPathGetFailure.json"}
{"callee_method_names": [], "method_name": "AbstractFutureBenchmarks.complete", "method_implementation": "{\n    boolean doCompletion = compareAndSetState(RUNNING, COMPLETING);\n    if (doCompletion) {\n        // If this thread successfully transitioned to COMPLETING, set the value\n        // and exception and then release to the final state.\n        this.value = v;\n        // Don't actually construct a CancellationException until necessary.\n        this.exception = ((finalState & (CANCELLED | INTERRUPTED)) != 0) ? new CancellationException(\"Future.cancel() was called.\") : t;\n        releaseShared(finalState);\n    } else if (getState() == COMPLETING) {\n        // If some other thread is currently completing the future, block until\n        // they are done so we can guarantee completion.\n        acquireShared(-1);\n    }\n    return doCompletion;\n}", "repo_id": "5", "comment": "/**\n * Implementation of completing a task. Either {@code v} or {@code t} will be set but not\n * both. The {@code finalState} is the state to change to from {@link #RUNNING}. If the state\n * is not in the RUNNING state we return {@code false} after waiting for the state to be set\n * to a valid final state ({@link #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}).\n *\n * @param v the value to set as the result of the computation.\n * @param t the exception to set as the result of the computation.\n * @param finalState the state to transition to.\n */\n", "repo_name": "guava-master/", "id": 3902, "method_signature": "boolean complete(V, Throwable, int)", "filename": "AbstractFutureBenchmarks.complete.json"}
{"callee_method_names": [], "method_name": "AbstractFutureBenchmarks.get", "method_implementation": "{\n    // Acquire the shared lock allowing interruption.\n    acquireSharedInterruptibly(-1);\n    return getValue();\n}", "repo_id": "5", "comment": "/**\n * Blocks until {@link #complete(Object, Throwable, int)} has been successfully called. Throws\n * a {@link CancellationException} if the task was cancelled, or a {@link ExecutionException}\n * if the task completed with an error.\n */\n", "repo_name": "guava-master/", "id": 3900, "method_signature": "V get()", "filename": "AbstractFutureBenchmarks.get.json"}
{"callee_method_names": [], "method_name": "AbstractFutureBenchmarks.getValue", "method_implementation": "{\n    int state = getState();\n    switch(state) {\n        case COMPLETED:\n            if (exception != null) {\n                throw new ExecutionException(exception);\n            } else {\n                return value;\n            }\n        case CANCELLED:\n        case INTERRUPTED:\n            throw cancellationExceptionWithCause(\"Task was cancelled.\", exception);\n        default:\n            throw new IllegalStateException(\"Error, synchronizer in invalid state: \" + state);\n    }\n}", "repo_id": "5", "comment": "/**\n * Implementation of the actual value retrieval. Will return the value on success, an\n * exception on failure, a cancellation on cancellation, or an illegal state if the\n * synchronizer is in an invalid state.\n */\n", "repo_name": "guava-master/", "id": 3901, "method_signature": "V getValue()", "filename": "AbstractFutureBenchmarks.getValue.json"}
{"callee_method_ids": [5456], "callee_method_names": ["Sync.set", "ExecutionList.execute"], "method_name": "AbstractFutureBenchmarks.set", "method_implementation": "{\n    boolean result = sync.set(value);\n    if (result) {\n        executionList.execute();\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Subclasses should invoke this method to set the result of the computation to {@code value}.\n * This will set the state of the future to {@link OldAbstractFuture.Sync#COMPLETED} and invoke\n * the listeners if the state was successfully changed.\n *\n * @param value the value that was the result of the task.\n * @return true if the state was successfully changed.\n */\n", "repo_name": "guava-master/", "id": 3895, "method_signature": "boolean set(V)", "filename": "AbstractFutureBenchmarks.set.json"}
{"callee_method_ids": [5456], "callee_method_names": ["Sync.setException", "ExecutionList.execute"], "method_name": "AbstractFutureBenchmarks.setException", "method_implementation": "{\n    boolean result = sync.setException(checkNotNull(throwable));\n    if (result) {\n        executionList.execute();\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Subclasses should invoke this method to set the result of the computation to an error, {@code\n * throwable}. This will set the state of the future to {@link OldAbstractFuture.Sync#COMPLETED}\n * and invoke the listeners if the state was successfully changed.\n *\n * @param throwable the exception that the task failed with.\n * @return true if the state was successfully changed.\n */\n", "repo_name": "guava-master/", "id": 3896, "method_signature": "boolean setException(Throwable)", "filename": "AbstractFutureBenchmarks.setException.json"}
{"callee_method_names": [], "method_name": "AbstractFutureBenchmarks.tryAcquireShared", "method_implementation": "{\n    if (isDone()) {\n        return 1;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/*\n       * Acquisition succeeds if the future is done, otherwise it fails.\n       */\n", "repo_name": "guava-master/", "id": 3897, "method_signature": "int tryAcquireShared(int)", "filename": "AbstractFutureBenchmarks.tryAcquireShared.json"}
{"callee_method_names": [], "method_name": "AbstractFutureBenchmarks.tryReleaseShared", "method_implementation": "{\n    setState(finalState);\n    return true;\n}", "repo_id": "5", "comment": "/*\n       * We always allow a release to go through, this means the state has been\n       * successfully changed and the result is available.\n       */\n", "repo_name": "guava-master/", "id": 3898, "method_signature": "boolean tryReleaseShared(int)", "filename": "AbstractFutureBenchmarks.tryReleaseShared.json"}
{"callee_method_names": ["Thread.interrupt", "HashSet.clear", "Impl.newFacade", "Facade<Object>.get", "Thread.start", "HashSet.add", "Facade<Object>.addListener", "Facade<Object>.set", "Facade<Object>.cancel", "Facade<Object>.setException"], "method_name": "AbstractFutureFootprintBenchmark.measureSize", "method_implementation": "{\n    for (Thread thread : blockedThreads) {\n        thread.interrupt();\n    }\n    blockedThreads.clear();\n    final Facade<Object> f = impl.newFacade();\n    for (int i = 0; i < numThreads; i++) {\n        Thread thread = new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    f.get();\n                } catch (Throwable expected) {\n                }\n            }\n        };\n        thread.start();\n        blockedThreads.add(thread);\n    }\n    for (int i = 0; i < numListeners; i++) {\n        f.addListener(Runnables.doNothing(), directExecutor());\n    }\n    for (Thread thread : blockedThreads) {\n        AbstractFutureBenchmarks.awaitWaiting(thread);\n    }\n    switch(state) {\n        case NOT_DONE:\n            break;\n        case FINISHED:\n            f.set(null);\n            break;\n        case CANCELLED:\n            f.cancel(false);\n            break;\n        case FAILED:\n            f.setException(new Exception());\n            break;\n        default:\n            throw new AssertionError();\n    }\n    return f;\n}", "repo_id": "5", "comment": "// larger than they are.\n", "repo_name": "guava-master/", "id": 3523, "method_signature": "Object measureSize()", "filename": "AbstractFutureFootprintBenchmark.measureSize.json"}
{"callee_method_names": [], "method_name": "AbstractFutureTest.sneakyThrow", "method_implementation": "{\n    class SneakyThrower<T extends Throwable> {\n\n        // intentionally unsafe for test\n        @SuppressWarnings(\"unchecked\")\n        void throwIt(Throwable t) throws T {\n            throw (T) t;\n        }\n    }\n    new SneakyThrower<Error>().throwIt(t);\n}", "repo_id": "5", "comment": "/**\n * Throws an undeclared checked exception.\n */\n", "repo_name": "guava-master/", "id": 3760, "method_signature": "void sneakyThrow(Throwable)", "filename": "AbstractFutureTest.sneakyThrow.json"}
{"callee_method_names": ["AbstractFuture<String>.set", "Thread.start", "AbstractFuture<String>.get", "AbstractFuture<String>.addListener", "AtomicBoolean.set", "AtomicBoolean.get", "Thread.interrupt", "Thread.join"], "method_name": "AbstractFutureTest.testListenersExecuteImmediately_afterWaiterWakesUp", "method_implementation": "{\n    final AbstractFuture<String> f = new AbstractFuture<String>() {\n\n        @Override\n        protected void afterDone() {\n            // this simply delays executing listeners\n            try {\n                Thread.sleep(TimeUnit.SECONDS.toMillis(10));\n            } catch (InterruptedException ignored) {\n                // preserve status\n                Thread.currentThread().interrupt();\n            }\n        }\n    };\n    Thread t = new Thread() {\n\n        @Override\n        public void run() {\n            f.set(\"foo\");\n        }\n    };\n    t.start();\n    f.get();\n    final AtomicBoolean ranImmediately = new AtomicBoolean();\n    f.addListener(new Runnable() {\n\n        @Override\n        public void run() {\n            ranImmediately.set(true);\n        }\n    }, MoreExecutors.directExecutor());\n    assertThat(ranImmediately.get()).isTrue();\n    t.interrupt();\n    t.join();\n}", "repo_id": "5", "comment": "// this would be observable from a waiter that was just unblocked.\n", "repo_name": "guava-master/", "id": 3759, "method_signature": "void testListenersExecuteImmediately_afterWaiterWakesUp()", "filename": "AbstractFutureTest.testListenersExecuteImmediately_afterWaiterWakesUp.json"}
{"callee_method_names": ["AtomicBoolean.set", "AtomicBoolean.get", "AbstractFuture<String>.set"], "method_name": "AbstractFutureTest.testListenersExecuteImmediately_fromAfterDone", "method_implementation": "{\n    AbstractFuture<String> f = new AbstractFuture<String>() {\n\n        @Override\n        protected void afterDone() {\n            final AtomicBoolean ranImmediately = new AtomicBoolean();\n            addListener(new Runnable() {\n\n                @Override\n                public void run() {\n                    ranImmediately.set(true);\n                }\n            }, MoreExecutors.directExecutor());\n            assertThat(ranImmediately.get()).isTrue();\n        }\n    };\n    f.set(\"foo\");\n}", "repo_id": "5", "comment": "// this would be observable from an afterDone callback\n", "repo_name": "guava-master/", "id": 3758, "method_signature": "void testListenersExecuteImmediately_fromAfterDone()", "filename": "AbstractFutureTest.testListenersExecuteImmediately_fromAfterDone.json"}
{"callee_method_names": ["CyclicBarrier.getParties", "AtomicBoolean.set", "AtomicReference<AbstractFuture<String>>.get", "AtomicReference<AbstractFuture<String>>.get", "AtomicBoolean.set", "AtomicReference<AbstractFuture<String>>.get", "AtomicBoolean.set", "AbstractFuture<String>.set", "AtomicReference<AbstractFuture<String>>.get", "Set<Object>.add", "Set<Object>.add", "IOException.getCause", "Set<Object>.add", "AtomicReference<AbstractFuture<String>>.get", "Set<Object>.add", "Set<Object>.add", "IOException.getCause", "Set<Object>.add", "List<Runnable>.add", "List<Runnable>.add", "List<Runnable>.add", "List<Runnable>.add", "AtomicReference<AbstractFuture<String>>.get", "List<Runnable>.size", "CyclicBarrier.getParties", "AtomicReference<AbstractFuture<String>>.set", "AtomicReference<AbstractFuture<String>>.set", "ExecutorService.execute", "AbstractFuture<String>.isDone", "AbstractFuture<String>.isCancelled", "AtomicBoolean.get", "AtomicBoolean.get", "AtomicBoolean.get", "AbstractFuture<String>.isCancelled", "AbstractFuture<String>.wasInterrupted", "AtomicBoolean.get", "AtomicBoolean.get", "AtomicBoolean.get", "AtomicBoolean.set", "AtomicBoolean.set", "AtomicBoolean.set", "Set<Object>.clear", "ExecutorService.shutdown"], "method_name": "AbstractFutureTest.testSetFutureCancelBash", "method_implementation": "{\n    if (isWindows()) {\n        // TODO: b/136041958 - Running very slowly on Windows CI.\n        return;\n    }\n    final int size = 50;\n    final CyclicBarrier barrier = new CyclicBarrier(// for the setter threads\n    2 + // for the listeners\n    size + // for the get threads,\n    size + // for the main thread\n    1);\n    final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());\n    final AtomicReference<AbstractFuture<String>> currentFuture = Atomics.newReference();\n    final AtomicReference<AbstractFuture<String>> setFutureFuture = Atomics.newReference();\n    final AtomicBoolean setFutureSetSuccess = new AtomicBoolean();\n    final AtomicBoolean setFutureCompletionSuccess = new AtomicBoolean();\n    final AtomicBoolean cancellationSuccess = new AtomicBoolean();\n    Runnable cancelRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            cancellationSuccess.set(currentFuture.get().cancel(true));\n            awaitUnchecked(barrier);\n        }\n    };\n    Runnable setFutureCompleteSuccessfullyRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            AbstractFuture<String> future = setFutureFuture.get();\n            setFutureSetSuccess.set(currentFuture.get().setFuture(future));\n            setFutureCompletionSuccess.set(future.set(\"hello-async-world\"));\n            awaitUnchecked(barrier);\n        }\n    };\n    final Set<Object> finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());\n    Runnable collectResultsRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            try {\n                String result = Uninterruptibles.getUninterruptibly(currentFuture.get());\n                finalResults.add(result);\n            } catch (ExecutionException e) {\n                finalResults.add(e.getCause());\n            } catch (CancellationException e) {\n                finalResults.add(CancellationException.class);\n            } finally {\n                awaitUnchecked(barrier);\n            }\n        }\n    };\n    Runnable collectResultsTimedGetRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            Future<String> future = currentFuture.get();\n            while (true) {\n                try {\n                    String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);\n                    finalResults.add(result);\n                    break;\n                } catch (ExecutionException e) {\n                    finalResults.add(e.getCause());\n                    break;\n                } catch (CancellationException e) {\n                    finalResults.add(CancellationException.class);\n                    break;\n                } catch (TimeoutException e) {\n                    // loop\n                }\n            }\n            awaitUnchecked(barrier);\n        }\n    };\n    List<Runnable> allTasks = new ArrayList<>();\n    allTasks.add(cancelRunnable);\n    allTasks.add(setFutureCompleteSuccessfullyRunnable);\n    for (int k = 0; k < size; k++) {\n        // For each listener we add a task that submits it to the executor directly for the blocking\n        // get use case and another task that adds it as a listener to the future to exercise both\n        // racing addListener calls and addListener calls completing after the future completes.\n        final Runnable listener = k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;\n        allTasks.add(listener);\n        allTasks.add(new Runnable() {\n\n            @Override\n            public void run() {\n                currentFuture.get().addListener(listener, executor);\n            }\n        });\n    }\n    // sanity check\n    assertEquals(allTasks.size() + 1, barrier.getParties());\n    for (int i = 0; i < 1000; i++) {\n        Collections.shuffle(allTasks);\n        final AbstractFuture<String> future = new AbstractFuture<String>() {\n        };\n        final AbstractFuture<String> setFuture = new AbstractFuture<String>() {\n        };\n        currentFuture.set(future);\n        setFutureFuture.set(setFuture);\n        for (Runnable task : allTasks) {\n            executor.execute(task);\n        }\n        awaitUnchecked(barrier);\n        assertThat(future.isDone()).isTrue();\n        // inspect state and ensure it is correct!\n        // asserts that all get calling threads received the same value\n        Object result = Iterables.getOnlyElement(finalResults);\n        if (result == CancellationException.class) {\n            assertTrue(future.isCancelled());\n            assertTrue(cancellationSuccess.get());\n            // cancellation can interleave in 3 ways\n            // 1. prior to setFuture\n            // 2. after setFuture before set() on the future assigned\n            // 3. after setFuture and set() are called but before the listener completes.\n            if (!setFutureSetSuccess.get() || !setFutureCompletionSuccess.get()) {\n                // If setFuture fails or set on the future fails then it must be because that future was\n                // cancelled\n                assertTrue(setFuture.isCancelled());\n                // we only call cancel(true)\n                assertTrue(setFuture.wasInterrupted());\n            }\n        } else {\n            // set on the future completed\n            assertFalse(cancellationSuccess.get());\n            assertTrue(setFutureSetSuccess.get());\n            assertTrue(setFutureCompletionSuccess.get());\n        }\n        // reset for next iteration\n        setFutureSetSuccess.set(false);\n        setFutureCompletionSuccess.set(false);\n        cancellationSuccess.set(false);\n        finalResults.clear();\n    }\n    executor.shutdown();\n}", "repo_id": "5", "comment": "// setFuture and cancel() interact in more complicated ways than the other setters.\n", "repo_name": "guava-master/", "id": 3754, "method_signature": "void testSetFutureCancelBash()", "filename": "AbstractFutureTest.testSetFutureCancelBash.json"}
{"callee_method_names": ["CyclicBarrier.getParties", "AtomicBoolean.set", "AtomicReference<AbstractFuture<String>>.get", "AtomicBoolean.set", "AtomicReference<AbstractFuture<String>>.get", "AtomicReference<AbstractFuture<String>>.get", "Set<Object>.add", "Set<Object>.add", "IOException.getCause", "Set<Object>.add", "List<Callable<?>>.add", "List<Callable<?>>.add", "List<Callable<?>>.add", "List<Callable<?>>.size", "CyclicBarrier.getParties", "AtomicReference<AbstractFuture<String>>.set", "ExecutorService.submit", "AbstractFuture<String>.isDone", "AbstractFuture<String>.isCancelled", "AtomicBoolean.get", "AtomicBoolean.get", "AtomicBoolean.get", "AtomicBoolean.get", "AtomicBoolean.set", "AtomicBoolean.set", "Set<Object>.clear", "ExecutorService.shutdown"], "method_name": "AbstractFutureTest.testSetFutureCancelBash_withDoneFuture", "method_implementation": "{\n    final CyclicBarrier barrier = new CyclicBarrier(// for the setter threads\n    2 + // for the blocking get thread,\n    1 + // for the main thread\n    1);\n    final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());\n    final AtomicReference<AbstractFuture<String>> currentFuture = Atomics.newReference();\n    final AtomicBoolean setFutureSuccess = new AtomicBoolean();\n    final AtomicBoolean cancellationSuccess = new AtomicBoolean();\n    Callable<@Nullable Void> cancelRunnable = new Callable<@Nullable Void>() {\n\n        @Override\n        @Nullable\n        public Void call() {\n            cancellationSuccess.set(currentFuture.get().cancel(true));\n            awaitUnchecked(barrier);\n            return null;\n        }\n    };\n    Callable<@Nullable Void> setFutureCompleteSuccessfullyRunnable = new Callable<@Nullable Void>() {\n\n        final ListenableFuture<String> future = Futures.immediateFuture(\"hello\");\n\n        @Override\n        @Nullable\n        public Void call() {\n            setFutureSuccess.set(currentFuture.get().setFuture(future));\n            awaitUnchecked(barrier);\n            return null;\n        }\n    };\n    final Set<Object> finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());\n    final Runnable collectResultsRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            try {\n                String result = Uninterruptibles.getUninterruptibly(currentFuture.get());\n                finalResults.add(result);\n            } catch (ExecutionException e) {\n                finalResults.add(e.getCause());\n            } catch (CancellationException e) {\n                finalResults.add(CancellationException.class);\n            } finally {\n                awaitUnchecked(barrier);\n            }\n        }\n    };\n    List<Callable<?>> allTasks = new ArrayList<>();\n    allTasks.add(cancelRunnable);\n    allTasks.add(setFutureCompleteSuccessfullyRunnable);\n    allTasks.add(Executors.callable(collectResultsRunnable));\n    // sanity check\n    assertEquals(allTasks.size() + 1, barrier.getParties());\n    for (int i = 0; i < 1000; i++) {\n        Collections.shuffle(allTasks);\n        final AbstractFuture<String> future = new AbstractFuture<String>() {\n        };\n        currentFuture.set(future);\n        for (Callable<?> task : allTasks) {\n            // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n            @SuppressWarnings(\"unused\")\n            Future<?> possiblyIgnoredError = executor.submit(task);\n        }\n        awaitUnchecked(barrier);\n        assertThat(future.isDone()).isTrue();\n        // inspect state and ensure it is correct!\n        // asserts that all get calling threads received the same value\n        Object result = Iterables.getOnlyElement(finalResults);\n        if (result == CancellationException.class) {\n            assertTrue(future.isCancelled());\n            assertTrue(cancellationSuccess.get());\n            assertFalse(setFutureSuccess.get());\n        } else {\n            assertTrue(setFutureSuccess.get());\n            assertFalse(cancellationSuccess.get());\n        }\n        // reset for next iteration\n        setFutureSuccess.set(false);\n        cancellationSuccess.set(false);\n        finalResults.clear();\n    }\n    executor.shutdown();\n}", "repo_id": "5", "comment": "// return true.\n", "repo_name": "guava-master/", "id": 3755, "method_signature": "void testSetFutureCancelBash_withDoneFuture()", "filename": "AbstractFutureTest.testSetFutureCancelBash_withDoneFuture.json"}
{"callee_method_names": ["SettableFuture<String>.setFuture", "SettableFuture<String>.toString"], "method_name": "AbstractFutureTest.testSetFutureToString_stackOverflow", "method_implementation": "{\n    SettableFuture<String> orig = SettableFuture.create();\n    SettableFuture<String> prev = orig;\n    for (int i = 0; i < 100000; i++) {\n        SettableFuture<String> curr = SettableFuture.create();\n        prev.setFuture(curr);\n        prev = curr;\n    }\n    // orig represents the 'outermost' future\n    assertThat(orig.toString()).contains(\"Exception thrown from implementation: class java.lang.StackOverflowError\");\n}", "repo_id": "5", "comment": "// call to fail\n", "repo_name": "guava-master/", "id": 3757, "method_signature": "void testSetFutureToString_stackOverflow()", "filename": "AbstractFutureTest.testSetFutureToString_stackOverflow.json"}
{"callee_method_names": ["SettableFuture<String>.setFuture", "SettableFuture<String>.set", "SettableFuture<String>.isDone"], "method_name": "AbstractFutureTest.testSetFuture_stackOverflow", "method_implementation": "{\n    SettableFuture<String> orig = SettableFuture.create();\n    SettableFuture<String> prev = orig;\n    for (int i = 0; i < 100000; i++) {\n        SettableFuture<String> curr = SettableFuture.create();\n        prev.setFuture(curr);\n        prev = curr;\n    }\n    // prev represents the 'innermost' future\n    prev.set(\"done\");\n    assertTrue(orig.isDone());\n}", "repo_id": "5", "comment": "// together.  Now it should only be limited by available memory (and time)\n", "repo_name": "guava-master/", "id": 3756, "method_signature": "void testSetFuture_stackOverflow()", "filename": "AbstractFutureTest.testSetFuture_stackOverflow.json"}
{"callee_method_names": ["TimedWaiterThread.start", "TimedWaiterThread.awaitWaiting", "TimedWaiterThread.suspend", "TimedWaiterThread.setPriority", "TimedWaiterThread.resume", "TimedWaiterThread.join"], "method_name": "AbstractFutureTest.testToString_delayedTimeout", "method_implementation": "{\n    Integer javaVersion = Ints.tryParse(JAVA_SPECIFICATION_VERSION.value());\n    // Parsing to an integer might fail because Java 8 returns \"1.8\" instead of \"8.\"\n    // We can continue if it's 1.8, and we can continue if it's an integer in [9, 20).\n    if (javaVersion != null && javaVersion >= 20) {\n        // TODO(b/261217224): Make this test work under newer JDKs.\n        return;\n    }\n    TimedWaiterThread thread = new TimedWaiterThread(new AbstractFuture<Object>() {\n    }, 2, TimeUnit.SECONDS);\n    thread.start();\n    thread.awaitWaiting();\n    thread.suspend();\n    // Sleep for enough time to add 1500 milliseconds of overwait to the get() call.\n    long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);\n    Thread.sleep(toWaitMillis);\n    thread.setPriority(Thread.MAX_PRIORITY);\n    thread.resume();\n    thread.join();\n    // It's possible to race and suspend the thread just before the park call actually takes effect,\n    // causing the thread to be suspended for 3.5 seconds, and then park itself for 2 seconds after\n    // being resumed. To avoid a flake in this scenario, calculate how long that thread actually\n    // waited and assert based on that time. Empirically, the race where the thread ends up waiting\n    // for 5.5 seconds happens about 2% of the time.\n    boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) >= 5;\n    // Count how long it actually took to return; we'll accept any number between the expected delay\n    // and the approximate actual delay, to be robust to variance in thread scheduling.\n    char overWaitNanosFirstDigit = Long.toString(thread.timeSpentBlocked - TimeUnit.MILLISECONDS.toNanos(longWait ? 5000 : 3000)).charAt(0);\n    if (overWaitNanosFirstDigit < '4') {\n        overWaitNanosFirstDigit = '9';\n    }\n    String nanosRegex = \"[4-\" + overWaitNanosFirstDigit + \"][0-9]+\";\n    assertWithMessage(\"Spent \" + thread.timeSpentBlocked + \" ns blocked; slept for \" + toWaitMillis + \" ms\").that(thread.exception).hasMessageThat().matches(\"Waited 2 seconds \\\\(plus \" + (longWait ? \"3\" : \"1\") + \" seconds, \" + nanosRegex + \" nanoseconds delay\\\\).*\");\n}", "repo_id": "5", "comment": "/**\n * This test attempts to cause a future to wait for longer than it was requested to from a timed\n * get() call. As measurements of time are prone to flakiness, it tries to assert based on ranges\n * derived from observing how much time actually passed for various operations.\n */\n", "repo_name": "guava-master/", "id": 3753, "method_signature": "void testToString_delayedTimeout()", "filename": "AbstractFutureTest.testToString_delayedTimeout.json"}
{"callee_method_names": [], "method_name": "AbstractGraph.toString", "method_implementation": "{\n    return \"isDirected: \" + isDirected() + \", allowsSelfLoops: \" + allowsSelfLoops() + \", nodes: \" + nodes() + \", edges: \" + edges();\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this graph.\n */\n", "repo_name": "guava-master/", "id": 6763, "method_signature": "String toString()", "filename": "AbstractGraph.toString.json"}
{"callee_method_names": ["String.hashCode", "String.hashCode", "List<CountsHashCodeAndEquals>.get", "List<CountsHashCodeAndEquals>.get", "List<CountsHashCodeAndEquals>.size"], "method_name": "AbstractHashFloodingTest.createAdversarialInput", "method_implementation": "{\n    String str1 = \"Aa\";\n    String str2 = \"BB\";\n    assertEquals(str1.hashCode(), str2.hashCode());\n    List<String> haveSameHashes2 = Arrays.asList(str1, str2);\n    List<CountsHashCodeAndEquals> result = Lists.newArrayList(Lists.transform(Lists.cartesianProduct(Collections.nCopies(power, haveSameHashes2)), strs -> new CountsHashCodeAndEquals(String.join(\"\", strs), () -> counter.hashCode++, () -> counter.equals++, () -> counter.compareTo++)));\n    assertEquals(result.get(0).delegateString.hashCode(), result.get(result.size() - 1).delegateString.hashCode());\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a list of objects with the same hash code, of size 2^power, counting calls to equals,\n * hashCode, and compareTo in counter.\n */\n", "repo_name": "guava-master/", "id": 520, "method_signature": "List<CountsHashCodeAndEquals> createAdversarialInput(int, CallsCounter)", "filename": "AbstractHashFloodingTest.createAdversarialInput.json"}
{"callee_method_names": ["DelegateService.startAsync"], "method_name": "AbstractIdleService.startAsync", "method_implementation": "{\n    delegate.startAsync();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5238, "method_signature": "Service startAsync()", "filename": "AbstractIdleService.startAsync.json"}
{"callee_method_names": ["DelegateService.stopAsync"], "method_name": "AbstractIdleService.stopAsync", "method_implementation": "{\n    delegate.stopAsync();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5239, "method_signature": "Service stopAsync()", "filename": "AbstractIdleService.stopAsync.json"}
{"callee_method_names": ["ImmutableList<ImmutableSet<String>>.size"], "method_name": "AbstractImmutableSetTest.testCopyOf_threadSafe", "method_implementation": "{\n    /*\n     * The actual collections that we pass as inputs will be wrappers around these, so\n     * ImmutableSet.copyOf won't short-circuit because it won't see an ImmutableSet input.\n     */\n    ImmutableList<ImmutableSet<String>> distinctCandidatesByAscendingSize = ImmutableList.of(ImmutableSet.of(), ImmutableSet.of(\"a\"), ImmutableSet.of(\"b\", \"a\"), ImmutableSet.of(\"c\", \"b\", \"a\"), ImmutableSet.of(\"d\", \"c\", \"b\", \"a\"));\n    for (boolean byAscendingSize : new boolean[] { true, false }) {\n        Iterable<ImmutableSet<String>> infiniteSets = Iterables.cycle(byAscendingSize ? distinctCandidatesByAscendingSize : Lists.reverse(distinctCandidatesByAscendingSize));\n        for (int startIndex = 0; startIndex < distinctCandidatesByAscendingSize.size(); startIndex++) {\n            Iterable<ImmutableSet<String>> infiniteSetsFromStartIndex = Iterables.skip(infiniteSets, startIndex);\n            for (boolean inputIsSet : new boolean[] { true, false }) {\n                Collection<String> input = inputIsSet ? new MutatedOnQuerySet<>(infiniteSetsFromStartIndex) : new MutatedOnQueryList<>(Iterables.transform(infiniteSetsFromStartIndex, ImmutableList::copyOf));\n                Set<String> immutableCopy;\n                try {\n                    immutableCopy = copyOf(input);\n                } catch (RuntimeException e) {\n                    throw new RuntimeException(Strings.lenientFormat(\"byAscendingSize %s, startIndex %s, inputIsSet %s\", byAscendingSize, startIndex, inputIsSet), e);\n                }\n                /*\n           * TODO(cpovirk): Check that the values match one of candidates that\n           * MutatedOnQuery*.delegate() actually returned during this test?\n           */\n                assertWithMessage(\"byAscendingSize %s, startIndex %s, inputIsSet %s\", byAscendingSize, startIndex, inputIsSet).that(immutableCopy).isIn(distinctCandidatesByAscendingSize);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Verify thread safety by using a collection whose size() may be inconsistent with the actual\n * number of elements and whose elements may change over time.\n *\n * <p>This test might fail in GWT because the GWT emulations might count on the input collection\n * not to change during the copy. It is safe to do so in GWT because javascript is\n * single-threaded.\n */\n", "repo_name": "guava-master/", "id": 3938, "method_signature": "void testCopyOf_threadSafe()", "filename": "AbstractImmutableSetTest.testCopyOf_threadSafe.json"}
{"callee_method_names": ["Method.getName", "Method.getName", "Method.getParameterTypes", "Object.getClass", "Method.getName"], "method_name": "AbstractInvocationHandler.invoke", "method_implementation": "{\n    if (args == null) {\n        args = NO_ARGS;\n    }\n    if (args.length == 0 && method.getName().equals(\"hashCode\")) {\n        return hashCode();\n    }\n    if (args.length == 1 && method.getName().equals(\"equals\") && method.getParameterTypes()[0] == Object.class) {\n        Object arg = args[0];\n        if (arg == null) {\n            return false;\n        }\n        if (proxy == arg) {\n            return true;\n        }\n        return isProxyOfSameInterfaces(arg, proxy.getClass()) && equals(Proxy.getInvocationHandler(arg));\n    }\n    if (args.length == 0 && method.getName().equals(\"toString\")) {\n        return toString();\n    }\n    return handleInvocation(proxy, method, args);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <ul>\n *   <li>{@code proxy.hashCode()} delegates to {@link AbstractInvocationHandler#hashCode}\n *   <li>{@code proxy.toString()} delegates to {@link AbstractInvocationHandler#toString}\n *   <li>{@code proxy.equals(argument)} returns true if:\n *       <ul>\n *         <li>{@code proxy} and {@code argument} are of the same type\n *         <li>and {@link AbstractInvocationHandler#equals} returns true for the {@link\n *             InvocationHandler} of {@code argument}\n *       </ul>\n *   <li>other method calls are dispatched to {@link #handleInvocation}.\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 4667, "method_signature": "Object invoke(Object, Method, Object[])", "filename": "AbstractInvocationHandler.invoke.json"}
{"callee_method_names": [], "method_name": "AbstractIterator.endOfData", "method_implementation": "{\n    state = State.DONE;\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Implementations of {@link #computeNext} <b>must</b> invoke this method when there are no\n * elements left in the iteration.\n *\n * @return {@code null}; a convenience so your {@code computeNext} implementation can use the\n *     simple statement {@code return endOfData();}\n */\n", "repo_name": "guava-master/", "id": 6418, "method_signature": "T endOfData()", "filename": "AbstractIterator.endOfData.json"}
{"callee_method_names": [], "method_name": "AbstractIterator.peek", "method_implementation": "{\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Safe because hasNext() ensures that tryToComputeNext() has put a T into `next`.\n    return uncheckedCastNullableTToT(next);\n}", "repo_id": "5", "comment": "/**\n * Returns the next element in the iteration without advancing the iteration, according to the\n * contract of {@link PeekingIterator#peek()}.\n *\n * <p>Implementations of {@code AbstractIterator} that wish to expose this functionality should\n * implement {@code PeekingIterator}.\n */\n", "repo_name": "guava-master/", "id": 6419, "method_signature": "T peek()", "filename": "AbstractIterator.peek.json"}
{"callee_method_names": [], "method_name": "AbstractIteratorTest.sneakyThrow", "method_implementation": "{\n    class SneakyThrower<T extends Throwable> {\n\n        // not really safe, but that's the point\n        @SuppressWarnings(\"unchecked\")\n        void throwIt(Throwable t) throws T {\n            throw (T) t;\n        }\n    }\n    new SneakyThrower<Error>().throwIt(t);\n}", "repo_id": "5", "comment": "/**\n * Throws an undeclared checked exception.\n */\n", "repo_name": "guava-master/", "id": 3968, "method_signature": "void sneakyThrow(Throwable)", "filename": "AbstractIteratorTest.sneakyThrow.json"}
{"callee_method_ids": [4159], "callee_method_names": ["IteratorOperation.execute", "MultiExceptionListIterator.promoteToNext", "IteratorOperation.execute", "E.getMessage", "PermittedMetaException.assertPermitted"], "method_name": "AbstractIteratorTester.internalExecuteAndCompare", "method_implementation": "{\n    Object referenceReturnValue = null;\n    PermittedMetaException referenceException = null;\n    Object targetReturnValue = null;\n    Exception targetException = null;\n    try {\n        targetReturnValue = method.execute(target);\n    } catch (Exception e) {\n        // sneaky checked exception\n        targetException = e;\n    }\n    try {\n        if (method == NEXT_METHOD && targetException == null && knownOrder == KnownOrder.UNKNOWN_ORDER) {\n            /*\n         * We already know the iterator is an Iterator<E>, and now we know that\n         * we called next(), so the returned element must be of type E.\n         */\n            @SuppressWarnings(\"unchecked\")\n            E targetReturnValueFromNext = (E) targetReturnValue;\n            /*\n         * We have an Iterator<E> and want to cast it to\n         * MultiExceptionListIterator. Because we're inside an\n         * AbstractIteratorTester<E>, that's implicitly a cast to\n         * AbstractIteratorTester<E>.MultiExceptionListIterator. The runtime\n         * won't be able to verify the AbstractIteratorTester<E> part, so it's\n         * an unchecked cast. We know, however, that the only possible value for\n         * the type parameter is <E>, since otherwise the\n         * MultiExceptionListIterator wouldn't be an Iterator<E>. The cast is\n         * safe, even though javac can't tell.\n         *\n         * Sun bug 6665356 is an additional complication. Until OpenJDK 7, javac\n         * doesn't recognize this kind of cast as unchecked cast. Neither does\n         * Eclipse 3.4. Right now, this suppression is mostly unnecessary.\n         */\n            MultiExceptionListIterator multiExceptionListIterator = (MultiExceptionListIterator) reference;\n            multiExceptionListIterator.promoteToNext(targetReturnValueFromNext);\n        }\n        referenceReturnValue = method.execute(reference);\n    } catch (PermittedMetaException e) {\n        referenceException = e;\n    } catch (UnknownElementException e) {\n        Helpers.fail(e, e.getMessage());\n    }\n    if (referenceException == null) {\n        if (targetException != null) {\n            Helpers.fail(targetException, \"Target threw exception when reference did not\");\n        }\n        /*\n       * Reference iterator returned a value, so we should expect the\n       * same value from the target\n       */\n        assertEquals(referenceReturnValue, targetReturnValue);\n        return;\n    }\n    if (targetException == null) {\n        fail(\"Target failed to throw \" + referenceException);\n    }\n    /*\n     * Reference iterator threw an exception, so we should expect an acceptable\n     * exception from the target.\n     */\n    referenceException.assertPermitted(targetException);\n}", "repo_id": "5", "comment": "/**\n * Apply this method to both iterators and return normally only if both produce the same response.\n *\n * @see Stimulus#executeAndCompare(ListIterator, Iterator)\n */\n", "repo_name": "guava-master/", "id": 4158, "method_signature": "void internalExecuteAndCompare(T, T, IteratorOperation)", "filename": "AbstractIteratorTester.internalExecuteAndCompare.json"}
{"callee_method_names": ["Stack.remove", "Stack.push"], "method_name": "AbstractIteratorTester.promoteToNext", "method_implementation": "{\n    if (nextElements.remove(e)) {\n        nextElements.push(e);\n    } else {\n        throw new UnknownElementException(nextElements, e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Moves the given element from its current position in {@link #nextElements} to the top of the\n * stack so that it is returned by the next call to {@link Iterator#next()}. If the element is\n * not in {@link #nextElements}, this method throws an {@link UnknownElementException}.\n *\n * <p>This method is used when testing iterators without a known ordering. We poll the target\n * iterator's next element and pass it to the reference iterator through this method so it can\n * return the same element. This enables the assertion to pass and the reference iterator to\n * properly update its state.\n */\n", "repo_name": "guava-master/", "id": 4156, "method_signature": "void promoteToNext(E)", "filename": "AbstractIteratorTester.promoteToNext.json"}
{"callee_method_names": [], "method_name": "AbstractIteratorTester.test", "method_implementation": "{\n    try {\n        recurse(0);\n    } catch (Exception e) {\n        // sneaky checked exception\n        throw new RuntimeException(Arrays.toString(stimuli), e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Executes the test.\n */\n", "repo_name": "guava-master/", "id": 4157, "method_signature": "void test()", "filename": "AbstractIteratorTester.test.json"}
{"callee_method_names": [], "method_name": "AbstractListMultimap.put", "method_implementation": "{\n    return super.put(key, value);\n}", "repo_id": "5", "comment": "/**\n * Stores a key-value pair in the multimap.\n *\n * @param key key to store in the multimap\n * @param value value to store in the multimap\n * @return {@code true} always\n */\n", "repo_name": "guava-master/", "id": 6006, "method_signature": "boolean put(K, V)", "filename": "AbstractListMultimap.put.json"}
{"callee_method_names": [], "method_name": "AbstractListMultimap.removeAll", "method_implementation": "{\n    return (List<V>) super.removeAll(key);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Because the values for a given key may have duplicates and follow the insertion ordering,\n * this method returns a {@link List}, instead of the {@link Collection} specified in the {@link\n * Multimap} interface.\n */\n", "repo_name": "guava-master/", "id": 6004, "method_signature": "List<V> removeAll(Object)", "filename": "AbstractListMultimap.removeAll.json"}
{"callee_method_names": [], "method_name": "AbstractListMultimap.replaceValues", "method_implementation": "{\n    return (List<V>) super.replaceValues(key, values);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Because the values for a given key may have duplicates and follow the insertion ordering,\n * this method returns a {@link List}, instead of the {@link Collection} specified in the {@link\n * Multimap} interface.\n */\n", "repo_name": "guava-master/", "id": 6005, "method_signature": "List<V> replaceValues(K, Iterable)", "filename": "AbstractListMultimap.replaceValues.json"}
{"callee_method_names": ["List<E>.size", "List<E>.size", "List<E>.get", "E.equals"], "method_name": "AbstractListTester.expectContents", "method_implementation": "{\n    List<E> expectedList = Helpers.copyToList(expectedCollection);\n    // Avoid expectEquals() here to delay reason manufacture until necessary.\n    if (getList().size() != expectedList.size()) {\n        fail(\"size mismatch: \" + reportContext(expectedList));\n    }\n    for (int i = 0; i < expectedList.size(); i++) {\n        E expected = expectedList.get(i);\n        E actual = getList().get(i);\n        if (expected != actual && (expected == null || !expected.equals(actual))) {\n            fail(\"mismatch at index \" + i + \": \" + reportContext(expectedList));\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>The {@code AbstractListTester} implementation overrides {@link\n * AbstractCollectionTester#expectContents(Collection)} to verify that the order of the elements\n * in the list under test matches what is expected.\n */\n", "repo_name": "guava-master/", "id": 4194, "method_signature": "void expectContents(Collection)", "filename": "AbstractListTester.expectContents.json"}
{"callee_method_names": ["CountDownLatch.countDown", "ListenableFuture<Boolean>.addListener", "ListenableFuture<Boolean>.get", "CountDownLatch.await", "ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "AbstractListenableFutureTest.testAllListenersCompleteSuccessfully", "method_implementation": "{\n    ExecutorService exec = Executors.newCachedThreadPool();\n    int listenerCount = 20;\n    CountDownLatch listenerLatch = new CountDownLatch(listenerCount);\n    // Test that listeners added both before and after the value is available\n    // get called correctly.\n    for (int i = 0; i < 20; i++) {\n        // Right in the middle start up a thread to close the latch.\n        if (i == 10) {\n            new Thread(() -> latch.countDown()).start();\n        }\n        future.addListener(listenerLatch::countDown, exec);\n    }\n    assertSame(Boolean.TRUE, future.get());\n    // Wait for the listener latch to complete.\n    listenerLatch.await(500, MILLISECONDS);\n    exec.shutdown();\n    exec.awaitTermination(500, MILLISECONDS);\n}", "repo_id": "5", "comment": "/**\n * Tests that all listeners complete, even if they were added before or after the future was\n * finishing. Also acts as a concurrency test to make sure the locking is done correctly when a\n * future is finishing so that no listeners can be lost.\n */\n", "repo_name": "guava-master/", "id": 4149, "method_signature": "void testAllListenersCompleteSuccessfully()", "filename": "AbstractListenableFutureTest.testAllListenersCompleteSuccessfully.json"}
{"callee_method_names": ["ListenableFuture<Boolean>.isDone", "ListenableFuture<Boolean>.isCancelled", "CountDownLatch.countDown", "ListenableFuture<Boolean>.isDone", "ListenableFuture<Boolean>.isCancelled", "ListenableFuture<Boolean>.cancel", "ListenableFuture<Boolean>.isDone", "ListenableFuture<Boolean>.isCancelled", "CountDownLatch.await", "CountDownLatch.countDown"], "method_name": "AbstractListenableFutureTest.testCanceledFutureThrowsCancellation", "method_implementation": "{\n    assertFalse(future.isDone());\n    assertFalse(future.isCancelled());\n    CountDownLatch successLatch = new CountDownLatch(1);\n    // Run cancellation in a separate thread as an extra thread-safety test.\n    new Thread(() -> {\n        assertThrows(CancellationException.class, future::get);\n        successLatch.countDown();\n    }).start();\n    assertFalse(future.isDone());\n    assertFalse(future.isCancelled());\n    future.cancel(true);\n    assertTrue(future.isDone());\n    assertTrue(future.isCancelled());\n    assertTrue(successLatch.await(200, MILLISECONDS));\n    latch.countDown();\n}", "repo_id": "5", "comment": "/**\n * Tests that a canceled future throws a cancellation exception.\n *\n * <p>This method checks the cancel, isCancelled, and isDone methods.\n */\n", "repo_name": "guava-master/", "id": 4148, "method_signature": "void testCanceledFutureThrowsCancellation()", "filename": "AbstractListenableFutureTest.testCanceledFutureThrowsCancellation.json"}
{"callee_method_names": ["ListenableFuture<Boolean>.isDone", "ListenableFuture<Boolean>.isCancelled", "ExecutorService.submit", "ListenableFuture<Boolean>.get", "CountDownLatch.countDown", "Future<Boolean>.get", "ExecutorService.shutdownNow", "ListenableFuture<Boolean>.isDone", "ListenableFuture<Boolean>.isCancelled"], "method_name": "AbstractListenableFutureTest.testGetBlocksUntilValueAvailable", "method_implementation": "{\n    assertFalse(future.isDone());\n    assertFalse(future.isCancelled());\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    try {\n        Future<Boolean> getResult = executor.submit(() -> future.get());\n        // Release the future value.\n        latch.countDown();\n        assertTrue(getResult.get(10, SECONDS));\n    } finally {\n        executor.shutdownNow();\n    }\n    assertTrue(future.isDone());\n    assertFalse(future.isCancelled());\n}", "repo_id": "5", "comment": "/**\n * Tests that the {@link Future#get()} method blocks until a value is available.\n */\n", "repo_name": "guava-master/", "id": 4146, "method_signature": "void testGetBlocksUntilValueAvailable()", "filename": "AbstractListenableFutureTest.testGetBlocksUntilValueAvailable.json"}
{"callee_method_names": ["ListenableFuture<Boolean>.get", "CountDownLatch.countDown"], "method_name": "AbstractListenableFutureTest.testTimeoutOnGetWorksCorrectly", "method_implementation": "{\n    // The task thread waits for the latch, so we expect a timeout here.\n    try {\n        future.get(20, MILLISECONDS);\n        fail(\"Should have timed out trying to get the value.\");\n    } catch (TimeoutException expected) {\n    } finally {\n        latch.countDown();\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests that the {@link Future#get(long, TimeUnit)} method times out correctly.\n */\n", "repo_name": "guava-master/", "id": 4147, "method_signature": "void testTimeoutOnGetWorksCorrectly()", "filename": "AbstractListenableFutureTest.testTimeoutOnGetWorksCorrectly.json"}
{"callee_method_names": [], "method_name": "AbstractListeningExecutorService.newTaskFor", "method_implementation": "{\n    return TrustedListenableFutureTask.create(callable);\n}", "repo_id": "5", "comment": "/**\n * @since 19.0 (present with return type {@code ListenableFutureTask} since 14.0)\n */\n", "repo_name": "guava-master/", "id": 5518, "method_signature": "RunnableFuture<T> newTaskFor(Callable)", "filename": "AbstractListeningExecutorService.newTaskFor.json"}
{"callee_method_ids": [5947], "callee_method_names": ["WrappedCollection.addToMap", "Map<K,Collection<V>>.put"], "method_name": "AbstractMapBasedMultimap.addToMap", "method_implementation": "{\n    if (ancestor != null) {\n        ancestor.addToMap();\n    } else {\n        map.put(key, delegate);\n    }\n}", "repo_id": "5", "comment": "/**\n * Add the delegate to the map. Other {@code WrappedCollection} methods should call this method\n * after adding elements to a previously empty collection.\n *\n * <p>Subcollection add the ancestor's delegate instead.\n */\n", "repo_name": "guava-master/", "id": 5940, "method_signature": "void addToMap()", "filename": "AbstractMapBasedMultimap.addToMap.json"}
{"callee_method_names": [], "method_name": "AbstractMapBasedMultimap.entryIterator", "method_implementation": "{\n    return new Itr<Entry<K, V>>() {\n\n        @Override\n        Entry<K, V> output(@ParametricNullness K key, @ParametricNullness V value) {\n            return Maps.immutableEntry(key, value);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an iterator across all key-value map entries, used by {@code entries().iterator()} and\n * {@code values().iterator()}. The default behavior, which traverses the values for one key, the\n * values for a second key, and so on, suffices for most {@code AbstractMapBasedMultimap}\n * implementations.\n *\n * @return an iterator across map entries\n */\n", "repo_name": "guava-master/", "id": 5943, "method_signature": "Iterator<Entry<K,V>> entryIterator()", "filename": "AbstractMapBasedMultimap.entryIterator.json"}
{"callee_method_names": ["Map<K,Collection<V>>.get"], "method_name": "AbstractMapBasedMultimap.get", "method_implementation": "{\n    Collection<V> collection = map.get(key);\n    if (collection == null) {\n        collection = createCollection(key);\n    }\n    return wrapCollection(key, collection);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>The returned collection is not serializable.\n */\n", "repo_name": "guava-master/", "id": 5937, "method_signature": "Collection<V> get(K)", "filename": "AbstractMapBasedMultimap.get.json"}
{"callee_method_names": [], "method_name": "AbstractMapBasedMultimap.keySet", "method_implementation": "{\n    SortedSet<K> result = sortedKeySet;\n    return (result == null) ? sortedKeySet = createKeySet() : result;\n}", "repo_id": "5", "comment": "// satisfy the SortedMap.keySet() interface\n", "repo_name": "guava-master/", "id": 5944, "method_signature": "SortedSet<K> keySet()", "filename": "AbstractMapBasedMultimap.keySet.json"}
{"callee_method_ids": [5945], "callee_method_names": ["WrappedCollection.refreshIfEmpty", "WrappedCollection.getDelegate", "Collection<V>.isEmpty", "Map<K,Collection<V>>.get"], "method_name": "AbstractMapBasedMultimap.refreshIfEmpty", "method_implementation": "{\n    if (ancestor != null) {\n        ancestor.refreshIfEmpty();\n        if (ancestor.getDelegate() != ancestorDelegate) {\n            throw new ConcurrentModificationException();\n        }\n    } else if (delegate.isEmpty()) {\n        Collection<V> newDelegate = map.get(key);\n        if (newDelegate != null) {\n            delegate = newDelegate;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * If the delegate collection is empty, but the multimap has values for the key, replace the\n * delegate with the new collection for the key.\n *\n * <p>For a subcollection, refresh its ancestor and validate that the ancestor delegate hasn't\n * changed.\n */\n", "repo_name": "guava-master/", "id": 5938, "method_signature": "void refreshIfEmpty()", "filename": "AbstractMapBasedMultimap.refreshIfEmpty.json"}
{"callee_method_names": ["Map<K,Collection<V>>.remove", "Collection<V>.addAll", "Collection<V>.size", "Collection<V>.clear"], "method_name": "AbstractMapBasedMultimap.removeAll", "method_implementation": "{\n    Collection<V> collection = map.remove(key);\n    if (collection == null) {\n        return createUnmodifiableEmptyCollection();\n    }\n    Collection<V> output = createCollection();\n    output.addAll(collection);\n    totalSize -= collection.size();\n    collection.clear();\n    return unmodifiableCollectionSubclass(output);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>The returned collection is immutable.\n */\n", "repo_name": "guava-master/", "id": 5936, "method_signature": "Collection<V> removeAll(Object)", "filename": "AbstractMapBasedMultimap.removeAll.json"}
{"callee_method_ids": [5946], "callee_method_names": ["WrappedCollection.removeIfEmpty", "Collection<V>.isEmpty", "Map<K,Collection<V>>.remove"], "method_name": "AbstractMapBasedMultimap.removeIfEmpty", "method_implementation": "{\n    if (ancestor != null) {\n        ancestor.removeIfEmpty();\n    } else if (delegate.isEmpty()) {\n        map.remove(key);\n    }\n}", "repo_id": "5", "comment": "/**\n * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}. For\n * subcollections, check whether the ancestor collection is empty.\n */\n", "repo_name": "guava-master/", "id": 5939, "method_signature": "void removeIfEmpty()", "filename": "AbstractMapBasedMultimap.removeIfEmpty.json"}
{"callee_method_names": ["Collection<V>.size", "Collection<V>.clear"], "method_name": "AbstractMapBasedMultimap.removeValuesForKey", "method_implementation": "{\n    Collection<V> collection = Maps.safeRemove(map, key);\n    if (collection != null) {\n        int count = collection.size();\n        collection.clear();\n        totalSize -= count;\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes all values for the provided key.\n */\n", "repo_name": "guava-master/", "id": 5942, "method_signature": "void removeValuesForKey(Object)", "filename": "AbstractMapBasedMultimap.removeValuesForKey.json"}
{"callee_method_names": ["Iterable<? extends V>.iterator", "Iterator<? extends V>.hasNext", "Collection<V>.addAll", "Collection<V>.size", "Collection<V>.clear", "Iterator<? extends V>.hasNext", "Collection<V>.add", "Iterator<? extends V>.next"], "method_name": "AbstractMapBasedMultimap.replaceValues", "method_implementation": "{\n    Iterator<? extends V> iterator = values.iterator();\n    if (!iterator.hasNext()) {\n        return removeAll(key);\n    }\n    // TODO(lowasser): investigate atomic failure?\n    Collection<V> collection = getOrCreateCollection(key);\n    Collection<V> oldValues = createCollection();\n    oldValues.addAll(collection);\n    totalSize -= collection.size();\n    collection.clear();\n    while (iterator.hasNext()) {\n        if (collection.add(iterator.next())) {\n            totalSize++;\n        }\n    }\n    return unmodifiableCollectionSubclass(oldValues);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>The returned collection is immutable.\n */\n", "repo_name": "guava-master/", "id": 5935, "method_signature": "Collection<V> replaceValues(K, Iterable)", "filename": "AbstractMapBasedMultimap.replaceValues.json"}
{"callee_method_names": ["Map<K,Collection<V>>.values", "Iterable<? extends V>.isEmpty", "Iterable<? extends V>.size"], "method_name": "AbstractMapBasedMultimap.setMap", "method_implementation": "{\n    this.map = map;\n    totalSize = 0;\n    for (Collection<V> values : map.values()) {\n        checkArgument(!values.isEmpty());\n        totalSize += values.size();\n    }\n}", "repo_id": "5", "comment": "/**\n * Used during deserialization only.\n */\n", "repo_name": "guava-master/", "id": 5934, "method_signature": "void setMap(Map)", "filename": "AbstractMapBasedMultimap.setMap.json"}
{"callee_method_names": [], "method_name": "AbstractMapBasedMultimap.validateIterator", "method_implementation": "{\n    refreshIfEmpty();\n    if (delegate != originalDelegate) {\n        throw new ConcurrentModificationException();\n    }\n}", "repo_id": "5", "comment": "/**\n * If the delegate changed since the iterator was created, the iterator is no longer valid.\n */\n", "repo_name": "guava-master/", "id": 5941, "method_signature": "void validateIterator()", "filename": "AbstractMapBasedMultimap.validateIterator.json"}
{"callee_method_names": ["ObjectCountHashMap<E>.indexOf", "ObjectCountHashMap<E>.put", "ObjectCountHashMap<E>.getValue", "ObjectCountHashMap<E>.setValue"], "method_name": "AbstractMapBasedMultiset.add", "method_implementation": "{\n    if (occurrences == 0) {\n        return count(element);\n    }\n    checkArgument(occurrences > 0, \"occurrences cannot be negative: %s\", occurrences);\n    int entryIndex = backingMap.indexOf(element);\n    if (entryIndex == -1) {\n        backingMap.put(element, occurrences);\n        size += occurrences;\n        return 0;\n    }\n    int oldCount = backingMap.getValue(entryIndex);\n    long newCount = (long) oldCount + (long) occurrences;\n    checkArgument(newCount <= Integer.MAX_VALUE, \"too many occurrences: %s\", newCount);\n    backingMap.setValue(entryIndex, (int) newCount);\n    size += occurrences;\n    return oldCount;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @throws IllegalArgumentException if the call would result in more than {@link\n *     Integer#MAX_VALUE} occurrences of {@code element} in this multiset.\n */\n", "repo_name": "guava-master/", "id": 5833, "method_signature": "int add(E, int)", "filename": "AbstractMapBasedMultiset.add.json"}
{"callee_method_names": ["ObjectCountHashMap<E>.firstIndex", "ObjectCountHashMap<E>.nextIndex", "Multiset<? super E>.add", "ObjectCountHashMap<E>.getKey", "ObjectCountHashMap<E>.getValue"], "method_name": "AbstractMapBasedMultiset.addTo", "method_implementation": "{\n    checkNotNull(target);\n    for (int i = backingMap.firstIndex(); i >= 0; i = backingMap.nextIndex(i)) {\n        target.add(backingMap.getKey(i), backingMap.getValue(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * Allocation-free implementation of {@code target.addAll(this)}.\n */\n", "repo_name": "guava-master/", "id": 5834, "method_signature": "void addTo(Multiset)", "filename": "AbstractMapBasedMultiset.addTo.json"}
{"callee_method_names": [], "method_name": "AbstractMapBasedMultiset.readObjectNoData", "method_implementation": "{\n    throw new InvalidObjectException(\"Stream data required\");\n}", "repo_id": "5", "comment": "// Don't allow default serialization.\n", "repo_name": "guava-master/", "id": 2455, "method_signature": "void readObjectNoData()", "filename": "AbstractMapBasedMultiset.readObjectNoData.json"}
{"callee_method_names": ["Map<E, Count>.remove", "Map<E, Count>.get", "Map<E, Count>.put"], "method_name": "AbstractMapBasedMultiset.setCount", "method_implementation": "{\n    checkNonnegative(count, \"count\");\n    Count existingCounter;\n    int oldCount;\n    if (count == 0) {\n        existingCounter = backingMap.remove(element);\n        oldCount = getAndSet(existingCounter, count);\n    } else {\n        existingCounter = backingMap.get(element);\n        oldCount = getAndSet(existingCounter, count);\n        if (existingCounter == null) {\n            backingMap.put(element, new Count(count));\n        }\n    }\n    size += (count - oldCount);\n    return oldCount;\n}", "repo_id": "5", "comment": "// Roughly a 33% performance improvement over AbstractMultiset.setCount().\n", "repo_name": "guava-master/", "id": 2454, "method_signature": "int setCount(E, int)", "filename": "AbstractMapBasedMultiset.setCount.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject"], "method_name": "AbstractMapBasedMultiset.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    Serialization.writeMultiset(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the number of distinct elements, the first element, its count, the second element,\n *     its count, and so on\n */\n", "repo_name": "guava-master/", "id": 5835, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "AbstractMapBasedMultiset.writeObject.json"}
{"callee_method_names": ["Entry<K, V>.getValue"], "method_name": "AbstractMapTester.createArrayWithNullKey", "method_implementation": "{\n    Entry<K, V>[] array = createSamplesArray();\n    int nullKeyLocation = getNullLocation();\n    Entry<K, V> oldEntry = array[nullKeyLocation];\n    array[nullKeyLocation] = entry(null, oldEntry.getValue());\n    return array;\n}", "repo_id": "5", "comment": "/**\n * @return an array of the proper size with {@code null} as the key of the middle element.\n */\n", "repo_name": "guava-master/", "id": 4210, "method_signature": "Entry<K,V>[] createArrayWithNullKey()", "filename": "AbstractMapTester.createArrayWithNullKey.json"}
{"callee_method_names": ["Entry<K, V>.getKey"], "method_name": "AbstractMapTester.createArrayWithNullValue", "method_implementation": "{\n    Entry<K, V>[] array = createSamplesArray();\n    int nullValueLocation = getNullLocation();\n    Entry<K, V> oldEntry = array[nullValueLocation];\n    array[nullValueLocation] = entry(oldEntry.getKey(), null);\n    return array;\n}", "repo_id": "5", "comment": "/**\n * @return an array of the proper size with {@code null} as the value of the middle element.\n */\n", "repo_name": "guava-master/", "id": 4211, "method_signature": "Entry<K,V>[] createArrayWithNullValue()", "filename": "AbstractMapTester.createArrayWithNullValue.json"}
{"callee_method_names": [], "method_name": "AbstractMapTester.expectNullKeyMissingWhenNullKeysUnsupported", "method_implementation": "{\n    try {\n        assertFalse(message, getMap().containsKey(null));\n    } catch (NullPointerException tolerated) {\n        // Tolerated\n    }\n}", "repo_id": "5", "comment": "/**\n * Equivalent to {@link #expectMissingKeys(Object[]) expectMissingKeys} {@code (null)} except that\n * the call to {@code contains(null)} is permitted to throw a {@code NullPointerException}.\n *\n * @param message message to use upon assertion failure\n */\n", "repo_name": "guava-master/", "id": 4212, "method_signature": "void expectNullKeyMissingWhenNullKeysUnsupported(String)", "filename": "AbstractMapTester.expectNullKeyMissingWhenNullKeysUnsupported.json"}
{"callee_method_names": [], "method_name": "AbstractMapTester.expectNullValueMissingWhenNullValuesUnsupported", "method_implementation": "{\n    try {\n        assertFalse(message, getMap().containsValue(null));\n    } catch (NullPointerException tolerated) {\n        // Tolerated\n    }\n}", "repo_id": "5", "comment": "/**\n * Equivalent to {@link #expectMissingValues(Object[]) expectMissingValues} {@code (null)} except\n * that the call to {@code contains(null)} is permitted to throw a {@code NullPointerException}.\n *\n * @param message message to use upon assertion failure\n */\n", "repo_name": "guava-master/", "id": 4213, "method_signature": "void expectNullValueMissingWhenNullValuesUnsupported(String)", "filename": "AbstractMapTester.expectNullValueMissingWhenNullValuesUnsupported.json"}
{"callee_method_names": ["Map<?,?>.hashCode", "Map<?,?>.hashCode", "Map<?,?>.entrySet", "Map<?,?>.entrySet", "Map<?,?>.values", "Map<?,?>.values", "Collection<?>.size", "Collection<?>.size", "Collection<?>.containsAll", "Collection<?>.containsAll"], "method_name": "AbstractMapsTransformValuesTest.assertMapsEqual", "method_implementation": "{\n    assertEquals(expected, map);\n    assertEquals(expected.hashCode(), map.hashCode());\n    assertEquals(expected.entrySet(), map.entrySet());\n    // Assert that expectedValues > mapValues and that\n    // mapValues > expectedValues; i.e. that expectedValues == mapValues.\n    Collection<?> expectedValues = expected.values();\n    Collection<?> mapValues = map.values();\n    assertEquals(expectedValues.size(), mapValues.size());\n    assertTrue(expectedValues.containsAll(mapValues));\n    assertTrue(mapValues.containsAll(expectedValues));\n}", "repo_id": "5", "comment": "/**\n * Helper assertion comparing two maps\n */\n", "repo_name": "guava-master/", "id": 4031, "method_signature": "void assertMapsEqual(Map, Map)", "filename": "AbstractMapsTransformValuesTest.assertMapsEqual.json"}
{"callee_method_names": ["Map<String, Collection<Integer>>.keySet", "Map<String, Collection<Integer>>.size", "Map<String, Collection<Integer>>.get", "Map<String, Collection<Integer>>.remove", "Map<String, Collection<Integer>>.containsKey", "Map<String, Collection<Integer>>.size", "Map<String, Collection<Integer>>.remove"], "method_name": "AbstractMultimapAsMapImplementsMapTest.testRemove", "method_implementation": "{\n    final Map<String, Collection<Integer>> map;\n    final String keyToRemove;\n    try {\n        map = makePopulatedMap();\n    } catch (UnsupportedOperationException e) {\n        return;\n    }\n    keyToRemove = map.keySet().iterator().next();\n    if (supportsRemove) {\n        int initialSize = map.size();\n        map.get(keyToRemove);\n        map.remove(keyToRemove);\n        // This line doesn't hold - see the Javadoc comments above.\n        // assertEquals(expectedValue, oldValue);\n        assertFalse(map.containsKey(keyToRemove));\n        assertEquals(initialSize - 1, map.size());\n    } else {\n        try {\n            map.remove(keyToRemove);\n            fail(\"Expected UnsupportedOperationException.\");\n        } catch (UnsupportedOperationException expected) {\n        }\n    }\n    assertInvariants(map);\n}", "repo_id": "5", "comment": "/**\n * The version of this test supplied by {@link MapInterfaceTest} fails for this particular Map\n * implementation, because {@code map.get()} returns a view collection that changes in the course\n * of a call to {@code remove()}. Thus, the expectation doesn't hold that {@code map.remove(x)}\n * returns the same value which {@code map.get(x)} did immediately beforehand.\n */\n", "repo_name": "guava-master/", "id": 4026, "method_signature": "void testRemove()", "filename": "AbstractMultimapAsMapImplementsMapTest.testRemove.json"}
{"callee_method_names": ["Entry<K, V>.getValue"], "method_name": "AbstractMultimapTester.createArrayWithNullKey", "method_implementation": "{\n    Entry<K, V>[] array = createSamplesArray();\n    int nullKeyLocation = getNullLocation();\n    Entry<K, V> oldEntry = array[nullKeyLocation];\n    array[nullKeyLocation] = Helpers.mapEntry(null, oldEntry.getValue());\n    return array;\n}", "repo_id": "5", "comment": "/**\n * @return an array of the proper size with {@code null} as the key of the middle element.\n */\n", "repo_name": "guava-master/", "id": 4176, "method_signature": "Entry<K,V>[] createArrayWithNullKey()", "filename": "AbstractMultimapTester.createArrayWithNullKey.json"}
{"callee_method_names": [], "method_name": "AbstractMultimapTester.createArrayWithNullKeyAndValue", "method_implementation": "{\n    Entry<K, V>[] array = createSamplesArray();\n    int nullValueLocation = getNullLocation();\n    array[nullValueLocation] = Helpers.mapEntry(null, null);\n    return array;\n}", "repo_id": "5", "comment": "/**\n * @return an array of the proper size with {@code null} as the key and value of the middle\n *     element.\n */\n", "repo_name": "guava-master/", "id": 4178, "method_signature": "Entry<K,V>[] createArrayWithNullKeyAndValue()", "filename": "AbstractMultimapTester.createArrayWithNullKeyAndValue.json"}
{"callee_method_names": ["Entry<K, V>.getKey"], "method_name": "AbstractMultimapTester.createArrayWithNullValue", "method_implementation": "{\n    Entry<K, V>[] array = createSamplesArray();\n    int nullValueLocation = getNullLocation();\n    Entry<K, V> oldEntry = array[nullValueLocation];\n    array[nullValueLocation] = Helpers.mapEntry(oldEntry.getKey(), null);\n    return array;\n}", "repo_id": "5", "comment": "/**\n * @return an array of the proper size with {@code null} as the value of the middle element.\n */\n", "repo_name": "guava-master/", "id": 4177, "method_signature": "Entry<K,V>[] createArrayWithNullValue()", "filename": "AbstractMultimapTester.createArrayWithNullValue.json"}
{"callee_method_names": [], "method_name": "AbstractMultimapTester.resetContainer", "method_implementation": "{\n    multimap = super.resetContainer(newContents);\n    return multimap;\n}", "repo_id": "5", "comment": "// TODO: dispose of this once collection is encapsulated.\n", "repo_name": "guava-master/", "id": 4179, "method_signature": "M resetContainer(M)", "filename": "AbstractMultimapTester.resetContainer.json"}
{"callee_method_names": [], "method_name": "AbstractMultiset.add", "method_implementation": "{\n    add(element, 1);\n    return true;\n}", "repo_id": "5", "comment": "// Modification Operations\n", "repo_name": "guava-master/", "id": 6139, "method_signature": "boolean add(E)", "filename": "AbstractMultiset.add.json"}
{"callee_method_names": [], "method_name": "AbstractMultiset.addAll", "method_implementation": "{\n    return Multisets.addAllImpl(this, elementsToAdd);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>This implementation is highly efficient when {@code elementsToAdd} is itself a {@link\n * Multiset}.\n */\n", "repo_name": "guava-master/", "id": 6140, "method_signature": "boolean addAll(Collection)", "filename": "AbstractMultiset.addAll.json"}
{"callee_method_names": [], "method_name": "AbstractMultisetSetCountTester.getSetCountDuplicateInitializingMethods", "method_implementation": "{\n    return Arrays.asList(getMethod(\"testSetCount_threeToThree_removeSupported\"), getMethod(\"testSetCount_threeToZero_supported\"), getMethod(\"testSetCount_threeToOne_supported\"));\n}", "repo_id": "5", "comment": "/**\n * Returns {@link Method} instances for the {@code setCount()} tests that assume multisets support\n * duplicates so that the test of {@code Multisets.forSet()} can suppress them.\n */\n", "repo_name": "guava-master/", "id": 4182, "method_signature": "List<Method> getSetCountDuplicateInitializingMethods()", "filename": "AbstractMultisetSetCountTester.getSetCountDuplicateInitializingMethods.json"}
{"callee_method_names": ["EndpointPair<?>.nodeU", "EndpointPair<?>.nodeU", "EndpointPair<?>.nodeV"], "method_name": "AbstractNetwork.contains", "method_implementation": "{\n    if (!(obj instanceof EndpointPair)) {\n        return false;\n    }\n    EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n    return isOrderingCompatible(endpointPair) && nodes().contains(endpointPair.nodeU()) && successors((N) endpointPair.nodeU()).contains(endpointPair.nodeV());\n}", "repo_id": "5", "comment": "// Network<LinkedList>.\n", "repo_name": "guava-master/", "id": 6758, "method_signature": "boolean contains(Object)", "filename": "AbstractNetwork.contains.json"}
{"callee_method_names": [], "method_name": "AbstractNetwork.toString", "method_implementation": "{\n    return \"isDirected: \" + isDirected() + \", allowsParallelEdges: \" + allowsParallelEdges() + \", allowsSelfLoops: \" + allowsSelfLoops() + \", nodes: \" + nodes() + \", edges: \" + edgeIncidentNodesMap(this);\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this network.\n */\n", "repo_name": "guava-master/", "id": 6759, "method_signature": "String toString()", "filename": "AbstractNetwork.toString.json"}
{"callee_method_names": ["List<Hasher>.size", "List<Hasher>.size", "List<Hasher>.get"], "method_name": "AbstractNonStreamingHashFunctionTest.testExhaustive", "method_implementation": "{\n    List<Hasher> hashers = ImmutableList.of(new StreamingVersion().newHasher(), new StreamingVersion().newHasher(52), new NonStreamingVersion().newHasher(), new NonStreamingVersion().newHasher(123));\n    Random random = new Random(0);\n    for (int i = 0; i < 200; i++) {\n        RandomHasherAction.pickAtRandom(random).performAction(random, hashers);\n    }\n    HashCode[] codes = new HashCode[hashers.size()];\n    for (int i = 0; i < hashers.size(); i++) {\n        codes[i] = hashers.get(i).hash();\n    }\n    for (int i = 1; i < codes.length; i++) {\n        assertEquals(codes[i - 1], codes[i]);\n    }\n}", "repo_id": "5", "comment": "/**\n * Constructs two trivial HashFunctions (output := input), one streaming and one non-streaming,\n * and checks that their results are identical, no matter which newHasher version we used.\n */\n", "repo_name": "guava-master/", "id": 3737, "method_signature": "void testExhaustive()", "filename": "AbstractNonStreamingHashFunctionTest.testExhaustive.json"}
{"callee_method_names": ["TreeMap<String, Class<?>>.put", "Class<?>.getName", "Chopper.chop", "Class<?>.getName", "Optional<String>.isPresent", "TreeMap<String, Class<?>>.get", "Optional<String>.get", "Multimap<Class<?>, Class<?>>.put", "LinkedHashSet<Class<?>>.add", "Multimap<Class<?>, Class<?>>.get", "List<Class<?>>.add"], "method_name": "AbstractPackageSanityTests.findClassesToTest", "method_implementation": "{\n    // \"a.b.Foo\" -> a.b.Foo.class\n    TreeMap<String, Class<?>> classMap = Maps.newTreeMap();\n    for (Class<?> cls : classes) {\n        classMap.put(cls.getName(), cls);\n    }\n    // Foo.class -> [FooTest.class, FooTests.class, FooTestSuite.class, ...]\n    Multimap<Class<?>, Class<?>> testClasses = HashMultimap.create();\n    LinkedHashSet<Class<?>> candidateClasses = Sets.newLinkedHashSet();\n    for (Class<?> cls : classes) {\n        Optional<String> testedClassName = TEST_SUFFIX.chop(cls.getName());\n        if (testedClassName.isPresent()) {\n            Class<?> testedClass = classMap.get(testedClassName.get());\n            if (testedClass != null) {\n                testClasses.put(testedClass, cls);\n            }\n        } else {\n            candidateClasses.add(cls);\n        }\n    }\n    List<Class<?>> result = Lists.newArrayList();\n    NEXT_CANDIDATE: for (Class<?> candidate : Iterables.filter(candidateClasses, classFilter)) {\n        for (Class<?> testClass : testClasses.get(candidate)) {\n            if (hasTest(testClass, explicitTestNames)) {\n                // covered by explicit test\n                continue NEXT_CANDIDATE;\n            }\n        }\n        result.add(candidate);\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Finds the classes not ending with a test suffix and not covered by an explicit test whose name\n * is {@code explicitTestNames}.\n */\n", "repo_name": "guava-master/", "id": 4133, "method_signature": "List<Class<?>> findClassesToTest(Iterable, Iterable)", "filename": "AbstractPackageSanityTests.findClassesToTest.json"}
{"callee_method_names": ["ClassSanityTester.doTestEquals"], "method_name": "AbstractPackageSanityTests.testEquals", "method_implementation": "{\n    for (Class<?> classToTest : findClassesToTest(loadClassesInPackage(), EQUALS_TEST_METHOD_NAMES)) {\n        if (!classToTest.isEnum() && isEqualsDefined(classToTest)) {\n            try {\n                tester.doTestEquals(classToTest);\n            } catch (Throwable e) {\n                throw sanityError(classToTest, EQUALS_TEST_METHOD_NAMES, \"equals test\", e);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests {@code equals()} and {@code hashCode()} implementations for every top-level class in the\n * package, that explicitly implements {@link Object#equals}. For a class {@code C}:\n *\n * <ul>\n *   <li>The visible constructor or visible static factory method with the most parameters is used\n *       to construct the sample instances. In case of tie, the candidate constructors or\n *       factories are tried one after another until one can be used to construct sample\n *       instances.\n *   <li>For the constructor or static factory method used to construct instances, it's checked\n *       that when equal parameters are passed, the result instance should also be equal; and vice\n *       versa.\n *   <li>Inequality check is not performed against state mutation methods such as {@link\n *       List#add}, or functional update methods such as {@link\n *       com.google.common.base.Joiner#skipNulls}.\n *   <li>If the constructor or factory method used to construct instance takes a parameter that\n *       {@link AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n *   <li>If there is no visible constructor or visible static factory method declared by {@code\n *       C}, {@code C} is skipped for equality test.\n *   <li>Equality test is not performed on method return values unless the method is a visible\n *       static factory method whose return type is {@code C} or {@code C}'s subtype.\n * </ul>\n *\n * <p>In all cases, if {@code C} needs custom logic for testing {@code equals()}, you can add an\n * explicit {@code testEquals()} test in the corresponding {@code CTest} class, and {@code C} will\n * be excluded from the automated {@code equals} test performed by this method.\n */\n", "repo_name": "guava-master/", "id": 4132, "method_signature": "void testEquals()", "filename": "AbstractPackageSanityTests.testEquals.json"}
{"callee_method_names": ["ClassSanityTester.doTestNulls"], "method_name": "AbstractPackageSanityTests.testNulls", "method_implementation": "{\n    for (Class<?> classToTest : findClassesToTest(loadClassesInPackage(), NULL_TEST_METHOD_NAMES)) {\n        try {\n            tester.doTestNulls(classToTest, visibility);\n        } catch (Throwable e) {\n            throw sanityError(classToTest, NULL_TEST_METHOD_NAMES, \"nulls test\", e);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs {@link NullPointerTester} checks for all top-level classes in the package. For a class\n * {@code C}\n *\n * <ul>\n *   <li>All visible static methods are checked such that passing null for any parameter that's\n *       not annotated nullable (according to the rules of {@link NullPointerTester}) should throw\n *       {@link NullPointerException}.\n *   <li>If there is any visible constructor or visible static factory method declared by the\n *       class, all visible instance methods will be checked too using the instance created by\n *       invoking the constructor or static factory method.\n *   <li>If the constructor or factory method used to construct instance takes a parameter that\n *       {@link AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n *   <li>If there is no visible constructor or visible static factory method declared by {@code\n *       C}, instance methods are skipped for nulls test.\n *   <li>Nulls test is not performed on method return values unless the method is a visible static\n *       factory method whose return type is {@code C} or {@code C}'s subtype.\n * </ul>\n *\n * <p>In all cases, if {@code C} needs custom logic for testing nulls, you can add an explicit\n * {@code testNulls()} test in the corresponding {@code CTest} class, and {@code C} will be\n * excluded from the automated null tests performed by this method.\n */\n", "repo_name": "guava-master/", "id": 4131, "method_signature": "void testNulls()", "filename": "AbstractPackageSanityTests.testNulls.json"}
{"callee_method_ids": [4091], "callee_method_names": ["ClassSanityTester.instantiate"], "method_name": "AbstractPackageSanityTests.testSerializable", "method_implementation": "{\n    // TODO: when we use @BeforeClass, we can pay the cost of class path scanning only once.\n    for (Class<?> classToTest : findClassesToTest(loadClassesInPackage(), SERIALIZABLE_TEST_METHOD_NAMES)) {\n        if (Serializable.class.isAssignableFrom(classToTest)) {\n            try {\n                Object instance = tester.instantiate(classToTest);\n                if (instance != null) {\n                    if (isEqualsDefined(classToTest)) {\n                        SerializableTester.reserializeAndAssert(instance);\n                    } else {\n                        SerializableTester.reserialize(instance);\n                    }\n                }\n            } catch (Throwable e) {\n                throw sanityError(classToTest, SERIALIZABLE_TEST_METHOD_NAMES, \"serializable test\", e);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests all top-level {@link Serializable} classes in the package. For a serializable Class\n * {@code C}:\n *\n * <ul>\n *   <li>If {@code C} explicitly implements {@link Object#equals}, the deserialized instance will\n *       be checked to be equal to the instance before serialization.\n *   <li>If {@code C} doesn't explicitly implement {@code equals} but instead inherits it from a\n *       superclass, no equality check is done on the deserialized instance because it's not clear\n *       whether the author intended for the class to be a value type.\n *   <li>If a constructor or factory method takes a parameter whose type is interface, a dynamic\n *       proxy will be passed to the method. It's possible that the method body expects an\n *       instance method of the passed-in proxy to be of a certain value yet the proxy isn't aware\n *       of the assumption, in which case the equality check before and after serialization will\n *       fail.\n *   <li>If the constructor or factory method takes a parameter that {@link\n *       AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n *   <li>If there is no visible constructor or visible static factory method declared by {@code\n *       C}, {@code C} is skipped for serialization test, even if it implements {@link\n *       Serializable}.\n *   <li>Serialization test is not performed on method return values unless the method is a\n *       visible static factory method whose return type is {@code C} or {@code C}'s subtype.\n * </ul>\n *\n * <p>In all cases, if {@code C} needs custom logic for testing serialization, you can add an\n * explicit {@code testSerializable()} test in the corresponding {@code CTest} class, and {@code\n * C} will be excluded from automated serialization test performed by this method.\n */\n", "repo_name": "guava-master/", "id": 4130, "method_signature": "void testSerializable()", "filename": "AbstractPackageSanityTests.testSerializable.json"}
{"callee_method_names": ["ScheduledExecutorService.shutdown", "ScheduledExecutorService.shutdown"], "method_name": "AbstractScheduledService.executor", "method_implementation": "{\n    @WeakOuter\n    class ThreadFactoryImpl implements ThreadFactory {\n\n        @Override\n        public Thread newThread(Runnable runnable) {\n            return MoreExecutors.newThread(serviceName(), runnable);\n        }\n    }\n    final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl());\n    // Add a listener to shut down the executor after the service is stopped. This ensures that the\n    // JVM shutdown will not be prevented from exiting after this service has stopped or failed.\n    // Technically this listener is added after start() was called so it is a little gross, but it\n    // is called within doStart() so we know that the service cannot terminate or fail concurrently\n    // with adding this listener so it is impossible to miss an event that we are interested in.\n    addListener(new Listener() {\n\n        @Override\n        public void terminated(State from) {\n            executor.shutdown();\n        }\n\n        @Override\n        public void failed(State from, Throwable failure) {\n            executor.shutdown();\n        }\n    }, directExecutor());\n    return executor;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@link ScheduledExecutorService} that will be used to execute the {@link #startUp},\n * {@link #runOneIteration} and {@link #shutDown} methods. If this method is overridden the\n * executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this service\n * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED\n * fails}. Subclasses may override this method to supply a custom {@link ScheduledExecutorService}\n * instance. This method is guaranteed to only be called once.\n *\n * <p>By default this returns a new {@link ScheduledExecutorService} with a single thread pool\n * that sets the name of the thread to the {@linkplain #serviceName() service name}. Also, the\n * pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service\n * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED\n * fails}.\n */\n", "repo_name": "guava-master/", "id": 5335, "method_signature": "ScheduledExecutorService executor()", "filename": "AbstractScheduledService.executor.json"}
{"callee_method_names": ["ScheduledExecutorService.scheduleWithFixedDelay"], "method_name": "AbstractScheduledService.newFixedDelaySchedule", "method_implementation": "{\n    checkNotNull(unit);\n    checkArgument(delay > 0, \"delay must be > 0, found %s\", delay);\n    return new Scheduler() {\n\n        @Override\n        public Cancellable schedule(AbstractService service, ScheduledExecutorService executor, Runnable task) {\n            return new FutureAsCancellable(executor.scheduleWithFixedDelay(task, initialDelay, delay, unit));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Scheduler} that schedules the task using the {@link\n * ScheduledExecutorService#scheduleWithFixedDelay} method.\n *\n * @param initialDelay the time to delay first execution\n * @param delay the delay between the termination of one execution and the commencement of the\n *     next\n * @param unit the time unit of the initialDelay and delay parameters\n */\n", "repo_name": "guava-master/", "id": 5333, "method_signature": "Scheduler newFixedDelaySchedule(long, long, TimeUnit)", "filename": "AbstractScheduledService.newFixedDelaySchedule.json"}
{"callee_method_names": ["ScheduledExecutorService.scheduleAtFixedRate"], "method_name": "AbstractScheduledService.newFixedRateSchedule", "method_implementation": "{\n    checkNotNull(unit);\n    checkArgument(period > 0, \"period must be > 0, found %s\", period);\n    return new Scheduler() {\n\n        @Override\n        public Cancellable schedule(AbstractService service, ScheduledExecutorService executor, Runnable task) {\n            return new FutureAsCancellable(executor.scheduleAtFixedRate(task, initialDelay, period, unit));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Scheduler} that schedules the task using the {@link\n * ScheduledExecutorService#scheduleAtFixedRate} method.\n *\n * @param initialDelay the time to delay first execution\n * @param period the period between successive executions of the task\n * @param unit the time unit of the initialDelay and period parameters\n */\n", "repo_name": "guava-master/", "id": 5334, "method_signature": "Scheduler newFixedRateSchedule(long, long, TimeUnit)", "filename": "AbstractScheduledService.newFixedRateSchedule.json"}
{"callee_method_ids": [5321, 5321], "callee_method_names": ["AbstractService.notifyFailed", "ReentrantLock.lock", "ReentrantLock.unlock", "AbstractService.notifyFailed"], "method_name": "AbstractScheduledService.reschedule", "method_implementation": "{\n    // invoke the callback outside the lock, prevents some shenanigans.\n    Schedule schedule;\n    try {\n        schedule = CustomScheduler.this.getNextSchedule();\n    } catch (Throwable t) {\n        restoreInterruptIfIsInterruptedException(t);\n        service.notifyFailed(t);\n        return new FutureAsCancellable(immediateCancelledFuture());\n    }\n    // We reschedule ourselves with a lock held for two reasons. 1. we want to make sure that\n    // cancel calls cancel on the correct future. 2. we want to make sure that the assignment\n    // to currentFuture doesn't race with itself so that currentFuture is assigned in the\n    // correct order.\n    Throwable scheduleFailure = null;\n    Cancellable toReturn;\n    lock.lock();\n    try {\n        toReturn = initializeOrUpdateCancellationDelegate(schedule);\n    } catch (Throwable e) {\n        // Any Exception is either a RuntimeException or sneaky checked exception.\n        //\n        // If an exception is thrown by the subclass then we need to make sure that the service\n        // notices and transitions to the FAILED state. We do it by calling notifyFailed directly\n        // because the service does not monitor the state of the future so if the exception is not\n        // caught and forwarded to the service the task would stop executing but the service would\n        // have no idea.\n        // TODO(lukes): consider building everything in terms of ListenableScheduledFuture then\n        // the AbstractService could monitor the future directly. Rescheduling is still hard...\n        // but it would help with some of these lock ordering issues.\n        scheduleFailure = e;\n        toReturn = new FutureAsCancellable(immediateCancelledFuture());\n    } finally {\n        lock.unlock();\n    }\n    // Call notifyFailed outside the lock to avoid lock ordering issues.\n    if (scheduleFailure != null) {\n        service.notifyFailed(scheduleFailure);\n    }\n    return toReturn;\n}", "repo_id": "5", "comment": "/**\n * Atomically reschedules this task and assigns the new future to {@link\n * #cancellationDelegate}.\n */\n", "repo_name": "guava-master/", "id": 5338, "method_signature": "Cancellable reschedule()", "filename": "AbstractScheduledService.reschedule.json"}
{"callee_method_names": ["Future<?>.startAsync"], "method_name": "AbstractScheduledService.startAsync", "method_implementation": "{\n    delegate.startAsync();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5336, "method_signature": "Service startAsync()", "filename": "AbstractScheduledService.startAsync.json"}
{"callee_method_names": ["Future<?>.stopAsync"], "method_name": "AbstractScheduledService.stopAsync", "method_implementation": "{\n    delegate.stopAsync();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5337, "method_signature": "Service stopAsync()", "filename": "AbstractScheduledService.stopAsync.json"}
{"callee_method_names": [], "method_name": "AbstractService.checkCurrentState", "method_implementation": "{\n    State actual = state();\n    if (actual != expected) {\n        if (actual == FAILED) {\n            // Handle this specially so that we can include the failureCause, if there is one.\n            throw new IllegalStateException(\"Expected the service \" + this + \" to be \" + expected + \", but the service has FAILED\", failureCause());\n        }\n        throw new IllegalStateException(\"Expected the service \" + this + \" to be \" + expected + \", but was \" + actual);\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks that the current state is equal to the expected state.\n */\n", "repo_name": "guava-master/", "id": 5318, "method_signature": "void checkCurrentState(State)", "filename": "AbstractService.checkCurrentState.json"}
{"callee_method_ids": [5521], "callee_method_names": ["Monitor.isOccupiedByCurrentThread", "ListenerCallQueue.dispatch"], "method_name": "AbstractService.dispatchListenerEvents", "method_implementation": "{\n    if (!monitor.isOccupiedByCurrentThread()) {\n        listeners.dispatch();\n    }\n}", "repo_id": "5", "comment": "/**\n * Attempts to execute all the listeners in {@link #listeners} while not holding the {@link\n * #monitor}.\n */\n", "repo_name": "guava-master/", "id": 5322, "method_signature": "void dispatchListenerEvents()", "filename": "AbstractService.dispatchListenerEvents.json"}
{"callee_method_names": [], "method_name": "AbstractService.externalState", "method_implementation": "{\n    if (shutdownWhenStartupFinishes && state == STARTING) {\n        return STOPPING;\n    } else {\n        return state;\n    }\n}", "repo_id": "5", "comment": "/**\n * @see Service#state()\n */\n", "repo_name": "guava-master/", "id": 5323, "method_signature": "State externalState()", "filename": "AbstractService.externalState.json"}
{"callee_method_names": [], "method_name": "AbstractService.failureCause", "method_implementation": "{\n    checkState(state == FAILED, \"failureCause() is only valid if the service has failed, service is %s\", state);\n    // requireNonNull is safe because the constructor requires a non-null cause with state=FAILED.\n    return requireNonNull(failure);\n}", "repo_id": "5", "comment": "/**\n * @see Service#failureCause()\n */\n", "repo_name": "guava-master/", "id": 5324, "method_signature": "Throwable failureCause()", "filename": "AbstractService.failureCause.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "AbstractService.notifyFailed", "method_implementation": "{\n    checkNotNull(cause);\n    monitor.enter();\n    try {\n        State previous = state();\n        switch(previous) {\n            case NEW:\n            case TERMINATED:\n                throw new IllegalStateException(\"Failed while in state:\" + previous, cause);\n            case RUNNING:\n            case STARTING:\n            case STOPPING:\n                snapshot = new StateSnapshot(FAILED, false, cause);\n                enqueueFailedEvent(previous, cause);\n                break;\n            case FAILED:\n                // Do nothing\n                break;\n        }\n    } finally {\n        monitor.leave();\n        dispatchListenerEvents();\n    }\n}", "repo_id": "5", "comment": "/**\n * Invoke this method to transition the service to the {@link State#FAILED}. The service will\n * <b>not be stopped</b> if it is running. Invoke this method when a service has failed critically\n * or otherwise cannot be started nor stopped.\n */\n", "repo_name": "guava-master/", "id": 5321, "method_signature": "void notifyFailed(Throwable)", "filename": "AbstractService.notifyFailed.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "AbstractService.notifyStarted", "method_implementation": "{\n    monitor.enter();\n    try {\n        // We have to examine the internal state of the snapshot here to properly handle the stop\n        // while starting case.\n        if (snapshot.state != STARTING) {\n            IllegalStateException failure = new IllegalStateException(\"Cannot notifyStarted() when the service is \" + snapshot.state);\n            notifyFailed(failure);\n            throw failure;\n        }\n        if (snapshot.shutdownWhenStartupFinishes) {\n            snapshot = new StateSnapshot(STOPPING);\n            // We don't call listeners here because we already did that when we set the\n            // shutdownWhenStartupFinishes flag.\n            doStop();\n        } else {\n            snapshot = new StateSnapshot(RUNNING);\n            enqueueRunningEvent();\n        }\n    } finally {\n        monitor.leave();\n        dispatchListenerEvents();\n    }\n}", "repo_id": "5", "comment": "/**\n * Implementing classes should invoke this method once their service has started. It will cause\n * the service to transition from {@link State#STARTING} to {@link State#RUNNING}.\n *\n * @throws IllegalStateException if the service is not {@link State#STARTING}.\n */\n", "repo_name": "guava-master/", "id": 5319, "method_signature": "void notifyStarted()", "filename": "AbstractService.notifyStarted.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "AbstractService.notifyStopped", "method_implementation": "{\n    monitor.enter();\n    try {\n        State previous = state();\n        switch(previous) {\n            case NEW:\n            case TERMINATED:\n            case FAILED:\n                throw new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n            case RUNNING:\n            case STARTING:\n            case STOPPING:\n                snapshot = new StateSnapshot(TERMINATED);\n                enqueueTerminatedEvent(previous);\n                break;\n        }\n    } finally {\n        monitor.leave();\n        dispatchListenerEvents();\n    }\n}", "repo_id": "5", "comment": "/**\n * Implementing classes should invoke this method once their service has stopped. It will cause\n * the service to transition from {@link State#STARTING} or {@link State#STOPPING} to {@link\n * State#TERMINATED}.\n *\n * @throws IllegalStateException if the service is not one of {@link State#STOPPING}, {@link\n *     State#STARTING}, or {@link State#RUNNING}.\n */\n", "repo_name": "guava-master/", "id": 5320, "method_signature": "void notifyStopped()", "filename": "AbstractService.notifyStopped.json"}
{"callee_method_names": ["CountDownLatch.await"], "method_name": "AbstractServiceTest.awaitRunChecks", "method_implementation": "{\n    assertTrue(\"Service thread hasn't finished its checks. \" + \"Exception status (possibly stale): \" + thrownByExecutionThread, hasConfirmedIsRunning.await(10, SECONDS));\n}", "repo_id": "5", "comment": "/*\n     * The main test thread tries to stop() the service shortly after\n     * confirming that it is running. Meanwhile, the service itself is trying\n     * to confirm that it is running. If the main thread's stop() call happens\n     * before it has the chance, the test will fail. To avoid this, the main\n     * thread calls this method, which waits until the service has performed\n     * its own \"running\" check.\n     */\n", "repo_name": "guava-master/", "id": 3817, "method_signature": "void awaitRunChecks()", "filename": "AbstractServiceTest.awaitRunChecks.json"}
{"callee_method_names": ["ManualSwitchedService.addListener", "AtomicInteger.incrementAndGet", "ManualSwitchedService.startAsync", "ManualSwitchedService.stopAsync", "AtomicInteger.get", "ManualSwitchedService.stopAsync", "AtomicInteger.get"], "method_name": "AbstractServiceTest.testManualServiceStopMultipleTimesWhileStarting", "method_implementation": "{\n    ManualSwitchedService service = new ManualSwitchedService();\n    final AtomicInteger stoppingCount = new AtomicInteger();\n    service.addListener(new Listener() {\n\n        @Override\n        public void stopping(State from) {\n            stoppingCount.incrementAndGet();\n        }\n    }, directExecutor());\n    service.startAsync();\n    service.stopAsync();\n    assertEquals(1, stoppingCount.get());\n    service.stopAsync();\n    assertEquals(1, stoppingCount.get());\n}", "repo_id": "5", "comment": "/**\n * This tests for a bug where if {@link Service#stopAsync()} was called while the service was\n * {@link State#STARTING} more than once, the {@link Listener#stopping(State)} callback would get\n * called multiple times.\n */\n", "repo_name": "guava-master/", "id": 3816, "method_signature": "void testManualServiceStopMultipleTimesWhileStarting()", "filename": "AbstractServiceTest.testManualServiceStopMultipleTimesWhileStarting.json"}
{"callee_method_names": [], "method_name": "AbstractSetMultimap.put", "method_implementation": "{\n    return super.put(key, value);\n}", "repo_id": "5", "comment": "/**\n * Stores a key-value pair in the multimap.\n *\n * @param key key to store in the multimap\n * @param value value to store in the multimap\n * @return {@code true} if the method increased the size of the multimap, or {@code false} if the\n *     multimap already contained the key-value pair\n */\n", "repo_name": "guava-master/", "id": 5717, "method_signature": "boolean put(K, V)", "filename": "AbstractSetMultimap.put.json"}
{"callee_method_names": [], "method_name": "AbstractSetMultimap.removeAll", "method_implementation": "{\n    return (Set<V>) super.removeAll(key);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a\n * {@link Set}, instead of the {@link Collection} specified in the {@link Multimap} interface.\n */\n", "repo_name": "guava-master/", "id": 5715, "method_signature": "Set<V> removeAll(Object)", "filename": "AbstractSetMultimap.removeAll.json"}
{"callee_method_names": [], "method_name": "AbstractSetMultimap.replaceValues", "method_implementation": "{\n    return (Set<V>) super.replaceValues(key, values);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a\n * {@link Set}, instead of the {@link Collection} specified in the {@link Multimap} interface.\n *\n * <p>Any duplicates in {@code values} will be stored in the multimap once.\n */\n", "repo_name": "guava-master/", "id": 5716, "method_signature": "Set<V> replaceValues(K, Iterable)", "filename": "AbstractSetMultimap.replaceValues.json"}
{"callee_method_names": [], "method_name": "AbstractSortedSetMultimap.removeAll", "method_implementation": "{\n    return (SortedSet<V>) super.removeAll(key);\n}", "repo_id": "5", "comment": "/**\n * Removes all values associated with a given key. The returned collection is immutable.\n *\n * <p>Because a {@code SortedSetMultimap} has unique sorted values for a given key, this method\n * returns a {@link SortedSet}, instead of the {@link Collection} specified in the {@link\n * Multimap} interface.\n */\n", "repo_name": "guava-master/", "id": 5919, "method_signature": "SortedSet<V> removeAll(Object)", "filename": "AbstractSortedSetMultimap.removeAll.json"}
{"callee_method_names": [], "method_name": "AbstractSortedSetMultimap.replaceValues", "method_implementation": "{\n    return (SortedSet<V>) super.replaceValues(key, values);\n}", "repo_id": "5", "comment": "/**\n * Stores a collection of values with the same key, replacing any existing values for that key.\n * The returned collection is immutable.\n *\n * <p>Because a {@code SortedSetMultimap} has unique sorted values for a given key, this method\n * returns a {@link SortedSet}, instead of the {@link Collection} specified in the {@link\n * Multimap} interface.\n *\n * <p>Any duplicates in {@code values} will be stored in the multimap once.\n */\n", "repo_name": "guava-master/", "id": 5920, "method_signature": "SortedSet<V> replaceValues(K, Iterable)", "filename": "AbstractSortedSetMultimap.replaceValues.json"}
{"callee_method_names": [], "method_name": "AbstractStandardDirectedGraphTest.populateStarShapedGraph", "method_implementation": "{\n    putEdge(2, 1);\n    putEdge(1, 4);\n    putEdge(1, 3);\n    putEdge(5, 1);\n    putEdge(1, 2);\n    putEdge(3, 1);\n}", "repo_id": "5", "comment": "/**\n * Populates the graph with nodes and edges in a star shape with node `1` in the middle.\n *\n * <p>Note that the edges are added in a shuffled order to properly test the effect of the\n * insertion order.\n */\n", "repo_name": "guava-master/", "id": 4050, "method_signature": "void populateStarShapedGraph()", "filename": "AbstractStandardDirectedGraphTest.populateStarShapedGraph.json"}
{"callee_method_names": ["MutableValueGraph<Integer, String>.nodes", "MutableValueGraph<Integer, String>.successors", "MutableValueGraph<Integer, String>.successors", "MutableValueGraph<Integer, String>.successors", "MutableValueGraph<Integer, String>.successors", "MutableValueGraph<Integer, String>.successors"], "method_name": "AbstractStandardDirectedGraphTest.putEdge_nodesNotInGraph", "method_implementation": "{\n    assume().that(graphIsMutable()).isTrue();\n    graphAsMutableGraph.addNode(N1);\n    assertTrue(graphAsMutableGraph.putEdge(N1, N5));\n    assertTrue(graphAsMutableGraph.putEdge(N4, N1));\n    assertTrue(graphAsMutableGraph.putEdge(N2, N3));\n    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n    assertThat(graph.successors(N1)).containsExactly(N5);\n    assertThat(graph.successors(N2)).containsExactly(N3);\n    assertThat(graph.successors(N3)).isEmpty();\n    assertThat(graph.successors(N4)).containsExactly(N1);\n    assertThat(graph.successors(N5)).isEmpty();\n}", "repo_id": "5", "comment": "/**\n * Tests that the method {@code putEdge} will silently add the missing nodes to the graph, then\n * add the edge connecting them. We are not using the proxy methods here as we want to test {@code\n * putEdge} when the end-points are not elements of the graph.\n */\n", "repo_name": "guava-master/", "id": 4051, "method_signature": "void putEdge_nodesNotInGraph()", "filename": "AbstractStandardDirectedGraphTest.putEdge_nodesNotInGraph.json"}
{"callee_method_names": ["MutableValueGraph<Integer, String>.incidentEdgeOrder", "MutableValueGraph<Integer, String>.edges"], "method_name": "AbstractStandardDirectedGraphTest.stableIncidentEdgeOrder_edges_returnsInStableOrder", "method_implementation": "{\n    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);\n    populateStarShapedGraph();\n    assertThat(graph.edges()).containsExactly(EndpointPair.ordered(2, 1), EndpointPair.ordered(1, 4), EndpointPair.ordered(1, 3), EndpointPair.ordered(1, 2), EndpointPair.ordered(3, 1), EndpointPair.ordered(5, 1)).inOrder();\n}", "repo_id": "5", "comment": "// Ideally, the ordering in test should never be updated.\n", "repo_name": "guava-master/", "id": 4049, "method_signature": "void stableIncidentEdgeOrder_edges_returnsInStableOrder()", "filename": "AbstractStandardDirectedGraphTest.stableIncidentEdgeOrder_edges_returnsInStableOrder.json"}
{"callee_method_names": [], "method_name": "AbstractStandardDirectedNetworkTest.addEdge_nodesNotInGraph", "method_implementation": "{\n    assume().that(graphIsMutable()).isTrue();\n    networkAsMutableNetwork.addNode(N1);\n    assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));\n    assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));\n    assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));\n    assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3);\n    assertThat(network.edges()).containsExactly(E15, E41, E23);\n    assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);\n    assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);\n    assertThat(network.edgesConnecting(N2, N3)).containsExactly(E23);\n    // Direction of the added edge is correctly handled\n    assertThat(network.edgesConnecting(N3, N2)).isEmpty();\n}", "repo_id": "5", "comment": "/**\n * This test checks an implementation dependent feature. It tests that the method {@code addEdge}\n * will silently add the missing nodes to the graph, then add the edge connecting them. We are not\n * using the proxy methods here as we want to test {@code addEdge} when the end-points are not\n * elements of the graph.\n */\n", "repo_name": "guava-master/", "id": 4047, "method_signature": "void addEdge_nodesNotInGraph()", "filename": "AbstractStandardDirectedNetworkTest.addEdge_nodesNotInGraph.json"}
{"callee_method_names": [], "method_name": "AbstractStandardUndirectedGraphTest.populateTShapedGraph", "method_implementation": "{\n    putEdge(2, 1);\n    putEdge(1, 4);\n    putEdge(1, 3);\n    // Duplicate\n    putEdge(1, 2);\n    putEdge(4, 5);\n}", "repo_id": "5", "comment": "/**\n * Populates the graph with nodes and edges in a star shape with node `1` in the middle.\n *\n * <p>Note that the edges are added in a shuffled order to properly test the effect of the\n * insertion order.\n */\n", "repo_name": "guava-master/", "id": 4064, "method_signature": "void populateTShapedGraph()", "filename": "AbstractStandardUndirectedGraphTest.populateTShapedGraph.json"}
{"callee_method_names": ["MutableGraph<Integer>.nodes", "MutableGraph<Integer>.adjacentNodes", "MutableGraph<Integer>.adjacentNodes", "MutableGraph<Integer>.adjacentNodes", "MutableGraph<Integer>.adjacentNodes", "MutableGraph<Integer>.adjacentNodes"], "method_name": "AbstractStandardUndirectedGraphTest.putEdge_nodesNotInGraph", "method_implementation": "{\n    assume().that(graphIsMutable()).isTrue();\n    graphAsMutableGraph.addNode(N1);\n    assertTrue(graphAsMutableGraph.putEdge(N1, N5));\n    assertTrue(graphAsMutableGraph.putEdge(N4, N1));\n    assertTrue(graphAsMutableGraph.putEdge(N2, N3));\n    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n    assertThat(graph.adjacentNodes(N1)).containsExactly(N4, N5);\n    assertThat(graph.adjacentNodes(N2)).containsExactly(N3);\n    assertThat(graph.adjacentNodes(N3)).containsExactly(N2);\n    assertThat(graph.adjacentNodes(N4)).containsExactly(N1);\n    assertThat(graph.adjacentNodes(N5)).containsExactly(N1);\n}", "repo_id": "5", "comment": "/**\n * Tests that the method {@code putEdge} will silently add the missing nodes to the graph, then\n * add the edge connecting them. We are not using the proxy methods here as we want to test {@code\n * putEdge} when the end-points are not elements of the graph.\n */\n", "repo_name": "guava-master/", "id": 4065, "method_signature": "void putEdge_nodesNotInGraph()", "filename": "AbstractStandardUndirectedGraphTest.putEdge_nodesNotInGraph.json"}
{"callee_method_names": ["MutableGraph<Integer>.incidentEdgeOrder", "MutableGraph<Integer>.edges"], "method_name": "AbstractStandardUndirectedGraphTest.stableIncidentEdgeOrder_edges_returnsInStableOrder", "method_implementation": "{\n    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);\n    populateTShapedGraph();\n    assertThat(graph.edges()).containsExactly(EndpointPair.unordered(1, 2), EndpointPair.unordered(1, 4), EndpointPair.unordered(1, 3), EndpointPair.unordered(4, 5)).inOrder();\n}", "repo_id": "5", "comment": "// Ideally, the ordering in test should never be updated.\n", "repo_name": "guava-master/", "id": 4063, "method_signature": "void stableIncidentEdgeOrder_edges_returnsInStableOrder()", "filename": "AbstractStandardUndirectedGraphTest.stableIncidentEdgeOrder_edges_returnsInStableOrder.json"}
{"callee_method_names": ["MutableNetwork<Integer, String>.nodes", "MutableNetwork<Integer, String>.edges", "MutableNetwork<Integer, String>.edgesConnecting", "MutableNetwork<Integer, String>.edgesConnecting", "MutableNetwork<Integer, String>.edgesConnecting", "MutableNetwork<Integer, String>.edgesConnecting"], "method_name": "AbstractStandardUndirectedNetworkTest.addEdge_nodesNotInGraph", "method_implementation": "{\n    assume().that(graphIsMutable()).isTrue();\n    networkAsMutableNetwork.addNode(N1);\n    assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));\n    assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));\n    assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));\n    assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3);\n    assertThat(network.edges()).containsExactly(E15, E41, E23);\n    assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);\n    assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);\n    assertThat(network.edgesConnecting(N2, N3)).containsExactly(E23);\n    assertThat(network.edgesConnecting(N3, N2)).containsExactly(E23);\n}", "repo_id": "5", "comment": "/**\n * This test checks an implementation dependent feature. It tests that the method {@code addEdge}\n * will silently add the missing nodes to the graph, then add the edge connecting them. We are not\n * using the proxy methods here as we want to test {@code addEdge} when the end-points are not\n * elements of the graph.\n */\n", "repo_name": "guava-master/", "id": 4066, "method_signature": "void addEdge_nodesNotInGraph()", "filename": "AbstractStandardUndirectedNetworkTest.addEdge_nodesNotInGraph.json"}
{"callee_method_names": ["ByteBuffer.remaining"], "method_name": "AbstractStreamingHasher.munchIfFull", "method_implementation": "{\n    if (buffer.remaining() < 8) {\n        // buffer is full; not enough room for a primitive. We have at least one full chunk.\n        munch();\n    }\n}", "repo_id": "5", "comment": "// Process pent-up data in chunks\n", "repo_name": "guava-master/", "id": 5237, "method_signature": "void munchIfFull()", "filename": "AbstractStreamingHasher.munchIfFull.json"}
{"callee_method_names": ["ByteBuffer.limit", "ByteBuffer.position", "ByteBuffer.putLong"], "method_name": "AbstractStreamingHasher.processRemaining", "method_implementation": "{\n    // move at the end\n    Java8Compatibility.position(bb, bb.limit());\n    // get ready to pad with longs\n    Java8Compatibility.limit(bb, chunkSize + 7);\n    while (bb.position() < chunkSize) {\n        bb.putLong(0);\n    }\n    Java8Compatibility.limit(bb, chunkSize);\n    Java8Compatibility.flip(bb);\n    process(bb);\n}", "repo_id": "5", "comment": "/**\n * This is invoked for the last bytes of the input, which are not enough to fill a whole chunk.\n * The passed {@code ByteBuffer} is guaranteed to be non-empty.\n *\n * <p>This implementation simply pads with zeros and delegates to {@link #process(ByteBuffer)}.\n */\n", "repo_name": "guava-master/", "id": 5236, "method_signature": "void processRemaining(ByteBuffer)", "filename": "AbstractStreamingHasher.processRemaining.json"}
{"callee_method_names": ["ByteArrayOutputStream.toByteArray"], "method_name": "AbstractStreamingHasherTest.assertInvariants", "method_implementation": "{\n    // we should have seen as many bytes as the next multiple of chunk after expectedBytes - 1\n    assertEquals(out.toByteArray().length, ceilToMultiple(expectedBytes, chunkSize));\n    assertEquals(expectedBytes / chunkSize, processCalled);\n    assertEquals(expectedBytes % chunkSize != 0, remainingCalled);\n}", "repo_id": "5", "comment": "// ensures that the number of invocations looks sane\n", "repo_name": "guava-master/", "id": 3744, "method_signature": "void assertInvariants(int)", "filename": "AbstractStreamingHasherTest.assertInvariants.json"}
{"callee_method_names": ["List<Sink>.add", "Control.newHasher", "Random.nextInt", "Hasher.putInt", "TestByteSink.hash", "Hasher.hash", "TestByteSink.assertInvariants", "TestByteSink.assertBytes"], "method_name": "AbstractStreamingHasherTest.testExhaustive", "method_implementation": "{\n    // will iteratively make more debuggable, each time it breaks\n    Random random = new Random(0);\n    for (int totalInsertions = 0; totalInsertions < 200; totalInsertions++) {\n        List<Sink> sinks = Lists.newArrayList();\n        for (int chunkSize = 4; chunkSize <= 32; chunkSize++) {\n            for (int bufferSize = chunkSize; bufferSize <= chunkSize * 4; bufferSize += chunkSize) {\n                // yes, that's a lot of sinks!\n                sinks.add(new Sink(chunkSize, bufferSize));\n                // For convenience, testing only with big endianness, to match DataOutputStream.\n                // I regard highly unlikely that both the little endianness tests above and this one\n                // passes, and there is still a little endianness bug lurking around.\n            }\n        }\n        Control control = new Control();\n        Hasher controlSink = control.newHasher(1024);\n        Iterable<Hasher> sinksAndControl = Iterables.concat(sinks, Collections.singleton(controlSink));\n        for (int insertion = 0; insertion < totalInsertions; insertion++) {\n            RandomHasherAction.pickAtRandom(random).performAction(random, sinksAndControl);\n        }\n        // We need to ensure that at least 4 bytes have been put into the hasher or else\n        // Hasher#hash will throw an ISE.\n        int intToPut = random.nextInt();\n        for (Hasher hasher : sinksAndControl) {\n            hasher.putInt(intToPut);\n        }\n        for (Sink sink : sinks) {\n            HashCode unused = sink.hash();\n        }\n        byte[] expected = controlSink.hash().asBytes();\n        for (Sink sink : sinks) {\n            sink.assertInvariants(expected.length);\n            sink.assertBytes(expected);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * This test creates a long random sequence of inputs, then a lot of differently configured sinks\n * process it; all should produce the same answer, the only difference should be the number of\n * process()/processRemaining() invocations, due to alignment.\n */\n", "repo_name": "guava-master/", "id": 3743, "method_signature": "void testExhaustive()", "filename": "AbstractStreamingHasherTest.testExhaustive.json"}
{"callee_method_names": ["Table<String, Integer, Character>.column"], "method_name": "AbstractTableReadTest.testColumnNull", "method_implementation": "{\n    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n    try {\n        table.column(null);\n        fail();\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "// This test assumes that the implementation does not support null keys.\n", "repo_name": "guava-master/", "id": 3953, "method_signature": "void testColumnNull()", "filename": "AbstractTableReadTest.testColumnNull.json"}
{"callee_method_names": ["Table<String, Integer, Character>.row"], "method_name": "AbstractTableReadTest.testRowNull", "method_implementation": "{\n    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n    try {\n        table.row(null);\n        fail();\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "// This test assumes that the implementation does not support null keys.\n", "repo_name": "guava-master/", "id": 3952, "method_signature": "void testRowNull()", "filename": "AbstractTableReadTest.testRowNull.json"}
{"callee_method_names": ["ImmutableTable<String, String, Integer>.put", "ImmutableTable<String, String, Integer>.put", "ImmutableTable<String, String, Integer>.put", "ImmutableTable<String, String, Integer>.contains", "ImmutableTable<String, String, Integer>.put"], "method_name": "AbstractTableTest.testPutNull", "method_implementation": "{\n    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n    assertSize(3);\n    try {\n        table.put(null, 2, 'd');\n        fail();\n    } catch (NullPointerException expected) {\n    }\n    try {\n        table.put(\"cat\", null, 'd');\n        fail();\n    } catch (NullPointerException expected) {\n    }\n    if (supportsNullValues()) {\n        assertNull(table.put(\"cat\", 2, null));\n        assertTrue(table.contains(\"cat\", 2));\n    } else {\n        try {\n            table.put(\"cat\", 2, null);\n            fail();\n        } catch (NullPointerException expected) {\n        }\n    }\n    assertSize(3);\n}", "repo_id": "5", "comment": "// This test assumes that the implementation does not support nulls.\n", "repo_name": "guava-master/", "id": 4021, "method_signature": "void testPutNull()", "filename": "AbstractTableTest.testPutNull.json"}
{"callee_method_names": [], "method_name": "AbstractTester.init", "method_implementation": "{\n    this.subjectGenerator = subjectGenerator;\n    this.suiteName = suiteName;\n    this.setUp = setUp;\n    this.tearDown = tearDown;\n}", "repo_id": "5", "comment": "// public so that it can be referenced in generated GWT tests.\n", "repo_name": "guava-master/", "id": 4199, "method_signature": "void init(G, String, Runnable, Runnable)", "filename": "AbstractTester.init.json"}
{"callee_method_names": ["Runnable.run"], "method_name": "AbstractTester.setUp", "method_implementation": "{\n    if (setUp != null) {\n        setUp.run();\n    }\n}", "repo_id": "5", "comment": "// public so that it can be referenced in generated GWT tests.\n", "repo_name": "guava-master/", "id": 4197, "method_signature": "void setUp()", "filename": "AbstractTester.setUp.json"}
{"callee_method_names": ["Runnable.run"], "method_name": "AbstractTester.tearDown", "method_implementation": "{\n    if (tearDown != null) {\n        tearDown.run();\n    }\n}", "repo_id": "5", "comment": "// public so that it can be referenced in generated GWT tests.\n", "repo_name": "guava-master/", "id": 4198, "method_signature": "void tearDown()", "filename": "AbstractTester.tearDown.json"}
{"callee_method_names": [], "method_name": "AbstractValueGraph.toString", "method_implementation": "{\n    return \"isDirected: \" + isDirected() + \", allowsSelfLoops: \" + allowsSelfLoops() + \", nodes: \" + nodes() + \", edges: \" + edgeValueMap(this);\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this graph.\n */\n", "repo_name": "guava-master/", "id": 6800, "method_signature": "String toString()", "filename": "AbstractValueGraph.toString.json"}
{"callee_method_names": ["Throwable.getCause", "Set<Throwable>.add"], "method_name": "AggregateFuture.addCausalChain", "method_implementation": "{\n    // Declare a \"true\" local variable so that the Checker Framework will infer nullness.\n    Throwable t = param;\n    for (; t != null; t = t.getCause()) {\n        boolean firstTimeSeen = seen.add(t);\n        if (!firstTimeSeen) {\n            /*\n         * We've seen this, so we've seen its causes, too. No need to re-add them. (There's one case\n         * where this isn't true, but we ignore it: If we record an exception, then someone calls\n         * initCause() on it, and then we examine it again, we'll conclude that we've seen the whole\n         * chain before when in fact we haven't. But this should be rare.)\n         */\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Adds the chain to the seen set, and returns whether all the chain was new to us.\n */\n", "repo_name": "guava-master/", "id": 5386, "method_signature": "boolean addCausalChain(Set, Throwable)", "filename": "AggregateFuture.addCausalChain.json"}
{"callee_method_names": ["Entry<?, ?>.getCause"], "method_name": "AggregateFuture.collectValueFromNonCancelledFuture", "method_implementation": "{\n    try {\n        // We get the result, even if collectOneValue is a no-op, so that we can fail fast.\n        collectOneValue(index, getDone(future));\n    } catch (ExecutionException e) {\n        handleException(e.getCause());\n    } catch (Throwable t) {\n        // sneaky checked exception\n        handleException(t);\n    }\n}", "repo_id": "5", "comment": "/**\n * Collects the result (success or failure) of one input future. The input must not have been\n * cancelled. For details on when this is called, see {@link #collectOneValue}.\n */\n", "repo_name": "guava-master/", "id": 5384, "method_signature": "void collectValueFromNonCancelledFuture(int, Future)", "filename": "AggregateFuture.collectValueFromNonCancelledFuture.json"}
{"callee_method_names": [], "method_name": "AggregateFuture.handleException", "method_implementation": "{\n    checkNotNull(throwable);\n    if (allMustSucceed) {\n        // As soon as the first one fails, make that failure the result of the output future.\n        // The results of all other inputs are then ignored (except for logging any failures).\n        boolean completedWithFailure = setException(throwable);\n        if (!completedWithFailure) {\n            // Go up the causal chain to see if we've already seen this cause; if we have, even if\n            // it's wrapped by a different exception, don't log it.\n            boolean firstTimeSeeingThisException = addCausalChain(getOrInitSeenExceptions(), throwable);\n            if (firstTimeSeeingThisException) {\n                log(throwable);\n                return;\n            }\n        }\n    }\n    /*\n     * TODO(cpovirk): Should whenAllComplete().call*() log errors, too? Currently, it doesn't call\n     * handleException() at all.\n     */\n    if (throwable instanceof Error) {\n        /*\n       * TODO(cpovirk): Do we really want to log this if we called setException(throwable) and it\n       * returned true? This was intentional (CL 46470009), but it seems odd compared to how we\n       * normally handle Error.\n       *\n       * Similarly, do we really want to log the same Error more than once?\n       */\n        log(throwable);\n    }\n}", "repo_id": "5", "comment": "/**\n * Fails this future with the given Throwable if {@link #allMustSucceed} is true. Also, logs the\n * throwable if it is an {@link Error} or if {@link #allMustSucceed} is {@code true}, the\n * throwable did not cause this future to fail, and it is the first time we've seen that\n * particular Throwable.\n */\n", "repo_name": "guava-master/", "id": 5383, "method_signature": "void handleException(Throwable)", "filename": "AggregateFuture.handleException.json"}
{"callee_method_names": ["ImmutableCollection<? extends ListenableFuture<? extends InputT>>.isEmpty", "Future<V>.addListener", "Future<V>.isCancelled", "Future<V>.addListener"], "method_name": "AggregateFuture.init", "method_implementation": "{\n    /*\n     * requireNonNull is safe because this is called from the constructor after `futures` is set but\n     * before releaseResources could be called (because we have not yet set up any of the listeners\n     * that could call it, nor exposed this Future for users to call cancel() on).\n     */\n    requireNonNull(futures);\n    // Corner case: List is empty.\n    if (futures.isEmpty()) {\n        handleAllCompleted();\n        return;\n    }\n    // NOTE: If we ever want to use a custom executor here, have a look at CombinedFuture as we'll\n    // need to handle RejectedExecutionException\n    if (allMustSucceed) {\n        // We need fail fast, so we have to keep track of which future failed so we can propagate\n        // the exception immediately\n        // Register a listener on each Future in the list to update the state of this future.\n        // Note that if all the futures on the list are done prior to completing this loop, the last\n        // call to addListener() will callback to setOneValue(), transitively call our cleanup\n        // listener, and set this.futures to null.\n        // This is not actually a problem, since the foreach only needs this.futures to be non-null\n        // at the beginning of the loop.\n        int i = 0;\n        for (ListenableFuture<? extends InputT> future : futures) {\n            int index = i++;\n            future.addListener(() -> {\n                try {\n                    if (future.isCancelled()) {\n                        // Clear futures prior to cancelling children. This sets our own state but lets\n                        // the input futures keep running, as some of them may be used elsewhere.\n                        futures = null;\n                        cancel(false);\n                    } else {\n                        collectValueFromNonCancelledFuture(index, future);\n                    }\n                } finally {\n                    /*\n                 * \"null\" means: There is no need to access `futures` again during\n                 * `processCompleted` because we're reading each value during a call to\n                 * handleOneInputDone.\n                 */\n                    decrementCountAndMaybeComplete(null);\n                }\n            }, directExecutor());\n        }\n    } else {\n        /*\n       * We'll call the user callback or collect the values only when all inputs complete,\n       * regardless of whether some failed. This lets us avoid calling expensive methods like\n       * Future.get() when we don't need to (specifically, for whenAllComplete().call*()), and it\n       * lets all futures share the same listener.\n       *\n       * We store `localFutures` inside the listener because `this.futures` might be nulled out by\n       * the time the listener runs for the final future -- at which point we need to check all\n       * inputs for exceptions *if* we're collecting values. If we're not, then the listener doesn't\n       * need access to the futures again, so we can just pass `null`.\n       *\n       * TODO(b/112550045): Allocating a single, cheaper listener is (I think) only an optimization.\n       * If we make some other optimizations, this one will no longer be necessary. The optimization\n       * could actually hurt in some cases, as it forces us to keep all inputs in memory until the\n       * final input completes.\n       */\n        ImmutableCollection<? extends Future<? extends InputT>> localFutures = collectsValues ? futures : null;\n        Runnable listener = () -> decrementCountAndMaybeComplete(localFutures);\n        for (ListenableFuture<? extends InputT> future : futures) {\n            future.addListener(listener, directExecutor());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Must be called at the end of each subclass's constructor. This method performs the \"real\"\n * initialization; we can't put this in the constructor because, in the case where futures are\n * already complete, we would not initialize the subclass before calling {@link\n * #collectValueFromNonCancelledFuture}. As this is called after the subclass is constructed,\n * we're guaranteed to have properly initialized the subclass.\n */\n", "repo_name": "guava-master/", "id": 5382, "method_signature": "void init()", "filename": "AggregateFuture.init.json"}
{"callee_method_names": [], "method_name": "AggregateFuture.releaseResources", "method_implementation": "{\n    checkNotNull(reason);\n    /*\n     * All elements of `futures` are completed, or this future has already completed and read\n     * `futures` into a local variable (in preparation for propagating cancellation to them). In\n     * either case, no one needs to read `futures` for cancellation purposes later. (And\n     * cancellation purposes are the main reason to access `futures`, as discussed in its docs.)\n     */\n    this.futures = null;\n}", "repo_id": "5", "comment": "// TODO(user): Write more tests for memory retention.\n", "repo_name": "guava-master/", "id": 5385, "method_signature": "void releaseResources(ReleaseResourcesReason)", "filename": "AggregateFuture.releaseResources.json"}
{"callee_method_names": [], "method_name": "Alphabet.ignoreCase", "method_implementation": "{\n    if (ignoreCase) {\n        return this;\n    }\n    // We can't use .clone() because of GWT.\n    byte[] newDecodabet = Arrays.copyOf(decodabet, decodabet.length);\n    for (int upper = 'A'; upper <= 'Z'; upper++) {\n        int lower = upper | 0x20;\n        byte decodeUpper = decodabet[upper];\n        byte decodeLower = decodabet[lower];\n        if (decodeUpper == -1) {\n            newDecodabet[upper] = decodeLower;\n        } else {\n            checkState(decodeLower == -1, \"Can't ignoreCase() since '%s' and '%s' encode different values\", (char) upper, (char) lower);\n            newDecodabet[lower] = decodeUpper;\n        }\n    }\n    return new Alphabet(name + \".ignoreCase()\", chars, newDecodabet, /* ignoreCase= */\n    true);\n}", "repo_id": "5", "comment": "/**\n * Returns an equivalent {@code Alphabet} except it ignores case.\n */\n", "repo_name": "guava-master/", "id": 4807, "method_signature": "Alphabet ignoreCase()", "filename": "Alphabet.ignoreCase.json"}
{"callee_method_names": ["ClassToInstanceMap<Object>.getInstance", "Class<T>.isEnum", "Class<T>.getEnumConstants", "Class<T>.isArray", "Class<T>.getModifiers", "Class<T>.getModifiers", "Class<T>.getConstructor", "Constructor<T>.setAccessible", "Constructor<T>.newInstance", "Logger.log", "UnicodeEscaper.getCause"], "method_name": "ArbitraryInstances.get", "method_implementation": "{\n    T defaultValue = DEFAULTS.getInstance(type);\n    if (defaultValue != null) {\n        return defaultValue;\n    }\n    Class<? extends T> implementation = getImplementation(type);\n    if (implementation != null) {\n        return get(implementation);\n    }\n    if (type.isEnum()) {\n        T[] enumConstants = type.getEnumConstants();\n        return (enumConstants == null || enumConstants.length == 0) ? null : enumConstants[0];\n    }\n    if (type.isArray()) {\n        return createEmptyArray(type);\n    }\n    T jvmDefault = Defaults.defaultValue(Primitives.unwrap(type));\n    if (jvmDefault != null) {\n        return jvmDefault;\n    }\n    if (Modifier.isAbstract(type.getModifiers()) || !Modifier.isPublic(type.getModifiers())) {\n        return arbitraryConstantInstanceOrNull(type);\n    }\n    final Constructor<T> constructor;\n    try {\n        constructor = type.getConstructor();\n    } catch (NoSuchMethodException e) {\n        return arbitraryConstantInstanceOrNull(type);\n    }\n    // accessibility check is too slow\n    constructor.setAccessible(true);\n    try {\n        return constructor.newInstance();\n        /*\n       * Do not merge the 2 catch blocks below. javac would infer a type of\n       * ReflectiveOperationException, which Animal Sniffer would reject. (Old versions of\n       * Android don't *seem* to mind, but there might be edge cases of which we're unaware.)\n       */\n    } catch (InstantiationException impossible) {\n        throw new AssertionError(impossible);\n    } catch (IllegalAccessException impossible) {\n        throw new AssertionError(impossible);\n    } catch (InvocationTargetException e) {\n        logger.log(Level.WARNING, \"Exception while invoking default constructor.\", e.getCause());\n        return arbitraryConstantInstanceOrNull(type);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an arbitrary instance for {@code type}, or {@code null} if no arbitrary instance can be\n * determined.\n */\n", "repo_name": "guava-master/", "id": 4138, "method_signature": "T get(Class)", "filename": "ArbitraryInstances.get.json"}
{"callee_method_names": ["Matcher.find", "Matcher.toMatchResult"], "method_name": "ArbitraryInstances.newMatchResult", "method_implementation": "{\n    Matcher matcher = Pattern.compile(\".\").matcher(\"X\");\n    matcher.find();\n    return matcher.toMatchResult();\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code MatchResult} that corresponds to a successful match. Apache Harmony (used\n * in Android) requires a successful match in order to generate a {@code MatchResult}:\n * http://goo.gl/5VQFmC\n */\n", "repo_name": "guava-master/", "id": 4137, "method_signature": "MatchResult newMatchResult()", "filename": "ArbitraryInstances.newMatchResult.json"}
{"callee_method_names": ["Object[].clone"], "method_name": "ArrayBasedBuilder.getReadyToExpandTo", "method_implementation": "{\n    if (contents.length < minCapacity) {\n        this.contents = Arrays.copyOf(this.contents, expandedCapacity(contents.length, minCapacity));\n        forceCopy = false;\n    } else if (forceCopy) {\n        this.contents = contents.clone();\n        forceCopy = false;\n    }\n}", "repo_id": "5", "comment": "/*\n     * Expand the absolute capacity of the builder so it can accept at least the specified number of\n     * elements without being resized. Also, if we've already built a collection backed by the\n     * current array, create a new array.\n     */\n", "repo_name": "guava-master/", "id": 5912, "method_signature": "void getReadyToExpandTo(int)", "filename": "ArrayBasedBuilder.getReadyToExpandTo.json"}
{"callee_method_names": [], "method_name": "ArrayBasedCharEscaper.escape", "method_implementation": "{\n    if (c < replacementsLength) {\n        char[] chars = replacements[c];\n        if (chars != null) {\n            return chars;\n        }\n    }\n    if (c >= safeMin && c <= safeMax) {\n        return null;\n    }\n    return escapeUnsafe(c);\n}", "repo_id": "5", "comment": "/**\n * Escapes a single character using the replacement array and safe range values. If the given\n * character does not have an explicit replacement and lies outside the safe range then {@link\n * #escapeUnsafe} is called.\n *\n * @return the replacement characters, or {@code null} if no escaping was required\n */\n", "repo_name": "guava-master/", "id": 4262, "method_signature": "char[] escape(char)", "filename": "ArrayBasedCharEscaper.escape.json"}
{"callee_method_names": ["Map<Character,String>.isEmpty", "Map<Character,String>.keySet", "Map<Character,String>.keySet", "Map<Character,String>.get"], "method_name": "ArrayBasedEscaperMap.createReplacementArray", "method_implementation": "{\n    // GWT specific check (do not optimize)\n    checkNotNull(map);\n    if (map.isEmpty()) {\n        return EMPTY_REPLACEMENT_ARRAY;\n    }\n    char max = Collections.max(map.keySet());\n    char[][] replacements = new char[max + 1][];\n    for (Character c : map.keySet()) {\n        replacements[c] = map.get(c).toCharArray();\n    }\n    return replacements;\n}", "repo_id": "5", "comment": "// original character value.\n", "repo_name": "guava-master/", "id": 4281, "method_signature": "char[][] createReplacementArray(Map)", "filename": "ArrayBasedEscaperMap.createReplacementArray.json"}
{"callee_method_names": [], "method_name": "ArrayBasedUnicodeEscaper.escape", "method_implementation": "{\n    if (cp < replacementsLength) {\n        char[] chars = replacements[cp];\n        if (chars != null) {\n            return chars;\n        }\n    }\n    if (cp >= safeMin && cp <= safeMax) {\n        return null;\n    }\n    return escapeUnsafe(cp);\n}", "repo_id": "5", "comment": "/**\n * Escapes a single Unicode code point using the replacement array and safe range values. If the\n * given character does not have an explicit replacement and lies outside the safe range then\n * {@link #escapeUnsafe} is called.\n *\n * @return the replacement characters, or {@code null} if no escaping was required\n */\n", "repo_name": "guava-master/", "id": 4264, "method_signature": "char[] escape(int)", "filename": "ArrayBasedUnicodeEscaper.escape.json"}
{"callee_method_names": ["CharSequence.charAt"], "method_name": "ArrayBasedUnicodeEscaper.nextEscapeIndex", "method_implementation": "{\n    while (index < end) {\n        char c = csq.charAt(index);\n        if ((c < replacementsLength && replacements[c] != null) || c > safeMaxChar || c < safeMinChar) {\n            break;\n        }\n        index++;\n    }\n    return index;\n}", "repo_id": "5", "comment": "/* Overridden for performance. */\n", "repo_name": "guava-master/", "id": 4265, "method_signature": "int nextEscapeIndex(CharSequence, int, int)", "filename": "ArrayBasedUnicodeEscaper.nextEscapeIndex.json"}
{"callee_method_names": ["ArrayList<V>.trimToSize"], "method_name": "ArrayListMultimap.trimToSize", "method_implementation": "{\n    for (Collection<V> collection : backingMap().values()) {\n        ArrayList<V> arrayList = (ArrayList<V>) collection;\n        arrayList.trimToSize();\n    }\n}", "repo_id": "5", "comment": "/**\n * Reduces the memory used by this {@code ArrayListMultimap}, if feasible.\n *\n * @deprecated For a {@link ListMultimap} that automatically trims to size, use {@link\n *     ImmutableListMultimap}. If you need a mutable collection, remove the {@code trimToSize}\n *     call, or switch to a {@code HashMap<K, ArrayList<V>>}.\n */\n", "repo_name": "guava-master/", "id": 6285, "method_signature": "void trimToSize()", "filename": "ArrayListMultimap.trimToSize.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject"], "method_name": "ArrayListMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    Serialization.writeMultimap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData expectedValuesPerKey, number of distinct keys, and then for each distinct key: the\n *     key, number of values for that key, and the key's values\n */\n", "repo_name": "guava-master/", "id": 6286, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "ArrayListMultimap.writeObject.json"}
{"callee_method_names": ["Multimap<String, Integer>.put", "Multimap<String, Integer>.put", "Multimap<String, Integer>.get", "Multimap<String, Integer>.get"], "method_name": "ArrayListMultimapTest.testGetRandomAccess", "method_implementation": "{\n    Multimap<String, Integer> multimap = create();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 3);\n    assertTrue(multimap.get(\"foo\") instanceof RandomAccess);\n    assertTrue(multimap.get(\"bar\") instanceof RandomAccess);\n}", "repo_id": "5", "comment": "/**\n * Confirm that get() returns a List implementing RandomAccess.\n */\n", "repo_name": "guava-master/", "id": 4005, "method_signature": "void testGetRandomAccess()", "filename": "ArrayListMultimapTest.testGetRandomAccess.json"}
{"callee_method_names": ["Multimap<String, Integer>.put", "Multimap<String, Integer>.put", "Multimap<String, Integer>.removeAll", "Multimap<String, Integer>.removeAll"], "method_name": "ArrayListMultimapTest.testRemoveAllRandomAccess", "method_implementation": "{\n    Multimap<String, Integer> multimap = create();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 3);\n    assertTrue(multimap.removeAll(\"foo\") instanceof RandomAccess);\n    assertTrue(multimap.removeAll(\"bar\") instanceof RandomAccess);\n}", "repo_id": "5", "comment": "/**\n * Confirm that removeAll() returns a List implementing RandomAccess.\n */\n", "repo_name": "guava-master/", "id": 4006, "method_signature": "void testRemoveAllRandomAccess()", "filename": "ArrayListMultimapTest.testRemoveAllRandomAccess.json"}
{"callee_method_names": ["Multimap<String, Integer>.put", "Multimap<String, Integer>.put", "Multimap<String, Integer>.replaceValues", "Multimap<String, Integer>.replaceValues"], "method_name": "ArrayListMultimapTest.testReplaceValuesRandomAccess", "method_implementation": "{\n    Multimap<String, Integer> multimap = create();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 3);\n    assertTrue(multimap.replaceValues(\"foo\", asList(2, 4)) instanceof RandomAccess);\n    assertTrue(multimap.replaceValues(\"bar\", asList(2, 4)) instanceof RandomAccess);\n}", "repo_id": "5", "comment": "/**\n * Confirm that replaceValues() returns a List implementing RandomAccess.\n */\n", "repo_name": "guava-master/", "id": 4007, "method_signature": "void testReplaceValuesRandomAccess()", "filename": "ArrayListMultimapTest.testReplaceValuesRandomAccess.json"}
{"callee_method_names": ["ListMultimap<String, Integer>.putAll", "ListMultimap<String, Integer>.get", "ListMultimap<String, Integer>.get", "List<Integer>.subList", "List<Integer>.clear", "List<Integer>.isEmpty", "ListMultimap<String, Integer>.put", "List<Integer>.isEmpty"], "method_name": "ArrayListMultimapTest.testSublistConcurrentModificationException", "method_implementation": "{\n    ListMultimap<String, Integer> multimap = create();\n    multimap.putAll(\"foo\", asList(1, 2, 3, 4, 5));\n    List<Integer> list = multimap.get(\"foo\");\n    assertThat(multimap.get(\"foo\")).containsExactly(1, 2, 3, 4, 5).inOrder();\n    List<Integer> sublist = list.subList(0, 5);\n    assertThat(sublist).containsExactly(1, 2, 3, 4, 5).inOrder();\n    sublist.clear();\n    assertTrue(sublist.isEmpty());\n    multimap.put(\"foo\", 6);\n    try {\n        sublist.isEmpty();\n        fail(\"Expected ConcurrentModificationException\");\n    } catch (ConcurrentModificationException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Test throwing ConcurrentModificationException when a sublist's ancestor's delegate changes.\n */\n", "repo_name": "guava-master/", "id": 4008, "method_signature": "void testSublistConcurrentModificationException()", "filename": "ArrayListMultimapTest.testSublistConcurrentModificationException.json"}
{"callee_method_names": ["ImmutableList<R>.size", "ImmutableList<C>.size"], "method_name": "ArrayTable.at", "method_implementation": "{\n    // In GWT array access never throws IndexOutOfBoundsException.\n    checkElementIndex(rowIndex, rowList.size());\n    checkElementIndex(columnIndex, columnList.size());\n    return array[rowIndex][columnIndex];\n}", "repo_id": "5", "comment": "/**\n * Returns the value corresponding to the specified row and column indices. The same value is\n * returned by {@code get(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex))}, but this\n * method runs more quickly.\n *\n * @param rowIndex position of the row key in {@link #rowKeyList()}\n * @param columnIndex position of the row key in {@link #columnKeyList()}\n * @return the value with the specified row and column\n * @throws IndexOutOfBoundsException if either index is negative, {@code rowIndex} is greater than\n *     or equal to the number of allowed row keys, or {@code columnIndex} is greater than or equal\n *     to the number of allowed column keys\n */\n", "repo_name": "guava-master/", "id": 5849, "method_signature": "V at(int, int)", "filename": "ArrayTable.at.json"}
{"callee_method_names": [], "method_name": "ArrayTable.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #eraseAll} instead.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link #eraseAll}\n */\n", "repo_name": "guava-master/", "id": 5852, "method_signature": "void clear()", "filename": "ArrayTable.clear.json"}
{"callee_method_names": ["ImmutableMap<C, Integer>.get"], "method_name": "ArrayTable.column", "method_implementation": "{\n    checkNotNull(columnKey);\n    Integer columnIndex = columnKeyToIndex.get(columnKey);\n    if (columnIndex == null) {\n        return emptyMap();\n    } else {\n        return new Column(columnIndex);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a view of all mappings that have the given column key. If the column key isn't in\n * {@link #columnKeySet()}, an empty immutable map is returned.\n *\n * <p>Otherwise, for each row key in {@link #rowKeySet()}, the returned map associates the row key\n * with the corresponding value in the table. Changes to the returned map will update the\n * underlying table, and vice versa.\n *\n * @param columnKey key of column to search for in the table\n * @return the corresponding map from row keys to values\n */\n", "repo_name": "guava-master/", "id": 5857, "method_signature": "Map<R,V> column(C)", "filename": "ArrayTable.column.json"}
{"callee_method_names": [], "method_name": "ArrayTable.create", "method_implementation": "{\n    return (table instanceof ArrayTable) ? new ArrayTable<R, C, V>((ArrayTable<R, C, V>) table) : new ArrayTable<R, C, V>(table);\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code ArrayTable} with the mappings in the provided table.\n *\n * <p>If {@code table} includes a mapping with row key {@code r} and a separate mapping with\n * column key {@code c}, the returned table contains a mapping with row key {@code r} and column\n * key {@code c}. If that row key / column key pair in not in {@code table}, the pair maps to\n * {@code null} in the generated table.\n *\n * <p>The returned table allows subsequent {@code put} calls with the row keys in {@code\n * table.rowKeySet()} and the column keys in {@code table.columnKeySet()}. Calling {@link #put}\n * with other keys leads to an {@code IllegalArgumentException}.\n *\n * <p>The ordering of {@code table.rowKeySet()} and {@code table.columnKeySet()} determines the\n * row and column iteration ordering of the returned table.\n *\n * @throws NullPointerException if {@code table} has a null key\n */\n", "repo_name": "guava-master/", "id": 5848, "method_signature": "ArrayTable<R,C,V> create(Table)", "filename": "ArrayTable.create.json"}
{"callee_method_names": ["ImmutableMap<R, Integer>.get", "ImmutableMap<C, Integer>.get"], "method_name": "ArrayTable.erase", "method_implementation": "{\n    Integer rowIndex = rowKeyToIndex.get(rowKey);\n    Integer columnIndex = columnKeyToIndex.get(columnKey);\n    if (rowIndex == null || columnIndex == null) {\n        return null;\n    }\n    return set(rowIndex, columnIndex, null);\n}", "repo_id": "5", "comment": "/**\n * Associates the value {@code null} with the specified keys, assuming both keys are valid. If\n * either key is null or isn't among the keys provided during construction, this method has no\n * effect.\n *\n * <p>This method is equivalent to {@code put(rowKey, columnKey, null)} when both provided keys\n * are valid.\n *\n * @param rowKey row key of mapping to be erased\n * @param columnKey column key of mapping to be erased\n * @return the value previously associated with the keys, or {@code null} if no mapping existed\n *     for the keys\n */\n", "repo_name": "guava-master/", "id": 5856, "method_signature": "V erase(Object, Object)", "filename": "ArrayTable.erase.json"}
{"callee_method_names": [], "method_name": "ArrayTable.eraseAll", "method_implementation": "{\n    for (@Nullable V[] row : array) {\n        Arrays.fill(row, null);\n    }\n}", "repo_id": "5", "comment": "/**\n * Associates the value {@code null} with every pair of allowed row and column keys.\n */\n", "repo_name": "guava-master/", "id": 5853, "method_signature": "void eraseAll()", "filename": "ArrayTable.eraseAll.json"}
{"callee_method_names": ["ImmutableMap<R, Integer>.get", "ImmutableMap<C, Integer>.get"], "method_name": "ArrayTable.put", "method_implementation": "{\n    checkNotNull(rowKey);\n    checkNotNull(columnKey);\n    Integer rowIndex = rowKeyToIndex.get(rowKey);\n    checkArgument(rowIndex != null, \"Row %s not in %s\", rowKey, rowList);\n    Integer columnIndex = columnKeyToIndex.get(columnKey);\n    checkArgument(columnIndex != null, \"Column %s not in %s\", columnKey, columnList);\n    return set(rowIndex, columnIndex, value);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @throws IllegalArgumentException if {@code rowKey} is not in {@link #rowKeySet()} or {@code\n *     columnKey} is not in {@link #columnKeySet()}.\n */\n", "repo_name": "guava-master/", "id": 5854, "method_signature": "V put(R, C, V)", "filename": "ArrayTable.put.json"}
{"callee_method_names": [], "method_name": "ArrayTable.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #erase} instead.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link #erase}\n */\n", "repo_name": "guava-master/", "id": 5855, "method_signature": "V remove(Object, Object)", "filename": "ArrayTable.remove.json"}
{"callee_method_names": ["ImmutableMap<R, Integer>.get"], "method_name": "ArrayTable.row", "method_implementation": "{\n    checkNotNull(rowKey);\n    Integer rowIndex = rowKeyToIndex.get(rowKey);\n    if (rowIndex == null) {\n        return emptyMap();\n    } else {\n        return new Row(rowIndex);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a view of all mappings that have the given row key. If the row key isn't in {@link\n * #rowKeySet()}, an empty immutable map is returned.\n *\n * <p>Otherwise, for each column key in {@link #columnKeySet()}, the returned map associates the\n * column key with the corresponding value in the table. Changes to the returned map will update\n * the underlying table, and vice versa.\n *\n * @param rowKey key of row to search for in the table\n * @return the corresponding map from column keys to values\n */\n", "repo_name": "guava-master/", "id": 5858, "method_signature": "Map<C,V> row(R)", "filename": "ArrayTable.row.json"}
{"callee_method_names": ["ImmutableList<R>.size", "ImmutableList<C>.size"], "method_name": "ArrayTable.set", "method_implementation": "{\n    // In GWT array access never throws IndexOutOfBoundsException.\n    checkElementIndex(rowIndex, rowList.size());\n    checkElementIndex(columnIndex, columnList.size());\n    V oldValue = array[rowIndex][columnIndex];\n    array[rowIndex][columnIndex] = value;\n    return oldValue;\n}", "repo_id": "5", "comment": "/**\n * Associates {@code value} with the specified row and column indices. The logic {@code\n * put(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex), value)} has the same\n * behavior, but this method runs more quickly.\n *\n * @param rowIndex position of the row key in {@link #rowKeyList()}\n * @param columnIndex position of the row key in {@link #columnKeyList()}\n * @param value value to store in the table\n * @return the previous value with the specified row and column\n * @throws IndexOutOfBoundsException if either index is negative, {@code rowIndex} is greater than\n *     or equal to the number of allowed row keys, or {@code columnIndex} is greater than or equal\n *     to the number of allowed column keys\n */\n", "repo_name": "guava-master/", "id": 5850, "method_signature": "V set(int, int, V)", "filename": "ArrayTable.set.json"}
{"callee_method_names": ["ImmutableList<R>.size", "ImmutableList<C>.size", "ImmutableList<R>.size"], "method_name": "ArrayTable.toArray", "method_implementation": "{\n    // TODO: safe?\n    @SuppressWarnings(\"unchecked\")\n    @Nullable\n    V[][] copy = (@Nullable V[][]) Array.newInstance(valueClass, rowList.size(), columnList.size());\n    for (int i = 0; i < rowList.size(); i++) {\n        System.arraycopy(array[i], 0, copy[i], 0, array[i].length);\n    }\n    return copy;\n}", "repo_id": "5", "comment": "/**\n * Returns a two-dimensional array with the table contents. The row and column indices correspond\n * to the positions of the row and column in the iterables provided during table construction. If\n * the table lacks a mapping for a given row and column, the corresponding array element is null.\n *\n * <p>Subsequent table changes will not modify the array, and vice versa.\n *\n * @param valueClass class of values stored in the returned array\n */\n", "repo_name": "guava-master/", "id": 5851, "method_signature": "V[][] toArray(Class)", "filename": "ArrayTable.toArray.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "Ascii.equalsIgnoreCase", "method_implementation": "{\n    // Calling length() is the null pointer check (so do it before we can exit early).\n    int length = s1.length();\n    if (s1 == s2) {\n        return true;\n    }\n    if (length != s2.length()) {\n        return false;\n    }\n    for (int i = 0; i < length; i++) {\n        char c1 = s1.charAt(i);\n        char c2 = s2.charAt(i);\n        if (c1 == c2) {\n            continue;\n        }\n        int alphaIndex = getAlphaIndex(c1);\n        // This was also benchmarked using '&' to avoid branching (but always evaluate the rhs),\n        // however this showed no obvious improvement.\n        if (alphaIndex < 26 && alphaIndex == getAlphaIndex(c2)) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Indicates whether the contents of the given character sequences {@code s1} and {@code s2} are\n * equal, ignoring the case of any ASCII alphabetic characters between {@code 'a'} and {@code 'z'}\n * or {@code 'A'} and {@code 'Z'} inclusive.\n *\n * <p>This method is significantly faster than {@link String#equalsIgnoreCase} and should be used\n * in preference if at least one of the parameters is known to contain only ASCII characters.\n *\n * <p>Note however that this method does not always behave identically to expressions such as:\n *\n * <ul>\n *   <li>{@code string.toUpperCase().equals(\"UPPER CASE ASCII\")}\n *   <li>{@code string.toLowerCase().equals(\"lower case ascii\")}\n * </ul>\n *\n * <p>due to case-folding of some non-ASCII characters (which does not occur in {@link\n * String#equalsIgnoreCase}). However in almost all cases that ASCII strings are used, the author\n * probably wanted the behavior provided by this method rather than the subtle and sometimes\n * surprising behavior of {@code toUpperCase()} and {@code toLowerCase()}.\n *\n * @since 16.0\n */\n", "repo_name": "guava-master/", "id": 5181, "method_signature": "boolean equalsIgnoreCase(CharSequence, CharSequence)", "filename": "Ascii.equalsIgnoreCase.json"}
{"callee_method_names": [], "method_name": "Ascii.isLowerCase", "method_implementation": "{\n    // Note: This was benchmarked against the alternate expression \"(char)(c - 'a') < 26\" (Nov '13)\n    // and found to perform at least as well, or better.\n    return (c >= 'a') && (c <= 'z');\n}", "repo_id": "5", "comment": "/**\n * Indicates whether {@code c} is one of the twenty-six lowercase ASCII alphabetic characters\n * between {@code 'a'} and {@code 'z'} inclusive. All others (including non-ASCII characters)\n * return {@code false}.\n */\n", "repo_name": "guava-master/", "id": 5179, "method_signature": "boolean isLowerCase(char)", "filename": "Ascii.isLowerCase.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "Ascii.toLowerCase", "method_implementation": "{\n    if (chars instanceof String) {\n        return toLowerCase((String) chars);\n    }\n    char[] newChars = new char[chars.length()];\n    for (int i = 0; i < newChars.length; i++) {\n        newChars[i] = toLowerCase(chars.charAt(i));\n    }\n    return String.valueOf(newChars);\n}", "repo_id": "5", "comment": "/**\n * Returns a copy of the input character sequence in which all {@linkplain #isUpperCase(char)\n * uppercase ASCII characters} have been converted to lowercase. All other characters are copied\n * without modification.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 5176, "method_signature": "String toLowerCase(CharSequence)", "filename": "Ascii.toLowerCase.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "Ascii.toUpperCase", "method_implementation": "{\n    if (chars instanceof String) {\n        return toUpperCase((String) chars);\n    }\n    char[] newChars = new char[chars.length()];\n    for (int i = 0; i < newChars.length; i++) {\n        newChars[i] = toUpperCase(chars.charAt(i));\n    }\n    return String.valueOf(newChars);\n}", "repo_id": "5", "comment": "/**\n * Returns a copy of the input character sequence in which all {@linkplain #isLowerCase(char)\n * lowercase ASCII characters} have been converted to uppercase. All other characters are copied\n * without modification.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 5178, "method_signature": "String toUpperCase(CharSequence)", "filename": "Ascii.toUpperCase.json"}
{"callee_method_names": ["String.length", "String.length", "CharSequence.length", "CharSequence.toString", "String.length"], "method_name": "Ascii.truncate", "method_implementation": "{\n    checkNotNull(seq);\n    // length to truncate the sequence to, not including the truncation indicator\n    int truncationLength = maxLength - truncationIndicator.length();\n    // in this worst case, this allows a maxLength equal to the length of the truncationIndicator,\n    // meaning that a string will be truncated to just the truncation indicator itself\n    checkArgument(truncationLength >= 0, \"maxLength (%s) must be >= length of the truncation indicator (%s)\", maxLength, truncationIndicator.length());\n    if (seq.length() <= maxLength) {\n        String string = seq.toString();\n        if (string.length() <= maxLength) {\n            return string;\n        }\n        // if the length of the toString() result was > maxLength for some reason, truncate that\n        seq = string;\n    }\n    return new StringBuilder(maxLength).append(seq, 0, truncationLength).append(truncationIndicator).toString();\n}", "repo_id": "5", "comment": "/**\n * Truncates the given character sequence to the given maximum length. If the length of the\n * sequence is greater than {@code maxLength}, the returned string will be exactly {@code\n * maxLength} chars in length and will end with the given {@code truncationIndicator}. Otherwise,\n * the sequence will be returned as a string with no changes to the content.\n *\n * <p>Examples:\n *\n * <pre>{@code\n * Ascii.truncate(\"foobar\", 7, \"...\"); // returns \"foobar\"\n * Ascii.truncate(\"foobar\", 5, \"...\"); // returns \"fo...\"\n * }</pre>\n *\n * <p><b>Note:</b> This method <i>may</i> work with certain non-ASCII text but is not safe for use\n * with arbitrary Unicode text. It is mostly intended for use with text that is known to be safe\n * for use with it (such as all-ASCII text) and for simple debugging text. When using this method,\n * consider the following:\n *\n * <ul>\n *   <li>it may split surrogate pairs\n *   <li>it may split characters and combining characters\n *   <li>it does not consider word boundaries\n *   <li>if truncating for display to users, there are other considerations that must be taken\n *       into account\n *   <li>the appropriate truncation indicator may be locale-dependent\n *   <li>it is safe to use non-ASCII characters in the truncation indicator\n * </ul>\n *\n * @throws IllegalArgumentException if {@code maxLength} is less than the length of {@code\n *     truncationIndicator}\n * @since 16.0\n */\n", "repo_name": "guava-master/", "id": 5180, "method_signature": "String truncate(CharSequence, int, String)", "filename": "Ascii.truncate.json"}
{"callee_method_names": ["DoubleBinaryOperator.applyAsDouble"], "method_name": "AtomicDouble.accumulateAndGet", "method_implementation": "{\n    checkNotNull(accumulatorFunction);\n    return updateAndGet(oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the current value with the results of applying the given function to the\n * current and given values.\n *\n * @param x the update value\n * @param accumulatorFunction the accumulator function\n * @return the updated value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2102, "method_signature": "double accumulateAndGet(double, DoubleBinaryOperator)", "filename": "AtomicDouble.accumulateAndGet.json"}
{"callee_method_names": ["AtomicLong.get", "AtomicLong.compareAndSet"], "method_name": "AtomicDouble.addAndGet", "method_implementation": "{\n    while (true) {\n        long current = value.get();\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (value.compareAndSet(current, next)) {\n            return nextVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically adds the given value to the current value.\n *\n * @param delta the value to add\n * @return the updated value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 5485, "method_signature": "double addAndGet(double)", "filename": "AtomicDouble.addAndGet.json"}
{"callee_method_names": ["DoubleBinaryOperator.applyAsDouble"], "method_name": "AtomicDouble.getAndAccumulate", "method_implementation": "{\n    checkNotNull(accumulatorFunction);\n    return getAndUpdate(oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the current value with the results of applying the given function to the\n * current and given values.\n *\n * @param x the update value\n * @param accumulatorFunction the accumulator function\n * @return the previous value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2101, "method_signature": "double getAndAccumulate(double, DoubleBinaryOperator)", "filename": "AtomicDouble.getAndAccumulate.json"}
{"callee_method_names": ["AtomicLong.get", "AtomicLong.compareAndSet"], "method_name": "AtomicDouble.getAndAdd", "method_implementation": "{\n    while (true) {\n        long current = value.get();\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (value.compareAndSet(current, next)) {\n            return currentVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically adds the given value to the current value.\n *\n * @param delta the value to add\n * @return the previous value\n */\n", "repo_name": "guava-master/", "id": 5484, "method_signature": "double getAndAdd(double)", "filename": "AtomicDouble.getAndAdd.json"}
{"callee_method_names": ["DoubleUnaryOperator.applyAsDouble", "AtomicLongFieldUpdater<AtomicDouble>.compareAndSet"], "method_name": "AtomicDouble.getAndUpdate", "method_implementation": "{\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = updateFunction.applyAsDouble(currentVal);\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the current value with the results of applying the given function.\n *\n * @param updateFunction the update function\n * @return the previous value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2103, "method_signature": "double getAndUpdate(DoubleUnaryOperator)", "filename": "AtomicDouble.getAndUpdate.json"}
{"callee_method_names": ["java.io.ObjectInputStream.defaultReadObject", "java.io.ObjectInputStream.readDouble"], "method_name": "AtomicDouble.readObject", "method_implementation": "{\n    s.defaultReadObject();\n    value = new AtomicLong();\n    set(s.readDouble());\n}", "repo_id": "5", "comment": "/**\n * Reconstitutes the instance from a stream (that is, deserializes it).\n */\n", "repo_name": "guava-master/", "id": 5487, "method_signature": "void readObject(java.io.ObjectInputStream)", "filename": "AtomicDouble.readObject.json"}
{"callee_method_names": ["DoubleUnaryOperator.applyAsDouble", "AtomicLongFieldUpdater<AtomicDouble>.compareAndSet"], "method_name": "AtomicDouble.updateAndGet", "method_implementation": "{\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = updateFunction.applyAsDouble(currentVal);\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the current value with the results of applying the given function.\n *\n * @param updateFunction the update function\n * @return the updated value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2104, "method_signature": "double updateAndGet(DoubleUnaryOperator)", "filename": "AtomicDouble.updateAndGet.json"}
{"callee_method_names": ["java.io.ObjectOutputStream.defaultWriteObject", "java.io.ObjectOutputStream.writeDouble"], "method_name": "AtomicDouble.writeObject", "method_implementation": "{\n    s.defaultWriteObject();\n    s.writeDouble(get());\n}", "repo_id": "5", "comment": "/**\n * Saves the state to a stream (that is, serializes it).\n *\n * @serialData The current value is emitted (a {@code double}).\n */\n", "repo_name": "guava-master/", "id": 5486, "method_signature": "void writeObject(java.io.ObjectOutputStream)", "filename": "AtomicDouble.writeObject.json"}
{"callee_method_names": ["DoubleBinaryOperator.applyAsDouble"], "method_name": "AtomicDoubleArray.accumulateAndGet", "method_implementation": "{\n    checkNotNull(accumulatorFunction);\n    return updateAndGet(i, oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the element at index {@code i} with the results of applying the given\n * function to the current and given values.\n *\n * @param i the index to update\n * @param x the update value\n * @param accumulatorFunction the accumulator function\n * @return the updated value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2074, "method_signature": "double accumulateAndGet(int, double, DoubleBinaryOperator)", "filename": "AtomicDoubleArray.accumulateAndGet.json"}
{"callee_method_names": ["AtomicLongArray.get", "AtomicLongArray.compareAndSet"], "method_name": "AtomicDoubleArray.addAndGet", "method_implementation": "{\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return nextVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically adds the given value to the element at index {@code i}.\n *\n * @param i the index\n * @param delta the value to add\n * @return the updated value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 5459, "method_signature": "double addAndGet(int, double)", "filename": "AtomicDoubleArray.addAndGet.json"}
{"callee_method_names": ["DoubleBinaryOperator.applyAsDouble"], "method_name": "AtomicDoubleArray.getAndAccumulate", "method_implementation": "{\n    checkNotNull(accumulatorFunction);\n    return getAndUpdate(i, oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the element at index {@code i} with the results of applying the given\n * function to the current and given values.\n *\n * @param i the index to update\n * @param x the update value\n * @param accumulatorFunction the accumulator function\n * @return the previous value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2073, "method_signature": "double getAndAccumulate(int, double, DoubleBinaryOperator)", "filename": "AtomicDoubleArray.getAndAccumulate.json"}
{"callee_method_names": ["AtomicLongArray.get", "AtomicLongArray.compareAndSet"], "method_name": "AtomicDoubleArray.getAndAdd", "method_implementation": "{\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return currentVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically adds the given value to the element at index {@code i}.\n *\n * @param i the index\n * @param delta the value to add\n * @return the previous value\n */\n", "repo_name": "guava-master/", "id": 5458, "method_signature": "double getAndAdd(int, double)", "filename": "AtomicDoubleArray.getAndAdd.json"}
{"callee_method_names": ["AtomicLongArray.get", "DoubleUnaryOperator.applyAsDouble", "AtomicLongArray.compareAndSet"], "method_name": "AtomicDoubleArray.getAndUpdate", "method_implementation": "{\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = updaterFunction.applyAsDouble(currentVal);\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return currentVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the element at index {@code i} with the results of applying the given\n * function to the current value.\n *\n * @param i the index to update\n * @param updaterFunction the update function\n * @return the previous value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2075, "method_signature": "double getAndUpdate(int, DoubleUnaryOperator)", "filename": "AtomicDoubleArray.getAndUpdate.json"}
{"callee_method_names": ["java.io.ObjectInputStream.defaultReadObject", "java.io.ObjectInputStream.readInt", "ImmutableLongArray.Builder.add", "java.io.ObjectInputStream.readDouble", "ImmutableLongArray.Builder.build"], "method_name": "AtomicDoubleArray.readObject", "method_implementation": "{\n    s.defaultReadObject();\n    int length = s.readInt();\n    ImmutableLongArray.Builder builder = ImmutableLongArray.builder();\n    for (int i = 0; i < length; i++) {\n        builder.add(doubleToRawLongBits(s.readDouble()));\n    }\n    this.longs = new AtomicLongArray(builder.build().toArray());\n}", "repo_id": "5", "comment": "/**\n * Reconstitutes the instance from a stream (that is, deserializes it).\n */\n", "repo_name": "guava-master/", "id": 5462, "method_signature": "void readObject(java.io.ObjectInputStream)", "filename": "AtomicDoubleArray.readObject.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "AtomicLongArray.get", "StringBuilder.append", "StringBuilder.append"], "method_name": "AtomicDoubleArray.toString", "method_implementation": "{\n    int iMax = length() - 1;\n    if (iMax == -1) {\n        return \"[]\";\n    }\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0; ; i++) {\n        b.append(longBitsToDouble(longs.get(i)));\n        if (i == iMax) {\n            return b.append(']').toString();\n        }\n        b.append(',').append(' ');\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the String representation of the current values of array.\n *\n * @return the String representation of the current values of array\n */\n", "repo_name": "guava-master/", "id": 5460, "method_signature": "String toString()", "filename": "AtomicDoubleArray.toString.json"}
{"callee_method_names": ["AtomicLongArray.get", "DoubleUnaryOperator.applyAsDouble", "AtomicLongArray.compareAndSet"], "method_name": "AtomicDoubleArray.updateAndGet", "method_implementation": "{\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = updaterFunction.applyAsDouble(currentVal);\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return nextVal;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically updates the element at index {@code i} with the results of applying the given\n * function to the current value.\n *\n * @param i the index to update\n * @param updaterFunction the update function\n * @return the updated value\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 2076, "method_signature": "double updateAndGet(int, DoubleUnaryOperator)", "filename": "AtomicDoubleArray.updateAndGet.json"}
{"callee_method_names": ["java.io.ObjectOutputStream.defaultWriteObject", "java.io.ObjectOutputStream.writeInt", "java.io.ObjectOutputStream.writeDouble"], "method_name": "AtomicDoubleArray.writeObject", "method_implementation": "{\n    s.defaultWriteObject();\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n        s.writeDouble(get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * Saves the state to a stream (that is, serializes it).\n *\n * @serialData The length of the array is emitted (int), followed by all of its elements (each a\n *     {@code double}) in the proper order.\n */\n", "repo_name": "guava-master/", "id": 5461, "method_signature": "void writeObject(java.io.ObjectOutputStream)", "filename": "AtomicDoubleArray.writeObject.json"}
{"callee_method_ids": [2074], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.accumulateAndGet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testAccumulateAndGetWithMax", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.accumulateAndGet(i, y, Double::max);\n                double expectedMax = max(x, y);\n                assertBitEquals(expectedMax, z);\n                assertBitEquals(expectedMax, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * accumulateAndGet with max stores max of given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 376, "method_signature": "void testAccumulateAndGetWithMax()", "filename": "AtomicDoubleArrayTest.testAccumulateAndGetWithMax.json"}
{"callee_method_ids": [2074], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.accumulateAndGet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testAccumulateAndGetWithSum", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.accumulateAndGet(i, y, Double::sum);\n                assertBitEquals(x + y, z);\n                assertBitEquals(x + y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * accumulateAndGet with sum adds given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 375, "method_signature": "void testAccumulateAndGetWithSum()", "filename": "AtomicDoubleArrayTest.testAccumulateAndGetWithSum.json"}
{"callee_method_ids": [5459], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.addAndGet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testAddAndGet", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.addAndGet(i, y);\n                assertBitEquals(x + y, z);\n                assertBitEquals(x + y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * addAndGet adds given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 3843, "method_signature": "void testAddAndGet()", "filename": "AtomicDoubleArrayTest.testAddAndGet.json"}
{"callee_method_names": ["AtomicDoubleArray.get", "AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.get", "AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testCompareAndSet", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        double prev = 0.0;\n        double unused = Math.E + Math.PI;\n        for (double x : VALUES) {\n            assertBitEquals(prev, aa.get(i));\n            assertFalse(aa.compareAndSet(i, unused, x));\n            assertBitEquals(prev, aa.get(i));\n            assertTrue(aa.compareAndSet(i, prev, x));\n            assertBitEquals(x, aa.get(i));\n            prev = x;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * compareAndSet succeeds in changing value if equal to expected else fails\n */\n", "repo_name": "guava-master/", "id": 3838, "method_signature": "void testCompareAndSet()", "filename": "AtomicDoubleArrayTest.testCompareAndSet.json"}
{"callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testCompareAndSetInMultipleThreads", "method_implementation": "{\n    final AtomicDoubleArray a = new AtomicDoubleArray(1);\n    a.set(0, 1.0);\n    Thread t = newStartedThread(new CheckedRunnable() {\n\n        public void realRun() {\n            while (!a.compareAndSet(0, 2.0, 3.0)) {\n                Thread.yield();\n            }\n        }\n    });\n    assertTrue(a.compareAndSet(0, 1.0, 2.0));\n    awaitTermination(t);\n    assertBitEquals(3.0, a.get(0));\n}", "repo_id": "5", "comment": "/**\n * compareAndSet in one thread enables another waiting for value to succeed\n */\n", "repo_name": "guava-master/", "id": 3839, "method_signature": "void testCompareAndSetInMultipleThreads()", "filename": "AtomicDoubleArrayTest.testCompareAndSetInMultipleThreads.json"}
{"callee_method_names": ["AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testConstructor", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        assertBitEquals(0.0, aa.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * constructor creates array of given size with all elements zero\n */\n", "repo_name": "guava-master/", "id": 3831, "method_signature": "void testConstructor()", "filename": "AtomicDoubleArrayTest.testConstructor.json"}
{"callee_method_names": ["AtomicDoubleArray.length", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testConstructor2", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(VALUES);\n    assertEquals(VALUES.length, aa.length());\n    for (int i = 0; i < VALUES.length; i++) {\n        assertBitEquals(VALUES[i], aa.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * constructor with array is of same size and has all elements\n */\n", "repo_name": "guava-master/", "id": 3832, "method_signature": "void testConstructor2()", "filename": "AtomicDoubleArrayTest.testConstructor2.json"}
{"callee_method_names": ["AtomicDoubleArray.length", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testConstructorEmptyArray", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(new double[0]);\n    assertEquals(0, aa.length());\n    assertThrows(IndexOutOfBoundsException.class, () -> aa.get(0));\n}", "repo_id": "5", "comment": "/**\n * constructor with empty array has size 0 and contains no elements\n */\n", "repo_name": "guava-master/", "id": 3833, "method_signature": "void testConstructorEmptyArray()", "filename": "AtomicDoubleArrayTest.testConstructorEmptyArray.json"}
{"callee_method_names": ["AtomicDoubleArray.length", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testConstructorZeroLength", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(0);\n    assertEquals(0, aa.length());\n    assertThrows(IndexOutOfBoundsException.class, () -> aa.get(0));\n}", "repo_id": "5", "comment": "/**\n * constructor with length zero has size 0 and contains no elements\n */\n", "repo_name": "guava-master/", "id": 3834, "method_signature": "void testConstructorZeroLength()", "filename": "AtomicDoubleArrayTest.testConstructorZeroLength.json"}
{"callee_method_names": ["AtomicDoubleArray.set"], "method_name": "AtomicDoubleArrayTest.testCountingInMultipleThreads", "method_implementation": "{\n    final AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        aa.set(i, (double) COUNTDOWN);\n    }\n    Counter c1 = new Counter(aa);\n    Counter c2 = new Counter(aa);\n    Thread t1 = newStartedThread(c1);\n    Thread t2 = newStartedThread(c2);\n    awaitTermination(t1);\n    awaitTermination(t2);\n    assertEquals(SIZE * COUNTDOWN, c1.counts + c2.counts);\n}", "repo_id": "5", "comment": "/**\n * Multiple threads using same array of counters successfully update a number of times equal to\n * total count\n */\n", "repo_name": "guava-master/", "id": 3844, "method_signature": "void testCountingInMultipleThreads()", "filename": "AtomicDoubleArrayTest.testCountingInMultipleThreads.json"}
{"callee_method_names": ["AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.weakCompareAndSet", "AtomicDoubleArray.get", "AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.get", "AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.weakCompareAndSet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testDistinctZeros", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        assertFalse(aa.compareAndSet(i, -0.0, 7.0));\n        assertFalse(aa.weakCompareAndSet(i, -0.0, 7.0));\n        assertBitEquals(+0.0, aa.get(i));\n        assertTrue(aa.compareAndSet(i, +0.0, -0.0));\n        assertBitEquals(-0.0, aa.get(i));\n        assertFalse(aa.compareAndSet(i, +0.0, 7.0));\n        assertFalse(aa.weakCompareAndSet(i, +0.0, 7.0));\n        assertBitEquals(-0.0, aa.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * compareAndSet treats +0.0 and -0.0 as distinct values\n */\n", "repo_name": "guava-master/", "id": 3847, "method_signature": "void testDistinctZeros()", "filename": "AtomicDoubleArrayTest.testDistinctZeros.json"}
{"callee_method_ids": [2073], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.getAndAccumulate", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testGetAndAccumulateWithMax", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.getAndAccumulate(i, y, Double::max);\n                double expectedMax = max(x, y);\n                assertBitEquals(x, z);\n                assertBitEquals(expectedMax, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndAccumulate with max stores max of given value to current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 374, "method_signature": "void testGetAndAccumulateWithMax()", "filename": "AtomicDoubleArrayTest.testGetAndAccumulateWithMax.json"}
{"callee_method_ids": [2073], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.getAndAccumulate", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testGetAndAccumulateWithSum", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.getAndAccumulate(i, y, Double::sum);\n                assertBitEquals(x, z);\n                assertBitEquals(x + y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndAccumulate with sum adds given value to current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 373, "method_signature": "void testGetAndAccumulateWithSum()", "filename": "AtomicDoubleArrayTest.testGetAndAccumulateWithSum.json"}
{"callee_method_ids": [5458], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.getAndAdd", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testGetAndAdd", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.getAndAdd(i, y);\n                assertBitEquals(x, z);\n                assertBitEquals(x + y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndAdd returns previous value and adds given value\n */\n", "repo_name": "guava-master/", "id": 3842, "method_signature": "void testGetAndAdd()", "filename": "AtomicDoubleArrayTest.testGetAndAdd.json"}
{"callee_method_names": ["AtomicDoubleArray.getAndSet"], "method_name": "AtomicDoubleArrayTest.testGetAndSet", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        double prev = 0.0;\n        for (double x : VALUES) {\n            assertBitEquals(prev, aa.getAndSet(i, x));\n            prev = x;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndSet returns previous value and sets to given value at given index\n */\n", "repo_name": "guava-master/", "id": 3841, "method_signature": "void testGetAndSet()", "filename": "AtomicDoubleArrayTest.testGetAndSet.json"}
{"callee_method_ids": [2075], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.getAndUpdate", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testGetAndUpdateWithSubtract", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.getAndUpdate(i, value -> value - y);\n                assertBitEquals(x, z);\n                assertBitEquals(x - y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndUpdate subtracts given value to current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 378, "method_signature": "void testGetAndUpdateWithSubtract()", "filename": "AtomicDoubleArrayTest.testGetAndUpdateWithSubtract.json"}
{"callee_method_ids": [2075], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.getAndUpdate", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testGetAndUpdateWithSum", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.getAndUpdate(i, value -> value + y);\n                assertBitEquals(x, z);\n                assertBitEquals(x + y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndUpdate adds given value to current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 377, "method_signature": "void testGetAndUpdateWithSum()", "filename": "AtomicDoubleArrayTest.testGetAndUpdateWithSum.json"}
{"callee_method_names": ["AtomicDoubleArray.get", "AtomicDoubleArray.lazySet", "AtomicDoubleArray.get", "AtomicDoubleArray.lazySet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testGetLazySet", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(VALUES.length);\n    for (int i = 0; i < VALUES.length; i++) {\n        assertBitEquals(0.0, aa.get(i));\n        aa.lazySet(i, VALUES[i]);\n        assertBitEquals(VALUES[i], aa.get(i));\n        aa.lazySet(i, -3.0);\n        assertBitEquals(-3.0, aa.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * get returns the last value lazySet at index by same thread\n */\n", "repo_name": "guava-master/", "id": 3837, "method_signature": "void testGetLazySet()", "filename": "AtomicDoubleArrayTest.testGetLazySet.json"}
{"callee_method_names": ["AtomicDoubleArray.get", "AtomicDoubleArray.set", "AtomicDoubleArray.get", "AtomicDoubleArray.set", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testGetSet", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(VALUES.length);\n    for (int i = 0; i < VALUES.length; i++) {\n        assertBitEquals(0.0, aa.get(i));\n        aa.set(i, VALUES[i]);\n        assertBitEquals(VALUES[i], aa.get(i));\n        aa.set(i, -3.0);\n        assertBitEquals(-3.0, aa.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * get returns the last value set at index\n */\n", "repo_name": "guava-master/", "id": 3836, "method_signature": "void testGetSet()", "filename": "AtomicDoubleArrayTest.testGetSet.json"}
{"callee_method_ids": [5458, 5459], "callee_method_names": ["AtomicDoubleArray.get", "AtomicDoubleArray.set", "AtomicDoubleArray.lazySet", "AtomicDoubleArray.compareAndSet", "AtomicDoubleArray.weakCompareAndSet", "AtomicDoubleArray.getAndAdd", "AtomicDoubleArray.addAndGet"], "method_name": "AtomicDoubleArrayTest.testIndexing", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int index : new int[] { -1, SIZE }) {\n        assertThrows(IndexOutOfBoundsException.class, () -> aa.get(index));\n        assertThrows(IndexOutOfBoundsException.class, () -> aa.set(index, 1.0));\n        assertThrows(IndexOutOfBoundsException.class, () -> aa.lazySet(index, 1.0));\n        assertThrows(IndexOutOfBoundsException.class, () -> aa.compareAndSet(index, 1.0, 2.0));\n        assertThrows(IndexOutOfBoundsException.class, () -> aa.weakCompareAndSet(index, 1.0, 2.0));\n        assertThrows(IndexOutOfBoundsException.class, () -> aa.getAndAdd(index, 1.0));\n        assertThrows(IndexOutOfBoundsException.class, () -> aa.addAndGet(index, 1.0));\n    }\n}", "repo_id": "5", "comment": "/**\n * get and set for out of bound indices throw IndexOutOfBoundsException\n */\n", "repo_name": "guava-master/", "id": 3835, "method_signature": "void testIndexing()", "filename": "AtomicDoubleArrayTest.testIndexing.json"}
{"callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.length", "AtomicDoubleArray.length", "AtomicDoubleArray.get", "AtomicDoubleArray.get", "AtomicDoubleArray.equals", "AtomicDoubleArray.equals", "AtomicDoubleArray.length", "AtomicDoubleArray.length", "AtomicDoubleArray.get", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testSerialization", "method_implementation": "{\n    AtomicDoubleArray x = new AtomicDoubleArray(SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        x.set(i, (double) -i);\n    }\n    AtomicDoubleArray y = serialClone(x);\n    assertTrue(x != y);\n    assertEquals(x.length(), y.length());\n    for (int i = 0; i < SIZE; i++) {\n        assertBitEquals(x.get(i), y.get(i));\n    }\n    AtomicDoubleArray a = new AtomicDoubleArray(VALUES);\n    AtomicDoubleArray b = serialClone(a);\n    assertFalse(a.equals(b));\n    assertFalse(b.equals(a));\n    assertEquals(a.length(), b.length());\n    for (int i = 0; i < VALUES.length; i++) {\n        assertBitEquals(a.get(i), b.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * a deserialized serialized array holds same values\n */\n", "repo_name": "guava-master/", "id": 3845, "method_signature": "void testSerialization()", "filename": "AtomicDoubleArrayTest.testSerialization.json"}
{"callee_method_ids": [5460], "callee_method_names": ["AtomicDoubleArray.toString"], "method_name": "AtomicDoubleArrayTest.testToString", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(VALUES);\n    assertEquals(Arrays.toString(VALUES), aa.toString());\n    assertEquals(\"[]\", new AtomicDoubleArray(0).toString());\n    assertEquals(\"[]\", new AtomicDoubleArray(new double[0]).toString());\n}", "repo_id": "5", "comment": "/**\n * toString returns current value\n */\n", "repo_name": "guava-master/", "id": 3846, "method_signature": "void testToString()", "filename": "AtomicDoubleArrayTest.testToString.json"}
{"callee_method_ids": [2076], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.updateAndGet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testUpdateAndGetWithSubtract", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.updateAndGet(i, value -> value - y);\n                assertBitEquals(x - y, z);\n                assertBitEquals(x - y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * updateAndGet subtracts given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 380, "method_signature": "void testUpdateAndGetWithSubtract()", "filename": "AtomicDoubleArrayTest.testUpdateAndGetWithSubtract.json"}
{"callee_method_ids": [2076], "callee_method_names": ["AtomicDoubleArray.set", "AtomicDoubleArray.updateAndGet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testUpdateAndGetWithSum", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        for (double x : VALUES) {\n            for (double y : VALUES) {\n                aa.set(i, x);\n                double z = aa.updateAndGet(i, value -> value + y);\n                assertBitEquals(x + y, z);\n                assertBitEquals(x + y, aa.get(i));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * updateAndGet adds given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 379, "method_signature": "void testUpdateAndGetWithSum()", "filename": "AtomicDoubleArrayTest.testUpdateAndGetWithSum.json"}
{"callee_method_names": ["AtomicDoubleArray.get", "AtomicDoubleArray.weakCompareAndSet", "AtomicDoubleArray.get", "AtomicDoubleArray.weakCompareAndSet", "AtomicDoubleArray.get"], "method_name": "AtomicDoubleArrayTest.testWeakCompareAndSet", "method_implementation": "{\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n    for (int i : new int[] { 0, SIZE - 1 }) {\n        double prev = 0.0;\n        double unused = Math.E + Math.PI;\n        for (double x : VALUES) {\n            assertBitEquals(prev, aa.get(i));\n            assertFalse(aa.weakCompareAndSet(i, unused, x));\n            assertBitEquals(prev, aa.get(i));\n            while (!aa.weakCompareAndSet(i, prev, x)) {\n                ;\n            }\n            assertBitEquals(x, aa.get(i));\n            prev = x;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * repeated weakCompareAndSet succeeds in changing value when equal to expected\n */\n", "repo_name": "guava-master/", "id": 3840, "method_signature": "void testWeakCompareAndSet()", "filename": "AtomicDoubleArrayTest.testWeakCompareAndSet.json"}
{"callee_method_ids": [2102], "callee_method_names": ["AtomicDouble.accumulateAndGet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testAccumulateAndGetWithMax", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.accumulateAndGet(y, Double::max);\n            double expectedMax = max(x, y);\n            assertBitEquals(expectedMax, z);\n            assertBitEquals(expectedMax, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * accumulateAndGet with max stores max of given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 397, "method_signature": "void testAccumulateAndGetWithMax()", "filename": "AtomicDoubleTest.testAccumulateAndGetWithMax.json"}
{"callee_method_ids": [2102], "callee_method_names": ["AtomicDouble.accumulateAndGet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testAccumulateAndGetWithSum", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.accumulateAndGet(y, Double::sum);\n            assertBitEquals(x + y, z);\n            assertBitEquals(x + y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * accumulateAndGet with sum adds given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 396, "method_signature": "void testAccumulateAndGetWithSum()", "filename": "AtomicDoubleTest.testAccumulateAndGetWithSum.json"}
{"callee_method_ids": [5485], "callee_method_names": ["AtomicDouble.addAndGet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testAddAndGet", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.addAndGet(y);\n            assertBitEquals(x + y, z);\n            assertBitEquals(x + y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * addAndGet adds given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 3856, "method_signature": "void testAddAndGet()", "filename": "AtomicDoubleTest.testAddAndGet.json"}
{"callee_method_names": ["AtomicDouble.get", "AtomicDouble.compareAndSet", "AtomicDouble.get", "AtomicDouble.compareAndSet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testCompareAndSet", "method_implementation": "{\n    double prev = Math.E;\n    double unused = Math.E + Math.PI;\n    AtomicDouble at = new AtomicDouble(prev);\n    for (double x : VALUES) {\n        assertBitEquals(prev, at.get());\n        assertFalse(at.compareAndSet(unused, x));\n        assertBitEquals(prev, at.get());\n        assertTrue(at.compareAndSet(prev, x));\n        assertBitEquals(x, at.get());\n        prev = x;\n    }\n}", "repo_id": "5", "comment": "/**\n * compareAndSet succeeds in changing value if equal to expected else fails\n */\n", "repo_name": "guava-master/", "id": 3851, "method_signature": "void testCompareAndSet()", "filename": "AtomicDoubleTest.testCompareAndSet.json"}
{"callee_method_names": ["AtomicDouble.compareAndSet", "AtomicDouble.compareAndSet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testCompareAndSetInMultipleThreads", "method_implementation": "{\n    final AtomicDouble at = new AtomicDouble(1.0);\n    Thread t = newStartedThread(new CheckedRunnable() {\n\n        public void realRun() {\n            while (!at.compareAndSet(2.0, 3.0)) {\n                Thread.yield();\n            }\n        }\n    });\n    assertTrue(at.compareAndSet(1.0, 2.0));\n    awaitTermination(t);\n    assertBitEquals(3.0, at.get());\n}", "repo_id": "5", "comment": "/**\n * compareAndSet in one thread enables another waiting for value to succeed\n */\n", "repo_name": "guava-master/", "id": 3852, "method_signature": "void testCompareAndSetInMultipleThreads()", "filename": "AtomicDoubleTest.testCompareAndSetInMultipleThreads.json"}
{"callee_method_names": ["AtomicDouble.get"], "method_name": "AtomicDoubleTest.testConstructor", "method_implementation": "{\n    for (double x : VALUES) {\n        AtomicDouble a = new AtomicDouble(x);\n        assertBitEquals(x, a.get());\n    }\n}", "repo_id": "5", "comment": "/**\n * constructor initializes to given value\n */\n", "repo_name": "guava-master/", "id": 3848, "method_signature": "void testConstructor()", "filename": "AtomicDoubleTest.testConstructor.json"}
{"callee_method_names": ["AtomicDouble.compareAndSet", "AtomicDouble.weakCompareAndSet", "AtomicDouble.get", "AtomicDouble.compareAndSet", "AtomicDouble.get", "AtomicDouble.compareAndSet", "AtomicDouble.weakCompareAndSet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testDistinctZeros", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble(+0.0);\n    assertFalse(at.compareAndSet(-0.0, 7.0));\n    assertFalse(at.weakCompareAndSet(-0.0, 7.0));\n    assertBitEquals(+0.0, at.get());\n    assertTrue(at.compareAndSet(+0.0, -0.0));\n    assertBitEquals(-0.0, at.get());\n    assertFalse(at.compareAndSet(+0.0, 7.0));\n    assertFalse(at.weakCompareAndSet(+0.0, 7.0));\n    assertBitEquals(-0.0, at.get());\n}", "repo_id": "5", "comment": "/**\n * compareAndSet treats +0.0 and -0.0 as distinct values\n */\n", "repo_name": "guava-master/", "id": 3863, "method_signature": "void testDistinctZeros()", "filename": "AtomicDoubleTest.testDistinctZeros.json"}
{"callee_method_names": ["AtomicDouble.doubleValue", "AtomicDouble.set", "AtomicDouble.doubleValue"], "method_name": "AtomicDoubleTest.testDoubleValue", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble();\n    assertEquals(0.0d, at.doubleValue());\n    for (double x : VALUES) {\n        at.set(x);\n        assertBitEquals(x, at.doubleValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * doubleValue returns current value.\n */\n", "repo_name": "guava-master/", "id": 3862, "method_signature": "void testDoubleValue()", "filename": "AtomicDoubleTest.testDoubleValue.json"}
{"callee_method_names": ["AtomicDouble.floatValue", "AtomicDouble.set", "AtomicDouble.floatValue"], "method_name": "AtomicDoubleTest.testFloatValue", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble();\n    assertEquals(0.0f, at.floatValue());\n    for (double x : VALUES) {\n        at.set(x);\n        assertEquals((float) x, at.floatValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * floatValue returns current value.\n */\n", "repo_name": "guava-master/", "id": 3861, "method_signature": "void testFloatValue()", "filename": "AtomicDoubleTest.testFloatValue.json"}
{"callee_method_ids": [2101], "callee_method_names": ["AtomicDouble.getAndAccumulate", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testGetAndAccumulateWithMax", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.getAndAccumulate(y, Double::max);\n            double expectedMax = max(x, y);\n            assertBitEquals(x, z);\n            assertBitEquals(expectedMax, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndAccumulate with max stores max of given value to current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 395, "method_signature": "void testGetAndAccumulateWithMax()", "filename": "AtomicDoubleTest.testGetAndAccumulateWithMax.json"}
{"callee_method_ids": [2101], "callee_method_names": ["AtomicDouble.getAndAccumulate", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testGetAndAccumulateWithSum", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.getAndAccumulate(y, Double::sum);\n            assertBitEquals(x, z);\n            assertBitEquals(x + y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndAccumulate with sum adds given value to current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 394, "method_signature": "void testGetAndAccumulateWithSum()", "filename": "AtomicDoubleTest.testGetAndAccumulateWithSum.json"}
{"callee_method_ids": [5484], "callee_method_names": ["AtomicDouble.getAndAdd", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testGetAndAdd", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.getAndAdd(y);\n            assertBitEquals(x, z);\n            assertBitEquals(x + y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndAdd returns previous value and adds given value\n */\n", "repo_name": "guava-master/", "id": 3855, "method_signature": "void testGetAndAdd()", "filename": "AtomicDoubleTest.testGetAndAdd.json"}
{"callee_method_names": ["AtomicDouble.getAndSet"], "method_name": "AtomicDoubleTest.testGetAndSet", "method_implementation": "{\n    double prev = Math.E;\n    AtomicDouble at = new AtomicDouble(prev);\n    for (double x : VALUES) {\n        assertBitEquals(prev, at.getAndSet(x));\n        prev = x;\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndSet returns previous value and sets to given value\n */\n", "repo_name": "guava-master/", "id": 3854, "method_signature": "void testGetAndSet()", "filename": "AtomicDoubleTest.testGetAndSet.json"}
{"callee_method_ids": [2103], "callee_method_names": ["AtomicDouble.getAndUpdate", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testGetAndUpdateWithSubtract", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.getAndUpdate(value -> value - y);\n            assertBitEquals(x, z);\n            assertBitEquals(x - y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndUpdate with subtract stores subtraction of value from current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 399, "method_signature": "void testGetAndUpdateWithSubtract()", "filename": "AtomicDoubleTest.testGetAndUpdateWithSubtract.json"}
{"callee_method_ids": [2103], "callee_method_names": ["AtomicDouble.getAndUpdate", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testGetAndUpdateWithSum", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.getAndUpdate(value -> value + y);\n            assertBitEquals(x, z);\n            assertBitEquals(x + y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * getAndUpdate with sum stores sum of given value to current, and returns previous value\n */\n", "repo_name": "guava-master/", "id": 398, "method_signature": "void testGetAndUpdateWithSum()", "filename": "AtomicDoubleTest.testGetAndUpdateWithSum.json"}
{"callee_method_names": ["AtomicDouble.get", "AtomicDouble.lazySet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testGetLazySet", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble(1.0);\n    assertBitEquals(1.0, at.get());\n    for (double x : VALUES) {\n        at.lazySet(x);\n        assertBitEquals(x, at.get());\n    }\n}", "repo_id": "5", "comment": "/**\n * get returns the last value lazySet in same thread\n */\n", "repo_name": "guava-master/", "id": 3850, "method_signature": "void testGetLazySet()", "filename": "AtomicDoubleTest.testGetLazySet.json"}
{"callee_method_names": ["AtomicDouble.get", "AtomicDouble.set", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testGetSet", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble(1.0);\n    assertBitEquals(1.0, at.get());\n    for (double x : VALUES) {\n        at.set(x);\n        assertBitEquals(x, at.get());\n    }\n}", "repo_id": "5", "comment": "/**\n * get returns the last value set\n */\n", "repo_name": "guava-master/", "id": 3849, "method_signature": "void testGetSet()", "filename": "AtomicDoubleTest.testGetSet.json"}
{"callee_method_names": ["AtomicDouble.intValue", "AtomicDouble.set", "AtomicDouble.intValue"], "method_name": "AtomicDoubleTest.testIntValue", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble();\n    assertEquals(0, at.intValue());\n    for (double x : VALUES) {\n        at.set(x);\n        assertEquals((int) x, at.intValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * intValue returns current value.\n */\n", "repo_name": "guava-master/", "id": 3859, "method_signature": "void testIntValue()", "filename": "AtomicDoubleTest.testIntValue.json"}
{"callee_method_names": ["AtomicDouble.longValue", "AtomicDouble.set", "AtomicDouble.longValue"], "method_name": "AtomicDoubleTest.testLongValue", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble();\n    assertEquals(0L, at.longValue());\n    for (double x : VALUES) {\n        at.set(x);\n        assertEquals((long) x, at.longValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * longValue returns current value.\n */\n", "repo_name": "guava-master/", "id": 3860, "method_signature": "void testLongValue()", "filename": "AtomicDoubleTest.testLongValue.json"}
{"callee_method_names": ["AtomicDouble.set", "AtomicDouble.get", "AtomicDouble.get", "AtomicDouble.get", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testSerialization", "method_implementation": "{\n    AtomicDouble a = new AtomicDouble();\n    AtomicDouble b = serialClone(a);\n    assertNotSame(a, b);\n    a.set(-22.0);\n    AtomicDouble c = serialClone(a);\n    assertNotSame(b, c);\n    assertBitEquals(-22.0, a.get());\n    assertBitEquals(0.0, b.get());\n    assertBitEquals(-22.0, c.get());\n    for (double x : VALUES) {\n        AtomicDouble d = new AtomicDouble(x);\n        assertBitEquals(serialClone(d).get(), d.get());\n    }\n}", "repo_id": "5", "comment": "/**\n * a deserialized serialized atomic holds same value\n */\n", "repo_name": "guava-master/", "id": 3857, "method_signature": "void testSerialization()", "filename": "AtomicDoubleTest.testSerialization.json"}
{"callee_method_names": ["AtomicDouble.toString", "AtomicDouble.set", "AtomicDouble.toString"], "method_name": "AtomicDoubleTest.testToString", "method_implementation": "{\n    AtomicDouble at = new AtomicDouble();\n    assertEquals(\"0.0\", at.toString());\n    for (double x : VALUES) {\n        at.set(x);\n        assertEquals(Double.toString(x), at.toString());\n    }\n}", "repo_id": "5", "comment": "/**\n * toString returns current value\n */\n", "repo_name": "guava-master/", "id": 3858, "method_signature": "void testToString()", "filename": "AtomicDoubleTest.testToString.json"}
{"callee_method_ids": [2104], "callee_method_names": ["AtomicDouble.updateAndGet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testUpdateAndGetWithSubtract", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.updateAndGet(value -> value - y);\n            assertBitEquals(x - y, z);\n            assertBitEquals(x - y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * updateAndGet with subtract stores subtraction of value from current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 401, "method_signature": "void testUpdateAndGetWithSubtract()", "filename": "AtomicDoubleTest.testUpdateAndGetWithSubtract.json"}
{"callee_method_ids": [2104], "callee_method_names": ["AtomicDouble.updateAndGet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testUpdateAndGetWithSum", "method_implementation": "{\n    for (double x : VALUES) {\n        for (double y : VALUES) {\n            AtomicDouble a = new AtomicDouble(x);\n            double z = a.updateAndGet(value -> value + y);\n            assertBitEquals(x + y, z);\n            assertBitEquals(x + y, a.get());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * updateAndGet with sum stores sum of given value to current, and returns current value\n */\n", "repo_name": "guava-master/", "id": 400, "method_signature": "void testUpdateAndGetWithSum()", "filename": "AtomicDoubleTest.testUpdateAndGetWithSum.json"}
{"callee_method_names": ["AtomicDouble.get", "AtomicDouble.weakCompareAndSet", "AtomicDouble.get", "AtomicDouble.weakCompareAndSet", "AtomicDouble.get"], "method_name": "AtomicDoubleTest.testWeakCompareAndSet", "method_implementation": "{\n    double prev = Math.E;\n    double unused = Math.E + Math.PI;\n    AtomicDouble at = new AtomicDouble(prev);\n    for (double x : VALUES) {\n        assertBitEquals(prev, at.get());\n        assertFalse(at.weakCompareAndSet(unused, x));\n        assertBitEquals(prev, at.get());\n        while (!at.weakCompareAndSet(prev, x)) {\n            ;\n        }\n        assertBitEquals(x, at.get());\n        prev = x;\n    }\n}", "repo_id": "5", "comment": "/**\n * repeated weakCompareAndSet succeeds in changing value when equal to expected\n */\n", "repo_name": "guava-master/", "id": 3853, "method_signature": "void testWeakCompareAndSet()", "filename": "AtomicDoubleTest.testWeakCompareAndSet.json"}
{"callee_method_names": ["LongBinaryOperator.applyAsLong"], "method_name": "AtomicLongMap.accumulateAndGet", "method_implementation": "{\n    checkNotNull(accumulatorFunction);\n    return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n}", "repo_id": "5", "comment": "/**\n * Updates the value currently associated with {@code key} by combining it with {@code x} via the\n * specified accumulator function, returning the new value. The previous value associated with\n * {@code key} (or zero, if there is none) is passed as the first argument to {@code\n * accumulatorFunction}, and {@code x} is passed as the second argument.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 1842, "method_signature": "long accumulateAndGet(K, long, LongBinaryOperator)", "filename": "AtomicLongMap.accumulateAndGet.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.get", "ConcurrentHashMap<K, AtomicLong>.putIfAbsent", "AtomicLong.get", "ConcurrentHashMap<K, AtomicLong>.replace", "AtomicLong.compareAndSet"], "method_name": "AtomicLongMap.addAndGet", "method_implementation": "{\n    outer: while (true) {\n        AtomicLong atomic = map.get(key);\n        if (atomic == null) {\n            atomic = map.putIfAbsent(key, new AtomicLong(delta));\n            if (atomic == null) {\n                return delta;\n            }\n            // atomic is now non-null; fall through\n        }\n        while (true) {\n            long oldValue = atomic.get();\n            if (oldValue == 0L) {\n                // don't compareAndSet a zero\n                if (map.replace(key, atomic, new AtomicLong(delta))) {\n                    return delta;\n                }\n                // atomic replaced\n                continue outer;\n            }\n            long newValue = oldValue + delta;\n            if (atomic.compareAndSet(oldValue, newValue)) {\n                return newValue;\n            }\n            // value changed\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds {@code delta} to the value currently associated with {@code key}, and returns the new\n * value.\n */\n", "repo_name": "guava-master/", "id": 5244, "method_signature": "long addAndGet(K, long)", "filename": "AtomicLongMap.addAndGet.json"}
{"callee_method_names": ["AtomicLongMap<K>.putAll"], "method_name": "AtomicLongMap.create", "method_implementation": "{\n    AtomicLongMap<K> result = create();\n    result.putAll(m);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code AtomicLongMap} with the same mappings as the specified {@code Map}.\n */\n", "repo_name": "guava-master/", "id": 5243, "method_signature": "AtomicLongMap<K> create(Map)", "filename": "AtomicLongMap.create.json"}
{"callee_method_names": ["LongBinaryOperator.applyAsLong"], "method_name": "AtomicLongMap.getAndAccumulate", "method_implementation": "{\n    checkNotNull(accumulatorFunction);\n    return getAndUpdate(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n}", "repo_id": "5", "comment": "/**\n * Updates the value currently associated with {@code key} by combining it with {@code x} via the\n * specified accumulator function, returning the old value. The previous value associated with\n * {@code key} (or zero, if there is none) is passed as the first argument to {@code\n * accumulatorFunction}, and {@code x} is passed as the second argument.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 1843, "method_signature": "long getAndAccumulate(K, long, LongBinaryOperator)", "filename": "AtomicLongMap.getAndAccumulate.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.get", "ConcurrentHashMap<K, AtomicLong>.putIfAbsent", "AtomicLong.get", "ConcurrentHashMap<K, AtomicLong>.replace", "AtomicLong.compareAndSet"], "method_name": "AtomicLongMap.getAndAdd", "method_implementation": "{\n    outer: while (true) {\n        AtomicLong atomic = map.get(key);\n        if (atomic == null) {\n            atomic = map.putIfAbsent(key, new AtomicLong(delta));\n            if (atomic == null) {\n                return 0L;\n            }\n            // atomic is now non-null; fall through\n        }\n        while (true) {\n            long oldValue = atomic.get();\n            if (oldValue == 0L) {\n                // don't compareAndSet a zero\n                if (map.replace(key, atomic, new AtomicLong(delta))) {\n                    return 0L;\n                }\n                // atomic replaced\n                continue outer;\n            }\n            long newValue = oldValue + delta;\n            if (atomic.compareAndSet(oldValue, newValue)) {\n                return oldValue;\n            }\n            // value changed\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds {@code delta} to the value currently associated with {@code key}, and returns the old\n * value.\n */\n", "repo_name": "guava-master/", "id": 5245, "method_signature": "long getAndAdd(K, long)", "filename": "AtomicLongMap.getAndAdd.json"}
{"callee_method_names": ["ConcurrentHashMap<K, Long>.compute", "long.longValue", "AtomicLong.set", "LongUnaryOperator.applyAsLong", "AtomicLong.get"], "method_name": "AtomicLongMap.getAndUpdate", "method_implementation": "{\n    checkNotNull(updaterFunction);\n    AtomicLong holder = new AtomicLong();\n    map.compute(key, (k, value) -> {\n        long oldValue = (value == null) ? 0L : value.longValue();\n        holder.set(oldValue);\n        return updaterFunction.applyAsLong(oldValue);\n    });\n    return holder.get();\n}", "repo_id": "5", "comment": "/**\n * Updates the value currently associated with {@code key} with the specified function, and\n * returns the old value. If there is not currently a value associated with {@code key}, the\n * function is applied to {@code 0L}.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 1841, "method_signature": "long getAndUpdate(K, LongUnaryOperator)", "filename": "AtomicLongMap.getAndUpdate.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.get", "ConcurrentHashMap<K, AtomicLong>.putIfAbsent", "AtomicLong.get", "ConcurrentHashMap<K, AtomicLong>.replace", "AtomicLong.compareAndSet"], "method_name": "AtomicLongMap.put", "method_implementation": "{\n    outer: while (true) {\n        AtomicLong atomic = map.get(key);\n        if (atomic == null) {\n            atomic = map.putIfAbsent(key, new AtomicLong(newValue));\n            if (atomic == null) {\n                return 0L;\n            }\n            // atomic is now non-null; fall through\n        }\n        while (true) {\n            long oldValue = atomic.get();\n            if (oldValue == 0L) {\n                // don't compareAndSet a zero\n                if (map.replace(key, atomic, new AtomicLong(newValue))) {\n                    return 0L;\n                }\n                // atomic replaced\n                continue outer;\n            }\n            if (atomic.compareAndSet(oldValue, newValue)) {\n                return oldValue;\n            }\n            // value changed\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Associates {@code newValue} with {@code key} in this map, and returns the value previously\n * associated with {@code key}, or zero if there was no such value.\n */\n", "repo_name": "guava-master/", "id": 5246, "method_signature": "long put(K, long)", "filename": "AtomicLongMap.put.json"}
{"callee_method_names": ["Map<? extends K,? extends Long>.entrySet", "Entry<?, ?>.getKey", "Entry<?, ?>.getValue"], "method_name": "AtomicLongMap.putAll", "method_implementation": "{\n    for (Entry<? extends K, ? extends Long> entry : m.entrySet()) {\n        put(entry.getKey(), entry.getValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * Copies all of the mappings from the specified map to this map. The effect of this call is\n * equivalent to that of calling {@code put(k, v)} on this map once for each mapping from key\n * {@code k} to value {@code v} in the specified map. The behavior of this operation is undefined\n * if the specified map is modified while the operation is in progress.\n */\n", "repo_name": "guava-master/", "id": 5247, "method_signature": "void putAll(Map)", "filename": "AtomicLongMap.putAll.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.get", "ConcurrentHashMap<K, AtomicLong>.putIfAbsent", "AtomicLong.get", "ConcurrentHashMap<K, AtomicLong>.replace"], "method_name": "AtomicLongMap.putIfAbsent", "method_implementation": "{\n    while (true) {\n        AtomicLong atomic = map.get(key);\n        if (atomic == null) {\n            atomic = map.putIfAbsent(key, new AtomicLong(newValue));\n            if (atomic == null) {\n                return 0L;\n            }\n            // atomic is now non-null; fall through\n        }\n        long oldValue = atomic.get();\n        if (oldValue == 0L) {\n            // don't compareAndSet a zero\n            if (map.replace(key, atomic, new AtomicLong(newValue))) {\n                return 0L;\n            }\n            // atomic replaced\n            continue;\n        }\n        return oldValue;\n    }\n}", "repo_id": "5", "comment": "/**\n * If {@code key} is not already associated with a value or if {@code key} is associated with\n * zero, associate it with {@code newValue}. Returns the previous value associated with {@code\n * key}, or zero if there was no mapping for {@code key}.\n */\n", "repo_name": "guava-master/", "id": 5252, "method_signature": "long putIfAbsent(K, long)", "filename": "AtomicLongMap.putIfAbsent.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.get", "AtomicLong.get", "AtomicLong.compareAndSet", "ConcurrentHashMap<K, AtomicLong>.remove"], "method_name": "AtomicLongMap.remove", "method_implementation": "{\n    AtomicLong atomic = map.get(key);\n    if (atomic == null) {\n        return false;\n    }\n    long oldValue = atomic.get();\n    if (oldValue != value) {\n        return false;\n    }\n    if (oldValue == 0L || atomic.compareAndSet(oldValue, 0L)) {\n        // only remove after setting to zero, to avoid concurrent updates\n        map.remove(key, atomic);\n        // succeed even if the remove fails, since the value was already adjusted\n        return true;\n    }\n    // value changed\n    return false;\n}", "repo_id": "5", "comment": "/**\n * If {@code (key, value)} is currently in the map, this method removes it and returns true;\n * otherwise, this method returns false.\n */\n", "repo_name": "guava-master/", "id": 5249, "method_signature": "boolean remove(K, long)", "filename": "AtomicLongMap.remove.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.entrySet", "Iterator<Entry<K, AtomicLong>>.hasNext", "Iterator<Entry<K, AtomicLong>>.next", "Entry<K, AtomicLong>.getValue", "AtomicLong.get", "Iterator<Entry<K, AtomicLong>>.remove"], "method_name": "AtomicLongMap.removeAllZeros", "method_implementation": "{\n    Iterator<Entry<K, AtomicLong>> entryIterator = map.entrySet().iterator();\n    while (entryIterator.hasNext()) {\n        Entry<K, AtomicLong> entry = entryIterator.next();\n        AtomicLong atomic = entry.getValue();\n        if (atomic != null && atomic.get() == 0L) {\n            entryIterator.remove();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes all mappings from this map whose values are zero.\n *\n * <p>This method is not atomic: the map may be visible in intermediate states, where some of the\n * zero values have been removed and others have not.\n */\n", "repo_name": "guava-master/", "id": 5250, "method_signature": "void removeAllZeros()", "filename": "AtomicLongMap.removeAllZeros.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.get", "AtomicLong.compareAndSet"], "method_name": "AtomicLongMap.replace", "method_implementation": "{\n    if (expectedOldValue == 0L) {\n        return putIfAbsent(key, newValue) == 0L;\n    } else {\n        AtomicLong atomic = map.get(key);\n        return (atomic == null) ? false : atomic.compareAndSet(expectedOldValue, newValue);\n    }\n}", "repo_id": "5", "comment": "/**\n * If {@code (key, expectedOldValue)} is currently in the map, this method replaces {@code\n * expectedOldValue} with {@code newValue} and returns true; otherwise, this method returns false.\n *\n * <p>If {@code expectedOldValue} is zero, this method will succeed if {@code (key, zero)} is\n * currently in the map, or if {@code key} is not in the map at all.\n */\n", "repo_name": "guava-master/", "id": 5253, "method_signature": "boolean replace(K, long, long)", "filename": "AtomicLongMap.replace.json"}
{"callee_method_names": ["ConcurrentHashMap<K, AtomicLong>.values", "long.get"], "method_name": "AtomicLongMap.sum", "method_implementation": "{\n    long sum = 0L;\n    for (AtomicLong value : map.values()) {\n        sum = sum + value.get();\n    }\n    return sum;\n}", "repo_id": "5", "comment": "/**\n * Returns the sum of all values in this map.\n *\n * <p>This method is not atomic: the sum may or may not include other concurrent operations.\n */\n", "repo_name": "guava-master/", "id": 5251, "method_signature": "long sum()", "filename": "AtomicLongMap.sum.json"}
{"callee_method_names": ["ConcurrentHashMap<K, Long>.compute", "LongUnaryOperator.applyAsLong", "long.longValue"], "method_name": "AtomicLongMap.updateAndGet", "method_implementation": "{\n    checkNotNull(updaterFunction);\n    Long result = map.compute(key, (k, value) -> updaterFunction.applyAsLong((value == null) ? 0L : value.longValue()));\n    return requireNonNull(result);\n}", "repo_id": "5", "comment": "/**\n * Updates the value currently associated with {@code key} with the specified function, and\n * returns the new value. If there is not currently a value associated with {@code key}, the\n * function is applied to {@code 0L}.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 1840, "method_signature": "long updateAndGet(K, LongUnaryOperator)", "filename": "AtomicLongMap.updateAndGet.json"}
{"callee_method_names": ["AvlNode<E>.removeMax"], "method_name": "AvlNode.removeMax", "method_implementation": "{\n    if (right == null) {\n        return left;\n    } else {\n        right = right.removeMax(node);\n        distinctElements--;\n        totalCount -= node.elemCount;\n        return rebalance();\n    }\n}", "repo_id": "5", "comment": "// Removes the maximum node from this subtree to be reused elsewhere\n", "repo_name": "guava-master/", "id": 6245, "method_signature": "AvlNode<E> removeMax(AvlNode)", "filename": "AvlNode.removeMax.json"}
{"callee_method_names": ["AvlNode<E>.removeMin"], "method_name": "AvlNode.removeMin", "method_implementation": "{\n    if (left == null) {\n        return right;\n    } else {\n        left = left.removeMin(node);\n        distinctElements--;\n        totalCount -= node.elemCount;\n        return rebalance();\n    }\n}", "repo_id": "5", "comment": "// Removes the minimum node from this subtree to be reused elsewhere\n", "repo_name": "guava-master/", "id": 6244, "method_signature": "AvlNode<E> removeMin(AvlNode)", "filename": "AvlNode.removeMin.json"}
{"callee_method_names": [], "method_name": "BaseEncoding.decode", "method_implementation": "{\n    try {\n        return decodeChecked(chars);\n    } catch (DecodingException badInput) {\n        throw new IllegalArgumentException(badInput);\n    }\n}", "repo_id": "5", "comment": "/**\n * Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the\n * inverse operation to {@link #encode(byte[])}.\n *\n * @throws IllegalArgumentException if the input is not a valid encoded string according to this\n *     encoding.\n */\n", "repo_name": "guava-master/", "id": 4803, "method_signature": "byte[] decode(CharSequence)", "filename": "BaseEncoding.decode.json"}
{"callee_method_names": ["CharSequence.length"], "method_name": "BaseEncoding.decodeChecked", "method_implementation": "{\n    chars = trimTrailingPadding(chars);\n    byte[] tmp = new byte[maxDecodedSize(chars.length())];\n    int len = decodeTo(tmp, chars);\n    return extract(tmp, len);\n}", "repo_id": "5", "comment": "/**\n * Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the\n * inverse operation to {@link #encode(byte[])}.\n *\n * @throws DecodingException if the input is not a valid encoded string according to this\n *     encoding.\n */\n", "repo_name": "guava-master/", "id": 4804, "method_signature": "byte[] decodeChecked(CharSequence)", "filename": "BaseEncoding.decodeChecked.json"}
{"callee_method_names": ["CharSource.openStream"], "method_name": "BaseEncoding.decodingSource", "method_implementation": "{\n    checkNotNull(encodedSource);\n    return new ByteSource() {\n\n        @Override\n        public InputStream openStream() throws IOException {\n            return decodingStream(encodedSource.openStream());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code ByteSource} that reads base-encoded bytes from the specified {@code\n * CharSource}.\n */\n", "repo_name": "guava-master/", "id": 4805, "method_signature": "ByteSource decodingSource(CharSource)", "filename": "BaseEncoding.decodingSource.json"}
{"callee_method_names": ["StringBuilder.toString"], "method_name": "BaseEncoding.encode", "method_implementation": "{\n    checkPositionIndexes(off, off + len, bytes.length);\n    StringBuilder result = new StringBuilder(maxEncodedSize(len));\n    try {\n        encodeTo(result, bytes, off, len);\n    } catch (IOException impossible) {\n        throw new AssertionError(impossible);\n    }\n    return result.toString();\n}", "repo_id": "5", "comment": "/**\n * Encodes the specified range of the specified byte array, and returns the encoded {@code\n * String}.\n */\n", "repo_name": "guava-master/", "id": 4801, "method_signature": "String encode(byte[], int, int)", "filename": "BaseEncoding.encode.json"}
{"callee_method_names": ["CharSink.openStream"], "method_name": "BaseEncoding.encodingSink", "method_implementation": "{\n    checkNotNull(encodedSink);\n    return new ByteSink() {\n\n        @Override\n        public OutputStream openStream() throws IOException {\n            return encodingStream(encodedSink.openStream());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code ByteSink} that writes base-encoded bytes to the specified {@code CharSink}.\n */\n", "repo_name": "guava-master/", "id": 4802, "method_signature": "ByteSink encodingSink(CharSink)", "filename": "BaseEncoding.encodingSink.json"}
{"callee_method_names": [], "method_name": "BaseEncoding.ignoreCase", "method_implementation": "{\n    if (ignoreCase) {\n        return this;\n    }\n    // We can't use .clone() because of GWT.\n    byte[] newDecodabet = Arrays.copyOf(decodabet, decodabet.length);\n    for (int upper = 'A'; upper <= 'Z'; upper++) {\n        int lower = upper | 0x20;\n        byte decodeUpper = decodabet[upper];\n        byte decodeLower = decodabet[lower];\n        if (decodeUpper == -1) {\n            newDecodabet[upper] = decodeLower;\n        } else {\n            checkState(decodeLower == -1, \"Can't ignoreCase() since '%s' and '%s' encode different values\", (char) upper, (char) lower);\n            newDecodabet[lower] = decodeUpper;\n        }\n    }\n    return new Alphabet(name + \".ignoreCase()\", chars, newDecodabet, /* ignoreCase= */\n    true);\n}", "repo_id": "5", "comment": "/**\n * Returns an equivalent {@code Alphabet} except it ignores case.\n */\n", "repo_name": "guava-master/", "id": 4806, "method_signature": "Alphabet ignoreCase()", "filename": "BaseEncoding.ignoreCase.json"}
{"callee_method_names": [], "method_name": "BaseEncodingTest.testBase16IgnoreCaseLowerCase", "method_implementation": "{\n    BaseEncoding ignoreCase = base16().ignoreCase().lowerCase();\n    assertThat(ignoreCase).isNotSameInstanceAs(base16());\n    testEncodingWithCasing(ignoreCase, \"foobar\", \"666f6f626172\");\n    testDecodes(ignoreCase, \"666F6F626172\", \"foobar\");\n    testDecodes(ignoreCase, \"666f6f626172\", \"foobar\");\n    testDecodes(ignoreCase, \"666F6f626172\", \"foobar\");\n}", "repo_id": "5", "comment": "// order the methods are called should not matter\n", "repo_name": "guava-master/", "id": 3633, "method_signature": "void testBase16IgnoreCaseLowerCase()", "filename": "BaseEncodingTest.testBase16IgnoreCaseLowerCase.json"}
{"callee_method_names": ["BigInteger.multiply", "BigInteger.multiply"], "method_name": "BigIntegerMath.binomial", "method_implementation": "{\n    checkNonNegative(\"n\", n);\n    checkNonNegative(\"k\", k);\n    checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n    if (k > (n >> 1)) {\n        k = n - k;\n    }\n    if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {\n        return BigInteger.valueOf(LongMath.binomial(n, k));\n    }\n    BigInteger accum = BigInteger.ONE;\n    long numeratorAccum = n;\n    long denominatorAccum = 1;\n    int bits = LongMath.log2(n, CEILING);\n    int numeratorBits = bits;\n    for (int i = 1; i < k; i++) {\n        int p = n - i;\n        int q = i + 1;\n        // log2(p) >= bits - 1, because p >= n/2\n        if (numeratorBits + bits >= Long.SIZE - 1) {\n            // The numerator is as big as it can get without risking overflow.\n            // Multiply numeratorAccum / denominatorAccum into accum.\n            accum = accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));\n            numeratorAccum = p;\n            denominatorAccum = q;\n            numeratorBits = bits;\n        } else {\n            // We can definitely multiply into the long accumulators without overflowing them.\n            numeratorAccum *= p;\n            denominatorAccum *= q;\n            numeratorBits += bits;\n        }\n    }\n    return accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));\n}", "repo_id": "5", "comment": "/**\n * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and\n * {@code k}, that is, {@code n! / (k! (n - k)!)}.\n *\n * <p><b>Warning:</b> the result can take as much as <i>O(k log n)</i> space.\n *\n * @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}\n */\n", "repo_name": "guava-master/", "id": 4587, "method_signature": "BigInteger binomial(int, int)", "filename": "BigIntegerMath.binomial.json"}
{"callee_method_names": ["BigDecimal.divide"], "method_name": "BigIntegerMath.divide", "method_implementation": "{\n    BigDecimal pDec = new BigDecimal(p);\n    BigDecimal qDec = new BigDecimal(q);\n    return pDec.divide(qDec, 0, mode).toBigIntegerExact();\n}", "repo_id": "5", "comment": "/**\n * Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code\n * RoundingMode}.\n *\n * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n *     is not an integer multiple of {@code b}\n */\n", "repo_name": "guava-master/", "id": 4585, "method_signature": "BigInteger divide(BigInteger, BigInteger, RoundingMode)", "filename": "BigIntegerMath.divide.json"}
{"callee_method_names": ["ArrayList<BigInteger>.add", "ArrayList<BigInteger>.add"], "method_name": "BigIntegerMath.factorial", "method_implementation": "{\n    checkNonNegative(\"n\", n);\n    // If the factorial is small enough, just use LongMath to do it.\n    if (n < LongMath.factorials.length) {\n        return BigInteger.valueOf(LongMath.factorials[n]);\n    }\n    // Pre-allocate space for our list of intermediate BigIntegers.\n    int approxSize = IntMath.divide(n * IntMath.log2(n, CEILING), Long.SIZE, CEILING);\n    ArrayList<BigInteger> bignums = new ArrayList<>(approxSize);\n    // Start from the pre-computed maximum long factorial.\n    int startingNumber = LongMath.factorials.length;\n    long product = LongMath.factorials[startingNumber - 1];\n    // Strip off 2s from this value.\n    int shift = Long.numberOfTrailingZeros(product);\n    product >>= shift;\n    // Use floor(log2(num)) + 1 to prevent overflow of multiplication.\n    int productBits = LongMath.log2(product, FLOOR) + 1;\n    int bits = LongMath.log2(startingNumber, FLOOR) + 1;\n    // Check for the next power of two boundary, to save us a CLZ operation.\n    int nextPowerOfTwo = 1 << (bits - 1);\n    // Iteratively multiply the longs as big as they can go.\n    for (long num = startingNumber; num <= n; num++) {\n        // Check to see if the floor(log2(num)) + 1 has changed.\n        if ((num & nextPowerOfTwo) != 0) {\n            nextPowerOfTwo <<= 1;\n            bits++;\n        }\n        // Get rid of the 2s in num.\n        int tz = Long.numberOfTrailingZeros(num);\n        long normalizedNum = num >> tz;\n        shift += tz;\n        // Adjust floor(log2(num)) + 1.\n        int normalizedBits = bits - tz;\n        // If it won't fit in a long, then we store off the intermediate product.\n        if (normalizedBits + productBits >= Long.SIZE) {\n            bignums.add(BigInteger.valueOf(product));\n            product = 1;\n            productBits = 0;\n        }\n        product *= normalizedNum;\n        productBits = LongMath.log2(product, FLOOR) + 1;\n    }\n    // Check for leftovers.\n    if (product > 1) {\n        bignums.add(BigInteger.valueOf(product));\n    }\n    // Efficiently multiply all the intermediate products together.\n    return listProduct(bignums).shiftLeft(shift);\n}", "repo_id": "5", "comment": "/**\n * Returns {@code n!}, that is, the product of the first {@code n} positive integers, or {@code 1}\n * if {@code n == 0}.\n *\n * <p><b>Warning:</b> the result takes <i>O(n log n)</i> space, so use cautiously.\n *\n * <p>This uses an efficient binary recursive algorithm to compute the factorial with balanced\n * multiplies. It also removes all the 2s from the intermediate products (shifting them back in at\n * the end).\n *\n * @throws IllegalArgumentException if {@code n < 0}\n */\n", "repo_name": "guava-master/", "id": 4586, "method_signature": "BigInteger factorial(int)", "filename": "BigIntegerMath.factorial.json"}
{"callee_method_names": ["BigInteger.bitLength"], "method_name": "BigIntegerMath.fitsInLong", "method_implementation": "{\n    return x.bitLength() <= Long.SIZE - 1;\n}", "repo_id": "5", "comment": "// Returns true if BigInteger.valueOf(x.longValue()).equals(x).\n", "repo_name": "guava-master/", "id": 4588, "method_signature": "boolean fitsInLong(BigInteger)", "filename": "BigIntegerMath.fitsInLong.json"}
{"callee_method_names": ["BigInteger.longValue", "BigInteger.compareTo", "BigInteger.divide", "BigInteger.compareTo", "BigInteger.compareTo", "BigInteger.compareTo", "BigInteger.equals", "BigInteger.pow", "BigInteger.pow", "BigInteger.compareTo"], "method_name": "BigIntegerMath.log10", "method_implementation": "{\n    checkPositive(\"x\", x);\n    if (fitsInLong(x)) {\n        return LongMath.log10(x.longValue(), mode);\n    }\n    int approxLog10 = (int) (log2(x, FLOOR) * LN_2 / LN_10);\n    BigInteger approxPow = BigInteger.TEN.pow(approxLog10);\n    int approxCmp = approxPow.compareTo(x);\n    /*\n     * We adjust approxLog10 and approxPow until they're equal to floor(log10(x)) and\n     * 10^floor(log10(x)).\n     */\n    if (approxCmp > 0) {\n        /*\n       * The code is written so that even completely incorrect approximations will still yield the\n       * correct answer eventually, but in practice this branch should almost never be entered, and\n       * even then the loop should not run more than once.\n       */\n        do {\n            approxLog10--;\n            approxPow = approxPow.divide(BigInteger.TEN);\n            approxCmp = approxPow.compareTo(x);\n        } while (approxCmp > 0);\n    } else {\n        BigInteger nextPow = BigInteger.TEN.multiply(approxPow);\n        int nextCmp = nextPow.compareTo(x);\n        while (nextCmp <= 0) {\n            approxLog10++;\n            approxPow = nextPow;\n            approxCmp = nextCmp;\n            nextPow = BigInteger.TEN.multiply(approxPow);\n            nextCmp = nextPow.compareTo(x);\n        }\n    }\n    int floorLog = approxLog10;\n    BigInteger floorPow = approxPow;\n    int floorCmp = approxCmp;\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(floorCmp == 0);\n        // fall through\n        case FLOOR:\n        case DOWN:\n            return floorLog;\n        case CEILING:\n        case UP:\n            return floorPow.equals(x) ? floorLog : floorLog + 1;\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            // Since sqrt(10) is irrational, log10(x) - floorLog can never be exactly 0.5\n            BigInteger x2 = x.pow(2);\n            BigInteger halfPowerSquared = floorPow.pow(2).multiply(BigInteger.TEN);\n            return (x2.compareTo(halfPowerSquared) <= 0) ? floorLog : floorLog + 1;\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not a power of ten\n */\n", "repo_name": "guava-master/", "id": 4582, "method_signature": "int log10(BigInteger, RoundingMode)", "filename": "BigIntegerMath.log10.json"}
{"callee_method_names": ["BigInteger.bitLength", "BigInteger.shiftRight", "BigInteger.compareTo", "BigInteger.pow", "BigInteger.bitLength"], "method_name": "BigIntegerMath.log2", "method_implementation": "{\n    checkPositive(\"x\", checkNotNull(x));\n    int logFloor = x.bitLength() - 1;\n    switch(mode) {\n        case UNNECESSARY:\n            // fall through\n            checkRoundingUnnecessary(isPowerOfTwo(x));\n        case DOWN:\n        case FLOOR:\n            return logFloor;\n        case UP:\n        case CEILING:\n            return isPowerOfTwo(x) ? logFloor : logFloor + 1;\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            if (logFloor < SQRT2_PRECOMPUTE_THRESHOLD) {\n                BigInteger halfPower = SQRT2_PRECOMPUTED_BITS.shiftRight(SQRT2_PRECOMPUTE_THRESHOLD - logFloor);\n                if (x.compareTo(halfPower) <= 0) {\n                    return logFloor;\n                } else {\n                    return logFloor + 1;\n                }\n            }\n            // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n            //\n            // To determine which side of logFloor.5 the logarithm is,\n            // we compare x^2 to 2^(2 * logFloor + 1).\n            BigInteger x2 = x.pow(2);\n            int logX2Floor = x2.bitLength() - 1;\n            return (logX2Floor < 2 * logFloor + 1) ? logFloor : logFloor + 1;\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not a power of two\n */\n", "repo_name": "guava-master/", "id": 4581, "method_signature": "int log2(BigInteger, RoundingMode)", "filename": "BigIntegerMath.log2.json"}
{"callee_method_names": [], "method_name": "BigIntegerMath.roundToDouble", "method_implementation": "{\n    return BigIntegerToDoubleRounder.INSTANCE.roundToDouble(x, mode);\n}", "repo_id": "5", "comment": "/**\n * Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}\n * is precisely representable as a {@code double}, its {@code double} value will be returned;\n * otherwise, the rounding will choose between the two nearest representable values with {@code\n * mode}.\n *\n * <p>For the case of {@link RoundingMode#HALF_DOWN}, {@code HALF_UP}, and {@code HALF_EVEN},\n * infinite {@code double} values are considered infinitely far away. For example, 2^2000 is not\n * representable as a double, but {@code roundToDouble(BigInteger.valueOf(2).pow(2000), HALF_UP)}\n * will return {@code Double.MAX_VALUE}, not {@code Double.POSITIVE_INFINITY}.\n *\n * <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754\n * default rounding mode: if the two nearest representable values are equally near, the one with\n * the least significant bit zero is chosen. (In such cases, both of the nearest representable\n * values are even integers; this method returns the one that is a multiple of a greater power of\n * two.)\n *\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not precisely representable as a {@code double}\n * @since 30.0\n */\n", "repo_name": "guava-master/", "id": 4584, "method_signature": "double roundToDouble(BigInteger, RoundingMode)", "filename": "BigIntegerMath.roundToDouble.json"}
{"callee_method_names": ["BigInteger.longValue", "BigInteger.pow", "BigInteger.intValue", "BigInteger.intValue", "BigInteger.pow", "BigInteger.add", "BigInteger.pow", "BigInteger.compareTo", "BigInteger.add"], "method_name": "BigIntegerMath.sqrt", "method_implementation": "{\n    checkNonNegative(\"x\", x);\n    if (fitsInLong(x)) {\n        return BigInteger.valueOf(LongMath.sqrt(x.longValue(), mode));\n    }\n    BigInteger sqrtFloor = sqrtFloor(x);\n    switch(mode) {\n        case UNNECESSARY:\n            // fall through\n            checkRoundingUnnecessary(sqrtFloor.pow(2).equals(x));\n        case FLOOR:\n        case DOWN:\n            return sqrtFloor;\n        case CEILING:\n        case UP:\n            int sqrtFloorInt = sqrtFloor.intValue();\n            boolean sqrtFloorIsExact = // fast check mod 2^32\n            (sqrtFloorInt * sqrtFloorInt == x.intValue()) && // slow exact check\n            sqrtFloor.pow(2).equals(x);\n            return sqrtFloorIsExact ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            BigInteger halfSquare = sqrtFloor.pow(2).add(sqrtFloor);\n            /*\n         * We wish to test whether or not x <= (sqrtFloor + 0.5)^2 = halfSquare + 0.25. Since both x\n         * and halfSquare are integers, this is equivalent to testing whether or not x <=\n         * halfSquare.\n         */\n            return (halfSquare.compareTo(x) >= 0) ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the square root of {@code x}, rounded with the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x < 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code\n *     sqrt(x)} is not an integer\n */\n", "repo_name": "guava-master/", "id": 4583, "method_signature": "BigInteger sqrt(BigInteger, RoundingMode)", "filename": "BigIntegerMath.sqrt.json"}
{"callee_method_names": [], "method_name": "BigIntegerMathBenchmark.oldSlowFactorial", "method_implementation": "{\n    assert n1 <= n2;\n    if (IntMath.log2(n2, CEILING) * (n2 - n1) < Long.SIZE - 1) {\n        // the result will definitely fit into a long\n        long result = 1;\n        for (int i = n1 + 1; i <= n2; i++) {\n            result *= i;\n        }\n        return BigInteger.valueOf(result);\n    }\n    /*\n     * We want each multiplication to have both sides with approximately the same number of digits.\n     * Currently, we just divide the range in half.\n     */\n    int mid = (n1 + n2) >>> 1;\n    return oldSlowFactorial(n1, mid).multiply(oldSlowFactorial(mid, n2));\n}", "repo_id": "5", "comment": "/**\n * Returns the product of {@code n1} exclusive through {@code n2} inclusive.\n */\n", "repo_name": "guava-master/", "id": 3477, "method_signature": "BigInteger oldSlowFactorial(int, int)", "filename": "BigIntegerMathBenchmark.oldSlowFactorial.json"}
{"callee_method_names": [], "method_name": "BigIntegerMathTest.runBinomialTest", "method_implementation": "{\n    for (int n = firstN; n <= lastN; n++) {\n        for (int k = 0; k <= n; k++) {\n            BigInteger expected = BigIntegerMath.factorial(n).divide(BigIntegerMath.factorial(k)).divide(BigIntegerMath.factorial(n - k));\n            assertEquals(expected, BigIntegerMath.binomial(n, k));\n        }\n    }\n}", "repo_id": "5", "comment": "// Depends on the correctness of BigIntegerMath.factorial\n", "repo_name": "guava-master/", "id": 3607, "method_signature": "void runBinomialTest(int, int)", "filename": "BigIntegerMathTest.runBinomialTest.json"}
{"callee_method_names": [], "method_name": "BigIntegerMathTest.testLog10Exact", "method_implementation": "{\n    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n        int logFloor = BigIntegerMath.log10(x, FLOOR);\n        boolean expectSuccess = TEN.pow(logFloor).equals(x);\n        try {\n            assertEquals(logFloor, BigIntegerMath.log10(x, UNNECESSARY));\n            assertTrue(expectSuccess);\n        } catch (ArithmeticException e) {\n            assertFalse(expectSuccess);\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of log10(BigInteger, FLOOR).\n", "repo_name": "guava-master/", "id": 3603, "method_signature": "void testLog10Exact()", "filename": "BigIntegerMathTest.testLog10Exact.json"}
{"callee_method_names": [], "method_name": "BigIntegerMathTest.testLog10HalfEven", "method_implementation": "{\n    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n        int halfEven = BigIntegerMath.log10(x, HALF_EVEN);\n        // Now figure out what rounding mode we should behave like (it depends if FLOOR was\n        // odd/even).\n        boolean floorWasEven = (BigIntegerMath.log10(x, FLOOR) & 1) == 0;\n        assertEquals(BigIntegerMath.log10(x, floorWasEven ? HALF_DOWN : HALF_UP), halfEven);\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of log10(BigInteger, {HALF_UP,HALF_DOWN}).\n", "repo_name": "guava-master/", "id": 3604, "method_signature": "void testLog10HalfEven()", "filename": "BigIntegerMathTest.testLog10HalfEven.json"}
{"callee_method_names": ["UnsignedInteger.setBit"], "method_name": "BigIntegerMathTest.testLog2Exact", "method_implementation": "{\n    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n        // We only expect an exception if x was not a power of 2.\n        boolean isPowerOf2 = BigIntegerMath.isPowerOfTwo(x);\n        try {\n            assertEquals(x, ZERO.setBit(BigIntegerMath.log2(x, UNNECESSARY)));\n            assertTrue(isPowerOf2);\n        } catch (ArithmeticException e) {\n            assertFalse(isPowerOf2);\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of isPowerOfTwo(BigInteger).\n", "repo_name": "guava-master/", "id": 3601, "method_signature": "void testLog2Exact()", "filename": "BigIntegerMathTest.testLog2Exact.json"}
{"callee_method_names": [], "method_name": "BigIntegerMathTest.testLog2HalfEven", "method_implementation": "{\n    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n        int halfEven = BigIntegerMath.log2(x, HALF_EVEN);\n        // Now figure out what rounding mode we should behave like (it depends if FLOOR was\n        // odd/even).\n        boolean floorWasEven = (BigIntegerMath.log2(x, FLOOR) & 1) == 0;\n        assertEquals(BigIntegerMath.log2(x, floorWasEven ? HALF_DOWN : HALF_UP), halfEven);\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of log2(BigInteger, {HALF_UP,HALF_DOWN}).\n", "repo_name": "guava-master/", "id": 3602, "method_signature": "void testLog2HalfEven()", "filename": "BigIntegerMathTest.testLog2HalfEven.json"}
{"callee_method_names": ["BigInteger.pow"], "method_name": "BigIntegerMathTest.testSqrtExact", "method_implementation": "{\n    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n        BigInteger floor = BigIntegerMath.sqrt(x, FLOOR);\n        // We only expect an exception if x was not a perfect square.\n        boolean isPerfectSquare = floor.pow(2).equals(x);\n        try {\n            assertEquals(floor, BigIntegerMath.sqrt(x, UNNECESSARY));\n            assertTrue(isPerfectSquare);\n        } catch (ArithmeticException e) {\n            assertFalse(isPerfectSquare);\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of sqrt(BigInteger, FLOOR).\n", "repo_name": "guava-master/", "id": 3605, "method_signature": "void testSqrtExact()", "filename": "BigIntegerMathTest.testSqrtExact.json"}
{"callee_method_names": [], "method_name": "BigIntegerMathTest.testSqrtHalfEven", "method_implementation": "{\n    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n        BigInteger halfEven = BigIntegerMath.sqrt(x, HALF_EVEN);\n        // Now figure out what rounding mode we should behave like (it depends if FLOOR was\n        // odd/even).\n        boolean floorWasOdd = BigIntegerMath.sqrt(x, FLOOR).testBit(0);\n        assertEquals(BigIntegerMath.sqrt(x, floorWasOdd ? HALF_UP : HALF_DOWN), halfEven);\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of sqrt(BigInteger, {HALF_UP,HALF_DOWN}).\n", "repo_name": "guava-master/", "id": 3606, "method_signature": "void testSqrtHalfEven()", "filename": "BigIntegerMathTest.testSqrtHalfEven.json"}
{"callee_method_names": ["List<Integer>.isEmpty", "List<Integer>.size", "List<Integer>.get", "List<Integer>.get", "List<Integer>.subList", "List<Integer>.subList", "List<Integer>.size", "List<Integer>.get"], "method_name": "BinaryTreeTraverserBenchmark.createTreap", "method_implementation": "{\n    if (keys.isEmpty()) {\n        return Optional.absent();\n    }\n    int minIndex = 0;\n    for (int i = 1; i < keys.size(); i++) {\n        if (keys.get(i) < keys.get(minIndex)) {\n            minIndex = i;\n        }\n    }\n    Optional<BinaryNode> leftChild = createTreap(keys.subList(0, minIndex));\n    Optional<BinaryNode> rightChild = createTreap(keys.subList(minIndex + 1, keys.size()));\n    return Optional.of(new BinaryNode(keys.get(minIndex), leftChild, rightChild));\n}", "repo_id": "5", "comment": "// See http://en.wikipedia.org/wiki/Treap for details on the algorithm.\n", "repo_name": "guava-master/", "id": 3543, "method_signature": "Optional<BinaryNode> createTreap(List)", "filename": "BinaryTreeTraverserBenchmark.createTreap.json"}
{"callee_method_names": ["Random.nextInt"], "method_name": "BinaryTreeTraverserBenchmark.createTree", "method_implementation": "{\n    int[] keys = new int[size];\n    for (int i = 0; i < size; i++) {\n        keys[i] = rng.nextInt();\n    }\n    return createTreap(Ints.asList(keys));\n}", "repo_id": "5", "comment": "/**\n * Generates a tree with topology selected uniformly at random from the topologies of binary\n * trees of the specified size.\n */\n", "repo_name": "guava-master/", "id": 3542, "method_signature": "Optional<BinaryNode> createTree(int, Random)", "filename": "BinaryTreeTraverserBenchmark.createTree.json"}
{"callee_method_names": [], "method_name": "BloomFilter.apply", "method_implementation": "{\n    return mightContain(input);\n}", "repo_id": "5", "comment": "/**\n * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #mightContain}\n *     instead.\n */\n", "repo_name": "guava-master/", "id": 5227, "method_signature": "boolean apply(T)", "filename": "BloomFilter.apply.json"}
{"callee_method_names": ["LockFreeBitArray.bitSize", "LockFreeBitArray.bitCount"], "method_name": "BloomFilter.approximateElementCount", "method_implementation": "{\n    long bitSize = bits.bitSize();\n    long bitCount = bits.bitCount();\n    /**\n     * Each insertion is expected to reduce the # of clear bits by a factor of\n     * `numHashFunctions/bitSize`. So, after n insertions, expected bitCount is `bitSize * (1 - (1 -\n     * numHashFunctions/bitSize)^n)`. Solving that for n, and approximating `ln x` as `x - 1` when x\n     * is close to 1 (why?), gives the following formula.\n     */\n    double fractionOfBitsSet = (double) bitCount / bitSize;\n    return DoubleMath.roundToLong(-Math.log1p(-fractionOfBitsSet) * bitSize / numHashFunctions, RoundingMode.HALF_UP);\n}", "repo_id": "5", "comment": "/**\n * Returns an estimate for the total number of distinct elements that have been added to this\n * Bloom filter. This approximation is reasonably accurate if it does not exceed the value of\n * {@code expectedInsertions} that was used when constructing the filter.\n *\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 5228, "method_signature": "long approximateElementCount()", "filename": "BloomFilter.approximateElementCount.json"}
{"callee_method_names": ["BloomFilter<T>.bitSize"], "method_name": "BloomFilter.isCompatible", "method_implementation": "{\n    checkNotNull(that);\n    return this != that && this.numHashFunctions == that.numHashFunctions && this.bitSize() == that.bitSize() && this.strategy.equals(that.strategy) && this.funnel.equals(that.funnel);\n}", "repo_id": "5", "comment": "/**\n * Determines whether a given Bloom filter is compatible with this Bloom filter. For two Bloom\n * filters to be compatible, they must:\n *\n * <ul>\n *   <li>not be the same instance\n *   <li>have the same number of hash functions\n *   <li>have the same bit size\n *   <li>have the same strategy\n *   <li>have equal funnels\n * </ul>\n *\n * @param that The Bloom filter to check for compatibility.\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5229, "method_signature": "boolean isCompatible(BloomFilter)", "filename": "BloomFilter.isCompatible.json"}
{"callee_method_names": [], "method_name": "BloomFilter.optimalNumOfBits", "method_implementation": "{\n    if (p == 0) {\n        p = Double.MIN_VALUE;\n    }\n    return (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));\n}", "repo_id": "5", "comment": "/**\n * Computes m (total bits of Bloom filter) which is expected to achieve, for the specified\n * expected insertions, the required false positive probability.\n *\n * <p>See http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives for the\n * formula.\n *\n * @param n expected insertions (must be positive)\n * @param p false positive rate (must be 0 < p < 1)\n */\n", "repo_name": "guava-master/", "id": 5232, "method_signature": "long optimalNumOfBits(long, double)", "filename": "BloomFilter.optimalNumOfBits.json"}
{"callee_method_names": [], "method_name": "BloomFilter.optimalNumOfHashFunctions", "method_implementation": "{\n    // (m / n) * log(2), but avoid truncation due to division!\n    return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));\n}", "repo_id": "5", "comment": "/**\n * Computes the optimal k (number of hashes per element inserted in Bloom filter), given the\n * expected insertions and total number of bits in the Bloom filter.\n *\n * <p>See http://en.wikipedia.org/wiki/File:Bloom_filter_fp_probability.svg for the formula.\n *\n * @param n expected insertions (must be positive)\n * @param m total number of bits in Bloom filter (must be positive)\n */\n", "repo_name": "guava-master/", "id": 5231, "method_signature": "int optimalNumOfHashFunctions(long, long)", "filename": "BloomFilter.optimalNumOfHashFunctions.json"}
{"callee_method_names": ["BloomFilter<T>.bitSize", "BloomFilter<T>.bitSize"], "method_name": "BloomFilter.putAll", "method_implementation": "{\n    checkNotNull(that);\n    checkArgument(this != that, \"Cannot combine a BloomFilter with itself.\");\n    checkArgument(this.numHashFunctions == that.numHashFunctions, \"BloomFilters must have the same number of hash functions (%s != %s)\", this.numHashFunctions, that.numHashFunctions);\n    checkArgument(this.bitSize() == that.bitSize(), \"BloomFilters must have the same size underlying bit arrays (%s != %s)\", this.bitSize(), that.bitSize());\n    checkArgument(this.strategy.equals(that.strategy), \"BloomFilters must have equal strategies (%s != %s)\", this.strategy, that.strategy);\n    checkArgument(this.funnel.equals(that.funnel), \"BloomFilters must have equal funnels (%s != %s)\", this.funnel, that.funnel);\n    this.bits.putAll(that.bits);\n}", "repo_id": "5", "comment": "/**\n * Combines this Bloom filter with another Bloom filter by performing a bitwise OR of the\n * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the Bloom\n * filters are appropriately sized to avoid saturating them.\n *\n * @param that The Bloom filter to combine this Bloom filter with. It is not mutated.\n * @throws IllegalArgumentException if {@code isCompatible(that) == false}\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5230, "method_signature": "void putAll(BloomFilter)", "filename": "BloomFilter.putAll.json"}
{"callee_method_ids": [5208], "callee_method_names": ["DataInputStream.readByte", "DataInputStream.readByte", "DataInputStream.readInt", "LockFreeBitArray.putData", "DataInputStream.readLong"], "method_name": "BloomFilter.readFrom", "method_implementation": "{\n    checkNotNull(in, \"InputStream\");\n    checkNotNull(funnel, \"Funnel\");\n    int strategyOrdinal = -1;\n    int numHashFunctions = -1;\n    int dataLength = -1;\n    try {\n        DataInputStream din = new DataInputStream(in);\n        // currently this assumes there is no negative ordinal; will have to be updated if we\n        // add non-stateless strategies (for which we've reserved negative ordinals; see\n        // Strategy.ordinal()).\n        strategyOrdinal = din.readByte();\n        numHashFunctions = UnsignedBytes.toInt(din.readByte());\n        dataLength = din.readInt();\n        Strategy strategy = BloomFilterStrategies.values()[strategyOrdinal];\n        LockFreeBitArray dataArray = new LockFreeBitArray(LongMath.checkedMultiply(dataLength, 64L));\n        for (int i = 0; i < dataLength; i++) {\n            dataArray.putData(i, din.readLong());\n        }\n        return new BloomFilter<T>(dataArray, numHashFunctions, funnel, strategy);\n    } catch (IOException e) {\n        throw e;\n    } catch (Exception e) {\n        // sneaky checked exception\n        String message = \"Unable to deserialize BloomFilter from InputStream.\" + \" strategyOrdinal: \" + strategyOrdinal + \" numHashFunctions: \" + numHashFunctions + \" dataLength: \" + dataLength;\n        throw new IOException(message, e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Reads a byte stream, which was written by {@linkplain #writeTo(OutputStream)}, into a {@code\n * BloomFilter}.\n *\n * <p>The {@code Funnel} to be used is not encoded in the stream, so it must be provided here.\n * <b>Warning:</b> the funnel provided <b>must</b> behave identically to the one used to populate\n * the original Bloom filter!\n *\n * @throws IOException if the InputStream throws an {@code IOException}, or if its data does not\n *     appear to be a BloomFilter serialized using the {@linkplain #writeTo(OutputStream)} method.\n */\n", "repo_name": "guava-master/", "id": 5234, "method_signature": "BloomFilter<T> readFrom(InputStream, Funnel)", "filename": "BloomFilter.readFrom.json"}
{"callee_method_names": [], "method_name": "BloomFilter.toBloomFilter", "method_implementation": "{\n    checkNotNull(funnel);\n    checkArgument(expectedInsertions >= 0, \"Expected insertions (%s) must be >= 0\", expectedInsertions);\n    checkArgument(fpp > 0.0, \"False positive probability (%s) must be > 0.0\", fpp);\n    checkArgument(fpp < 1.0, \"False positive probability (%s) must be < 1.0\", fpp);\n    return Collector.of(() -> BloomFilter.create(funnel, expectedInsertions, fpp), BloomFilter::put, (bf1, bf2) -> {\n        bf1.putAll(bf2);\n        return bf1;\n    }, Collector.Characteristics.UNORDERED, Collector.Characteristics.CONCURRENT);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} expecting the specified number of insertions, and yielding a {@link\n * BloomFilter} with the specified expected false positive probability.\n *\n * <p>Note that if the {@code Collector} receives significantly more elements than specified, the\n * resulting {@code BloomFilter} will suffer a sharp deterioration of its false positive\n * probability.\n *\n * <p>The constructed {@code BloomFilter} will be serializable if the provided {@code Funnel<T>}\n * is.\n *\n * <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of\n * ensuring proper serialization and deserialization, which is important since {@link #equals}\n * also relies on object identity of funnels.\n *\n * @param funnel the funnel of T's that the constructed {@code BloomFilter} will use\n * @param expectedInsertions the number of expected insertions to the constructed {@code\n *     BloomFilter}; must be positive\n * @param fpp the desired false positive probability (must be positive and less than 1.0)\n * @return a {@code Collector} generating a {@code BloomFilter} of the received elements\n * @since 23.0\n */\n", "repo_name": "guava-master/", "id": 1826, "method_signature": "Collector<T,?,BloomFilter<T>> toBloomFilter(Funnel, long, double)", "filename": "BloomFilter.toBloomFilter.json"}
{"callee_method_names": ["DataOutputStream.writeByte", "Strategy.ordinal", "DataOutputStream.writeByte", "DataOutputStream.writeInt", "LockFreeBitArray.length", "LockFreeBitArray.length", "DataOutputStream.writeLong", "LockFreeBitArray.get"], "method_name": "BloomFilter.writeTo", "method_implementation": "{\n    // Serial form:\n    // 1 signed byte for the strategy\n    // 1 unsigned byte for the number of hash functions\n    // 1 big endian int, the number of longs in our bitset\n    // N big endian longs of our bitset\n    DataOutputStream dout = new DataOutputStream(out);\n    dout.writeByte(SignedBytes.checkedCast(strategy.ordinal()));\n    // note: checked at the c'tor\n    dout.writeByte(UnsignedBytes.checkedCast(numHashFunctions));\n    dout.writeInt(bits.data.length());\n    for (int i = 0; i < bits.data.length(); i++) {\n        dout.writeLong(bits.data.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * Writes this {@code BloomFilter} to an output stream, with a custom format (not Java\n * serialization). This has been measured to save at least 400 bytes compared to regular\n * serialization.\n *\n * <p>Use {@linkplain #readFrom(InputStream, Funnel)} to reconstruct the written BloomFilter.\n */\n", "repo_name": "guava-master/", "id": 5233, "method_signature": "void writeTo(OutputStream)", "filename": "BloomFilter.writeTo.json"}
{"callee_method_names": [], "method_name": "BloomFilterTest.testBasic", "method_implementation": "{\n    for (double fpr = 0.0000001; fpr < 0.1; fpr *= 10) {\n        for (int expectedInsertions = 1; expectedInsertions <= 10000; expectedInsertions *= 10) {\n            checkSanity(BloomFilter.create(HashTestUtils.BAD_FUNNEL, expectedInsertions, fpr));\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Sanity checking with many combinations of false positive rates and expected insertions\n */\n", "repo_name": "guava-master/", "id": 3727, "method_signature": "void testBasic()", "filename": "BloomFilterTest.testBasic.json"}
{"callee_method_names": [], "method_name": "BloomFilterTest.testBloomFilterStrategies", "method_implementation": "{\n    assertThat(BloomFilterStrategies.values()).hasLength(2);\n    assertEquals(BloomFilterStrategies.MURMUR128_MITZ_32, BloomFilterStrategies.values()[0]);\n    assertEquals(BloomFilterStrategies.MURMUR128_MITZ_64, BloomFilterStrategies.values()[1]);\n}", "repo_id": "5", "comment": "/**\n * This test will fail whenever someone updates/reorders the BloomFilterStrategies constants. Only\n * appending a new constant is allowed.\n */\n", "repo_name": "guava-master/", "id": 3730, "method_signature": "void testBloomFilterStrategies()", "filename": "BloomFilterTest.testBloomFilterStrategies.json"}
{"callee_method_names": [], "method_name": "BloomFilterTest.testOptimalHashes", "method_implementation": "{\n    for (int n = 1; n < 1000; n++) {\n        for (int m = 0; m < 1000; m++) {\n            assertTrue(BloomFilter.optimalNumOfHashFunctions(n, m) > 0);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests that we never get an optimal hashes number of zero.\n */\n", "repo_name": "guava-master/", "id": 3728, "method_signature": "void testOptimalHashes()", "filename": "BloomFilterTest.testOptimalHashes.json"}
{"callee_method_names": ["Random.nextInt", "Random.nextDouble"], "method_name": "BloomFilterTest.testOptimalSize", "method_implementation": "{\n    for (int n = 1; n < 1000; n++) {\n        for (double fpp = Double.MIN_VALUE; fpp < 1.0; fpp += 0.001) {\n            assertTrue(BloomFilter.optimalNumOfBits(n, fpp) >= 0);\n        }\n    }\n    // some random values\n    Random random = new Random(0);\n    for (int repeats = 0; repeats < 10000; repeats++) {\n        assertTrue(BloomFilter.optimalNumOfBits(random.nextInt(1 << 16), random.nextDouble()) >= 0);\n    }\n    // and some crazy values (this used to be capped to Integer.MAX_VALUE, now it can go bigger\n    assertEquals(3327428144502L, BloomFilter.optimalNumOfBits(Integer.MAX_VALUE, Double.MIN_VALUE));\n    IllegalArgumentException expected = assertThrows(IllegalArgumentException.class, () -> {\n        BloomFilter<String> unused = BloomFilter.create(HashTestUtils.BAD_FUNNEL, Integer.MAX_VALUE, Double.MIN_VALUE);\n    });\n    assertThat(expected).hasMessageThat().isEqualTo(\"Could not create BloomFilter of 3327428144502 bits\");\n}", "repo_id": "5", "comment": "/**\n * Tests that we always get a non-negative optimal size.\n */\n", "repo_name": "guava-master/", "id": 3729, "method_signature": "void testOptimalSize()", "filename": "BloomFilterTest.testOptimalSize.json"}
{"callee_method_names": [], "method_name": "Booleans.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new BooleanArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>There are at most two distinct objects in this list, {@code (Boolean) true} and {@code\n * (Boolean) false}. Java guarantees that those are always represented by the same objects.\n *\n * <p>The returned list is serializable.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4523, "method_signature": "List<Boolean> asList(boolean[])", "filename": "Booleans.asList.json"}
{"callee_method_names": [], "method_name": "Booleans.concat", "method_implementation": "{\n    int length = 0;\n    for (boolean[] array : arrays) {\n        length += array.length;\n    }\n    boolean[] result = new boolean[length];\n    int pos = 0;\n    for (boolean[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new boolean[] {a, b}, new boolean[] {}, new boolean[] {c}} returns the array {@code {a,\n * b, c}}.\n *\n * @param arrays zero or more {@code boolean} arrays\n * @return a single array containing all the values from the source arrays, in order\n */\n", "repo_name": "guava-master/", "id": 4519, "method_signature": "boolean[] concat(boolean[][])", "filename": "Booleans.concat.json"}
{"callee_method_names": [], "method_name": "Booleans.contains", "method_implementation": "{\n    for (boolean value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.\n *\n * <p><b>Note:</b> consider representing the array as a {@link java.util.BitSet} instead,\n * replacing {@code Booleans.contains(array, true)} with {@code !bitSet.isEmpty()} and {@code\n * Booleans.contains(array, false)} with {@code bitSet.nextClearBit(0) == sizeOfBitSet}.\n *\n * @param array an array of {@code boolean} values, possibly empty\n * @param target a primitive {@code boolean} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4515, "method_signature": "boolean contains(boolean[], boolean)", "filename": "Booleans.contains.json"}
{"callee_method_names": [], "method_name": "Booleans.countTrue", "method_implementation": "{\n    int count = 0;\n    for (boolean value : values) {\n        if (value) {\n            count++;\n        }\n    }\n    return count;\n}", "repo_id": "5", "comment": "/**\n * Returns the number of {@code values} that are {@code true}.\n *\n * @since 16.0\n */\n", "repo_name": "guava-master/", "id": 4524, "method_signature": "int countTrue(boolean[])", "filename": "Booleans.countTrue.json"}
{"callee_method_names": [], "method_name": "Booleans.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4520, "method_signature": "boolean[] ensureCapacity(boolean[], int, int)", "filename": "Booleans.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Booleans.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4517, "method_signature": "int indexOf(boolean[], boolean[])", "filename": "Booleans.indexOf.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Booleans.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 7);\n    builder.append(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code boolean} values separated by {@code separator}.\n * For example, {@code join(\"-\", false, true, false)} returns the string {@code\n * \"false-true-false\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code boolean} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4521, "method_signature": "String join(String, boolean[])", "filename": "Booleans.join.json"}
{"callee_method_names": [], "method_name": "Booleans.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4518, "method_signature": "int lastIndexOf(boolean[], boolean, int, int)", "filename": "Booleans.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Booleans.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        boolean tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Booleans.asList(array).subList(fromIndex, toIndex))}, but is likely to be\n * more efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4525, "method_signature": "void reverse(boolean[], int, int)", "filename": "Booleans.reverse.json"}
{"callee_method_names": [], "method_name": "Booleans.rotate", "method_implementation": "{\n    // See Ints.rotate for more details about possible algorithms here.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Booleans.asList(array).subList(fromIndex, toIndex), distance)}, but is\n * somewhat faster.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4526, "method_signature": "void rotate(boolean[], int, int, int)", "filename": "Booleans.rotate.json"}
{"callee_method_names": ["Collection<Boolean>.toArray"], "method_name": "Booleans.toArray", "method_implementation": "{\n    if (collection instanceof BooleanArrayAsList) {\n        return ((BooleanArrayAsList) collection).toBooleanArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    boolean[] array = new boolean[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = (Boolean) checkNotNull(boxedArray[i]);\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Copies a collection of {@code Boolean} instances into a new array of primitive {@code boolean}\n * values.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * <p><b>Note:</b> consider representing the collection as a {@link java.util.BitSet} instead.\n *\n * @param collection a collection of {@code Boolean} objects\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n */\n", "repo_name": "guava-master/", "id": 4522, "method_signature": "boolean[] toArray(Collection)", "filename": "Booleans.toArray.json"}
{"callee_method_names": ["Range<C>.isEmpty", "List<Range<C>>.add"], "method_name": "Builder.add", "method_implementation": "{\n    checkArgument(!range.isEmpty(), \"range must not be empty, but was %s\", range);\n    ranges.add(range);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,\n * but overlapping ranges will cause an exception when {@link #build()} is called.\n *\n * @throws IllegalArgumentException if {@code range} is empty\n */\n", "repo_name": "guava-master/", "id": 6637, "method_signature": "Builder<C> add(Range)", "filename": "Builder.add.json"}
{"callee_method_names": [], "method_name": "Builder.addAll", "method_implementation": "{\n    for (Range<C> range : ranges) {\n        add(range);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be\n * merged, but overlapping ranges will cause an exception when {@link #build()} is called.\n *\n * @throws IllegalArgumentException if any inserted ranges are empty\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 6638, "method_signature": "Builder<C> addAll(Iterable)", "filename": "Builder.addAll.json"}
{"callee_method_names": ["ObjectCountHashMap<E>.put", "ObjectCountHashMap<E>.get"], "method_name": "Builder.addCopies", "method_implementation": "{\n    // see the comment on the field\n    requireNonNull(contents);\n    if (occurrences == 0) {\n        return this;\n    }\n    if (buildInvoked) {\n        contents = new ObjectCountHashMap<E>(contents);\n        isLinkedHash = false;\n    }\n    buildInvoked = false;\n    checkNotNull(element);\n    contents.put(element, occurrences + contents.get(element));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds a number of occurrences of an element to this {@code ImmutableMultiset}.\n *\n * @param element the element to add\n * @param occurrences the number of occurrences of the element to add. May be zero, in which\n *     case no change will be made.\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code element} is null\n * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation\n *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element\n */\n", "repo_name": "guava-master/", "id": 5709, "method_signature": "Builder<E> addCopies(E, int)", "filename": "Builder.addCopies.json"}
{"callee_method_names": ["MutableNetwork<N, E>.addEdge"], "method_name": "Builder.addEdge", "method_implementation": "{\n    mutableNetwork.addEdge(endpoints, edge);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will\n * also connect {@code nodeV} to {@code nodeU}.\n *\n * <p>If this network is directed, {@code edge} will be directed in this network; if it is\n * undirected, {@code edge} will be undirected in this network.\n *\n * <p>If this network is directed, {@code endpoints} must be ordered.\n *\n * <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It\n * must also be non-null.\n *\n * <p>If either or both endpoints are not already present in this network, this method will\n * silently {@link #addNode(Object) add} each missing endpoint to the network.\n *\n * <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this\n * method will have no effect.\n *\n * @return this {@code Builder} object\n * @throws IllegalArgumentException if {@code edge} already exists in the network and connects\n *     some other endpoint pair that is not equal to {@code endpoints}\n * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}\n * @throws IllegalArgumentException if the endpoints are unordered and the network is directed\n */\n", "repo_name": "guava-master/", "id": 6751, "method_signature": "ImmutableNetwork.Builder<N,E> addEdge(EndpointPair, E)", "filename": "Builder.addEdge.json"}
{"callee_method_names": ["HashMap.put"], "method_name": "Builder.addEscape", "method_implementation": "{\n    checkNotNull(replacement);\n    // This can replace an existing character (the builder is re-usable).\n    replacementMap.put(c, replacement);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds a replacement string for the given input character. The specified character will be\n * replaced by the given string whenever it occurs in the input, irrespective of whether it lies\n * inside or outside the 'safe' range.\n *\n * @param c the character to be replaced\n * @param replacement the string to replace the given character\n * @return the builder instance\n * @throws NullPointerException if {@code replacement} is null\n */\n", "repo_name": "guava-master/", "id": 4279, "method_signature": "Builder addEscape(char, String)", "filename": "Builder.addEscape.json"}
{"callee_method_names": ["MutableValueGraph<N, V>.addNode"], "method_name": "Builder.addNode", "method_implementation": "{\n    mutableValueGraph.addNode(node);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code node} if it is not already present.\n *\n * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.\n *\n * @return this {@code Builder} object\n */\n", "repo_name": "guava-master/", "id": 6789, "method_signature": "ImmutableValueGraph.Builder<N,V> addNode(N)", "filename": "Builder.addNode.json"}
{"callee_method_names": ["Map<K, Collection<V>>.entrySet"], "method_name": "Builder.build", "method_implementation": "{\n    Collection<Map.Entry<K, Collection<V>>> mapEntries = builderMap.entrySet();\n    if (keyComparator != null) {\n        mapEntries = Ordering.from(keyComparator).<K>onKeys().immutableSortedCopy(mapEntries);\n    }\n    return ImmutableListMultimap.fromMapEntries(mapEntries, valueComparator);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created immutable multimap.\n */\n", "repo_name": "guava-master/", "id": 6671, "method_signature": "ImmutableMultimap<K,V> build()", "filename": "Builder.build.json"}
{"callee_method_names": [], "method_name": "Builder.buildKeepingLast", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported for bimaps\");\n}", "repo_id": "5", "comment": "/**\n * Throws {@link UnsupportedOperationException}. This method is inherited from {@link\n * ImmutableMap.Builder}, but it does not make sense for bimaps.\n *\n * @throws UnsupportedOperationException always\n * @deprecated This method does not make sense for bimaps and should not be called.\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 6372, "method_signature": "ImmutableBiMap<K,V> buildKeepingLast()", "filename": "Builder.buildKeepingLast.json"}
{"callee_method_names": [], "method_name": "Builder.buildOrThrow", "method_implementation": "{\n    if (size == 0) {\n        return of();\n    }\n    if (valueComparator != null) {\n        if (entriesUsed) {\n            alternatingKeysAndValues = Arrays.copyOf(alternatingKeysAndValues, 2 * size);\n        }\n        sortEntries(alternatingKeysAndValues, size, valueComparator);\n    }\n    entriesUsed = true;\n    return new RegularImmutableBiMap<K, V>(alternatingKeysAndValues, size);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created immutable bimap, or throws an exception if any key or value was added\n * more than once. The iteration order of the returned bimap is the order in which entries were\n * inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case\n * entries are sorted by value.\n *\n * @throws IllegalArgumentException if duplicate keys or values were added\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 6371, "method_signature": "ImmutableBiMap<K,V> buildOrThrow()", "filename": "Builder.buildOrThrow.json"}
{"callee_method_names": ["MinMaxPriorityQueue<T>.offer"], "method_name": "Builder.create", "method_implementation": "{\n    MinMaxPriorityQueue<T> queue = new MinMaxPriorityQueue<>(this, initialQueueSize(expectedSize, maximumSize, initialContents));\n    for (T element : initialContents) {\n        queue.offer(element);\n    }\n    return queue;\n}", "repo_id": "5", "comment": "/**\n * Builds a new min-max priority queue using the previously specified options, and having the\n * given initial elements.\n */\n", "repo_name": "guava-master/", "id": 6529, "method_signature": "MinMaxPriorityQueue<T> create(Iterable)", "filename": "Builder.create.json"}
{"callee_method_names": [], "method_name": "Builder.expandedCapacity", "method_implementation": "{\n    if (minCapacity < 0) {\n        throw new AssertionError(\"cannot store more than MAX_VALUE elements\");\n    }\n    // careful of overflow!\n    int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;\n    if (newCapacity < minCapacity) {\n        newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;\n    }\n    if (newCapacity < 0) {\n        // guaranteed to be >= newCapacity\n        newCapacity = Integer.MAX_VALUE;\n    }\n    return newCapacity;\n}", "repo_id": "5", "comment": "// Unfortunately this is pasted from ImmutableCollection.Builder.\n", "repo_name": "guava-master/", "id": 4514, "method_signature": "int expandedCapacity(int, int)", "filename": "Builder.expandedCapacity.json"}
{"callee_method_names": [], "method_name": "Builder.expectedSize", "method_implementation": "{\n    checkArgument(expectedSize >= 0);\n    this.expectedSize = expectedSize;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures this builder to build min-max priority queues with an initial expected size of\n * {@code expectedSize}.\n */\n", "repo_name": "guava-master/", "id": 6527, "method_signature": "Builder<B> expectedSize(int)", "filename": "Builder.expectedSize.json"}
{"callee_method_names": [], "method_name": "Builder.maintenance", "method_implementation": "{\n    if (length == elements.length) {\n        dedupAndCoalesce(true);\n    } else if (forceCopyElements) {\n        this.elements = Arrays.copyOf(elements, elements.length);\n        // we don't currently need to copy the counts array, because we don't use it directly\n        // in built ISMs\n    }\n    forceCopyElements = false;\n}", "repo_id": "5", "comment": "/**\n * Check if we need to do deduplication and coalescing, and if so, do it.\n */\n", "repo_name": "guava-master/", "id": 5636, "method_signature": "void maintenance()", "filename": "Builder.maintenance.json"}
{"callee_method_names": [], "method_name": "Builder.maximumSize", "method_implementation": "{\n    checkArgument(maximumSize > 0);\n    this.maximumSize = maximumSize;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures this builder to build {@code MinMaxPriorityQueue} instances that are limited to\n * {@code maximumSize} elements. Each time a queue grows beyond this bound, it immediately\n * removes its greatest element (according to its comparator), which might be the element that\n * was just added.\n */\n", "repo_name": "guava-master/", "id": 6528, "method_signature": "Builder<B> maximumSize(int)", "filename": "Builder.maximumSize.json"}
{"callee_method_names": [], "method_name": "Builder.orderColumnsBy", "method_implementation": "{\n    this.columnComparator = checkNotNull(columnComparator, \"columnComparator\");\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated table's columns.\n */\n", "repo_name": "guava-master/", "id": 5820, "method_signature": "Builder<R,C,V> orderColumnsBy(Comparator)", "filename": "Builder.orderColumnsBy.json"}
{"callee_method_names": [], "method_name": "Builder.orderEntriesByValue", "method_implementation": "{\n    super.orderEntriesByValue(valueComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures this {@code Builder} to order entries by value according to the specified\n * comparator.\n *\n * <p>The sort order is stable, that is, if two entries have values that compare as equivalent,\n * the entry that was inserted first will be first in the built map's iteration order.\n *\n * @throws IllegalStateException if this method was already called\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6370, "method_signature": "Builder<K,V> orderEntriesByValue(Comparator)", "filename": "Builder.orderEntriesByValue.json"}
{"callee_method_names": [], "method_name": "Builder.orderKeysBy", "method_implementation": "{\n    this.keyComparator = checkNotNull(keyComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated multimap's keys.\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6669, "method_signature": "Builder<K,V> orderKeysBy(Comparator)", "filename": "Builder.orderKeysBy.json"}
{"callee_method_names": [], "method_name": "Builder.orderRowsBy", "method_implementation": "{\n    this.rowComparator = checkNotNull(rowComparator, \"rowComparator\");\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated table's rows.\n */\n", "repo_name": "guava-master/", "id": 5819, "method_signature": "Builder<R,C,V> orderRowsBy(Comparator)", "filename": "Builder.orderRowsBy.json"}
{"callee_method_names": [], "method_name": "Builder.orderValuesBy", "method_implementation": "{\n    this.valueComparator = checkNotNull(valueComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated multimap's values for each key.\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6670, "method_signature": "Builder<K,V> orderValuesBy(Comparator)", "filename": "Builder.orderValuesBy.json"}
{"callee_method_names": ["Map<K, Collection<V>>.get", "Map<K, Collection<V>>.put", "Collection<V>.add"], "method_name": "Builder.put", "method_implementation": "{\n    checkEntryNotNull(key, value);\n    Collection<V> valueCollection = builderMap.get(key);\n    if (valueCollection == null) {\n        builderMap.put(key, valueCollection = newMutableValueCollection());\n    }\n    valueCollection.add(value);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds a key-value mapping to the built multimap.\n */\n", "repo_name": "guava-master/", "id": 6665, "method_signature": "Builder<K,V> put(K, V)", "filename": "Builder.put.json"}
{"callee_method_names": ["Multimap<? extends K,? extends V>.asMap", "long.getKey", "long.getValue"], "method_name": "Builder.putAll", "method_implementation": "{\n    for (Entry<? extends K, ? extends Collection<? extends V>> entry : multimap.asMap().entrySet()) {\n        putAll(entry.getKey(), entry.getValue());\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Stores another multimap's entries in the built multimap. The generated multimap's key and\n * value orderings correspond to the iteration ordering of the {@code multimap.asMap()} view,\n * with new keys and values following any existing keys and values.\n *\n * @throws NullPointerException if any key or value in {@code multimap} is null. The builder is\n *     left in an invalid state.\n */\n", "repo_name": "guava-master/", "id": 6668, "method_signature": "Builder<K,V> putAll(Multimap)", "filename": "Builder.putAll.json"}
{"callee_method_names": ["MutableGraph<N>.putEdge"], "method_name": "Builder.putEdge", "method_implementation": "{\n    mutableGraph.putEdge(endpoints);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds an edge connecting {@code endpoints} (in the order, if any, specified by {@code\n * endpoints}) if one is not already present.\n *\n * <p>If this graph is directed, {@code endpoints} must be ordered and the added edge will be\n * directed; if it is undirected, the added edge will be undirected.\n *\n * <p>If this graph is directed, {@code endpoints} must be ordered.\n *\n * <p>If either or both endpoints are not already present in this graph, this method will\n * silently {@link #addNode(Object) add} each missing endpoint to the graph.\n *\n * @return this {@code Builder} object\n * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n *     #allowsSelfLoops()}\n * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n */\n", "repo_name": "guava-master/", "id": 6784, "method_signature": "Builder<N> putEdge(EndpointPair)", "filename": "Builder.putEdge.json"}
{"callee_method_names": ["MutableValueGraph<N, V>.putEdgeValue"], "method_name": "Builder.putEdgeValue", "method_implementation": "{\n    mutableValueGraph.putEdgeValue(endpoints, value);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds an edge connecting {@code endpoints} if one is not already present, and sets a value for\n * that edge to {@code value} (overwriting the existing value, if any).\n *\n * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n * undirected.\n *\n * <p>If this graph is directed, {@code endpoints} must be ordered.\n *\n * <p>Values do not have to be unique. However, values must be non-null.\n *\n * <p>If either or both endpoints are not already present in this graph, this method will\n * silently {@link #addNode(Object) add} each missing endpoint to the graph.\n *\n * @return this {@code Builder} object\n * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n *     #allowsSelfLoops()}\n * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n */\n", "repo_name": "guava-master/", "id": 6791, "method_signature": "ImmutableValueGraph.Builder<N,V> putEdgeValue(EndpointPair, V)", "filename": "Builder.putEdgeValue.json"}
{"callee_method_names": ["ObjectCountHashMap<E>.remove", "ObjectCountHashMap<E>.put"], "method_name": "Builder.setCount", "method_implementation": "{\n    // see the comment on the field\n    requireNonNull(contents);\n    if (count == 0 && !isLinkedHash) {\n        contents = new ObjectCountLinkedHashMap<E>(contents);\n        isLinkedHash = true;\n        // to preserve insertion order through deletions, we have to switch to an actual linked\n        // implementation at least for now, but this should be a super rare case\n    } else if (buildInvoked) {\n        contents = new ObjectCountHashMap<E>(contents);\n        isLinkedHash = false;\n    }\n    buildInvoked = false;\n    checkNotNull(element);\n    if (count == 0) {\n        contents.remove(element);\n    } else {\n        contents.put(checkNotNull(element), count);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds or removes the necessary occurrences of an element such that the element attains the\n * desired count.\n *\n * @param element the element to add or remove occurrences of\n * @param count the desired count of the element in this multiset\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code element} is null\n * @throws IllegalArgumentException if {@code count} is negative\n */\n", "repo_name": "guava-master/", "id": 5710, "method_signature": "Builder<E> setCount(E, int)", "filename": "Builder.setCount.json"}
{"callee_method_names": [], "method_name": "Builder.setSafeRange", "method_implementation": "{\n    this.safeMin = safeMin;\n    this.safeMax = safeMax;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the safe range of characters for the escaper. Characters in this range that have no\n * explicit replacement are considered 'safe' and remain unescaped in the output. If {@code\n * safeMax < safeMin} then the safe range is empty.\n *\n * @param safeMin the lowest 'safe' character\n * @param safeMax the highest 'safe' character\n * @return the builder instance\n */\n", "repo_name": "guava-master/", "id": 4277, "method_signature": "Builder setSafeRange(char, char)", "filename": "Builder.setSafeRange.json"}
{"callee_method_names": [], "method_name": "Builder.setUnsafeReplacement", "method_implementation": "{\n    this.unsafeReplacement = unsafeReplacement;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the replacement string for any characters outside the 'safe' range that have no explicit\n * replacement. If {@code unsafeReplacement} is {@code null} then no replacement will occur, if\n * it is {@code \"\"} then the unsafe characters are removed from the output.\n *\n * @param unsafeReplacement the string to replace unsafe characters\n * @return the builder instance\n */\n", "repo_name": "guava-master/", "id": 4278, "method_signature": "Builder setUnsafeReplacement(String)", "filename": "Builder.setUnsafeReplacement.json"}
{"callee_method_names": [], "method_name": "Builder.tryGetMap", "method_implementation": "{\n    if (multiset instanceof RegularImmutableMultiset) {\n        return ((RegularImmutableMultiset<T>) multiset).contents;\n    } else if (multiset instanceof AbstractMapBasedMultiset) {\n        return ((AbstractMapBasedMultiset<T>) multiset).backingMap;\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * If the specified collection is backed by an ObjectCountHashMap, it will be much more\n * efficient to iterate over it by index rather than an entry iterator, which will need to\n * allocate an object for each entry, so we check for that.\n */\n", "repo_name": "guava-master/", "id": 5713, "method_signature": "ObjectCountHashMap<T> tryGetMap(Iterable)", "filename": "Builder.tryGetMap.json"}
{"callee_method_names": [], "method_name": "ByteSink.openBufferedStream", "method_implementation": "{\n    OutputStream out = openStream();\n    return (out instanceof BufferedOutputStream) ? (BufferedOutputStream) out : new BufferedOutputStream(out);\n}", "repo_id": "5", "comment": "/**\n * Opens a new buffered {@link OutputStream} for writing to this sink. The returned stream is not\n * required to be a {@link BufferedOutputStream} in order to allow implementations to simply\n * delegate to {@link #openStream()} when the stream returned by that method does not benefit from\n * additional buffering (for example, a {@code ByteArrayOutputStream}). This method returns a new,\n * independent stream each time it is called.\n *\n * <p>The caller is responsible for ensuring that the returned stream is closed.\n *\n * @throws IOException if an I/O error occurs while opening the stream\n * @since 15.0 (in 14.0 with return type {@link BufferedOutputStream})\n */\n", "repo_name": "guava-master/", "id": 4808, "method_signature": "OutputStream openBufferedStream()", "filename": "ByteSink.openBufferedStream.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "OutputStream.write", "OutputStream.flush", "Closer.rethrow", "Closer.close"], "method_name": "ByteSink.write", "method_implementation": "{\n    checkNotNull(bytes);\n    Closer closer = Closer.create();\n    try {\n        OutputStream out = closer.register(openStream());\n        out.write(bytes);\n        // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n        out.flush();\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Writes all the given bytes to this sink.\n *\n * @throws IOException if an I/O occurs while writing to this sink\n */\n", "repo_name": "guava-master/", "id": 4809, "method_signature": "void write(byte[])", "filename": "ByteSink.write.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "OutputStream.flush", "Closer.rethrow", "Closer.close"], "method_name": "ByteSink.writeFrom", "method_implementation": "{\n    checkNotNull(input);\n    Closer closer = Closer.create();\n    try {\n        OutputStream out = closer.register(openStream());\n        long written = ByteStreams.copy(input, out);\n        // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n        out.flush();\n        return written;\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Writes all the bytes from the given {@code InputStream} to this sink. Does not close {@code\n * input}.\n *\n * @return the number of bytes written\n * @throws IOException if an I/O occurs while reading from {@code input} or writing to this sink\n */\n", "repo_name": "guava-master/", "id": 4810, "method_signature": "long writeFrom(InputStream)", "filename": "ByteSink.writeFrom.json"}
{"callee_method_ids": [4848, 4848, 4851, 4852], "callee_method_names": ["Closer.register", "Closer.register", "ByteSource.openStream", "Closer.rethrow", "Closer.close"], "method_name": "ByteSource.contentEquals", "method_implementation": "{\n    checkNotNull(other);\n    byte[] buf1 = createBuffer();\n    byte[] buf2 = createBuffer();\n    Closer closer = Closer.create();\n    try {\n        InputStream in1 = closer.register(openStream());\n        InputStream in2 = closer.register(other.openStream());\n        while (true) {\n            int read1 = ByteStreams.read(in1, buf1, 0, buf1.length);\n            int read2 = ByteStreams.read(in2, buf2, 0, buf2.length);\n            if (read1 != read2 || !Arrays.equals(buf1, buf2)) {\n                return false;\n            } else if (read1 != buf1.length) {\n                return true;\n            }\n        }\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks that the contents of this byte source are equal to the contents of the given byte\n * source.\n *\n * @throws IOException if an I/O error occurs while reading from this source or {@code other}\n */\n", "repo_name": "guava-master/", "id": 4767, "method_signature": "boolean contentEquals(ByteSource)", "filename": "ByteSource.contentEquals.json"}
{"callee_method_ids": [4848, 4848, 4851, 4852], "callee_method_names": ["Closer.register", "Closer.register", "ByteSink.openStream", "Closer.rethrow", "Closer.close"], "method_name": "ByteSource.copyTo", "method_implementation": "{\n    checkNotNull(sink);\n    Closer closer = Closer.create();\n    try {\n        InputStream in = closer.register(openStream());\n        OutputStream out = closer.register(sink.openStream());\n        return ByteStreams.copy(in, out);\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Copies the contents of this byte source to the given {@code ByteSink}.\n *\n * @return the number of bytes copied\n * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n *     sink}\n */\n", "repo_name": "guava-master/", "id": 4763, "method_signature": "long copyTo(ByteSink)", "filename": "ByteSource.copyTo.json"}
{"callee_method_names": [], "method_name": "ByteSource.countBySkipping", "method_implementation": "{\n    long count = 0;\n    long skipped;\n    while ((skipped = skipUpTo(in, Integer.MAX_VALUE)) > 0) {\n        count += skipped;\n    }\n    return count;\n}", "repo_id": "5", "comment": "/**\n * Counts the bytes in the given input stream using skip if possible.\n */\n", "repo_name": "guava-master/", "id": 4761, "method_signature": "long countBySkipping(InputStream)", "filename": "ByteSource.countBySkipping.json"}
{"callee_method_names": ["HashFunction.newHasher", "Hasher.hash"], "method_name": "ByteSource.hash", "method_implementation": "{\n    Hasher hasher = hashFunction.newHasher();\n    copyTo(Funnels.asOutputStream(hasher));\n    return hasher.hash();\n}", "repo_id": "5", "comment": "/**\n * Hashes the contents of this byte source using the given hash function.\n *\n * @throws IOException if an I/O error occurs while reading from this source\n */\n", "repo_name": "guava-master/", "id": 4766, "method_signature": "HashCode hash(HashFunction)", "filename": "ByteSource.hash.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Optional<Long>.isPresent", "Optional<Long>.get", "Closer.register", "InputStream.read", "Closer.rethrow", "Closer.close"], "method_name": "ByteSource.isEmpty", "method_implementation": "{\n    Optional<Long> sizeIfKnown = sizeIfKnown();\n    if (sizeIfKnown.isPresent()) {\n        return sizeIfKnown.get() == 0L;\n    }\n    Closer closer = Closer.create();\n    try {\n        InputStream in = closer.register(openStream());\n        return in.read() == -1;\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns whether the source has zero bytes. The default implementation first checks {@link\n * #sizeIfKnown}, returning true if it's known to be zero and false if it's known to be non-zero.\n * If the size is not known, it falls back to opening a stream and checking for EOF.\n *\n * <p>Note that, in cases where {@code sizeIfKnown} returns zero, it is <i>possible</i> that bytes\n * are actually available for reading. (For example, some special files may return a size of 0\n * despite actually having content when read.) This means that a source may return {@code true}\n * from {@code isEmpty()} despite having readable content.\n *\n * @throws IOException if an I/O error occurs\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 4759, "method_signature": "boolean isEmpty()", "filename": "ByteSource.isEmpty.json"}
{"callee_method_names": [], "method_name": "ByteSource.openBufferedStream", "method_implementation": "{\n    InputStream in = openStream();\n    return (in instanceof BufferedInputStream) ? (BufferedInputStream) in : new BufferedInputStream(in);\n}", "repo_id": "5", "comment": "/**\n * Opens a new buffered {@link InputStream} for reading from this source. The returned stream is\n * not required to be a {@link BufferedInputStream} in order to allow implementations to simply\n * delegate to {@link #openStream()} when the stream returned by that method does not benefit from\n * additional buffering (for example, a {@code ByteArrayInputStream}). This method returns a new,\n * independent stream each time it is called.\n *\n * <p>The caller is responsible for ensuring that the returned stream is closed.\n *\n * @throws IOException if an I/O error occurs while opening the stream\n * @since 15.0 (in 14.0 with return type {@link BufferedInputStream})\n */\n", "repo_name": "guava-master/", "id": 4758, "method_signature": "InputStream openBufferedStream()", "filename": "ByteSource.openBufferedStream.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "Closer.rethrow", "Closer.close"], "method_name": "ByteSource.read", "method_implementation": "{\n    checkNotNull(processor);\n    Closer closer = Closer.create();\n    try {\n        InputStream in = closer.register(openStream());\n        return ByteStreams.readBytes(in, processor);\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Reads the contents of this byte source using the given {@code processor} to process bytes as\n * they are read. Stops when all bytes have been read or the consumer returns {@code false}.\n * Returns the result produced by the processor.\n *\n * @throws IOException if an I/O error occurs while reading from this source or if {@code\n *     processor} throws an {@code IOException}\n * @since 16.0\n */\n", "repo_name": "guava-master/", "id": 4765, "method_signature": "T read(ByteProcessor)", "filename": "ByteSource.read.json"}
{"callee_method_ids": [4848, 4852, 4848, 4851, 4852], "callee_method_names": ["Optional<Long>.isPresent", "Optional<Long>.get", "Closer.register", "Closer.close", "Closer.register", "Closer.rethrow", "Closer.close"], "method_name": "ByteSource.size", "method_implementation": "{\n    Optional<Long> sizeIfKnown = sizeIfKnown();\n    if (sizeIfKnown.isPresent()) {\n        return sizeIfKnown.get();\n    }\n    Closer closer = Closer.create();\n    try {\n        InputStream in = closer.register(openStream());\n        return countBySkipping(in);\n    } catch (IOException e) {\n        // skip may not be supported... at any rate, try reading\n    } finally {\n        closer.close();\n    }\n    closer = Closer.create();\n    try {\n        InputStream in = closer.register(openStream());\n        return ByteStreams.exhaust(in);\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the size of this source in bytes, even if doing so requires opening and traversing an\n * entire stream. To avoid a potentially expensive operation, see {@link #sizeIfKnown}.\n *\n * <p>The default implementation calls {@link #sizeIfKnown} and returns the value if present. If\n * absent, it will fall back to a heavyweight operation that will open a stream, read (or {@link\n * InputStream#skip(long) skip}, if possible) to the end of the stream and return the total number\n * of bytes that were read.\n *\n * <p>Note that for some sources that implement {@link #sizeIfKnown} to provide a more efficient\n * implementation, it is <i>possible</i> that this method will return a different number of bytes\n * than would be returned by reading all of the bytes (for example, some special files may return\n * a size of 0 despite actually having content when read).\n *\n * <p>In either case, for mutable sources such as files, a subsequent read may return a different\n * number of bytes if the contents are changed.\n *\n * @throws IOException if an I/O error occurs while reading the size of this source\n */\n", "repo_name": "guava-master/", "id": 4760, "method_signature": "long size()", "filename": "ByteSource.size.json"}
{"callee_method_ids": [4765], "callee_method_names": ["ByteSource.slice", "ByteSource.read"], "method_name": "ByteSourceTest.assertCorrectSlice", "method_implementation": "{\n    checkArgument(expectRead == (int) Math.max(0, Math.min(input, offset + length) - offset));\n    byte[] expected = newPreFilledByteArray(offset, expectRead);\n    ByteSource source = new TestByteSource(newPreFilledByteArray(input));\n    ByteSource slice = source.slice(offset, length);\n    assertArrayEquals(expected, slice.read());\n}", "repo_id": "5", "comment": "/**\n * @param input the size of the input source\n * @param offset the first argument to {@link ByteSource#slice}\n * @param length the second argument to {@link ByteSource#slice}\n * @param expectRead the number of bytes we expect to read\n */\n", "repo_name": "guava-master/", "id": 3639, "method_signature": "void assertCorrectSlice(int, int, long, int)", "filename": "ByteSourceTest.assertCorrectSlice.json"}
{"callee_method_ids": [4763], "callee_method_names": ["ByteSource.copyTo"], "method_name": "ByteSourceTest.runSuppressionFailureTest", "method_implementation": "{\n    try {\n        in.copyTo(out);\n        fail();\n    } catch (IOException expected) {\n        return CloserTest.getSuppressed(expected).length;\n    }\n    // can't happen\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * @return the number of exceptions that were suppressed on the expected thrown exception\n */\n", "repo_name": "guava-master/", "id": 3640, "method_signature": "int runSuppressionFailureTest(ByteSource, ByteSink)", "filename": "ByteSourceTest.runSuppressionFailureTest.json"}
{"callee_method_names": ["AppendableByteSource.slice", "ByteSource.openStream", "AppendableByteSource.append", "InputStream.read"], "method_name": "ByteSourceTest.testSlice_appendingAfterSlicing", "method_implementation": "{\n    // Source of length 5\n    AppendableByteSource source = new AppendableByteSource(newPreFilledByteArray(5));\n    // Slice it starting at offset 10.\n    ByteSource slice = source.slice(10, 5);\n    // Open a stream to the slice.\n    InputStream in = slice.openStream();\n    // Append 10 more bytes to the source.\n    source.append(newPreFilledByteArray(5, 10));\n    // The stream reports no bytes... importantly, it doesn't read the byte at index 5 when it\n    // should be reading the byte at index 10.\n    // We could use a custom InputStream instead to make the read start at index 10, but since this\n    // is a racy situation anyway, this behavior seems reasonable.\n    assertEquals(-1, in.read());\n}", "repo_id": "5", "comment": "// TODO(cgdecker): Maybe add a test for this to ByteSourceTester\n", "repo_name": "guava-master/", "id": 3638, "method_signature": "void testSlice_appendingAfterSlicing()", "filename": "ByteSourceTest.testSlice_appendingAfterSlicing.json"}
{"callee_method_ids": [4765, 4765, 4767], "callee_method_names": ["ByteSource.read", "ByteSource.slice", "ByteSource.read", "ByteSource.slice", "ByteSource.contentEquals"], "method_name": "ByteSourceTester.testSlice_constrainedRange", "method_implementation": "{\n    long size = source.read().length;\n    if (size >= 2) {\n        ByteSource sliced = source.slice(1, size - 2);\n        assertEquals(size - 2, sliced.read().length);\n        ByteSource resliced = sliced.slice(0, size - 1);\n        assertTrue(sliced.contentEquals(resliced));\n    }\n}", "repo_id": "5", "comment": "// Test that you can not expand the readable data in a previously sliced ByteSource.\n", "repo_name": "guava-master/", "id": 3647, "method_signature": "void testSlice_constrainedRange()", "filename": "ByteSourceTester.testSlice_constrainedRange.json"}
{"callee_method_names": ["FileChannel.position", "FileChannel.transferTo", "FileChannel.position", "FileChannel.size", "ReadableByteChannel.read", "ByteBuffer.hasRemaining", "WritableByteChannel.write"], "method_name": "ByteStreams.copy", "method_implementation": "{\n    checkNotNull(from);\n    checkNotNull(to);\n    if (from instanceof FileChannel) {\n        FileChannel sourceChannel = (FileChannel) from;\n        long oldPosition = sourceChannel.position();\n        long position = oldPosition;\n        long copied;\n        do {\n            copied = sourceChannel.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);\n            position += copied;\n            sourceChannel.position(position);\n        } while (copied > 0 || position < sourceChannel.size());\n        return position - oldPosition;\n    }\n    ByteBuffer buf = ByteBuffer.wrap(createBuffer());\n    long total = 0;\n    while (from.read(buf) != -1) {\n        Java8Compatibility.flip(buf);\n        while (buf.hasRemaining()) {\n            total += to.write(buf);\n        }\n        Java8Compatibility.clear(buf);\n    }\n    return total;\n}", "repo_id": "5", "comment": "/**\n * Copies all bytes from the readable channel to the writable channel. Does not close or flush\n * either channel.\n *\n * @param from the readable channel to read from\n * @param to the writable channel to write to\n * @return the number of bytes copied\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4812, "method_signature": "long copy(ReadableByteChannel, WritableByteChannel)", "filename": "ByteStreams.copy.json"}
{"callee_method_names": ["InputStream.read"], "method_name": "ByteStreams.exhaust", "method_implementation": "{\n    long total = 0;\n    long read;\n    byte[] buf = createBuffer();\n    while ((read = in.read(buf)) != -1) {\n        total += read;\n    }\n    return total;\n}", "repo_id": "5", "comment": "/**\n * Reads and discards data from the given {@code InputStream} until the end of the stream is\n * reached. Returns the total number of bytes read. Does not close the stream.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4815, "method_signature": "long exhaust(InputStream)", "filename": "ByteStreams.exhaust.json"}
{"callee_method_names": ["InputStream.mark"], "method_name": "ByteStreams.mark", "method_implementation": "{\n    in.mark(readLimit);\n    mark = left;\n}", "repo_id": "5", "comment": "// it's okay to mark even if mark isn't supported, as reset won't work\n", "repo_name": "guava-master/", "id": 4818, "method_signature": "void mark(int)", "filename": "ByteStreams.mark.json"}
{"callee_method_names": [], "method_name": "ByteStreams.newDataOutput", "method_implementation": "{\n    // When called at high frequency, boxing size generates too much garbage,\n    // so avoid doing that if we can.\n    if (size < 0) {\n        throw new IllegalArgumentException(String.format(\"Invalid size: %s\", size));\n    }\n    return newDataOutput(new ByteArrayOutputStream(size));\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@link ByteArrayDataOutput} instance sized to hold {@code size} bytes before\n * resizing.\n *\n * @throws IllegalArgumentException if {@code size} is negative\n */\n", "repo_name": "guava-master/", "id": 4816, "method_signature": "ByteArrayDataOutput newDataOutput(int)", "filename": "ByteStreams.newDataOutput.json"}
{"callee_method_names": ["InputStream.read"], "method_name": "ByteStreams.read", "method_implementation": "{\n    checkNotNull(in);\n    checkNotNull(b);\n    if (len < 0) {\n        throw new IndexOutOfBoundsException(String.format(\"len (%s) cannot be negative\", len));\n    }\n    checkPositionIndexes(off, off + len, b.length);\n    int total = 0;\n    while (total < len) {\n        int result = in.read(b, off + total, len - total);\n        if (result == -1) {\n            break;\n        }\n        total += result;\n    }\n    return total;\n}", "repo_id": "5", "comment": "/**\n * Reads some bytes from an input stream and stores them into the buffer array {@code b}. This\n * method blocks until {@code len} bytes of input data have been read into the array, or end of\n * file is detected. The number of bytes read is returned, possibly zero. Does not close the\n * stream.\n *\n * <p>A caller can detect EOF if the number of bytes read is less than {@code len}. All subsequent\n * calls on the same stream will return zero.\n *\n * <p>If {@code b} is null, a {@code NullPointerException} is thrown. If {@code off} is negative,\n * or {@code len} is negative, or {@code off+len} is greater than the length of the array {@code\n * b}, then an {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then no bytes\n * are read. Otherwise, the first byte read is stored into element {@code b[off]}, the next one\n * into {@code b[off+1]}, and so on. The number of bytes read is, at most, equal to {@code len}.\n *\n * @param in the input stream to read from\n * @param b the buffer into which the data is read\n * @param off an int specifying the offset into the data\n * @param len an int specifying the number of bytes to read\n * @return the number of bytes read\n * @throws IOException if an I/O error occurs\n * @throws IndexOutOfBoundsException if {@code off} is negative, if {@code len} is negative, or if\n *     {@code off + len} is greater than {@code b.length}\n */\n", "repo_name": "guava-master/", "id": 4823, "method_signature": "int read(InputStream, byte[], int, int)", "filename": "ByteStreams.read.json"}
{"callee_method_names": ["InputStream.read", "ByteProcessor<T>.processBytes", "ByteProcessor<T>.getResult"], "method_name": "ByteStreams.readBytes", "method_implementation": "{\n    checkNotNull(input);\n    checkNotNull(processor);\n    byte[] buf = createBuffer();\n    int read;\n    do {\n        read = input.read(buf);\n    } while (read != -1 && processor.processBytes(buf, 0, read));\n    return processor.getResult();\n}", "repo_id": "5", "comment": "/**\n * Process the bytes of the given input stream using the given processor.\n *\n * @param input the input stream to process\n * @param processor the object to which to pass the bytes of the stream\n * @return the result of the byte processor\n * @throws IOException if an I/O error occurs\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4822, "method_signature": "T readBytes(InputStream, ByteProcessor)", "filename": "ByteStreams.readBytes.json"}
{"callee_method_names": [], "method_name": "ByteStreams.readFully", "method_implementation": "{\n    int read = read(in, b, off, len);\n    if (read != len) {\n        throw new EOFException(\"reached end of stream after reading \" + read + \" bytes; \" + len + \" bytes expected\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Attempts to read {@code len} bytes from the stream into the given array starting at {@code\n * off}, with the same behavior as {@link DataInput#readFully(byte[], int, int)}. Does not close\n * the stream.\n *\n * @param in the input stream to read from.\n * @param b the buffer into which the data is read.\n * @param off an int specifying the offset into the data.\n * @param len an int specifying the number of bytes to read.\n * @throws EOFException if this stream reaches the end before reading all the bytes.\n * @throws IOException if an I/O error occurs.\n */\n", "repo_name": "guava-master/", "id": 4819, "method_signature": "void readFully(InputStream, byte[], int, int)", "filename": "ByteStreams.readFully.json"}
{"callee_method_names": [], "method_name": "ByteStreams.skipFully", "method_implementation": "{\n    long skipped = skipUpTo(in, n);\n    if (skipped < n) {\n        throw new EOFException(\"reached end of stream after skipping \" + skipped + \" bytes; \" + n + \" bytes expected\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Discards {@code n} bytes of data from the input stream. This method will block until the full\n * amount has been skipped. Does not close the stream.\n *\n * @param in the input stream to read from\n * @param n the number of bytes to skip\n * @throws EOFException if this stream reaches the end before skipping all the bytes\n * @throws IOException if an I/O error occurs, or the stream does not support skipping\n */\n", "repo_name": "guava-master/", "id": 4820, "method_signature": "void skipFully(InputStream, long)", "filename": "ByteStreams.skipFully.json"}
{"callee_method_names": ["InputStream.read"], "method_name": "ByteStreams.skipUpTo", "method_implementation": "{\n    long totalSkipped = 0;\n    // A buffer is allocated if skipSafely does not skip any bytes.\n    byte[] buf = null;\n    while (totalSkipped < n) {\n        long remaining = n - totalSkipped;\n        long skipped = skipSafely(in, remaining);\n        if (skipped == 0) {\n            // Do a buffered read since skipSafely could return 0 repeatedly, for example if\n            // in.available() always returns 0 (the default).\n            int skip = (int) Math.min(remaining, BUFFER_SIZE);\n            if (buf == null) {\n                // Allocate a buffer bounded by the maximum size that can be requested, for\n                // example an array of BUFFER_SIZE is unnecessary when the value of remaining\n                // is smaller.\n                buf = new byte[skip];\n            }\n            if ((skipped = in.read(buf, 0, skip)) == -1) {\n                // Reached EOF\n                break;\n            }\n        }\n        totalSkipped += skipped;\n    }\n    return totalSkipped;\n}", "repo_id": "5", "comment": "/**\n * Discards up to {@code n} bytes of data from the input stream. This method will block until\n * either the full amount has been skipped or until the end of the stream is reached, whichever\n * happens first. Returns the total number of bytes skipped.\n */\n", "repo_name": "guava-master/", "id": 4821, "method_signature": "long skipUpTo(InputStream, long)", "filename": "ByteStreams.skipUpTo.json"}
{"callee_method_names": ["InputStream.read", "InputStream.read", "Queue<byte[]>.add", "Queue<byte[]>.add"], "method_name": "ByteStreams.toByteArray", "method_implementation": "{\n    checkArgument(expectedSize >= 0, \"expectedSize (%s) must be non-negative\", expectedSize);\n    if (expectedSize > MAX_ARRAY_LEN) {\n        throw new OutOfMemoryError(expectedSize + \" bytes is too large to fit in a byte array\");\n    }\n    byte[] bytes = new byte[(int) expectedSize];\n    int remaining = (int) expectedSize;\n    while (remaining > 0) {\n        int off = (int) expectedSize - remaining;\n        int read = in.read(bytes, off, remaining);\n        if (read == -1) {\n            // end of stream before reading expectedSize bytes\n            // just return the bytes read so far\n            return Arrays.copyOf(bytes, off);\n        }\n        remaining -= read;\n    }\n    // bytes is now full\n    int b = in.read();\n    if (b == -1) {\n        return bytes;\n    }\n    // the stream was longer, so read the rest normally\n    Queue<byte[]> bufs = new ArrayDeque<>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);\n    bufs.add(bytes);\n    bufs.add(new byte[] { (byte) b });\n    return toByteArrayInternal(in, bufs, bytes.length + 1);\n}", "repo_id": "5", "comment": "/**\n * Reads all bytes from an input stream into a byte array. The given expected size is used to\n * create an initial byte array, but if the actual number of bytes read from the stream differs,\n * the correct result will be returned anyway.\n */\n", "repo_name": "guava-master/", "id": 4814, "method_signature": "byte[] toByteArray(InputStream, long)", "filename": "ByteStreams.toByteArray.json"}
{"callee_method_names": ["Queue<byte[]>.add", "InputStream.read", "InputStream.read"], "method_name": "ByteStreams.toByteArrayInternal", "method_implementation": "{\n    // Roughly size to match what has been read already. Some file systems, such as procfs, return 0\n    // as their length. These files are very small, so it's wasteful to allocate an 8KB buffer.\n    int initialBufferSize = min(BUFFER_SIZE, max(128, Integer.highestOneBit(totalLen) * 2));\n    // Starting with an 8k buffer, double the size of each successive buffer. Smaller buffers\n    // quadruple in size until they reach 8k, to minimize the number of small reads for longer\n    // streams. Buffers are retained in a deque so that there's no copying between buffers while\n    // reading and so all of the bytes in each new allocated buffer are available for reading from\n    // the stream.\n    for (int bufSize = initialBufferSize; totalLen < MAX_ARRAY_LEN; bufSize = IntMath.saturatedMultiply(bufSize, bufSize < 4096 ? 4 : 2)) {\n        byte[] buf = new byte[min(bufSize, MAX_ARRAY_LEN - totalLen)];\n        bufs.add(buf);\n        int off = 0;\n        while (off < buf.length) {\n            // always OK to fill buf; its size plus the rest of bufs is never more than MAX_ARRAY_LEN\n            int r = in.read(buf, off, buf.length - off);\n            if (r == -1) {\n                return combineBuffers(bufs, totalLen);\n            }\n            off += r;\n            totalLen += r;\n        }\n    }\n    // read MAX_ARRAY_LEN bytes without seeing end of stream\n    if (in.read() == -1) {\n        // oh, there's the end of the stream\n        return combineBuffers(bufs, MAX_ARRAY_LEN);\n    } else {\n        throw new OutOfMemoryError(\"input is too large to fit in a byte array\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a byte array containing the bytes from the buffers already in {@code bufs} (which have\n * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given\n * input stream.\n */\n", "repo_name": "guava-master/", "id": 4813, "method_signature": "byte[] toByteArrayInternal(InputStream, Queue, int)", "filename": "ByteStreams.toByteArrayInternal.json"}
{"callee_method_names": [], "method_name": "ByteStreams.write", "method_implementation": "{\n    checkNotNull(b);\n    checkPositionIndexes(off, off + len, b.length);\n}", "repo_id": "5", "comment": "/**\n * Discards the specified byte array.\n */\n", "repo_name": "guava-master/", "id": 4817, "method_signature": "void write(byte[], int, int)", "filename": "ByteStreams.write.json"}
{"callee_method_names": [], "method_name": "Bytes.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new ByteArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>The returned list maintains the values, but not the identities, of {@code Byte} objects\n * written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for\n * the returned list is unspecified.\n *\n * <p>The returned list is serializable.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4431, "method_signature": "List<Byte> asList(byte[])", "filename": "Bytes.asList.json"}
{"callee_method_names": [], "method_name": "Bytes.concat", "method_implementation": "{\n    int length = 0;\n    for (byte[] array : arrays) {\n        length += array.length;\n    }\n    byte[] result = new byte[length];\n    int pos = 0;\n    for (byte[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new byte[] {a, b}, new byte[] {}, new byte[] {c}} returns the array {@code {a, b, c}}.\n *\n * @param arrays zero or more {@code byte} arrays\n * @return a single array containing all the values from the source arrays, in order\n */\n", "repo_name": "guava-master/", "id": 4428, "method_signature": "byte[] concat(byte[][])", "filename": "Bytes.concat.json"}
{"callee_method_names": [], "method_name": "Bytes.contains", "method_implementation": "{\n    for (byte value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.\n *\n * @param array an array of {@code byte} values, possibly empty\n * @param target a primitive {@code byte} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4424, "method_signature": "boolean contains(byte[], byte)", "filename": "Bytes.contains.json"}
{"callee_method_names": [], "method_name": "Bytes.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4429, "method_signature": "byte[] ensureCapacity(byte[], int, int)", "filename": "Bytes.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Bytes.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4426, "method_signature": "int indexOf(byte[], byte[])", "filename": "Bytes.indexOf.json"}
{"callee_method_names": [], "method_name": "Bytes.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4427, "method_signature": "int lastIndexOf(byte[], byte, int, int)", "filename": "Bytes.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Bytes.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        byte tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Bytes.asList(array).subList(fromIndex, toIndex))}, but is likely to be more\n * efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4432, "method_signature": "void reverse(byte[], int, int)", "filename": "Bytes.reverse.json"}
{"callee_method_names": [], "method_name": "Bytes.rotate", "method_implementation": "{\n    // See Ints.rotate for more details about possible algorithms here.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Bytes.asList(array).subList(fromIndex, toIndex), distance)}, but is somewhat\n * faster.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4433, "method_signature": "void rotate(byte[], int, int, int)", "filename": "Bytes.rotate.json"}
{"callee_method_names": ["Collection<? extends Number>.toArray"], "method_name": "Bytes.toArray", "method_implementation": "{\n    if (collection instanceof ByteArrayAsList) {\n        return ((ByteArrayAsList) collection).toByteArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    byte[] array = new byte[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = ((Number) checkNotNull(boxedArray[i])).byteValue();\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing each value of {@code collection}, converted to a {@code byte} value\n * in the manner of {@link Number#byteValue}.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * @param collection a collection of {@code Number} instances\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n * @since 1.0 (parameter was {@code Collection<Byte>} before 12.0)\n */\n", "repo_name": "guava-master/", "id": 4430, "method_signature": "byte[] toArray(Collection)", "filename": "Bytes.toArray.json"}
{"callee_method_names": ["List<Byte>.subList", "List<Byte>.subList"], "method_name": "BytesTest.testAsList_subList_toArray_roundTrip", "method_implementation": "{\n    byte[] array = { (byte) 0, (byte) 1, (byte) 2, (byte) 3 };\n    List<Byte> list = Bytes.asList(array);\n    assertThat(Bytes.toArray(list.subList(1, 3))).isEqualTo(new byte[] { (byte) 1, (byte) 2 });\n    assertThat(Bytes.toArray(list.subList(2, 2))).isEqualTo(new byte[] {});\n}", "repo_id": "5", "comment": "// This test stems from a real bug found by andrewk\n", "repo_name": "guava-master/", "id": 3552, "method_signature": "void testAsList_subList_toArray_roundTrip()", "filename": "BytesTest.testAsList_subList_toArray_roundTrip.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.build", "method_implementation": "{\n    checkWeightWithWeigher();\n    checkNonLoadingCache();\n    return new LocalCache.LocalManualCache<>(this);\n}", "repo_id": "5", "comment": "/**\n * Builds a cache which does not automatically load values when keys are requested.\n *\n * <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a {@code\n * CacheLoader}.\n *\n * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n * invoked again to create multiple independent caches.\n *\n * @return a cache having the requested features\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4890, "method_signature": "Cache<K1,V1> build()", "filename": "CacheBuilder.build.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.concurrencyLevel", "method_implementation": "{\n    checkState(this.concurrencyLevel == UNSET_INT, \"concurrency level was already set to %s\", this.concurrencyLevel);\n    checkArgument(concurrencyLevel > 0);\n    this.concurrencyLevel = concurrencyLevel;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The\n * table is internally partitioned to try to permit the indicated number of concurrent updates\n * without contention. Because assignment of entries to these partitions is not necessarily\n * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to\n * accommodate as many threads as will ever concurrently modify the table. Using a significantly\n * higher value than you need can waste space and time, and a significantly lower value can lead\n * to thread contention. But overestimates and underestimates within an order of magnitude do not\n * usually have much noticeable impact. A value of one permits only one thread to modify the cache\n * at a time, but since read operations and cache loading computations can proceed concurrently,\n * this still yields higher concurrency than full synchronization.\n *\n * <p>Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\n * value, you should always choose it explicitly.\n *\n * <p>The current implementation uses the concurrency level to create a fixed number of hashtable\n * segments, each governed by its own write lock. The segment lock is taken once for each explicit\n * write, and twice for each cache loading computation (once prior to loading the new value, and\n * once after loading completes). Much internal cache management is performed at the segment\n * granularity. For example, access queues and write queues are kept per segment when they are\n * required by the selected eviction algorithm. As such, when writing unit tests it is not\n * uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction\n * behavior.\n *\n * <p>Note that future implementations may abandon segment locking in favor of more advanced\n * concurrency controls.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive\n * @throws IllegalStateException if a concurrency level was already set\n */\n", "repo_name": "guava-master/", "id": 4875, "method_signature": "CacheBuilder<K,V> concurrencyLevel(int)", "filename": "CacheBuilder.concurrencyLevel.json"}
{"callee_method_names": ["TimeUnit.toNanos"], "method_name": "CacheBuilder.expireAfterAccess", "method_implementation": "{\n    checkState(expireAfterAccessNanos == UNSET_INT, \"expireAfterAccess was already set to %s ns\", expireAfterAccessNanos);\n    checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n    this.expireAfterAccessNanos = unit.toNanos(duration);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies that each entry should be automatically removed from the cache once a fixed duration\n * has elapsed after the entry's creation, the most recent replacement of its value, or its last\n * access. Access time is reset by all cache read and write operations (including {@code\n * Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by {@code\n * containsKey(Object)}, nor by operations on the collection-views of {@link Cache#asMap}. So, for\n * example, iterating through {@code Cache.asMap().entrySet()} does not reset access time for the\n * entries you retrieve.\n *\n * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n * maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be\n * useful in testing, or to disable caching temporarily without a code change.\n *\n * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n * write operations. Expired entries are cleaned up as part of the routine maintenance described\n * in the class javadoc.\n *\n * @param duration the length of time after an entry is last accessed that it should be\n *     automatically removed\n * @param unit the unit that {@code duration} is expressed in\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalArgumentException if {@code duration} is negative\n * @throws IllegalStateException if {@link #expireAfterAccess} was already set\n */\n", "repo_name": "guava-master/", "id": 4883, "method_signature": "CacheBuilder<K,V> expireAfterAccess(long, TimeUnit)", "filename": "CacheBuilder.expireAfterAccess.json"}
{"callee_method_names": ["TimeUnit.toNanos"], "method_name": "CacheBuilder.expireAfterWrite", "method_implementation": "{\n    checkState(expireAfterWriteNanos == UNSET_INT, \"expireAfterWrite was already set to %s ns\", expireAfterWriteNanos);\n    checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n    this.expireAfterWriteNanos = unit.toNanos(duration);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies that each entry should be automatically removed from the cache once a fixed duration\n * has elapsed after the entry's creation, or the most recent replacement of its value.\n *\n * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n * maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be\n * useful in testing, or to disable caching temporarily without a code change.\n *\n * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n * write operations. Expired entries are cleaned up as part of the routine maintenance described\n * in the class javadoc.\n *\n * @param duration the length of time after an entry is created that it should be automatically\n *     removed\n * @param unit the unit that {@code duration} is expressed in\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalArgumentException if {@code duration} is negative\n * @throws IllegalStateException if {@link #expireAfterWrite} was already set\n */\n", "repo_name": "guava-master/", "id": 4882, "method_signature": "CacheBuilder<K,V> expireAfterWrite(long, TimeUnit)", "filename": "CacheBuilder.expireAfterWrite.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.getRemovalListener", "method_implementation": "{\n    return (RemovalListener<K1, V1>) MoreObjects.firstNonNull(removalListener, NullListener.INSTANCE);\n}", "repo_id": "5", "comment": "// Make a safe contravariant cast now so we don't have to do it over and over.\n", "repo_name": "guava-master/", "id": 4887, "method_signature": "RemovalListener<K1,V1> getRemovalListener()", "filename": "CacheBuilder.getRemovalListener.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.initialCapacity", "method_implementation": "{\n    checkState(this.initialCapacity == UNSET_INT, \"initial capacity was already set to %s\", this.initialCapacity);\n    checkArgument(initialCapacity >= 0);\n    this.initialCapacity = initialCapacity;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the minimum total size for the internal hash tables. For example, if the initial capacity\n * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each\n * having a hash table of size eight. Providing a large enough estimate at construction time\n * avoids the need for expensive resizing operations later, but setting this value unnecessarily\n * high wastes memory.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalArgumentException if {@code initialCapacity} is negative\n * @throws IllegalStateException if an initial capacity was already set\n */\n", "repo_name": "guava-master/", "id": 4874, "method_signature": "CacheBuilder<K,V> initialCapacity(int)", "filename": "CacheBuilder.initialCapacity.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.keyEquivalence", "method_implementation": "{\n    checkState(keyEquivalence == null, \"key equivalence was already set to %s\", keyEquivalence);\n    keyEquivalence = checkNotNull(equivalence);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets a custom {@code Equivalence} strategy for comparing keys.\n *\n * <p>By default, the cache uses {@link Equivalence#identity} to determine key equality when\n * {@link #weakKeys} is specified, and {@link Equivalence#equals()} otherwise.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n */\n", "repo_name": "guava-master/", "id": 4872, "method_signature": "CacheBuilder<K,V> keyEquivalence(Equivalence)", "filename": "CacheBuilder.keyEquivalence.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.lenientParsing", "method_implementation": "{\n    strictParsing = false;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Enables lenient parsing. Useful for tests and spec parsing.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n */\n", "repo_name": "guava-master/", "id": 4871, "method_signature": "CacheBuilder<K,V> lenientParsing()", "filename": "CacheBuilder.lenientParsing.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.maximumSize", "method_implementation": "{\n    checkState(this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n    checkState(this.maximumWeight == UNSET_INT, \"maximum weight was already set to %s\", this.maximumWeight);\n    checkState(this.weigher == null, \"maximum size can not be combined with weigher\");\n    checkArgument(maximumSize >= 0, \"maximum size must not be negative\");\n    this.maximumSize = maximumSize;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the maximum number of entries the cache may contain.\n *\n * <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in\n * the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each\n * resulting segment inside the cache <i>independently</i> limits its own size to approximately\n * {@code maximumSize / concurrencyLevel}.\n *\n * <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.\n * For example, the cache may evict an entry because it hasn't been used recently or very often.\n *\n * <p>If {@code maximumSize} is zero, elements will be evicted immediately after being loaded into\n * cache. This can be useful in testing, or to disable caching temporarily.\n *\n * <p>This feature cannot be used in conjunction with {@link #maximumWeight}.\n *\n * @param maximumSize the maximum size of the cache\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalArgumentException if {@code maximumSize} is negative\n * @throws IllegalStateException if a maximum size or weight was already set\n */\n", "repo_name": "guava-master/", "id": 4876, "method_signature": "CacheBuilder<K,V> maximumSize(long)", "filename": "CacheBuilder.maximumSize.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.maximumWeight", "method_implementation": "{\n    checkState(this.maximumWeight == UNSET_INT, \"maximum weight was already set to %s\", this.maximumWeight);\n    checkState(this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n    checkArgument(maximumWeight >= 0, \"maximum weight must not be negative\");\n    this.maximumWeight = maximumWeight;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the maximum weight of entries the cache may contain. Weight is determined using the\n * {@link Weigher} specified with {@link #weigher}, and use of this method requires a\n * corresponding call to {@link #weigher} prior to calling {@link #build}.\n *\n * <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in\n * the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each\n * resulting segment inside the cache <i>independently</i> limits its own weight to approximately\n * {@code maximumWeight / concurrencyLevel}.\n *\n * <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.\n * For example, the cache may evict an entry because it hasn't been used recently or very often.\n *\n * <p>If {@code maximumWeight} is zero, elements will be evicted immediately after being loaded\n * into cache. This can be useful in testing, or to disable caching temporarily.\n *\n * <p>Note that weight is only used to determine whether the cache is over capacity; it has no\n * effect on selecting which entry should be evicted next.\n *\n * <p>This feature cannot be used in conjunction with {@link #maximumSize}.\n *\n * @param maximumWeight the maximum total weight of entries the cache may contain\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalArgumentException if {@code maximumWeight} is negative\n * @throws IllegalStateException if a maximum weight or size was already set\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4877, "method_signature": "CacheBuilder<K,V> maximumWeight(long)", "filename": "CacheBuilder.maximumWeight.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.recordStats", "method_implementation": "{\n    statsCounterSupplier = CACHE_STATS_COUNTER;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this\n * {@link Cache#stats} will return zero for all statistics. Note that recording stats requires\n * bookkeeping to be performed with each operation, and thus imposes a performance penalty on\n * cache operation.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n * @since 12.0 (previously, stats collection was automatic)\n */\n", "repo_name": "guava-master/", "id": 4888, "method_signature": "CacheBuilder<K,V> recordStats()", "filename": "CacheBuilder.recordStats.json"}
{"callee_method_names": ["TimeUnit.toNanos"], "method_name": "CacheBuilder.refreshAfterWrite", "method_implementation": "{\n    checkNotNull(unit);\n    checkState(refreshNanos == UNSET_INT, \"refresh was already set to %s ns\", refreshNanos);\n    checkArgument(duration > 0, \"duration must be positive: %s %s\", duration, unit);\n    this.refreshNanos = unit.toNanos(duration);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies that active entries are eligible for automatic refresh once a fixed duration has\n * elapsed after the entry's creation, or the most recent replacement of its value. The semantics\n * of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling {@link\n * CacheLoader#reload}.\n *\n * <p>As the default implementation of {@link CacheLoader#reload} is synchronous, it is\n * recommended that users of this method override {@link CacheLoader#reload} with an asynchronous\n * implementation; otherwise refreshes will be performed during unrelated cache read and write\n * operations.\n *\n * <p>Currently automatic refreshes are performed when the first stale request for an entry\n * occurs. The request triggering refresh will make a synchronous call to {@link\n * CacheLoader#reload}\n * and immediately return the new value if the returned future is complete, and the old value\n * otherwise.\n *\n * <p><b>Note:</b> <i>all exceptions thrown during refresh will be logged and then swallowed</i>.\n *\n * @param duration the length of time after an entry is created that it should be considered\n *     stale, and thus eligible for refresh\n * @param unit the unit that {@code duration} is expressed in\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalArgumentException if {@code duration} is negative\n * @throws IllegalStateException if {@link #refreshAfterWrite} was already set\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4884, "method_signature": "CacheBuilder<K,V> refreshAfterWrite(long, TimeUnit)", "filename": "CacheBuilder.refreshAfterWrite.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.removalListener", "method_implementation": "{\n    checkState(this.removalListener == null);\n    // safely limiting the kinds of caches this can produce\n    @SuppressWarnings(\"unchecked\")\n    CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n    me.removalListener = checkNotNull(listener);\n    return me;\n}", "repo_id": "5", "comment": "/**\n * Specifies a listener instance that caches should notify each time an entry is removed for any\n * {@linkplain RemovalCause reason}. Each cache created by this builder will invoke this listener\n * as part of the routine maintenance described in the class documentation above.\n *\n * <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache builder\n * reference; instead use the reference this method <i>returns</i>. At runtime, these point to the\n * same instance, but only the returned reference has the correct generic type information to\n * ensure type safety. For best results, use the standard method-chaining idiom illustrated in the\n * class documentation above, configuring a builder and building your cache in a single statement.\n * Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache\n * operation at some <i>undefined</i> point in the future.\n *\n * <p><b>Warning:</b> any exception thrown by {@code listener} will <i>not</i> be propagated to\n * the {@code Cache} user, only logged via a {@link Logger}.\n *\n * @return the cache builder reference that should be used instead of {@code this} for any\n *     remaining configuration and cache building\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalStateException if a removal listener was already set\n */\n", "repo_name": "guava-master/", "id": 4886, "method_signature": "CacheBuilder<K1,V1> removalListener(RemovalListener)", "filename": "CacheBuilder.removalListener.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.softValues", "method_implementation": "{\n    return setValueStrength(Strength.SOFT);\n}", "repo_id": "5", "comment": "/**\n * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n * SoftReference} (by default, strong references are used). Softly-referenced objects will be\n * garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory\n * demand.\n *\n * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain\n * #maximumSize(long) maximum size} instead of using soft references. You should only use this\n * method if you are well familiar with the practical consequences of soft references.\n *\n * <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})\n * comparison to determine equality of values.\n *\n * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},\n * but will never be visible to read or write operations; such entries are cleaned up as part of\n * the routine maintenance described in the class javadoc.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalStateException if the value strength was already set\n */\n", "repo_name": "guava-master/", "id": 4881, "method_signature": "CacheBuilder<K,V> softValues()", "filename": "CacheBuilder.softValues.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.ticker", "method_implementation": "{\n    checkState(this.ticker == null);\n    this.ticker = checkNotNull(ticker);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies a nanosecond-precision time source for this cache. By default, {@link\n * System#nanoTime} is used.\n *\n * <p>The primary intent of this method is to facilitate testing of caches with a fake or mock\n * time source.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalStateException if a ticker was already set\n */\n", "repo_name": "guava-master/", "id": 4885, "method_signature": "CacheBuilder<K,V> ticker(Ticker)", "filename": "CacheBuilder.ticker.json"}
{"callee_method_names": ["java.time.Duration.toNanos", "java.time.Duration.isNegative"], "method_name": "CacheBuilder.toNanosSaturated", "method_implementation": "{\n    // Using a try/catch seems lazy, but the catch block will rarely get invoked (except for\n    // durations longer than approximately +/- 292 years).\n    try {\n        return duration.toNanos();\n    } catch (ArithmeticException tooBig) {\n        return duration.isNegative() ? Long.MIN_VALUE : Long.MAX_VALUE;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the number of nanoseconds of the given duration without throwing or overflowing.\n *\n * <p>Instead of throwing {@link ArithmeticException}, this method silently saturates to either\n * {@link Long#MAX_VALUE} or {@link Long#MIN_VALUE}. This behavior can be useful when decomposing\n * a duration in order to call a legacy API which requires a {@code long, TimeUnit} pair.\n */\n", "repo_name": "guava-master/", "id": 1484, "method_signature": "long toNanosSaturated(java.time.Duration)", "filename": "CacheBuilder.toNanosSaturated.json"}
{"callee_method_names": ["MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "Strength.toString", "MoreObjects.ToStringHelper.add", "Strength.toString", "MoreObjects.ToStringHelper.addValue", "MoreObjects.ToStringHelper.addValue", "MoreObjects.ToStringHelper.addValue", "MoreObjects.ToStringHelper.toString"], "method_name": "CacheBuilder.toString", "method_implementation": "{\n    MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n    if (initialCapacity != UNSET_INT) {\n        s.add(\"initialCapacity\", initialCapacity);\n    }\n    if (concurrencyLevel != UNSET_INT) {\n        s.add(\"concurrencyLevel\", concurrencyLevel);\n    }\n    if (maximumSize != UNSET_INT) {\n        s.add(\"maximumSize\", maximumSize);\n    }\n    if (maximumWeight != UNSET_INT) {\n        s.add(\"maximumWeight\", maximumWeight);\n    }\n    if (expireAfterWriteNanos != UNSET_INT) {\n        s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\n    }\n    if (expireAfterAccessNanos != UNSET_INT) {\n        s.add(\"expireAfterAccess\", expireAfterAccessNanos + \"ns\");\n    }\n    if (keyStrength != null) {\n        s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n    }\n    if (valueStrength != null) {\n        s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n    }\n    if (keyEquivalence != null) {\n        s.addValue(\"keyEquivalence\");\n    }\n    if (valueEquivalence != null) {\n        s.addValue(\"valueEquivalence\");\n    }\n    if (removalListener != null) {\n        s.addValue(\"removalListener\");\n    }\n    return s.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation for this CacheBuilder instance. The exact form of the returned\n * string is not specified.\n */\n", "repo_name": "guava-master/", "id": 4891, "method_signature": "String toString()", "filename": "CacheBuilder.toString.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.valueEquivalence", "method_implementation": "{\n    checkState(valueEquivalence == null, \"value equivalence was already set to %s\", valueEquivalence);\n    this.valueEquivalence = checkNotNull(equivalence);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets a custom {@code Equivalence} strategy for comparing values.\n *\n * <p>By default, the cache uses {@link Equivalence#identity} to determine value equality when\n * {@link #weakValues} or {@link #softValues} is specified, and {@link Equivalence#equals()}\n * otherwise.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n */\n", "repo_name": "guava-master/", "id": 4873, "method_signature": "CacheBuilder<K,V> valueEquivalence(Equivalence)", "filename": "CacheBuilder.valueEquivalence.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.weakKeys", "method_implementation": "{\n    return setKeyStrength(Strength.WEAK);\n}", "repo_id": "5", "comment": "/**\n * Specifies that each key (not value) stored in the cache should be wrapped in a {@link\n * WeakReference} (by default, strong references are used).\n *\n * <p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})\n * comparison to determine equality of keys. Its {@link Cache#asMap} view will therefore\n * technically violate the {@link Map} specification (in the same way that {@link IdentityHashMap}\n * does).\n *\n * <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size}, but\n * will never be visible to read or write operations; such entries are cleaned up as part of the\n * routine maintenance described in the class javadoc.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalStateException if the key strength was already set\n */\n", "repo_name": "guava-master/", "id": 4879, "method_signature": "CacheBuilder<K,V> weakKeys()", "filename": "CacheBuilder.weakKeys.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.weakValues", "method_implementation": "{\n    return setValueStrength(Strength.WEAK);\n}", "repo_id": "5", "comment": "/**\n * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n * WeakReference} (by default, strong references are used).\n *\n * <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor\n * candidate for caching; consider {@link #softValues} instead.\n *\n * <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})\n * comparison to determine equality of values.\n *\n * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},\n * but will never be visible to read or write operations; such entries are cleaned up as part of\n * the routine maintenance described in the class javadoc.\n *\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalStateException if the value strength was already set\n */\n", "repo_name": "guava-master/", "id": 4880, "method_signature": "CacheBuilder<K,V> weakValues()", "filename": "CacheBuilder.weakValues.json"}
{"callee_method_names": [], "method_name": "CacheBuilder.weigher", "method_implementation": "{\n    checkState(this.weigher == null);\n    if (strictParsing) {\n        checkState(this.maximumSize == UNSET_INT, \"weigher can not be combined with maximum size (%s provided)\", this.maximumSize);\n    }\n    // safely limiting the kinds of caches this can produce\n    @SuppressWarnings(\"unchecked\")\n    CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n    me.weigher = checkNotNull(weigher);\n    return me;\n}", "repo_id": "5", "comment": "/**\n * Specifies the weigher to use in determining the weight of entries. Entry weight is taken into\n * consideration by {@link #maximumWeight(long)} when determining which entries to evict, and use\n * of this method requires a corresponding call to {@link #maximumWeight(long)} prior to calling\n * {@link #build}. Weights are measured and recorded when entries are inserted into the cache, and\n * are thus effectively static during the lifetime of a cache entry.\n *\n * <p>When the weight of an entry is zero it will not be considered for size-based eviction\n * (though it still may be evicted by other means).\n *\n * <p><b>Important note:</b> Instead of returning <em>this</em> as a {@code CacheBuilder}\n * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the\n * original reference or the returned reference may be used to complete configuration and build\n * the cache, but only the \"generic\" one is type-safe. That is, it will properly prevent you from\n * building caches whose key or value types are incompatible with the types accepted by the\n * weigher already provided; the {@code CacheBuilder} type cannot do this. For best results,\n * simply use the standard method-chaining idiom, as illustrated in the documentation at top,\n * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.\n *\n * <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build a\n * cache whose key or value type is incompatible with the weigher, you will likely experience a\n * {@link ClassCastException} at some <i>undefined</i> point in the future.\n *\n * @param weigher the weigher to use in calculating the weight of cache entries\n * @return this {@code CacheBuilder} instance (for chaining)\n * @throws IllegalStateException if a weigher was already set or {@link #maximumSize(long)} was\n *     previously called\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4878, "method_signature": "CacheBuilder<K1,V1> weigher(Weigher)", "filename": "CacheBuilder.weigher.json"}
{"callee_method_names": ["List<Set<Optional<?>>>.add"], "method_name": "CacheBuilderFactory.buildCartesianProduct", "method_implementation": "{\n    List<Set<Optional<?>>> optionalSets = Lists.newArrayListWithExpectedSize(sets.length);\n    for (Set<?> set : sets) {\n        Set<Optional<?>> optionalSet = Sets.newLinkedHashSet(Iterables.transform(set, NULLABLE_TO_OPTIONAL));\n        optionalSets.add(optionalSet);\n    }\n    Set<List<Optional<?>>> cartesianProduct = Sets.cartesianProduct(optionalSets);\n    return Iterables.transform(cartesianProduct, new Function<List<Optional<?>>, List<Object>>() {\n\n        @Override\n        public List<Object> apply(List<Optional<?>> objs) {\n            return Lists.transform(objs, OPTIONAL_TO_NULLABLE);\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Sets.cartesianProduct doesn't allow sets that contain null, but we want null to mean \"don't\n * call the associated CacheBuilder method\" - that is, get the default CacheBuilder behavior. This\n * method wraps the elements in the input sets (which may contain null) as Optionals, calls\n * Sets.cartesianProduct with those, then transforms the result to unwrap the Optionals.\n */\n", "repo_name": "guava-master/", "id": 3665, "method_signature": "Iterable<List<Object>> buildCartesianProduct(Set<?>[])", "filename": "CacheBuilderFactory.buildCartesianProduct.json"}
{"callee_method_ids": [5001, 5001], "callee_method_names": ["String.isEmpty", "Splitter.split", "Splitter.split", "List<String>.isEmpty", "List<String>.size", "List<String>.get", "ImmutableMap<String, ValueParser>.get", "List<String>.size", "List<String>.get", "ValueParser.parse"], "method_name": "CacheBuilderSpec.parse", "method_implementation": "{\n    CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);\n    if (!cacheBuilderSpecification.isEmpty()) {\n        for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {\n            List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));\n            checkArgument(!keyAndValue.isEmpty(), \"blank key-value pair\");\n            checkArgument(keyAndValue.size() <= 2, \"key-value pair %s with more than one equals sign\", keyValuePair);\n            // Find the ValueParser for the current key.\n            String key = keyAndValue.get(0);\n            ValueParser valueParser = VALUE_PARSERS.get(key);\n            checkArgument(valueParser != null, \"unknown key %s\", key);\n            String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);\n            valueParser.parse(spec, key, value);\n        }\n    }\n    return spec;\n}", "repo_id": "5", "comment": "/**\n * Creates a CacheBuilderSpec from a string.\n *\n * @param cacheBuilderSpecification the string form\n */\n", "repo_name": "guava-master/", "id": 4892, "method_signature": "CacheBuilderSpec parse(String)", "filename": "CacheBuilderSpec.parse.json"}
{"callee_method_names": ["CacheBuilder<Object, Object>.initialCapacity", "CacheBuilder<Object, Object>.maximumSize", "CacheBuilder<Object, Object>.maximumWeight", "CacheBuilder<Object, Object>.concurrencyLevel", "CacheBuilder<Object, Object>.weakKeys", "CacheBuilder<Object, Object>.softValues", "CacheBuilder<Object, Object>.weakValues", "CacheBuilder<Object, Object>.recordStats", "CacheBuilder<Object, Object>.expireAfterWrite", "CacheBuilder<Object, Object>.expireAfterAccess", "CacheBuilder<Object, Object>.refreshAfterWrite"], "method_name": "CacheBuilderSpec.toCacheBuilder", "method_implementation": "{\n    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();\n    if (initialCapacity != null) {\n        builder.initialCapacity(initialCapacity);\n    }\n    if (maximumSize != null) {\n        builder.maximumSize(maximumSize);\n    }\n    if (maximumWeight != null) {\n        builder.maximumWeight(maximumWeight);\n    }\n    if (concurrencyLevel != null) {\n        builder.concurrencyLevel(concurrencyLevel);\n    }\n    if (keyStrength != null) {\n        switch(keyStrength) {\n            case WEAK:\n                builder.weakKeys();\n                break;\n            default:\n                throw new AssertionError();\n        }\n    }\n    if (valueStrength != null) {\n        switch(valueStrength) {\n            case SOFT:\n                builder.softValues();\n                break;\n            case WEAK:\n                builder.weakValues();\n                break;\n            default:\n                throw new AssertionError();\n        }\n    }\n    if (recordStats != null && recordStats) {\n        builder.recordStats();\n    }\n    if (writeExpirationTimeUnit != null) {\n        builder.expireAfterWrite(writeExpirationDuration, writeExpirationTimeUnit);\n    }\n    if (accessExpirationTimeUnit != null) {\n        builder.expireAfterAccess(accessExpirationDuration, accessExpirationTimeUnit);\n    }\n    if (refreshTimeUnit != null) {\n        builder.refreshAfterWrite(refreshDuration, refreshTimeUnit);\n    }\n    return builder;\n}", "repo_id": "5", "comment": "/**\n * Returns a CacheBuilder configured according to this instance's specification.\n */\n", "repo_name": "guava-master/", "id": 4893, "method_signature": "CacheBuilder<Object,Object> toCacheBuilder()", "filename": "CacheBuilderSpec.toCacheBuilder.json"}
{"callee_method_names": ["LoadingCache<String, String>.getUnchecked", "Set<String>.add", "AtomicBoolean.set", "ExecutorService.submit", "LoadingCache<String, String>.getUnchecked", "AtomicInteger.incrementAndGet", "CountDownLatch.countDown", "Set<String>.add", "CountDownLatch.countDown", "AtomicInteger.get", "LoadingCache<String, String>.invalidateAll", "CountDownLatch.await", "Map<String, String>.put", "RemovalNotification<K, V>.getKey", "RemovalNotification<K, V>.getValue", "RemovalNotification<K, V>.getKey", "RemovalNotification<K, V>.getValue", "Map<String, String>.get", "LoadingCache<String, String>.asMap", "Map<String, String>.keySet", "LoadingCache<String, String>.asMap", "Map<String, String>.keySet"], "method_name": "CacheBuilderTest.testRemovalNotification_clear_basher", "method_implementation": "{\n    // If a clear() happens close to the end of computation, one of two things should happen:\n    // - computation ends first: the removal listener is called, and the cache does not contain the\n    //   key/value pair\n    // - clear() happens first: the removal listener is not called, and the cache contains the pair\n    AtomicBoolean computationShouldWait = new AtomicBoolean();\n    CountDownLatch computationLatch = new CountDownLatch(1);\n    QueuingRemovalListener<String, String> listener = queuingRemovalListener();\n    final LoadingCache<String, String> cache = CacheBuilder.newBuilder().removalListener(listener).concurrencyLevel(20).build(new DelayingIdentityLoader<String>(computationShouldWait, computationLatch));\n    int nThreads = 100;\n    int nTasks = 1000;\n    int nSeededEntries = 100;\n    Set<String> expectedKeys = Sets.newHashSetWithExpectedSize(nTasks + nSeededEntries);\n    // seed the map, so its segments have a count>0; otherwise, clear() won't visit the in-progress\n    // entries\n    for (int i = 0; i < nSeededEntries; i++) {\n        String s = \"b\" + i;\n        cache.getUnchecked(s);\n        expectedKeys.add(s);\n    }\n    computationShouldWait.set(true);\n    final AtomicInteger computedCount = new AtomicInteger();\n    ExecutorService threadPool = Executors.newFixedThreadPool(nThreads);\n    final CountDownLatch tasksFinished = new CountDownLatch(nTasks);\n    for (int i = 0; i < nTasks; i++) {\n        final String s = \"a\" + i;\n        // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n        @SuppressWarnings(\"unused\")\n        Future<?> possiblyIgnoredError = threadPool.submit(new Runnable() {\n\n            @Override\n            public void run() {\n                cache.getUnchecked(s);\n                computedCount.incrementAndGet();\n                tasksFinished.countDown();\n            }\n        });\n        expectedKeys.add(s);\n    }\n    computationLatch.countDown();\n    // let some computations complete\n    while (computedCount.get() < nThreads) {\n        Thread.yield();\n    }\n    cache.invalidateAll();\n    tasksFinished.await();\n    // Check all of the removal notifications we received: they should have had correctly-associated\n    // keys and values. (An earlier bug saw removal notifications for in-progress computations,\n    // which had real keys with null values.)\n    Map<String, String> removalNotifications = Maps.newHashMap();\n    for (RemovalNotification<String, String> notification : listener) {\n        removalNotifications.put(notification.getKey(), notification.getValue());\n        assertEquals(\"Unexpected key/value pair passed to removalListener\", notification.getKey(), notification.getValue());\n    }\n    // All of the seed values should have been visible, so we should have gotten removal\n    // notifications for all of them.\n    for (int i = 0; i < nSeededEntries; i++) {\n        assertEquals(\"b\" + i, removalNotifications.get(\"b\" + i));\n    }\n    // Each of the values added to the map should either still be there, or have seen a removal\n    // notification.\n    assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));\n    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());\n}", "repo_id": "5", "comment": "/**\n * This is a less carefully-controlled version of {@link #testRemovalNotification_clear} - this is\n * a black-box test that tries to create lots of different thread-interleavings, and asserts that\n * each computation is affected by a call to {@code clear()} (and therefore gets passed to the\n * removal listener), or else is not affected by the {@code clear()} (and therefore exists in the\n * cache afterward).\n */\n", "repo_name": "guava-master/", "id": 3657, "method_signature": "void testRemovalNotification_clear_basher()", "filename": "CacheBuilderTest.testRemovalNotification_clear_basher.json"}
{"callee_method_names": ["Random.nextInt", "AtomicInteger.incrementAndGet", "AtomicInteger.incrementAndGet", "AtomicInteger.incrementAndGet", "AtomicInteger.incrementAndGet", "ExecutorService.submit", "LoadingCache<String, String>.getUnchecked", "Random.nextInt", "ExecutorService.shutdown", "ExecutorService.awaitTermination", "RemovalNotification<K, V>.getKey", "RemovalNotification<K, V>.getValue", "LoadingCache<String, String>.stats", "QueuingRemovalListener<String, String>.size", "CacheStats.evictionCount", "AtomicInteger.get", "CacheStats.loadSuccessCount", "AtomicInteger.get", "AtomicInteger.get", "CacheStats.loadExceptionCount", "AtomicInteger.get", "LoadingCache<String, String>.size", "QueuingRemovalListener<String, String>.size"], "method_name": "CacheBuilderTest.testRemovalNotification_get_basher", "method_implementation": "{\n    int nTasks = 1000;\n    int nThreads = 100;\n    final int getsPerTask = 1000;\n    final int nUniqueKeys = 10000;\n    // Randoms.insecureRandom();\n    final Random random = new Random();\n    QueuingRemovalListener<String, String> removalListener = queuingRemovalListener();\n    final AtomicInteger computeCount = new AtomicInteger();\n    final AtomicInteger exceptionCount = new AtomicInteger();\n    final AtomicInteger computeNullCount = new AtomicInteger();\n    CacheLoader<String, String> countingIdentityLoader = new CacheLoader<String, String>() {\n\n        @Override\n        public String load(String key) throws InterruptedException {\n            int behavior = random.nextInt(4);\n            if (behavior == 0) {\n                // throw an exception\n                exceptionCount.incrementAndGet();\n                throw new RuntimeException(\"fake exception for test\");\n            } else if (behavior == 1) {\n                // return null\n                computeNullCount.incrementAndGet();\n                return null;\n            } else if (behavior == 2) {\n                // slight delay before returning\n                Thread.sleep(5);\n                computeCount.incrementAndGet();\n                return key;\n            } else {\n                computeCount.incrementAndGet();\n                return key;\n            }\n        }\n    };\n    final LoadingCache<String, String> cache = CacheBuilder.newBuilder().recordStats().concurrencyLevel(2).expireAfterWrite(100, MILLISECONDS).removalListener(removalListener).maximumSize(5000).build(countingIdentityLoader);\n    ExecutorService threadPool = Executors.newFixedThreadPool(nThreads);\n    for (int i = 0; i < nTasks; i++) {\n        // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n        @SuppressWarnings(\"unused\")\n        Future<?> possiblyIgnoredError = threadPool.submit(new Runnable() {\n\n            @Override\n            public void run() {\n                for (int j = 0; j < getsPerTask; j++) {\n                    try {\n                        cache.getUnchecked(\"key\" + random.nextInt(nUniqueKeys));\n                    } catch (RuntimeException e) {\n                    }\n                }\n            }\n        });\n    }\n    threadPool.shutdown();\n    threadPool.awaitTermination(300, SECONDS);\n    // Since we're not doing any more cache operations, and the cache only expires/evicts when doing\n    // other operations, the cache and the removal queue won't change from this point on.\n    // Verify that each received removal notification was valid\n    for (RemovalNotification<String, String> notification : removalListener) {\n        assertEquals(\"Invalid removal notification\", notification.getKey(), notification.getValue());\n    }\n    CacheStats stats = cache.stats();\n    assertEquals(removalListener.size(), stats.evictionCount());\n    assertEquals(computeCount.get(), stats.loadSuccessCount());\n    assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());\n    // each computed value is still in the cache, or was passed to the removal listener\n    assertEquals(computeCount.get(), cache.size() + removalListener.size());\n}", "repo_id": "5", "comment": "/**\n * Calls get() repeatedly from many different threads, and tests that all of the removed entries\n * (removed because of size limits or expiration) trigger appropriate removal notifications.\n */\n", "repo_name": "guava-master/", "id": 3658, "method_signature": "void testRemovalNotification_get_basher()", "filename": "CacheBuilderTest.testRemovalNotification_get_basher.json"}
{"callee_method_names": ["LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount", "LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount", "LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount", "LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount", "LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount"], "method_name": "CacheEvictionTest.testEviction_maxWeight_entryTooBig", "method_implementation": "{\n    CountingRemovalListener<Integer, Integer> removalListener = countingRemovalListener();\n    IdentityLoader<Integer> loader = identityLoader();\n    LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().concurrencyLevel(1).maximumWeight(4).weigher(intValueWeigher()).removalListener(removalListener).build(loader);\n    // caches 2\n    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n    assertThat(cache.asMap().keySet()).containsExactly(2);\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(0);\n    // caches 3, evicts 2\n    assertThat(cache.getUnchecked(3)).isEqualTo(3);\n    assertThat(cache.asMap().keySet()).containsExactly(3);\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(1);\n    // doesn't cache 5, doesn't evict\n    assertThat(cache.getUnchecked(5)).isEqualTo(5);\n    assertThat(cache.asMap().keySet()).containsExactly(3);\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(2);\n    // caches 1, evicts nothing\n    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n    assertThat(cache.asMap().keySet()).containsExactly(3, 1);\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(2);\n    // caches 4, evicts 1 and 3\n    assertThat(cache.getUnchecked(4)).isEqualTo(4);\n    assertThat(cache.asMap().keySet()).containsExactly(4);\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(4);\n    // Should we pepper more of these calls throughout the above? Where?\n    CacheTesting.checkValidState(cache);\n}", "repo_id": "5", "comment": "/**\n * Tests that when a single entry exceeds the segment's max weight, the new entry is immediately\n * evicted and nothing else.\n */\n", "repo_name": "guava-master/", "id": 3656, "method_signature": "void testEviction_maxWeight_entryTooBig()", "filename": "CacheEvictionTest.testEviction_maxWeight_entryTooBig.json"}
{"callee_method_names": ["LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount", "LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount", "LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount", "LoadingCache<Integer, Integer>.getUnchecked", "LoadingCache<Integer, Integer>.asMap", "CountingRemovalListener<Integer, Integer>.getCount"], "method_name": "CacheEvictionTest.testEviction_maxWeight_zero", "method_implementation": "{\n    CountingRemovalListener<Integer, Integer> removalListener = countingRemovalListener();\n    IdentityLoader<Integer> loader = identityLoader();\n    // Even numbers are free, odd are too expensive\n    Weigher<Integer, Integer> evensOnly = new Weigher<Integer, Integer>() {\n\n        @Override\n        public int weigh(Integer k, Integer v) {\n            return k % 2;\n        }\n    };\n    LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().concurrencyLevel(1).maximumWeight(0).weigher(evensOnly).removalListener(removalListener).build(loader);\n    // 1 won't be cached\n    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n    assertThat(cache.asMap().keySet()).isEmpty();\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(1);\n    // 2 will be cached\n    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n    assertThat(cache.asMap().keySet()).containsExactly(2);\n    CacheTesting.processPendingNotifications(cache);\n    CacheTesting.checkValidState(cache);\n    assertThat(removalListener.getCount()).isEqualTo(1);\n    // 4 will be cached\n    assertThat(cache.getUnchecked(4)).isEqualTo(4);\n    assertThat(cache.asMap().keySet()).containsExactly(2, 4);\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(1);\n    // 5 won't be cached, won't dump cache\n    assertThat(cache.getUnchecked(5)).isEqualTo(5);\n    assertThat(cache.asMap().keySet()).containsExactly(2, 4);\n    CacheTesting.processPendingNotifications(cache);\n    assertThat(removalListener.getCount()).isEqualTo(2);\n    // Should we pepper more of these calls throughout the above? Where?\n    CacheTesting.checkValidState(cache);\n}", "repo_id": "5", "comment": "/**\n * With an unlimited-size cache with maxWeight of 0, entries weighing 0 should still be cached.\n * Entries with positive weight should not be cached (nor dump existing cache).\n */\n", "repo_name": "guava-master/", "id": 3655, "method_signature": "void testEviction_maxWeight_zero()", "filename": "CacheEvictionTest.testEviction_maxWeight_zero.json"}
{"callee_method_names": ["CacheLoader<K,V>.load", "CacheLoader<K,V>.reload", "Executor.execute", "CacheLoader<K,V>.loadAll"], "method_name": "CacheLoader.asyncReloading", "method_implementation": "{\n    checkNotNull(loader);\n    checkNotNull(executor);\n    return new CacheLoader<K, V>() {\n\n        @Override\n        public V load(K key) throws Exception {\n            return loader.load(key);\n        }\n\n        @Override\n        public ListenableFuture<V> reload(final K key, final V oldValue) {\n            ListenableFutureTask<V> task = ListenableFutureTask.create(() -> loader.reload(key, oldValue).get());\n            executor.execute(task);\n            return task;\n        }\n\n        @Override\n        public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n            return loader.loadAll(keys);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code CacheLoader} which wraps {@code loader}, executing calls to {@link\n * CacheLoader#reload} using {@code executor}.\n *\n * <p>This method is useful only when {@code loader.reload} has a synchronous implementation, such\n * as {@linkplain #reload the default implementation}.\n *\n * @since 17.0\n */\n", "repo_name": "guava-master/", "id": 4863, "method_signature": "CacheLoader<K,V> asyncReloading(CacheLoader, Executor)", "filename": "CacheLoader.asyncReloading.json"}
{"callee_method_names": [], "method_name": "CacheLoader.loadAll", "method_implementation": "{\n    // This will be caught by getAll(), causing it to fall back to multiple calls to\n    // LoadingCache.get\n    throw new UnsupportedLoadingOperationException();\n}", "repo_id": "5", "comment": "/**\n * Computes or retrieves the values corresponding to {@code keys}. This method is called by {@link\n * LoadingCache#getAll}.\n *\n * <p>If the returned map doesn't contain all requested {@code keys} then the entries it does\n * contain will be cached, but {@code getAll} will throw an exception. If the returned map\n * contains extra keys not present in {@code keys} then all returned entries will be cached, but\n * only the entries for {@code keys} will be returned from {@code getAll}.\n *\n * <p>This method should be overridden when bulk retrieval is significantly more efficient than\n * many individual lookups. Note that {@link LoadingCache#getAll} will defer to individual calls\n * to {@link LoadingCache#get} if this method is not overridden.\n *\n * @param keys the unique, non-null keys whose values should be loaded\n * @return a map from each key in {@code keys} to the value associated with that key; <b>may not\n *     contain null values</b>\n * @throws Exception if unable to load the result\n * @throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n *     treated like any other {@code Exception} in all respects except that, when it is caught,\n *     the thread's interrupt status is set\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4862, "method_signature": "Map<K,V> loadAll(Iterable)", "filename": "CacheLoader.loadAll.json"}
{"callee_method_names": [], "method_name": "CacheLoader.reload", "method_implementation": "{\n    checkNotNull(key);\n    checkNotNull(oldValue);\n    return Futures.immediateFuture(load(key));\n}", "repo_id": "5", "comment": "/**\n * Computes or retrieves a replacement value corresponding to an already-cached {@code key}. This\n * method is called when an existing cache entry is refreshed by {@link\n * CacheBuilder#refreshAfterWrite}, or through a call to {@link LoadingCache#refresh}.\n *\n * <p>This implementation synchronously delegates to {@link #load}. It is recommended that it be\n * overridden with an asynchronous implementation when using {@link\n * CacheBuilder#refreshAfterWrite}.\n *\n * <p><b>Note:</b> <i>all exceptions thrown by this method will be logged and then swallowed</i>.\n *\n * @param key the non-null key whose value should be loaded\n * @param oldValue the non-null old value corresponding to {@code key}\n * @return the future new value associated with {@code key}; <b>must not be null, must not return\n *     null</b>\n * @throws Exception if unable to reload the result\n * @throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n *     treated like any other {@code Exception} in all respects except that, when it is caught,\n *     the thread's interrupt status is set\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4861, "method_signature": "ListenableFuture<V> reload(K, V)", "filename": "CacheLoader.reload.json"}
{"callee_method_names": ["CountDownLatch.countDown", "LoadingCache<K,?>.get", "LoadingCache<K,?>.getUnchecked", "LoadingCache<K,?>.refresh", "LoadingCache<K,?>.get", "AtomicReferenceArray<Object>.set", "AtomicReferenceArray<Object>.set", "CountDownLatch.countDown", "Thread.start", "Thread.isAlive", "Thread.getState", "CountDownLatch.countDown", "CountDownLatch.await", "List<Object>.add", "AtomicReferenceArray<Object>.get"], "method_name": "CacheLoadingTest.doConcurrentGet", "method_implementation": "{\n    final AtomicReferenceArray<Object> result = new AtomicReferenceArray<>(nThreads);\n    final CountDownLatch gettersComplete = new CountDownLatch(nThreads);\n    for (int i = 0; i < nThreads; i++) {\n        final int index = i;\n        Thread thread = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                gettersStartedSignal.countDown();\n                Object value = null;\n                try {\n                    int mod = index % 3;\n                    if (mod == 0) {\n                        value = cache.get(key);\n                    } else if (mod == 1) {\n                        value = cache.getUnchecked(key);\n                    } else {\n                        cache.refresh(key);\n                        value = cache.get(key);\n                    }\n                    result.set(index, value);\n                } catch (Throwable t) {\n                    result.set(index, t);\n                }\n                gettersComplete.countDown();\n            }\n        });\n        thread.start();\n        // we want to wait until each thread is WAITING - one thread waiting inside CacheLoader.load\n        // (in startSignal.await()), and the others waiting for that thread's result.\n        while (thread.isAlive() && thread.getState() != Thread.State.WAITING) {\n            Thread.yield();\n        }\n    }\n    gettersStartedSignal.countDown();\n    gettersComplete.await();\n    List<Object> resultList = Lists.newArrayListWithExpectedSize(nThreads);\n    for (int i = 0; i < nThreads; i++) {\n        resultList.add(result.get(i));\n    }\n    return resultList;\n}", "repo_id": "5", "comment": "/**\n * Test-helper method that performs {@code nThreads} concurrent calls to {@code cache.get(key)} or\n * {@code cache.getUnchecked(key)}, and returns a List containing each of the results. The result\n * for any given call to {@code cache.get} or {@code cache.getUnchecked} is the value returned, or\n * the exception thrown.\n *\n * <p>As we iterate from {@code 0} to {@code nThreads}, threads with an even index will call\n * {@code getUnchecked}, and threads with an odd index will call {@code get}. If the cache throws\n * exceptions, this difference may be visible in the returned List.\n */\n", "repo_name": "guava-master/", "id": 3671, "method_signature": "List<Object> doConcurrentGet(LoadingCache, K, int, CountDownLatch)", "filename": "CacheLoadingTest.doConcurrentGet.json"}
{"callee_method_names": ["AtomicInteger.incrementAndGet", "CountDownLatch.countDown", "CountDownLatch.await", "LoadingCache<String, String>.asMap", "LoadingCache<String, String>.refresh", "CountDownLatch.countDown", "CountDownLatch.await", "CountDownLatch.countDown", "AtomicReferenceArray<String>.set", "LoadingCache<String, String>.getUnchecked", "CountDownLatch.countDown", "CountDownLatch.await", "CountDownLatch.countDown", "AtomicReferenceArray<String>.set", "LoadingCache<String, String>.getUnchecked", "CountDownLatch.countDown", "CountDownLatch.await", "CountDownLatch.countDown", "CountDownLatch.await", "AtomicInteger.get", "AtomicReferenceArray<String>.get", "AtomicReferenceArray<String>.get", "LoadingCache<String, String>.getUnchecked"], "method_name": "CacheLoadingTest.ignoreTestExpandDuringRefresh", "method_implementation": "{\n    final AtomicInteger callCount = new AtomicInteger();\n    // tells the computing thread when to start computing\n    final CountDownLatch computeSignal = new CountDownLatch(1);\n    // tells the main thread when computation is pending\n    final CountDownLatch secondSignal = new CountDownLatch(1);\n    // tells the main thread when the second get has started\n    final CountDownLatch thirdSignal = new CountDownLatch(1);\n    // tells the main thread when the third get has started\n    final CountDownLatch fourthSignal = new CountDownLatch(1);\n    // tells the test when all gets have returned\n    final CountDownLatch doneSignal = new CountDownLatch(3);\n    final String suffix = \"Suffix\";\n    CacheLoader<String, String> computeFunction = new CacheLoader<String, String>() {\n\n        @Override\n        public String load(String key) throws InterruptedException {\n            callCount.incrementAndGet();\n            secondSignal.countDown();\n            computeSignal.await();\n            return key + suffix;\n        }\n    };\n    final AtomicReferenceArray<String> result = new AtomicReferenceArray<>(2);\n    final LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);\n    final String key = \"bar\";\n    cache.asMap().put(key, key);\n    // start computing thread\n    new Thread() {\n\n        @Override\n        public void run() {\n            cache.refresh(key);\n            doneSignal.countDown();\n        }\n    }.start();\n    // wait for computation to start\n    secondSignal.await();\n    checkNothingLogged();\n    // start waiting thread\n    new Thread() {\n\n        @Override\n        public void run() {\n            thirdSignal.countDown();\n            result.set(0, cache.getUnchecked(key));\n            doneSignal.countDown();\n        }\n    }.start();\n    // give the second get a chance to run; it is okay for this to be racy\n    // as the end result should be the same either way\n    thirdSignal.await();\n    Thread.yield();\n    // Expand!\n    CacheTesting.forceExpandSegment(cache, key);\n    // start another waiting thread\n    new Thread() {\n\n        @Override\n        public void run() {\n            fourthSignal.countDown();\n            result.set(1, cache.getUnchecked(key));\n            doneSignal.countDown();\n        }\n    }.start();\n    // give the third get a chance to run; it is okay for this to be racy\n    // as the end result should be the same either way\n    fourthSignal.await();\n    Thread.yield();\n    // let computation finish\n    computeSignal.countDown();\n    doneSignal.await();\n    assertTrue(callCount.get() == 1);\n    assertEquals(key, result.get(0));\n    assertEquals(key, result.get(1));\n    assertEquals(key + suffix, cache.getUnchecked(key));\n}", "repo_id": "5", "comment": "// Test ignored because it is extremely flaky in CI builds\n", "repo_name": "guava-master/", "id": 3672, "method_signature": "void ignoreTestExpandDuringRefresh()", "filename": "CacheLoadingTest.ignoreTestExpandDuringRefresh.json"}
{"callee_method_names": ["CacheBuilder<Object,Object>.build", "AtomicInteger.incrementAndGet", "CountDownLatch.await", "AtomicInteger.get", "List<Object>.get", "List<Object>.get", "List<Object>.get", "List<Object>.get", "LoadingCache<String, String>.getUnchecked", "AtomicInteger.get"], "method_name": "CacheLoadingTest.testConcurrentLoadingCheckedException", "method_implementation": "{\n    int count = 10;\n    final AtomicInteger callCount = new AtomicInteger();\n    final CountDownLatch startSignal = new CountDownLatch(count + 1);\n    final IOException e = new IOException();\n    LoadingCache<String, String> cache = builder.build(new CacheLoader<String, String>() {\n\n        @Override\n        public String load(String key) throws IOException, InterruptedException {\n            callCount.incrementAndGet();\n            startSignal.await();\n            throw e;\n        }\n    });\n    List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n    assertEquals(1, callCount.get());\n    for (int i = 0; i < count; i++) {\n        // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),\n        // we should get an ExecutionException; if we call getUnchecked(), we should get an\n        // UncheckedExecutionException.\n        int mod = i % 3;\n        if (mod == 0 || mod == 2) {\n            assertThat(result.get(i)).isInstanceOf(ExecutionException.class);\n            assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);\n        } else {\n            assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);\n            assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);\n        }\n    }\n    // subsequent calls should call the loader again, not get the old exception\n    try {\n        cache.getUnchecked(\"bar\");\n        fail();\n    } catch (UncheckedExecutionException expected) {\n    }\n    assertEquals(2, callCount.get());\n}", "repo_id": "5", "comment": "/**\n * On a concurrent computation that throws a checked exception, all threads should get the\n * (wrapped) exception, with the loader called only once. The result should not be cached (a later\n * request should call the loader again).\n */\n", "repo_name": "guava-master/", "id": 3670, "method_signature": "void testConcurrentLoadingCheckedException(CacheBuilder)", "filename": "CacheLoadingTest.testConcurrentLoadingCheckedException.json"}
{"callee_method_names": ["CacheBuilder<Object,Object>.build", "AtomicInteger.incrementAndGet", "CountDownLatch.await", "AtomicInteger.get", "List<Object>.get"], "method_name": "CacheLoadingTest.testConcurrentLoadingDefault", "method_implementation": "{\n    int count = 10;\n    final AtomicInteger callCount = new AtomicInteger();\n    final CountDownLatch startSignal = new CountDownLatch(count + 1);\n    final Object result = new Object();\n    LoadingCache<String, Object> cache = builder.build(new CacheLoader<String, Object>() {\n\n        @Override\n        public Object load(String key) throws InterruptedException {\n            callCount.incrementAndGet();\n            startSignal.await();\n            return result;\n        }\n    });\n    List<Object> resultArray = doConcurrentGet(cache, \"bar\", count, startSignal);\n    assertEquals(1, callCount.get());\n    for (int i = 0; i < count; i++) {\n        assertSame(\"result(\" + i + \") didn't match expected\", result, resultArray.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * On a successful concurrent computation, only one thread does the work, but all the threads get\n * the same result.\n */\n", "repo_name": "guava-master/", "id": 3667, "method_signature": "void testConcurrentLoadingDefault(CacheBuilder)", "filename": "CacheLoadingTest.testConcurrentLoadingDefault.json"}
{"callee_method_names": ["CacheBuilder<Object,Object>.build", "AtomicInteger.incrementAndGet", "CountDownLatch.await", "AtomicInteger.get", "List<Object>.get", "LoadingCache<String, String>.getUnchecked", "AtomicInteger.get"], "method_name": "CacheLoadingTest.testConcurrentLoadingNull", "method_implementation": "{\n    int count = 10;\n    final AtomicInteger callCount = new AtomicInteger();\n    final CountDownLatch startSignal = new CountDownLatch(count + 1);\n    LoadingCache<String, String> cache = builder.build(new CacheLoader<String, String>() {\n\n        @Override\n        public String load(String key) throws InterruptedException {\n            callCount.incrementAndGet();\n            startSignal.await();\n            return null;\n        }\n    });\n    List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n    assertEquals(1, callCount.get());\n    for (int i = 0; i < count; i++) {\n        assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);\n    }\n    // subsequent calls should call the loader again, not get the old exception\n    try {\n        cache.getUnchecked(\"bar\");\n        fail();\n    } catch (InvalidCacheLoadException expected) {\n    }\n    assertEquals(2, callCount.get());\n}", "repo_id": "5", "comment": "/**\n * On a concurrent computation that returns null, all threads should get an\n * InvalidCacheLoadException, with the loader only called once. The result should not be cached (a\n * later request should call the loader again).\n */\n", "repo_name": "guava-master/", "id": 3668, "method_signature": "void testConcurrentLoadingNull(CacheBuilder)", "filename": "CacheLoadingTest.testConcurrentLoadingNull.json"}
{"callee_method_names": ["CacheBuilder<Object,Object>.build", "AtomicInteger.incrementAndGet", "CountDownLatch.await", "AtomicInteger.get", "List<Object>.get", "List<Object>.get", "LoadingCache<String, String>.getUnchecked", "AtomicInteger.get"], "method_name": "CacheLoadingTest.testConcurrentLoadingUncheckedException", "method_implementation": "{\n    int count = 10;\n    final AtomicInteger callCount = new AtomicInteger();\n    final CountDownLatch startSignal = new CountDownLatch(count + 1);\n    final RuntimeException e = new RuntimeException();\n    LoadingCache<String, String> cache = builder.build(new CacheLoader<String, String>() {\n\n        @Override\n        public String load(String key) throws InterruptedException {\n            callCount.incrementAndGet();\n            startSignal.await();\n            throw e;\n        }\n    });\n    List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n    assertEquals(1, callCount.get());\n    for (int i = 0; i < count; i++) {\n        // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked\n        // exception thrown by the loader is always wrapped as an UncheckedExecutionException.\n        assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);\n        assertThat(((UncheckedExecutionException) result.get(i))).hasCauseThat().isSameInstanceAs(e);\n    }\n    // subsequent calls should call the loader again, not get the old exception\n    try {\n        cache.getUnchecked(\"bar\");\n        fail();\n    } catch (UncheckedExecutionException expected) {\n    }\n    assertEquals(2, callCount.get());\n}", "repo_id": "5", "comment": "/**\n * On a concurrent computation that throws an unchecked exception, all threads should get the\n * (wrapped) exception, with the loader called only once. The result should not be cached (a later\n * request should call the loader again).\n */\n", "repo_name": "guava-master/", "id": 3669, "method_signature": "void testConcurrentLoadingUncheckedException(CacheBuilder)", "filename": "CacheLoadingTest.testConcurrentLoadingUncheckedException.json"}
{"callee_method_names": ["LoadingCache<Object, Object>.get", "LoadingCache<Object, Object>.getUnchecked", "LoadingCache<Object, Object>.refresh", "LoadingCache<Object, Object>.getAll", "LoadingCache<Object, Object>.get", "LoadingCache<Object, Object>.getUnchecked", "LoadingCache<Object, Object>.refresh", "LoadingCache<Object, Object>.getAll"], "method_name": "CacheLoadingTest.testLoadingExceptionWithCause", "method_implementation": "{\n    final Exception cause = new Exception();\n    final UncheckedExecutionException uee = new UncheckedExecutionException(cause);\n    final ExecutionException ee = new ExecutionException(cause);\n    LoadingCache<Object, Object> cacheUnchecked = CacheBuilder.newBuilder().build(exceptionLoader(uee));\n    LoadingCache<Object, Object> cacheChecked = CacheBuilder.newBuilder().build(exceptionLoader(ee));\n    try {\n        cacheUnchecked.get(new Object());\n        fail();\n    } catch (ExecutionException e) {\n        fail();\n    } catch (UncheckedExecutionException caughtEe) {\n        assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);\n    }\n    UncheckedExecutionException caughtUee = assertThrows(UncheckedExecutionException.class, () -> cacheUnchecked.getUnchecked(new Object()));\n    assertThat(caughtUee).hasCauseThat().isSameInstanceAs(uee);\n    cacheUnchecked.refresh(new Object());\n    checkLoggedCause(uee);\n    try {\n        cacheUnchecked.getAll(asList(new Object()));\n        fail();\n    } catch (ExecutionException e) {\n        fail();\n    } catch (UncheckedExecutionException caughtEe) {\n        assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);\n    }\n    ExecutionException caughtEe = assertThrows(ExecutionException.class, () -> cacheChecked.get(new Object()));\n    assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);\n    caughtUee = assertThrows(UncheckedExecutionException.class, () -> cacheChecked.getUnchecked(new Object()));\n    assertThat(caughtUee).hasCauseThat().isSameInstanceAs(ee);\n    cacheChecked.refresh(new Object());\n    checkLoggedCause(ee);\n    caughtEe = assertThrows(ExecutionException.class, () -> cacheChecked.getAll(asList(new Object())));\n    assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);\n}", "repo_id": "5", "comment": "/**\n * Make sure LoadingCache correctly wraps ExecutionExceptions and UncheckedExecutionExceptions.\n */\n", "repo_name": "guava-master/", "id": 3666, "method_signature": "void testLoadingExceptionWithCause()", "filename": "CacheLoadingTest.testLoadingExceptionWithCause.json"}
{"callee_method_names": [], "method_name": "CacheStats.minus", "method_implementation": "{\n    return new CacheStats(Math.max(0, saturatedSubtract(hitCount, other.hitCount)), Math.max(0, saturatedSubtract(missCount, other.missCount)), Math.max(0, saturatedSubtract(loadSuccessCount, other.loadSuccessCount)), Math.max(0, saturatedSubtract(loadExceptionCount, other.loadExceptionCount)), Math.max(0, saturatedSubtract(totalLoadTime, other.totalLoadTime)), Math.max(0, saturatedSubtract(evictionCount, other.evictionCount)));\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code CacheStats} representing the difference between this {@code CacheStats}\n * and {@code other}. Negative values, which aren't supported by {@code CacheStats} will be\n * rounded up to zero.\n */\n", "repo_name": "guava-master/", "id": 4894, "method_signature": "CacheStats minus(CacheStats)", "filename": "CacheStats.minus.json"}
{"callee_method_names": [], "method_name": "CacheStats.plus", "method_implementation": "{\n    return new CacheStats(saturatedAdd(hitCount, other.hitCount), saturatedAdd(missCount, other.missCount), saturatedAdd(loadSuccessCount, other.loadSuccessCount), saturatedAdd(loadExceptionCount, other.loadExceptionCount), saturatedAdd(totalLoadTime, other.totalLoadTime), saturatedAdd(evictionCount, other.evictionCount));\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code CacheStats} representing the sum of this {@code CacheStats} and {@code\n * other}.\n *\n * <p><b>Note:</b> the values of the metrics are undefined in case of overflow (though it is\n * guaranteed not to throw an exception). If you require specific handling, we recommend\n * implementing your own stats collector.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4895, "method_signature": "CacheStats plus(CacheStats)", "filename": "CacheStats.plus.json"}
{"callee_method_names": [], "method_name": "CacheTesting.checkEviction", "method_implementation": "{\n    if (hasLocalCache(cache)) {\n        checkEviction(toLocalCache(cache));\n    }\n}", "repo_id": "5", "comment": "/**\n * Peeks into the cache's internals to verify that its eviction queue is consistent. Verifies that\n * the prev/next links are correct, and that all items in each segment are also in that segment's\n * eviction (recency) queue.\n */\n", "repo_name": "guava-master/", "id": 3682, "method_signature": "void checkEviction(Cache)", "filename": "CacheTesting.checkEviction.json"}
{"callee_method_names": [], "method_name": "CacheTesting.checkExpiration", "method_implementation": "{\n    if (hasLocalCache(cache)) {\n        checkExpiration(toLocalCache(cache));\n    }\n}", "repo_id": "5", "comment": "/**\n * Peeks into the cache's internals to verify that its expiration queue is consistent. Verifies\n * that the next/prev links in the expiration queue are correct, and that the queue is ordered by\n * expiration time.\n */\n", "repo_name": "guava-master/", "id": 3681, "method_signature": "void checkExpiration(Cache)", "filename": "CacheTesting.checkExpiration.json"}
{"callee_method_names": ["LoadingCache<Integer,Integer>.size", "Segment<?, ?>.peek", "Receiver<ReferenceEntry<Integer,Integer>>.accept", "Segment<?, ?>.peek", "LoadingCache<Integer,Integer>.size"], "method_name": "CacheTesting.checkRecency", "method_implementation": "{\n    checkNotNull(operation);\n    if (hasLocalCache(cache)) {\n        warmUp(cache, 0, 2 * maxSize);\n        LocalCache<Integer, Integer> cchm = toLocalCache(cache);\n        Segment<?, ?> segment = cchm.segments[0];\n        drainRecencyQueue(segment);\n        assertEquals(maxSize, accessQueueSize(cache));\n        assertEquals(maxSize, cache.size());\n        ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();\n        @SuppressWarnings(\"unchecked\")\n        ReferenceEntry<Integer, Integer> entry = (ReferenceEntry<Integer, Integer>) originalHead;\n        operation.accept(entry);\n        drainRecencyQueue(segment);\n        assertNotSame(originalHead, segment.accessQueue.peek());\n        assertEquals(cache.size(), accessQueueSize(cache));\n    }\n}", "repo_id": "5", "comment": "/**\n * Assuming the given cache has maximum size {@code maxSize}, this method populates the cache (by\n * getting a bunch of different keys), then makes sure all the items in the cache are also in the\n * eviction queue. It will invoke the given {@code operation} on the first element in the eviction\n * queue, and then reverify that all items in the cache are in the eviction queue, and verify that\n * the head of the eviction queue has changed as a result of the operation.\n */\n", "repo_name": "guava-master/", "id": 3683, "method_signature": "void checkRecency(LoadingCache, int, Receiver)", "filename": "CacheTesting.checkRecency.json"}
{"callee_method_names": [], "method_name": "CacheTesting.checkValidState", "method_implementation": "{\n    if (hasLocalCache(cache)) {\n        checkValidState(toLocalCache(cache));\n    }\n}", "repo_id": "5", "comment": "/**\n * Peeks into the cache's internals to check its internal consistency. Verifies that each\n * segment's count matches its #elements (after cleanup), each segment is unlocked, each entry\n * contains a non-null key and value, and the eviction and expiration queues are consistent (see\n * {@link #checkEviction}, {@link #checkExpiration}).\n */\n", "repo_name": "guava-master/", "id": 3680, "method_signature": "void checkValidState(Cache)", "filename": "CacheTesting.checkValidState.json"}
{"callee_method_names": ["LocalCache<K, V>.hash", "LocalCache<K, V>.segmentFor", "Segment<K, V>.expand"], "method_name": "CacheTesting.forceExpandSegment", "method_implementation": "{\n    checkNotNull(cache);\n    checkNotNull(key);\n    LocalCache<K, V> map = toLocalCache(cache);\n    int hash = map.hash(key);\n    Segment<K, V> segment = map.segmentFor(hash);\n    segment.expand();\n}", "repo_id": "5", "comment": "/**\n * Forces the segment containing the given {@code key} to expand (see {@link Segment#expand()}).\n */\n", "repo_name": "guava-master/", "id": 3678, "method_signature": "void forceExpandSegment(Cache, K)", "filename": "CacheTesting.forceExpandSegment.json"}
{"callee_method_names": ["Reference<?>.clear"], "method_name": "CacheTesting.simulateKeyReclamation", "method_implementation": "{\n    ReferenceEntry<K, V> entry = getReferenceEntry(cache, key);\n    Preconditions.checkState(entry instanceof Reference);\n    Reference<?> ref = (Reference<?>) entry;\n    if (ref != null) {\n        ref.clear();\n    }\n}", "repo_id": "5", "comment": "/**\n * Poke into the Cache internals to simulate garbage collection of the given key. This assumes\n * that the given entry is a weak or soft reference, and throws an IllegalStateException if that\n * assumption does not hold.\n */\n", "repo_name": "guava-master/", "id": 3677, "method_signature": "void simulateKeyReclamation(Cache, K)", "filename": "CacheTesting.simulateKeyReclamation.json"}
{"callee_method_names": ["ReferenceEntry<K, V>.getValueReference", "Reference<V>.clear"], "method_name": "CacheTesting.simulateValueReclamation", "method_implementation": "{\n    ReferenceEntry<K, V> entry = getReferenceEntry(cache, key);\n    if (entry != null) {\n        ValueReference<K, V> valueRef = entry.getValueReference();\n        // fail on strong/computing refs\n        Preconditions.checkState(valueRef instanceof Reference);\n        Reference<V> ref = (Reference<V>) valueRef;\n        if (ref != null) {\n            ref.clear();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Poke into the Cache internals to simulate garbage collection of the value associated with the\n * given key. This assumes that the associated entry is a WeakValueReference or a\n * SoftValueReference (and not a LoadingValueReference), and throws an IllegalStateException if\n * that assumption does not hold.\n */\n", "repo_name": "guava-master/", "id": 3676, "method_signature": "void simulateValueReclamation(Cache, K)", "filename": "CacheTesting.simulateValueReclamation.json"}
{"callee_method_names": ["Cache<K,V>.getClass"], "method_name": "CacheTesting.toLocalCache", "method_implementation": "{\n    if (cache instanceof LocalLoadingCache) {\n        return ((LocalLoadingCache<K, V>) cache).localCache;\n    }\n    throw new IllegalArgumentException(\"Cache of type \" + cache.getClass() + \" doesn't have a LocalCache.\");\n}", "repo_id": "5", "comment": "/**\n * Gets the {@link LocalCache} used by the given {@link Cache}, if any, or throws an\n * IllegalArgumentException if this is a Cache type that doesn't have a LocalCache.\n */\n", "repo_name": "guava-master/", "id": 3679, "method_signature": "LocalCache<K,V> toLocalCache(Cache)", "filename": "CacheTesting.toLocalCache.json"}
{"callee_method_names": ["LoadingCache<Integer,Integer>.getUnchecked"], "method_name": "CacheTesting.warmUp", "method_implementation": "{\n    checkNotNull(map);\n    for (int i = start; i < end; i++) {\n        map.getUnchecked(i);\n    }\n}", "repo_id": "5", "comment": "/**\n * Warms the given cache by getting all values in {@code [start, end)}, in order.\n */\n", "repo_name": "guava-master/", "id": 3684, "method_signature": "void warmUp(LoadingCache, int, int)", "filename": "CacheTesting.warmUp.json"}
{"callee_method_names": [], "method_name": "CachingAsList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 3091, "method_signature": "Object writeReplace()", "filename": "CachingAsList.writeReplace.json"}
{"callee_method_names": ["ListeningExecutorService.submit"], "method_name": "Callables.asAsyncCallable", "method_implementation": "{\n    checkNotNull(callable);\n    checkNotNull(listeningExecutorService);\n    return () -> listeningExecutorService.submit(callable);\n}", "repo_id": "5", "comment": "/**\n * Creates an {@link AsyncCallable} from a {@link Callable}.\n *\n * <p>The {@link AsyncCallable} returns the {@link ListenableFuture} resulting from {@link\n * ListeningExecutorService#submit(Callable)}.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 5327, "method_signature": "AsyncCallable<T> asAsyncCallable(Callable, ListeningExecutorService)", "filename": "Callables.asAsyncCallable.json"}
{"callee_method_names": ["Thread.getName", "Supplier<String>.get", "Runnable.run"], "method_name": "Callables.threadRenaming", "method_implementation": "{\n    checkNotNull(nameSupplier);\n    checkNotNull(task);\n    return () -> {\n        Thread currentThread = Thread.currentThread();\n        String oldName = currentThread.getName();\n        boolean restoreName = trySetName(nameSupplier.get(), currentThread);\n        try {\n            task.run();\n        } finally {\n            if (restoreName) {\n                boolean unused = trySetName(oldName, currentThread);\n            }\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Wraps the given runnable such that for the duration of {@link Runnable#run} the thread that is\n * running with have the given name.\n *\n * @param task The Runnable to wrap\n * @param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once\n *     for each invocation of the wrapped callable.\n */\n", "repo_name": "guava-master/", "id": 5329, "method_signature": "Runnable threadRenaming(Runnable, Supplier)", "filename": "Callables.threadRenaming.json"}
{"callee_method_names": ["Thread.setName"], "method_name": "Callables.trySetName", "method_implementation": "{\n    /*\n     * setName should usually succeed, but the security manager can prohibit it. Is there a way to\n     * see if we have the modifyThread permission without catching an exception?\n     */\n    try {\n        currentThread.setName(threadName);\n        return true;\n    } catch (SecurityException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Tries to set name of the given {@link Thread}, returns true if successful.\n */\n", "repo_name": "guava-master/", "id": 5330, "method_signature": "boolean trySetName(String, Thread)", "filename": "Callables.trySetName.json"}
{"callee_method_names": [], "method_name": "CartesianList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6222, "method_signature": "Object writeReplace()", "filename": "CartesianList.writeReplace.json"}
{"callee_method_names": [], "method_name": "CartesianSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5605, "method_signature": "Object writeReplace()", "filename": "CartesianSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "CellSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6074, "method_signature": "Object writeReplace()", "filename": "CellSet.writeReplace.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "CharArrayDecorator.escape", "method_implementation": "{\n    int slen = s.length();\n    for (int index = 0; index < slen; index++) {\n        char c = s.charAt(index);\n        if (c < replacements.length && replacements[c] != null) {\n            return escapeSlow(s, index);\n        }\n    }\n    return s;\n}", "repo_id": "5", "comment": "/*\n     * Overriding escape method to be slightly faster for this decorator. We test the replacements\n     * array directly, saving a method call.\n     */\n", "repo_name": "guava-master/", "id": 4286, "method_signature": "String escape(String)", "filename": "CharArrayDecorator.escape.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "CharEscaper.escape", "method_implementation": "{\n    // GWT specific check (do not optimize)\n    checkNotNull(string);\n    // Inlineable fast-path loop which hands off to escapeSlow() only if needed\n    int length = string.length();\n    for (int index = 0; index < length; index++) {\n        if (escape(string.charAt(index)) != null) {\n            return escapeSlow(string, index);\n        }\n    }\n    return string;\n}", "repo_id": "5", "comment": "/**\n * Returns the escaped form of a given literal string.\n *\n * @param string the literal string to be escaped\n * @return the escaped form of {@code string}\n * @throws NullPointerException if {@code string} is null\n */\n", "repo_name": "guava-master/", "id": 4258, "method_signature": "String escape(String)", "filename": "CharEscaper.escape.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.getChars", "String.getChars"], "method_name": "CharEscaper.escapeSlow", "method_implementation": "{\n    int slen = s.length();\n    // Get a destination buffer and setup some loop variables.\n    char[] dest = Platform.charBufferFromThreadLocal();\n    int destSize = dest.length;\n    int destIndex = 0;\n    int lastEscape = 0;\n    // Loop through the rest of the string, replacing when needed into the\n    // destination buffer, which gets grown as needed as well.\n    for (; index < slen; index++) {\n        // Get a replacement for the current character.\n        char[] r = escape(s.charAt(index));\n        // If no replacement is needed, just continue.\n        if (r == null) {\n            continue;\n        }\n        int rlen = r.length;\n        int charsSkipped = index - lastEscape;\n        // This is the size needed to add the replacement, not the full size\n        // needed by the string. We only regrow when we absolutely must, and\n        // when we do grow, grow enough to avoid excessive growing. Grow.\n        int sizeNeeded = destIndex + charsSkipped + rlen;\n        if (destSize < sizeNeeded) {\n            destSize = sizeNeeded + DEST_PAD_MULTIPLIER * (slen - index);\n            dest = growBuffer(dest, destIndex, destSize);\n        }\n        // If we have skipped any characters, we need to copy them now.\n        if (charsSkipped > 0) {\n            s.getChars(lastEscape, index, dest, destIndex);\n            destIndex += charsSkipped;\n        }\n        // Copy the replacement string into the dest buffer as needed.\n        if (rlen > 0) {\n            System.arraycopy(r, 0, dest, destIndex, rlen);\n            destIndex += rlen;\n        }\n        lastEscape = index + 1;\n    }\n    // Copy leftover characters if there are any.\n    int charsLeft = slen - lastEscape;\n    if (charsLeft > 0) {\n        int sizeNeeded = destIndex + charsLeft;\n        if (destSize < sizeNeeded) {\n            // Regrow and copy, expensive! No padding as this is the final copy.\n            dest = growBuffer(dest, destIndex, sizeNeeded);\n        }\n        s.getChars(lastEscape, slen, dest, destIndex);\n        destIndex = sizeNeeded;\n    }\n    return new String(dest, 0, destIndex);\n}", "repo_id": "5", "comment": "/**\n * Returns the escaped form of a given literal string, starting at the given index. This method is\n * called by the {@link #escape(String)} method when it discovers that escaping is required. It is\n * protected to allow subclasses to override the fastpath escaping function to inline their\n * escaping test. See {@link CharEscaperBuilder} for an example usage.\n *\n * @param s the literal string to be escaped\n * @param index the index to start escaping from\n * @return the escaped form of {@code string}\n * @throws NullPointerException if {@code string} is null\n */\n", "repo_name": "guava-master/", "id": 4259, "method_signature": "String escapeSlow(String, int)", "filename": "CharEscaper.escapeSlow.json"}
{"callee_method_names": [], "method_name": "CharEscaper.growBuffer", "method_implementation": "{\n    if (size < 0) {\n        // overflow - should be OutOfMemoryError but GWT/j2cl don't support it\n        throw new AssertionError(\"Cannot increase internal buffer any further\");\n    }\n    char[] copy = new char[size];\n    if (index > 0) {\n        System.arraycopy(dest, 0, copy, 0, index);\n    }\n    return copy;\n}", "repo_id": "5", "comment": "/**\n * Helper method to grow the character buffer as needed, this only happens once in a while so it's\n * ok if it's in a method call. If the index passed in is 0 then no copying will be done.\n */\n", "repo_name": "guava-master/", "id": 4260, "method_signature": "char[] growBuffer(char[], int, int)", "filename": "CharEscaper.growBuffer.json"}
{"callee_method_names": ["Map<Character, String>.put"], "method_name": "CharEscaperBuilder.addEscape", "method_implementation": "{\n    map.put(c, checkNotNull(r));\n    if (c > max) {\n        max = c;\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Add a new mapping from an index to an object to the escaping.\n */\n", "repo_name": "guava-master/", "id": 4283, "method_signature": "CharEscaperBuilder addEscape(char, String)", "filename": "CharEscaperBuilder.addEscape.json"}
{"callee_method_names": [], "method_name": "CharEscaperBuilder.addEscapes", "method_implementation": "{\n    checkNotNull(r);\n    for (char c : cs) {\n        addEscape(c, r);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Add multiple mappings at once for a particular index.\n */\n", "repo_name": "guava-master/", "id": 4284, "method_signature": "CharEscaperBuilder addEscapes(char[], String)", "filename": "CharEscaperBuilder.addEscapes.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "CharEscaperBuilder.escape", "method_implementation": "{\n    int slen = s.length();\n    for (int index = 0; index < slen; index++) {\n        char c = s.charAt(index);\n        if (c < replacements.length && replacements[c] != null) {\n            return escapeSlow(s, index);\n        }\n    }\n    return s;\n}", "repo_id": "5", "comment": "/*\n     * Overriding escape method to be slightly faster for this decorator. We test the replacements\n     * array directly, saving a method call.\n     */\n", "repo_name": "guava-master/", "id": 4282, "method_signature": "String escape(String)", "filename": "CharEscaperBuilder.escape.json"}
{"callee_method_names": ["Map<Character, String>.entrySet", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue"], "method_name": "CharEscaperBuilder.toArray", "method_implementation": "{\n    char[][] result = new char[max + 1][];\n    for (Entry<Character, String> entry : map.entrySet()) {\n        result[entry.getKey()] = entry.getValue().toCharArray();\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Convert this builder into an array of char[]s where the maximum index is the value of the\n * highest character that has been seen. The array will be sparse in the sense that any unseen\n * index will default to null.\n *\n * @return a \"sparse\" array that holds the replacement mappings.\n */\n", "repo_name": "guava-master/", "id": 4285, "method_signature": "char[][] toArray()", "filename": "CharEscaperBuilder.toArray.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "CharMatcher.anyOf", "method_implementation": "{\n    switch(sequence.length()) {\n        case 0:\n            return none();\n        case 1:\n            return is(sequence.charAt(0));\n        case 2:\n            return isEither(sequence.charAt(0), sequence.charAt(1));\n        default:\n            // TODO(lowasser): is it potentially worth just going ahead and building a precomputed\n            // matcher?\n            return new AnyOf(sequence);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code char} matcher that matches any BMP character present in the given character\n * sequence. Returns a bogus matcher if the sequence contains supplementary characters.\n */\n", "repo_name": "guava-master/", "id": 5081, "method_signature": "CharMatcher anyOf(CharSequence)", "filename": "CharMatcher.anyOf.json"}
{"callee_method_names": [], "method_name": "CharMatcher.apply", "method_implementation": "{\n    return matches(character);\n}", "repo_id": "5", "comment": "/**\n * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #matches}\n *     instead.\n */\n", "repo_name": "guava-master/", "id": 5097, "method_signature": "boolean apply(Character)", "filename": "CharMatcher.apply.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.toString"], "method_name": "CharMatcher.collapseFrom", "method_implementation": "{\n    // This implementation avoids unnecessary allocation.\n    int len = sequence.length();\n    for (int i = 0; i < len; i++) {\n        char c = sequence.charAt(i);\n        if (matches(c)) {\n            if (c == replacement && (i == len - 1 || !matches(sequence.charAt(i + 1)))) {\n                // a no-op replacement\n                i++;\n            } else {\n                StringBuilder builder = new StringBuilder(len).append(sequence, 0, i).append(replacement);\n                return finishCollapseFrom(sequence, i + 1, len, replacement, builder, true);\n            }\n        }\n    }\n    // no replacement needed\n    return sequence.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string copy of the input character sequence, with each group of consecutive matching\n * BMP characters replaced by a single replacement character. For example:\n *\n * <pre>{@code\n * CharMatcher.anyOf(\"eko\").collapseFrom(\"bookkeeper\", '-')\n * }</pre>\n *\n * ... returns {@code \"b-p-r\"}.\n *\n * <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching\n * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each\n * character.\n *\n * @param sequence the character sequence to replace matching groups of characters in\n * @param replacement the character to append to the result string in place of each group of\n *     matching characters in {@code sequence}\n * @return the new string\n */\n", "repo_name": "guava-master/", "id": 5095, "method_signature": "String collapseFrom(CharSequence, char)", "filename": "CharMatcher.collapseFrom.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "CharMatcher.countIn", "method_implementation": "{\n    int count = 0;\n    for (int i = 0; i < sequence.length(); i++) {\n        if (matches(sequence.charAt(i))) {\n            count++;\n        }\n    }\n    return count;\n}", "repo_id": "5", "comment": "/**\n * Returns the number of matching {@code char}s found in a character sequence.\n *\n * <p>Counts 2 per supplementary character, such as for {@link #whitespace}().{@link #negate}().\n */\n", "repo_name": "guava-master/", "id": 5088, "method_signature": "int countIn(CharSequence)", "filename": "CharMatcher.countIn.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "CharMatcher.indexIn", "method_implementation": "{\n    int length = sequence.length();\n    checkPositionIndex(start, length);\n    for (int i = start; i < length; i++) {\n        if (matches(sequence.charAt(i))) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the index of the first matching BMP character in a character sequence, starting from a\n * given position, or {@code -1} if no character matches after that position.\n *\n * <p>The default implementation iterates over the sequence in forward order, beginning at {@code\n * start}, calling {@link #matches} for each character.\n *\n * @param sequence the character sequence to examine\n * @param start the first index to examine; must be nonnegative and no greater than {@code\n *     sequence.length()}\n * @return the index of the first matching character, guaranteed to be no less than {@code start},\n *     or {@code -1} if no character matches\n * @throws IndexOutOfBoundsException if start is negative or greater than {@code\n *     sequence.length()}\n */\n", "repo_name": "guava-master/", "id": 5086, "method_signature": "int indexIn(CharSequence, int)", "filename": "CharMatcher.indexIn.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "CharMatcher.lastIndexIn", "method_implementation": "{\n    for (int i = sequence.length() - 1; i >= 0; i--) {\n        if (matches(sequence.charAt(i))) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the index of the last matching BMP character in a character sequence, or {@code -1} if\n * no matching character is present.\n *\n * <p>The default implementation iterates over the sequence in reverse order calling {@link\n * #matches} for each character.\n *\n * @param sequence the character sequence to examine from the end\n * @return an index, or {@code -1} if no character matches\n */\n", "repo_name": "guava-master/", "id": 5087, "method_signature": "int lastIndexIn(CharSequence)", "filename": "CharMatcher.lastIndexIn.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "CharMatcher.matchesAllOf", "method_implementation": "{\n    for (int i = sequence.length() - 1; i >= 0; i--) {\n        if (!matches(sequence.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if a character sequence contains only matching BMP characters.\n *\n * <p>The default implementation iterates over the sequence, invoking {@link #matches} for each\n * character, until this returns {@code false} or the end is reached.\n *\n * @param sequence the character sequence to examine, possibly empty\n * @return {@code true} if this matcher matches every character in the sequence, including when\n *     the sequence is empty\n */\n", "repo_name": "guava-master/", "id": 5085, "method_signature": "boolean matchesAllOf(CharSequence)", "filename": "CharMatcher.matchesAllOf.json"}
{"callee_method_names": ["BitSet.cardinality", "BitSet.flip", "String.endsWith", "String.substring", "String.length", "String.length"], "method_name": "CharMatcher.precomputedInternal", "method_implementation": "{\n    final BitSet table = new BitSet();\n    setBits(table);\n    int totalCharacters = table.cardinality();\n    if (totalCharacters * 2 <= DISTINCT_CHARS) {\n        return precomputedPositive(totalCharacters, table, toString());\n    } else {\n        // TODO(lowasser): is it worth it to worry about the last character of large matchers?\n        table.flip(Character.MIN_VALUE, Character.MAX_VALUE + 1);\n        int negatedCharacters = DISTINCT_CHARS - totalCharacters;\n        String suffix = \".negate()\";\n        final String description = toString();\n        String negatedDescription = description.endsWith(suffix) ? description.substring(0, description.length() - suffix.length()) : description + suffix;\n        return new NegatedFastMatcher(precomputedPositive(negatedCharacters, table, negatedDescription)) {\n\n            @Override\n            public String toString() {\n                return description;\n            }\n        };\n    }\n}", "repo_id": "5", "comment": "/**\n * This is the actual implementation of {@link #precomputed}, but we bounce calls through a method\n * on {@link Platform} so that we can have different behavior in GWT.\n *\n * <p>This implementation tries to be smart in a number of ways. It recognizes cases where the\n * negation is cheaper to precompute than the matcher itself; it tries to build small hash tables\n * for matchers that only match a few characters, and so on. In the worst-case scenario, it\n * constructs an eight-kilobyte bit array and queries that. In many situations this produces a\n * matcher which is faster to query than the original.\n */\n", "repo_name": "guava-master/", "id": 5082, "method_signature": "CharMatcher precomputedInternal()", "filename": "CharMatcher.precomputedInternal.json"}
{"callee_method_names": ["BitSet.nextSetBit", "BitSet.nextSetBit", "BitSet.nextSetBit", "BitSet.length"], "method_name": "CharMatcher.precomputedPositive", "method_implementation": "{\n    switch(totalCharacters) {\n        case 0:\n            return none();\n        case 1:\n            return is((char) table.nextSetBit(0));\n        case 2:\n            char c1 = (char) table.nextSetBit(0);\n            char c2 = (char) table.nextSetBit(c1 + 1);\n            return isEither(c1, c2);\n        default:\n            return isSmall(totalCharacters, table.length()) ? SmallCharMatcher.from(table, description) : new BitSetMatcher(table, description);\n    }\n}", "repo_id": "5", "comment": "/**\n * Helper method for {@link #precomputedInternal} that doesn't test if the negation is cheaper.\n */\n", "repo_name": "guava-master/", "id": 5083, "method_signature": "CharMatcher precomputedPositive(int, BitSet, String)", "filename": "CharMatcher.precomputedPositive.json"}
{"callee_method_names": ["CharSequence.toString", "String.toCharArray"], "method_name": "CharMatcher.removeFrom", "method_implementation": "{\n    String string = sequence.toString();\n    int pos = indexIn(string);\n    if (pos == -1) {\n        return string;\n    }\n    char[] chars = string.toCharArray();\n    int spread = 1;\n    // This unusual loop comes from extensive benchmarking\n    OUT: while (true) {\n        pos++;\n        while (true) {\n            if (pos == chars.length) {\n                break OUT;\n            }\n            if (matches(chars[pos])) {\n                break;\n            }\n            chars[pos - spread] = chars[pos];\n            pos++;\n        }\n        spread++;\n    }\n    return new String(chars, 0, pos - spread);\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing all non-matching characters of a character sequence, in order. For\n * example:\n *\n * <pre>{@code\n * CharMatcher.is('a').removeFrom(\"bazaar\")\n * }</pre>\n *\n * ... returns {@code \"bzr\"}.\n */\n", "repo_name": "guava-master/", "id": 5089, "method_signature": "String removeFrom(CharSequence)", "filename": "CharMatcher.removeFrom.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.toString", "String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CharMatcher.replaceFrom", "method_implementation": "{\n    int replacementLen = replacement.length();\n    if (replacementLen == 0) {\n        return removeFrom(sequence);\n    }\n    if (replacementLen == 1) {\n        return replaceFrom(sequence, replacement.charAt(0));\n    }\n    String string = sequence.toString();\n    int pos = indexIn(string);\n    if (pos == -1) {\n        return string;\n    }\n    int len = string.length();\n    StringBuilder buf = new StringBuilder((len * 3 / 2) + 16);\n    int oldpos = 0;\n    do {\n        buf.append(string, oldpos, pos);\n        buf.append(replacement);\n        oldpos = pos + 1;\n        pos = indexIn(string, oldpos);\n    } while (pos != -1);\n    buf.append(string, oldpos, len);\n    return buf.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string copy of the input character sequence, with each matching BMP character\n * replaced by a given replacement sequence. For example:\n *\n * <pre>{@code\n * CharMatcher.is('a').replaceFrom(\"yaha\", \"oo\")\n * }</pre>\n *\n * ... returns {@code \"yoohoo\"}.\n *\n * <p><b>Note:</b> If the replacement is a fixed string with only one character, you are better\n * off calling {@link #replaceFrom(CharSequence, char)} directly.\n *\n * @param sequence the character sequence to replace matching characters in\n * @param replacement the characters to append to the result string in place of each matching\n *     character in {@code sequence}\n * @return the new string\n */\n", "repo_name": "guava-master/", "id": 5091, "method_signature": "String replaceFrom(CharSequence, CharSequence)", "filename": "CharMatcher.replaceFrom.json"}
{"callee_method_names": ["BitSet.set"], "method_name": "CharMatcher.setBits", "method_implementation": "{\n    for (int c = Character.MAX_VALUE; c >= Character.MIN_VALUE; c--) {\n        if (matches((char) c)) {\n            table.set(c);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Sets bits in {@code table} matched by this matcher.\n */\n", "repo_name": "guava-master/", "id": 5084, "method_signature": "void setBits(BitSet)", "filename": "CharMatcher.setBits.json"}
{"callee_method_names": ["String.charAt"], "method_name": "CharMatcher.showCharacter", "method_implementation": "{\n    String hex = \"0123456789ABCDEF\";\n    char[] tmp = { '\\\\', 'u', '\\0', '\\0', '\\0', '\\0' };\n    for (int i = 0; i < 4; i++) {\n        tmp[5 - i] = hex.charAt(c & 0xF);\n        c = (char) (c >> 4);\n    }\n    return String.copyValueOf(tmp);\n}", "repo_id": "5", "comment": "/**\n * Returns the Java Unicode escape sequence for the given {@code char}, in the form \"\\u12AB\" where\n * \"12AB\" is the four hexadecimal digits representing the 16-bit code unit.\n */\n", "repo_name": "guava-master/", "id": 5098, "method_signature": "String showCharacter(char)", "filename": "CharMatcher.showCharacter.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "CharMatcher.trimAndCollapseFrom", "method_implementation": "{\n    // This implementation avoids unnecessary allocation.\n    int len = sequence.length();\n    int first = 0;\n    int last = len - 1;\n    while (first < len && matches(sequence.charAt(first))) {\n        first++;\n    }\n    while (last > first && matches(sequence.charAt(last))) {\n        last--;\n    }\n    return (first == 0 && last == len - 1) ? collapseFrom(sequence, replacement) : finishCollapseFrom(sequence, first, last + 1, replacement, new StringBuilder(last + 1 - first), false);\n}", "repo_id": "5", "comment": "/**\n * Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that\n * groups of matching BMP characters at the start or end of the sequence are removed without\n * replacement.\n */\n", "repo_name": "guava-master/", "id": 5096, "method_signature": "String trimAndCollapseFrom(CharSequence, char)", "filename": "CharMatcher.trimAndCollapseFrom.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.subSequence"], "method_name": "CharMatcher.trimFrom", "method_implementation": "{\n    int len = sequence.length();\n    int first;\n    int last;\n    for (first = 0; first < len; first++) {\n        if (!matches(sequence.charAt(first))) {\n            break;\n        }\n    }\n    for (last = len - 1; last > first; last--) {\n        if (!matches(sequence.charAt(last))) {\n            break;\n        }\n    }\n    return sequence.subSequence(first, last + 1).toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a substring of the input character sequence that omits all matching BMP characters from\n * the beginning and from the end of the string. For example:\n *\n * <pre>{@code\n * CharMatcher.anyOf(\"ab\").trimFrom(\"abacatbab\")\n * }</pre>\n *\n * ... returns {@code \"cat\"}.\n *\n * <p>Note that:\n *\n * <pre>{@code\n * CharMatcher.inRange('\\0', ' ').trimFrom(str)\n * }</pre>\n *\n * ... is equivalent to {@link String#trim()}.\n */\n", "repo_name": "guava-master/", "id": 5092, "method_signature": "String trimFrom(CharSequence)", "filename": "CharMatcher.trimFrom.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.subSequence"], "method_name": "CharMatcher.trimLeadingFrom", "method_implementation": "{\n    int len = sequence.length();\n    for (int first = 0; first < len; first++) {\n        if (!matches(sequence.charAt(first))) {\n            return sequence.subSequence(first, len).toString();\n        }\n    }\n    return \"\";\n}", "repo_id": "5", "comment": "/**\n * Returns a substring of the input character sequence that omits all matching BMP characters from\n * the beginning of the string. For example:\n *\n * <pre>{@code\n * CharMatcher.anyOf(\"ab\").trimLeadingFrom(\"abacatbab\")\n * }</pre>\n *\n * ... returns {@code \"catbab\"}.\n */\n", "repo_name": "guava-master/", "id": 5093, "method_signature": "String trimLeadingFrom(CharSequence)", "filename": "CharMatcher.trimLeadingFrom.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.subSequence"], "method_name": "CharMatcher.trimTrailingFrom", "method_implementation": "{\n    int len = sequence.length();\n    for (int last = len - 1; last >= 0; last--) {\n        if (!matches(sequence.charAt(last))) {\n            return sequence.subSequence(0, last + 1).toString();\n        }\n    }\n    return \"\";\n}", "repo_id": "5", "comment": "/**\n * Returns a substring of the input character sequence that omits all matching BMP characters from\n * the end of the string. For example:\n *\n * <pre>{@code\n * CharMatcher.anyOf(\"ab\").trimTrailingFrom(\"abacatbab\")\n * }</pre>\n *\n * ... returns {@code \"abacat\"}.\n */\n", "repo_name": "guava-master/", "id": 5094, "method_signature": "String trimTrailingFrom(CharSequence)", "filename": "CharMatcher.trimTrailingFrom.json"}
{"callee_method_ids": [5084], "callee_method_names": ["SampleMatcherConfig.precomputed", "CharMatcher.setBits", "BitSet.cardinality"], "method_name": "CharMatcherBenchmark.setUp", "method_implementation": "{\n    this.matcher = precomputed ? config.matcher.precomputed() : config.matcher;\n    if (size == Size.SMALL) {\n        BitSet tmp = new BitSet();\n        matcher.setBits(tmp);\n        int matchedCharCount = tmp.cardinality();\n        this.matcher = SmallCharMatcher.from(tmp, \"\");\n    }\n    this.string = checkString(length, percent, config.matchingChars, new Random(), forceSlow, web);\n}", "repo_id": "5", "comment": "// Caliper invokes setUp() after injecting params\n", "repo_name": "guava-master/", "id": 3485, "method_signature": "void setUp()", "filename": "CharMatcherBenchmark.setUp.json"}
{"callee_method_names": ["String.equals"], "method_name": "CharMatcherTest.assertEqualsSame", "method_implementation": "{\n    if (expected.equals(in)) {\n        assertSame(in, out);\n    } else {\n        assertEquals(expected, out);\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks that expected is equals to out, and further, if in is equals to expected, then out is\n * successfully optimized to be identical to in, i.e. that \"in\" is simply returned.\n */\n", "repo_name": "guava-master/", "id": 3700, "method_signature": "void assertEqualsSame(String, String, String)", "filename": "CharMatcherTest.assertEqualsSame.json"}
{"callee_method_names": [], "method_name": "CharMatcherTest.testCollapse", "method_implementation": "{\n    // collapsing groups of '-' into '_' or '-'\n    doTestCollapse(\"-\", \"_\");\n    doTestCollapse(\"x-\", \"x_\");\n    doTestCollapse(\"-x\", \"_x\");\n    doTestCollapse(\"--\", \"_\");\n    doTestCollapse(\"x--\", \"x_\");\n    doTestCollapse(\"--x\", \"_x\");\n    doTestCollapse(\"-x-\", \"_x_\");\n    doTestCollapse(\"x-x\", \"x_x\");\n    doTestCollapse(\"---\", \"_\");\n    doTestCollapse(\"--x-\", \"_x_\");\n    doTestCollapse(\"--xx\", \"_xx\");\n    doTestCollapse(\"-x--\", \"_x_\");\n    doTestCollapse(\"-x-x\", \"_x_x\");\n    doTestCollapse(\"-xx-\", \"_xx_\");\n    doTestCollapse(\"x--x\", \"x_x\");\n    doTestCollapse(\"x-x-\", \"x_x_\");\n    doTestCollapse(\"x-xx\", \"x_xx\");\n    doTestCollapse(\"x-x--xx---x----x\", \"x_x_xx_x_x\");\n    doTestCollapseWithNoChange(\"\");\n    doTestCollapseWithNoChange(\"x\");\n    doTestCollapseWithNoChange(\"xx\");\n}", "repo_id": "5", "comment": "// cover lots of different configurations of input text\n", "repo_name": "guava-master/", "id": 3701, "method_signature": "void testCollapse()", "filename": "CharMatcherTest.testCollapse.json"}
{"callee_method_ids": [5001], "callee_method_names": ["Splitter.split", "Iterator<String>.hasNext", "Iterator<String>.next", "Iterator<String>.hasNext", "String.isEmpty"], "method_name": "CharSequenceCharSource.linesIterator", "method_implementation": "{\n    return new AbstractIterator<String>() {\n\n        Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n\n        @Override\n        @CheckForNull\n        protected String computeNext() {\n            if (lines.hasNext()) {\n                String next = lines.next();\n                // skip last line if it's empty\n                if (lines.hasNext() || !next.isEmpty()) {\n                    return next;\n                }\n            }\n            return endOfData();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an iterator over the lines in the string. If the string ends in a newline, a final\n * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().\n */\n", "repo_name": "guava-master/", "id": 4844, "method_signature": "Iterator<String> linesIterator()", "filename": "CharSequenceCharSource.linesIterator.json"}
{"callee_method_names": ["CharSequence.toString", "String.length", "String.charAt", "CharSequenceReader.read", "String.length", "String.length", "String.length", "CharSequenceReader.read", "CharSequenceReader.read", "StringBuilder.append", "StringBuilder.toString", "String.length", "String.length", "String.length", "CharSequenceReader.read", "CharBuffer.toString", "CharSequenceReader.read", "StringBuilder.append", "StringBuilder.toString", "String.length", "CharSequenceReader.skip", "String.length", "CharSequenceReader.skip", "String.length", "CharSequenceReader.read", "String.substring"], "method_name": "CharSequenceReaderTest.assertReadsCorrectly", "method_implementation": "{\n    String expected = charSequence.toString();\n    // read char by char\n    CharSequenceReader reader = new CharSequenceReader(charSequence);\n    for (int i = 0; i < expected.length(); i++) {\n        assertEquals(expected.charAt(i), reader.read());\n    }\n    assertFullyRead(reader);\n    // read all to one array\n    reader = new CharSequenceReader(charSequence);\n    char[] buf = new char[expected.length()];\n    assertEquals(expected.length() == 0 ? -1 : expected.length(), reader.read(buf));\n    assertEquals(expected, new String(buf));\n    assertFullyRead(reader);\n    // read in chunks to fixed array\n    reader = new CharSequenceReader(charSequence);\n    buf = new char[5];\n    StringBuilder builder = new StringBuilder();\n    int read;\n    while ((read = reader.read(buf, 0, buf.length)) != -1) {\n        builder.append(buf, 0, read);\n    }\n    assertEquals(expected, builder.toString());\n    assertFullyRead(reader);\n    // read all to one CharBuffer\n    reader = new CharSequenceReader(charSequence);\n    CharBuffer buf2 = CharBuffer.allocate(expected.length());\n    assertEquals(expected.length() == 0 ? -1 : expected.length(), reader.read(buf2));\n    Java8Compatibility.flip(buf2);\n    assertEquals(expected, buf2.toString());\n    assertFullyRead(reader);\n    // read in chunks to fixed CharBuffer\n    reader = new CharSequenceReader(charSequence);\n    buf2 = CharBuffer.allocate(5);\n    builder = new StringBuilder();\n    while (reader.read(buf2) != -1) {\n        Java8Compatibility.flip(buf2);\n        builder.append(buf2);\n        Java8Compatibility.clear(buf2);\n    }\n    assertEquals(expected, builder.toString());\n    assertFullyRead(reader);\n    // skip fully\n    reader = new CharSequenceReader(charSequence);\n    assertEquals(expected.length(), reader.skip(Long.MAX_VALUE));\n    assertFullyRead(reader);\n    // skip 5 and read the rest\n    if (expected.length() > 5) {\n        reader = new CharSequenceReader(charSequence);\n        assertEquals(5, reader.skip(5));\n        buf = new char[expected.length() - 5];\n        assertEquals(buf.length, reader.read(buf, 0, buf.length));\n        assertEquals(expected.substring(5), new String(buf));\n        assertFullyRead(reader);\n    }\n}", "repo_id": "5", "comment": "/**\n * Creates a CharSequenceReader wrapping the given CharSequence and tests that the reader produces\n * the same sequence when read using each type of read method it provides.\n */\n", "repo_name": "guava-master/", "id": 3646, "method_signature": "void assertReadsCorrectly(CharSequence)", "filename": "CharSequenceReaderTest.assertReadsCorrectly.json"}
{"callee_method_names": [], "method_name": "CharSink.openBufferedStream", "method_implementation": "{\n    Writer writer = openStream();\n    return (writer instanceof BufferedWriter) ? (BufferedWriter) writer : new BufferedWriter(writer);\n}", "repo_id": "5", "comment": "/**\n * Opens a new buffered {@link Writer} for writing to this sink. The returned stream is not\n * required to be a {@link BufferedWriter} in order to allow implementations to simply delegate to\n * {@link #openStream()} when the stream returned by that method does not benefit from additional\n * buffering. This method returns a new, independent writer each time it is called.\n *\n * <p>The caller is responsible for ensuring that the returned writer is closed.\n *\n * @throws IOException if an I/O error occurs while opening the writer\n * @since 15.0 (in 14.0 with return type {@link BufferedWriter})\n */\n", "repo_name": "guava-master/", "id": 4741, "method_signature": "Writer openBufferedStream()", "filename": "CharSink.openBufferedStream.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "Writer.append", "Writer.flush", "Closer.rethrow", "Closer.close"], "method_name": "CharSink.write", "method_implementation": "{\n    checkNotNull(charSequence);\n    Closer closer = Closer.create();\n    try {\n        Writer out = closer.register(openStream());\n        out.append(charSequence);\n        // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n        out.flush();\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Writes the given character sequence to this sink.\n *\n * @throws IOException if an I/O error while writing to this sink\n */\n", "repo_name": "guava-master/", "id": 4742, "method_signature": "void write(CharSequence)", "filename": "CharSink.write.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "Writer.flush", "Closer.rethrow", "Closer.close"], "method_name": "CharSink.writeFrom", "method_implementation": "{\n    checkNotNull(readable);\n    Closer closer = Closer.create();\n    try {\n        Writer out = closer.register(openStream());\n        long written = CharStreams.copy(readable, out);\n        // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n        out.flush();\n        return written;\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Writes all the text from the given {@link Readable} (such as a {@link Reader}) to this sink.\n * Does not close {@code readable} if it is {@code Closeable}.\n *\n * @return the number of characters written\n * @throws IOException if an I/O error occurs while reading from {@code readable} or writing to\n *     this sink\n */\n", "repo_name": "guava-master/", "id": 4744, "method_signature": "long writeFrom(Readable)", "filename": "CharSink.writeFrom.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "Writer.append", "Writer.flush", "Closer.rethrow", "Closer.close"], "method_name": "CharSink.writeLines", "method_implementation": "{\n    checkNotNull(lines);\n    checkNotNull(lineSeparator);\n    Closer closer = Closer.create();\n    try {\n        Writer out = closer.register(openBufferedStream());\n        for (CharSequence line : lines) {\n            out.append(line).append(lineSeparator);\n        }\n        // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n        out.flush();\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Writes the given lines of text to this sink with each line (including the last) terminated with\n * the given line separator.\n *\n * @throws IOException if an I/O error occurs while writing to this sink\n */\n", "repo_name": "guava-master/", "id": 4743, "method_signature": "void writeLines(Iterable, String)", "filename": "CharSink.writeLines.json"}
{"callee_method_ids": [4848, 4848, 4851, 4852], "callee_method_names": ["Closer.register", "Closer.register", "CharSink.openStream", "Closer.rethrow", "Closer.close"], "method_name": "CharSource.copyTo", "method_implementation": "{\n    checkNotNull(sink);\n    Closer closer = Closer.create();\n    try {\n        Reader reader = closer.register(openStream());\n        Writer writer = closer.register(sink.openStream());\n        return CharStreams.copy(reader, writer);\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Copies the contents of this source to the given sink.\n *\n * @return the number of characters copied\n * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n *     sink}\n */\n", "repo_name": "guava-master/", "id": 4836, "method_signature": "long copyTo(CharSink)", "filename": "CharSource.copyTo.json"}
{"callee_method_names": ["Iterator<String>.forEachOrdered", "IOException.getCause"], "method_name": "CharSource.forEachLine", "method_implementation": "{\n    try (Stream<String> lines = lines()) {\n        // The lines should be ordered regardless in most cases, but use forEachOrdered to be sure\n        lines.forEachOrdered(action);\n    } catch (UncheckedIOException e) {\n        throw e.getCause();\n    }\n}", "repo_id": "5", "comment": "/**\n * Reads all lines of text from this source, running the given {@code action} for each line as it\n * is read.\n *\n * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n * it does.\n *\n * @throws IOException if an I/O error occurs while reading from this source or if {@code action}\n *     throws an {@code UncheckedIOException}\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 1429, "method_signature": "void forEachLine(Consumer)", "filename": "CharSource.forEachLine.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Optional<Long>.isPresent", "Optional<Long>.get", "Closer.register", "Reader.read", "Closer.rethrow", "Closer.close"], "method_name": "CharSource.isEmpty", "method_implementation": "{\n    Optional<Long> lengthIfKnown = lengthIfKnown();\n    if (lengthIfKnown.isPresent()) {\n        return lengthIfKnown.get() == 0L;\n    }\n    Closer closer = Closer.create();\n    try {\n        Reader reader = closer.register(openStream());\n        return reader.read() == -1;\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns whether the source has zero chars. The default implementation first checks {@link\n * #lengthIfKnown}, returning true if it's known to be zero and false if it's known to be\n * non-zero. If the length is not known, it falls back to opening a stream and checking for EOF.\n *\n * <p>Note that, in cases where {@code lengthIfKnown} returns zero, it is <i>possible</i> that\n * chars are actually available for reading. This means that a source may return {@code true} from\n * {@code isEmpty()} despite having readable content.\n *\n * @throws IOException if an I/O error occurs\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 4841, "method_signature": "boolean isEmpty()", "filename": "CharSource.isEmpty.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Optional<Long>.isPresent", "Optional<Long>.get", "Closer.register", "Closer.rethrow", "Closer.close"], "method_name": "CharSource.length", "method_implementation": "{\n    Optional<Long> lengthIfKnown = lengthIfKnown();\n    if (lengthIfKnown.isPresent()) {\n        return lengthIfKnown.get();\n    }\n    Closer closer = Closer.create();\n    try {\n        Reader reader = closer.register(openStream());\n        return countBySkipping(reader);\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the length of this source in chars, even if doing so requires opening and traversing an\n * entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.\n *\n * <p>The default implementation calls {@link #lengthIfKnown} and returns the value if present. If\n * absent, it will fall back to a heavyweight operation that will open a stream, {@link\n * Reader#skip(long) skip} to the end of the stream, and return the total number of chars that\n * were skipped.\n *\n * <p>Note that for sources that implement {@link #lengthIfKnown} to provide a more efficient\n * implementation, it is <i>possible</i> that this method will return a different number of chars\n * than would be returned by reading all of the chars.\n *\n * <p>In either case, for mutable sources such as files, a subsequent read may return a different\n * number of chars if the contents are changed.\n *\n * @throws IOException if an I/O error occurs while reading the length of this source\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 4834, "method_signature": "long length()", "filename": "CharSource.length.json"}
{"callee_method_names": ["BufferedReader.lines", "BufferedReader.close"], "method_name": "CharSource.lines", "method_implementation": "{\n    BufferedReader reader = openBufferedStream();\n    return reader.lines().onClose(() -> {\n        try {\n            reader.close();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Opens a new {@link Stream} for reading text one line at a time from this source. This method\n * returns a new, independent stream each time it is called.\n *\n * <p>The returned stream is lazy and only reads from the source in the terminal operation. If an\n * I/O error occurs while the stream is reading from the source or when the stream is closed, an\n * {@link UncheckedIOException} is thrown.\n *\n * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n * it does.\n *\n * <p>The caller is responsible for ensuring that the returned stream is closed. For example:\n *\n * <pre>{@code\n * try (Stream<String> lines = source.lines()) {\n *   lines.map(...)\n *      .filter(...)\n *      .forEach(...);\n * }\n * }</pre>\n *\n * @throws IOException if an I/O error occurs while opening the stream\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 1421, "method_signature": "Stream<String> lines()", "filename": "CharSource.lines.json"}
{"callee_method_ids": [5001], "callee_method_names": ["Splitter.split", "Iterator<String>.hasNext", "Iterator<String>.next", "Iterator<String>.hasNext", "String.isEmpty"], "method_name": "CharSource.linesIterator", "method_implementation": "{\n    return new AbstractIterator<String>() {\n\n        Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n\n        @Override\n        @CheckForNull\n        protected String computeNext() {\n            if (lines.hasNext()) {\n                String next = lines.next();\n                // skip last line if it's empty\n                if (lines.hasNext() || !next.isEmpty()) {\n                    return next;\n                }\n            }\n            return endOfData();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an iterator over the lines in the string. If the string ends in a newline, a final\n * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().\n */\n", "repo_name": "guava-master/", "id": 4843, "method_signature": "Iterator<String> linesIterator()", "filename": "CharSource.linesIterator.json"}
{"callee_method_names": [], "method_name": "CharSource.openBufferedStream", "method_implementation": "{\n    Reader reader = openStream();\n    return (reader instanceof BufferedReader) ? (BufferedReader) reader : new BufferedReader(reader);\n}", "repo_id": "5", "comment": "/**\n * Opens a new {@link BufferedReader} for reading from this source. This method returns a new,\n * independent reader each time it is called.\n *\n * <p>The caller is responsible for ensuring that the returned reader is closed.\n *\n * @throws IOException if an I/O error occurs while of opening the reader\n */\n", "repo_name": "guava-master/", "id": 4833, "method_signature": "BufferedReader openBufferedStream()", "filename": "CharSource.openBufferedStream.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "Closer.rethrow", "Closer.close"], "method_name": "CharSource.read", "method_implementation": "{\n    Closer closer = Closer.create();\n    try {\n        Reader reader = closer.register(openStream());\n        return CharStreams.toString(reader);\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Reads the contents of this source as a string.\n *\n * @throws IOException if an I/O error occurs while reading from this source\n */\n", "repo_name": "guava-master/", "id": 4837, "method_signature": "String read()", "filename": "CharSource.read.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "BufferedReader.readLine", "Closer.rethrow", "Closer.close"], "method_name": "CharSource.readFirstLine", "method_implementation": "{\n    Closer closer = Closer.create();\n    try {\n        BufferedReader reader = closer.register(openBufferedStream());\n        return reader.readLine();\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Reads the first line of this source as a string. Returns {@code null} if this source is empty.\n *\n * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n * it does.\n *\n * @throws IOException if an I/O error occurs while reading from this source\n */\n", "repo_name": "guava-master/", "id": 4838, "method_signature": "String readFirstLine()", "filename": "CharSource.readFirstLine.json"}
{"callee_method_ids": [4848, 4851, 4852], "callee_method_names": ["Closer.register", "Closer.rethrow", "Closer.close"], "method_name": "CharSource.readLines", "method_implementation": "{\n    checkNotNull(processor);\n    Closer closer = Closer.create();\n    try {\n        Reader reader = closer.register(openStream());\n        return CharStreams.readLines(reader, processor);\n    } catch (Throwable e) {\n        throw closer.rethrow(e);\n    } finally {\n        closer.close();\n    }\n}", "repo_id": "5", "comment": "/**\n * Reads lines of text from this source, processing each line as it is read using the given {@link\n * LineProcessor processor}. Stops when all lines have been processed or the processor returns\n * {@code false} and returns the result produced by the processor.\n *\n * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n * it does.\n *\n * @throws IOException if an I/O error occurs while reading from this source or if {@code\n *     processor} throws an {@code IOException}\n * @since 16.0\n */\n", "repo_name": "guava-master/", "id": 4840, "method_signature": "T readLines(LineProcessor)", "filename": "CharSource.readLines.json"}
{"callee_method_names": [], "method_name": "CharSource.wrap", "method_implementation": "{\n    return charSequence instanceof String ? new StringCharSource((String) charSequence) : new CharSequenceCharSource(charSequence);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the given character sequence as a {@link CharSource}. The behavior of the\n * returned {@code CharSource} and any {@code Reader} instances created by it is unspecified if\n * the {@code charSequence} is mutated while it is being read, so don't do that.\n *\n * @since 15.0 (since 14.0 as {@code CharStreams.asCharSource(String)})\n */\n", "repo_name": "guava-master/", "id": 4842, "method_signature": "CharSource wrap(CharSequence)", "filename": "CharSource.wrap.json"}
{"callee_method_ids": [4836], "callee_method_names": ["CharSource.copyTo"], "method_name": "CharSourceTest.runSuppressionFailureTest", "method_implementation": "{\n    try {\n        in.copyTo(out);\n        fail();\n    } catch (IOException expected) {\n        return CloserTest.getSuppressed(expected).length;\n    }\n    // can't happen\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * @return the number of exceptions that were suppressed on the expected thrown exception\n */\n", "repo_name": "guava-master/", "id": 3645, "method_signature": "int runSuppressionFailureTest(CharSource, CharSink)", "filename": "CharSourceTest.runSuppressionFailureTest.json"}
{"callee_method_names": [], "method_name": "CharStreams.asWriter", "method_implementation": "{\n    if (target instanceof Writer) {\n        return (Writer) target;\n    }\n    return new AppendableWriter(target);\n}", "repo_id": "5", "comment": "/**\n * Returns a Writer that sends all output to the given {@link Appendable} target. Closing the\n * writer will close the target if it is {@link Closeable}, and flushing the writer will flush the\n * target if it is {@link java.io.Flushable}.\n *\n * @param target the object to which output will be sent\n * @return a new Writer object, unless target is a Writer, in which case the target is returned\n */\n", "repo_name": "guava-master/", "id": 4757, "method_signature": "Writer asWriter(Appendable)", "filename": "CharStreams.asWriter.json"}
{"callee_method_names": ["Readable.read", "Appendable.append", "CharBuffer.remaining"], "method_name": "CharStreams.copy", "method_implementation": "{\n    // The most common case is that from is a Reader (like InputStreamReader or StringReader) so\n    // take advantage of that.\n    if (from instanceof Reader) {\n        // optimize for common output types which are optimized to deal with char[]\n        if (to instanceof StringBuilder) {\n            return copyReaderToBuilder((Reader) from, (StringBuilder) to);\n        } else {\n            return copyReaderToWriter((Reader) from, asWriter(to));\n        }\n    }\n    checkNotNull(from);\n    checkNotNull(to);\n    long total = 0;\n    CharBuffer buf = createBuffer();\n    while (from.read(buf) != -1) {\n        Java8Compatibility.flip(buf);\n        to.append(buf);\n        total += buf.remaining();\n        Java8Compatibility.clear(buf);\n    }\n    return total;\n}", "repo_id": "5", "comment": "/**\n * Copies all characters between the {@link Readable} and {@link Appendable} objects. Does not\n * close or flush either object.\n *\n * @param from the object to read from\n * @param to the object to write to\n * @return the number of characters copied\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4749, "method_signature": "long copy(Readable, Appendable)", "filename": "CharStreams.copy.json"}
{"callee_method_names": ["Reader.read", "StringBuilder.append"], "method_name": "CharStreams.copyReaderToBuilder", "method_implementation": "{\n    checkNotNull(from);\n    checkNotNull(to);\n    char[] buf = new char[DEFAULT_BUF_SIZE];\n    int nRead;\n    long total = 0;\n    while ((nRead = from.read(buf)) != -1) {\n        to.append(buf, 0, nRead);\n        total += nRead;\n    }\n    return total;\n}", "repo_id": "5", "comment": "/**\n * Copies all characters between the {@link Reader} and {@link StringBuilder} objects. Does not\n * close or flush the reader.\n *\n * <p>This is identical to {@link #copy(Readable, Appendable)} but optimized for these specific\n * types. CharBuffer has poor performance when being written into or read out of so round tripping\n * all the bytes through the buffer takes a long time. With these specialized types we can just\n * use a char array.\n *\n * @param from the object to read from\n * @param to the object to write to\n * @return the number of characters copied\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4750, "method_signature": "long copyReaderToBuilder(Reader, StringBuilder)", "filename": "CharStreams.copyReaderToBuilder.json"}
{"callee_method_names": ["Reader.read", "Writer.write"], "method_name": "CharStreams.copyReaderToWriter", "method_implementation": "{\n    checkNotNull(from);\n    checkNotNull(to);\n    char[] buf = new char[DEFAULT_BUF_SIZE];\n    int nRead;\n    long total = 0;\n    while ((nRead = from.read(buf)) != -1) {\n        to.write(buf, 0, nRead);\n        total += nRead;\n    }\n    return total;\n}", "repo_id": "5", "comment": "/**\n * Copies all characters between the {@link Reader} and {@link Writer} objects. Does not close or\n * flush the reader or writer.\n *\n * <p>This is identical to {@link #copy(Readable, Appendable)} but optimized for these specific\n * types. CharBuffer has poor performance when being written into or read out of so round tripping\n * all the bytes through the buffer takes a long time. With these specialized types we can just\n * use a char array.\n *\n * @param from the object to read from\n * @param to the object to write to\n * @return the number of characters copied\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4751, "method_signature": "long copyReaderToWriter(Reader, Writer)", "filename": "CharStreams.copyReaderToWriter.json"}
{"callee_method_names": ["Readable.read"], "method_name": "CharStreams.exhaust", "method_implementation": "{\n    long total = 0;\n    long read;\n    CharBuffer buf = createBuffer();\n    while ((read = readable.read(buf)) != -1) {\n        total += read;\n        Java8Compatibility.clear(buf);\n    }\n    return total;\n}", "repo_id": "5", "comment": "/**\n * Reads and discards data from the given {@code Readable} until the end of the stream is reached.\n * Returns the total number of chars read. Does not close the stream.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4755, "method_signature": "long exhaust(Readable)", "filename": "CharStreams.exhaust.json"}
{"callee_method_ids": [4856], "callee_method_names": ["LineReader.readLine", "LineProcessor<T>.processLine", "LineProcessor<T>.getResult"], "method_name": "CharStreams.readLines", "method_implementation": "{\n    checkNotNull(readable);\n    checkNotNull(processor);\n    LineReader lineReader = new LineReader(readable);\n    String line;\n    while ((line = lineReader.readLine()) != null) {\n        if (!processor.processLine(line)) {\n            break;\n        }\n    }\n    return processor.getResult();\n}", "repo_id": "5", "comment": "/**\n * Streams lines from a {@link Readable} object, stopping when the processor returns {@code false}\n * or all lines have been read and returning the result produced by the processor. Does not close\n * {@code readable}. Note that this method may not fully consume the contents of {@code readable}\n * if the processor stops processing early.\n *\n * @throws IOException if an I/O error occurs\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4754, "method_signature": "T readLines(Readable, LineProcessor)", "filename": "CharStreams.readLines.json"}
{"callee_method_names": ["Reader.skip"], "method_name": "CharStreams.skipFully", "method_implementation": "{\n    checkNotNull(reader);\n    while (n > 0) {\n        long amt = reader.skip(n);\n        if (amt == 0) {\n            throw new EOFException();\n        }\n        n -= amt;\n    }\n}", "repo_id": "5", "comment": "/**\n * Discards {@code n} characters of data from the reader. This method will block until the full\n * amount has been skipped. Does not close the reader.\n *\n * @param reader the reader to read from\n * @param n the number of characters to skip\n * @throws EOFException if this stream reaches the end before skipping all the characters\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4756, "method_signature": "void skipFully(Reader, long)", "filename": "CharStreams.skipFully.json"}
{"callee_method_names": [], "method_name": "CharStreams.toStringBuilder", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    if (r instanceof Reader) {\n        copyReaderToBuilder((Reader) r, sb);\n    } else {\n        copy(r, sb);\n    }\n    return sb;\n}", "repo_id": "5", "comment": "/**\n * Reads all characters from a {@link Readable} object into a new {@link StringBuilder} instance.\n * Does not close the {@code Readable}.\n *\n * @param r the object to read from\n * @return a {@link StringBuilder} containing all the characters\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4752, "method_signature": "StringBuilder toStringBuilder(Readable)", "filename": "CharStreams.toStringBuilder.json"}
{"callee_method_ids": [4765], "callee_method_names": ["ByteSource.read"], "method_name": "CharStreamsTest.newNonBufferFillingReader", "method_implementation": "{\n    return new FilterReader(reader) {\n\n        @Override\n        public int read(char[] cbuf, int off, int len) throws IOException {\n            // if a buffer isn't being cleared correctly, this method will eventually start being called\n            // with a len of 0 forever\n            if (len <= 0) {\n                fail(\"read called with a len of \" + len);\n            }\n            // read fewer than the max number of chars to read\n            // shouldn't be a problem unless the buffer is shrinking each call\n            return in.read(cbuf, off, Math.max(len - 1024, 0));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a reader wrapping the given reader that only reads half of the maximum number of\n * characters that it could read in read(char[], int, int).\n */\n", "repo_name": "guava-master/", "id": 3642, "method_signature": "Reader newNonBufferFillingReader(Reader)", "filename": "CharStreamsTest.newNonBufferFillingReader.json"}
{"callee_method_names": ["StringBuilder.toString", "String.length"], "method_name": "CharStreamsTest.testCopyWithReaderThatDoesNotFillBuffer", "method_implementation": "{\n    // need a long enough string for the buffer to hit 0 remaining before the copy completes\n    String string = Strings.repeat(\"0123456789\", 100);\n    StringBuilder b = new StringBuilder();\n    // the main assertion of this test is here... the copy will fail if the buffer size goes down\n    // each time it is not filled completely\n    long copied = CharStreams.copy(newNonBufferFillingReader(new StringReader(string)), b);\n    assertEquals(string, b.toString());\n    assertEquals(string.length(), copied);\n}", "repo_id": "5", "comment": "/**\n * Test for Guava issue 1061: http://code.google.com/p/guava-libraries/issues/detail?id=1061\n *\n * <p>CharStreams.copy was failing to clear its CharBuffer after each read call, which effectively\n * reduced the available size of the buffer each time a call to read didn't fill up the available\n * space in the buffer completely. In general this is a performance problem since the buffer size\n * is permanently reduced, but with certain Reader implementations it could also cause the buffer\n * size to reach 0, causing an infinite loop.\n */\n", "repo_name": "guava-master/", "id": 3641, "method_signature": "void testCopyWithReaderThatDoesNotFillBuffer()", "filename": "CharStreamsTest.testCopyWithReaderThatDoesNotFillBuffer.json"}
{"callee_method_names": ["Appendable.append", "Appendable.append", "Appendable.append"], "method_name": "CharStreamsTest.wrapAsGenericAppendable", "method_implementation": "{\n    return new Appendable() {\n\n        @Override\n        public Appendable append(CharSequence csq) throws IOException {\n            a.append(csq);\n            return this;\n        }\n\n        @Override\n        public Appendable append(CharSequence csq, int start, int end) throws IOException {\n            a.append(csq, start, end);\n            return this;\n        }\n\n        @Override\n        public Appendable append(char c) throws IOException {\n            a.append(c);\n            return this;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Wrap an appendable in an appendable to defeat any type specific optimizations.\n */\n", "repo_name": "guava-master/", "id": 3643, "method_signature": "Appendable wrapAsGenericAppendable(Appendable)", "filename": "CharStreamsTest.wrapAsGenericAppendable.json"}
{"callee_method_names": ["Readable.read"], "method_name": "CharStreamsTest.wrapAsGenericReadable", "method_implementation": "{\n    return new Readable() {\n\n        @Override\n        public int read(CharBuffer cb) throws IOException {\n            return a.read(cb);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Wrap a readable in a readable to defeat any type specific optimizations.\n */\n", "repo_name": "guava-master/", "id": 3644, "method_signature": "Readable wrapAsGenericReadable(Readable)", "filename": "CharStreamsTest.wrapAsGenericReadable.json"}
{"callee_method_names": [], "method_name": "Chars.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new CharArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>The returned list maintains the values, but not the identities, of {@code Character} objects\n * written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for\n * the returned list is unspecified.\n *\n * <p>The returned list is serializable.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4450, "method_signature": "List<Character> asList(char[])", "filename": "Chars.asList.json"}
{"callee_method_names": [], "method_name": "Chars.checkedCast", "method_implementation": "{\n    char result = (char) value;\n    checkArgument(result == value, \"Out of range: %s\", value);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code char} value that is equal to {@code value}, if possible.\n *\n * @param value any value in the range of the {@code char} type\n * @return the {@code char} value that equals {@code value}\n * @throws IllegalArgumentException if {@code value} is greater than {@link Character#MAX_VALUE}\n *     or less than {@link Character#MIN_VALUE}\n */\n", "repo_name": "guava-master/", "id": 4434, "method_signature": "char checkedCast(long)", "filename": "Chars.checkedCast.json"}
{"callee_method_names": [], "method_name": "Chars.concat", "method_implementation": "{\n    int length = 0;\n    for (char[] array : arrays) {\n        length += array.length;\n    }\n    char[] result = new char[length];\n    int pos = 0;\n    for (char[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new char[] {a, b}, new char[] {}, new char[] {c}} returns the array {@code {a, b, c}}.\n *\n * @param arrays zero or more {@code char} arrays\n * @return a single array containing all the values from the source arrays, in order\n */\n", "repo_name": "guava-master/", "id": 4442, "method_signature": "char[] concat(char[][])", "filename": "Chars.concat.json"}
{"callee_method_names": [], "method_name": "Chars.contains", "method_implementation": "{\n    for (char value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.\n *\n * @param array an array of {@code char} values, possibly empty\n * @param target a primitive {@code char} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4436, "method_signature": "boolean contains(char[], char)", "filename": "Chars.contains.json"}
{"callee_method_names": [], "method_name": "Chars.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4444, "method_signature": "char[] ensureCapacity(char[], int, int)", "filename": "Chars.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Chars.fromByteArray", "method_implementation": "{\n    checkArgument(bytes.length >= BYTES, \"array too small: %s < %s\", bytes.length, BYTES);\n    return fromBytes(bytes[0], bytes[1]);\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code char} value whose big-endian representation is stored in the first 2 bytes\n * of {@code bytes}; equivalent to {@code ByteBuffer.wrap(bytes).getChar()}. For example, the\n * input byte array {@code {0x54, 0x32}} would yield the {@code char} value {@code '\\\\u5432'}.\n *\n * <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that library exposes much more\n * flexibility at little cost in readability.\n *\n * @throws IllegalArgumentException if {@code bytes} has fewer than 2 elements\n */\n", "repo_name": "guava-master/", "id": 4443, "method_signature": "char fromByteArray(byte[])", "filename": "Chars.fromByteArray.json"}
{"callee_method_names": [], "method_name": "Chars.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4438, "method_signature": "int indexOf(char[], char[])", "filename": "Chars.indexOf.json"}
{"callee_method_names": ["String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Chars.join", "method_implementation": "{\n    checkNotNull(separator);\n    int len = array.length;\n    if (len == 0) {\n        return \"\";\n    }\n    StringBuilder builder = new StringBuilder(len + separator.length() * (len - 1));\n    builder.append(array[0]);\n    for (int i = 1; i < len; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code char} values separated by {@code separator}.\n * For example, {@code join(\"-\", '1', '2', '3')} returns the string {@code \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code char} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4445, "method_signature": "String join(String, char[])", "filename": "Chars.join.json"}
{"callee_method_names": [], "method_name": "Chars.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4439, "method_signature": "int lastIndexOf(char[], char, int, int)", "filename": "Chars.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Chars.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    char max = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code char} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4441, "method_signature": "char max(char[])", "filename": "Chars.max.json"}
{"callee_method_names": [], "method_name": "Chars.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    char min = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] < min) {\n            min = array[i];\n        }\n    }\n    return min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code char} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4440, "method_signature": "char min(char[])", "filename": "Chars.min.json"}
{"callee_method_names": [], "method_name": "Chars.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        char tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Chars.asList(array).subList(fromIndex, toIndex))}, but is likely to be more\n * efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4448, "method_signature": "void reverse(char[], int, int)", "filename": "Chars.reverse.json"}
{"callee_method_names": [], "method_name": "Chars.rotate", "method_implementation": "{\n    // See Ints.rotate for more details about possible algorithms here.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Chars.asList(array).subList(fromIndex, toIndex), distance)}, but is\n * considerably faster and avoids allocations and garbage collection.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4449, "method_signature": "void rotate(char[], int, int, int)", "filename": "Chars.rotate.json"}
{"callee_method_names": [], "method_name": "Chars.saturatedCast", "method_implementation": "{\n    if (value > Character.MAX_VALUE) {\n        return Character.MAX_VALUE;\n    }\n    if (value < Character.MIN_VALUE) {\n        return Character.MIN_VALUE;\n    }\n    return (char) value;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code char} nearest in value to {@code value}.\n *\n * @param value any {@code long} value\n * @return the same value cast to {@code char} if it is in the range of the {@code char} type,\n *     {@link Character#MAX_VALUE} if it is too large, or {@link Character#MIN_VALUE} if it is too\n *     small\n */\n", "repo_name": "guava-master/", "id": 4435, "method_signature": "char saturatedCast(long)", "filename": "Chars.saturatedCast.json"}
{"callee_method_names": [], "method_name": "Chars.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    Arrays.sort(array, fromIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4447, "method_signature": "void sortDescending(char[], int, int)", "filename": "Chars.sortDescending.json"}
{"callee_method_names": ["Collection<Character>.toArray"], "method_name": "Chars.toArray", "method_implementation": "{\n    if (collection instanceof CharArrayAsList) {\n        return ((CharArrayAsList) collection).toCharArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    char[] array = new char[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = (Character) checkNotNull(boxedArray[i]);\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Copies a collection of {@code Character} instances into a new array of primitive {@code char}\n * values.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * @param collection a collection of {@code Character} objects\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n */\n", "repo_name": "guava-master/", "id": 4446, "method_signature": "char[] toArray(Collection)", "filename": "Chars.toArray.json"}
{"callee_method_names": ["List<Character>.subList", "List<Character>.subList"], "method_name": "CharsTest.testAsList_subList_toArray_roundTrip", "method_implementation": "{\n    char[] array = { (char) 0, (char) 1, (char) 2, (char) 3 };\n    List<Character> list = Chars.asList(array);\n    assertThat(Chars.toArray(list.subList(1, 3))).isEqualTo(new char[] { (char) 1, (char) 2 });\n    assertThat(Chars.toArray(list.subList(2, 2))).isEqualTo(new char[] {});\n}", "repo_id": "5", "comment": "// This test stems from a real bug found by andrewk\n", "repo_name": "guava-master/", "id": 3561, "method_signature": "void testAsList_subList_toArray_roundTrip()", "filename": "CharsTest.testAsList_subList_toArray_roundTrip.json"}
{"callee_method_names": ["String.lastIndexOf", "String.substring", "String.isEmpty", "String.substring", "String.length"], "method_name": "ClassInfo.getSimpleName", "method_implementation": "{\n    int lastDollarSign = className.lastIndexOf('$');\n    if (lastDollarSign != -1) {\n        String innerClassName = className.substring(lastDollarSign + 1);\n        // local and anonymous classes are prefixed with number (1,2,3...), anonymous classes are\n        // entirely numeric whereas local classes have the user supplied name as a suffix\n        return CharMatcher.inRange('0', '9').trimLeadingFrom(innerClassName);\n    }\n    String packageName = getPackageName();\n    if (packageName.isEmpty()) {\n        return className;\n    }\n    // Since this is a top level class, its simple name is always the part after package name.\n    return className.substring(packageName.length() + 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the simple name of the underlying class as given in the source code.\n *\n * <p>Behaves similarly to {@link Class#getSimpleName()} but does not require the class to be\n * loaded.\n *\n * <p>But note that this class uses heuristics to identify the simple name. See a related\n * discussion in <a href=\"https://github.com/google/guava/issues/3349\">issue 3349</a>.\n */\n", "repo_name": "guava-master/", "id": 4709, "method_signature": "String getSimpleName()", "filename": "ClassInfo.getSimpleName.json"}
{"callee_method_names": ["ClassLoader.loadClass"], "method_name": "ClassInfo.load", "method_implementation": "{\n    try {\n        return loader.loadClass(className);\n    } catch (ClassNotFoundException e) {\n        // Shouldn't happen, since the class name is read from the class path.\n        throw new IllegalStateException(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Loads (but doesn't link or initialize) the class.\n *\n * @throws LinkageError when there were errors in loading classes that this class depends on.\n *     For example, {@link NoClassDefFoundError}.\n */\n", "repo_name": "guava-master/", "id": 4710, "method_signature": "Class<?> load()", "filename": "ClassInfo.load.json"}
{"callee_method_names": ["Set<File>.add", "ImmutableSet.Builder<ResourceInfo>.addAll", "ImmutableSet.Builder<ResourceInfo>.build"], "method_name": "ClassPath.from", "method_implementation": "{\n    ImmutableSet<LocationInfo> locations = locationsFrom(classloader);\n    // Add all locations to the scanned set so that in a classpath [jar1, jar2], where jar1 has a\n    // manifest with Class-Path pointing to jar2, we won't scan jar2 twice.\n    Set<File> scanned = new HashSet<>();\n    for (LocationInfo location : locations) {\n        scanned.add(location.file());\n    }\n    // Scan all locations\n    ImmutableSet.Builder<ResourceInfo> builder = ImmutableSet.builder();\n    for (LocationInfo location : locations) {\n        builder.addAll(location.scanResources(scanned));\n    }\n    return new ClassPath(builder.build());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code ClassPath} representing all classes and resources loadable from {@code\n * classloader} and its ancestor class loaders.\n *\n * <p><b>Warning:</b> {@code ClassPath} can find classes and resources only from:\n *\n * <ul>\n *   <li>{@link URLClassLoader} instances' {@code file:} URLs\n *   <li>the {@linkplain ClassLoader#getSystemClassLoader() system class loader}. To search the\n *       system class loader even when it is not a {@link URLClassLoader} (as in Java 9), {@code\n *       ClassPath} searches the files from the {@code java.class.path} system property.\n * </ul>\n *\n * @throws IOException if the attempt to read class path resources (jar files or directories)\n *     failed.\n */\n", "repo_name": "guava-master/", "id": 4695, "method_signature": "ClassPath from(ClassLoader)", "filename": "ClassPath.from.json"}
{"callee_method_ids": [5001], "callee_method_names": ["Manifest.getMainAttributes", "Splitter.split", "Logger.warning", "URL.getProtocol", "ImmutableSet.Builder<File>.add", "ImmutableSet.Builder<File>.build"], "method_name": "ClassPath.getClassPathFromManifest", "method_implementation": "{\n    if (manifest == null) {\n        return ImmutableSet.of();\n    }\n    ImmutableSet.Builder<File> builder = ImmutableSet.builder();\n    String classpathAttribute = manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH.toString());\n    if (classpathAttribute != null) {\n        for (String path : CLASS_PATH_ATTRIBUTE_SEPARATOR.split(classpathAttribute)) {\n            URL url;\n            try {\n                url = getClassPathEntry(jarFile, path);\n            } catch (MalformedURLException e) {\n                // Ignore bad entry\n                logger.warning(\"Invalid Class-Path entry: \" + path);\n                continue;\n            }\n            if (url.getProtocol().equals(\"file\")) {\n                builder.add(toFile(url));\n            }\n        }\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns the class path URIs specified by the {@code Class-Path} manifest attribute, according\n * to <a\n * href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Main_Attributes\">JAR\n * File Specification</a>. If {@code manifest} is null, it means the jar file has no manifest, and\n * an empty set will be returned.\n */\n", "repo_name": "guava-master/", "id": 4705, "method_signature": "ImmutableSet<File> getClassPathFromManifest(File, Manifest)", "filename": "ClassPath.getClassPathFromManifest.json"}
{"callee_method_names": ["String.lastIndexOf", "String.substring", "String.isEmpty", "String.substring", "String.length"], "method_name": "ClassPath.getSimpleName", "method_implementation": "{\n    int lastDollarSign = className.lastIndexOf('$');\n    if (lastDollarSign != -1) {\n        String innerClassName = className.substring(lastDollarSign + 1);\n        // local and anonymous classes are prefixed with number (1,2,3...), anonymous classes are\n        // entirely numeric whereas local classes have the user supplied name as a suffix\n        return CharMatcher.inRange('0', '9').trimLeadingFrom(innerClassName);\n    }\n    String packageName = getPackageName();\n    if (packageName.isEmpty()) {\n        return className;\n    }\n    // Since this is a top level class, its simple name is always the part after package name.\n    return className.substring(packageName.length() + 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the simple name of the underlying class as given in the source code.\n *\n * <p>Behaves similarly to {@link Class#getSimpleName()} but does not require the class to be\n * loaded.\n *\n * <p>But note that this class uses heuristics to identify the simple name. See a related\n * discussion in <a href=\"https://github.com/google/guava/issues/3349\">issue 3349</a>.\n */\n", "repo_name": "guava-master/", "id": 4700, "method_signature": "String getSimpleName()", "filename": "ClassPath.getSimpleName.json"}
{"callee_method_names": ["ImmutableSet.Builder<ClassInfo>.add", "ImmutableSet.Builder<ClassInfo>.build"], "method_name": "ClassPath.getTopLevelClasses", "method_implementation": "{\n    checkNotNull(packageName);\n    ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();\n    for (ClassInfo classInfo : getTopLevelClasses()) {\n        if (classInfo.getPackageName().equals(packageName)) {\n            builder.add(classInfo);\n        }\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns all top level classes whose package name is {@code packageName}.\n */\n", "repo_name": "guava-master/", "id": 4697, "method_signature": "ImmutableSet<ClassInfo> getTopLevelClasses(String)", "filename": "ClassPath.getTopLevelClasses.json"}
{"callee_method_names": ["ImmutableSet.Builder<ClassInfo>.add", "ImmutableSet.Builder<ClassInfo>.build"], "method_name": "ClassPath.getTopLevelClassesRecursive", "method_implementation": "{\n    checkNotNull(packageName);\n    String packagePrefix = packageName + '.';\n    ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();\n    for (ClassInfo classInfo : getTopLevelClasses()) {\n        if (classInfo.getName().startsWith(packagePrefix)) {\n            builder.add(classInfo);\n        }\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns all top level classes whose package name is {@code packageName} or starts with {@code\n * packageName} followed by a '.'.\n */\n", "repo_name": "guava-master/", "id": 4698, "method_signature": "ImmutableSet<ClassInfo> getTopLevelClassesRecursive(String)", "filename": "ClassPath.getTopLevelClassesRecursive.json"}
{"callee_method_names": ["ClassLoader.loadClass"], "method_name": "ClassPath.load", "method_implementation": "{\n    try {\n        return loader.loadClass(className);\n    } catch (ClassNotFoundException e) {\n        // Shouldn't happen, since the class name is read from the class path.\n        throw new IllegalStateException(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Loads (but doesn't link or initialize) the class.\n *\n * @throws LinkageError when there were errors in loading classes that this class depends on.\n *     For example, {@link NoClassDefFoundError}.\n */\n", "repo_name": "guava-master/", "id": 4701, "method_signature": "Class<?> load()", "filename": "ClassPath.load.json"}
{"callee_method_names": ["ImmutableSet.Builder<LocationInfo>.add", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue", "ImmutableSet.Builder<LocationInfo>.build"], "method_name": "ClassPath.locationsFrom", "method_implementation": "{\n    ImmutableSet.Builder<LocationInfo> builder = ImmutableSet.builder();\n    for (Map.Entry<File, ClassLoader> entry : getClassPathEntries(classloader).entrySet()) {\n        builder.add(new LocationInfo(entry.getKey(), entry.getValue()));\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns all locations that {@code classloader} and parent loaders load classes and resources\n * from. Callers can {@linkplain LocationInfo#scanResources scan} individual locations selectively\n * or even in parallel.\n */\n", "repo_name": "guava-master/", "id": 4702, "method_signature": "ImmutableSet<LocationInfo> locationsFrom(ClassLoader)", "filename": "ClassPath.locationsFrom.json"}
{"callee_method_names": ["ImmutableList.Builder<URL>.add", "ImmutableList.Builder<URL>.add", "Logger.log", "ImmutableList.Builder<URL>.build"], "method_name": "ClassPath.parseJavaClassPath", "method_implementation": "{\n    ImmutableList.Builder<URL> urls = ImmutableList.builder();\n    for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n        try {\n            try {\n                urls.add(new File(entry).toURI().toURL());\n            } catch (SecurityException e) {\n                // File.toURI checks to see if the file is a directory\n                urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n            }\n        } catch (MalformedURLException e) {\n            logger.log(WARNING, \"malformed classpath entry: \" + entry, e);\n        }\n    }\n    return urls.build();\n}", "repo_id": "5", "comment": "/**\n * Returns the URLs in the class path specified by the {@code java.class.path} {@linkplain\n * System#getProperty system property}.\n */\n", "repo_name": "guava-master/", "id": 4706, "method_signature": "ImmutableList<URL> parseJavaClassPath()", "filename": "ClassPath.parseJavaClassPath.json"}
{"callee_method_names": ["File.listFiles", "Logger.warning", "Set<File>.add", "Set<File>.remove", "String.equals", "ImmutableSet.Builder<ResourceInfo>.add"], "method_name": "ClassPath.scanDirectory", "method_implementation": "{\n    File[] files = directory.listFiles();\n    if (files == null) {\n        logger.warning(\"Cannot read directory \" + directory);\n        // IO error, just skip the directory\n        return;\n    }\n    for (File f : files) {\n        String name = f.getName();\n        if (f.isDirectory()) {\n            File deref = f.getCanonicalFile();\n            if (currentPath.add(deref)) {\n                scanDirectory(deref, packagePrefix + name + \"/\", currentPath, builder);\n                currentPath.remove(deref);\n            }\n        } else {\n            String resourceName = packagePrefix + name;\n            if (!resourceName.equals(JarFile.MANIFEST_NAME)) {\n                builder.add(ResourceInfo.of(f, resourceName, classloader));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Recursively scan the given directory, adding resources for each file encountered. Symlinks\n * which have already been traversed in the current tree path will be skipped to eliminate\n * cycles; otherwise symlinks are traversed.\n *\n * @param directory the root of the directory to scan\n * @param packagePrefix resource path prefix inside {@code classloader} for any files found\n *     under {@code directory}\n * @param currentPath canonical files already visited in the current directory tree path, for\n *     cycle elimination\n */\n", "repo_name": "guava-master/", "id": 4704, "method_signature": "void scanDirectory(File, String, Set, ImmutableSet.Builder)", "filename": "ClassPath.scanDirectory.json"}
{"callee_method_names": ["Set<File>.add", "ImmutableSet.Builder<ResourceInfo>.build"], "method_name": "ClassPath.scanResources", "method_implementation": "{\n    ImmutableSet.Builder<ResourceInfo> builder = ImmutableSet.builder();\n    scannedFiles.add(home);\n    scan(home, scannedFiles, builder);\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Scans this location and returns all scanned resources.\n *\n * <p>This file and jar files from \"Class-Path\" entry in the scanned manifest files will be\n * added to {@code scannedFiles}.\n *\n * <p>A file will be scanned at most once even if specified multiple times by one or multiple\n * jar files' \"Class-Path\" manifest entries. Particularly, if a jar file from the \"Class-Path\"\n * manifest entry is already in {@code scannedFiles}, either because it was scanned earlier, or\n * it was intentionally added to the set by the caller, it will not be scanned again.\n *\n * <p>Note that when you call {@code location.scanResources(scannedFiles)}, the location will\n * always be scanned even if {@code scannedFiles} already contains it.\n */\n", "repo_name": "guava-master/", "id": 4703, "method_signature": "ImmutableSet<ResourceInfo> scanResources(Set)", "filename": "ClassPath.scanResources.json"}
{"callee_method_names": ["URL.getProtocol", "URL.toURI", "URL.getPath"], "method_name": "ClassPath.toFile", "method_implementation": "{\n    checkArgument(url.getProtocol().equals(\"file\"));\n    try {\n        // Accepts escaped characters like %20.\n        return new File(url.toURI());\n    } catch (URISyntaxException e) {\n        // URL.toURI() doesn't escape chars.\n        // Accepts non-escaped chars like space.\n        return new File(url.getPath());\n    }\n}", "repo_id": "5", "comment": "// TODO(benyu): Try java.nio.file.Paths#get() when Guava drops JDK 6 support.\n", "repo_name": "guava-master/", "id": 4707, "method_signature": "File toFile(URL)", "filename": "ClassPath.toFile.json"}
{"callee_method_names": ["ClassLoader.getResource"], "method_name": "ClassPath.url", "method_implementation": "{\n    URL url = loader.getResource(resourceName);\n    if (url == null) {\n        throw new NoSuchElementException(resourceName);\n    }\n    return url;\n}", "repo_id": "5", "comment": "/**\n * Returns the url identifying the resource.\n *\n * <p>See {@link ClassLoader#getResource}\n *\n * @throws NoSuchElementException if the resource cannot be loaded through the class loader,\n *     despite physically existing in the class path.\n */\n", "repo_name": "guava-master/", "id": 4699, "method_signature": "URL url()", "filename": "ClassPath.url.json"}
{"callee_method_names": [], "method_name": "ClassPathTest.testToFile", "method_implementation": "{\n    assertThat(ClassPath.toFile(new URL(\"file:///c:/Documents%20and%20Settings/\"))).isEqualTo(new File(\"/c:/Documents and Settings/\"));\n    assertThat(ClassPath.toFile(new URL(\"file:///c:/Documents ~ Settings, or not/11-12 12:05\"))).isEqualTo(new File(\"/c:/Documents ~ Settings, or not/11-12 12:05\"));\n}", "repo_id": "5", "comment": "// https://github.com/google/guava/issues/2152\n", "repo_name": "guava-master/", "id": 3612, "method_signature": "void testToFile()", "filename": "ClassPathTest.testToFile.json"}
{"callee_method_names": [], "method_name": "ClassPathTest.testToFile_AndroidIncompatible", "method_implementation": "{\n    assertThat(ClassPath.toFile(new URL(\"file:///c:\\\\Documents ~ Settings, or not\\\\11-12 12:05\"))).isEqualTo(new File(\"/c:\\\\Documents ~ Settings, or not\\\\11-12 12:05\"));\n    assertThat(ClassPath.toFile(new URL(\"file:///C:\\\\Program Files\\\\Apache Software Foundation\"))).isEqualTo(new File(\"/C:\\\\Program Files\\\\Apache Software Foundation/\"));\n    // Chinese Ni Hao\n    assertThat(ClassPath.toFile(new URL(\"file:///C:\\\\\\u20320 \\u22909\"))).isEqualTo(new File(\"/C:\\\\\\u20320 \\u22909\"));\n}", "repo_id": "5", "comment": "// https://github.com/google/guava/issues/2152\n", "repo_name": "guava-master/", "id": 3613, "method_signature": "void testToFile_AndroidIncompatible()", "filename": "ClassPathTest.testToFile_AndroidIncompatible.json"}
{"callee_method_names": [], "method_name": "ClassPathUtil.getClassPathUrls", "method_implementation": "{\n    return ClassPathUtil.class.getClassLoader() instanceof URLClassLoader ? ((URLClassLoader) ClassPathUtil.class.getClassLoader()).getURLs() : parseJavaClassPath();\n}", "repo_id": "5", "comment": "/**\n * Returns the URLs in the class path.\n */\n", "repo_name": "guava-master/", "id": 3879, "method_signature": "URL[] getClassPathUrls()", "filename": "ClassPathUtil.getClassPathUrls.json"}
{"callee_method_names": ["ImmutableList.Builder<URL>.add", "ImmutableList.Builder<URL>.add", "AssertionError.initCause", "ImmutableList.Builder<URL>.build"], "method_name": "ClassPathUtil.parseJavaClassPath", "method_implementation": "{\n    ImmutableList.Builder<URL> urls = ImmutableList.builder();\n    for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n        try {\n            try {\n                urls.add(new File(entry).toURI().toURL());\n            } catch (SecurityException e) {\n                // File.toURI checks to see if the file is a directory\n                urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n            }\n        } catch (MalformedURLException e) {\n            AssertionError error = new AssertionError(\"malformed class path entry: \" + entry);\n            error.initCause(e);\n            throw error;\n        }\n    }\n    return urls.build().toArray(new URL[0]);\n}", "repo_id": "5", "comment": "// TODO(b/65488446): Make this a public API.\n", "repo_name": "guava-master/", "id": 3878, "method_signature": "URL[] parseJavaClassPath()", "filename": "ClassPathUtil.parseJavaClassPath.json"}
{"callee_method_names": ["Class<?>.getDeclaredMethods", "Invokable<?, ?>.setAccessible", "Invokable<?, ?>.isPublic", "Invokable<?, ?>.isStatic", "Invokable<?, ?>.isSynthetic", "ImmutableList.Builder<Invokable<?, ?>>.add", "ImmutableList.Builder<Invokable<?, ?>>.build"], "method_name": "ClassSanityTester.forAllPublicStaticMethods", "method_implementation": "{\n    ImmutableList.Builder<Invokable<?, ?>> builder = ImmutableList.builder();\n    for (Method method : cls.getDeclaredMethods()) {\n        Invokable<?, ?> invokable = Invokable.from(method);\n        invokable.setAccessible(true);\n        if (invokable.isPublic() && invokable.isStatic() && !invokable.isSynthetic()) {\n            builder.add(invokable);\n        }\n    }\n    return new FactoryMethodReturnValueTester(cls, builder.build(), \"public static methods\");\n}", "repo_id": "5", "comment": "/**\n * Returns an object responsible for performing sanity tests against the return values of all\n * public static methods declared by {@code cls}, excluding superclasses.\n */\n", "repo_name": "guava-master/", "id": 4092, "method_signature": "FactoryMethodReturnValueTester forAllPublicStaticMethods(Class)", "filename": "ClassSanityTester.forAllPublicStaticMethods.json"}
{"callee_method_names": ["List<Object>.size", "List<Parameter>.get", "List<Object>.get", "List<Object>.set"], "method_name": "ClassSanityTester.generateEqualFactoryArguments", "method_implementation": "{\n    List<Object> equalArgs = Lists.newArrayList(args);\n    for (int i = 0; i < args.size(); i++) {\n        Parameter param = params.get(i);\n        Object arg = args.get(i);\n        // Use new fresh value generator because 'args' were populated with new fresh generator each.\n        // Two newFreshValueGenerator() instances should normally generate equal value sequence.\n        Object shouldBeEqualArg = generateDummyArg(param, newFreshValueGenerator());\n        if (arg != shouldBeEqualArg && Objects.equal(arg, shouldBeEqualArg) && hashCodeInsensitiveToArgReference(factory, args, i, checkNotNull(shouldBeEqualArg)) && hashCodeInsensitiveToArgReference(factory, args, i, generateDummyArg(param, newFreshValueGenerator()))) {\n            // If the implementation uses identityHashCode(), referential equality is\n            // probably intended. So no point in using an equal-but-different factory argument.\n            // We check twice to avoid confusion caused by accidental hash collision.\n            equalArgs.set(i, shouldBeEqualArg);\n        }\n    }\n    return equalArgs;\n}", "repo_id": "5", "comment": "/**\n * Returns dummy factory arguments that are equal to {@code args} but may be different instances,\n * to be used to construct a second instance of the same equality group.\n */\n", "repo_name": "guava-master/", "id": 4098, "method_signature": "List<Object> generateEqualFactoryArguments(Invokable, List, List)", "filename": "ClassSanityTester.generateEqualFactoryArguments.json"}
{"callee_method_ids": [6316], "callee_method_names": ["TypeToken<T>.getRawType", "TypeToken<T>.method", "Invokable<T, T>.isPrivate", "Invokable<T, T>.isSynthetic", "Invokable<T, T>.isStatic", "TypeToken<T>.isSupertypeOf", "Invokable<T, T>.getReturnType", "List<Invokable<?, ? extends T>>.add", "TypeToken<T>.getRawType", "TypeToken<T>.getRawType", "TypeToken<T>.constructor", "Invokable<T, T>.isPrivate", "Invokable<T, T>.isSynthetic", "List<Invokable<?, ? extends T>>.add", "Invokable<?, ? extends T>.setAccessible", "Ordering.compound"], "method_name": "ClassSanityTester.getFactories", "method_implementation": "{\n    List<Invokable<?, ? extends T>> factories = Lists.newArrayList();\n    for (Method method : type.getRawType().getDeclaredMethods()) {\n        Invokable<?, ?> invokable = type.method(method);\n        if (!invokable.isPrivate() && !invokable.isSynthetic() && invokable.isStatic() && type.isSupertypeOf(invokable.getReturnType())) {\n            // guarded by isAssignableFrom()\n            @SuppressWarnings(\"unchecked\")\n            Invokable<?, ? extends T> factory = (Invokable<?, ? extends T>) invokable;\n            factories.add(factory);\n        }\n    }\n    if (!Modifier.isAbstract(type.getRawType().getModifiers())) {\n        for (Constructor<?> constructor : type.getRawType().getDeclaredConstructors()) {\n            Invokable<T, T> invokable = type.constructor(constructor);\n            if (!invokable.isPrivate() && !invokable.isSynthetic()) {\n                factories.add(invokable);\n            }\n        }\n    }\n    for (Invokable<?, ?> factory : factories) {\n        factory.setAccessible(true);\n    }\n    // Sorts methods/constructors with the least number of parameters first since it's likely easier\n    // to fill dummy parameter values for them. Ties are broken by name then by the string form of\n    // the parameter list.\n    return BY_NUMBER_OF_PARAMETERS.compound(BY_METHOD_NAME).compound(BY_PARAMETERS).immutableSortedCopy(factories);\n}", "repo_id": "5", "comment": "/**\n * Factories with the least number of parameters are listed first.\n */\n", "repo_name": "guava-master/", "id": 4100, "method_signature": "ImmutableList<Invokable<?,? extends T>> getFactories(TypeToken)", "filename": "ClassSanityTester.getFactories.json"}
{"callee_method_names": ["Class<T>.isEnum", "Class<T>.getEnumConstants", "List<ParameterNotInstantiableException>.add", "List<InvocationTargetException>.add", "List<FactoryMethodReturnsNullException>.add"], "method_name": "ClassSanityTester.instantiate", "method_implementation": "{\n    if (cls.isEnum()) {\n        T[] constants = cls.getEnumConstants();\n        if (constants != null && constants.length > 0) {\n            return constants[0];\n        } else {\n            return null;\n        }\n    }\n    TypeToken<T> type = TypeToken.of(cls);\n    List<ParameterNotInstantiableException> paramErrors = Lists.newArrayList();\n    List<InvocationTargetException> instantiationExceptions = Lists.newArrayList();\n    List<FactoryMethodReturnsNullException> nullErrors = Lists.newArrayList();\n    for (Invokable<?, ? extends T> factory : getFactories(type)) {\n        T instance;\n        try {\n            instance = instantiate(factory);\n        } catch (ParameterNotInstantiableException e) {\n            paramErrors.add(e);\n            continue;\n        } catch (InvocationTargetException e) {\n            instantiationExceptions.add(e);\n            continue;\n        }\n        if (instance == null) {\n            nullErrors.add(new FactoryMethodReturnsNullException(factory));\n        } else {\n            return instance;\n        }\n    }\n    throwFirst(paramErrors);\n    throwFirst(instantiationExceptions);\n    throwFirst(nullErrors);\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Instantiates {@code cls} by invoking one of its non-private constructors or non-private static\n * factory methods with the parameters automatically provided using dummy values.\n *\n * @return The instantiated instance, or {@code null} if the class has no non-private constructor\n *     or factory method to be constructed.\n */\n", "repo_name": "guava-master/", "id": 4091, "method_signature": "T instantiate(Class)", "filename": "ClassSanityTester.instantiate.json"}
{"callee_method_names": ["ListMultimap<Class<?>, Object>.asMap", "FreshValueGenerator.addSampleInstances", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue"], "method_name": "ClassSanityTester.newFreshValueGenerator", "method_implementation": "{\n    FreshValueGenerator generator = new FreshValueGenerator() {\n\n        @Override\n        Object interfaceMethodCalled(Class<?> interfaceType, Method method) {\n            return getDummyValue(TypeToken.of(interfaceType).method(method).getReturnType());\n        }\n    };\n    for (Entry<Class<?>, Collection<Object>> entry : distinctValues.asMap().entrySet()) {\n        generator.addSampleInstances((Class) entry.getKey(), entry.getValue());\n    }\n    return generator;\n}", "repo_id": "5", "comment": "// structure to hold the mappings.\n", "repo_name": "guava-master/", "id": 4099, "method_signature": "FreshValueGenerator newFreshValueGenerator()", "filename": "ClassSanityTester.newFreshValueGenerator.json"}
{"callee_method_ids": [4120], "callee_method_names": ["NullPointerTester.setDefault", "MutableClassToInstanceMap<Object>.putInstance"], "method_name": "ClassSanityTester.setDefault", "method_implementation": "{\n    nullPointerTester.setDefault(type, value);\n    defaultValues.putInstance(type, value);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the default value for {@code type}. The default value isn't used in testing {@link\n * Object#equals} because more than one sample instances are needed for testing inequality. To set\n * distinct values for equality testing, use {@link #setDistinctValues} instead.\n */\n", "repo_name": "guava-master/", "id": 4087, "method_signature": "ClassSanityTester setDefault(Class, T)", "filename": "ClassSanityTester.setDefault.json"}
{"callee_method_names": ["ListMultimap<Class<?>, Object>.replaceValues"], "method_name": "ClassSanityTester.setDistinctValues", "method_implementation": "{\n    checkNotNull(type);\n    checkNotNull(value1);\n    checkNotNull(value2);\n    checkArgument(!Objects.equal(value1, value2), \"Duplicate value provided.\");\n    distinctValues.replaceValues(type, ImmutableList.of(value1, value2));\n    setDefault(type, value1);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets distinct values for {@code type}, so that when a class {@code Foo} is tested for {@link\n * Object#equals} and {@link Object#hashCode}, and its construction requires a parameter of {@code\n * type}, the distinct values of {@code type} can be passed as parameters to create {@code Foo}\n * instances that are unequal.\n *\n * <p>Calling {@code setDistinctValues(type, v1, v2)} also sets the default value for {@code type}\n * that's used for {@link #testNulls}.\n *\n * <p>Only necessary for types where {@link ClassSanityTester} doesn't already know how to create\n * distinct values.\n *\n * @return this tester instance\n * @since 17.0\n */\n", "repo_name": "guava-master/", "id": 4088, "method_signature": "ClassSanityTester setDistinctValues(Class, T, T)", "filename": "ClassSanityTester.setDistinctValues.json"}
{"callee_method_names": [], "method_name": "ClassSanityTester.testEquals", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        try {\n            testEqualsUsing(factory);\n        } catch (FactoryMethodReturnsNullException e) {\n            // If the factory returns null, we just skip it.\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Tests {@link Object#equals} and {@link Object#hashCode} against the return values of the\n * static methods, by asserting that when equal parameters are passed to the same static method,\n * the return value should also be equal; and vice versa.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4095, "method_signature": "FactoryMethodReturnValueTester testEquals()", "filename": "ClassSanityTester.testEquals.json"}
{"callee_method_names": ["AssertionError.initCause", "UnicodeEscaper.getCause", "AssertionError.initCause"], "method_name": "ClassSanityTester.testEqualsAndSerializable", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        try {\n            testEqualsUsing(factory);\n        } catch (FactoryMethodReturnsNullException e) {\n            // If the factory returns null, we just skip it.\n        }\n        Object instance = instantiate(factory);\n        if (instance != null) {\n            try {\n                SerializableTester.reserializeAndAssert(instance);\n            } catch (Exception e) {\n                // sneaky checked exception\n                AssertionError error = new AssertionFailedError(\"Serialization failed on return value of \" + factory);\n                error.initCause(e.getCause());\n                throw error;\n            } catch (AssertionFailedError e) {\n                AssertionError error = new AssertionFailedError(\"Return value of \" + factory + \" reserialized to an unequal value\");\n                error.initCause(e);\n                throw error;\n            }\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Runs equals and serialization test on the return values.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4097, "method_signature": "FactoryMethodReturnValueTester testEqualsAndSerializable()", "filename": "ClassSanityTester.testEqualsAndSerializable.json"}
{"callee_method_names": ["Set<String>.contains", "Object.getClass", "NullPointerTester.testAllPublicInstanceMethods", "AssertionError.initCause"], "method_name": "ClassSanityTester.testNulls", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        Object instance = instantiate(factory);\n        if (instance != null && packagesToTest.contains(Reflection.getPackageName(instance.getClass()))) {\n            try {\n                nullPointerTester.testAllPublicInstanceMethods(instance);\n            } catch (AssertionError e) {\n                AssertionError error = new AssertionFailedError(\"Null check failed on return value of \" + factory);\n                error.initCause(e);\n                throw error;\n            }\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Tests null checks against the instance methods of the return values, if any.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4094, "method_signature": "FactoryMethodReturnValueTester testNulls()", "filename": "ClassSanityTester.testNulls.json"}
{"callee_method_names": ["AssertionError.initCause", "UnicodeEscaper.getCause"], "method_name": "ClassSanityTester.testSerializable", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        Object instance = instantiate(factory);\n        if (instance != null) {\n            try {\n                SerializableTester.reserialize(instance);\n            } catch (Exception e) {\n                // sneaky checked exception\n                AssertionError error = new AssertionFailedError(\"Serialization failed on return value of \" + factory);\n                error.initCause(e.getCause());\n                throw error;\n            }\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Runs serialization test on the return values of the static methods.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4096, "method_signature": "FactoryMethodReturnValueTester testSerializable()", "filename": "ClassSanityTester.testSerializable.json"}
{"callee_method_names": [], "method_name": "ClassSanityTester.thatReturn", "method_implementation": "{\n    this.returnTypeToTest = returnType;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies that only the methods that are declared to return {@code returnType} or its subtype\n * are tested.\n *\n * @return this tester object\n */\n", "repo_name": "guava-master/", "id": 4093, "method_signature": "FactoryMethodReturnValueTester thatReturn(Class)", "filename": "ClassSanityTester.thatReturn.json"}
{"callee_method_names": [], "method_name": "CloseableList.whenClosedCountDown", "method_implementation": "{\n    if (closed) {\n        return new CountDownLatch(0);\n    }\n    synchronized (this) {\n        if (closed) {\n            return new CountDownLatch(0);\n        }\n        checkState(whenClosed == null);\n        return whenClosed = new CountDownLatch(1);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a latch that reaches zero when this objects' deferred closeables have been closed.\n */\n", "repo_name": "guava-master/", "id": 5430, "method_signature": "CountDownLatch whenClosedCountDown()", "filename": "CloseableList.whenClosedCountDown.json"}
{"callee_method_names": ["Closeable.close", "Logger.log"], "method_name": "Closeables.close", "method_implementation": "{\n    if (closeable == null) {\n        return;\n    }\n    try {\n        closeable.close();\n    } catch (IOException e) {\n        if (swallowIOException) {\n            logger.log(Level.WARNING, \"IOException thrown while closing Closeable.\", e);\n        } else {\n            throw e;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Closes a {@link Closeable}, with control over whether an {@code IOException} may be thrown.\n * This is primarily useful in a finally block, where a thrown exception needs to be logged but\n * not propagated (otherwise the original exception will be lost).\n *\n * <p>If {@code swallowIOException} is true then we never throw {@code IOException} but merely log\n * it.\n *\n * <p>Example:\n *\n * <pre>{@code\n * public void useStreamNicely() throws IOException {\n *   SomeStream stream = new SomeStream(\"foo\");\n *   boolean threw = true;\n *   try {\n *     // ... code which does something with the stream ...\n *     threw = false;\n *   } finally {\n *     // If an exception occurs, rethrow it only if threw==false:\n *     Closeables.close(stream, threw);\n *   }\n * }\n * }</pre>\n *\n * @param closeable the {@code Closeable} object to be closed, or null, in which case this method\n *     does nothing\n * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code close}\n *     methods\n * @throws IOException if {@code swallowIOException} is false and {@code close} throws an {@code\n *     IOException}.\n */\n", "repo_name": "guava-master/", "id": 4845, "method_signature": "void close(Closeable, boolean)", "filename": "Closeables.close.json"}
{"callee_method_names": [], "method_name": "Closeables.closeQuietly", "method_implementation": "{\n    try {\n        close(reader, true);\n    } catch (IOException impossible) {\n        throw new AssertionError(impossible);\n    }\n}", "repo_id": "5", "comment": "/**\n * Closes the given {@link Reader}, logging any {@code IOException} that's thrown rather than\n * propagating it.\n *\n * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing an\n * I/O resource, it should generally be safe in the case of a resource that's being used only for\n * reading, such as a {@code Reader}. Unlike with writable resources, there's no chance that a\n * failure that occurs when closing the reader indicates a meaningful problem such as a failure to\n * flush all bytes to the underlying resource.\n *\n * @param reader the reader to be closed, or {@code null} in which case this method does nothing\n * @since 17.0\n */\n", "repo_name": "guava-master/", "id": 4847, "method_signature": "void closeQuietly(Reader)", "filename": "Closeables.closeQuietly.json"}
{"callee_method_names": [], "method_name": "CloseablesTest.doClose", "method_implementation": "{\n    try {\n        Closeables.close(closeable, swallowException);\n        if (expectThrown) {\n            fail(\"Didn't throw exception.\");\n        }\n    } catch (IOException e) {\n        if (!expectThrown) {\n            fail(\"Threw exception\");\n        }\n    }\n    verify(closeable).close();\n}", "repo_id": "5", "comment": "// be thrown by Closeables.close;\n", "repo_name": "guava-master/", "id": 3637, "method_signature": "void doClose(Closeable, boolean, boolean)", "filename": "CloseablesTest.doClose.json"}
{"callee_method_names": [], "method_name": "CloseablesTest.setupCloseable", "method_implementation": "{\n    mockCloseable = mock(Closeable.class);\n    if (shouldThrow) {\n        doThrow(new IOException(\"This should only appear in the logs. It should not be rethrown.\")).when(mockCloseable).close();\n    }\n}", "repo_id": "5", "comment": "// exception.\n", "repo_name": "guava-master/", "id": 3636, "method_signature": "void setupCloseable(boolean)", "filename": "CloseablesTest.setupCloseable.json"}
{"callee_method_names": ["ArrayDeque.isEmpty", "ArrayDeque.removeFirst", "Closeable.close", "Suppressor.suppress"], "method_name": "Closer.close", "method_implementation": "{\n    Throwable throwable = thrown;\n    // close closeables in LIFO order\n    while (!stack.isEmpty()) {\n        Closeable closeable = stack.removeFirst();\n        try {\n            closeable.close();\n        } catch (Throwable e) {\n            if (throwable == null) {\n                throwable = e;\n            } else {\n                suppressor.suppress(closeable, throwable, e);\n            }\n        }\n    }\n    if (thrown == null && throwable != null) {\n        Throwables.propagateIfPossible(throwable, IOException.class);\n        // not possible\n        throw new AssertionError(throwable);\n    }\n}", "repo_id": "5", "comment": "/**\n * Closes all {@code Closeable} instances that have been added to this {@code Closer}. If an\n * exception was thrown in the try block and passed to one of the {@code exceptionThrown} methods,\n * any exceptions thrown when attempting to close a closeable will be suppressed. Otherwise, the\n * <i>first</i> exception to be thrown from an attempt to close a closeable will be thrown and any\n * additional exceptions that are thrown after that will be suppressed.\n */\n", "repo_name": "guava-master/", "id": 4852, "method_signature": "void close()", "filename": "Closer.close.json"}
{"callee_method_names": ["ArrayDeque.addFirst"], "method_name": "Closer.register", "method_implementation": "{\n    if (closeable != null) {\n        stack.addFirst(closeable);\n    }\n    return closeable;\n}", "repo_id": "5", "comment": "// close. this word no longer has any meaning to me.\n", "repo_name": "guava-master/", "id": 4848, "method_signature": "C register(C)", "filename": "Closer.register.json"}
{"callee_method_names": [], "method_name": "Closer.rethrow", "method_implementation": "{\n    checkNotNull(e);\n    thrown = e;\n    Throwables.propagateIfPossible(e, IOException.class);\n    Throwables.propagateIfPossible(e, declaredType1, declaredType2);\n    throw new RuntimeException(e);\n}", "repo_id": "5", "comment": "/**\n * Stores the given throwable and rethrows it. It will be rethrown as is if it is an {@code\n * IOException}, {@code RuntimeException}, {@code Error} or a checked exception of either of the\n * given types. Otherwise, it will be rethrown wrapped in a {@code RuntimeException}. <b>Note:</b>\n * Be sure to declare all of the checked exception types your try block can throw when calling an\n * overload of this method so as to avoid losing the original exception type.\n *\n * <p>This method always throws, and as such should be called as {@code throw closer.rethrow(e,\n * ...);} to ensure the compiler knows that it will throw.\n *\n * @return this method does not return; it always throws\n * @throws IOException when the given throwable is an IOException\n * @throws X1 when the given throwable is of the declared type X1\n * @throws X2 when the given throwable is of the declared type X2\n */\n", "repo_name": "guava-master/", "id": 4851, "method_signature": "RuntimeException rethrow(Throwable, Class, Class)", "filename": "Closer.rethrow.json"}
{"callee_method_names": ["ClosingFunction5<V1,V2,V3,V4,V5,U>.apply", "ClosingFunction5<V1,V2,V3,V4,V5,U>.toString"], "method_name": "ClosingFuture.call", "method_implementation": "{\n    return call(new CombiningCallable<U>() {\n\n        @Override\n        @ParametricNullness\n        public U call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3), peeker.getDone(future4), peeker.getDone(future5));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * combining function to their values. The function can use a {@link DeferredCloser} to capture\n * objects to be closed when the pipeline is done.\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the\n * returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n */\n", "repo_name": "guava-master/", "id": 5415, "method_signature": "ClosingFuture<U> call(ClosingFunction5, Executor)", "filename": "ClosingFuture.call.json"}
{"callee_method_names": ["AsyncClosingFunction5<V1,V2,V3,V4,V5,U>.apply", "AsyncClosingFunction5<V1,V2,V3,V4,V5,U>.toString"], "method_name": "ClosingFuture.callAsync", "method_implementation": "{\n    return callAsync(new AsyncCombiningCallable<U>() {\n\n        @Override\n        public ClosingFuture<U> call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3), peeker.getDone(future4), peeker.getDone(future5));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * {@code ClosingFuture}-returning function to their values. The function can use a {@link\n * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those\n * captured by the returned {@link ClosingFuture}).\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the\n * returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n *\n * <p>If the function throws any other exception, it will be used as the failure of the derived\n * step.\n *\n * <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of\n * the closeable objects in that {@code ClosingFuture} will be closed.\n *\n * <p>Usage guidelines for this method:\n *\n * <ul>\n *   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a\n *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,\n *       Executor)} instead, with a function that returns the next value directly.\n *   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}\n *       for every closeable object this step creates in order to capture it for later closing.\n *   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code\n *       ClosingFuture} call {@link #from(ListenableFuture)}.\n * </ul>\n *\n * <p>The same warnings about doing heavyweight operations within {@link\n * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.\n */\n", "repo_name": "guava-master/", "id": 5416, "method_signature": "ClosingFuture<U> callAsync(AsyncClosingFunction5, Executor)", "filename": "ClosingFuture.callAsync.json"}
{"callee_method_names": ["LazyLogger.get", "ListenableFuture<C>.cancel"], "method_name": "ClosingFuture.cancel", "method_implementation": "{\n    logger.get().log(FINER, \"cancelling {0}\", this);\n    boolean cancelled = future.cancel(mayInterruptIfRunning);\n    if (cancelled) {\n        close();\n    }\n    return cancelled;\n}", "repo_id": "5", "comment": "/**\n * Attempts to cancel execution of this step. This attempt will fail if the step has already\n * completed, has already been cancelled, or could not be cancelled for some other reason. If\n * successful, and this step has not started when {@code cancel} is called, this step should never\n * run.\n *\n * <p>If successful, causes the objects captured by this step (if already started) and its input\n * step(s) for later closing to be closed on their respective {@link Executor}s. If any such calls\n * specified {@link MoreExecutors#directExecutor()}, those objects will be closed synchronously.\n *\n * @param mayInterruptIfRunning {@code true} if the thread executing this task should be\n *     interrupted; otherwise, in-progress tasks are allowed to complete, but the step will be\n *     cancelled regardless\n * @return {@code false} if the step could not be cancelled, typically because it has already\n *     completed normally; {@code true} otherwise\n */\n", "repo_name": "guava-master/", "id": 5405, "method_signature": "boolean cancel(boolean)", "filename": "ClosingFuture.cancel.json"}
{"callee_method_names": [], "method_name": "ClosingFuture.catchingAsync", "method_implementation": "{\n    return catchingAsyncMoreGeneric(exceptionType, fallback, executor);\n}", "repo_id": "5", "comment": "// ExecutionException?\n", "repo_name": "guava-master/", "id": 5401, "method_signature": "ClosingFuture<V> catchingAsync(Class, AsyncClosingFunction, Executor)", "filename": "ClosingFuture.catchingAsync.json"}
{"callee_method_names": ["CloseableList.applyAsyncClosingFunction", "AsyncClosingFunction<? super X,W>.toString", "ListenableFuture<C>.catchingAsync"], "method_name": "ClosingFuture.catchingAsyncMoreGeneric", "method_implementation": "{\n    checkNotNull(fallback);\n    AsyncFunction<X, W> asyncFunction = new AsyncFunction<X, W>() {\n\n        @Override\n        public ListenableFuture<W> apply(X exception) throws Exception {\n            return closeables.applyAsyncClosingFunction(fallback, exception);\n        }\n\n        @Override\n        public String toString() {\n            return fallback.toString();\n        }\n    };\n    return derive(future.catchingAsync(exceptionType, asyncFunction, executor));\n}", "repo_id": "5", "comment": "// Avoids generic type capture inconsistency problems where |? extends V| is incompatible with V.\n", "repo_name": "guava-master/", "id": 5402, "method_signature": "ClosingFuture<V> catchingAsyncMoreGeneric(Class, AsyncClosingFunction, Executor)", "filename": "ClosingFuture.catchingAsyncMoreGeneric.json"}
{"callee_method_names": ["CloseableList.applyClosingFunction", "ClosingFunction<? super X,W>.toString", "ListenableFuture<C>.catchingAsync"], "method_name": "ClosingFuture.catchingMoreGeneric", "method_implementation": "{\n    checkNotNull(fallback);\n    AsyncFunction<X, W> applyFallback = new AsyncFunction<X, W>() {\n\n        @Override\n        public ListenableFuture<W> apply(X exception) throws Exception {\n            return closeables.applyClosingFunction(fallback, exception);\n        }\n\n        @Override\n        public String toString() {\n            return fallback.toString();\n        }\n    };\n    // TODO(dpb): Switch to future.catchingSync when that exists (passing a throwing function).\n    return derive(future.catchingAsync(exceptionType, applyFallback, executor));\n}", "repo_id": "5", "comment": "// Avoids generic type capture inconsistency problems where |? extends V| is incompatible with V.\n", "repo_name": "guava-master/", "id": 5400, "method_signature": "ClosingFuture<V> catchingMoreGeneric(Class, ClosingFunction, Executor)", "filename": "ClosingFuture.catchingMoreGeneric.json"}
{"callee_method_names": ["CloseableList.add"], "method_name": "ClosingFuture.eventuallyClose", "method_implementation": "{\n    checkNotNull(closingExecutor);\n    if (closeable != null) {\n        list.add(closeable, closingExecutor);\n    }\n    return closeable;\n}", "repo_id": "5", "comment": "/**\n * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.\n *\n * <p>For users of the {@code -jre} flavor of Guava, the object can be any {@code\n * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code\n * Closeable}. (For more about the flavors, see <a\n * href=\"https://github.com/google/guava#adding-guava-to-your-build\">Adding Guava to your\n * build</a>.)\n *\n * <p>Be careful when targeting an older SDK than you are building against (most commonly when\n * building for Android): Ensure that any object you pass implements the interface not just in\n * your current SDK version but also at the oldest version you support. For example, <a\n * href=\"https://developer.android.com/sdk/api_diff/16/\">API Level 16</a> is the first version\n * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper\n * {@code Closeable} with a method reference like {@code cursor::close}.\n *\n * <p>Note that this method is still binary-compatible between flavors because the erasure of\n * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.\n *\n * @param closeable the object to be closed (see notes above)\n * @param closingExecutor the object will be closed on this executor\n * @return the first argument\n */\n", "repo_name": "guava-master/", "id": 5391, "method_signature": "C eventuallyClose(C, Executor)", "filename": "ClosingFuture.eventuallyClose.json"}
{"callee_method_names": [], "method_name": "ClosingFuture.eventuallyClosing", "method_implementation": "{\n    checkNotNull(closingExecutor);\n    final ClosingFuture<C> closingFuture = new ClosingFuture<>(nonCancellationPropagating(future));\n    Futures.addCallback(future, new FutureCallback<@Nullable Closeable>() {\n\n        @Override\n        public void onSuccess(@CheckForNull Closeable result) {\n            closingFuture.closeables.closer.eventuallyClose(result, closingExecutor);\n        }\n\n        @Override\n        public void onFailure(Throwable t) {\n        }\n    }, directExecutor());\n    return closingFuture;\n}", "repo_id": "5", "comment": "/**\n * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.\n *\n * <p>If {@code future} succeeds, its value will be closed (using {@code closingExecutor)}) when\n * the pipeline is done, even if the pipeline is canceled or fails.\n *\n * <p>Cancelling the pipeline will not cancel {@code future}, so that the pipeline can access its\n * value in order to close it.\n *\n * @param future the future to create the {@code ClosingFuture} from. For discussion of the\n *     future's result type {@code C}, see {@link DeferredCloser#eventuallyClose(Object,\n *     Executor)}.\n * @param closingExecutor the future's result will be closed on this executor\n * @deprecated Creating {@link Future}s of closeable types is dangerous in general because the\n *     underlying value may never be closed if the {@link Future} is canceled after its operation\n *     begins. Consider replacing code that creates {@link ListenableFuture}s of closeable types,\n *     including those that pass them to this method, with {@link #submit(ClosingCallable,\n *     Executor)} in order to ensure that resources do not leak. Or, to start a pipeline with a\n *     {@link ListenableFuture} that doesn't create values that should be closed, use {@link\n *     ClosingFuture#from}.\n */\n", "repo_name": "guava-master/", "id": 5392, "method_signature": "ClosingFuture<C> eventuallyClosing(ListenableFuture, Executor)", "filename": "ClosingFuture.eventuallyClosing.json"}
{"callee_method_names": ["LazyLogger.get", "ListenableFuture<C>.addListener", "AtomicReference.get"], "method_name": "ClosingFuture.finishToFuture", "method_implementation": "{\n    if (compareAndUpdateState(OPEN, WILL_CLOSE)) {\n        logger.get().log(FINER, \"will close {0}\", this);\n        future.addListener(new Runnable() {\n\n            @Override\n            public void run() {\n                checkAndUpdateState(WILL_CLOSE, CLOSING);\n                close();\n                checkAndUpdateState(CLOSING, CLOSED);\n            }\n        }, directExecutor());\n    } else {\n        switch(state.get()) {\n            case SUBSUMED:\n                throw new IllegalStateException(\"Cannot call finishToFuture() after deriving another step\");\n            case WILL_CREATE_VALUE_AND_CLOSER:\n                throw new IllegalStateException(\"Cannot call finishToFuture() after calling finishToValueAndCloser()\");\n            case WILL_CLOSE:\n            case CLOSING:\n            case CLOSED:\n                throw new IllegalStateException(\"Cannot call finishToFuture() twice\");\n            case OPEN:\n                throw new AssertionError();\n        }\n    }\n    return future;\n}", "repo_id": "5", "comment": "/**\n * Marks this step as the last step in the {@code ClosingFuture} pipeline.\n *\n * <p>The returned {@link Future} is completed when the pipeline's computation completes, or when\n * the pipeline is cancelled.\n *\n * <p>All objects the pipeline has captured for closing will begin to be closed asynchronously\n * <b>after</b> the returned {@code Future} is done: the future completes before closing starts,\n * rather than once it has finished.\n *\n * <p>After calling this method, you may not call {@link\n * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, this method, or any other\n * derivation method on the original {@code ClosingFuture} instance.\n *\n * @return a {@link Future} that represents the final value or exception of the pipeline\n */\n", "repo_name": "guava-master/", "id": 5403, "method_signature": "FluentFuture<V> finishToFuture()", "filename": "ClosingFuture.finishToFuture.json"}
{"callee_method_names": ["AtomicReference.get", "ListenableFuture<C>.addListener"], "method_name": "ClosingFuture.finishToValueAndCloser", "method_implementation": "{\n    checkNotNull(consumer);\n    if (!compareAndUpdateState(OPEN, WILL_CREATE_VALUE_AND_CLOSER)) {\n        switch(state.get()) {\n            case SUBSUMED:\n                throw new IllegalStateException(\"Cannot call finishToValueAndCloser() after deriving another step\");\n            case WILL_CLOSE:\n            case CLOSING:\n            case CLOSED:\n                throw new IllegalStateException(\"Cannot call finishToValueAndCloser() after calling finishToFuture()\");\n            case WILL_CREATE_VALUE_AND_CLOSER:\n                throw new IllegalStateException(\"Cannot call finishToValueAndCloser() twice\");\n            case OPEN:\n                break;\n        }\n        throw new AssertionError(state);\n    }\n    future.addListener(new Runnable() {\n\n        @Override\n        public void run() {\n            provideValueAndCloser(consumer, ClosingFuture.this);\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Marks this step as the last step in the {@code ClosingFuture} pipeline. When this step is done,\n * {@code receiver} will be called with an object that contains the result of the operation. The\n * receiver can store the {@link ValueAndCloser} outside the receiver for later synchronous use.\n *\n * <p>After calling this method, you may not call {@link #finishToFuture()}, this method again, or\n * any other derivation method on the original {@code ClosingFuture} instance.\n *\n * @param consumer a callback whose method will be called (using {@code executor}) when this\n *     operation is done\n */\n", "repo_name": "guava-master/", "id": 5404, "method_signature": "void finishToValueAndCloser(ValueAndCloserConsumer, Executor)", "filename": "ClosingFuture.finishToValueAndCloser.json"}
{"callee_method_names": ["ImmutableList<ClosingFuture<?>>.contains"], "method_name": "ClosingFuture.getDone", "method_implementation": "{\n    checkState(beingCalled);\n    checkArgument(futures.contains(closingFuture));\n    return Futures.getDone(closingFuture.future);\n}", "repo_id": "5", "comment": "/**\n * Returns the value of {@code closingFuture}.\n *\n * @throws ExecutionException if {@code closingFuture} is a failed step\n * @throws CancellationException if the {@code closingFuture}'s future was cancelled\n * @throws IllegalArgumentException if {@code closingFuture} is not one of the futures passed to\n *     {@link #whenAllComplete(Iterable)} or {@link #whenAllComplete(Iterable)}\n * @throws IllegalStateException if called outside of a call to {@link\n *     CombiningCallable#call(DeferredCloser, Peeker)} or {@link\n *     AsyncCombiningCallable#call(DeferredCloser, Peeker)}\n */\n", "repo_name": "guava-master/", "id": 5406, "method_signature": "D getDone(ClosingFuture)", "filename": "ClosingFuture.getDone.json"}
{"callee_method_names": ["CloseableList.applyClosingFunction", "ClosingFunction<? super V,U>.toString", "ListenableFuture<C>.transformAsync"], "method_name": "ClosingFuture.transform", "method_implementation": "{\n    checkNotNull(function);\n    AsyncFunction<V, U> applyFunction = new AsyncFunction<V, U>() {\n\n        @Override\n        public ListenableFuture<U> apply(V input) throws Exception {\n            return closeables.applyClosingFunction(function, input);\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    };\n    // TODO(dpb): Switch to future.transformSync when that exists (passing a throwing function).\n    return derive(future.transformAsync(applyFunction, executor));\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function\n * to its value. The function can use a {@link DeferredCloser} to capture objects to be closed\n * when the pipeline is done.\n *\n * <p>If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code\n * ClosingFuture} will be equivalent to this one.\n *\n * <p>If the function throws an exception, that exception is used as the result of the derived\n * {@code ClosingFuture}.\n *\n * <p>Example usage:\n *\n * <pre>{@code\n * ClosingFuture<List<Row>> rowsFuture =\n *     queryFuture.transform((closer, result) -> result.getRows(), executor);\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings\n * about heavyweight listeners are also applicable to heavyweight functions passed to this method.\n *\n * <p>After calling this method, you may not call {@link #finishToFuture()}, {@link\n * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on\n * the original {@code ClosingFuture} instance.\n *\n * @param function transforms the value of this step to the value of the derived step\n * @param executor executor to run the function in\n * @return the derived step\n * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this\n *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()\n *     finished}\n */\n", "repo_name": "guava-master/", "id": 5397, "method_signature": "ClosingFuture<U> transform(ClosingFunction, Executor)", "filename": "ClosingFuture.transform.json"}
{"callee_method_names": ["CloseableList.applyAsyncClosingFunction", "AsyncClosingFunction<? super V,U>.toString", "ListenableFuture<C>.transformAsync"], "method_name": "ClosingFuture.transformAsync", "method_implementation": "{\n    checkNotNull(function);\n    AsyncFunction<V, U> applyFunction = new AsyncFunction<V, U>() {\n\n        @Override\n        public ListenableFuture<U> apply(V input) throws Exception {\n            return closeables.applyAsyncClosingFunction(function, input);\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    };\n    return derive(future.transformAsync(applyFunction, executor));\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function\n * that returns a {@code ClosingFuture} to its value. The function can use a {@link\n * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those\n * captured by the returned {@link ClosingFuture}).\n *\n * <p>If this {@code ClosingFuture} succeeds, the derived one will be equivalent to the one\n * returned by the function.\n *\n * <p>If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code\n * ClosingFuture} will be equivalent to this one.\n *\n * <p>If the function throws an exception, that exception is used as the result of the derived\n * {@code ClosingFuture}. But if the exception is thrown after the function creates a {@code\n * ClosingFuture}, then none of the closeable objects in that {@code ClosingFuture} will be\n * closed.\n *\n * <p>Usage guidelines for this method:\n *\n * <ul>\n *   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a\n *       {@code ClosingFuture}. If possible, prefer calling {@link #transform(ClosingFunction,\n *       Executor)} instead, with a function that returns the next value directly.\n *   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}\n *       for every closeable object this step creates in order to capture it for later closing.\n *   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code\n *       ClosingFuture} call {@link #from(ListenableFuture)}.\n *   <li>In case this step doesn't create new closeables, you can adapt an API that returns a\n *       {@link ListenableFuture} to return a {@code ClosingFuture} by wrapping it with a call to\n *       {@link #withoutCloser(AsyncFunction)}\n * </ul>\n *\n * <p>Example usage:\n *\n * <pre>{@code\n * // Result.getRowsClosingFuture() returns a ClosingFuture.\n * ClosingFuture<List<Row>> rowsFuture =\n *     queryFuture.transformAsync((closer, result) -> result.getRowsClosingFuture(), executor);\n *\n * // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the\n * // number of written rows. openOutputFile() returns a FileOutputStream (which implements\n * // Closeable).\n * ClosingFuture<Integer> rowsFuture2 =\n *     queryFuture.transformAsync(\n *         (closer, result) -> {\n *           FileOutputStream fos = closer.eventuallyClose(openOutputFile(), closingExecutor);\n *           return ClosingFuture.from(result.writeRowsToOutputStreamFuture(fos));\n *      },\n *      executor);\n *\n * // Result.getRowsFuture() returns a ListenableFuture (no new closeables are created).\n * ClosingFuture<List<Row>> rowsFuture3 =\n *     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);\n *\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings\n * about heavyweight listeners are also applicable to heavyweight functions passed to this method.\n * (Specifically, {@code directExecutor} functions should avoid heavyweight operations inside\n * {@code AsyncClosingFunction.apply}. Any heavyweight operations should occur in other threads\n * responsible for completing the returned {@code ClosingFuture}.)\n *\n * <p>After calling this method, you may not call {@link #finishToFuture()}, {@link\n * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on\n * the original {@code ClosingFuture} instance.\n *\n * @param function transforms the value of this step to a {@code ClosingFuture} with the value of\n *     the derived step\n * @param executor executor to run the function in\n * @return the derived step\n * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this\n *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()\n *     finished}\n */\n", "repo_name": "guava-master/", "id": 5398, "method_signature": "ClosingFuture<U> transformAsync(AsyncClosingFunction, Executor)", "filename": "ClosingFuture.transformAsync.json"}
{"callee_method_names": [], "method_name": "ClosingFuture.whenAllSucceed", "method_implementation": "{\n    return whenAllSucceed(FluentIterable.of(future1, future2, future3, future4, future5, future6).append(moreFutures));\n}", "repo_id": "5", "comment": "/**\n * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline, assuming they\n * all succeed. If any fail, the resulting pipeline will fail.\n *\n * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of\n *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}\n */\n", "repo_name": "guava-master/", "id": 5396, "method_signature": "Combiner whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture<?>[])", "filename": "ClosingFuture.whenAllSucceed.json"}
{"callee_method_names": [], "method_name": "ClosingFuture.whenClosedCountDown", "method_implementation": "{\n    if (closed) {\n        return new CountDownLatch(0);\n    }\n    synchronized (this) {\n        if (closed) {\n            return new CountDownLatch(0);\n        }\n        checkState(whenClosed == null);\n        return whenClosed = new CountDownLatch(1);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a latch that reaches zero when this objects' deferred closeables have been closed.\n */\n", "repo_name": "guava-master/", "id": 5417, "method_signature": "CountDownLatch whenClosedCountDown()", "filename": "ClosingFuture.whenClosedCountDown.json"}
{"callee_method_names": ["AsyncFunction<V,U>.apply"], "method_name": "ClosingFuture.withoutCloser", "method_implementation": "{\n    checkNotNull(function);\n    return new AsyncClosingFunction<V, U>() {\n\n        @Override\n        public ClosingFuture<U> apply(DeferredCloser closer, V input) throws Exception {\n            return ClosingFuture.from(function.apply(input));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an {@link AsyncClosingFunction} that applies an {@link AsyncFunction} to an input,\n * ignoring the DeferredCloser and returning a {@code ClosingFuture} derived from the returned\n * {@link ListenableFuture}.\n *\n * <p>Use this method to pass a transformation to {@link #transformAsync(AsyncClosingFunction,\n * Executor)} or to {@link #catchingAsync(Class, AsyncClosingFunction, Executor)} as long as it\n * meets these conditions:\n *\n * <ul>\n *   <li>It does not need to capture any {@link Closeable} objects by calling {@link\n *       DeferredCloser#eventuallyClose(Object, Executor)}.\n *   <li>It returns a {@link ListenableFuture}.\n * </ul>\n *\n * <p>Example usage:\n *\n * <pre>{@code\n * // Result.getRowsFuture() returns a ListenableFuture.\n * ClosingFuture<List<Row>> rowsFuture =\n *     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);\n * }</pre>\n *\n * @param function transforms the value of a {@code ClosingFuture} step to a {@link\n *     ListenableFuture} with the value of a derived step\n */\n", "repo_name": "guava-master/", "id": 5399, "method_signature": "AsyncClosingFunction<V,U> withoutCloser(AsyncFunction)", "filename": "ClosingFuture.withoutCloser.json"}
{"callee_method_names": ["Collection<? extends Throwable>.size", "Collection<? extends Throwable>.size", "Collection<? extends Throwable>.iterator"], "method_name": "ClusterException.create", "method_implementation": "{\n    if (exceptions.size() == 0) {\n        throw new IllegalArgumentException(\"Can't create an ExceptionCollection with no exceptions\");\n    }\n    if (exceptions.size() == 1) {\n        Throwable temp = exceptions.iterator().next();\n        if (temp instanceof RuntimeException) {\n            return (RuntimeException) temp;\n        } else {\n            return new RuntimeException(temp);\n        }\n    }\n    return new ClusterException(exceptions);\n}", "repo_id": "5", "comment": "/**\n * Given a collection of exceptions, returns a {@link RuntimeException}, with the following rules:\n *\n * <ul>\n *   <li>If {@code exceptions} has a single exception and that exception is a {@link\n *       RuntimeException}, return it\n *   <li>If {@code exceptions} has a single exceptions and that exceptions is <em>not</em> a\n *       {@link RuntimeException}, return a simple {@code RuntimeException} that wraps it\n *   <li>Otherwise, return an instance of {@link ClusterException} that wraps the first exception\n *       in the {@code exceptions} collection.\n * </ul>\n *\n * <p>Though this method takes any {@link Collection}, it often makes most sense to pass a {@link\n * java.util.List} or some other collection that preserves the order in which the exceptions got\n * added.\n *\n * @throws NullPointerException if {@code exceptions} is null\n * @throws IllegalArgumentException if {@code exceptions} is empty\n */\n", "repo_name": "guava-master/", "id": 4085, "method_signature": "RuntimeException create(Collection)", "filename": "ClusterException.create.json"}
{"callee_method_names": ["Spliterator<T>.tryAdvance", "Predicate<? super T>.test", "Consumer<? super String>.accept", "Spliterator<T>.trySplit", "Spliterator<T>.estimateSize", "Spliterator<T>.getComparator", "Spliterator<T>.characteristics"], "method_name": "CollectSpliterators.filter", "method_implementation": "{\n    checkNotNull(fromSpliterator);\n    checkNotNull(predicate);\n    class Splitr implements Spliterator<T>, Consumer<T> {\n\n        @CheckForNull\n        T holder = null;\n\n        @Override\n        public void accept(@ParametricNullness T t) {\n            this.holder = t;\n        }\n\n        @Override\n        public boolean tryAdvance(Consumer<? super T> action) {\n            while (fromSpliterator.tryAdvance(this)) {\n                try {\n                    // The cast is safe because tryAdvance puts a T into `holder`.\n                    T next = uncheckedCastNullableTToT(holder);\n                    if (predicate.test(next)) {\n                        action.accept(next);\n                        return true;\n                    }\n                } finally {\n                    holder = null;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        @CheckForNull\n        public Spliterator<T> trySplit() {\n            Spliterator<T> fromSplit = fromSpliterator.trySplit();\n            return (fromSplit == null) ? null : filter(fromSplit, predicate);\n        }\n\n        @Override\n        public long estimateSize() {\n            return fromSpliterator.estimateSize() / 2;\n        }\n\n        @Override\n        @CheckForNull\n        public Comparator<? super T> getComparator() {\n            return fromSpliterator.getComparator();\n        }\n\n        @Override\n        public int characteristics() {\n            return fromSpliterator.characteristics() & (Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED | Spliterator.SORTED);\n        }\n    }\n    return new Splitr();\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Spliterator} filtered by the specified predicate.\n */\n", "repo_name": "guava-master/", "id": 2463, "method_signature": "Spliterator<T> filter(Spliterator, Predicate)", "filename": "CollectSpliterators.filter.json"}
{"callee_method_names": [], "method_name": "CollectSpliterators.flatMap", "method_implementation": "{\n    checkArgument((topCharacteristics & Spliterator.SUBSIZED) == 0, \"flatMap does not support SUBSIZED characteristic\");\n    checkArgument((topCharacteristics & Spliterator.SORTED) == 0, \"flatMap does not support SORTED characteristic\");\n    checkNotNull(fromSpliterator);\n    checkNotNull(function);\n    return new FlatMapSpliteratorOfObject<>(null, fromSpliterator, function, topCharacteristics, topSize);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Spliterator} that iterates over the elements of the spliterators generated by\n * applying {@code function} to the elements of {@code fromSpliterator}.\n */\n", "repo_name": "guava-master/", "id": 2464, "method_signature": "Spliterator<OutElementT> flatMap(Spliterator, Function, int, long)", "filename": "CollectSpliterators.flatMap.json"}
{"callee_method_names": [], "method_name": "CollectSpliterators.flatMapToDouble", "method_implementation": "{\n    checkArgument((topCharacteristics & Spliterator.SUBSIZED) == 0, \"flatMap does not support SUBSIZED characteristic\");\n    checkArgument((topCharacteristics & Spliterator.SORTED) == 0, \"flatMap does not support SORTED characteristic\");\n    checkNotNull(fromSpliterator);\n    checkNotNull(function);\n    return new FlatMapSpliteratorOfDouble<>(null, fromSpliterator, function, topCharacteristics, topSize);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Spliterator.OfDouble} that iterates over the elements of the spliterators\n * generated by applying {@code function} to the elements of {@code fromSpliterator}. (If {@code\n * function} returns {@code null} for an input, it is replaced with an empty stream.)\n */\n", "repo_name": "guava-master/", "id": 2467, "method_signature": "Spliterator.OfDouble flatMapToDouble(Spliterator, Function, int, long)", "filename": "CollectSpliterators.flatMapToDouble.json"}
{"callee_method_names": [], "method_name": "CollectSpliterators.flatMapToInt", "method_implementation": "{\n    checkArgument((topCharacteristics & Spliterator.SUBSIZED) == 0, \"flatMap does not support SUBSIZED characteristic\");\n    checkArgument((topCharacteristics & Spliterator.SORTED) == 0, \"flatMap does not support SORTED characteristic\");\n    checkNotNull(fromSpliterator);\n    checkNotNull(function);\n    return new FlatMapSpliteratorOfInt<>(null, fromSpliterator, function, topCharacteristics, topSize);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Spliterator.OfInt} that iterates over the elements of the spliterators\n * generated by applying {@code function} to the elements of {@code fromSpliterator}. (If {@code\n * function} returns {@code null} for an input, it is replaced with an empty stream.)\n */\n", "repo_name": "guava-master/", "id": 2465, "method_signature": "Spliterator.OfInt flatMapToInt(Spliterator, Function, int, long)", "filename": "CollectSpliterators.flatMapToInt.json"}
{"callee_method_names": [], "method_name": "CollectSpliterators.flatMapToLong", "method_implementation": "{\n    checkArgument((topCharacteristics & Spliterator.SUBSIZED) == 0, \"flatMap does not support SUBSIZED characteristic\");\n    checkArgument((topCharacteristics & Spliterator.SORTED) == 0, \"flatMap does not support SORTED characteristic\");\n    checkNotNull(fromSpliterator);\n    checkNotNull(function);\n    return new FlatMapSpliteratorOfLong<>(null, fromSpliterator, function, topCharacteristics, topSize);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Spliterator.OfLong} that iterates over the elements of the spliterators\n * generated by applying {@code function} to the elements of {@code fromSpliterator}. (If {@code\n * function} returns {@code null} for an input, it is replaced with an empty stream.)\n */\n", "repo_name": "guava-master/", "id": 2466, "method_signature": "Spliterator.OfLong flatMapToLong(Spliterator, Function, int, long)", "filename": "CollectSpliterators.flatMapToLong.json"}
{"callee_method_names": ["Spliterator<InElementT>.tryAdvance", "Consumer<? super String>.accept", "Function<? super InElementT,? extends OutElementT>.apply", "Spliterator<InElementT>.forEachRemaining", "Consumer<? super String>.accept", "Function<? super InElementT,? extends OutElementT>.apply", "Spliterator<InElementT>.trySplit", "Spliterator<InElementT>.estimateSize", "Spliterator<InElementT>.characteristics"], "method_name": "CollectSpliterators.map", "method_implementation": "{\n    checkNotNull(fromSpliterator);\n    checkNotNull(function);\n    return new Spliterator<OutElementT>() {\n\n        @Override\n        public boolean tryAdvance(Consumer<? super OutElementT> action) {\n            return fromSpliterator.tryAdvance(fromElement -> action.accept(function.apply(fromElement)));\n        }\n\n        @Override\n        public void forEachRemaining(Consumer<? super OutElementT> action) {\n            fromSpliterator.forEachRemaining(fromElement -> action.accept(function.apply(fromElement)));\n        }\n\n        @Override\n        @CheckForNull\n        public Spliterator<OutElementT> trySplit() {\n            Spliterator<InElementT> fromSplit = fromSpliterator.trySplit();\n            return (fromSplit != null) ? map(fromSplit, function) : null;\n        }\n\n        @Override\n        public long estimateSize() {\n            return fromSpliterator.estimateSize();\n        }\n\n        @Override\n        public int characteristics() {\n            return fromSpliterator.characteristics() & ~(Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.SORTED);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Spliterator} over the elements of {@code fromSpliterator} mapped by {@code\n * function}.\n */\n", "repo_name": "guava-master/", "id": 2462, "method_signature": "Spliterator<OutElementT> map(Spliterator, Function)", "filename": "CollectSpliterators.map.json"}
{"callee_method_names": ["Collection<E>.removeAll"], "method_name": "CollectionRemoveAllTester.testRemoveAll_somePresentLargeCollectionToRemove", "method_implementation": "{\n    assertTrue(\"removeAll(largeIntersectingCollection) should return true\", collection.removeAll(MinimalCollection.of(e0(), e0(), e0(), e3(), e3(), e3())));\n    expectMissing(e0());\n}", "repo_id": "5", "comment": "/**\n * Trigger the {@code other.size() >= this.size()} case in {@link AbstractSet#removeAll}.\n */\n", "repo_name": "guava-master/", "id": 4188, "method_signature": "void testRemoveAll_somePresentLargeCollectionToRemove()", "filename": "CollectionRemoveAllTester.testRemoveAll_somePresentLargeCollectionToRemove.json"}
{"callee_method_names": ["List<E>.size", "Comparator<? super E>.compare", "List<E>.get", "List<E>.get"], "method_name": "Collections2.calculateSize", "method_implementation": "{\n    int permutations = 1;\n    int n = 1;\n    int r = 1;\n    while (n < sortedInputList.size()) {\n        int comparison = comparator.compare(sortedInputList.get(n - 1), sortedInputList.get(n));\n        if (comparison < 0) {\n            // We move to the next non-repeated element.\n            permutations = IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));\n            r = 0;\n            if (permutations == Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n        }\n        n++;\n        r++;\n    }\n    return IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));\n}", "repo_id": "5", "comment": "/**\n * The number of permutations with repeated elements is calculated as follows:\n *\n * <ul>\n *   <li>For an empty list, it is 1 (base case).\n *   <li>When r numbers are added to a list of n-r elements, the number of permutations is\n *       increased by a factor of (n choose r).\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 6609, "method_signature": "int calculateSize(List, Comparator)", "filename": "Collections2.calculateSize.json"}
{"callee_method_names": ["Collection<?>.contains"], "method_name": "Collections2.containsAllImpl", "method_implementation": "{\n    for (Object o : c) {\n        if (!self.contains(o)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if the collection {@code self} contains all of the elements in the\n * collection {@code c}.\n *\n * <p>This method iterates over the specified collection {@code c}, checking each element returned\n * by the iterator in turn to see if it is contained in the specified collection {@code self}. If\n * all elements are so contained, {@code true} is returned, otherwise {@code false}.\n *\n * @param self a collection which might contain all elements in {@code c}\n * @param c a collection whose elements might be contained by {@code self}\n */\n", "repo_name": "guava-master/", "id": 6607, "method_signature": "boolean containsAllImpl(Collection, Collection)", "filename": "Collections2.containsAllImpl.json"}
{"callee_method_names": [], "method_name": "Collections2.filter", "method_implementation": "{\n    if (unfiltered instanceof FilteredCollection) {\n        // Support clear(), removeAll(), and retainAll() when filtering a filtered\n        // collection.\n        return ((FilteredCollection<E>) unfiltered).createCombined(predicate);\n    }\n    return new FilteredCollection<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n}", "repo_id": "5", "comment": "// javadoc?\n", "repo_name": "guava-master/", "id": 6604, "method_signature": "Collection<E> filter(Collection, Predicate)", "filename": "Collections2.filter.json"}
{"callee_method_names": ["List<?>.size", "List<?>.size", "List<?>.size", "List<?>.size", "List<?>.size", "ObjectCountHashMap<?>.getValue", "ObjectCountHashMap<?>.get", "ObjectCountHashMap<?>.getKey"], "method_name": "Collections2.isPermutation", "method_implementation": "{\n    if (first.size() != second.size()) {\n        return false;\n    }\n    ObjectCountHashMap<?> firstCounts = counts(first);\n    ObjectCountHashMap<?> secondCounts = counts(second);\n    if (first.size() != second.size()) {\n        return false;\n    }\n    for (int i = 0; i < first.size(); i++) {\n        if (firstCounts.getValue(i) != secondCounts.get(firstCounts.getKey(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if the second list is a permutation of the first.\n */\n", "repo_name": "guava-master/", "id": 6610, "method_signature": "boolean isPermutation(List, List)", "filename": "Collections2.isPermutation.json"}
{"callee_method_names": ["Collection<?>.contains"], "method_name": "Collections2.safeContains", "method_implementation": "{\n    checkNotNull(collection);\n    try {\n        return collection.contains(object);\n    } catch (ClassCastException | NullPointerException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Delegates to {@link Collection#contains}. Returns {@code false} if the {@code contains} method\n * throws a {@code ClassCastException} or {@code NullPointerException}.\n */\n", "repo_name": "guava-master/", "id": 6605, "method_signature": "boolean safeContains(Collection, Object)", "filename": "Collections2.safeContains.json"}
{"callee_method_names": ["Collection<?>.remove"], "method_name": "Collections2.safeRemove", "method_implementation": "{\n    checkNotNull(collection);\n    try {\n        return collection.remove(object);\n    } catch (ClassCastException | NullPointerException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Delegates to {@link Collection#remove}. Returns {@code false} if the {@code remove} method\n * throws a {@code ClassCastException} or {@code NullPointerException}.\n */\n", "repo_name": "guava-master/", "id": 6606, "method_signature": "boolean safeRemove(Collection, Object)", "filename": "Collections2.safeRemove.json"}
{"callee_method_names": ["Collection<?>.size", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "Collections2.toStringImpl", "method_implementation": "{\n    StringBuilder sb = newStringBuilderForCollection(collection.size()).append('[');\n    boolean first = true;\n    for (Object o : collection) {\n        if (!first) {\n            sb.append(\", \");\n        }\n        first = false;\n        if (o == collection) {\n            sb.append(\"(this Collection)\");\n        } else {\n            sb.append(o);\n        }\n    }\n    return sb.append(']').toString();\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Collection#toString()}.\n */\n", "repo_name": "guava-master/", "id": 6608, "method_signature": "String toStringImpl(Collection)", "filename": "Collections2.toStringImpl.json"}
{"callee_method_names": ["Collector<T,A,R>.characteristics"], "method_name": "CollectorTester.expectCollects", "method_implementation": "{\n    List<T> list = Arrays.asList(inputs);\n    doExpectCollects(expectedResult, list);\n    if (collector.characteristics().contains(Collector.Characteristics.UNORDERED)) {\n        Collections.reverse(list);\n        doExpectCollects(expectedResult, list);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Verifies that the specified expected result is always produced by collecting the specified\n * inputs, regardless of how the elements are divided.\n */\n", "repo_name": "guava-master/", "id": 669, "method_signature": "CollectorTester<T,A,R> expectCollects(R, T[])", "filename": "CollectorTester.expectCollects.json"}
{"callee_method_names": [], "method_name": "CollectorTester.of", "method_implementation": "{\n    return new CollectorTester<>(collector, equivalence);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code CollectorTester} for the specified {@code Collector}. The result of the {@code\n * Collector} will be compared to the expected value using the specified {@code equivalence}.\n */\n", "repo_name": "guava-master/", "id": 668, "method_signature": "CollectorTester<T,A,R> of(Collector, BiPredicate)", "filename": "CollectorTester.of.json"}
{"callee_method_names": ["Map<R, Map<C, V>>.entrySet", "Iterator<Entry<R, Map<C, V>>>.hasNext", "Iterator<Entry<R, Map<C, V>>>.next", "Entry<R, Map<C, V>>.getValue", "Map<C, V>.get", "Predicate<? super Entry<R,V>>.apply", "Entry<R, Map<C, V>>.getKey", "Map<C, V>.remove", "Map<C, V>.isEmpty", "Iterator<Entry<R, Map<C, V>>>.remove"], "method_name": "Column.removeFromColumnIf", "method_implementation": "{\n    boolean changed = false;\n    Iterator<Entry<R, Map<C, V>>> iterator = backingMap.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Entry<R, Map<C, V>> entry = iterator.next();\n        Map<C, V> map = entry.getValue();\n        V value = map.get(columnKey);\n        if (value != null && predicate.apply(Maps.immutableEntry(entry.getKey(), value))) {\n            map.remove(columnKey);\n            changed = true;\n            if (map.isEmpty()) {\n                iterator.remove();\n            }\n        }\n    }\n    return changed;\n}", "repo_id": "5", "comment": "/**\n * Removes all {@code Column} mappings whose row key and value satisfy the given predicate.\n */\n", "repo_name": "guava-master/", "id": 6415, "method_signature": "boolean removeFromColumnIf(Predicate)", "filename": "Column.removeFromColumnIf.json"}
{"callee_method_names": [], "method_name": "Column.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5553, "method_signature": "Object writeReplace()", "filename": "Column.writeReplace.json"}
{"callee_method_names": [], "method_name": "ColumnMap.get", "method_implementation": "{\n    // requireNonNull is safe because of the containsColumn check.\n    return containsColumn(key) ? column((C) requireNonNull(key)) : null;\n}", "repo_id": "5", "comment": "// has the correct type.\n", "repo_name": "guava-master/", "id": 6417, "method_signature": "Map<R,V> get(Object)", "filename": "ColumnMap.get.json"}
{"callee_method_names": [], "method_name": "ColumnMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5555, "method_signature": "Object writeReplace()", "filename": "ColumnMap.writeReplace.json"}
{"callee_method_names": ["CombiningCallable<V>.toString", "ClosingFuture<V>.add"], "method_name": "Combiner.call", "method_implementation": "{\n    Callable<V> callable = new Callable<V>() {\n\n        @Override\n        @ParametricNullness\n        public V call() throws Exception {\n            return new Peeker(inputs).call(combiningCallable, closeables);\n        }\n\n        @Override\n        public String toString() {\n            return combiningCallable.toString();\n        }\n    };\n    ClosingFuture<V> derived = new ClosingFuture<>(futureCombiner().call(callable, executor));\n    derived.closeables.add(closeables, directExecutor());\n    return derived;\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * combining function to their values. The function can use a {@link DeferredCloser} to capture\n * objects to be closed when the pipeline is done.\n *\n * <p>If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs\n * fail, so will the returned step.\n *\n * <p>If the combiningCallable throws a {@code CancellationException}, the pipeline will be\n * cancelled.\n *\n * <p>If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown\n * {@code ExecutionException} will be extracted and used as the failure of the derived step.\n */\n", "repo_name": "guava-master/", "id": 5420, "method_signature": "ClosingFuture<V> call(CombiningCallable, Executor)", "filename": "Combiner.call.json"}
{"callee_method_names": ["AsyncCombiningCallable<V>.toString", "ClosingFuture<V>.add"], "method_name": "Combiner.callAsync", "method_implementation": "{\n    AsyncCallable<V> asyncCallable = new AsyncCallable<V>() {\n\n        @Override\n        public ListenableFuture<V> call() throws Exception {\n            return new Peeker(inputs).callAsync(combiningCallable, closeables);\n        }\n\n        @Override\n        public String toString() {\n            return combiningCallable.toString();\n        }\n    };\n    ClosingFuture<V> derived = new ClosingFuture<>(futureCombiner().callAsync(asyncCallable, executor));\n    derived.closeables.add(closeables, directExecutor());\n    return derived;\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * {@code ClosingFuture}-returning function to their values. The function can use a {@link\n * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those\n * captured by the returned {@link ClosingFuture}).\n *\n * <p>If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs\n * fail, so will the returned step.\n *\n * <p>If the combiningCallable throws a {@code CancellationException}, the pipeline will be\n * cancelled.\n *\n * <p>If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown\n * {@code ExecutionException} will be extracted and used as the failure of the derived step.\n *\n * <p>If the combiningCallable throws any other exception, it will be used as the failure of the\n * derived step.\n *\n * <p>If an exception is thrown after the combiningCallable creates a {@code ClosingFuture},\n * then none of the closeable objects in that {@code ClosingFuture} will be closed.\n *\n * <p>Usage guidelines for this method:\n *\n * <ul>\n *   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a\n *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,\n *       Executor)} instead, with a function that returns the next value directly.\n *   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}\n *       for every closeable object this step creates in order to capture it for later closing.\n *   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code\n *       ClosingFuture} call {@link #from(ListenableFuture)}.\n * </ul>\n *\n * <p>The same warnings about doing heavyweight operations within {@link\n * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.\n */\n", "repo_name": "guava-master/", "id": 5421, "method_signature": "ClosingFuture<V> callAsync(AsyncCombiningCallable, Executor)", "filename": "Combiner.callAsync.json"}
{"callee_method_names": ["ClosingFunction2<V1,V2,U>.apply", "ClosingFunction2<V1,V2,U>.toString"], "method_name": "Combiner2.call", "method_implementation": "{\n    return call(new CombiningCallable<U>() {\n\n        @Override\n        @ParametricNullness\n        public U call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * combining function to their values. The function can use a {@link DeferredCloser} to capture\n * objects to be closed when the pipeline is done.\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and\n * any of the inputs fail, so will the returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n */\n", "repo_name": "guava-master/", "id": 5422, "method_signature": "ClosingFuture<U> call(ClosingFunction2, Executor)", "filename": "Combiner2.call.json"}
{"callee_method_names": ["AsyncClosingFunction2<V1,V2,U>.apply", "AsyncClosingFunction2<V1,V2,U>.toString"], "method_name": "Combiner2.callAsync", "method_implementation": "{\n    return callAsync(new AsyncCombiningCallable<U>() {\n\n        @Override\n        public ClosingFuture<U> call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * {@code ClosingFuture}-returning function to their values. The function can use a {@link\n * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those\n * captured by the returned {@link ClosingFuture}).\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and\n * any of the inputs fail, so will the returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n *\n * <p>If the function throws any other exception, it will be used as the failure of the derived\n * step.\n *\n * <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of\n * the closeable objects in that {@code ClosingFuture} will be closed.\n *\n * <p>Usage guidelines for this method:\n *\n * <ul>\n *   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a\n *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,\n *       Executor)} instead, with a function that returns the next value directly.\n *   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}\n *       for every closeable object this step creates in order to capture it for later closing.\n *   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code\n *       ClosingFuture} call {@link #from(ListenableFuture)}.\n * </ul>\n *\n * <p>The same warnings about doing heavyweight operations within {@link\n * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.\n */\n", "repo_name": "guava-master/", "id": 5423, "method_signature": "ClosingFuture<U> callAsync(AsyncClosingFunction2, Executor)", "filename": "Combiner2.callAsync.json"}
{"callee_method_names": ["ClosingFunction3<V1,V2,V3,U>.apply", "ClosingFunction3<V1,V2,V3,U>.toString"], "method_name": "Combiner3.call", "method_implementation": "{\n    return call(new CombiningCallable<U>() {\n\n        @Override\n        @ParametricNullness\n        public U call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * combining function to their values. The function can use a {@link DeferredCloser} to capture\n * objects to be closed when the pipeline is done.\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture)} and any of the inputs fail, so will the returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n */\n", "repo_name": "guava-master/", "id": 5424, "method_signature": "ClosingFuture<U> call(ClosingFunction3, Executor)", "filename": "Combiner3.call.json"}
{"callee_method_names": ["AsyncClosingFunction3<V1,V2,V3,U>.apply", "AsyncClosingFunction3<V1,V2,V3,U>.toString"], "method_name": "Combiner3.callAsync", "method_implementation": "{\n    return callAsync(new AsyncCombiningCallable<U>() {\n\n        @Override\n        public ClosingFuture<U> call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * {@code ClosingFuture}-returning function to their values. The function can use a {@link\n * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those\n * captured by the returned {@link ClosingFuture}).\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture)} and any of the inputs fail, so will the returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n *\n * <p>If the function throws any other exception, it will be used as the failure of the derived\n * step.\n *\n * <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of\n * the closeable objects in that {@code ClosingFuture} will be closed.\n *\n * <p>Usage guidelines for this method:\n *\n * <ul>\n *   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a\n *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,\n *       Executor)} instead, with a function that returns the next value directly.\n *   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}\n *       for every closeable object this step creates in order to capture it for later closing.\n *   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code\n *       ClosingFuture} call {@link #from(ListenableFuture)}.\n * </ul>\n *\n * <p>The same warnings about doing heavyweight operations within {@link\n * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.\n */\n", "repo_name": "guava-master/", "id": 5425, "method_signature": "ClosingFuture<U> callAsync(AsyncClosingFunction3, Executor)", "filename": "Combiner3.callAsync.json"}
{"callee_method_names": ["ClosingFunction4<V1,V2,V3,V4,U>.apply", "ClosingFunction4<V1,V2,V3,V4,U>.toString"], "method_name": "Combiner4.call", "method_implementation": "{\n    return call(new CombiningCallable<U>() {\n\n        @Override\n        @ParametricNullness\n        public U call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3), peeker.getDone(future4));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * combining function to their values. The function can use a {@link DeferredCloser} to capture\n * objects to be closed when the pipeline is done.\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n */\n", "repo_name": "guava-master/", "id": 5426, "method_signature": "ClosingFuture<U> call(ClosingFunction4, Executor)", "filename": "Combiner4.call.json"}
{"callee_method_names": ["AsyncClosingFunction4<V1,V2,V3,V4,U>.apply", "AsyncClosingFunction4<V1,V2,V3,V4,U>.toString"], "method_name": "Combiner4.callAsync", "method_implementation": "{\n    return callAsync(new AsyncCombiningCallable<U>() {\n\n        @Override\n        public ClosingFuture<U> call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3), peeker.getDone(future4));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * {@code ClosingFuture}-returning function to their values. The function can use a {@link\n * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those\n * captured by the returned {@link ClosingFuture}).\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n *\n * <p>If the function throws any other exception, it will be used as the failure of the derived\n * step.\n *\n * <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of\n * the closeable objects in that {@code ClosingFuture} will be closed.\n *\n * <p>Usage guidelines for this method:\n *\n * <ul>\n *   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a\n *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,\n *       Executor)} instead, with a function that returns the next value directly.\n *   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}\n *       for every closeable object this step creates in order to capture it for later closing.\n *   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code\n *       ClosingFuture} call {@link #from(ListenableFuture)}.\n * </ul>\n *\n * <p>The same warnings about doing heavyweight operations within {@link\n * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.\n */\n", "repo_name": "guava-master/", "id": 5427, "method_signature": "ClosingFuture<U> callAsync(AsyncClosingFunction4, Executor)", "filename": "Combiner4.callAsync.json"}
{"callee_method_names": ["ClosingFunction5<V1,V2,V3,V4,V5,U>.apply", "ClosingFunction5<V1,V2,V3,V4,V5,U>.toString"], "method_name": "Combiner5.call", "method_implementation": "{\n    return call(new CombiningCallable<U>() {\n\n        @Override\n        @ParametricNullness\n        public U call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3), peeker.getDone(future4), peeker.getDone(future5));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * combining function to their values. The function can use a {@link DeferredCloser} to capture\n * objects to be closed when the pipeline is done.\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the\n * returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n */\n", "repo_name": "guava-master/", "id": 5428, "method_signature": "ClosingFuture<U> call(ClosingFunction5, Executor)", "filename": "Combiner5.call.json"}
{"callee_method_names": ["AsyncClosingFunction5<V1,V2,V3,V4,V5,U>.apply", "AsyncClosingFunction5<V1,V2,V3,V4,V5,U>.toString"], "method_name": "Combiner5.callAsync", "method_implementation": "{\n    return callAsync(new AsyncCombiningCallable<U>() {\n\n        @Override\n        public ClosingFuture<U> call(DeferredCloser closer, Peeker peeker) throws Exception {\n            return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2), peeker.getDone(future3), peeker.getDone(future4), peeker.getDone(future5));\n        }\n\n        @Override\n        public String toString() {\n            return function.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a\n * {@code ClosingFuture}-returning function to their values. The function can use a {@link\n * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those\n * captured by the returned {@link ClosingFuture}).\n *\n * <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,\n * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the\n * returned step.\n *\n * <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.\n *\n * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code\n * ExecutionException} will be extracted and used as the failure of the derived step.\n *\n * <p>If the function throws any other exception, it will be used as the failure of the derived\n * step.\n *\n * <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of\n * the closeable objects in that {@code ClosingFuture} will be closed.\n *\n * <p>Usage guidelines for this method:\n *\n * <ul>\n *   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a\n *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,\n *       Executor)} instead, with a function that returns the next value directly.\n *   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}\n *       for every closeable object this step creates in order to capture it for later closing.\n *   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code\n *       ClosingFuture} call {@link #from(ListenableFuture)}.\n * </ul>\n *\n * <p>The same warnings about doing heavyweight operations within {@link\n * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.\n */\n", "repo_name": "guava-master/", "id": 5429, "method_signature": "ClosingFuture<U> callAsync(AsyncClosingFunction5, Executor)", "filename": "Combiner5.callAsync.json"}
{"callee_method_names": [], "method_name": "CompactHashMap.allocArrays", "method_implementation": "{\n    Preconditions.checkState(needsAllocArrays(), \"Arrays already allocated\");\n    int expectedSize = metadata;\n    int buckets = CompactHashing.tableSize(expectedSize);\n    this.table = CompactHashing.createTable(buckets);\n    setHashTableMask(buckets - 1);\n    this.entries = new int[expectedSize];\n    this.keys = new Object[expectedSize];\n    this.values = new Object[expectedSize];\n    return expectedSize;\n}", "repo_id": "5", "comment": "/**\n * Handle lazy allocation of arrays.\n */\n", "repo_name": "guava-master/", "id": 6052, "method_signature": "int allocArrays()", "filename": "CompactHashMap.allocArrays.json"}
{"callee_method_names": [], "method_name": "CompactHashMap.init", "method_implementation": "{\n    Preconditions.checkArgument(expectedSize >= 0, \"Expected size must be >= 0\");\n    // Save expectedSize for use in allocArrays()\n    this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);\n}", "repo_id": "5", "comment": "/**\n * Pseudoconstructor for serialization support.\n */\n", "repo_name": "guava-master/", "id": 6051, "method_signature": "void init(int)", "filename": "CompactHashMap.init.json"}
{"callee_method_names": [], "method_name": "CompactHashMap.insertEntry", "method_implementation": "{\n    this.setEntry(entryIndex, CompactHashing.maskCombine(hash, UNSET, mask));\n    this.setKey(entryIndex, key);\n    this.setValue(entryIndex, value);\n}", "repo_id": "5", "comment": "/**\n * Creates a fresh entry with the specified object at the specified position in the entry arrays.\n */\n", "repo_name": "guava-master/", "id": 6054, "method_signature": "void insertEntry(int, K, V, int, int)", "filename": "CompactHashMap.insertEntry.json"}
{"callee_method_names": [], "method_name": "CompactHashMap.moveLastEntry", "method_implementation": "{\n    Object table = requireTable();\n    int[] entries = requireEntries();\n    @Nullable\n    Object[] keys = requireKeys();\n    @Nullable\n    Object[] values = requireValues();\n    int srcIndex = size() - 1;\n    if (dstIndex < srcIndex) {\n        // move last entry to deleted spot\n        Object key = keys[srcIndex];\n        keys[dstIndex] = key;\n        values[dstIndex] = values[srcIndex];\n        keys[srcIndex] = null;\n        values[srcIndex] = null;\n        // move the last entry to the removed spot, just like we moved the element\n        entries[dstIndex] = entries[srcIndex];\n        entries[srcIndex] = 0;\n        // also need to update whoever's \"next\" pointer was pointing to the last entry place\n        int tableIndex = smearedHash(key) & mask;\n        int next = CompactHashing.tableGet(table, tableIndex);\n        int srcNext = srcIndex + 1;\n        if (next == srcNext) {\n            // we need to update the root pointer\n            CompactHashing.tableSet(table, tableIndex, dstIndex + 1);\n        } else {\n            // we need to update a pointer in an entry\n            int entryIndex;\n            int entry;\n            do {\n                entryIndex = next - 1;\n                entry = entries[entryIndex];\n                next = CompactHashing.getNext(entry, mask);\n            } while (next != srcNext);\n            // here, entries[entryIndex] points to the old entry location; update it\n            entries[entryIndex] = CompactHashing.maskCombine(entry, dstIndex + 1, mask);\n        }\n    } else {\n        keys[dstIndex] = null;\n        values[dstIndex] = null;\n        entries[dstIndex] = 0;\n    }\n}", "repo_id": "5", "comment": "/**\n * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.\n */\n", "repo_name": "guava-master/", "id": 6057, "method_signature": "void moveLastEntry(int, int)", "filename": "CompactHashMap.moveLastEntry.json"}
{"callee_method_names": [], "method_name": "CompactHashMap.resizeEntries", "method_implementation": "{\n    this.entries = Arrays.copyOf(requireEntries(), newCapacity);\n    this.keys = Arrays.copyOf(requireKeys(), newCapacity);\n    this.values = Arrays.copyOf(requireValues(), newCapacity);\n}", "repo_id": "5", "comment": "/**\n * Resizes the internal entries array to the specified capacity, which may be greater or less than\n * the current capacity.\n */\n", "repo_name": "guava-master/", "id": 6056, "method_signature": "void resizeEntries(int)", "filename": "CompactHashMap.resizeEntries.json"}
{"callee_method_names": [], "method_name": "CompactHashMap.resizeMeMaybe", "method_implementation": "{\n    int entriesSize = requireEntries().length;\n    if (newSize > entriesSize) {\n        // 1.5x but round up to nearest odd (this is optimal for memory consumption on Android)\n        int newCapacity = Math.min(CompactHashing.MAX_SIZE, (entriesSize + Math.max(1, entriesSize >>> 1)) | 1);\n        if (newCapacity != entriesSize) {\n            resizeEntries(newCapacity);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Resizes the entries storage if necessary.\n */\n", "repo_name": "guava-master/", "id": 6055, "method_signature": "void resizeMeMaybe(int)", "filename": "CompactHashMap.resizeMeMaybe.json"}
{"callee_method_names": [], "method_name": "CompactHashMap.setHashTableMask", "method_implementation": "{\n    int hashTableBits = Integer.SIZE - Integer.numberOfLeadingZeros(mask);\n    metadata = CompactHashing.maskCombine(metadata, hashTableBits, CompactHashing.HASH_TABLE_BITS_MASK);\n}", "repo_id": "5", "comment": "/**\n * Stores the hash table mask as the number of bits needed to represent an index.\n */\n", "repo_name": "guava-master/", "id": 6053, "method_signature": "void setHashTableMask(int)", "filename": "CompactHashMap.setHashTableMask.json"}
{"callee_method_names": ["Map<K, V>.putAll"], "method_name": "CompactHashMap.trimToSize", "method_implementation": "{\n    if (needsAllocArrays()) {\n        return;\n    }\n    Map<K, V> delegate = delegateOrNull();\n    if (delegate != null) {\n        Map<K, V> newDelegate = createHashFloodingResistantDelegate(size());\n        newDelegate.putAll(delegate);\n        this.table = newDelegate;\n        return;\n    }\n    int size = this.size;\n    if (size < requireEntries().length) {\n        resizeEntries(size);\n    }\n    int minimumTableSize = CompactHashing.tableSize(size);\n    int mask = hashTableMask();\n    if (minimumTableSize < mask) {\n        // smaller table size will always be less than current mask\n        resizeTable(mask, minimumTableSize, UNSET, UNSET);\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures that this {@code CompactHashMap} has the smallest representation in memory, given its\n * current size.\n */\n", "repo_name": "guava-master/", "id": 6058, "method_signature": "void trimToSize()", "filename": "CompactHashMap.trimToSize.json"}
{"callee_method_names": [], "method_name": "CompactHashSet.allocArrays", "method_implementation": "{\n    Preconditions.checkState(needsAllocArrays(), \"Arrays already allocated\");\n    int expectedSize = metadata;\n    int buckets = CompactHashing.tableSize(expectedSize);\n    this.table = CompactHashing.createTable(buckets);\n    setHashTableMask(buckets - 1);\n    this.entries = new int[expectedSize];\n    this.elements = new Object[expectedSize];\n    return expectedSize;\n}", "repo_id": "5", "comment": "/**\n * Handle lazy allocation of arrays.\n */\n", "repo_name": "guava-master/", "id": 6166, "method_signature": "int allocArrays()", "filename": "CompactHashSet.allocArrays.json"}
{"callee_method_names": [], "method_name": "CompactHashSet.create", "method_implementation": "{\n    CompactHashSet<E> set = createWithExpectedSize(elements.length);\n    Collections.addAll(set, elements);\n    return set;\n}", "repo_id": "5", "comment": "/**\n * Creates a <i>mutable</i> {@code CompactHashSet} instance containing the given elements in\n * unspecified order.\n *\n * @param elements the elements that the set should contain\n * @return a new {@code CompactHashSet} containing those elements (minus duplicates)\n */\n", "repo_name": "guava-master/", "id": 6164, "method_signature": "CompactHashSet<E> create(E[])", "filename": "CompactHashSet.create.json"}
{"callee_method_names": [], "method_name": "CompactHashSet.init", "method_implementation": "{\n    Preconditions.checkArgument(expectedSize >= 0, \"Expected size must be >= 0\");\n    // Save expectedSize for use in allocArrays()\n    this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);\n}", "repo_id": "5", "comment": "/**\n * Pseudoconstructor for serialization support.\n */\n", "repo_name": "guava-master/", "id": 6165, "method_signature": "void init(int)", "filename": "CompactHashSet.init.json"}
{"callee_method_names": [], "method_name": "CompactHashSet.moveLastEntry", "method_implementation": "{\n    Object table = requireTable();\n    int[] entries = requireEntries();\n    @Nullable\n    Object[] elements = requireElements();\n    int srcIndex = size() - 1;\n    if (dstIndex < srcIndex) {\n        // move last entry to deleted spot\n        Object object = elements[srcIndex];\n        elements[dstIndex] = object;\n        elements[srcIndex] = null;\n        // move the last entry to the removed spot, just like we moved the element\n        entries[dstIndex] = entries[srcIndex];\n        entries[srcIndex] = 0;\n        // also need to update whoever's \"next\" pointer was pointing to the last entry place\n        int tableIndex = smearedHash(object) & mask;\n        int next = CompactHashing.tableGet(table, tableIndex);\n        int srcNext = srcIndex + 1;\n        if (next == srcNext) {\n            // we need to update the root pointer\n            CompactHashing.tableSet(table, tableIndex, dstIndex + 1);\n        } else {\n            // we need to update a pointer in an entry\n            int entryIndex;\n            int entry;\n            do {\n                entryIndex = next - 1;\n                entry = entries[entryIndex];\n                next = CompactHashing.getNext(entry, mask);\n            } while (next != srcNext);\n            // here, entries[entryIndex] points to the old entry location; update it\n            entries[entryIndex] = CompactHashing.maskCombine(entry, dstIndex + 1, mask);\n        }\n    } else {\n        elements[dstIndex] = null;\n        entries[dstIndex] = 0;\n    }\n}", "repo_id": "5", "comment": "/**\n * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.\n */\n", "repo_name": "guava-master/", "id": 6169, "method_signature": "void moveLastEntry(int, int)", "filename": "CompactHashSet.moveLastEntry.json"}
{"callee_method_names": [], "method_name": "CompactHashSet.resizeMeMaybe", "method_implementation": "{\n    int entriesSize = requireEntries().length;\n    if (newSize > entriesSize) {\n        // 1.5x but round up to nearest odd (this is optimal for memory consumption on Android)\n        int newCapacity = Math.min(CompactHashing.MAX_SIZE, (entriesSize + Math.max(1, entriesSize >>> 1)) | 1);\n        if (newCapacity != entriesSize) {\n            resizeEntries(newCapacity);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Resizes the entries storage if necessary.\n */\n", "repo_name": "guava-master/", "id": 6168, "method_signature": "void resizeMeMaybe(int)", "filename": "CompactHashSet.resizeMeMaybe.json"}
{"callee_method_names": [], "method_name": "CompactHashSet.setHashTableMask", "method_implementation": "{\n    int hashTableBits = Integer.SIZE - Integer.numberOfLeadingZeros(mask);\n    metadata = CompactHashing.maskCombine(metadata, hashTableBits, CompactHashing.HASH_TABLE_BITS_MASK);\n}", "repo_id": "5", "comment": "/**\n * Stores the hash table mask as the number of bits needed to represent an index.\n */\n", "repo_name": "guava-master/", "id": 6167, "method_signature": "void setHashTableMask(int)", "filename": "CompactHashSet.setHashTableMask.json"}
{"callee_method_names": ["Set<E>.addAll"], "method_name": "CompactHashSet.trimToSize", "method_implementation": "{\n    if (needsAllocArrays()) {\n        return;\n    }\n    Set<E> delegate = delegateOrNull();\n    if (delegate != null) {\n        Set<E> newDelegate = createHashFloodingResistantDelegate(size());\n        newDelegate.addAll(delegate);\n        this.table = newDelegate;\n        return;\n    }\n    int size = this.size;\n    if (size < requireEntries().length) {\n        resizeEntries(size);\n    }\n    int minimumTableSize = CompactHashing.tableSize(size);\n    int mask = hashTableMask();\n    if (minimumTableSize < mask) {\n        // smaller table size will always be less than current mask\n        resizeTable(mask, minimumTableSize, UNSET, UNSET);\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures that this {@code CompactHashSet} has the smallest representation in memory, given its\n * current size.\n */\n", "repo_name": "guava-master/", "id": 6170, "method_signature": "void trimToSize()", "filename": "CompactHashSet.trimToSize.json"}
{"callee_method_names": [], "method_name": "CompactHashing.createTable", "method_implementation": "{\n    if (buckets < 2 || buckets > Ints.MAX_POWER_OF_TWO || Integer.highestOneBit(buckets) != buckets) {\n        throw new IllegalArgumentException(\"must be power of 2 between 2^1 and 2^30: \" + buckets);\n    }\n    if (buckets <= BYTE_MAX_SIZE) {\n        return new byte[buckets];\n    } else if (buckets <= SHORT_MAX_SIZE) {\n        return new short[buckets];\n    } else {\n        return new int[buckets];\n    }\n}", "repo_id": "5", "comment": "/**\n * Creates and returns a properly-sized array with the given number of buckets.\n */\n", "repo_name": "guava-master/", "id": 6219, "method_signature": "Object createTable(int)", "filename": "CompactHashing.createTable.json"}
{"callee_method_names": [], "method_name": "CompactHashing.tableGet", "method_implementation": "{\n    if (table instanceof byte[]) {\n        // unsigned read\n        return ((byte[]) table)[index] & BYTE_MASK;\n    } else if (table instanceof short[]) {\n        // unsigned read\n        return ((short[]) table)[index] & SHORT_MASK;\n    } else {\n        return ((int[]) table)[index];\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n * is unsigned, so the range of possible returned values is 0\u2013255 or 0\u201365535, respectively.\n */\n", "repo_name": "guava-master/", "id": 6220, "method_signature": "int tableGet(Object, int)", "filename": "CompactHashing.tableGet.json"}
{"callee_method_names": [], "method_name": "CompactHashing.tableSet", "method_implementation": "{\n    if (table instanceof byte[]) {\n        // unsigned write\n        ((byte[]) table)[index] = (byte) entry;\n    } else if (table instanceof short[]) {\n        // unsigned write\n        ((short[]) table)[index] = (short) entry;\n    } else {\n        ((int[]) table)[index] = entry;\n    }\n}", "repo_id": "5", "comment": "/**\n * Sets {@code table[index]} to {@code entry}, where {@code table} is actually a {@code byte[]},\n * {@code short[]}, or {@code int[]}. The value of {@code entry} should fit in the size of the\n * assigned array element, when seen as an unsigned value. So if {@code table} is a {@code byte[]}\n * then we should have {@code 0 \u2264 entry \u2264 255}, and if {@code table} is a {@code short[]} then we\n * should have {@code 0 \u2264 entry \u2264 65535}. It is the caller's responsibility to ensure this.\n */\n", "repo_name": "guava-master/", "id": 6221, "method_signature": "void tableSet(Object, int, int)", "filename": "CompactHashing.tableSet.json"}
{"callee_method_names": [], "method_name": "CompactLinkedHashSet.create", "method_implementation": "{\n    CompactLinkedHashSet<E> set = createWithExpectedSize(elements.length);\n    Collections.addAll(set, elements);\n    return set;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code CompactLinkedHashSet} instance containing the given elements in unspecified\n * order.\n *\n * @param elements the elements that the set should contain\n * @return a new {@code CompactLinkedHashSet} containing those elements (minus duplicates)\n */\n", "repo_name": "guava-master/", "id": 6011, "method_signature": "CompactLinkedHashSet<E> create(E[])", "filename": "CompactLinkedHashSet.create.json"}
{"callee_method_names": ["Object.orElse"], "method_name": "Comparators.emptiesFirst", "method_implementation": "{\n    checkNotNull(valueComparator);\n    return Comparator.<Optional<T>, @Nullable T>comparing(o -> o.orElse(null), Comparator.nullsFirst(valueComparator));\n}", "repo_id": "5", "comment": "/**\n * Returns a comparator of {@link Optional} values which treats {@link Optional#empty} as less\n * than all other values, and orders the rest using {@code valueComparator} on the contained\n * value.\n *\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 3107, "method_signature": "Comparator<Optional<T>> emptiesFirst(Comparator)", "filename": "Comparators.emptiesFirst.json"}
{"callee_method_names": ["Object.orElse"], "method_name": "Comparators.emptiesLast", "method_implementation": "{\n    checkNotNull(valueComparator);\n    return Comparator.<Optional<T>, @Nullable T>comparing(o -> o.orElse(null), Comparator.nullsLast(valueComparator));\n}", "repo_id": "5", "comment": "/**\n * Returns a comparator of {@link Optional} values which treats {@link Optional#empty} as greater\n * than all other values, and orders the rest using {@code valueComparator} on the contained\n * value.\n *\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 3108, "method_signature": "Comparator<Optional<T>> emptiesLast(Comparator)", "filename": "Comparators.emptiesLast.json"}
{"callee_method_names": ["Comparator<? super T>.reversed"], "method_name": "Comparators.greatest", "method_implementation": "{\n    return least(k, comparator.reversed());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that returns the {@code k} greatest (relative to the specified\n * {@code Comparator}) input elements, in descending order, as an unmodifiable {@code List}. Ties\n * are broken arbitrarily.\n *\n * <p>For example:\n *\n * <pre>{@code\n * Stream.of(\"foo\", \"quux\", \"banana\", \"elephant\")\n *     .collect(greatest(2, comparingInt(String::length)))\n * // returns {\"elephant\", \"banana\"}\n * }</pre>\n *\n * <p>This {@code Collector} uses O(k) memory and takes expected time O(n) (worst-case O(n log\n * k)), as opposed to e.g. {@code Stream.sorted(comparator.reversed()).limit(k)}, which currently\n * takes O(n log n) time and O(n) space.\n *\n * @throws IllegalArgumentException if {@code k < 0}\n */\n", "repo_name": "guava-master/", "id": 6474, "method_signature": "Collector<T,?,List<T>> greatest(int, Comparator)", "filename": "Comparators.greatest.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Comparator<T>.compare"], "method_name": "Comparators.isInOrder", "method_implementation": "{\n    checkNotNull(comparator);\n    Iterator<? extends T> it = iterable.iterator();\n    if (it.hasNext()) {\n        T prev = it.next();\n        while (it.hasNext()) {\n            T next = it.next();\n            if (comparator.compare(prev, next) > 0) {\n                return false;\n            }\n            prev = next;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if each element in {@code iterable} after the first is greater than or\n * equal to the element that preceded it, according to the specified comparator. Note that this is\n * always true when the iterable has fewer than two elements.\n */\n", "repo_name": "guava-master/", "id": 6471, "method_signature": "boolean isInOrder(Iterable, Comparator)", "filename": "Comparators.isInOrder.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Comparator<T>.compare"], "method_name": "Comparators.isInStrictOrder", "method_implementation": "{\n    checkNotNull(comparator);\n    Iterator<? extends T> it = iterable.iterator();\n    if (it.hasNext()) {\n        T prev = it.next();\n        while (it.hasNext()) {\n            T next = it.next();\n            if (comparator.compare(prev, next) >= 0) {\n                return false;\n            }\n            prev = next;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if each element in {@code iterable} after the first is <i>strictly</i>\n * greater than the element that preceded it, according to the specified comparator. Note that\n * this is always true when the iterable has fewer than two elements.\n */\n", "repo_name": "guava-master/", "id": 6472, "method_signature": "boolean isInStrictOrder(Iterable, Comparator)", "filename": "Comparators.isInStrictOrder.json"}
{"callee_method_names": [], "method_name": "Comparators.least", "method_implementation": "{\n    checkNonnegative(k, \"k\");\n    checkNotNull(comparator);\n    return Collector.of(() -> TopKSelector.<T>least(k, comparator), TopKSelector::offer, TopKSelector::combine, TopKSelector::topK, Collector.Characteristics.UNORDERED);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that returns the {@code k} smallest (relative to the specified\n * {@code Comparator}) input elements, in ascending order, as an unmodifiable {@code List}. Ties\n * are broken arbitrarily.\n *\n * <p>For example:\n *\n * <pre>{@code\n * Stream.of(\"foo\", \"quux\", \"banana\", \"elephant\")\n *     .collect(least(2, comparingInt(String::length)))\n * // returns {\"foo\", \"quux\"}\n * }</pre>\n *\n * <p>This {@code Collector} uses O(k) memory and takes expected time O(n) (worst-case O(n log\n * k)), as opposed to e.g. {@code Stream.sorted(comparator).limit(k)}, which currently takes O(n\n * log n) time and O(n) space.\n *\n * @throws IllegalArgumentException if {@code k < 0}\n */\n", "repo_name": "guava-master/", "id": 6473, "method_signature": "Collector<T,?,List<T>> least(int, Comparator)", "filename": "Comparators.least.json"}
{"callee_method_names": ["Comparator<T>.compare"], "method_name": "Comparators.max", "method_implementation": "{\n    return (comparator.compare(a, b) >= 0) ? a : b;\n}", "repo_id": "5", "comment": "/**\n * Returns the maximum of the two values, according to the given comparator. If the values compare\n * as equal, the first is returned.\n *\n * <p>The recommended solution for finding the {@code maximum} of some values depends on the type\n * of your data and the number of elements you have. Read more in the Guava User Guide article on\n * <a href=\"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#comparators\">{@code\n * Comparators}</a>.\n *\n * @param a first value to compare, returned if greater than or equal to b.\n * @param b second value to compare.\n * @throws ClassCastException if the parameters are not <i>mutually comparable</i> using the given\n *     comparator.\n * @since 30.0\n */\n", "repo_name": "guava-master/", "id": 6476, "method_signature": "T max(T, T, Comparator)", "filename": "Comparators.max.json"}
{"callee_method_names": ["Comparator<T>.compare"], "method_name": "Comparators.min", "method_implementation": "{\n    return (comparator.compare(a, b) <= 0) ? a : b;\n}", "repo_id": "5", "comment": "/**\n * Returns the minimum of the two values, according to the given comparator. If the values compare\n * as equal, the first is returned.\n *\n * <p>The recommended solution for finding the {@code minimum} of some values depends on the type\n * of your data and the number of elements you have. Read more in the Guava User Guide article on\n * <a href=\"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#comparators\">{@code\n * Comparators}</a>.\n *\n * @param a first value to compare, returned if less than or equal to b\n * @param b second value to compare.\n * @throws ClassCastException if the parameters are not <i>mutually comparable</i> using the given\n *     comparator.\n * @since 30.0\n */\n", "repo_name": "guava-master/", "id": 6475, "method_signature": "T min(T, T, Comparator)", "filename": "Comparators.min.json"}
{"callee_method_names": ["Comparator<Foo>.compare", "Comparator<Foo>.compare"], "method_name": "ComparisonChainTest.testComparatorEquivalent", "method_implementation": "{\n    Comparator<Foo> comparatorUsingComparisonChain = (a, b) -> ComparisonChain.start().compare(a.aString, b.aString).compare(a.anInt, b.anInt).compare(a.anEnum, b.anEnum, Ordering.natural().nullsLast()).result();\n    Comparator<Foo> comparatorUsingComparatorMethods = comparing((Foo foo) -> foo.aString).thenComparing(foo -> foo.anInt).thenComparing(foo -> foo.anEnum, nullsLast(naturalOrder()));\n    ImmutableList<Foo> instances = ImmutableList.of(new Foo(\"a\", 1, TriState.TRUE), new Foo(\"a\", 2, TriState.TRUE), new Foo(\"b\", 1, TriState.FALSE), new Foo(\"b\", 1, TriState.TRUE), new Foo(\"b\", 1, null));\n    for (Foo a : instances) {\n        for (Foo b : instances) {\n            int comparedUsingComparisonChain = signum(comparatorUsingComparisonChain.compare(a, b));\n            int comparedUsingComparatorMethods = signum(comparatorUsingComparatorMethods.compare(a, b));\n            assertWithMessage(\"%s vs %s\", a, b).that(comparedUsingComparatorMethods).isEqualTo(comparedUsingComparisonChain);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Validates that the Comparator equivalent we document is correct.\n */\n", "repo_name": "guava-master/", "id": 482, "method_signature": "void testComparatorEquivalent()", "filename": "ComparisonChainTest.testComparatorEquivalent.json"}
{"callee_method_names": ["Bar.isBaz", "Bar.isBaz", "Comparator<Bar>.compare", "Bar.isBaz", "Bar.isBaz", "Comparator<Bar>.compare"], "method_name": "ComparisonChainTest.testTrueFirstFalseFirst", "method_implementation": "{\n    Bar trueBar = new Bar(true);\n    Bar falseBar = new Bar(false);\n    assertThat(ComparisonChain.start().compareTrueFirst(trueBar.isBaz(), falseBar.isBaz()).result()).isLessThan(0);\n    Comparator<Bar> trueFirstComparator = comparing(Bar::isBaz, Booleans.trueFirst());\n    assertThat(trueFirstComparator.compare(trueBar, falseBar)).isLessThan(0);\n    assertThat(ComparisonChain.start().compareFalseFirst(falseBar.isBaz(), trueBar.isBaz()).result()).isLessThan(0);\n    Comparator<Bar> falseFirstComparator = comparing(Bar::isBaz, Booleans.falseFirst());\n    assertThat(falseFirstComparator.compare(falseBar, trueBar)).isLessThan(0);\n}", "repo_id": "5", "comment": "/**\n * Validates that {@link Booleans#trueFirst()} and {@link Booleans#falseFirst()} can be used with\n * {@link Comparator} when replacing {@link ComparisonChain#compareTrueFirst} and {@link\n * ComparisonChain#compareFalseFirst}, as we document.\n */\n", "repo_name": "guava-master/", "id": 483, "method_signature": "void testTrueFirstFalseFirst()", "filename": "ComparisonChainTest.testTrueFirstFalseFirst.json"}
{"callee_method_names": [], "method_name": "ComplementRanges.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6636, "method_signature": "Object writeReplace()", "filename": "ComplementRanges.writeReplace.json"}
{"callee_method_names": [], "method_name": "Completion.assertCompletionNotExpected", "method_implementation": "{\n    Preconditions.checkArgument(timeout < expectedCompletionWaitMillis);\n    assertAtLeastTimePassed(stopwatch, timeout);\n    assertTimeNotPassed(stopwatch, expectedCompletionWaitMillis);\n}", "repo_id": "5", "comment": "/**\n * Asserts that at least {@code timeout} has passed but the expected completion time has not.\n */\n", "repo_name": "guava-master/", "id": 3934, "method_signature": "void assertCompletionNotExpected(long)", "filename": "Completion.assertCompletionNotExpected.json"}
{"callee_method_names": ["Iterator<? extends Iterator<? extends T>>.hasNext", "Deque<Iterator<? extends Iterator<? extends T>>>.isEmpty", "Deque<Iterator<? extends Iterator<? extends T>>>.removeFirst"], "method_name": "ConcatenatedIterator.getTopMetaIterator", "method_implementation": "{\n    while (topMetaIterator == null || !topMetaIterator.hasNext()) {\n        if (metaIterators != null && !metaIterators.isEmpty()) {\n            topMetaIterator = metaIterators.removeFirst();\n        } else {\n            return null;\n        }\n    }\n    return topMetaIterator;\n}", "repo_id": "5", "comment": "// Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.\n", "repo_name": "guava-master/", "id": 5691, "method_signature": "Iterator<? extends Iterator<? extends T>> getTopMetaIterator()", "filename": "ConcatenatedIterator.getTopMetaIterator.json"}
{"callee_method_names": ["ConcurrentMap<E, AtomicInteger>.putIfAbsent", "AtomicInteger.get", "AtomicInteger.compareAndSet", "ConcurrentMap<E, AtomicInteger>.putIfAbsent", "ConcurrentMap<E, AtomicInteger>.replace"], "method_name": "ConcurrentHashMultiset.add", "method_implementation": "{\n    checkNotNull(element);\n    if (occurrences == 0) {\n        return count(element);\n    }\n    CollectPreconditions.checkPositive(occurrences, \"occurrences\");\n    while (true) {\n        AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n        if (existingCounter == null) {\n            existingCounter = countMap.putIfAbsent(element, new AtomicInteger(occurrences));\n            if (existingCounter == null) {\n                return 0;\n            }\n            // existingCounter != null: fall through to operate against the existing AtomicInteger\n        }\n        while (true) {\n            int oldValue = existingCounter.get();\n            if (oldValue != 0) {\n                try {\n                    int newValue = IntMath.checkedAdd(oldValue, occurrences);\n                    if (existingCounter.compareAndSet(oldValue, newValue)) {\n                        // newValue can't == 0, so no need to check & remove\n                        return oldValue;\n                    }\n                } catch (ArithmeticException overflow) {\n                    throw new IllegalArgumentException(\"Overflow adding \" + occurrences + \" occurrences to a count of \" + oldValue);\n                }\n            } else {\n                // In the case of a concurrent remove, we might observe a zero value, which means another\n                // thread is about to remove (element, existingCounter) from the map. Rather than wait,\n                // we can just do that work here.\n                AtomicInteger newCounter = new AtomicInteger(occurrences);\n                if ((countMap.putIfAbsent(element, newCounter) == null) || countMap.replace(element, existingCounter, newCounter)) {\n                    return 0;\n                }\n                break;\n            }\n        }\n        // If we're still here, there was a race, so just try again.\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds a number of occurrences of the specified element to this multiset.\n *\n * @param element the element to add\n * @param occurrences the number of occurrences to add\n * @return the previous count of the element before the operation; possibly zero\n * @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting amount\n *     would exceed {@link Integer#MAX_VALUE}\n */\n", "repo_name": "guava-master/", "id": 6179, "method_signature": "int add(E, int)", "filename": "ConcurrentHashMultiset.add.json"}
{"callee_method_names": ["AtomicInteger.get"], "method_name": "ConcurrentHashMultiset.count", "method_implementation": "{\n    AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n    return (existingCounter == null) ? 0 : existingCounter.get();\n}", "repo_id": "5", "comment": "/**\n * Returns the number of occurrences of {@code element} in this multiset.\n *\n * @param element the element to look for\n * @return the nonnegative number of occurrences of the element\n */\n", "repo_name": "guava-master/", "id": 6176, "method_signature": "int count(Object)", "filename": "ConcurrentHashMultiset.count.json"}
{"callee_method_names": [], "method_name": "ConcurrentHashMultiset.create", "method_implementation": "{\n    ConcurrentHashMultiset<E> multiset = ConcurrentHashMultiset.create();\n    Iterables.addAll(multiset, elements);\n    return multiset;\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code ConcurrentHashMultiset} containing the specified elements, using the\n * default initial capacity, load factor, and concurrency settings.\n *\n * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.\n *\n * @param elements the elements that the multiset should contain\n */\n", "repo_name": "guava-master/", "id": 6175, "method_signature": "ConcurrentHashMultiset<E> create(Iterable)", "filename": "ConcurrentHashMultiset.create.json"}
{"callee_method_names": [], "method_name": "ConcurrentHashMultiset.createEntrySet", "method_implementation": "{\n    return new EntrySet();\n}", "repo_id": "5", "comment": "/**\n * @deprecated Internal method, use {@link #entrySet()}.\n */\n", "repo_name": "guava-master/", "id": 6184, "method_signature": "Set<Multiset.Entry<E>> createEntrySet()", "filename": "ConcurrentHashMultiset.createEntrySet.json"}
{"callee_method_names": ["AtomicInteger.get", "AtomicInteger.compareAndSet", "ConcurrentMap<E, AtomicInteger>.remove"], "method_name": "ConcurrentHashMultiset.remove", "method_implementation": "{\n    if (occurrences == 0) {\n        return count(element);\n    }\n    CollectPreconditions.checkPositive(occurrences, \"occurrences\");\n    AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n    if (existingCounter == null) {\n        return 0;\n    }\n    while (true) {\n        int oldValue = existingCounter.get();\n        if (oldValue != 0) {\n            int newValue = Math.max(0, oldValue - occurrences);\n            if (existingCounter.compareAndSet(oldValue, newValue)) {\n                if (newValue == 0) {\n                    // Just CASed to 0; remove the entry to clean up the map. If the removal fails,\n                    // another thread has already replaced it with a new counter, which is fine.\n                    countMap.remove(element, existingCounter);\n                }\n                return oldValue;\n            }\n        } else {\n            return 0;\n        }\n    }\n}", "repo_id": "5", "comment": "/*\n   * TODO(cpovirk): remove and removeExactly currently accept null inputs only\n   * if occurrences == 0. This satisfies both NullPointerTester and\n   * CollectionRemoveTester.testRemove_nullAllowed, but it's not clear that it's\n   * a good policy, especially because, in order for the test to pass, the\n   * parameter must be misleadingly annotated as @Nullable. I suspect that\n   * we'll want to remove @Nullable, add an eager checkNotNull, and loosen up\n   * testRemove_nullAllowed.\n   */\n", "repo_name": "guava-master/", "id": 6180, "method_signature": "int remove(Object, int)", "filename": "ConcurrentHashMultiset.remove.json"}
{"callee_method_names": ["AtomicInteger.get", "AtomicInteger.compareAndSet", "ConcurrentMap<E, AtomicInteger>.remove"], "method_name": "ConcurrentHashMultiset.removeExactly", "method_implementation": "{\n    if (occurrences == 0) {\n        return true;\n    }\n    CollectPreconditions.checkPositive(occurrences, \"occurrences\");\n    AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n    if (existingCounter == null) {\n        return false;\n    }\n    while (true) {\n        int oldValue = existingCounter.get();\n        if (oldValue < occurrences) {\n            return false;\n        }\n        int newValue = oldValue - occurrences;\n        if (existingCounter.compareAndSet(oldValue, newValue)) {\n            if (newValue == 0) {\n                // Just CASed to 0; remove the entry to clean up the map. If the removal fails,\n                // another thread has already replaced it with a new counter, which is fine.\n                countMap.remove(element, existingCounter);\n            }\n            return true;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes exactly the specified number of occurrences of {@code element}, or makes no change if\n * this is not possible.\n *\n * <p>This method, in contrast to {@link #remove(Object, int)}, has no effect when the element\n * count is smaller than {@code occurrences}.\n *\n * @param element the element to remove\n * @param occurrences the number of occurrences of {@code element} to remove\n * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)\n * @throws IllegalArgumentException if {@code occurrences} is negative\n */\n", "repo_name": "guava-master/", "id": 6181, "method_signature": "boolean removeExactly(Object, int)", "filename": "ConcurrentHashMultiset.removeExactly.json"}
{"callee_method_names": ["ConcurrentMap<E, AtomicInteger>.putIfAbsent", "AtomicInteger.get", "ConcurrentMap<E, AtomicInteger>.remove", "ConcurrentMap<E, AtomicInteger>.putIfAbsent", "ConcurrentMap<E, AtomicInteger>.replace", "AtomicInteger.compareAndSet", "ConcurrentMap<E, AtomicInteger>.remove"], "method_name": "ConcurrentHashMultiset.setCount", "method_implementation": "{\n    checkNotNull(element);\n    checkNonnegative(expectedOldCount, \"oldCount\");\n    checkNonnegative(newCount, \"newCount\");\n    AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n    if (existingCounter == null) {\n        if (expectedOldCount != 0) {\n            return false;\n        } else if (newCount == 0) {\n            return true;\n        } else {\n            // if our write lost the race, it must have lost to a nonzero value, so we can stop\n            return countMap.putIfAbsent(element, new AtomicInteger(newCount)) == null;\n        }\n    }\n    int oldValue = existingCounter.get();\n    if (oldValue == expectedOldCount) {\n        if (oldValue == 0) {\n            if (newCount == 0) {\n                // Just observed a 0; try to remove the entry to clean up the map\n                countMap.remove(element, existingCounter);\n                return true;\n            } else {\n                AtomicInteger newCounter = new AtomicInteger(newCount);\n                return (countMap.putIfAbsent(element, newCounter) == null) || countMap.replace(element, existingCounter, newCounter);\n            }\n        } else {\n            if (existingCounter.compareAndSet(oldValue, newCount)) {\n                if (newCount == 0) {\n                    // Just CASed to 0; remove the entry to clean up the map. If the removal fails,\n                    // another thread has already replaced it with a new counter, which is fine.\n                    countMap.remove(element, existingCounter);\n                }\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Sets the number of occurrences of {@code element} to {@code newCount}, but only if the count is\n * currently {@code expectedOldCount}. If {@code element} does not appear in the multiset exactly\n * {@code expectedOldCount} times, no changes will be made.\n *\n * @return {@code true} if the change was successful. This usually indicates that the multiset has\n *     been modified, but not always: in the case that {@code expectedOldCount == newCount}, the\n *     method will return {@code true} if the condition was met.\n * @throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative\n */\n", "repo_name": "guava-master/", "id": 6183, "method_signature": "boolean setCount(E, int, int)", "filename": "ConcurrentHashMultiset.setCount.json"}
{"callee_method_names": ["ConcurrentMap<E, AtomicInteger>.values", "V.get"], "method_name": "ConcurrentHashMultiset.size", "method_implementation": "{\n    long sum = 0L;\n    for (AtomicInteger value : countMap.values()) {\n        sum += value.get();\n    }\n    return Ints.saturatedCast(sum);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If the data in the multiset is modified by any other threads during this method, it is\n * undefined which (if any) of these modifications will be reflected in the result.\n */\n", "repo_name": "guava-master/", "id": 6177, "method_signature": "int size()", "filename": "ConcurrentHashMultiset.size.json"}
{"callee_method_names": ["int.getElement", "int.getCount", "List<E>.add"], "method_name": "ConcurrentHashMultiset.snapshot", "method_implementation": "{\n    List<E> list = Lists.newArrayListWithExpectedSize(size());\n    for (Multiset.Entry<E> entry : entrySet()) {\n        E element = entry.getElement();\n        for (int i = entry.getCount(); i > 0; i--) {\n            list.add(element);\n        }\n    }\n    return list;\n}", "repo_id": "5", "comment": "/*\n   * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but\n   * either of these would recurse back to us again!\n   */\n", "repo_name": "guava-master/", "id": 6178, "method_signature": "List<E> snapshot()", "filename": "ConcurrentHashMultiset.snapshot.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.putIfAbsent", "ConcurrentMap<E, Integer>.replace"], "method_name": "ConcurrentHashMultisetBenchmark.add", "method_implementation": "{\n    if (occurrences == 0) {\n        return count(element);\n    }\n    checkArgument(occurrences > 0, \"Invalid occurrences: %s\", occurrences);\n    while (true) {\n        int current = count(element);\n        if (current == 0) {\n            if (countMap.putIfAbsent(element, occurrences) == null) {\n                return 0;\n            }\n        } else {\n            checkArgument(occurrences <= Integer.MAX_VALUE - current, \"Overflow adding %s occurrences to a count of %s\", occurrences, current);\n            int next = current + occurrences;\n            if (countMap.replace(element, current, next)) {\n                return current;\n            }\n        }\n        // If we're still here, there was a race, so just try again.\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds a number of occurrences of the specified element to this multiset.\n *\n * @param element the element to add\n * @param occurrences the number of occurrences to add\n * @return the previous count of the element before the operation; possibly zero\n * @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting\n *     amount would exceed {@link Integer#MAX_VALUE}\n */\n", "repo_name": "guava-master/", "id": 3527, "method_signature": "int add(E, int)", "filename": "ConcurrentHashMultisetBenchmark.add.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.get"], "method_name": "ConcurrentHashMultisetBenchmark.count", "method_implementation": "{\n    try {\n        return unbox(countMap.get(element));\n    } catch (NullPointerException | ClassCastException e) {\n        return 0;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the number of occurrences of {@code element} in this multiset.\n *\n * @param element the element to look for\n * @return the nonnegative number of occurrences of the element\n */\n", "repo_name": "guava-master/", "id": 3524, "method_signature": "int count(Object)", "filename": "ConcurrentHashMultisetBenchmark.count.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.remove", "ConcurrentMap<E, Integer>.replace"], "method_name": "ConcurrentHashMultisetBenchmark.remove", "method_implementation": "{\n    if (occurrences == 0) {\n        return count(element);\n    }\n    checkArgument(occurrences > 0, \"Invalid occurrences: %s\", occurrences);\n    while (true) {\n        int current = count(element);\n        if (current == 0) {\n            return 0;\n        }\n        if (occurrences >= current) {\n            if (countMap.remove(element, current)) {\n                return current;\n            }\n        } else {\n            // We know it's an \"E\" because it already exists in the map.\n            @SuppressWarnings(\"unchecked\")\n            E casted = (E) element;\n            if (countMap.replace(casted, current, current - occurrences)) {\n                return current;\n            }\n        }\n        // If we're still here, there was a race, so just try again.\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes a number of occurrences of the specified element from this multiset. If the multiset\n * contains fewer than this number of occurrences to begin with, all occurrences will be\n * removed.\n *\n * @param element the element whose occurrences should be removed\n * @param occurrences the number of occurrences of the element to remove\n * @return the count of the element before the operation; possibly zero\n * @throws IllegalArgumentException if {@code occurrences} is negative\n */\n", "repo_name": "guava-master/", "id": 3528, "method_signature": "int remove(Object, int)", "filename": "ConcurrentHashMultisetBenchmark.remove.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.remove"], "method_name": "ConcurrentHashMultisetBenchmark.removeAllOccurrences", "method_implementation": "{\n    try {\n        return unbox(countMap.remove(element));\n    } catch (NullPointerException | ClassCastException e) {\n        return 0;\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes <b>all</b> occurrences of the specified element from this multiset. This method\n * complements {@link Multiset#remove(Object)}, which removes only one occurrence at a time.\n *\n * @param element the element whose occurrences should all be removed\n * @return the number of occurrences successfully removed, possibly zero\n */\n", "repo_name": "guava-master/", "id": 3529, "method_signature": "int removeAllOccurrences(Object)", "filename": "ConcurrentHashMultisetBenchmark.removeAllOccurrences.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.remove", "ConcurrentMap<E, Integer>.replace"], "method_name": "ConcurrentHashMultisetBenchmark.removeExactly", "method_implementation": "{\n    if (occurrences == 0) {\n        return true;\n    }\n    checkArgument(occurrences > 0, \"Invalid occurrences: %s\", occurrences);\n    while (true) {\n        int current = count(element);\n        if (occurrences > current) {\n            return false;\n        }\n        if (occurrences == current) {\n            if (countMap.remove(element, occurrences)) {\n                return true;\n            }\n        } else {\n            // it's in the map, must be an \"E\"\n            @SuppressWarnings(\"unchecked\")\n            E casted = (E) element;\n            if (countMap.replace(casted, current, current - occurrences)) {\n                return true;\n            }\n        }\n        // If we're still here, there was a race, so just try again.\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes exactly the specified number of occurrences of {@code element}, or makes no change if\n * this is not possible.\n *\n * <p>This method, in contrast to {@link #remove(Object, int)}, has no effect when the element\n * count is smaller than {@code occurrences}.\n *\n * @param element the element to remove\n * @param occurrences the number of occurrences of {@code element} to remove\n * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)\n */\n", "repo_name": "guava-master/", "id": 3530, "method_signature": "boolean removeExactly(Object, int)", "filename": "ConcurrentHashMultisetBenchmark.removeExactly.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.containsKey", "ConcurrentMap<E, Integer>.remove", "ConcurrentMap<E, Integer>.putIfAbsent", "ConcurrentMap<E, Integer>.replace"], "method_name": "ConcurrentHashMultisetBenchmark.setCount", "method_implementation": "{\n    checkNonnegative(oldCount, \"oldCount\");\n    checkNonnegative(newCount, \"newCount\");\n    if (newCount == 0) {\n        if (oldCount == 0) {\n            // No change to make, but must return true if the element is not present\n            return !countMap.containsKey(element);\n        } else {\n            return countMap.remove(element, oldCount);\n        }\n    }\n    if (oldCount == 0) {\n        return countMap.putIfAbsent(element, newCount) == null;\n    }\n    return countMap.replace(element, oldCount, newCount);\n}", "repo_id": "5", "comment": "/**\n * Sets the number of occurrences of {@code element} to {@code newCount}, but only if the count\n * is currently {@code oldCount}. If {@code element} does not appear in the multiset exactly\n * {@code oldCount} times, no changes will be made.\n *\n * @return {@code true} if the change was successful. This usually indicates that the multiset\n *     has been modified, but not always: in the case that {@code oldCount == newCount}, the\n *     method will return {@code true} if the condition was met.\n * @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is negative\n */\n", "repo_name": "guava-master/", "id": 3532, "method_signature": "boolean setCount(E, int, int)", "filename": "ConcurrentHashMultisetBenchmark.setCount.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.values"], "method_name": "ConcurrentHashMultisetBenchmark.size", "method_implementation": "{\n    long sum = 0L;\n    for (Integer value : countMap.values()) {\n        sum += value;\n    }\n    return Ints.saturatedCast(sum);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If the data in the multiset is modified by any other threads during this method, it is\n * undefined which (if any) of these modifications will be reflected in the result.\n */\n", "repo_name": "guava-master/", "id": 3525, "method_signature": "int size()", "filename": "ConcurrentHashMultisetBenchmark.size.json"}
{"callee_method_names": ["Entry<K,V1>.getElement", "Entry<K,V1>.getCount", "List<E>.add"], "method_name": "ConcurrentHashMultisetBenchmark.snapshot", "method_implementation": "{\n    List<E> list = Lists.newArrayListWithExpectedSize(size());\n    for (Multiset.Entry<E> entry : entrySet()) {\n        E element = entry.getElement();\n        for (int i = entry.getCount(); i > 0; i--) {\n            list.add(element);\n        }\n    }\n    return list;\n}", "repo_id": "5", "comment": "/*\n     * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but\n     * either of these would recurse back to us again!\n     */\n", "repo_name": "guava-master/", "id": 3526, "method_signature": "List<E> snapshot()", "filename": "ConcurrentHashMultisetBenchmark.snapshot.json"}
{"callee_method_names": ["ConcurrentMap<String, AtomicInteger>.get", "ConcurrentMap<String, AtomicInteger>.putIfAbsent", "ConcurrentMap<String, AtomicInteger>.replace", "ConcurrentMap<String, AtomicInteger>.putIfAbsent", "ConcurrentMap<String, AtomicInteger>.get", "ConcurrentMap<String, AtomicInteger>.replace", "ConcurrentMap<String, AtomicInteger>.putIfAbsent", "ConcurrentMap<String, AtomicInteger>.get", "ConcurrentHashMultiset<String>.add", "AtomicInteger.get"], "method_name": "ConcurrentHashMultisetTest.testAdd_withFailures", "method_implementation": "{\n    AtomicInteger existing = new AtomicInteger(12);\n    AtomicInteger existingZero = new AtomicInteger(0);\n    // initial map.get()\n    when(backingMap.get(KEY)).thenReturn(null);\n    // since get returned null, try a putIfAbsent; that fails due to a simulated race\n    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existingZero);\n    // since the putIfAbsent returned a zero, we'll try to replace...\n    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);\n    // ...and then putIfAbsent. Simulate failure on both\n    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);\n    // next map.get()\n    when(backingMap.get(KEY)).thenReturn(existingZero);\n    // since get returned zero, try a replace; that fails due to a simulated race\n    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);\n    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);\n    // another map.get()\n    when(backingMap.get(KEY)).thenReturn(existing);\n    // we shouldn't see any more map operations; CHM will now just update the AtomicInteger\n    assertEquals(12, multiset.add(KEY, 3));\n    assertEquals(15, existing.get());\n}", "repo_id": "5", "comment": "/**\n * Simulate some of the races that can happen on add. We can't easily simulate the race that\n * happens when an {@link AtomicInteger#compareAndSet} fails, but we can simulate the case where\n * the putIfAbsent returns a non-null value, and the case where the replace() of an observed zero\n * fails.\n */\n", "repo_name": "guava-master/", "id": 4012, "method_signature": "void testAdd_withFailures()", "filename": "ConcurrentHashMultisetTest.testAdd_withFailures.json"}
{"callee_method_names": ["Class<?>.getTypeParameters"], "method_name": "ConstructorInvokable.getGenericReturnType", "method_implementation": "{\n    Class<?> declaringClass = getDeclaringClass();\n    TypeVariable<?>[] typeParams = declaringClass.getTypeParameters();\n    if (typeParams.length > 0) {\n        return Types.newParameterizedType(declaringClass, typeParams);\n    } else {\n        return declaringClass;\n    }\n}", "repo_id": "5", "comment": "/**\n * If the class is parameterized, such as {@link java.util.ArrayList ArrayList}, this returns\n * {@code ArrayList<E>}.\n */\n", "repo_name": "guava-master/", "id": 4722, "method_signature": "Type getGenericReturnType()", "filename": "ConstructorInvokable.getGenericReturnType.json"}
{"callee_method_names": ["Constructor<?>.getTypeParameters"], "method_name": "ConstructorInvokable.getTypeParameters", "method_implementation": "{\n    TypeVariable<?>[] declaredByClass = getDeclaringClass().getTypeParameters();\n    TypeVariable<?>[] declaredByConstructor = constructor.getTypeParameters();\n    TypeVariable<?>[] result = new TypeVariable<?>[declaredByClass.length + declaredByConstructor.length];\n    System.arraycopy(declaredByClass, 0, result, 0, declaredByClass.length);\n    System.arraycopy(declaredByConstructor, 0, result, declaredByClass.length, declaredByConstructor.length);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>{@code [<E>]} will be returned for ArrayList's constructor. When both the class and the\n * constructor have type parameters, the class parameters are prepended before those of the\n * constructor's. This is an arbitrary rule since no existing language spec mandates one way or\n * the other. From the declaration syntax, the class type parameter appears first, but the call\n * syntax may show up in opposite order such as {@code new <A>Foo<B>()}.\n */\n", "repo_name": "guava-master/", "id": 4723, "method_signature": "TypeVariable<?>[] getTypeParameters()", "filename": "ConstructorInvokable.getTypeParameters.json"}
{"callee_method_names": [], "method_name": "ContiguousSet.builder", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. {@code ContiguousSet} instances are constructed with {@link #create}. This\n * method exists only to hide {@link ImmutableSet#builder} from consumers of {@code\n * ContiguousSet}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link #create}.\n */\n", "repo_name": "guava-master/", "id": 6145, "method_signature": "ImmutableSortedSet.Builder<E> builder()", "filename": "ContiguousSet.builder.json"}
{"callee_method_names": ["Range<C>.hasLowerBound", "Range<C>.intersection", "DiscreteDomain<C>.minValue", "Range<C>.hasUpperBound", "Range<C>.intersection", "DiscreteDomain<C>.maxValue", "Range<C>.isEmpty", "Range<C>.leastValueAbove", "Range<C>.greatestValueBelow"], "method_name": "ContiguousSet.create", "method_implementation": "{\n    checkNotNull(range);\n    checkNotNull(domain);\n    Range<C> effectiveRange = range;\n    try {\n        if (!range.hasLowerBound()) {\n            effectiveRange = effectiveRange.intersection(Range.atLeast(domain.minValue()));\n        }\n        if (!range.hasUpperBound()) {\n            effectiveRange = effectiveRange.intersection(Range.atMost(domain.maxValue()));\n        }\n    } catch (NoSuchElementException e) {\n        throw new IllegalArgumentException(e);\n    }\n    boolean empty;\n    if (effectiveRange.isEmpty()) {\n        empty = true;\n    } else {\n        /*\n       * requireNonNull is safe because the effectiveRange operations above would have thrown or\n       * effectiveRange.isEmpty() would have returned true.\n       */\n        C afterLower = requireNonNull(range.lowerBound.leastValueAbove(domain));\n        C beforeUpper = requireNonNull(range.upperBound.greatestValueBelow(domain));\n        // Per class spec, we are allowed to throw CCE if necessary\n        empty = Range.compareOrThrow(afterLower, beforeUpper) > 0;\n    }\n    return empty ? new EmptyContiguousSet<C>(domain) : new RegularContiguousSet<C>(effectiveRange, domain);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code ContiguousSet} containing the same values in the given domain {@linkplain\n * Range#contains contained} by the range.\n *\n * @throws IllegalArgumentException if neither range nor the domain has a lower bound, or if\n *     neither has an upper bound\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 6141, "method_signature": "ContiguousSet<C> create(Range, DiscreteDomain)", "filename": "ContiguousSet.create.json"}
{"callee_method_names": [], "method_name": "ContiguousSet.headSet", "method_implementation": "{\n    return headSetImpl(checkNotNull(toElement), inclusive);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 6142, "method_signature": "ContiguousSet<C> headSet(C, boolean)", "filename": "ContiguousSet.headSet.json"}
{"callee_method_names": [], "method_name": "ContiguousSet.subSet", "method_implementation": "{\n    checkNotNull(fromElement);\n    checkNotNull(toElement);\n    checkArgument(comparator().compare(fromElement, toElement) <= 0);\n    return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 6143, "method_signature": "ContiguousSet<C> subSet(C, boolean, C, boolean)", "filename": "ContiguousSet.subSet.json"}
{"callee_method_names": [], "method_name": "ContiguousSet.tailSet", "method_implementation": "{\n    return tailSetImpl(checkNotNull(fromElement), inclusive);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 6144, "method_signature": "ContiguousSet<C> tailSet(C, boolean)", "filename": "ContiguousSet.tailSet.json"}
{"callee_method_names": [], "method_name": "ContiguousSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6146, "method_signature": "Object writeReplace()", "filename": "ContiguousSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "ContiguousSetDescendingGenerator.order", "method_implementation": "{\n    Collections.sort(insertionOrder, Ordering.natural().reverse());\n    return insertionOrder;\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements in reverse natural order.\n */\n", "repo_name": "guava-master/", "id": 4175, "method_signature": "List<Integer> order(List)", "filename": "ContiguousSetDescendingGenerator.order.json"}
{"callee_method_names": [], "method_name": "Converter.apply", "method_implementation": "{\n    /*\n     * Given that we declare this method as accepting and returning non-nullable values (because we\n     * implement Function<A, B>, as discussed in a class-level comment), it would make some sense to\n     * perform runtime null checks on the input and output. (That would also make NullPointerTester\n     * happy!) However, since we didn't do that for many years, we're not about to start now.\n     * (Runtime checks could be particularly bad for users of LegacyConverter.)\n     *\n     * Luckily, our nullness checker is smart enough to realize that `convert` has @PolyNull-like\n     * behavior, so it knows that `convert(a)` returns a non-nullable value, and we don't need to\n     * perform even a cast, much less a runtime check.\n     *\n     * All that said, don't forget that everyone should call converter.convert() instead of\n     * converter.apply(), anyway. If clients use only converter.convert(), then their nullness\n     * checkers are unlikely to ever look at the annotations on this declaration.\n     *\n     * Historical note: At one point, we'd declared this method as accepting and returning nullable\n     * values. For details on that, see earlier revisions of this file.\n     */\n    return convert(a);\n}", "repo_id": "5", "comment": "/**\n * @deprecated Provided to satisfy the {@code Function} interface; use {@link #convert} instead.\n */\n", "repo_name": "guava-master/", "id": 4966, "method_signature": "B apply(A)", "filename": "Converter.apply.json"}
{"callee_method_names": ["Iterable<? extends A>.iterator", "Iterator<? extends A>.hasNext", "Iterator<? extends A>.next", "Iterator<? extends A>.remove"], "method_name": "Converter.convertAll", "method_implementation": "{\n    checkNotNull(fromIterable, \"fromIterable\");\n    return new Iterable<B>() {\n\n        @Override\n        public Iterator<B> iterator() {\n            return new Iterator<B>() {\n\n                private final Iterator<? extends A> fromIterator = fromIterable.iterator();\n\n                @Override\n                public boolean hasNext() {\n                    return fromIterator.hasNext();\n                }\n\n                @Override\n                public B next() {\n                    return convert(fromIterator.next());\n                }\n\n                @Override\n                public void remove() {\n                    fromIterator.remove();\n                }\n            };\n        }\n    };\n}", "repo_id": "5", "comment": "/*\n   * Just as Converter could implement `Function<@Nullable A, @Nullable B>` instead of `Function<A,\n   * B>`, convertAll could accept and return iterables with nullable element types. In both cases,\n   * we've chosen to instead use a signature that benefits existing users -- and is still safe.\n   *\n   * For convertAll, I haven't looked as closely at *how* much existing users benefit, so we should\n   * keep an eye out for problems that new users encounter. Note also that convertAll could support\n   * both use cases by using @PolyNull. (By contrast, we can't use @PolyNull for our superinterface\n   * (`implements Function<@PolyNull A, @PolyNull B>`), at least as far as I know.)\n   */\n", "repo_name": "guava-master/", "id": 4964, "method_signature": "Iterable<B> convertAll(Iterable)", "filename": "Converter.convertAll.json"}
{"callee_method_names": [], "method_name": "Converter.from", "method_implementation": "{\n    return new FunctionBasedConverter<>(forwardFunction, backwardFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a converter based on separate forward and backward functions. This is useful if the\n * function instances already exist, or so that you can supply lambda expressions. If those\n * circumstances don't apply, you probably don't need to use this; subclass {@code Converter} and\n * implement its {@link #doForward} and {@link #doBackward} methods directly.\n *\n * <p>These functions will never be passed {@code null} and must not under any circumstances\n * return {@code null}. If a value cannot be converted, the function should throw an unchecked\n * exception (typically, but not necessarily, {@link IllegalArgumentException}).\n *\n * <p>The returned converter is serializable if both provided functions are.\n *\n * @since 17.0\n */\n", "repo_name": "guava-master/", "id": 4967, "method_signature": "Converter<A,B> from(Function, Function)", "filename": "Converter.from.json"}
{"callee_method_names": [], "method_name": "Converter.reverse", "method_implementation": "{\n    Converter<B, A> result = reverse;\n    return (result == null) ? reverse = new ReverseConverter<>(this) : result;\n}", "repo_id": "5", "comment": "/**\n * Returns the reversed view of this converter, which converts {@code this.convert(a)} back to a\n * value roughly equivalent to {@code a}.\n *\n * <p>The returned converter is serializable if {@code this} converter is.\n *\n * <p><b>Note:</b> you should not override this method. It is non-final for legacy reasons.\n */\n", "repo_name": "guava-master/", "id": 4965, "method_signature": "Converter<B,A> reverse()", "filename": "Converter.reverse.json"}
{"callee_method_names": [], "method_name": "Crc32cHashFunctionTest.assertCrc", "method_implementation": "{\n    int actualCrc = Hashing.crc32c().hashBytes(data).asInt();\n    assertEquals(String.format(\"expected: %08x, actual: %08x\", expectedCrc, actualCrc), expectedCrc, actualCrc);\n    int actualCrcHasher = Hashing.crc32c().newHasher().putBytes(data).hash().asInt();\n    assertEquals(String.format(\"expected: %08x, actual: %08x\", expectedCrc, actualCrc), expectedCrc, actualCrcHasher);\n}", "repo_id": "5", "comment": "/**\n * Verifies that the crc of an array of byte data matches the expected value.\n *\n * @param expectedCrc the expected crc value.\n * @param data the data to run the checksum on.\n */\n", "repo_name": "guava-master/", "id": 3720, "method_signature": "void assertCrc(int, byte[])", "filename": "Crc32cHashFunctionTest.assertCrc.json"}
{"callee_method_names": [], "method_name": "Crc32cHashFunctionTest.testSomeOtherKnownValues", "method_implementation": "{\n    assertCrc(0x22620404, \"The quick brown fox jumps over the lazy dog\".getBytes(UTF_8));\n    assertCrc(0xE3069283, \"123456789\".getBytes(UTF_8));\n    assertCrc(0xf3dbd4fe, \"1234567890\".getBytes(UTF_8));\n    assertCrc(0xBFE92A83, \"23456789\".getBytes(UTF_8));\n}", "repo_id": "5", "comment": "// Known values from http://www.evanjones.ca/crc32c.html\n", "repo_name": "guava-master/", "id": 3719, "method_signature": "void testSomeOtherKnownValues()", "filename": "Crc32cHashFunctionTest.testSomeOtherKnownValues.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject"], "method_name": "CustomListMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(factory);\n    stream.writeObject(backingMap());\n}", "repo_id": "5", "comment": "/**\n * @serialData the factory and the backing map\n */\n", "repo_name": "guava-master/", "id": 6114, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "CustomListMultimap.writeObject.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject"], "method_name": "CustomMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(factory);\n    stream.writeObject(backingMap());\n}", "repo_id": "5", "comment": "/**\n * @serialData the factory and the backing map\n */\n", "repo_name": "guava-master/", "id": 6113, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "CustomMultimap.writeObject.json"}
{"callee_method_ids": [5321, 5321], "callee_method_names": ["AbstractService.notifyFailed", "ReentrantLock.lock", "ReentrantLock.unlock", "AbstractService.notifyFailed"], "method_name": "CustomScheduler.reschedule", "method_implementation": "{\n    // invoke the callback outside the lock, prevents some shenanigans.\n    Schedule schedule;\n    try {\n        schedule = CustomScheduler.this.getNextSchedule();\n    } catch (Throwable t) {\n        restoreInterruptIfIsInterruptedException(t);\n        service.notifyFailed(t);\n        return new FutureAsCancellable(immediateCancelledFuture());\n    }\n    // We reschedule ourselves with a lock held for two reasons. 1. we want to make sure that\n    // cancel calls cancel on the correct future. 2. we want to make sure that the assignment\n    // to currentFuture doesn't race with itself so that currentFuture is assigned in the\n    // correct order.\n    Throwable scheduleFailure = null;\n    Cancellable toReturn;\n    lock.lock();\n    try {\n        toReturn = initializeOrUpdateCancellationDelegate(schedule);\n    } catch (Throwable e) {\n        // Any Exception is either a RuntimeException or sneaky checked exception.\n        //\n        // If an exception is thrown by the subclass then we need to make sure that the service\n        // notices and transitions to the FAILED state. We do it by calling notifyFailed directly\n        // because the service does not monitor the state of the future so if the exception is not\n        // caught and forwarded to the service the task would stop executing but the service would\n        // have no idea.\n        // TODO(lukes): consider building everything in terms of ListenableScheduledFuture then\n        // the AbstractService could monitor the future directly. Rescheduling is still hard...\n        // but it would help with some of these lock ordering issues.\n        scheduleFailure = e;\n        toReturn = new FutureAsCancellable(immediateCancelledFuture());\n    } finally {\n        lock.unlock();\n    }\n    // Call notifyFailed outside the lock to avoid lock ordering issues.\n    if (scheduleFailure != null) {\n        service.notifyFailed(scheduleFailure);\n    }\n    return toReturn;\n}", "repo_id": "5", "comment": "/**\n * Atomically reschedules this task and assigns the new future to {@link\n * #cancellationDelegate}.\n */\n", "repo_name": "guava-master/", "id": 5341, "method_signature": "Cancellable reschedule()", "filename": "CustomScheduler.reschedule.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject"], "method_name": "CustomSetMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(factory);\n    stream.writeObject(backingMap());\n}", "repo_id": "5", "comment": "/**\n * @serialData the factory and the backing map\n */\n", "repo_name": "guava-master/", "id": 6115, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "CustomSetMultimap.writeObject.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject"], "method_name": "CustomSortedSetMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(factory);\n    stream.writeObject(backingMap());\n}", "repo_id": "5", "comment": "/**\n * @serialData the factory and the backing map\n */\n", "repo_name": "guava-master/", "id": 6116, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "CustomSortedSetMultimap.writeObject.json"}
{"callee_method_names": [], "method_name": "Cut.compareTo", "method_implementation": "{\n    if (that == belowAll()) {\n        return 1;\n    }\n    if (that == aboveAll()) {\n        return -1;\n    }\n    int result = Range.compareOrThrow(endpoint, that.endpoint);\n    if (result != 0) {\n        return result;\n    }\n    // same value. below comes before above\n    return Booleans.compare(this instanceof AboveValue, that instanceof AboveValue);\n}", "repo_id": "5", "comment": "// note: overridden by {BELOW,ABOVE}_ALL\n", "repo_name": "guava-master/", "id": 5560, "method_signature": "int compareTo(Cut)", "filename": "Cut.compareTo.json"}
{"callee_method_names": ["CycleDetectingLock.isAcquiredByCurrentThread", "ThreadLocal.get", "CycleDetectingLock.getLockGraphNode", "LockGraphNode.checkAcquiredLocks", "ArrayList<LockGraphNode>.add"], "method_name": "CycleDetectingLockFactory.aboutToAcquire", "method_implementation": "{\n    if (!lock.isAcquiredByCurrentThread()) {\n        // requireNonNull accommodates Android's @RecentlyNullable annotation on ThreadLocal.get\n        ArrayList<LockGraphNode> acquiredLockList = requireNonNull(acquiredLocks.get());\n        LockGraphNode node = lock.getLockGraphNode();\n        node.checkAcquiredLocks(policy, acquiredLockList);\n        acquiredLockList.add(node);\n    }\n}", "repo_id": "5", "comment": "/**\n * CycleDetectingLock implementations must call this method before attempting to acquire the lock.\n */\n", "repo_name": "guava-master/", "id": 5476, "method_signature": "void aboutToAcquire(CycleDetectingLock)", "filename": "CycleDetectingLockFactory.aboutToAcquire.json"}
{"callee_method_ids": [5482], "callee_method_names": ["LockGraphNode.getLockName", "Map<LockGraphNode, ExampleStackTrace>.containsKey", "Map<LockGraphNode, PotentialDeadlockException>.get", "PotentialDeadlockException.getConflictingStackTrace", "Policy.handlePotentialDeadlock", "LockGraphNode.findPathTo", "Map<LockGraphNode, ExampleStackTrace>.put", "Map<LockGraphNode, PotentialDeadlockException>.put", "Policy.handlePotentialDeadlock"], "method_name": "CycleDetectingLockFactory.checkAcquiredLock", "method_implementation": "{\n    // checkAcquiredLock() should never be invoked by a lock that has already\n    // been acquired. For unordered locks, aboutToAcquire() ensures this by\n    // checking isAcquiredByCurrentThread(). For ordered locks, however, this\n    // can happen because multiple locks may share the same LockGraphNode. In\n    // this situation, throw an IllegalStateException as defined by contract\n    // described in the documentation of WithExplicitOrdering.\n    Preconditions.checkState(this != acquiredLock, \"Attempted to acquire multiple locks with the same rank %s\", acquiredLock.getLockName());\n    if (allowedPriorLocks.containsKey(acquiredLock)) {\n        // The acquisition ordering from \"acquiredLock\" to \"this\" has already\n        // been verified as safe. In a properly written application, this is\n        // the common case.\n        return;\n    }\n    PotentialDeadlockException previousDeadlockException = disallowedPriorLocks.get(acquiredLock);\n    if (previousDeadlockException != null) {\n        // Previously determined to be an unsafe lock acquisition.\n        // Create a new PotentialDeadlockException with the same causal chain\n        // (the example cycle) as that of the cached exception.\n        PotentialDeadlockException exception = new PotentialDeadlockException(acquiredLock, this, previousDeadlockException.getConflictingStackTrace());\n        policy.handlePotentialDeadlock(exception);\n        return;\n    }\n    // Otherwise, it's the first time seeing this lock relationship. Look for\n    // a path from the acquiredLock to this.\n    Set<LockGraphNode> seen = Sets.newIdentityHashSet();\n    ExampleStackTrace path = acquiredLock.findPathTo(this, seen);\n    if (path == null) {\n        // this can be safely acquired after the acquiredLock.\n        //\n        // Note that there is a race condition here which can result in missing\n        // a cyclic edge: it's possible for two threads to simultaneous find\n        // \"safe\" edges which together form a cycle. Preventing this race\n        // condition efficiently without _introducing_ deadlock is probably\n        // tricky. For now, just accept the race condition---missing a warning\n        // now and then is still better than having no deadlock detection.\n        allowedPriorLocks.put(acquiredLock, new ExampleStackTrace(acquiredLock, this));\n    } else {\n        // Unsafe acquisition order detected. Create and cache a\n        // PotentialDeadlockException.\n        PotentialDeadlockException exception = new PotentialDeadlockException(acquiredLock, this, path);\n        disallowedPriorLocks.put(acquiredLock, exception);\n        policy.handlePotentialDeadlock(exception);\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks the acquisition-ordering between {@code this}, which is about to be acquired, and the\n * specified {@code acquiredLock}.\n *\n * <p>When this method returns, the {@code acquiredLock} should be in either the {@code\n * preAcquireLocks} map, for the case in which it is safe to acquire {@code this} after the\n * {@code acquiredLock}, or in the {@code disallowedPriorLocks} map, in which case it is not\n * safe.\n */\n", "repo_name": "guava-master/", "id": 5474, "method_signature": "void checkAcquiredLock(Policy, LockGraphNode)", "filename": "CycleDetectingLockFactory.checkAcquiredLock.json"}
{"callee_method_names": ["Class<E>.getEnumConstants", "ArrayList<LockGraphNode>.add", "EnumMap<E, LockGraphNode>.put", "ArrayList<LockGraphNode>.get", "ArrayList<LockGraphNode>.subList", "ArrayList<LockGraphNode>.get", "ArrayList<LockGraphNode>.subList"], "method_name": "CycleDetectingLockFactory.createNodes", "method_implementation": "{\n    EnumMap<E, LockGraphNode> map = Maps.newEnumMap(clazz);\n    E[] keys = clazz.getEnumConstants();\n    int numKeys = keys.length;\n    ArrayList<LockGraphNode> nodes = Lists.newArrayListWithCapacity(numKeys);\n    // Create a LockGraphNode for each enum value.\n    for (E key : keys) {\n        LockGraphNode node = new LockGraphNode(getLockName(key));\n        nodes.add(node);\n        map.put(key, node);\n    }\n    // Pre-populate all allowedPriorLocks with nodes of smaller ordinal.\n    for (int i = 1; i < numKeys; i++) {\n        nodes.get(i).checkAcquiredLocks(Policies.THROW, nodes.subList(0, i));\n    }\n    // Pre-populate all disallowedPriorLocks with nodes of larger ordinal.\n    for (int i = 0; i < numKeys - 1; i++) {\n        nodes.get(i).checkAcquiredLocks(Policies.DISABLED, nodes.subList(i + 1, numKeys));\n    }\n    return Collections.unmodifiableMap(map);\n}", "repo_id": "5", "comment": "/**\n * For a given Enum type, creates an immutable map from each of the Enum's values to a\n * corresponding LockGraphNode, with the {@code allowedPriorLocks} and {@code\n * disallowedPriorLocks} prepopulated with nodes according to the natural ordering of the\n * associated Enum values.\n */\n", "repo_name": "guava-master/", "id": 5470, "method_signature": "Map<E,LockGraphNode> createNodes(Class)", "filename": "CycleDetectingLockFactory.createNodes.json"}
{"callee_method_ids": [5482], "callee_method_names": ["Set<LockGraphNode>.add", "Map<LockGraphNode, ExampleStackTrace>.get", "Map<LockGraphNode, ExampleStackTrace>.entrySet", "Entry<K, AtomicLong>.getKey", "LockGraphNode.findPathTo", "ExampleStackTrace.setStackTrace", "Entry<K, AtomicLong>.getValue", "ExampleStackTrace.initCause"], "method_name": "CycleDetectingLockFactory.findPathTo", "method_implementation": "{\n    if (!seen.add(this)) {\n        // Already traversed this node.\n        return null;\n    }\n    ExampleStackTrace found = allowedPriorLocks.get(node);\n    if (found != null) {\n        // Found a path ending at the node!\n        return found;\n    }\n    // Recurse the edges.\n    for (Entry<LockGraphNode, ExampleStackTrace> entry : allowedPriorLocks.entrySet()) {\n        LockGraphNode preAcquiredLock = entry.getKey();\n        found = preAcquiredLock.findPathTo(node, seen);\n        if (found != null) {\n            // One of this node's allowedPriorLocks found a path. Prepend an\n            // ExampleStackTrace(preAcquiredLock, this) to the returned chain of\n            // ExampleStackTraces.\n            ExampleStackTrace path = new ExampleStackTrace(preAcquiredLock, this);\n            path.setStackTrace(entry.getValue().getStackTrace());\n            path.initCause(found);\n            return path;\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Performs a depth-first traversal of the graph edges defined by each node's {@code\n * allowedPriorLocks} to find a path between {@code this} and the specified {@code lock}.\n *\n * @return If a path was found, a chained {@link ExampleStackTrace} illustrating the path to the\n *     {@code lock}, or {@code null} if no path was found.\n */\n", "repo_name": "guava-master/", "id": 5475, "method_signature": "ExampleStackTrace findPathTo(LockGraphNode, Set)", "filename": "CycleDetectingLockFactory.findPathTo.json"}
{"callee_method_names": ["T.getCause", "StringBuilder.append", "T.getMessage", "StringBuilder.toString"], "method_name": "CycleDetectingLockFactory.getMessage", "method_implementation": "{\n    // requireNonNull is safe because ExampleStackTrace sets a non-null message.\n    StringBuilder message = new StringBuilder(requireNonNull(super.getMessage()));\n    for (Throwable t = conflictingStackTrace; t != null; t = t.getCause()) {\n        message.append(\", \").append(t.getMessage());\n    }\n    return message.toString();\n}", "repo_id": "5", "comment": "/**\n * Appends the chain of messages from the {@code conflictingStackTrace} to the original {@code\n * message}.\n */\n", "repo_name": "guava-master/", "id": 5473, "method_signature": "String getMessage()", "filename": "CycleDetectingLockFactory.getMessage.json"}
{"callee_method_names": ["CycleDetectingLock.isAcquiredByCurrentThread", "ThreadLocal.get", "CycleDetectingLock.getLockGraphNode", "ArrayList<LockGraphNode>.size", "ArrayList<LockGraphNode>.get", "ArrayList<LockGraphNode>.remove"], "method_name": "CycleDetectingLockFactory.lockStateChanged", "method_implementation": "{\n    if (!lock.isAcquiredByCurrentThread()) {\n        // requireNonNull accommodates Android's @RecentlyNullable annotation on ThreadLocal.get\n        ArrayList<LockGraphNode> acquiredLockList = requireNonNull(acquiredLocks.get());\n        LockGraphNode node = lock.getLockGraphNode();\n        // Iterate in reverse because locks are usually locked/unlocked in a\n        // LIFO order.\n        for (int i = acquiredLockList.size() - 1; i >= 0; i--) {\n            if (acquiredLockList.get(i) == node) {\n                acquiredLockList.remove(i);\n                break;\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * CycleDetectingLock implementations must call this method in a {@code finally} clause after any\n * attempt to change the lock state, including both lock and unlock attempts. Failure to do so can\n * result in corrupting the acquireLocks set.\n */\n", "repo_name": "guava-master/", "id": 5477, "method_signature": "void lockStateChanged(CycleDetectingLock)", "filename": "CycleDetectingLockFactory.lockStateChanged.json"}
{"callee_method_names": [], "method_name": "CycleDetectingLockFactory.newInstanceWithExplicitOrdering", "method_implementation": "{\n    // createNodes maps each enumClass to a Map with the corresponding enum key\n    // type.\n    checkNotNull(enumClass);\n    checkNotNull(policy);\n    @SuppressWarnings(\"unchecked\")\n    Map<E, LockGraphNode> lockGraphNodes = (Map<E, LockGraphNode>) getOrCreateNodes(enumClass);\n    return new WithExplicitOrdering<>(policy, lockGraphNodes);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}.\n */\n", "repo_name": "guava-master/", "id": 5469, "method_signature": "WithExplicitOrdering<E> newInstanceWithExplicitOrdering(Class, Policy)", "filename": "CycleDetectingLockFactory.newInstanceWithExplicitOrdering.json"}
{"callee_method_names": ["Map<E, LockGraphNode>.get"], "method_name": "CycleDetectingLockFactory.newReentrantLock", "method_implementation": "{\n    return policy == Policies.DISABLED ? new ReentrantLock(fair) : // requireNonNull is safe because createNodes inserts an entry for every E.\n    // (If the caller passes `null` for the `rank` parameter, this will throw, but that's OK.)\n    new CycleDetectingReentrantLock(requireNonNull(lockGraphNodes.get(rank)), fair);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link ReentrantLock} with the given fairness policy and rank. The values returned\n * by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the lock in\n * warning or exception output.\n *\n * @throws IllegalStateException If the factory has already created a {@code Lock} with the\n *     specified rank.\n */\n", "repo_name": "guava-master/", "id": 5471, "method_signature": "ReentrantLock newReentrantLock(E, boolean)", "filename": "CycleDetectingLockFactory.newReentrantLock.json"}
{"callee_method_names": ["Map<E, LockGraphNode>.get"], "method_name": "CycleDetectingLockFactory.newReentrantReadWriteLock", "method_implementation": "{\n    return policy == Policies.DISABLED ? new ReentrantReadWriteLock(fair) : // requireNonNull is safe because createNodes inserts an entry for every E.\n    // (If the caller passes `null` for the `rank` parameter, this will throw, but that's OK.)\n    new CycleDetectingReentrantReadWriteLock(requireNonNull(lockGraphNodes.get(rank)), fair);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link ReentrantReadWriteLock} with the given fairness policy and rank. The values\n * returned by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the\n * lock in warning or exception output.\n *\n * @throws IllegalStateException If the factory has already created a {@code Lock} with the\n *     specified rank.\n */\n", "repo_name": "guava-master/", "id": 5472, "method_signature": "ReentrantReadWriteLock newReentrantReadWriteLock(E, boolean)", "filename": "CycleDetectingLockFactory.newReentrantReadWriteLock.json"}
{"callee_method_names": [], "method_name": "CycleDetectingLockFactoryTest.newInstanceWithExplicitOrdering", "method_implementation": "{\n    return new CycleDetectingLockFactory.WithExplicitOrdering<E>(policy, CycleDetectingLockFactory.createNodes(enumClass));\n}", "repo_id": "5", "comment": "// conflicts across different test runs.\n", "repo_name": "guava-master/", "id": 3876, "method_signature": "CycleDetectingLockFactory.WithExplicitOrdering<E> newInstanceWithExplicitOrdering(Class, Policy)", "filename": "CycleDetectingLockFactoryTest.newInstanceWithExplicitOrdering.json"}
{"callee_method_names": ["ReentrantLock.lock", "ReentrantLock.lock", "ReentrantLock.unlock", "ReentrantLock.unlock", "ReentrantLock.lock", "ReentrantLock.lock", "ReentrantLock.unlock", "ReentrantLock.lock"], "method_name": "CycleDetectingLockFactoryTest.testDeadlock_threeLocks", "method_implementation": "{\n    // Establish an ordering from lockA -> lockB.\n    lockA.lock();\n    lockB.lock();\n    lockB.unlock();\n    lockA.unlock();\n    // Establish an ordering from lockB -> lockC.\n    lockB.lock();\n    lockC.lock();\n    lockB.unlock();\n    // lockC -> lockA should fail.\n    PotentialDeadlockException expected = assertThrows(PotentialDeadlockException.class, () -> lockA.lock());\n    checkMessage(expected, \"LockC -> LockA\", \"LockB -> LockC\", \"LockA -> LockB\");\n}", "repo_id": "5", "comment": "// Tests transitive deadlock detection.\n", "repo_name": "guava-master/", "id": 3877, "method_signature": "void testDeadlock_threeLocks()", "filename": "CycleDetectingLockFactoryTest.testDeadlock_threeLocks.json"}
{"callee_method_names": ["String.replace", "URL.toString", "String.endsWith", "String.substring", "String.length", "String.length"], "method_name": "DecoupledLoader.getBaseUrl", "method_implementation": "{\n    // Find URL pointing to Finalizer.class file.\n    String finalizerPath = FINALIZER_CLASS_NAME.replace('.', '/') + \".class\";\n    URL finalizerUrl = getClass().getClassLoader().getResource(finalizerPath);\n    if (finalizerUrl == null) {\n        throw new FileNotFoundException(finalizerPath);\n    }\n    // Find URL pointing to base of class path.\n    String urlString = finalizerUrl.toString();\n    if (!urlString.endsWith(finalizerPath)) {\n        throw new IOException(\"Unsupported path style: \" + urlString);\n    }\n    urlString = urlString.substring(0, urlString.length() - finalizerPath.length());\n    return new URL(finalizerUrl, urlString);\n}", "repo_id": "5", "comment": "/**\n * Gets URL for base of path containing Finalizer.class.\n */\n", "repo_name": "guava-master/", "id": 5105, "method_signature": "URL getBaseUrl()", "filename": "DecoupledLoader.getBaseUrl.json"}
{"callee_method_names": [], "method_name": "DecoupledLoader.newLoader", "method_implementation": "{\n    // We use the bootstrap class loader as the parent because Finalizer by design uses\n    // only standard Java classes. That also means that FinalizableReferenceQueueTest\n    // doesn't pick up the wrong version of the Finalizer class.\n    return new URLClassLoader(new URL[] { base }, null);\n}", "repo_id": "5", "comment": "/**\n * Creates a class loader with the given base URL as its classpath.\n */\n", "repo_name": "guava-master/", "id": 5106, "method_signature": "URLClassLoader newLoader(URL)", "filename": "DecoupledLoader.newLoader.json"}
{"callee_method_names": ["Class<T>.isPrimitive"], "method_name": "Defaults.defaultValue", "method_implementation": "{\n    checkNotNull(type);\n    if (type.isPrimitive()) {\n        if (type == boolean.class) {\n            return (T) Boolean.FALSE;\n        } else if (type == char.class) {\n            return (T) Character.valueOf('\\0');\n        } else if (type == byte.class) {\n            return (T) Byte.valueOf((byte) 0);\n        } else if (type == short.class) {\n            return (T) Short.valueOf((short) 0);\n        } else if (type == int.class) {\n            return (T) Integer.valueOf(0);\n        } else if (type == long.class) {\n            return (T) Long.valueOf(0L);\n        } else if (type == float.class) {\n            return (T) FLOAT_DEFAULT;\n        } else if (type == double.class) {\n            return (T) DOUBLE_DEFAULT;\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Returns the default value of {@code type} as defined by JLS --- {@code 0} for numbers, {@code\n * false} for {@code boolean} and {@code '\\0'} for {@code char}. For non-primitive types and\n * {@code void}, {@code null} is returned.\n */\n", "repo_name": "guava-master/", "id": 4992, "method_signature": "T defaultValue(Class)", "filename": "Defaults.defaultValue.json"}
{"callee_method_names": ["CloseableList.add"], "method_name": "DeferredCloser.eventuallyClose", "method_implementation": "{\n    checkNotNull(closingExecutor);\n    if (closeable != null) {\n        list.add(closeable, closingExecutor);\n    }\n    return closeable;\n}", "repo_id": "5", "comment": "/**\n * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.\n *\n * <p>For users of the {@code -jre} flavor of Guava, the object can be any {@code\n * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code\n * Closeable}. (For more about the flavors, see <a\n * href=\"https://github.com/google/guava#adding-guava-to-your-build\">Adding Guava to your\n * build</a>.)\n *\n * <p>Be careful when targeting an older SDK than you are building against (most commonly when\n * building for Android): Ensure that any object you pass implements the interface not just in\n * your current SDK version but also at the oldest version you support. For example, <a\n * href=\"https://developer.android.com/sdk/api_diff/16/\">API Level 16</a> is the first version\n * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper\n * {@code Closeable} with a method reference like {@code cursor::close}.\n *\n * <p>Note that this method is still binary-compatible between flavors because the erasure of\n * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.\n *\n * @param closeable the object to be closed (see notes above)\n * @param closingExecutor the object will be closed on this executor\n * @return the first argument\n */\n", "repo_name": "guava-master/", "id": 5418, "method_signature": "C eventuallyClose(C, Executor)", "filename": "DeferredCloser.eventuallyClose.json"}
{"callee_method_names": [], "method_name": "DegeneratedImmutableSetGenerator.create", "method_implementation": "{\n    return (ImmutableSet<String>) ImmutableSet.of(elements[0], elements[0]);\n}", "repo_id": "5", "comment": "// is pointless\n", "repo_name": "guava-master/", "id": 4174, "method_signature": "Set<String> create(String[])", "filename": "DegeneratedImmutableSetGenerator.create.json"}
{"callee_method_names": [], "method_name": "DenseImmutableTable.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5550, "method_signature": "Object writeReplace()", "filename": "DenseImmutableTable.writeReplace.json"}
{"callee_method_names": ["SortedMap<K,V>.headMap", "SortedMap<K,V>.tailMap", "SortedMap<K,V>.subMap"], "method_name": "DerivedCollectionGenerators.createSubMap", "method_implementation": "{\n    if (from == Bound.NO_BOUND && to == Bound.EXCLUSIVE) {\n        return map.headMap(lastExclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.NO_BOUND) {\n        return map.tailMap(firstInclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.EXCLUSIVE) {\n        return map.subMap(firstInclusive, lastExclusive);\n    } else {\n        throw new IllegalArgumentException();\n    }\n}", "repo_id": "5", "comment": "/**\n * Calls the smallest subMap overload that filters out the extreme values. This method is\n * overridden in NavigableMapTestSuiteBuilder.\n */\n", "repo_name": "guava-master/", "id": 4151, "method_signature": "SortedMap<K,V> createSubMap(SortedMap, K, K)", "filename": "DerivedCollectionGenerators.createSubMap.json"}
{"callee_method_names": ["SortedSet<E>.headSet", "SortedSet<E>.tailSet", "SortedSet<E>.subSet"], "method_name": "DerivedCollectionGenerators.createSubSet", "method_implementation": "{\n    if (from == Bound.NO_BOUND && to == Bound.EXCLUSIVE) {\n        return set.headSet(lastExclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.NO_BOUND) {\n        return set.tailSet(firstInclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.EXCLUSIVE) {\n        return set.subSet(firstInclusive, lastExclusive);\n    } else {\n        throw new IllegalArgumentException();\n    }\n}", "repo_id": "5", "comment": "/**\n * Calls the smallest subSet overload that filters out the extreme values.\n */\n", "repo_name": "guava-master/", "id": 4150, "method_signature": "SortedSet<E> createSubSet(SortedSet, E, E)", "filename": "DerivedCollectionGenerators.createSubSet.json"}
{"callee_method_names": [], "method_name": "DescendingImmutableSortedMultiset.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5896, "method_signature": "Object writeReplace()", "filename": "DescendingImmutableSortedMultiset.writeReplace.json"}
{"callee_method_names": [], "method_name": "DescendingImmutableSortedSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6009, "method_signature": "Object writeReplace()", "filename": "DescendingImmutableSortedSet.writeReplace.json"}
{"callee_method_names": ["Object.notifyAll"], "method_name": "DirectExecutorService.endTask", "method_implementation": "{\n    synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n            lock.notifyAll();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Decrements the running task count.\n */\n", "repo_name": "guava-master/", "id": 5277, "method_signature": "void endTask()", "filename": "DirectExecutorService.endTask.json"}
{"callee_method_names": [], "method_name": "DirectExecutorService.shutdownNow", "method_implementation": "{\n    shutdown();\n    return Collections.emptyList();\n}", "repo_id": "5", "comment": "// See newDirectExecutorService javadoc for unusual behavior of this method.\n", "repo_name": "guava-master/", "id": 5275, "method_signature": "List<Runnable> shutdownNow()", "filename": "DirectExecutorService.shutdownNow.json"}
{"callee_method_names": [], "method_name": "DirectExecutorService.startTask", "method_implementation": "{\n    synchronized (lock) {\n        if (shutdown) {\n            throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks if the executor has been shut down and increments the running task count.\n *\n * @throws RejectedExecutionException if the executor has been previously shutdown\n */\n", "repo_name": "guava-master/", "id": 5276, "method_signature": "void startTask()", "filename": "DirectExecutorService.startTask.json"}
{"callee_method_names": [], "method_name": "DiscreteDomain.offset", "method_implementation": "{\n    C current = origin;\n    checkNonnegative(distance, \"distance\");\n    for (long i = 0; i < distance; i++) {\n        current = next(current);\n        if (current == null) {\n            throw new IllegalArgumentException(\"overflowed computing offset(\" + origin + \", \" + distance + \")\");\n        }\n    }\n    return current;\n}", "repo_id": "5", "comment": "/**\n * Returns, conceptually, \"origin + distance\", or equivalently, the result of calling {@link\n * #next} on {@code origin} {@code distance} times.\n */\n", "repo_name": "guava-master/", "id": 6138, "method_signature": "C offset(C, long)", "filename": "DiscreteDomain.offset.json"}
{"callee_method_names": [], "method_name": "DoubleMath.factorial", "method_implementation": "{\n    checkNonNegative(\"n\", n);\n    if (n > MAX_FACTORIAL) {\n        return Double.POSITIVE_INFINITY;\n    } else {\n        // Multiplying the last (n & 0xf) values into their own accumulator gives a more accurate\n        // result than multiplying by everySixteenthFactorial[n >> 4] directly.\n        double accum = 1.0;\n        for (int i = 1 + (n & ~0xf); i <= n; i++) {\n            accum *= i;\n        }\n        return accum * everySixteenthFactorial[n >> 4];\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if\n * {@code n == 0}, or {@code n!}, or {@link Double#POSITIVE_INFINITY} if {@code n! >\n * Double.MAX_VALUE}.\n *\n * <p>The result is within 1 ulp of the true value.\n *\n * @throws IllegalArgumentException if {@code n < 0}\n */\n", "repo_name": "guava-master/", "id": 4556, "method_signature": "double factorial(int)", "filename": "DoubleMath.factorial.json"}
{"callee_method_names": [], "method_name": "DoubleMath.fuzzyCompare", "method_implementation": "{\n    if (fuzzyEquals(a, b, tolerance)) {\n        return 0;\n    } else if (a < b) {\n        return -1;\n    } else if (a > b) {\n        return 1;\n    } else {\n        return Booleans.compare(Double.isNaN(a), Double.isNaN(b));\n    }\n}", "repo_id": "5", "comment": "/**\n * Compares {@code a} and {@code b} \"fuzzily,\" with a tolerance for nearly-equal values.\n *\n * <p>This method is equivalent to {@code fuzzyEquals(a, b, tolerance) ? 0 : Double.compare(a,\n * b)}. In particular, like {@link Double#compare(double, double)}, it treats all NaN values as\n * equal and greater than all other values (including {@link Double#POSITIVE_INFINITY}).\n *\n * <p>This is <em>not</em> a total ordering and is <em>not</em> suitable for use in {@link\n * Comparable#compareTo} implementations. In particular, it is not transitive.\n *\n * @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 4558, "method_signature": "int fuzzyCompare(double, double, double)", "filename": "DoubleMath.fuzzyCompare.json"}
{"callee_method_names": [], "method_name": "DoubleMath.fuzzyEquals", "method_implementation": "{\n    MathPreconditions.checkNonNegative(\"tolerance\", tolerance);\n    return Math.copySign(a - b, 1.0) <= tolerance || // copySign(x, 1.0) is a branch-free version of abs(x), but with different NaN semantics\n    (// needed to ensure that infinities equal themselves\n    a == b) || (Double.isNaN(a) && Double.isNaN(b));\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code a} and {@code b} are within {@code tolerance} of each other.\n *\n * <p>Technically speaking, this is equivalent to {@code Math.abs(a - b) <= tolerance ||\n * Double.valueOf(a).equals(Double.valueOf(b))}.\n *\n * <p>Notable special cases include:\n *\n * <ul>\n *   <li>All NaNs are fuzzily equal.\n *   <li>If {@code a == b}, then {@code a} and {@code b} are always fuzzily equal.\n *   <li>Positive and negative zero are always fuzzily equal.\n *   <li>If {@code tolerance} is zero, and neither {@code a} nor {@code b} is NaN, then {@code a}\n *       and {@code b} are fuzzily equal if and only if {@code a == b}.\n *   <li>With {@link Double#POSITIVE_INFINITY} tolerance, all non-NaN values are fuzzily equal.\n *   <li>With finite tolerance, {@code Double.POSITIVE_INFINITY} and {@code\n *       Double.NEGATIVE_INFINITY} are fuzzily equal only to themselves.\n * </ul>\n *\n * <p>This is reflexive and symmetric, but <em>not</em> transitive, so it is <em>not</em> an\n * equivalence relation and <em>not</em> suitable for use in {@link Object#equals}\n * implementations.\n *\n * @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 4557, "method_signature": "boolean fuzzyEquals(double, double, double)", "filename": "DoubleMath.fuzzyEquals.json"}
{"callee_method_names": [], "method_name": "DoubleMath.isMathematicalInteger", "method_implementation": "{\n    return isFinite(x) && (x == 0.0 || SIGNIFICAND_BITS - Long.numberOfTrailingZeros(getSignificand(x)) <= getExponent(x));\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code x} represents a mathematical integer.\n *\n * <p>This is equivalent to, but not necessarily implemented as, the expression {@code\n * !Double.isNaN(x) && !Double.isInfinite(x) && x == Math.rint(x)}.\n */\n", "repo_name": "guava-master/", "id": 4555, "method_signature": "boolean isMathematicalInteger(double)", "filename": "DoubleMath.isMathematicalInteger.json"}
{"callee_method_names": [], "method_name": "DoubleMath.isPowerOfTwo", "method_implementation": "{\n    if (x > 0.0 && isFinite(x)) {\n        long significand = getSignificand(x);\n        return (significand & (significand - 1)) == 0;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code x} is exactly equal to {@code 2^k} for some finite integer\n * {@code k}.\n */\n", "repo_name": "guava-master/", "id": 4553, "method_signature": "boolean isPowerOfTwo(double)", "filename": "DoubleMath.isPowerOfTwo.json"}
{"callee_method_names": [], "method_name": "DoubleMath.log2", "method_implementation": "{\n    checkArgument(x > 0.0 && isFinite(x), \"x must be positive and finite\");\n    int exponent = getExponent(x);\n    if (!isNormal(x)) {\n        return log2(x * IMPLICIT_BIT, mode) - SIGNIFICAND_BITS;\n        // Do the calculation on a normal value.\n    }\n    // x is positive, finite, and normal\n    boolean increment;\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(isPowerOfTwo(x));\n        // fall through\n        case FLOOR:\n            increment = false;\n            break;\n        case CEILING:\n            increment = !isPowerOfTwo(x);\n            break;\n        case DOWN:\n            increment = exponent < 0 & !isPowerOfTwo(x);\n            break;\n        case UP:\n            increment = exponent >= 0 & !isPowerOfTwo(x);\n            break;\n        case HALF_DOWN:\n        case HALF_EVEN:\n        case HALF_UP:\n            double xScaled = scaleNormalize(x);\n            // sqrt(2) is irrational, and the spec is relative to the \"exact numerical result,\"\n            // so log2(x) is never exactly exponent + 0.5.\n            increment = (xScaled * xScaled) > 2.0;\n            break;\n        default:\n            throw new AssertionError();\n    }\n    return increment ? exponent + 1 : exponent;\n}", "repo_id": "5", "comment": "/**\n * Returns the base 2 logarithm of a double value, rounded with the specified rounding mode to an\n * {@code int}.\n *\n * <p>Regardless of the rounding mode, this is faster than {@code (int) log2(x)}.\n *\n * @throws IllegalArgumentException if {@code x <= 0.0}, {@code x} is NaN, or {@code x} is\n *     infinite\n */\n", "repo_name": "guava-master/", "id": 4554, "method_signature": "int log2(double, RoundingMode)", "filename": "DoubleMath.log2.json"}
{"callee_method_names": ["Iterator<? extends Number>.hasNext", "Iterator<? extends Number>.next", "Iterator<? extends Number>.hasNext", "Iterator<? extends Number>.next"], "method_name": "DoubleMath.mean", "method_implementation": "{\n    checkArgument(values.hasNext(), \"Cannot take mean of 0 values\");\n    long count = 1;\n    double mean = checkFinite(values.next().doubleValue());\n    while (values.hasNext()) {\n        double value = checkFinite(values.next().doubleValue());\n        count++;\n        // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)\n        mean += (value - mean) / count;\n    }\n    return mean;\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of\n * {@code values}.\n *\n * <p>If these values are a sample drawn from a population, this is also an unbiased estimator of\n * the arithmetic mean of the population.\n *\n * @param values a nonempty series of values, which will be converted to {@code double} values\n *     (this may cause loss of precision)\n * @throws IllegalArgumentException if {@code values} is empty or contains any non-finite value\n * @deprecated Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite\n *     values.\n */\n", "repo_name": "guava-master/", "id": 4563, "method_signature": "double mean(Iterator)", "filename": "DoubleMath.mean.json"}
{"callee_method_names": [], "method_name": "DoubleMath.roundIntermediate", "method_implementation": "{\n    if (!isFinite(x)) {\n        throw new ArithmeticException(\"input is infinite or NaN\");\n    }\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(isMathematicalInteger(x));\n            return x;\n        case FLOOR:\n            if (x >= 0.0 || isMathematicalInteger(x)) {\n                return x;\n            } else {\n                return (long) x - 1;\n            }\n        case CEILING:\n            if (x <= 0.0 || isMathematicalInteger(x)) {\n                return x;\n            } else {\n                return (long) x + 1;\n            }\n        case DOWN:\n            return x;\n        case UP:\n            if (isMathematicalInteger(x)) {\n                return x;\n            } else {\n                return (long) x + (x > 0 ? 1 : -1);\n            }\n        case HALF_EVEN:\n            return rint(x);\n        case HALF_UP:\n            {\n                double z = rint(x);\n                if (abs(x - z) == 0.5) {\n                    return x + copySign(0.5, x);\n                } else {\n                    return z;\n                }\n            }\n        case HALF_DOWN:\n            {\n                double z = rint(x);\n                if (abs(x - z) == 0.5) {\n                    return x;\n                } else {\n                    return z;\n                }\n            }\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/*\n   * This method returns a value y such that rounding y DOWN (towards zero) gives the same result as\n   * rounding x according to the specified mode.\n   */\n", "repo_name": "guava-master/", "id": 4549, "method_signature": "double roundIntermediate(double, RoundingMode)", "filename": "DoubleMath.roundIntermediate.json"}
{"callee_method_names": ["BigInteger.negate"], "method_name": "DoubleMath.roundToBigInteger", "method_implementation": "{\n    x = roundIntermediate(x, mode);\n    if (MIN_LONG_AS_DOUBLE - x < 1.0 & x < MAX_LONG_AS_DOUBLE_PLUS_ONE) {\n        return BigInteger.valueOf((long) x);\n    }\n    int exponent = getExponent(x);\n    long significand = getSignificand(x);\n    BigInteger result = BigInteger.valueOf(significand).shiftLeft(exponent - SIGNIFICAND_BITS);\n    return (x < 0) ? result.negate() : result;\n}", "repo_id": "5", "comment": "// #roundIntermediate, java.lang.Math.getExponent, com.google.common.math.DoubleUtils\n", "repo_name": "guava-master/", "id": 4552, "method_signature": "BigInteger roundToBigInteger(double, RoundingMode)", "filename": "DoubleMath.roundToBigInteger.json"}
{"callee_method_names": [], "method_name": "DoubleMath.roundToInt", "method_implementation": "{\n    double z = roundIntermediate(x, mode);\n    checkInRangeForRoundingInputs(z > MIN_INT_AS_DOUBLE - 1.0 & z < MAX_INT_AS_DOUBLE + 1.0, x, mode);\n    return (int) z;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code int} value that is equal to {@code x} rounded with the specified rounding\n * mode, if possible.\n *\n * @throws ArithmeticException if\n *     <ul>\n *       <li>{@code x} is infinite or NaN\n *       <li>{@code x}, after being rounded to a mathematical integer using the specified rounding\n *           mode, is either less than {@code Integer.MIN_VALUE} or greater than {@code\n *           Integer.MAX_VALUE}\n *       <li>{@code x} is not a mathematical integer and {@code mode} is {@link\n *           RoundingMode#UNNECESSARY}\n *     </ul>\n */\n", "repo_name": "guava-master/", "id": 4550, "method_signature": "int roundToInt(double, RoundingMode)", "filename": "DoubleMath.roundToInt.json"}
{"callee_method_names": [], "method_name": "DoubleMath.roundToLong", "method_implementation": "{\n    double z = roundIntermediate(x, mode);\n    checkInRangeForRoundingInputs(MIN_LONG_AS_DOUBLE - z < 1.0 & z < MAX_LONG_AS_DOUBLE_PLUS_ONE, x, mode);\n    return (long) z;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code long} value that is equal to {@code x} rounded with the specified rounding\n * mode, if possible.\n *\n * @throws ArithmeticException if\n *     <ul>\n *       <li>{@code x} is infinite or NaN\n *       <li>{@code x}, after being rounded to a mathematical integer using the specified rounding\n *           mode, is either less than {@code Long.MIN_VALUE} or greater than {@code\n *           Long.MAX_VALUE}\n *       <li>{@code x} is not a mathematical integer and {@code mode} is {@link\n *           RoundingMode#UNNECESSARY}\n *     </ul>\n */\n", "repo_name": "guava-master/", "id": 4551, "method_signature": "long roundToLong(double, RoundingMode)", "filename": "DoubleMath.roundToLong.json"}
{"callee_method_names": [], "method_name": "Doubles.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new DoubleArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>The returned list maintains the values, but not the identities, of {@code Double} objects\n * written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for\n * the returned list is unspecified.\n *\n * <p>The returned list may have unexpected behavior if it contains {@code NaN}, or if {@code NaN}\n * is used as a parameter to any of its methods.\n *\n * <p>The returned list is serializable.\n *\n * <p><b>Note:</b> when possible, you should represent your data as an {@link\n * ImmutableDoubleArray} instead, which has an {@link ImmutableDoubleArray#asList asList} view.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4422, "method_signature": "List<Double> asList(double[])", "filename": "Doubles.asList.json"}
{"callee_method_names": [], "method_name": "Doubles.concat", "method_implementation": "{\n    int length = 0;\n    for (double[] array : arrays) {\n        length += array.length;\n    }\n    double[] result = new double[length];\n    int pos = 0;\n    for (double[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new double[] {a, b}, new double[] {}, new double[] {c}} returns the array {@code {a, b,\n * c}}.\n *\n * @param arrays zero or more {@code double} arrays\n * @return a single array containing all the values from the source arrays, in order\n */\n", "repo_name": "guava-master/", "id": 4415, "method_signature": "double[] concat(double[][])", "filename": "Doubles.concat.json"}
{"callee_method_names": [], "method_name": "Doubles.constrainToRange", "method_implementation": "{\n    // avoid auto-boxing by not using Preconditions.checkArgument(); see Guava issue 3984\n    // Reject NaN by testing for the good case (min <= max) instead of the bad (min > max).\n    if (min <= max) {\n        return Math.min(Math.max(value, min), max);\n    }\n    throw new IllegalArgumentException(lenientFormat(\"min (%s) must be less than or equal to max (%s)\", min, max));\n}", "repo_id": "5", "comment": "/**\n * Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.\n *\n * <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned\n * unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code\n * value} is greater than {@code max}, {@code max} is returned.\n *\n * @param value the {@code double} value to constrain\n * @param min the lower bound (inclusive) of the range to constrain {@code value} to\n * @param max the upper bound (inclusive) of the range to constrain {@code value} to\n * @throws IllegalArgumentException if {@code min > max}\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 4414, "method_signature": "double constrainToRange(double, double, double)", "filename": "Doubles.constrainToRange.json"}
{"callee_method_names": [], "method_name": "Doubles.contains", "method_implementation": "{\n    for (double value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}. Note\n * that this always returns {@code false} when {@code target} is {@code NaN}.\n *\n * @param array an array of {@code double} values, possibly empty\n * @param target a primitive {@code double} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4408, "method_signature": "boolean contains(double[], double)", "filename": "Doubles.contains.json"}
{"callee_method_names": [], "method_name": "Doubles.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4416, "method_signature": "double[] ensureCapacity(double[], int, int)", "filename": "Doubles.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Doubles.hashCode", "method_implementation": "{\n    return ((Double) value).hashCode();\n    // TODO(kevinb): do it this way when we can (GWT problem):\n    // long bits = Double.doubleToLongBits(value);\n    // return (int) (bits ^ (bits >>> 32));\n}", "repo_id": "5", "comment": "/**\n * Returns a hash code for {@code value}; equal to the result of invoking {@code ((Double)\n * value).hashCode()}.\n *\n * <p><b>Java 8 users:</b> use {@link Double#hashCode(double)} instead.\n *\n * @param value a primitive {@code double} value\n * @return a hash code for the value\n */\n", "repo_name": "guava-master/", "id": 4407, "method_signature": "int hashCode(double)", "filename": "Doubles.hashCode.json"}
{"callee_method_names": [], "method_name": "Doubles.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * <p>Note that this always returns {@code -1} when {@code target} contains {@code NaN}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4410, "method_signature": "int indexOf(double[], double[])", "filename": "Doubles.indexOf.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Doubles.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 12);\n    builder.append(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code double} values, converted to strings as\n * specified by {@link Double#toString(double)}, and separated by {@code separator}. For example,\n * {@code join(\"-\", 1.0, 2.0, 3.0)} returns the string {@code \"1.0-2.0-3.0\"}.\n *\n * <p>Note that {@link Double#toString(double)} formats {@code double} differently in GWT\n * sometimes. In the previous example, it returns the string {@code \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code double} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4417, "method_signature": "String join(String, double[])", "filename": "Doubles.join.json"}
{"callee_method_names": [], "method_name": "Doubles.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4411, "method_signature": "int lastIndexOf(double[], double, int, int)", "filename": "Doubles.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Doubles.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    double max = array[0];\n    for (int i = 1; i < array.length; i++) {\n        max = Math.max(max, array[i]);\n    }\n    return max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}, using the same rules of comparison as\n * {@link Math#max(double, double)}.\n *\n * @param array a <i>nonempty</i> array of {@code double} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4413, "method_signature": "double max(double[])", "filename": "Doubles.max.json"}
{"callee_method_names": [], "method_name": "Doubles.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    double min = array[0];\n    for (int i = 1; i < array.length; i++) {\n        min = Math.min(min, array[i]);\n    }\n    return min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}, using the same rules of comparison as {@link\n * Math#min(double, double)}.\n *\n * @param array a <i>nonempty</i> array of {@code double} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4412, "method_signature": "double min(double[])", "filename": "Doubles.min.json"}
{"callee_method_names": [], "method_name": "Doubles.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        double tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Doubles.asList(array).subList(fromIndex, toIndex))}, but is likely to be\n * more efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4419, "method_signature": "void reverse(double[], int, int)", "filename": "Doubles.reverse.json"}
{"callee_method_names": [], "method_name": "Doubles.rotate", "method_implementation": "{\n    // See Ints.rotate for more details about possible algorithms here.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Bytes.asList(array).subList(fromIndex, toIndex), distance)}, but is\n * considerably faster and avoids allocations and garbage collection.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4420, "method_signature": "void rotate(double[], int, int, int)", "filename": "Doubles.rotate.json"}
{"callee_method_names": [], "method_name": "Doubles.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    Arrays.sort(array, fromIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order.\n *\n * <p>Note that this method uses the total order imposed by {@link Double#compare}, which treats\n * all NaN values as equal and 0.0 as greater than -0.0.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4418, "method_signature": "void sortDescending(double[], int, int)", "filename": "Doubles.sortDescending.json"}
{"callee_method_names": ["Collection<? extends Number>.toArray"], "method_name": "Doubles.toArray", "method_implementation": "{\n    if (collection instanceof DoubleArrayAsList) {\n        return ((DoubleArrayAsList) collection).toDoubleArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    double[] array = new double[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = ((Number) checkNotNull(boxedArray[i])).doubleValue();\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing each value of {@code collection}, converted to a {@code double}\n * value in the manner of {@link Number#doubleValue}.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * @param collection a collection of {@code Number} instances\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n * @since 1.0 (parameter was {@code Collection<Double>} before 12.0)\n */\n", "repo_name": "guava-master/", "id": 4421, "method_signature": "double[] toArray(Collection)", "filename": "Doubles.toArray.json"}
{"callee_method_names": ["java.util.regex.Pattern.matcher"], "method_name": "Doubles.tryParse", "method_implementation": "{\n    if (FLOATING_POINT_PATTERN.matcher(string).matches()) {\n        // TODO(lowasser): could be potentially optimized, but only with\n        // extensive testing\n        try {\n            return Double.parseDouble(string);\n        } catch (NumberFormatException e) {\n            // Double.parseDouble has changed specs several times, so fall through\n            // gracefully\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Parses the specified string as a double-precision floating point value. The ASCII character\n * {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.\n *\n * <p>Unlike {@link Double#parseDouble(String)}, this method returns {@code null} instead of\n * throwing an exception if parsing fails. Valid inputs are exactly those accepted by {@link\n * Double#valueOf(String)}, except that leading and trailing whitespace is not permitted.\n *\n * <p>This implementation is likely to be faster than {@code Double.parseDouble} if many failures\n * are expected.\n *\n * @param string the string representation of a {@code double} value\n * @return the floating point value represented by {@code string}, or {@code null} if {@code\n *     string} has a length of zero or cannot be parsed as a {@code double} value\n * @throws NullPointerException if {@code string} is {@code null}\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4423, "method_signature": "Double tryParse(String)", "filename": "Doubles.tryParse.json"}
{"callee_method_names": ["String.trim", "String.length"], "method_name": "DoublesTest.referenceTryParse", "method_implementation": "{\n    if (input.trim().length() < input.length()) {\n        return null;\n    }\n    try {\n        return Double.valueOf(input);\n    } catch (NumberFormatException e) {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * A reference implementation for {@code tryParse} that just catches the exception from {@link\n * Double#valueOf}.\n */\n", "repo_name": "guava-master/", "id": 3549, "method_signature": "Double referenceTryParse(String)", "filename": "DoublesTest.referenceTryParse.json"}
{"callee_method_names": ["List<Double>.subList", "List<Double>.subList"], "method_name": "DoublesTest.testAsList_subList_toArray_roundTrip", "method_implementation": "{\n    double[] array = { (double) 0, (double) 1, (double) 2, (double) 3 };\n    List<Double> list = Doubles.asList(array);\n    assertThat(Doubles.toArray(list.subList(1, 3))).isEqualTo(new double[] { (double) 1, (double) 2 });\n    assertThat(Doubles.toArray(list.subList(2, 2))).isEmpty();\n}", "repo_id": "5", "comment": "// This test stems from a real bug found by andrewk\n", "repo_name": "guava-master/", "id": 3548, "method_signature": "void testAsList_subList_toArray_roundTrip()", "filename": "DoublesTest.testAsList_subList_toArray_roundTrip.json"}
{"callee_method_names": ["Set<Class<?>>.addAll", "TypeToken<T>.getTypes", "Set<Class<?>>.add", "Set<Class<?>>.iterator", "Set<Class<?>>.toArray", "Set<Class<?>>.size"], "method_name": "DummyProxy.newProxy", "method_implementation": "{\n    Set<Class<?>> interfaceClasses = Sets.newLinkedHashSet();\n    interfaceClasses.addAll(interfaceType.getTypes().interfaces().rawTypes());\n    // Make the proxy serializable to work with SerializableTester\n    interfaceClasses.add(Serializable.class);\n    Object dummy = Proxy.newProxyInstance(interfaceClasses.iterator().next().getClassLoader(), interfaceClasses.toArray(new Class<?>[interfaceClasses.size()]), new DummyHandler(interfaceType));\n    // interfaceType is T\n    @SuppressWarnings(\"unchecked\")\n    T result = (T) dummy;\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a new proxy for {@code interfaceType}. Proxies of the same interface are equal to each\n * other if the {@link DummyProxy} instance that created the proxies are equal.\n */\n", "repo_name": "guava-master/", "id": 4110, "method_signature": "T newProxy(TypeToken)", "filename": "DummyProxy.newProxy.json"}
{"callee_method_names": [], "method_name": "ElementOrder.comparator", "method_implementation": "{\n    if (comparator != null) {\n        return comparator;\n    }\n    throw new UnsupportedOperationException(\"This ordering does not define a comparator.\");\n}", "repo_id": "5", "comment": "/**\n * Returns the {@link Comparator} used.\n *\n * @throws UnsupportedOperationException if comparator is not defined\n */\n", "repo_name": "guava-master/", "id": 6736, "method_signature": "Comparator<T> comparator()", "filename": "ElementOrder.comparator.json"}
{"callee_method_names": [], "method_name": "ElementOrder.createMap", "method_implementation": "{\n    switch(type) {\n        case UNORDERED:\n            return Maps.newHashMapWithExpectedSize(expectedSize);\n        case INSERTION:\n        case STABLE:\n            return Maps.newLinkedHashMapWithExpectedSize(expectedSize);\n        case SORTED:\n            return Maps.newTreeMap(comparator());\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an empty mutable map whose keys will respect this {@link ElementOrder}.\n */\n", "repo_name": "guava-master/", "id": 6737, "method_signature": "Map<K,V> createMap(int)", "filename": "ElementOrder.createMap.json"}
{"callee_method_names": ["MutableNetwork<Integer, String>.edgeOrder", "MutableNetwork<Integer, String>.edges", "MutableNetwork<Integer, String>.nodeOrder"], "method_name": "ElementOrderTest.edgeOrder_default", "method_implementation": "{\n    MutableNetwork<Integer, String> network = NetworkBuilder.directed().build();\n    addEdges(network);\n    assertThat(network.edgeOrder()).isEqualTo(ElementOrder.insertion());\n    assertThat(network.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder();\n    // default\n    assertThat(network.nodeOrder()).isEqualTo(ElementOrder.insertion());\n}", "repo_id": "5", "comment": "// The default ordering is INSERTION unless otherwise specified.\n", "repo_name": "guava-master/", "id": 4073, "method_signature": "void edgeOrder_default()", "filename": "ElementOrderTest.edgeOrder_default.json"}
{"callee_method_names": ["MutableGraph<Integer>.nodeOrder", "MutableGraph<Integer>.nodes"], "method_name": "ElementOrderTest.nodeOrder_default", "method_implementation": "{\n    MutableGraph<Integer> graph = GraphBuilder.directed().build();\n    addNodes(graph);\n    assertThat(graph.nodeOrder()).isEqualTo(insertion());\n    assertThat(graph.nodes()).containsExactly(3, 1, 4).inOrder();\n}", "repo_id": "5", "comment": "// The default ordering is INSERTION unless otherwise specified.\n", "repo_name": "guava-master/", "id": 4072, "method_signature": "void nodeOrder_default()", "filename": "ElementOrderTest.nodeOrder_default.json"}
{"callee_method_names": [], "method_name": "ElementSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5933, "method_signature": "Object writeReplace()", "filename": "ElementSet.writeReplace.json"}
{"callee_method_names": ["CacheBuilderFactory.buildAllPermutations", "CacheBuilder<Object, Object>.build"], "method_name": "EmptyCachesTest.caches", "method_implementation": "{\n    // lots of different ways to configure a LoadingCache\n    CacheBuilderFactory factory = cacheFactory();\n    return Iterables.transform(factory.buildAllPermutations(), new Function<CacheBuilder<Object, Object>, LoadingCache<Object, Object>>() {\n\n        @Override\n        public LoadingCache<Object, Object> apply(CacheBuilder<Object, Object> builder) {\n            return builder.build(identityLoader());\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Most of the tests in this class run against every one of these caches.\n */\n", "repo_name": "guava-master/", "id": 3685, "method_signature": "Iterable<LoadingCache<Object,Object>> caches()", "filename": "EmptyCachesTest.caches.json"}
{"callee_method_names": ["N.equals", "N.equals"], "method_name": "EndpointPair.adjacentNode", "method_implementation": "{\n    if (node.equals(nodeU)) {\n        return nodeV;\n    } else if (node.equals(nodeV)) {\n        return nodeU;\n    } else {\n        throw new IllegalArgumentException(\"EndpointPair \" + this + \" does not contain node \" + node);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the node that is adjacent to {@code node} along the origin edge.\n *\n * @throws IllegalArgumentException if this {@link EndpointPair} does not contain {@code node}\n * @since 20.0 (but the argument type was changed from {@code Object} to {@code N} in 31.0)\n */\n", "repo_name": "guava-master/", "id": 6738, "method_signature": "N adjacentNode(N)", "filename": "EndpointPair.adjacentNode.json"}
{"callee_method_names": ["Iterator<N>.hasNext", "Iterator<N>.hasNext", "Iterator<N>.next", "BaseGraph<N>.successors"], "method_name": "EndpointPairIterator.advance", "method_implementation": "{\n    checkState(!successorIterator.hasNext());\n    if (!nodeIterator.hasNext()) {\n        return false;\n    }\n    node = nodeIterator.next();\n    successorIterator = graph.successors(node).iterator();\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Called after {@link #successorIterator} is exhausted. Advances {@link #node} to the next node\n * and updates {@link #successorIterator} to iterate through the successors of {@link #node}.\n */\n", "repo_name": "guava-master/", "id": 6799, "method_signature": "boolean advance()", "filename": "EndpointPairIterator.advance.json"}
{"callee_method_names": [], "method_name": "EntryCollection.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6672, "method_signature": "Object writeReplace()", "filename": "EntryCollection.writeReplace.json"}
{"callee_method_names": ["Entry<?>.getElement", "Entry<?>.getCount", "Multiset<@Nullable Object>.setCount"], "method_name": "EntrySet.remove", "method_implementation": "{\n    if (object instanceof Multiset.Entry) {\n        Entry<?> entry = (Entry<?>) object;\n        Object element = entry.getElement();\n        int entryCount = entry.getCount();\n        if (entryCount != 0) {\n            // Safe as long as we never add a new entry, which we won't.\n            // (Presumably it can still throw CCE/NPE but only if the underlying Multiset does.)\n            @SuppressWarnings({ \"unchecked\", \"nullness\" })\n            Multiset<@Nullable Object> multiset = (Multiset<@Nullable Object>) multiset();\n            return multiset.setCount(element, entryCount, 0);\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "// GWT compiler warning; see contains().\n", "repo_name": "guava-master/", "id": 6218, "method_signature": "boolean remove(Object)", "filename": "EntrySet.remove.json"}
{"callee_method_names": [], "method_name": "EntrySet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6447, "method_signature": "Object writeReplace()", "filename": "EntrySet.writeReplace.json"}
{"callee_method_names": [], "method_name": "EntrySetImpl.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6046, "method_signature": "Object writeReplace()", "filename": "EntrySetImpl.writeReplace.json"}
{"callee_method_names": ["EnumBiMap<K, V>.putAll"], "method_name": "EnumBiMap.create", "method_implementation": "{\n    EnumBiMap<K, V> bimap = create(inferKeyTypeOrObjectUnderJ2cl(map), inferValueTypeOrObjectUnderJ2cl(map));\n    bimap.putAll(map);\n    return bimap;\n}", "repo_id": "5", "comment": "/**\n * Returns a new bimap with the same mappings as the specified map. If the specified map is an\n * {@code EnumBiMap}, the new bimap has the same types as the provided map. Otherwise, the\n * specified map must contain at least one mapping, in order to determine the key and value types.\n *\n * @param map the map whose mappings are to be placed in this map\n * @throws IllegalArgumentException if map is not an {@code EnumBiMap} instance and contains no\n *     mappings\n */\n", "repo_name": "guava-master/", "id": 6600, "method_signature": "EnumBiMap<K,V> create(Map)", "filename": "EnumBiMap.create.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject"], "method_name": "EnumBiMap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(keyTypeOrObjectUnderJ2cl);\n    stream.writeObject(valueTypeOrObjectUnderJ2cl);\n    Serialization.writeMap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the key class, value class, number of entries, first key, first value, second key,\n *     second value, and so on.\n */\n", "repo_name": "guava-master/", "id": 6601, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "EnumBiMap.writeObject.json"}
{"callee_method_names": ["EnumHashBiMap<K, V>.putAll"], "method_name": "EnumHashBiMap.create", "method_implementation": "{\n    EnumHashBiMap<K, V> bimap = create(EnumBiMap.inferKeyTypeOrObjectUnderJ2cl(map));\n    bimap.putAll(map);\n    return bimap;\n}", "repo_id": "5", "comment": "/**\n * Constructs a new bimap with the same mappings as the specified map. If the specified map is an\n * {@code EnumHashBiMap} or an {@link EnumBiMap}, the new bimap has the same key type as the input\n * bimap. Otherwise, the specified map must contain at least one mapping, in order to determine\n * the key type.\n *\n * @param map the map whose mappings are to be placed in this map\n * @throws IllegalArgumentException if map is not an {@code EnumBiMap} or an {@code EnumHashBiMap}\n *     instance and contains no mappings\n */\n", "repo_name": "guava-master/", "id": 6185, "method_signature": "EnumHashBiMap<K,V> create(Map)", "filename": "EnumHashBiMap.create.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject"], "method_name": "EnumHashBiMap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(keyTypeOrObjectUnderJ2cl);\n    Serialization.writeMap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the key class, number of entries, first key, first value, second key, second value,\n *     and so on.\n */\n", "repo_name": "guava-master/", "id": 6186, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "EnumHashBiMap.writeObject.json"}
{"callee_method_names": ["E.ordinal"], "method_name": "EnumMultiset.add", "method_implementation": "{\n    checkIsE(element);\n    checkNonnegative(occurrences, \"occurrences\");\n    if (occurrences == 0) {\n        return count(element);\n    }\n    int index = element.ordinal();\n    int oldCount = counts[index];\n    long newCount = (long) oldCount + occurrences;\n    checkArgument(newCount <= Integer.MAX_VALUE, \"too many occurrences: %s\", newCount);\n    counts[index] = (int) newCount;\n    if (oldCount == 0) {\n        distinctElements++;\n    }\n    size += occurrences;\n    return oldCount;\n}", "repo_id": "5", "comment": "// Modification Operations\n", "repo_name": "guava-master/", "id": 6066, "method_signature": "int add(E, int)", "filename": "EnumMultiset.add.json"}
{"callee_method_names": [], "method_name": "EnumMultiset.checkIsE", "method_implementation": "{\n    checkNotNull(element);\n    if (!isActuallyE(element)) {\n        throw new ClassCastException(\"Expected an \" + type + \" but got \" + element);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code element} cast to {@code E}, if it actually is a nonnull E. Otherwise, throws\n * either a NullPointerException or a ClassCastException as appropriate.\n */\n", "repo_name": "guava-master/", "id": 6065, "method_signature": "void checkIsE(Object)", "filename": "EnumMultiset.checkIsE.json"}
{"callee_method_names": [], "method_name": "EnumMultiset.create", "method_implementation": "{\n    EnumMultiset<E> result = create(type);\n    Iterables.addAll(result, elements);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code EnumMultiset} instance containing the given elements. Unlike {@link\n * EnumMultiset#create(Iterable)}, this method does not produce an exception on an empty iterable.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6064, "method_signature": "EnumMultiset<E> create(Iterable, Class)", "filename": "EnumMultiset.create.json"}
{"callee_method_names": ["ObjectInputStream.defaultReadObject", "ObjectInputStream.readObject", "Class<E>.getEnumConstants"], "method_name": "EnumMultiset.readObject", "method_implementation": "{\n    stream.defaultReadObject();\n    // reading data stored by writeObject\n    @SuppressWarnings(\"unchecked\")\n    Class<E> localType = (Class<E>) requireNonNull(stream.readObject());\n    type = localType;\n    enumConstants = type.getEnumConstants();\n    counts = new int[enumConstants.length];\n    Serialization.populateMultiset(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the {@code Class<E>} for the enum type, the number of distinct elements, the first\n *     element, its count, the second element, its count, and so on\n */\n", "repo_name": "guava-master/", "id": 6069, "method_signature": "void readObject(ObjectInputStream)", "filename": "EnumMultiset.readObject.json"}
{"callee_method_names": ["Enum<?>.ordinal"], "method_name": "EnumMultiset.remove", "method_implementation": "{\n    // isActuallyE checks for null, but we check explicitly to help nullness checkers.\n    if (element == null || !isActuallyE(element)) {\n        return 0;\n    }\n    Enum<?> e = (Enum<?>) element;\n    checkNonnegative(occurrences, \"occurrences\");\n    if (occurrences == 0) {\n        return count(element);\n    }\n    int index = e.ordinal();\n    int oldCount = counts[index];\n    if (oldCount == 0) {\n        return 0;\n    } else if (oldCount <= occurrences) {\n        counts[index] = 0;\n        distinctElements--;\n        size -= oldCount;\n    } else {\n        counts[index] = oldCount - occurrences;\n        size -= occurrences;\n    }\n    return oldCount;\n}", "repo_id": "5", "comment": "// Modification Operations\n", "repo_name": "guava-master/", "id": 6067, "method_signature": "int remove(Object, int)", "filename": "EnumMultiset.remove.json"}
{"callee_method_names": ["E.ordinal"], "method_name": "EnumMultiset.setCount", "method_implementation": "{\n    checkIsE(element);\n    checkNonnegative(count, \"count\");\n    int index = element.ordinal();\n    int oldCount = counts[index];\n    counts[index] = count;\n    size += count - oldCount;\n    if (oldCount == 0 && count > 0) {\n        distinctElements++;\n    } else if (oldCount > 0 && count == 0) {\n        distinctElements--;\n    }\n    return oldCount;\n}", "repo_id": "5", "comment": "// Modification Operations\n", "repo_name": "guava-master/", "id": 6068, "method_signature": "int setCount(E, int)", "filename": "EnumMultiset.setCount.json"}
{"callee_method_names": ["Enum<?>.getDeclaringClass", "Class<?>.getDeclaredField", "Enum<?>.name"], "method_name": "Enums.getField", "method_implementation": "{\n    Class<?> clazz = enumValue.getDeclaringClass();\n    try {\n        return clazz.getDeclaredField(enumValue.name());\n    } catch (NoSuchFieldException impossible) {\n        throw new AssertionError(impossible);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the {@link Field} in which {@code enumValue} is defined. For example, to get the {@code\n * Description} annotation on the {@code GOLF} constant of enum {@code Sport}, use {@code\n * Enums.getField(Sport.GOLF).getAnnotation(Description.class)}.\n *\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5124, "method_signature": "Field getField(Enum)", "filename": "Enums.getField.json"}
{"callee_method_names": [], "method_name": "Enums.getIfPresent", "method_implementation": "{\n    checkNotNull(enumClass);\n    checkNotNull(value);\n    return Platform.getEnumIfPresent(enumClass, value);\n}", "repo_id": "5", "comment": "/**\n * Returns an optional enum constant for the given type, using {@link Enum#valueOf}. If the\n * constant does not exist, {@link Optional#absent} is returned. A common use case is for parsing\n * user input or falling back to a default enum constant. For example, {@code\n * Enums.getIfPresent(Country.class, countryInput).or(Country.DEFAULT);}\n *\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5125, "method_signature": "Optional<T> getIfPresent(Class, String)", "filename": "Enums.getIfPresent.json"}
{"callee_method_names": ["int.name", "Set<Object>.add", "Optional<TestEnum>.get", "Class<TestEnum>.getEnumConstants"], "method_name": "EnumsTest.doTestClassUnloading", "method_implementation": "{\n    URLClassLoader shadowLoader = new URLClassLoader(getClassPathUrls(), null);\n    @SuppressWarnings(\"unchecked\")\n    Class<TestEnum> shadowTestEnum = (Class<TestEnum>) Class.forName(TestEnum.class.getName(), false, shadowLoader);\n    assertNotSame(shadowTestEnum, TestEnum.class);\n    // We can't write Set<TestEnum> because that is a Set of the TestEnum from the original\n    // ClassLoader.\n    Set<Object> shadowConstants = new HashSet<>();\n    for (TestEnum constant : TestEnum.values()) {\n        Optional<TestEnum> result = Enums.getIfPresent(shadowTestEnum, constant.name());\n        assertThat(result).isPresent();\n        shadowConstants.add(result.get());\n    }\n    assertEquals(ImmutableSet.<Object>copyOf(shadowTestEnum.getEnumConstants()), shadowConstants);\n    Optional<TestEnum> result = Enums.getIfPresent(shadowTestEnum, \"blibby\");\n    assertThat(result).isAbsent();\n    return new WeakReference<>(shadowLoader);\n}", "repo_id": "5", "comment": "// cleared.\n", "repo_name": "guava-master/", "id": 3697, "method_signature": "WeakReference<?> doTestClassUnloading()", "filename": "EnumsTest.doTestClassUnloading.json"}
{"callee_method_names": ["ImmutableList.Builder<URL>.add", "ImmutableList.Builder<URL>.add", "AssertionError.initCause", "ImmutableList.Builder<URL>.build"], "method_name": "EnumsTest.parseJavaClassPath", "method_implementation": "{\n    ImmutableList.Builder<URL> urls = ImmutableList.builder();\n    for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n        try {\n            try {\n                urls.add(new File(entry).toURI().toURL());\n            } catch (SecurityException e) {\n                // File.toURI checks to see if the file is a directory\n                urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n            }\n        } catch (MalformedURLException e) {\n            AssertionError error = new AssertionError(\"malformed class path entry: \" + entry);\n            error.initCause(e);\n            throw error;\n        }\n    }\n    return urls.build();\n}", "repo_id": "5", "comment": "// TODO(b/65488446): Make this a public API.\n", "repo_name": "guava-master/", "id": 3698, "method_signature": "ImmutableList<URL> parseJavaClassPath()", "filename": "EnumsTest.parseJavaClassPath.json"}
{"callee_method_names": ["List<Object>.add", "List<List<Object>>.add"], "method_name": "EqualsTester.addEqualityGroup", "method_implementation": "{\n    checkNotNull(equalityGroup);\n    List<Object> list = new ArrayList<>(equalityGroup.length);\n    for (int i = 0; i < equalityGroup.length; i++) {\n        Object element = equalityGroup[i];\n        if (element == null) {\n            throw new NullPointerException(\"at index \" + i);\n        }\n        list.add(element);\n    }\n    equalityGroups.add(list);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code equalityGroup} with objects that are supposed to be equal to each other and not\n * equal to any other equality groups added to this tester.\n *\n * <p>The {@code @Nullable} annotations on the {@code equalityGroup} parameter imply that the\n * objects, and the array itself, can be null. That is for programmer convenience, when the\n * objects come from factory methods that are themselves {@code @Nullable}. In reality neither the\n * array nor its contents can be null, but it is not useful to force the use of {@code\n * requireNonNull} or the like just to assert that.\n *\n * <p>{@code EqualsTester} will always check that every object it is given returns false from\n * {@code equals(null)}, so it is neither useful nor allowed to include a null value in any\n * equality group.\n */\n", "repo_name": "guava-master/", "id": 4083, "method_signature": "EqualsTester addEqualityGroup(Object[])", "filename": "EqualsTester.addEqualityGroup.json"}
{"callee_method_names": ["RelationshipTester<Object>.addRelatedGroup", "RelationshipTester<Object>.test"], "method_name": "EqualsTester.testEquals", "method_implementation": "{\n    RelationshipTester<Object> delegate = new RelationshipTester<>(Equivalence.equals(), \"Object#equals\", \"Object#hashCode\", itemReporter);\n    for (List<Object> group : equalityGroups) {\n        delegate.addRelatedGroup(group);\n    }\n    for (int run = 0; run < REPETITIONS; run++) {\n        testItems();\n        delegate.test();\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Run tests on equals method, throwing a failure on an invalid test\n */\n", "repo_name": "guava-master/", "id": 4084, "method_signature": "EqualsTester testEquals()", "filename": "EqualsTester.testEquals.json"}
{"callee_method_ids": [4083, 4084], "callee_method_names": ["EqualsTester.addEqualityGroup", "EqualsTester.testEquals"], "method_name": "EqualsTesterTest.testAddEqualObjectWithOArgConstructor", "method_implementation": "{\n    equalsTester.addEqualityGroup(equalObject1, notEqualObject1);\n    try {\n        equalsTester.testEquals();\n    } catch (AssertionFailedError e) {\n        assertErrorMessage(e, equalObject1 + \" [group 1, item 1] must be Object#equals to \" + notEqualObject1 + \" [group 1, item 2]\");\n        return;\n    }\n    fail(\"Should get not equal to equal object error\");\n}", "repo_id": "5", "comment": "/**\n * Test adding objects only by addEqualityGroup, with no reference object specified in the\n * constructor.\n */\n", "repo_name": "guava-master/", "id": 4243, "method_signature": "void testAddEqualObjectWithOArgConstructor()", "filename": "EqualsTesterTest.testAddEqualObjectWithOArgConstructor.json"}
{"callee_method_ids": [4083], "callee_method_names": ["EqualsTester.addEqualityGroup"], "method_name": "EqualsTesterTest.testAddNullEqualObject", "method_implementation": "{\n    try {\n        equalsTester.addEqualityGroup(reference, (Object[]) null);\n        fail(\"Should fail on null equal object\");\n    } catch (NullPointerException e) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Test adding null equal object yields error\n */\n", "repo_name": "guava-master/", "id": 4242, "method_signature": "void testAddNullEqualObject()", "filename": "EqualsTesterTest.testAddNullEqualObject.json"}
{"callee_method_ids": [4083], "callee_method_names": ["EqualsTester.addEqualityGroup"], "method_name": "EqualsTesterTest.testAddNullReference", "method_implementation": "{\n    try {\n        equalsTester.addEqualityGroup((Object) null);\n        fail(\"Should fail on null reference\");\n    } catch (NullPointerException e) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Test null reference yields error\n */\n", "repo_name": "guava-master/", "id": 4240, "method_signature": "void testAddNullReference()", "filename": "EqualsTesterTest.testAddNullReference.json"}
{"callee_method_ids": [4083], "callee_method_names": ["EqualsTester.addEqualityGroup"], "method_name": "EqualsTesterTest.testAddTwoEqualObjectsAtOnceWithNull", "method_implementation": "{\n    try {\n        equalsTester.addEqualityGroup(reference, equalObject1, null);\n        fail(\"Should fail on null equal object\");\n    } catch (NullPointerException e) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Test equalObjects after adding multiple instances at once with a null\n */\n", "repo_name": "guava-master/", "id": 4241, "method_signature": "void testAddTwoEqualObjectsAtOnceWithNull()", "filename": "EqualsTesterTest.testAddTwoEqualObjectsAtOnceWithNull.json"}
{"callee_method_ids": [4083, 4084], "callee_method_names": ["EqualsTester.addEqualityGroup", "EqualsTester.testEquals"], "method_name": "EqualsTesterTest.testInvalidEqualsIncompatibleClass", "method_implementation": "{\n    Object obj = new InvalidEqualsIncompatibleClassObject();\n    equalsTester.addEqualityGroup(obj);\n    try {\n        equalsTester.testEquals();\n    } catch (AssertionFailedError e) {\n        assertErrorMessage(e, obj + \" must not be Object#equals to an arbitrary object of another class\");\n        return;\n    }\n    fail(\"Should get equal to incompatible class error\");\n}", "repo_id": "5", "comment": "/**\n * Test proper handling where an object incorrectly tests for an incompatible class\n */\n", "repo_name": "guava-master/", "id": 4246, "method_signature": "void testInvalidEqualsIncompatibleClass()", "filename": "EqualsTesterTest.testInvalidEqualsIncompatibleClass.json"}
{"callee_method_ids": [4083, 4084], "callee_method_names": ["EqualsTester.addEqualityGroup", "EqualsTester.testEquals"], "method_name": "EqualsTesterTest.testInvalidEqualsNull", "method_implementation": "{\n    Object obj = new InvalidEqualsNullObject();\n    equalsTester.addEqualityGroup(obj);\n    try {\n        equalsTester.testEquals();\n    } catch (AssertionFailedError e) {\n        assertErrorMessage(e, obj + \" must not be Object#equals to null\");\n        return;\n    }\n    fail(\"Should get equal to null error\");\n}", "repo_id": "5", "comment": "/**\n * Test proper handling where an object tests equal to null\n */\n", "repo_name": "guava-master/", "id": 4245, "method_signature": "void testInvalidEqualsNull()", "filename": "EqualsTesterTest.testInvalidEqualsNull.json"}
{"callee_method_ids": [4083, 4084], "callee_method_names": ["EqualsTester.addEqualityGroup", "EqualsTester.testEquals", "Object.hashCode", "Object.hashCode"], "method_name": "EqualsTesterTest.testInvalidHashCode", "method_implementation": "{\n    Object a = new InvalidHashCodeObject(1, 2);\n    Object b = new InvalidHashCodeObject(1, 2);\n    equalsTester.addEqualityGroup(a, b);\n    try {\n        equalsTester.testEquals();\n    } catch (AssertionFailedError e) {\n        assertErrorMessage(e, \"the Object#hashCode (\" + a.hashCode() + \") of \" + a + \" [group 1, item 1] must be equal to the Object#hashCode (\" + b.hashCode() + \") of \" + b);\n        return;\n    }\n    fail(\"Should get invalid hashCode error\");\n}", "repo_id": "5", "comment": "/**\n * Test for an invalid hashCode method, i.e., one that returns different value for objects that\n * are equal according to the equals method\n */\n", "repo_name": "guava-master/", "id": 4248, "method_signature": "void testInvalidHashCode()", "filename": "EqualsTesterTest.testInvalidHashCode.json"}
{"callee_method_ids": [4083, 4084], "callee_method_names": ["EqualsTester.addEqualityGroup", "EqualsTester.testEquals"], "method_name": "EqualsTesterTest.testInvalidNotEqualsEqualObject", "method_implementation": "{\n    equalsTester.addEqualityGroup(reference, notEqualObject1);\n    try {\n        equalsTester.testEquals();\n    } catch (AssertionFailedError e) {\n        assertErrorMessage(e, reference + \" [group 1, item 1]\");\n        assertErrorMessage(e, notEqualObject1 + \" [group 1, item 2]\");\n        return;\n    }\n    fail(\"Should get not equal to equal object error\");\n}", "repo_id": "5", "comment": "/**\n * Test proper handling where an object is not equal to one the user has said should be equal\n */\n", "repo_name": "guava-master/", "id": 4247, "method_signature": "void testInvalidNotEqualsEqualObject()", "filename": "EqualsTesterTest.testInvalidNotEqualsEqualObject.json"}
{"callee_method_ids": [4083, 4084], "callee_method_names": ["EqualsTester.addEqualityGroup", "EqualsTester.testEquals"], "method_name": "EqualsTesterTest.testNonReflexiveEquals", "method_implementation": "{\n    Object obj = new NonReflexiveObject();\n    equalsTester.addEqualityGroup(obj);\n    try {\n        equalsTester.testEquals();\n    } catch (AssertionFailedError e) {\n        assertErrorMessage(e, obj + \" must be Object#equals to itself\");\n        return;\n    }\n    fail(\"Should get non-reflexive error\");\n}", "repo_id": "5", "comment": "/**\n * Test proper handling of case where an object is not equal to itself\n */\n", "repo_name": "guava-master/", "id": 4244, "method_signature": "void testNonReflexiveEquals()", "filename": "EqualsTesterTest.testNonReflexiveEquals.json"}
{"callee_method_names": ["Equivalence<Object>.equivalent"], "method_name": "Equivalence.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof Wrapper) {\n        // note: not necessarily a Wrapper<T>\n        Wrapper<?> that = (Wrapper<?>) obj;\n        if (this.equivalence.equals(that.equivalence)) {\n            /*\n           * We'll accept that as sufficient \"proof\" that either equivalence should be able to\n           * handle either reference, so it's safe to circumvent compile-time type checking.\n           */\n            @SuppressWarnings(\"unchecked\")\n            Equivalence<Object> equivalence = (Equivalence<Object>) this.equivalence;\n            return equivalence.equivalent(this.reference, that.reference);\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@link Equivalence#equivalent(Object, Object)} applied to the wrapped\n * references is {@code true} and both wrappers use the {@link Object#equals(Object) same}\n * equivalence.\n */\n", "repo_name": "guava-master/", "id": 5159, "method_signature": "boolean equals(Object)", "filename": "Equivalence.equals.json"}
{"callee_method_names": [], "method_name": "Equivalence.equivalent", "method_implementation": "{\n    if (a == b) {\n        return true;\n    }\n    if (a == null || b == null) {\n        return false;\n    }\n    return doEquivalent(a, b);\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if the given objects are considered equivalent.\n *\n * <p>This method describes an <i>equivalence relation</i> on object references, meaning that for\n * all references {@code x}, {@code y}, and {@code z} (any of which may be null):\n *\n * <ul>\n *   <li>{@code equivalent(x, x)} is true (<i>reflexive</i> property)\n *   <li>{@code equivalent(x, y)} and {@code equivalent(y, x)} each return the same result\n *       (<i>symmetric</i> property)\n *   <li>If {@code equivalent(x, y)} and {@code equivalent(y, z)} are both true, then {@code\n *       equivalent(x, z)} is also true (<i>transitive</i> property)\n * </ul>\n *\n * <p>Note that all calls to {@code equivalent(x, y)} are expected to return the same result as\n * long as neither {@code x} nor {@code y} is modified.\n */\n", "repo_name": "guava-master/", "id": 5157, "method_signature": "boolean equivalent(T, T)", "filename": "Equivalence.equivalent.json"}
{"callee_method_names": [], "method_name": "Equivalence.hash", "method_implementation": "{\n    if (t == null) {\n        return 0;\n    }\n    return doHash(t);\n}", "repo_id": "5", "comment": "/**\n * Returns a hash code for {@code t}.\n *\n * <p>The {@code hash} has the following properties:\n *\n * <ul>\n *   <li>It is <i>consistent</i>: for any reference {@code x}, multiple invocations of {@code\n *       hash(x}} consistently return the same value provided {@code x} remains unchanged\n *       according to the definition of the equivalence. The hash need not remain consistent from\n *       one execution of an application to another execution of the same application.\n *   <li>It is <i>distributable across equivalence</i>: for any references {@code x} and {@code\n *       y}, if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i>\n *       necessary that the hash be distributable across <i>inequivalence</i>. If {@code\n *       equivalence(x, y)} is false, {@code hash(x) == hash(y)} may still be true.\n *   <li>{@code hash(null)} is {@code 0}.\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 5158, "method_signature": "int hash(T)", "filename": "Equivalence.hash.json"}
{"callee_method_names": [], "method_name": "Equivalence.pairwise", "method_implementation": "{\n    // Ideally, the returned equivalence would support Iterable<? extends T>. However,\n    // the need for this is so rare that it's not worth making callers deal with the ugly wildcard.\n    return new PairwiseEquivalence<>(this);\n}", "repo_id": "5", "comment": "/**\n * Returns an equivalence over iterables based on the equivalence of their elements. More\n * specifically, two iterables are considered equivalent if they both contain the same number of\n * elements, and each pair of corresponding elements is equivalent according to {@code this}. Null\n * iterables are equivalent to one another.\n *\n * <p>Note that this method performs a similar function for equivalences as {@link\n * com.google.common.collect.Ordering#lexicographical} does for orderings.\n *\n * <p>The returned object is serializable if this object is serializable.\n *\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5160, "method_signature": "Equivalence<Iterable<S>> pairwise()", "filename": "Equivalence.pairwise.json"}
{"callee_method_names": [], "method_name": "Equivalence.test", "method_implementation": "{\n    return equivalent(t, u);\n}", "repo_id": "5", "comment": "/**\n * @deprecated Provided only to satisfy the {@link BiPredicate} interface; use {@link #equivalent}\n *     instead.\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 1751, "method_signature": "boolean test(T, T)", "filename": "Equivalence.test.json"}
{"callee_method_names": [], "method_name": "EquivalenceTester.addEquivalenceGroup", "method_implementation": "{\n    addEquivalenceGroup(Lists.asList(first, rest));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds a group of objects that are supposed to be equivalent to each other and not equivalent to\n * objects in any other equivalence group added to this tester.\n */\n", "repo_name": "guava-master/", "id": 4141, "method_signature": "EquivalenceTester<T> addEquivalenceGroup(T, T[])", "filename": "EquivalenceTester.addEquivalenceGroup.json"}
{"callee_method_names": ["RelationshipTester<T>.test"], "method_name": "EquivalenceTester.test", "method_implementation": "{\n    for (int run = 0; run < REPETITIONS; run++) {\n        testItems();\n        delegate.test();\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Run tests on equivalence methods, throwing a failure on an invalid test\n */\n", "repo_name": "guava-master/", "id": 4142, "method_signature": "EquivalenceTester<T> test()", "filename": "EquivalenceTester.test.json"}
{"callee_method_names": [], "method_name": "EquivalenceTesterTest.testOf_NullPointerException", "method_implementation": "{\n    try {\n        EquivalenceTester.of(null);\n        fail(\"Should fail on null reference\");\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Test null reference yields error\n */\n", "repo_name": "guava-master/", "id": 4238, "method_signature": "void testOf_NullPointerException()", "filename": "EquivalenceTesterTest.testOf_NullPointerException.json"}
{"callee_method_names": ["Escaper.escape", "Escaper.escape"], "method_name": "EscaperAsserts.assertBasic", "method_implementation": "{\n    // Escapers operate on characters: no characters, no escaping.\n    Assert.assertEquals(\"\", escaper.escape(\"\"));\n    // Assert that escapers throw null pointer exceptions.\n    try {\n        escaper.escape((String) null);\n        Assert.fail(\"exception not thrown when escaping a null string\");\n    } catch (NullPointerException e) {\n        // pass\n    }\n}", "repo_id": "5", "comment": "/**\n * Asserts that an escaper behaves correctly with respect to null inputs.\n *\n * @param escaper the non-null escaper to test\n */\n", "repo_name": "guava-master/", "id": 4079, "method_signature": "void assertBasic(Escaper)", "filename": "EscaperAsserts.assertBasic.json"}
{"callee_method_names": [], "method_name": "EscaperAsserts.assertEscaping", "method_implementation": "{\n    String escaped = computeReplacement(escaper, cp);\n    Assert.assertNotNull(escaped);\n    Assert.assertEquals(expected, escaped);\n}", "repo_id": "5", "comment": "/**\n * Asserts that a Unicode escaper escapes the given code point into the expected string.\n *\n * @param escaper the non-null escaper to test\n * @param expected the expected output string\n * @param cp the Unicode code point to escape\n */\n", "repo_name": "guava-master/", "id": 4081, "method_signature": "void assertEscaping(UnicodeEscaper, String, int)", "filename": "EscaperAsserts.assertEscaping.json"}
{"callee_method_names": [], "method_name": "EscaperAsserts.assertUnicodeEscaping", "method_implementation": "{\n    int cp = Character.toCodePoint(hi, lo);\n    String escaped = computeReplacement(escaper, cp);\n    Assert.assertNotNull(escaped);\n    Assert.assertEquals(expected, escaped);\n}", "repo_id": "5", "comment": "/**\n * Asserts that a Unicode escaper escapes the given hi/lo surrogate pair into the expected string.\n *\n * @param escaper the non-null escaper to test\n * @param expected the expected output string\n * @param hi the high surrogate pair character\n * @param lo the low surrogate pair character\n */\n", "repo_name": "guava-master/", "id": 4082, "method_signature": "void assertUnicodeEscaping(UnicodeEscaper, String, char, char)", "filename": "EscaperAsserts.assertUnicodeEscaping.json"}
{"callee_method_names": ["HashMap.put"], "method_name": "Escapers.addEscape", "method_implementation": "{\n    checkNotNull(replacement);\n    // This can replace an existing character (the builder is re-usable).\n    replacementMap.put(c, replacement);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds a replacement string for the given input character. The specified character will be\n * replaced by the given string whenever it occurs in the input, irrespective of whether it lies\n * inside or outside the 'safe' range.\n *\n * @param c the character to be replaced\n * @param replacement the string to replace the given character\n * @return the builder instance\n * @throws NullPointerException if {@code replacement} is null\n */\n", "repo_name": "guava-master/", "id": 4273, "method_signature": "Builder addEscape(char, String)", "filename": "Escapers.addEscape.json"}
{"callee_method_names": ["Escaper.getClass"], "method_name": "Escapers.asUnicodeEscaper", "method_implementation": "{\n    checkNotNull(escaper);\n    if (escaper instanceof UnicodeEscaper) {\n        return (UnicodeEscaper) escaper;\n    } else if (escaper instanceof CharEscaper) {\n        return wrap((CharEscaper) escaper);\n    }\n    // In practice this shouldn't happen because it would be very odd not to\n    // extend either CharEscaper or UnicodeEscaper for non-trivial cases.\n    throw new IllegalArgumentException(\"Cannot create a UnicodeEscaper from: \" + escaper.getClass().getName());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link UnicodeEscaper} equivalent to the given escaper instance. If the escaper is\n * already a UnicodeEscaper then it is simply returned, otherwise it is wrapped in a\n * UnicodeEscaper.\n *\n * <p>When a {@link CharEscaper} escaper is wrapped by this method it acquires extra behavior with\n * respect to the well-formedness of Unicode character sequences and will throw {@link\n * IllegalArgumentException} when given bad input.\n *\n * @param escaper the instance to be wrapped\n * @return a UnicodeEscaper with the same behavior as the given instance\n * @throws NullPointerException if escaper is null\n * @throws IllegalArgumentException if escaper is not a UnicodeEscaper or a CharEscaper\n */\n", "repo_name": "guava-master/", "id": 4275, "method_signature": "UnicodeEscaper asUnicodeEscaper(Escaper)", "filename": "Escapers.asUnicodeEscaper.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "Escapers.build", "method_implementation": "{\n    return new ArrayBasedCharEscaper(replacementMap, safeMin, safeMax) {\n\n        @CheckForNull\n        private final char[] replacementChars = unsafeReplacement != null ? unsafeReplacement.toCharArray() : null;\n\n        @Override\n        @CheckForNull\n        protected char[] escapeUnsafe(char c) {\n            return replacementChars;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a new escaper based on the current state of the builder.\n */\n", "repo_name": "guava-master/", "id": 4274, "method_signature": "Escaper build()", "filename": "Escapers.build.json"}
{"callee_method_names": [], "method_name": "Escapers.setSafeRange", "method_implementation": "{\n    this.safeMin = safeMin;\n    this.safeMax = safeMax;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the safe range of characters for the escaper. Characters in this range that have no\n * explicit replacement are considered 'safe' and remain unescaped in the output. If {@code\n * safeMax < safeMin} then the safe range is empty.\n *\n * @param safeMin the lowest 'safe' character\n * @param safeMax the highest 'safe' character\n * @return the builder instance\n */\n", "repo_name": "guava-master/", "id": 4271, "method_signature": "Builder setSafeRange(char, char)", "filename": "Escapers.setSafeRange.json"}
{"callee_method_names": [], "method_name": "Escapers.setUnsafeReplacement", "method_implementation": "{\n    this.unsafeReplacement = unsafeReplacement;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the replacement string for any characters outside the 'safe' range that have no explicit\n * replacement. If {@code unsafeReplacement} is {@code null} then no replacement will occur, if\n * it is {@code \"\"} then the unsafe characters are removed from the output.\n *\n * @param unsafeReplacement the string to replace unsafe characters\n * @return the builder instance\n */\n", "repo_name": "guava-master/", "id": 4272, "method_signature": "Builder setUnsafeReplacement(String)", "filename": "Escapers.setUnsafeReplacement.json"}
{"callee_method_ids": [4258, 4258, 4258], "callee_method_names": ["CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape"], "method_name": "Escapers.wrap", "method_implementation": "{\n    return new UnicodeEscaper() {\n\n        @Override\n        @CheckForNull\n        protected char[] escape(int cp) {\n            // If a code point maps to a single character, just escape that.\n            if (cp < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                return escaper.escape((char) cp);\n            }\n            // Convert the code point to a surrogate pair and escape them both.\n            // Note: This code path is horribly slow and typically allocates 4 new\n            // char[] each time it is invoked. However this avoids any\n            // synchronization issues and makes the escaper thread safe.\n            char[] surrogateChars = new char[2];\n            Character.toChars(cp, surrogateChars, 0);\n            char[] hiChars = escaper.escape(surrogateChars[0]);\n            char[] loChars = escaper.escape(surrogateChars[1]);\n            // If either hiChars or lowChars are non-null, the CharEscaper is trying\n            // to escape the characters of a surrogate pair separately. This is\n            // uncommon and applies only to escapers that assume UCS-2 rather than\n            // UTF-16. See: http://en.wikipedia.org/wiki/UTF-16/UCS-2\n            if (hiChars == null && loChars == null) {\n                // We expect this to be the common code path for most escapers.\n                return null;\n            }\n            // Combine the characters and/or escaped sequences into a single array.\n            int hiCount = hiChars != null ? hiChars.length : 1;\n            int loCount = loChars != null ? loChars.length : 1;\n            char[] output = new char[hiCount + loCount];\n            if (hiChars != null) {\n                // TODO: Is this faster than System.arraycopy() for small arrays?\n                for (int n = 0; n < hiChars.length; ++n) {\n                    output[n] = hiChars[n];\n                }\n            } else {\n                output[0] = surrogateChars[0];\n            }\n            if (loChars != null) {\n                for (int n = 0; n < loChars.length; ++n) {\n                    output[hiCount + n] = loChars[n];\n                }\n            } else {\n                output[hiCount] = surrogateChars[1];\n            }\n            return output;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Private helper to wrap a CharEscaper as a UnicodeEscaper.\n */\n", "repo_name": "guava-master/", "id": 4276, "method_signature": "UnicodeEscaper wrap(CharEscaper)", "filename": "Escapers.wrap.json"}
{"callee_method_names": ["ImmutableMap<Character,char[]>.get"], "method_name": "EscapersTest.createSimpleCharEscaper", "method_implementation": "{\n    return new CharEscaper() {\n\n        @Override\n        protected char[] escape(char c) {\n            return replacementMap.get(c);\n        }\n    };\n}", "repo_id": "5", "comment": "// A trivial non-optimized escaper for testing.\n", "repo_name": "guava-master/", "id": 3544, "method_signature": "CharEscaper createSimpleCharEscaper(ImmutableMap)", "filename": "EscapersTest.createSimpleCharEscaper.json"}
{"callee_method_names": ["ImmutableMap<Integer,char[]>.get"], "method_name": "EscapersTest.createSimpleUnicodeEscaper", "method_implementation": "{\n    return new UnicodeEscaper() {\n\n        @Override\n        protected char[] escape(int cp) {\n            return replacementMap.get(cp);\n        }\n    };\n}", "repo_id": "5", "comment": "// A trivial non-optimized escaper for testing.\n", "repo_name": "guava-master/", "id": 3545, "method_signature": "UnicodeEscaper createSimpleUnicodeEscaper(ImmutableMap)", "filename": "EscapersTest.createSimpleUnicodeEscaper.json"}
{"callee_method_names": ["SubscriberExceptionHandler.handleException", "Logger.log"], "method_name": "EventBus.handleSubscriberException", "method_implementation": "{\n    checkNotNull(e);\n    checkNotNull(context);\n    try {\n        exceptionHandler.handleException(e, context);\n    } catch (Throwable e2) {\n        // if the handler threw an exception... well, just log it\n        logger.log(Level.SEVERE, String.format(Locale.ROOT, \"Exception %s thrown while handling exception: %s\", e2, e), e2);\n    }\n}", "repo_id": "5", "comment": "/**\n * Handles the given exception thrown by a subscriber with the given context.\n */\n", "repo_name": "guava-master/", "id": 6807, "method_signature": "void handleSubscriberException(Throwable, SubscriberExceptionContext)", "filename": "EventBus.handleSubscriberException.json"}
{"callee_method_ids": [6803], "callee_method_names": ["SubscriberRegistry.getSubscribers", "Iterator<Subscriber>.hasNext", "Dispatcher.dispatch"], "method_name": "EventBus.post", "method_implementation": "{\n    Iterator<Subscriber> eventSubscribers = subscribers.getSubscribers(event);\n    if (eventSubscribers.hasNext()) {\n        dispatcher.dispatch(event, eventSubscribers);\n    } else if (!(event instanceof DeadEvent)) {\n        // the event had no subscribers and was not itself a DeadEvent\n        post(new DeadEvent(this, event));\n    }\n}", "repo_id": "5", "comment": "/**\n * Posts an event to all registered subscribers. This method will return successfully after the\n * event has been posted to all subscribers, and regardless of any exceptions thrown by\n * subscribers.\n *\n * <p>If no subscribers have been subscribed for {@code event}'s class, and {@code event} is not\n * already a {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.\n *\n * @param event event to post.\n */\n", "repo_name": "guava-master/", "id": 6808, "method_signature": "void post(Object)", "filename": "EventBus.post.json"}
{"callee_method_ids": [6808, 6808, 6808], "callee_method_names": ["List<Object>.add", "List<Comparable<?>>.add", "EventBus.register", "EventBus.register", "EventBus.register", "EventBus.post", "EventBus.post", "EventBus.post", "StringCatcher.getEvents", "List<String>.size", "List<String>.get", "List<Object>.size", "List<Object>.get", "List<Object>.get", "List<Object>.get", "List<Comparable<?>>.size", "List<Comparable<?>>.get", "List<Comparable<?>>.get"], "method_name": "EventBusTest.testPolymorphicDistribution", "method_implementation": "{\n    // Three catchers for related types String, Object, and Comparable<?>.\n    // String isa Object\n    // String isa Comparable<?>\n    // Comparable<?> isa Object\n    StringCatcher stringCatcher = new StringCatcher();\n    final List<Object> objectEvents = Lists.newArrayList();\n    Object objCatcher = new Object() {\n\n        @SuppressWarnings(\"unused\")\n        @Subscribe\n        public void eat(Object food) {\n            objectEvents.add(food);\n        }\n    };\n    final List<Comparable<?>> compEvents = Lists.newArrayList();\n    Object compCatcher = new Object() {\n\n        @SuppressWarnings(\"unused\")\n        @Subscribe\n        public void eat(Comparable<?> food) {\n            compEvents.add(food);\n        }\n    };\n    bus.register(stringCatcher);\n    bus.register(objCatcher);\n    bus.register(compCatcher);\n    // Two additional event types: Object and Comparable<?> (played by Integer)\n    Object objEvent = new Object();\n    Object compEvent = new Integer(6);\n    bus.post(EVENT);\n    bus.post(objEvent);\n    bus.post(compEvent);\n    // Check the StringCatcher...\n    List<String> stringEvents = stringCatcher.getEvents();\n    assertEquals(\"Only one String should be delivered.\", 1, stringEvents.size());\n    assertEquals(\"Correct string should be delivered.\", EVENT, stringEvents.get(0));\n    // Check the Catcher<Object>...\n    assertEquals(\"Three Objects should be delivered.\", 3, objectEvents.size());\n    assertEquals(\"String fixture must be first object delivered.\", EVENT, objectEvents.get(0));\n    assertEquals(\"Object fixture must be second object delivered.\", objEvent, objectEvents.get(1));\n    assertEquals(\"Comparable fixture must be thirdobject delivered.\", compEvent, objectEvents.get(2));\n    // Check the Catcher<Comparable<?>>...\n    assertEquals(\"Two Comparable<?>s should be delivered.\", 2, compEvents.size());\n    assertEquals(\"String fixture must be first comparable delivered.\", EVENT, compEvents.get(0));\n    assertEquals(\"Comparable fixture must be second comparable delivered.\", compEvent, compEvents.get(1));\n}", "repo_id": "5", "comment": "/**\n * Tests that events are distributed to any subscribers to their type or any supertype, including\n * interfaces and superclasses.\n *\n * <p>Also checks delivery ordering in such cases.\n */\n", "repo_name": "guava-master/", "id": 4076, "method_signature": "void testPolymorphicDistribution()", "filename": "EventBusTest.testPolymorphicDistribution.json"}
{"callee_method_ids": [6808], "callee_method_names": ["List<Future<?>>.add", "ExecutorService.submit", "List<Future<?>>.get", "List<StringCatcher>.size", "EventBus.post"], "method_name": "EventBusTest.testRegisterThreadSafety", "method_implementation": "{\n    List<StringCatcher> catchers = Lists.newCopyOnWriteArrayList();\n    List<Future<?>> futures = Lists.newArrayList();\n    ExecutorService executor = Executors.newFixedThreadPool(10);\n    int numberOfCatchers = 10000;\n    for (int i = 0; i < numberOfCatchers; i++) {\n        futures.add(executor.submit(new Registrator(bus, catchers)));\n    }\n    for (int i = 0; i < numberOfCatchers; i++) {\n        futures.get(i).get();\n    }\n    assertEquals(\"Unexpected number of catchers in the list\", numberOfCatchers, catchers.size());\n    bus.post(EVENT);\n    List<String> expectedEvents = ImmutableList.of(EVENT);\n    for (StringCatcher catcher : catchers) {\n        assertEquals(\"One of the registered catchers did not receive an event.\", expectedEvents, catcher.getEvents());\n    }\n}", "repo_id": "5", "comment": "// pass if it isn't, though this is unlikely.\n", "repo_name": "guava-master/", "id": 4077, "method_signature": "void testRegisterThreadSafety()", "filename": "EventBusTest.testRegisterThreadSafety.json"}
{"callee_method_ids": [6808], "callee_method_names": ["EventBus.register", "AtomicInteger.incrementAndGet", "EventBus.post", "AtomicInteger.get"], "method_name": "EventBusTest.testRegistrationWithBridgeMethod", "method_implementation": "{\n    final AtomicInteger calls = new AtomicInteger();\n    bus.register(new Callback<String>() {\n\n        @Subscribe\n        @Override\n        public void call(String s) {\n            calls.incrementAndGet();\n        }\n    });\n    bus.post(\"hello\");\n    assertEquals(1, calls.get());\n}", "repo_id": "5", "comment": "/**\n * Tests that bridge methods are not subscribed to events. In Java 8, annotations are included on\n * the bridge method in addition to the original method, which causes both the original and bridge\n * methods to be subscribed (since both are annotated @Subscribe) without specifically checking\n * for bridge methods.\n */\n", "repo_name": "guava-master/", "id": 4078, "method_signature": "void testRegistrationWithBridgeMethod()", "filename": "EventBusTest.testRegistrationWithBridgeMethod.json"}
{"callee_method_names": ["Queue<E>.remove", "Queue<E>.add"], "method_name": "EvictingQueue.add", "method_implementation": "{\n    // check before removing\n    checkNotNull(e);\n    if (maxSize == 0) {\n        return true;\n    }\n    if (size() == maxSize) {\n        delegate.remove();\n    }\n    delegate.add(e);\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Adds the given element to this queue. If the queue is currently full, the element at the head\n * of the queue is evicted to make room.\n *\n * @return {@code true} always\n */\n", "repo_name": "guava-master/", "id": 6375, "method_signature": "boolean add(E)", "filename": "EvictingQueue.add.json"}
{"callee_method_names": [], "method_name": "EvictingQueue.offer", "method_implementation": "{\n    return add(e);\n}", "repo_id": "5", "comment": "/**\n * Adds the given element to this queue. If the queue is currently full, the element at the head\n * of the queue is evicted to make room.\n *\n * @return {@code true} always\n */\n", "repo_name": "guava-master/", "id": 6374, "method_signature": "boolean offer(E)", "filename": "EvictingQueue.offer.json"}
{"callee_method_names": [], "method_name": "ExampleDerivedInterfaceTester.testRequiringAllThreeDerivedFeatures", "method_implementation": "{\n    doNotActuallyRunThis();\n}", "repo_id": "5", "comment": "// Exists to test that our framework doesn't run it:\n", "repo_name": "guava-master/", "id": 4254, "method_signature": "void testRequiringAllThreeDerivedFeatures()", "filename": "ExampleDerivedInterfaceTester.testRequiringAllThreeDerivedFeatures.json"}
{"callee_method_names": [], "method_name": "ExampleDerivedInterfaceTester.testRequiringConflictingFeatures", "method_implementation": "{\n    doNotActuallyRunThis();\n}", "repo_id": "5", "comment": "// Exists to test that our framework doesn't run it:\n", "repo_name": "guava-master/", "id": 4255, "method_signature": "void testRequiringConflictingFeatures()", "filename": "ExampleDerivedInterfaceTester.testRequiringConflictingFeatures.json"}
{"callee_method_names": [], "method_name": "ExampleDerivedInterfaceTester.testRequiringTwoExplicitDerivedFeatures", "method_implementation": "{\n    doNotActuallyRunThis();\n}", "repo_id": "5", "comment": "// Exists to test that our framework doesn't run it:\n", "repo_name": "guava-master/", "id": 4253, "method_signature": "void testRequiringTwoExplicitDerivedFeatures()", "filename": "ExampleDerivedInterfaceTester.testRequiringTwoExplicitDerivedFeatures.json"}
{"callee_method_names": [], "method_name": "ExecutionList.add", "method_implementation": "{\n    // Fail fast on a null. We throw NPE here because the contract of Executor states that it throws\n    // NPE on null listener, so we propagate that contract up into the add method as well.\n    checkNotNull(runnable, \"Runnable was null.\");\n    checkNotNull(executor, \"Executor was null.\");\n    // Lock while we check state. We must maintain the lock while adding the new pair so that\n    // another thread can't run the list out from under us. We only add to the list if we have not\n    // yet started execution.\n    synchronized (this) {\n        if (!executed) {\n            runnables = new RunnableExecutorPair(runnable, executor, runnables);\n            return;\n        }\n    }\n    // Execute the runnable immediately. Because of scheduling this may end up getting called before\n    // some of the previously added runnables, but we're OK with that. If we want to change the\n    // contract to guarantee ordering among runnables we'd have to modify the logic here to allow\n    // it.\n    executeListener(runnable, executor);\n}", "repo_id": "5", "comment": "/**\n * Adds the {@code Runnable} and accompanying {@code Executor} to the list of listeners to\n * execute. If execution has already begun, the listener is executed immediately.\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n * documentation.\n */\n", "repo_name": "guava-master/", "id": 5455, "method_signature": "void add(Runnable, Executor)", "filename": "ExecutionList.add.json"}
{"callee_method_names": [], "method_name": "ExecutionList.execute", "method_implementation": "{\n    // Lock while we update our state so the add method above will finish adding any listeners\n    // before we start to run them.\n    RunnableExecutorPair list;\n    synchronized (this) {\n        if (executed) {\n            return;\n        }\n        executed = true;\n        list = runnables;\n        // allow GC to free listeners even if this stays around for a while.\n        runnables = null;\n    }\n    // If we succeeded then list holds all the runnables we to execute. The pairs in the stack are\n    // in the opposite order from how they were added so we need to reverse the list to fulfill our\n    // contract.\n    // This is somewhat annoying, but turns out to be very fast in practice. Alternatively, we could\n    // drop the contract on the method that enforces this queue like behavior since depending on it\n    // is likely to be a bug anyway.\n    // N.B. All writes to the list and the next pointers must have happened before the above\n    // synchronized block, so we can iterate the list without the lock held here.\n    RunnableExecutorPair reversedList = null;\n    while (list != null) {\n        RunnableExecutorPair tmp = list;\n        list = list.next;\n        tmp.next = reversedList;\n        reversedList = tmp;\n    }\n    while (reversedList != null) {\n        executeListener(reversedList.runnable, reversedList.executor);\n        reversedList = reversedList.next;\n    }\n}", "repo_id": "5", "comment": "/**\n * Runs this execution list, executing all existing pairs in the order they were added. However,\n * note that listeners added after this point may be executed before those previously added, and\n * note that the execution order of all listeners is ultimately chosen by the implementations of\n * the supplied executors.\n *\n * <p>This method is idempotent. Calling it several times in parallel is semantically equivalent\n * to calling it exactly once.\n *\n * @since 10.0 (present in 1.0 as {@code run})\n */\n", "repo_name": "guava-master/", "id": 5456, "method_signature": "void execute()", "filename": "ExecutionList.execute.json"}
{"callee_method_names": ["Executor.execute", "LazyLogger.get"], "method_name": "ExecutionList.executeListener", "method_implementation": "{\n    try {\n        executor.execute(runnable);\n    } catch (Exception e) {\n        // sneaky checked exception\n        // Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if\n        // we're given a bad one. We only catch RuntimeException because we want Errors to propagate\n        // up.\n        log.get().log(Level.SEVERE, \"RuntimeException while executing runnable \" + runnable + \" with executor \" + executor, e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Submits the given runnable to the given {@link Executor} catching and logging all {@linkplain\n * RuntimeException runtime exceptions} thrown by the executor.\n */\n", "repo_name": "guava-master/", "id": 5457, "method_signature": "void executeListener(Runnable, Executor)", "filename": "ExecutionList.executeListener.json"}
{"callee_method_names": ["Class<sun.misc.Unsafe>.getDeclaredFields", "Future<T>.setAccessible", "Future<T>.get", "Class<sun.misc.Unsafe>.isInstance", "Class<sun.misc.Unsafe>.cast", "Throwable.getCause"], "method_name": "ExecutionListBenchmark.getUnsafe", "method_implementation": "{\n    try {\n        return sun.misc.Unsafe.getUnsafe();\n    } catch (SecurityException tryReflectionInstead) {\n    }\n    try {\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n\n            @Override\n            public sun.misc.Unsafe run() throws Exception {\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n                    f.setAccessible(true);\n                    Object x = f.get(null);\n                    if (k.isInstance(x))\n                        return k.cast(x);\n                }\n                throw new NoSuchFieldError(\"the Unsafe\");\n            }\n        });\n    } catch (java.security.PrivilegedActionException e) {\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * TODO(lukes): This was copied verbatim from Striped64.java... standardize this?\n */\n", "repo_name": "guava-master/", "id": 3489, "method_signature": "sun.misc.Unsafe getUnsafe()", "filename": "ExecutionListBenchmark.getUnsafe.json"}
{"callee_method_names": ["Class<sun.misc.Unsafe>.getDeclaredFields", "Future<T>.setAccessible", "Future<T>.get", "Class<sun.misc.Unsafe>.isInstance", "Class<sun.misc.Unsafe>.cast", "Throwable.getCause"], "method_name": "ExecutionListCAS.getUnsafe", "method_implementation": "{\n    try {\n        return sun.misc.Unsafe.getUnsafe();\n    } catch (SecurityException tryReflectionInstead) {\n    }\n    try {\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n\n            @Override\n            public sun.misc.Unsafe run() throws Exception {\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n                    f.setAccessible(true);\n                    Object x = f.get(null);\n                    if (k.isInstance(x))\n                        return k.cast(x);\n                }\n                throw new NoSuchFieldError(\"the Unsafe\");\n            }\n        });\n    } catch (java.security.PrivilegedActionException e) {\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * TODO(lukes): This was copied verbatim from Striped64.java... standardize this?\n */\n", "repo_name": "guava-master/", "id": 3490, "method_signature": "sun.misc.Unsafe getUnsafe()", "filename": "ExecutionListCAS.getUnsafe.json"}
{"callee_method_names": ["Callable<T>.call", "Callable<T>.toString"], "method_name": "ExecutionSequencer.submit", "method_implementation": "{\n    checkNotNull(callable);\n    checkNotNull(executor);\n    return submitAsync(new AsyncCallable<T>() {\n\n        @Override\n        public ListenableFuture<T> call() throws Exception {\n            return immediateFuture(callable.call());\n        }\n\n        @Override\n        public String toString() {\n            return callable.toString();\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Enqueues a task to run when the previous task (if any) completes.\n *\n * <p>Cancellation does not propagate from the output future to a callable that has begun to\n * execute, but if the output future is cancelled before {@link Callable#call()} is invoked,\n * {@link Callable#call()} will not be invoked.\n */\n", "repo_name": "guava-master/", "id": 5241, "method_signature": "ListenableFuture<T> submit(Callable, Executor)", "filename": "ExecutionSequencer.submit.json"}
{"callee_method_names": ["TaskNonReentrantExecutor.trySetStarted", "AsyncCallable<T>.call", "AsyncCallable<T>.toString", "AtomicReference.getAndSet", "ListenableFuture<@Nullable Void>.addListener", "TrustedListenableFutureTask<T>.isDone", "SettableFuture<@Nullable Void>.setFuture", "ListenableFuture<T>.isCancelled", "TaskNonReentrantExecutor.trySetCancelled", "TrustedListenableFutureTask<T>.cancel", "ListenableFuture<T>.addListener", "TrustedListenableFutureTask<T>.addListener"], "method_name": "ExecutionSequencer.submitAsync", "method_implementation": "{\n    checkNotNull(callable);\n    checkNotNull(executor);\n    TaskNonReentrantExecutor taskExecutor = new TaskNonReentrantExecutor(executor, this);\n    AsyncCallable<T> task = new AsyncCallable<T>() {\n\n        @Override\n        public ListenableFuture<T> call() throws Exception {\n            if (!taskExecutor.trySetStarted()) {\n                return immediateCancelledFuture();\n            }\n            return callable.call();\n        }\n\n        @Override\n        public String toString() {\n            return callable.toString();\n        }\n    };\n    /*\n     * Four futures are at play here:\n     * taskFuture is the future tracking the result of the callable.\n     * newFuture is a future that completes after this and all prior tasks are done.\n     * oldFuture is the previous task's newFuture.\n     * outputFuture is the future we return to the caller, a nonCancellationPropagating taskFuture.\n     *\n     * newFuture is guaranteed to only complete once all tasks previously submitted to this instance\n     * have completed - namely after oldFuture is done, and taskFuture has either completed or been\n     * cancelled before the callable started execution.\n     */\n    SettableFuture<@Nullable Void> newFuture = SettableFuture.create();\n    ListenableFuture<@Nullable Void> oldFuture = ref.getAndSet(newFuture);\n    // Invoke our task once the previous future completes.\n    TrustedListenableFutureTask<T> taskFuture = TrustedListenableFutureTask.create(task);\n    oldFuture.addListener(taskFuture, taskExecutor);\n    ListenableFuture<T> outputFuture = Futures.nonCancellationPropagating(taskFuture);\n    // newFuture's lifetime is determined by taskFuture, which can't complete before oldFuture\n    // unless taskFuture is cancelled, in which case it falls back to oldFuture. This ensures that\n    // if the future we return is cancelled, we don't begin execution of the next task until after\n    // oldFuture completes.\n    Runnable listener = () -> {\n        if (taskFuture.isDone()) {\n            // Since the value of oldFuture can only ever be immediateFuture(null) or setFuture of\n            // a future that eventually came from immediateFuture(null), this doesn't leak\n            // throwables or completion values.\n            newFuture.setFuture(oldFuture);\n        } else if (outputFuture.isCancelled() && taskExecutor.trySetCancelled()) {\n            // If this CAS succeeds, we know that the provided callable will never be invoked,\n            // so when oldFuture completes it is safe to allow the next submitted task to\n            // proceed. Doing this immediately here lets the next task run without waiting for\n            // the cancelled task's executor to run the noop AsyncCallable.\n            //\n            // ---\n            //\n            // If the CAS fails, the provided callable already started running (or it is about\n            // to). Our contract promises:\n            //\n            // 1. not to execute a new callable until the old one has returned\n            //\n            // If we were to cancel taskFuture, that would let the next task start while the old\n            // one is still running.\n            //\n            // Now, maybe we could tweak our implementation to not start the next task until the\n            // callable actually completes. (We could detect completion in our wrapper\n            // `AsyncCallable task`.) However, our contract also promises:\n            //\n            // 2. not to cancel any Future the user returned from an AsyncCallable\n            //\n            // We promise this because, once we cancel that Future, we would no longer be able to\n            // tell when any underlying work it is doing is done. Thus, we might start a new task\n            // while that underlying work is still running.\n            //\n            // So that is why we cancel only in the case of CAS success.\n            taskFuture.cancel(false);\n        }\n    };\n    // Adding the listener to both futures guarantees that newFuture will always be set. Adding to\n    // taskFuture guarantees completion if the callable is invoked, and adding to outputFuture\n    // propagates cancellation if the callable has not yet been invoked.\n    outputFuture.addListener(listener, directExecutor());\n    taskFuture.addListener(listener, directExecutor());\n    return outputFuture;\n}", "repo_id": "5", "comment": "/**\n * Enqueues a task to run when the previous task (if any) completes.\n *\n * <p>Cancellation does not propagate from the output future to the future returned from {@code\n * callable} or a callable that has begun to execute, but if the output future is cancelled before\n * {@link AsyncCallable#call()} is invoked, {@link AsyncCallable#call()} will not be invoked.\n */\n", "repo_name": "guava-master/", "id": 5242, "method_signature": "ListenableFuture<T> submitAsync(AsyncCallable, Executor)", "filename": "ExecutionSequencer.submitAsync.json"}
{"callee_method_names": [], "method_name": "FactoryMethodReturnValueTester.testEquals", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        try {\n            testEqualsUsing(factory);\n        } catch (FactoryMethodReturnsNullException e) {\n            // If the factory returns null, we just skip it.\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Tests {@link Object#equals} and {@link Object#hashCode} against the return values of the\n * static methods, by asserting that when equal parameters are passed to the same static method,\n * the return value should also be equal; and vice versa.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4103, "method_signature": "FactoryMethodReturnValueTester testEquals()", "filename": "FactoryMethodReturnValueTester.testEquals.json"}
{"callee_method_names": ["AssertionError.initCause", "UnicodeEscaper.getCause", "AssertionError.initCause"], "method_name": "FactoryMethodReturnValueTester.testEqualsAndSerializable", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        try {\n            testEqualsUsing(factory);\n        } catch (FactoryMethodReturnsNullException e) {\n            // If the factory returns null, we just skip it.\n        }\n        Object instance = instantiate(factory);\n        if (instance != null) {\n            try {\n                SerializableTester.reserializeAndAssert(instance);\n            } catch (Exception e) {\n                // sneaky checked exception\n                AssertionError error = new AssertionFailedError(\"Serialization failed on return value of \" + factory);\n                error.initCause(e.getCause());\n                throw error;\n            } catch (AssertionFailedError e) {\n                AssertionError error = new AssertionFailedError(\"Return value of \" + factory + \" reserialized to an unequal value\");\n                error.initCause(e);\n                throw error;\n            }\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Runs equals and serialization test on the return values.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4105, "method_signature": "FactoryMethodReturnValueTester testEqualsAndSerializable()", "filename": "FactoryMethodReturnValueTester.testEqualsAndSerializable.json"}
{"callee_method_names": ["Set<String>.contains", "Object.getClass", "NullPointerTester.testAllPublicInstanceMethods", "AssertionError.initCause"], "method_name": "FactoryMethodReturnValueTester.testNulls", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        Object instance = instantiate(factory);\n        if (instance != null && packagesToTest.contains(Reflection.getPackageName(instance.getClass()))) {\n            try {\n                nullPointerTester.testAllPublicInstanceMethods(instance);\n            } catch (AssertionError e) {\n                AssertionError error = new AssertionFailedError(\"Null check failed on return value of \" + factory);\n                error.initCause(e);\n                throw error;\n            }\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Tests null checks against the instance methods of the return values, if any.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4102, "method_signature": "FactoryMethodReturnValueTester testNulls()", "filename": "FactoryMethodReturnValueTester.testNulls.json"}
{"callee_method_names": ["AssertionError.initCause", "UnicodeEscaper.getCause"], "method_name": "FactoryMethodReturnValueTester.testSerializable", "method_implementation": "{\n    for (Invokable<?, ?> factory : getFactoriesToTest()) {\n        Object instance = instantiate(factory);\n        if (instance != null) {\n            try {\n                SerializableTester.reserialize(instance);\n            } catch (Exception e) {\n                // sneaky checked exception\n                AssertionError error = new AssertionFailedError(\"Serialization failed on return value of \" + factory);\n                error.initCause(e.getCause());\n                throw error;\n            }\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Runs serialization test on the return values of the static methods.\n *\n * <p>Test fails if default value cannot be determined for a constructor or factory method\n * parameter, or if the constructor or factory method throws exception.\n *\n * @return this tester\n */\n", "repo_name": "guava-master/", "id": 4104, "method_signature": "FactoryMethodReturnValueTester testSerializable()", "filename": "FactoryMethodReturnValueTester.testSerializable.json"}
{"callee_method_names": [], "method_name": "FactoryMethodReturnValueTester.thatReturn", "method_implementation": "{\n    this.returnTypeToTest = returnType;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies that only the methods that are declared to return {@code returnType} or its subtype\n * are tested.\n *\n * @return this tester object\n */\n", "repo_name": "guava-master/", "id": 4101, "method_signature": "FactoryMethodReturnValueTester thatReturn(Class)", "filename": "FactoryMethodReturnValueTester.thatReturn.json"}
{"callee_method_names": ["AtomicLong.addAndGet"], "method_name": "FakeTicker.advance", "method_implementation": "{\n    nanos.addAndGet(nanoseconds);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Advances the ticker value by {@code nanoseconds}.\n */\n", "repo_name": "guava-master/", "id": 4135, "method_signature": "FakeTicker advance(long)", "filename": "FakeTicker.advance.json"}
{"callee_method_names": ["TimeUnit.toNanos"], "method_name": "FakeTicker.setAutoIncrementStep", "method_implementation": "{\n    checkArgument(autoIncrementStep >= 0, \"May not auto-increment by a negative amount\");\n    this.autoIncrementStepNanos = timeUnit.toNanos(autoIncrementStep);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the increment applied to the ticker whenever it is queried.\n *\n * <p>The default behavior is to auto increment by zero. i.e: The ticker is left unchanged when\n * queried.\n */\n", "repo_name": "guava-master/", "id": 4136, "method_signature": "FakeTicker setAutoIncrementStep(long, TimeUnit)", "filename": "FakeTicker.setAutoIncrementStep.json"}
{"callee_method_names": ["ExecutorService.submit", "CountDownLatch.countDown", "CountDownLatch.await", "Callable<Void>.call", "CountDownLatch.countDown", "CountDownLatch.await"], "method_name": "FakeTickerTest.runConcurrentTest", "method_implementation": "{\n    ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);\n    final CountDownLatch startLatch = new CountDownLatch(numberOfThreads);\n    final CountDownLatch doneLatch = new CountDownLatch(numberOfThreads);\n    for (int i = numberOfThreads; i > 0; i--) {\n        // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n        @SuppressWarnings(\"unused\")\n        Future<?> possiblyIgnoredError = executorService.submit(new Callable<@Nullable Void>() {\n\n            @Override\n            @Nullable\n            public Void call() throws Exception {\n                startLatch.countDown();\n                startLatch.await();\n                callable.call();\n                doneLatch.countDown();\n                return null;\n            }\n        });\n    }\n    doneLatch.await();\n}", "repo_id": "5", "comment": "/**\n * Runs {@code callable} concurrently {@code numberOfThreads} times.\n */\n", "repo_name": "guava-master/", "id": 4236, "method_signature": "void runConcurrentTest(int, Callable)", "filename": "FakeTickerTest.runConcurrentTest.json"}
{"callee_method_names": [], "method_name": "FarmHashFingerprint64.hashLength65Plus", "method_implementation": "{\n    int seed = 81;\n    // For strings over 64 bytes we loop. Internal state consists of 56 bytes: v, w, x, y, and z.\n    long x = seed;\n    @SuppressWarnings(\"ConstantOverflow\")\n    long y = seed * K1 + 113;\n    long z = shiftMix(y * K2 + 113) * K2;\n    long[] v = new long[2];\n    long[] w = new long[2];\n    x = x * K2 + load64(bytes, offset);\n    // Set end so that after the loop we have 1 to 64 bytes left to process.\n    int end = offset + ((length - 1) / 64) * 64;\n    int last64offset = end + ((length - 1) & 63) - 63;\n    do {\n        x = rotateRight(x + y + v[0] + load64(bytes, offset + 8), 37) * K1;\n        y = rotateRight(y + v[1] + load64(bytes, offset + 48), 42) * K1;\n        x ^= w[1];\n        y += v[0] + load64(bytes, offset + 40);\n        z = rotateRight(z + w[0], 33) * K1;\n        weakHashLength32WithSeeds(bytes, offset, v[1] * K1, x + w[0], v);\n        weakHashLength32WithSeeds(bytes, offset + 32, z + w[1], y + load64(bytes, offset + 16), w);\n        long tmp = x;\n        x = z;\n        z = tmp;\n        offset += 64;\n    } while (offset != end);\n    long mul = K1 + ((z & 0xFF) << 1);\n    // Operate on the last 64 bytes of input.\n    offset = last64offset;\n    w[0] += ((length - 1) & 63);\n    v[0] += w[0];\n    w[0] += v[0];\n    x = rotateRight(x + y + v[0] + load64(bytes, offset + 8), 37) * mul;\n    y = rotateRight(y + v[1] + load64(bytes, offset + 48), 42) * mul;\n    x ^= w[1] * 9;\n    y += v[0] * 9 + load64(bytes, offset + 40);\n    z = rotateRight(z + w[0], 33) * mul;\n    weakHashLength32WithSeeds(bytes, offset, v[1] * mul, x + w[0], v);\n    weakHashLength32WithSeeds(bytes, offset + 32, z + w[1], y + load64(bytes, offset + 16), w);\n    return hashLength16(hashLength16(v[0], w[0], mul) + shiftMix(y) * K0 + x, hashLength16(v[1], w[1], mul) + z, mul);\n}", "repo_id": "5", "comment": "/*\n   * Compute an 8-byte hash of a byte array of length greater than 64 bytes.\n   */\n", "repo_name": "guava-master/", "id": 5210, "method_signature": "long hashLength65Plus(byte[], int, int)", "filename": "FarmHashFingerprint64.hashLength65Plus.json"}
{"callee_method_names": [], "method_name": "FarmHashFingerprint64.weakHashLength32WithSeeds", "method_implementation": "{\n    long part1 = load64(bytes, offset);\n    long part2 = load64(bytes, offset + 8);\n    long part3 = load64(bytes, offset + 16);\n    long part4 = load64(bytes, offset + 24);\n    seedA += part1;\n    seedB = rotateRight(seedB + seedA + part4, 21);\n    long c = seedA;\n    seedA += part2;\n    seedA += part3;\n    seedB += rotateRight(seedA, 44);\n    output[0] = seedA + part4;\n    output[1] = seedB + c;\n}", "repo_id": "5", "comment": "/**\n * Computes intermediate hash of 32 bytes of byte array from the given offset. Results are\n * returned in the output array because when we last measured, this was 12% faster than allocating\n * new arrays every time.\n */\n", "repo_name": "guava-master/", "id": 5209, "method_signature": "void weakHashLength32WithSeeds(byte[], int, long, long, long[])", "filename": "FarmHashFingerprint64.weakHashLength32WithSeeds.json"}
{"callee_method_names": [], "method_name": "FarmHashFingerprint64Test.testMultipleLengths", "method_implementation": "{\n    int iterations = 800;\n    byte[] buf = new byte[iterations * 4];\n    int bufLen = 0;\n    long h = 0;\n    for (int i = 0; i < iterations; ++i) {\n        h ^= fingerprint(buf, i);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        h ^= fingerprint(buf, i * i % bufLen);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        h ^= fingerprint(buf, i * i * i % bufLen);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        h ^= fingerprint(buf, bufLen);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        int x0 = buf[bufLen - 1] & 0xff;\n        int x1 = buf[bufLen - 2] & 0xff;\n        int x2 = buf[bufLen - 3] & 0xff;\n        int x3 = buf[bufLen / 2] & 0xff;\n        buf[((x0 << 16) + (x1 << 8) + x2) % bufLen] ^= x3;\n        buf[((x1 << 16) + (x2 << 8) + x3) % bufLen] ^= i % 256;\n    }\n    assertEquals(0x7a1d67c50ec7e167L, h);\n}", "repo_id": "5", "comment": "/**\n * Tests that the Java port of FarmHashFingerprint64 provides the same results on buffers up to\n * 800 bytes long as the C++ reference implementation.\n */\n", "repo_name": "guava-master/", "id": 3725, "method_signature": "void testMultipleLengths()", "filename": "FarmHashFingerprint64Test.testMultipleLengths.json"}
{"callee_method_names": [], "method_name": "FarmHashFingerprint64Test.testReallySimpleFingerprints", "method_implementation": "{\n    assertEquals(8581389452482819506L, fingerprint(\"test\".getBytes(UTF_8)));\n    // 32 characters long\n    assertEquals(-4196240717365766262L, fingerprint(Strings.repeat(\"test\", 8).getBytes(UTF_8)));\n    // 256 characters long\n    assertEquals(3500507768004279527L, fingerprint(Strings.repeat(\"test\", 64).getBytes(UTF_8)));\n}", "repo_id": "5", "comment": "// If this test fails, all bets are off\n", "repo_name": "guava-master/", "id": 3724, "method_signature": "void testReallySimpleFingerprints()", "filename": "FarmHashFingerprint64Test.testReallySimpleFingerprints.json"}
{"callee_method_names": ["Class<?>.equals", "Set<Class<?>>.add", "Class<?>.getSuperclass"], "method_name": "FauxveridesTest.getClassesBetween", "method_implementation": "{\n    Set<Class<?>> classes = newHashSet();\n    while (!descendant.equals(ancestor)) {\n        classes.add(descendant);\n        descendant = descendant.getSuperclass();\n    }\n    return classes;\n}", "repo_id": "5", "comment": "/**\n * [descendant, ancestor)\n */\n", "repo_name": "guava-master/", "id": 4011, "method_signature": "Set<Class<?>> getClassesBetween(Class, Class)", "filename": "FauxveridesTest.getClassesBetween.json"}
{"callee_method_names": ["Class<E>.getDeclaredClasses"], "method_name": "FeatureEnumTest.assertGoodFeatureEnum", "method_implementation": "{\n    final Class<?>[] classes = featureEnumClass.getDeclaredClasses();\n    for (Class<?> containedClass : classes) {\n        if (containedClass.getSimpleName().equals(\"Require\")) {\n            if (containedClass.isAnnotation()) {\n                assertGoodTesterAnnotation(asAnnotation(containedClass));\n            } else {\n                fail(rootLocaleFormat(\"Feature enum %s contains a class named \" + \"'Require' but it is not an annotation.\", featureEnumClass));\n            }\n            return;\n        }\n    }\n    fail(rootLocaleFormat(\"Feature enum %s should contain an \" + \"annotation named 'Require'.\", featureEnumClass));\n}", "repo_id": "5", "comment": "// can reuse it.\n", "repo_name": "guava-master/", "id": 4256, "method_signature": "void assertGoodFeatureEnum(Class)", "filename": "FeatureEnumTest.assertGoodFeatureEnum.json"}
{"callee_method_names": [], "method_name": "FeatureSpecificTestSuiteBuilder.checkCanCreate", "method_implementation": "{\n    if (subjectGenerator == null) {\n        throw new IllegalStateException(\"Call using() before createTestSuite().\");\n    }\n    if (name == null) {\n        throw new IllegalStateException(\"Call named() before createTestSuite().\");\n    }\n    if (features == null) {\n        throw new IllegalStateException(\"Call withFeatures() before createTestSuite().\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Throw {@link IllegalStateException} if {@link #createTestSuite()} can't be called yet.\n */\n", "repo_name": "guava-master/", "id": 4209, "method_signature": "void checkCanCreate()", "filename": "FeatureSpecificTestSuiteBuilder.checkCanCreate.json"}
{"callee_method_names": ["Logger.fine", "Logger.fine", "Logger.fine", "TestSuite.countTestCases", "TestSuite.addTest"], "method_name": "FeatureSpecificTestSuiteBuilder.createTestSuite", "method_implementation": "{\n    checkCanCreate();\n    logger.fine(\" Testing: \" + name);\n    logger.fine(\"Features: \" + formatFeatureSet(features));\n    FeatureUtil.addImpliedFeatures(features);\n    logger.fine(\"Expanded: \" + formatFeatureSet(features));\n    // Class parameters must be raw.\n    List<Class<? extends AbstractTester>> testers = getTesters();\n    TestSuite suite = new TestSuite(name);\n    for (Class<? extends AbstractTester> testerClass : testers) {\n        TestSuite testerSuite = makeSuiteForTesterClass((Class<? extends AbstractTester<?>>) testerClass);\n        if (testerSuite.countTestCases() > 0) {\n            suite.addTest(testerSuite);\n        }\n    }\n    return suite;\n}", "repo_id": "5", "comment": "/*\n   * Class parameters must be raw. This annotation should go on testerClass in\n   * the for loop, but the 1.5 javac crashes on annotations in for loops:\n   * <http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6294589>\n   */\n", "repo_name": "guava-master/", "id": 4208, "method_signature": "TestSuite createTestSuite()", "filename": "FeatureSpecificTestSuiteBuilder.createTestSuite.json"}
{"callee_method_names": ["String.contains"], "method_name": "FeatureSpecificTestSuiteBuilder.named", "method_implementation": "{\n    if (name.contains(\"(\")) {\n        throw new IllegalArgumentException(\"Eclipse hides all characters after \" + \"'('; please use '[]' or other characters instead of parentheses\");\n    }\n    this.name = name;\n    return self();\n}", "repo_id": "5", "comment": "/**\n * Configures this builder produce a TestSuite with the given name.\n */\n", "repo_name": "guava-master/", "id": 4207, "method_signature": "B named(String)", "filename": "FeatureSpecificTestSuiteBuilder.named.json"}
{"callee_method_names": ["Queue<Feature<?>>.isEmpty", "Queue<Feature<?>>.remove", "Feature<?>.getImpliedFeatures", "Set<Feature<?>>.add", "Queue<Feature<?>>.add"], "method_name": "FeatureUtil.addImpliedFeatures", "method_implementation": "{\n    Queue<Feature<?>> queue = new ArrayDeque<>(features);\n    while (!queue.isEmpty()) {\n        Feature<?> feature = queue.remove();\n        for (Feature<?> implied : feature.getImpliedFeatures()) {\n            if (features.add(implied)) {\n                queue.add(implied);\n            }\n        }\n    }\n    return features;\n}", "repo_id": "5", "comment": "/**\n * Given a set of features, add to it all the features directly or indirectly implied by any of\n * them, and return it.\n *\n * @param features the set of features to expand\n * @return the same set of features, expanded with all implied features\n */\n", "repo_name": "guava-master/", "id": 4223, "method_signature": "Set<Feature<?>> addImpliedFeatures(Set)", "filename": "FeatureUtil.addImpliedFeatures.json"}
{"callee_method_names": [], "method_name": "FeatureUtil.buildDeclaredTesterRequirements", "method_implementation": "{\n    TesterRequirements requirements = new TesterRequirements();\n    Iterable<Annotation> testerAnnotations = getTesterAnnotations(classOrMethod);\n    for (Annotation testerAnnotation : testerAnnotations) {\n        TesterRequirements moreRequirements = buildTesterRequirements(testerAnnotation);\n        incorporateRequirements(requirements, moreRequirements, testerAnnotation);\n    }\n    return requirements;\n}", "repo_id": "5", "comment": "/**\n * Construct the set of requirements specified by annotations directly on a tester class or\n * method.\n *\n * @param classOrMethod a tester class or a test method thereof\n * @return all the constraints implicitly or explicitly required by annotations on the class or\n *     method.\n * @throws ConflictingRequirementsException if the requirements are mutually inconsistent.\n */\n", "repo_name": "guava-master/", "id": 4230, "method_signature": "TesterRequirements buildDeclaredTesterRequirements(AnnotatedElement)", "filename": "FeatureUtil.buildDeclaredTesterRequirements.json"}
{"callee_method_names": ["Annotation.annotationType", "Class<? extends Annotation>.getMethod", "Class<? extends Annotation>.getMethod"], "method_name": "FeatureUtil.buildTesterRequirements", "method_implementation": "{\n    Class<? extends Annotation> annotationClass = testerAnnotation.annotationType();\n    Feature<?>[] presentFeatures;\n    Feature<?>[] absentFeatures;\n    try {\n        presentFeatures = (Feature[]) annotationClass.getMethod(\"value\").invoke(testerAnnotation);\n        absentFeatures = (Feature[]) annotationClass.getMethod(\"absent\").invoke(testerAnnotation);\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Error extracting features from tester annotation.\", e);\n    }\n    Set<Feature<?>> allPresentFeatures = addImpliedFeatures(Helpers.<Feature<?>>copyToSet(presentFeatures));\n    Set<Feature<?>> allAbsentFeatures = addImpliedFeatures(Helpers.<Feature<?>>copyToSet(absentFeatures));\n    if (!Collections.disjoint(allPresentFeatures, allAbsentFeatures)) {\n        throw new ConflictingRequirementsException(\"Annotation explicitly or \" + \"implicitly requires one or more features to be both present \" + \"and absent.\", intersection(allPresentFeatures, allAbsentFeatures), testerAnnotation);\n    }\n    return new TesterRequirements(allPresentFeatures, allAbsentFeatures);\n}", "repo_id": "5", "comment": "/**\n * Find all the constraints explicitly or implicitly specified by a single tester annotation.\n *\n * @param testerAnnotation a tester annotation\n * @return the requirements specified by the annotation\n * @throws ConflictingRequirementsException if the requirements are mutually inconsistent.\n */\n", "repo_name": "guava-master/", "id": 4229, "method_signature": "TesterRequirements buildTesterRequirements(Annotation)", "filename": "FeatureUtil.buildTesterRequirements.json"}
{"callee_method_names": [], "method_name": "FeatureUtil.checkConflict", "method_implementation": "{\n    if (!Collections.disjoint(newFeatures, earlierFeatures)) {\n        throw new ConflictingRequirementsException(String.format(Locale.ROOT, \"Annotation requires to be %s features that earlier \" + \"annotations required to be %s.\", newRequirement, earlierRequirement), intersection(newFeatures, earlierFeatures), source);\n    }\n}", "repo_id": "5", "comment": "// Used by incorporateRequirements() only\n", "repo_name": "guava-master/", "id": 4233, "method_signature": "void checkConflict(String, Set, String, Set, Object)", "filename": "FeatureUtil.checkConflict.json"}
{"callee_method_names": ["HashMap.get", "AnnotatedElement.getDeclaredAnnotations", "E.annotationType", "List<Annotation>.add", "HashMap.put"], "method_name": "FeatureUtil.getTesterAnnotations", "method_implementation": "{\n    synchronized (annotationCache) {\n        List<Annotation> annotations = annotationCache.get(classOrMethod);\n        if (annotations == null) {\n            annotations = new ArrayList<>();\n            for (Annotation a : classOrMethod.getDeclaredAnnotations()) {\n                if (a.annotationType().isAnnotationPresent(TesterAnnotation.class)) {\n                    annotations.add(a);\n                }\n            }\n            annotations = Collections.unmodifiableList(annotations);\n            annotationCache.put(classOrMethod, annotations);\n        }\n        return annotations;\n    }\n}", "repo_id": "5", "comment": "/**\n * Find all the tester annotations declared on a tester class or method.\n *\n * @param classOrMethod a class or method whose tester annotations to find\n * @return an iterable sequence of tester annotations on the class\n */\n", "repo_name": "guava-master/", "id": 4231, "method_signature": "Iterable<Annotation> getTesterAnnotations(AnnotatedElement)", "filename": "FeatureUtil.getTesterAnnotations.json"}
{"callee_method_names": ["HashMap.get", "HashMap.put"], "method_name": "FeatureUtil.getTesterRequirements", "method_implementation": "{\n    synchronized (methodTesterRequirementsCache) {\n        TesterRequirements requirements = methodTesterRequirementsCache.get(testerMethod);\n        if (requirements == null) {\n            requirements = buildTesterRequirements(testerMethod);\n            methodTesterRequirementsCache.put(testerMethod, requirements);\n        }\n        return requirements;\n    }\n}", "repo_id": "5", "comment": "/**\n * Get the full set of requirements for a tester class.\n *\n * @param testerMethod a test method of a tester class\n * @return all the constraints implicitly or explicitly required by the method, its declaring\n *     class, or any of its superclasses.\n * @throws ConflictingRequirementsException if the requirements are mutually inconsistent.\n */\n", "repo_name": "guava-master/", "id": 4226, "method_signature": "TesterRequirements getTesterRequirements(Method)", "filename": "FeatureUtil.getTesterRequirements.json"}
{"callee_method_names": ["Queue<Feature<?>>.isEmpty", "Queue<Feature<?>>.remove", "Feature<?>.getImpliedFeatures", "Set<Feature<?>>.contains", "Set<Feature<?>>.add", "Queue<Feature<?>>.add"], "method_name": "FeatureUtil.impliedFeatures", "method_implementation": "{\n    Set<Feature<?>> impliedSet = new LinkedHashSet<>();\n    Queue<Feature<?>> queue = new ArrayDeque<>(features);\n    while (!queue.isEmpty()) {\n        Feature<?> feature = queue.remove();\n        for (Feature<?> implied : feature.getImpliedFeatures()) {\n            if (!features.contains(implied) && impliedSet.add(implied)) {\n                queue.add(implied);\n            }\n        }\n    }\n    return impliedSet;\n}", "repo_id": "5", "comment": "/**\n * Given a set of features, return a new set of all features directly or indirectly implied by any\n * of them.\n *\n * @param features the set of features whose implications to find\n * @return the implied set of features\n */\n", "repo_name": "guava-master/", "id": 4224, "method_signature": "Set<Feature<?>> impliedFeatures(Set)", "filename": "FeatureUtil.impliedFeatures.json"}
{"callee_method_names": ["TesterRequirements.getPresentFeatures", "TesterRequirements.getAbsentFeatures", "TesterRequirements.getPresentFeatures", "TesterRequirements.getAbsentFeatures", "Set<Feature<?>>.addAll", "Set<Feature<?>>.addAll"], "method_name": "FeatureUtil.incorporateRequirements", "method_implementation": "{\n    Set<Feature<?>> presentFeatures = requirements.getPresentFeatures();\n    Set<Feature<?>> absentFeatures = requirements.getAbsentFeatures();\n    Set<Feature<?>> morePresentFeatures = moreRequirements.getPresentFeatures();\n    Set<Feature<?>> moreAbsentFeatures = moreRequirements.getAbsentFeatures();\n    checkConflict(\"absent\", absentFeatures, \"present\", morePresentFeatures, source);\n    checkConflict(\"present\", presentFeatures, \"absent\", moreAbsentFeatures, source);\n    presentFeatures.addAll(morePresentFeatures);\n    absentFeatures.addAll(moreAbsentFeatures);\n    return requirements;\n}", "repo_id": "5", "comment": "/**\n * Incorporate additional requirements into an existing requirements object.\n *\n * @param requirements the existing requirements object\n * @param moreRequirements more requirements to incorporate\n * @param source the source of the additional requirements (used only for error reporting)\n * @return the existing requirements object, modified to include the additional requirements\n * @throws ConflictingRequirementsException if the additional requirements are inconsistent with\n *     the existing requirements\n */\n", "repo_name": "guava-master/", "id": 4232, "method_signature": "TesterRequirements incorporateRequirements(TesterRequirements, TesterRequirements, Object)", "filename": "FeatureUtil.incorporateRequirements.json"}
{"callee_method_names": ["Set<T>.retainAll"], "method_name": "FeatureUtil.intersection", "method_implementation": "{\n    Set<T> result = Helpers.<T>copyToSet(set1);\n    result.retainAll(set2);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Construct a new {@link java.util.Set} that is the intersection of the given sets.\n */\n", "repo_name": "guava-master/", "id": 4234, "method_signature": "Set<T> intersection(Set, Set)", "filename": "FeatureUtil.intersection.json"}
{"callee_method_names": [], "method_name": "FeatureUtilTest.testRequiringAllThreeDerivedFeatures", "method_implementation": "{\n    doNotActuallyRunThis();\n}", "repo_id": "5", "comment": "// Exists to test that our framework doesn't run it:\n", "repo_name": "guava-master/", "id": 4251, "method_signature": "void testRequiringAllThreeDerivedFeatures()", "filename": "FeatureUtilTest.testRequiringAllThreeDerivedFeatures.json"}
{"callee_method_names": [], "method_name": "FeatureUtilTest.testRequiringConflictingFeatures", "method_implementation": "{\n    doNotActuallyRunThis();\n}", "repo_id": "5", "comment": "// Exists to test that our framework doesn't run it:\n", "repo_name": "guava-master/", "id": 4252, "method_signature": "void testRequiringConflictingFeatures()", "filename": "FeatureUtilTest.testRequiringConflictingFeatures.json"}
{"callee_method_names": [], "method_name": "FeatureUtilTest.testRequiringTwoExplicitDerivedFeatures", "method_implementation": "{\n    doNotActuallyRunThis();\n}", "repo_id": "5", "comment": "// Exists to test that our framework doesn't run it:\n", "repo_name": "guava-master/", "id": 4250, "method_signature": "void testRequiringTwoExplicitDerivedFeatures()", "filename": "FeatureUtilTest.testRequiringTwoExplicitDerivedFeatures.json"}
{"callee_method_names": [], "method_name": "FileBackedOutputStream.getFile", "method_implementation": "{\n    return file;\n}", "repo_id": "5", "comment": "/**\n * Returns the file holding the data (possibly null).\n */\n", "repo_name": "guava-master/", "id": 4830, "method_signature": "File getFile()", "filename": "FileBackedOutputStream.getFile.json"}
{"callee_method_names": ["MemoryOutput.reset", "File.delete"], "method_name": "FileBackedOutputStream.reset", "method_implementation": "{\n    try {\n        close();\n    } finally {\n        if (memory == null) {\n            memory = new MemoryOutput();\n        } else {\n            memory.reset();\n        }\n        out = memory;\n        if (file != null) {\n            File deleteMe = file;\n            file = null;\n            if (!deleteMe.delete()) {\n                throw new IOException(\"Could not delete: \" + deleteMe);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Calls {@link #close} if not already closed, and then resets this object back to its initial\n * state, for reuse. If data was buffered to a file, it will be deleted.\n *\n * @throws IOException if an I/O error occurred while deleting the file buffer\n */\n", "repo_name": "guava-master/", "id": 4831, "method_signature": "void reset()", "filename": "FileBackedOutputStream.reset.json"}
{"callee_method_names": ["MemoryOutput.getCount", "File.deleteOnExit", "FileOutputStream.write", "MemoryOutput.getBuffer", "MemoryOutput.getCount", "FileOutputStream.flush", "File.delete"], "method_name": "FileBackedOutputStream.update", "method_implementation": "{\n    if (memory != null && (memory.getCount() + len > fileThreshold)) {\n        File temp = TempFileCreator.INSTANCE.createTempFile(\"FileBackedOutputStream\");\n        if (resetOnFinalize) {\n            // Finalizers are not guaranteed to be called on system shutdown;\n            // this is insurance.\n            temp.deleteOnExit();\n        }\n        try {\n            FileOutputStream transfer = new FileOutputStream(temp);\n            transfer.write(memory.getBuffer(), 0, memory.getCount());\n            transfer.flush();\n            // We've successfully transferred the data; switch to writing to file\n            out = transfer;\n        } catch (IOException e) {\n            temp.delete();\n            throw e;\n        }\n        file = temp;\n        memory = null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks if writing {@code len} bytes would go over threshold, and switches to file buffering if\n * so.\n */\n", "repo_name": "guava-master/", "id": 4832, "method_signature": "void update(int)", "filename": "FileBackedOutputStream.update.json"}
{"callee_method_names": [], "method_name": "Files.append", "method_implementation": "{\n    asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n}", "repo_id": "5", "comment": "/**\n * Appends a character sequence (such as a string) to a file using the given character set.\n *\n * @param from the character sequence to append\n * @param to the destination file\n * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @throws IOException if an I/O error occurs\n * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n *     method is scheduled to be removed in October 2019.\n */\n", "repo_name": "guava-master/", "id": 4787, "method_signature": "void append(CharSequence, File, Charset)", "filename": "Files.append.json"}
{"callee_method_names": [], "method_name": "Files.copy", "method_implementation": "{\n    asCharSource(from, charset).copyTo(to);\n}", "repo_id": "5", "comment": "/**\n * Copies all characters from a file to an appendable object, using the given character set.\n *\n * @param from the source file\n * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @param to the appendable object\n * @throws IOException if an I/O error occurs\n * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}.\n */\n", "repo_name": "guava-master/", "id": 4786, "method_signature": "void copy(File, Charset, Appendable)", "filename": "Files.copy.json"}
{"callee_method_names": ["File.getCanonicalFile", "File.mkdirs", "File.isDirectory"], "method_name": "Files.createParentDirs", "method_implementation": "{\n    checkNotNull(file);\n    File parent = file.getCanonicalFile().getParentFile();\n    if (parent == null) {\n        /*\n       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n       * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n       * -- or even that the caller can create it, but this method makes no such guarantees even for\n       * non-root files.\n       */\n        return;\n    }\n    parent.mkdirs();\n    if (!parent.isDirectory()) {\n        throw new IOException(\"Unable to create parent directories of \" + file);\n    }\n}", "repo_id": "5", "comment": "/**\n * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n * this operation fails it may have succeeded in creating some (but not all) of the necessary\n * parent directories.\n *\n * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n *     directories of the specified file could not be created.\n * @since 4.0\n */\n", "repo_name": "guava-master/", "id": 4791, "method_signature": "void createParentDirs(File)", "filename": "Files.createParentDirs.json"}
{"callee_method_names": [], "method_name": "Files.createTempDir", "method_implementation": "{\n    return TempFileCreator.INSTANCE.createTempDir();\n}", "repo_id": "5", "comment": "/**\n * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n * defined by the {@code java.io.tmpdir} system property), and returns its name.\n *\n * <p>The temporary directory is created with permissions restricted to the current user or, in\n * the case of Android, the current app. If that is not possible (as is the case under the very\n * old Android Ice Cream Sandwich release), then this method throws an exception instead of\n * creating a directory that would be more accessible. (This behavior is new in Guava 32.0.0.\n * Previous versions would create a directory that is more accessible, as discussed in <a\n * href=\"https://github.com/google/guava/issues/4011\">CVE-2020-8908</a>.)\n *\n * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n * delete the file and create a directory in its place, but this leads a race condition which can\n * be exploited to create security vulnerabilities, especially when executable files are to be\n * written into the directory.\n *\n * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n * and that it will not be called thousands of times per second.\n *\n * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n * java.nio.file.Files#createTempDirectory}.\n *\n * @return the newly-created directory\n * @throws IllegalStateException if the directory could not be created, such as if the system does\n *     not support creating temporary directories securely\n * @deprecated For Android users, see the <a\n *     href=\"https://developer.android.com/training/data-storage\" target=\"_blank\">Data and File\n *     Storage overview</a> to select an appropriate temporary directory (perhaps {@code\n *     context.getCacheDir()}), and create your own directory under that. (For example, you might\n *     use {@code new File(context.getCacheDir(), \"directoryname\").mkdir()}, or, if you need an\n *     arbitrary number of temporary directories, you might have to generate multiple directory\n *     names in a loop until {@code mkdir()} returns {@code true}.) For developers on Java 7 or\n *     later, use {@link java.nio.file.Files#createTempDirectory}, transforming it to a {@link\n *     File} using {@link java.nio.file.Path#toFile() toFile()} if needed. To restrict permissions\n *     as this method does, pass {@code\n *     PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"))} to your\n *     call to {@code createTempDirectory}.\n */\n", "repo_name": "guava-master/", "id": 4789, "method_signature": "File createTempDir()", "filename": "Files.createTempDir.json"}
{"callee_method_names": ["File.equals", "File.length", "File.length"], "method_name": "Files.equal", "method_implementation": "{\n    checkNotNull(file1);\n    checkNotNull(file2);\n    if (file1 == file2 || file1.equals(file2)) {\n        return true;\n    }\n    /*\n     * Some operating systems may return zero as the length for files denoting system-dependent\n     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n     * directly.\n     */\n    long len1 = file1.length();\n    long len2 = file2.length();\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\n        return false;\n    }\n    return asByteSource(file1).contentEquals(asByteSource(file2));\n}", "repo_id": "5", "comment": "/**\n * Returns true if the given files exist, are not directories, and contain the same bytes.\n *\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4788, "method_signature": "boolean equal(File, File)", "filename": "Files.equal.json"}
{"callee_method_names": ["String.lastIndexOf", "String.substring"], "method_name": "Files.getFileExtension", "method_implementation": "{\n    checkNotNull(fullName);\n    String fileName = new File(fullName).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n * the given file name, or the empty string if the file has no extension. The result does not\n * include the '{@code .}'.\n *\n * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4799, "method_signature": "String getFileExtension(String)", "filename": "Files.getFileExtension.json"}
{"callee_method_names": ["String.lastIndexOf", "String.substring"], "method_name": "Files.getNameWithoutExtension", "method_implementation": "{\n    checkNotNull(file);\n    String fileName = new File(file).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n}", "repo_id": "5", "comment": "/**\n * Returns the file name without its <a\n * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n *\n * @param file The name of the file to trim the extension from. This can be either a fully\n *     qualified file name (including a path) or just a file name.\n * @return The file name without its path or extension.\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4800, "method_signature": "String getNameWithoutExtension(String)", "filename": "Files.getNameWithoutExtension.json"}
{"callee_method_names": [], "method_name": "Files.hash", "method_implementation": "{\n    return asByteSource(file).hash(hashFunction);\n}", "repo_id": "5", "comment": "/**\n * Computes the hash code of the {@code file} using {@code hashFunction}.\n *\n * @param file the file to read\n * @param hashFunction the hash function to use to hash the data\n * @return the {@link HashCode} of all of the bytes in the file\n * @throws IOException if an I/O error occurs\n * @since 12.0\n * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}.\n */\n", "repo_name": "guava-master/", "id": 4797, "method_signature": "HashCode hash(File, HashFunction)", "filename": "Files.hash.json"}
{"callee_method_names": ["File.equals", "File.renameTo", "File.delete", "File.delete"], "method_name": "Files.move", "method_implementation": "{\n    checkNotNull(from);\n    checkNotNull(to);\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    if (!from.renameTo(to)) {\n        copy(from, to);\n        if (!from.delete()) {\n            if (!to.delete()) {\n                throw new IOException(\"Unable to delete \" + to);\n            }\n            throw new IOException(\"Unable to delete \" + from);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Moves a file from one path to another. This method can rename a file and/or move it to a\n * different directory. In either case {@code to} must be the target path for the file itself; not\n * just the new name for the file or the path to the new parent directory.\n *\n * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n *\n * @param from the source file\n * @param to the destination file\n * @throws IOException if an I/O error occurs\n * @throws IllegalArgumentException if {@code from.equals(to)}\n */\n", "repo_name": "guava-master/", "id": 4792, "method_signature": "void move(File, File)", "filename": "Files.move.json"}
{"callee_method_names": [], "method_name": "Files.newReader", "method_implementation": "{\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n}", "repo_id": "5", "comment": "/**\n * Returns a buffered reader that reads from a file using the given character set.\n *\n * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n *\n * @param file the file to read from\n * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @return the buffered reader\n */\n", "repo_name": "guava-master/", "id": 4782, "method_signature": "BufferedReader newReader(File, Charset)", "filename": "Files.newReader.json"}
{"callee_method_names": [], "method_name": "Files.newWriter", "method_implementation": "{\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n}", "repo_id": "5", "comment": "/**\n * Returns a buffered writer that writes to a file using the given character set.\n *\n * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n * java.nio.file.OpenOption...)}.\n *\n * @param file the file to write to\n * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @return the buffered writer\n */\n", "repo_name": "guava-master/", "id": 4783, "method_signature": "BufferedWriter newWriter(File, Charset)", "filename": "Files.newWriter.json"}
{"callee_method_names": [], "method_name": "Files.readBytes", "method_implementation": "{\n    return asByteSource(file).read(processor);\n}", "repo_id": "5", "comment": "/**\n * Process the bytes of a file.\n *\n * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n *\n * @param file the file to read\n * @param processor the object to which the bytes of the file are passed.\n * @return the result of the byte processor\n * @throws IOException if an I/O error occurs\n * @deprecated Prefer {@code asByteSource(file).read(processor)}.\n */\n", "repo_name": "guava-master/", "id": 4796, "method_signature": "T readBytes(File, ByteProcessor)", "filename": "Files.readBytes.json"}
{"callee_method_names": [], "method_name": "Files.readFirstLine", "method_implementation": "{\n    return asCharSource(file, charset).readFirstLine();\n}", "repo_id": "5", "comment": "/**\n * Reads the first line from a file. The line does not include line-termination characters, but\n * does include other leading and trailing whitespace.\n *\n * @param file the file to read from\n * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @return the first line, or null if the file is empty\n * @throws IOException if an I/O error occurs\n * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}.\n */\n", "repo_name": "guava-master/", "id": 4793, "method_signature": "String readFirstLine(File, Charset)", "filename": "Files.readFirstLine.json"}
{"callee_method_names": [], "method_name": "Files.readLines", "method_implementation": "{\n    return asCharSource(file, charset).readLines(callback);\n}", "repo_id": "5", "comment": "/**\n * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n * all of the lines.\n *\n * @param file the file to read from\n * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @param callback the {@link LineProcessor} to use to handle the lines\n * @return the output of processing the lines\n * @throws IOException if an I/O error occurs\n * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}.\n */\n", "repo_name": "guava-master/", "id": 4795, "method_signature": "T readLines(File, Charset, LineProcessor)", "filename": "Files.readLines.json"}
{"callee_method_names": ["String.length", "List<String>.size", "List<String>.get", "List<String>.size", "List<String>.remove", "List<String>.size", "List<String>.add", "List<String>.add", "String.charAt", "String.startsWith", "String.substring", "String.equals"], "method_name": "Files.simplifyPath", "method_implementation": "{\n    checkNotNull(pathname);\n    if (pathname.length() == 0) {\n        return \".\";\n    }\n    // split the path apart\n    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n    List<String> path = new ArrayList<>();\n    // resolve ., .., and //\n    for (String component : components) {\n        switch(component) {\n            case \".\":\n                continue;\n            case \"..\":\n                if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\")) {\n                    path.remove(path.size() - 1);\n                } else {\n                    path.add(\"..\");\n                }\n                break;\n            default:\n                path.add(component);\n                break;\n        }\n    }\n    // put it back together\n    String result = Joiner.on('/').join(path);\n    if (pathname.charAt(0) == '/') {\n        result = \"/\" + result;\n    }\n    while (result.startsWith(\"/../\")) {\n        result = result.substring(3);\n    }\n    if (result.equals(\"/..\")) {\n        result = \"/\";\n    } else if (\"\".equals(result)) {\n        result = \".\";\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n * to the original. The following heuristics are used:\n *\n * <ul>\n *   <li>empty string becomes .\n *   <li>. stays as .\n *   <li>fold out ./\n *   <li>fold out ../ when possible\n *   <li>collapse multiple slashes\n *   <li>delete trailing slashes (unless the path is just \"/\")\n * </ul>\n *\n * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n * sibling of {@code a} referred to by {@code b}.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4798, "method_signature": "String simplifyPath(String)", "filename": "Files.simplifyPath.json"}
{"callee_method_names": [], "method_name": "Files.toString", "method_implementation": "{\n    return asCharSource(file, charset).read();\n}", "repo_id": "5", "comment": "/**\n * Reads all characters from a file into a {@link String}, using the given character set.\n *\n * @param file the file to read from\n * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @return a string containing all the characters from the file\n * @throws IOException if an I/O error occurs\n * @deprecated Prefer {@code asCharSource(file, charset).read()}.\n */\n", "repo_name": "guava-master/", "id": 4784, "method_signature": "String toString(File, Charset)", "filename": "Files.toString.json"}
{"callee_method_names": ["File.createNewFile", "File.setLastModified"], "method_name": "Files.touch", "method_implementation": "{\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n        throw new IOException(\"Unable to update modification time of \" + file);\n    }\n}", "repo_id": "5", "comment": "/**\n * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n * the same name.\n *\n * @param file the file to create or update\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4790, "method_signature": "void touch(File)", "filename": "Files.touch.json"}
{"callee_method_names": [], "method_name": "Files.write", "method_implementation": "{\n    asCharSink(to, charset).write(from);\n}", "repo_id": "5", "comment": "/**\n * Writes a character sequence (such as a string) to a file using the given character set.\n *\n * @param from the character sequence to write\n * @param to the destination file\n * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n *     helpful predefined constants\n * @throws IOException if an I/O error occurs\n * @deprecated Prefer {@code asCharSink(to, charset).write(from)}.\n */\n", "repo_name": "guava-master/", "id": 4785, "method_signature": "void write(CharSequence, File, Charset)", "filename": "Files.write.json"}
{"callee_method_names": [], "method_name": "FilesSimplifyPathTest.test716", "method_implementation": "{\n    assertEquals(\"b\", simplifyPath(\"./b\"));\n    assertEquals(\"b\", simplifyPath(\"./b/.\"));\n    assertEquals(\"b\", simplifyPath(\"././b/./.\"));\n    assertEquals(\"b\", simplifyPath(\"././b\"));\n    assertEquals(\"a/b\", simplifyPath(\"./a/b\"));\n}", "repo_id": "5", "comment": "// https://code.google.com/p/guava-libraries/issues/detail?id=716\n", "repo_name": "guava-master/", "id": 3627, "method_signature": "void test716()", "filename": "FilesSimplifyPathTest.test716.json"}
{"callee_method_names": [], "method_name": "FilesSimplifyPathTest.testMadbotsBug", "method_implementation": "{\n    assertEquals(\"../this\", simplifyPath(\"../this\"));\n    assertEquals(\"../this/is/ok\", simplifyPath(\"../this/is/ok\"));\n    assertEquals(\"../ok\", simplifyPath(\"../this/../ok\"));\n}", "repo_id": "5", "comment": "// b/4558855\n", "repo_name": "guava-master/", "id": 3626, "method_signature": "void testMadbotsBug()", "filename": "FilesSimplifyPathTest.testMadbotsBug.json"}
{"callee_method_names": [], "method_name": "FilesSimplifyPathTest.testMultipleDotFilenames", "method_implementation": "{\n    assertEquals(\"..a\", simplifyPath(\"..a\"));\n    assertEquals(\"/..a\", simplifyPath(\"/..a\"));\n    assertEquals(\"/..a/..b\", simplifyPath(\"/..a/..b\"));\n    assertEquals(\"/.....a/..b\", simplifyPath(\"/.....a/..b\"));\n    assertEquals(\"..../....\", simplifyPath(\"..../....\"));\n    assertEquals(\"..a../..b..\", simplifyPath(\"..a../..b..\"));\n}", "repo_id": "5", "comment": "// https://code.google.com/p/guava-libraries/issues/detail?id=716\n", "repo_name": "guava-master/", "id": 3628, "method_signature": "void testMultipleDotFilenames()", "filename": "FilesSimplifyPathTest.testMultipleDotFilenames.json"}
{"callee_method_names": [], "method_name": "FilesSimplifyPathTest.testRfc2396Abnormal", "method_implementation": "{\n    assertEquals(\"/a/b/c/g.\", simplifyPath(\"/a/b/c/g.\"));\n    assertEquals(\"/a/b/c/.g\", simplifyPath(\"/a/b/c/.g\"));\n    assertEquals(\"/a/b/c/g..\", simplifyPath(\"/a/b/c/g..\"));\n    assertEquals(\"/a/b/c/..g\", simplifyPath(\"/a/b/c/..g\"));\n    assertEquals(\"/a/b/g\", simplifyPath(\"/a/b/c/./../g\"));\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/./g/.\"));\n    assertEquals(\"/a/b/c/g/h\", simplifyPath(\"/a/b/c/g/./h\"));\n    assertEquals(\"/a/b/c/h\", simplifyPath(\"/a/b/c/g/../h\"));\n    assertEquals(\"/a/b/c/g;x=1/y\", simplifyPath(\"/a/b/c/g;x=1/./y\"));\n    assertEquals(\"/a/b/c/y\", simplifyPath(\"/a/b/c/g;x=1/../y\"));\n}", "repo_id": "5", "comment": "/**\n * http://gbiv.com/protocols/uri/rfc/rfc2396.html#rfc.section.C.2\n */\n", "repo_name": "guava-master/", "id": 3630, "method_signature": "void testRfc2396Abnormal()", "filename": "FilesSimplifyPathTest.testRfc2396Abnormal.json"}
{"callee_method_names": [], "method_name": "FilesSimplifyPathTest.testRfc2396Normal", "method_implementation": "{\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/g\"));\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/./g\"));\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/g/\"));\n    assertEquals(\"/a/b/c/g?y\", simplifyPath(\"/a/b/c/g?y\"));\n    assertEquals(\"/a/b/c/g#s\", simplifyPath(\"/a/b/c/g#s\"));\n    assertEquals(\"/a/b/c/g?y#s\", simplifyPath(\"/a/b/c/g?y#s\"));\n    assertEquals(\"/a/b/c/;x\", simplifyPath(\"/a/b/c/;x\"));\n    assertEquals(\"/a/b/c/g;x\", simplifyPath(\"/a/b/c/g;x\"));\n    assertEquals(\"/a/b/c/g;x?y#s\", simplifyPath(\"/a/b/c/g;x?y#s\"));\n    assertEquals(\"/a/b/c\", simplifyPath(\"/a/b/c/.\"));\n    assertEquals(\"/a/b/c\", simplifyPath(\"/a/b/c/./\"));\n    assertEquals(\"/a/b\", simplifyPath(\"/a/b/c/..\"));\n    assertEquals(\"/a/b\", simplifyPath(\"/a/b/c/../\"));\n    assertEquals(\"/a/b/g\", simplifyPath(\"/a/b/c/../g\"));\n    assertEquals(\"/a\", simplifyPath(\"/a/b/c/../..\"));\n    assertEquals(\"/a\", simplifyPath(\"/a/b/c/../../\"));\n    assertEquals(\"/a/g\", simplifyPath(\"/a/b/c/../../g\"));\n}", "repo_id": "5", "comment": "/**\n * http://gbiv.com/protocols/uri/rfc/rfc2396.html#rfc.section.C.1\n */\n", "repo_name": "guava-master/", "id": 3629, "method_signature": "void testRfc2396Normal()", "filename": "FilesSimplifyPathTest.testRfc2396Normal.json"}
{"callee_method_names": [], "method_name": "FilesSimplifyPathTest.testRfc3986Abnormal", "method_implementation": "{\n    assertEquals(\"/g\", simplifyPath(\"/a/b/c/../../../g\"));\n    assertEquals(\"/g\", simplifyPath(\"/a/b/c/../../../../g\"));\n    assertEquals(\"/a/b/c/g.\", simplifyPath(\"/a/b/c/g.\"));\n    assertEquals(\"/a/b/c/.g\", simplifyPath(\"/a/b/c/.g\"));\n    assertEquals(\"/a/b/c/g..\", simplifyPath(\"/a/b/c/g..\"));\n    assertEquals(\"/a/b/c/..g\", simplifyPath(\"/a/b/c/..g\"));\n    assertEquals(\"/a/b/g\", simplifyPath(\"/a/b/c/./../g\"));\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/./g/.\"));\n    assertEquals(\"/a/b/c/g/h\", simplifyPath(\"/a/b/c/g/./h\"));\n    assertEquals(\"/a/b/c/h\", simplifyPath(\"/a/b/c/g/../h\"));\n    assertEquals(\"/a/b/c/g;x=1/y\", simplifyPath(\"/a/b/c/g;x=1/./y\"));\n    assertEquals(\"/a/b/c/y\", simplifyPath(\"/a/b/c/g;x=1/../y\"));\n}", "repo_id": "5", "comment": "/**\n * http://gbiv.com/protocols/uri/rfc/rfc3986.html#relative-abnormal\n */\n", "repo_name": "guava-master/", "id": 3632, "method_signature": "void testRfc3986Abnormal()", "filename": "FilesSimplifyPathTest.testRfc3986Abnormal.json"}
{"callee_method_names": [], "method_name": "FilesSimplifyPathTest.testRfc3986Normal", "method_implementation": "{\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/g\"));\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/./g\"));\n    assertEquals(\"/a/b/c/g\", simplifyPath(\"/a/b/c/g/\"));\n    assertEquals(\"/a/b/c/g?y\", simplifyPath(\"/a/b/c/g?y\"));\n    assertEquals(\"/a/b/c/g#s\", simplifyPath(\"/a/b/c/g#s\"));\n    assertEquals(\"/a/b/c/g?y#s\", simplifyPath(\"/a/b/c/g?y#s\"));\n    assertEquals(\"/a/b/c/;x\", simplifyPath(\"/a/b/c/;x\"));\n    assertEquals(\"/a/b/c/g;x\", simplifyPath(\"/a/b/c/g;x\"));\n    assertEquals(\"/a/b/c/g;x?y#s\", simplifyPath(\"/a/b/c/g;x?y#s\"));\n    assertEquals(\"/a/b/c\", simplifyPath(\"/a/b/c/.\"));\n    assertEquals(\"/a/b/c\", simplifyPath(\"/a/b/c/./\"));\n    assertEquals(\"/a/b\", simplifyPath(\"/a/b/c/..\"));\n    assertEquals(\"/a/b\", simplifyPath(\"/a/b/c/../\"));\n    assertEquals(\"/a/b/g\", simplifyPath(\"/a/b/c/../g\"));\n    assertEquals(\"/a\", simplifyPath(\"/a/b/c/../..\"));\n    assertEquals(\"/a\", simplifyPath(\"/a/b/c/../../\"));\n    assertEquals(\"/a/g\", simplifyPath(\"/a/b/c/../../g\"));\n}", "repo_id": "5", "comment": "/**\n * http://gbiv.com/protocols/uri/rfc/rfc3986.html#relative-normal\n */\n", "repo_name": "guava-master/", "id": 3631, "method_signature": "void testRfc3986Normal()", "filename": "FilesSimplifyPathTest.testRfc3986Normal.json"}
{"callee_method_names": [], "method_name": "FilesTest.file", "method_implementation": "{\n    // not very efficient, but should definitely be correct\n    File file = first;\n    for (String name : more) {\n        file = new File(file, name);\n    }\n    return file;\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code File} object for the given path parts.\n */\n", "repo_name": "guava-master/", "id": 3648, "method_signature": "File file(File, String[])", "filename": "FilesTest.file.json"}
{"callee_method_names": ["Map<K, V>.containsKey", "Predicate<? super K>.apply"], "method_name": "FilteredKeyMap.containsKey", "method_implementation": "{\n    return unfiltered.containsKey(key) && keyPredicate.apply((K) key);\n}", "repo_id": "5", "comment": "// that key is a K.\n", "repo_name": "guava-master/", "id": 6599, "method_signature": "boolean containsKey(Object)", "filename": "FilteredKeyMap.containsKey.json"}
{"callee_method_names": ["ReferenceQueue<Object>.poll", "Reference<?>.clear", "Logger.log"], "method_name": "FinalizableReferenceQueue.cleanUp", "method_implementation": "{\n    if (threadStarted) {\n        return;\n    }\n    Reference<?> reference;\n    while ((reference = queue.poll()) != null) {\n        /*\n       * This is for the benefit of phantom references. Weak and soft references will have already\n       * been cleared by this point.\n       */\n        reference.clear();\n        try {\n            ((FinalizableReference) reference).finalizeReferent();\n        } catch (Throwable t) {\n            logger.log(Level.SEVERE, \"Error cleaning up after reference.\", t);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Repeatedly dequeues references from the queue and invokes {@link\n * FinalizableReference#finalizeReferent()} on them until the queue is empty. This method is a\n * no-op if the background thread was created successfully.\n */\n", "repo_name": "guava-master/", "id": 5100, "method_signature": "void cleanUp()", "filename": "FinalizableReferenceQueue.cleanUp.json"}
{"callee_method_names": ["String.replace", "URL.toString", "String.endsWith", "String.substring", "String.length", "String.length"], "method_name": "FinalizableReferenceQueue.getBaseUrl", "method_implementation": "{\n    // Find URL pointing to Finalizer.class file.\n    String finalizerPath = FINALIZER_CLASS_NAME.replace('.', '/') + \".class\";\n    URL finalizerUrl = getClass().getClassLoader().getResource(finalizerPath);\n    if (finalizerUrl == null) {\n        throw new FileNotFoundException(finalizerPath);\n    }\n    // Find URL pointing to base of class path.\n    String urlString = finalizerUrl.toString();\n    if (!urlString.endsWith(finalizerPath)) {\n        throw new IOException(\"Unsupported path style: \" + urlString);\n    }\n    urlString = urlString.substring(0, urlString.length() - finalizerPath.length());\n    return new URL(finalizerUrl, urlString);\n}", "repo_id": "5", "comment": "/**\n * Gets URL for base of path containing Finalizer.class.\n */\n", "repo_name": "guava-master/", "id": 5102, "method_signature": "URL getBaseUrl()", "filename": "FinalizableReferenceQueue.getBaseUrl.json"}
{"callee_method_names": ["Class<?>.getMethod"], "method_name": "FinalizableReferenceQueue.getStartFinalizer", "method_implementation": "{\n    try {\n        return finalizer.getMethod(\"startFinalizer\", Class.class, ReferenceQueue.class, PhantomReference.class);\n    } catch (NoSuchMethodException e) {\n        throw new AssertionError(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Looks up Finalizer.startFinalizer().\n */\n", "repo_name": "guava-master/", "id": 5104, "method_signature": "Method getStartFinalizer(Class)", "filename": "FinalizableReferenceQueue.getStartFinalizer.json"}
{"callee_method_names": ["CacheLoader<? super K, V>.loadFinalizer"], "method_name": "FinalizableReferenceQueue.loadFinalizer", "method_implementation": "{\n    for (FinalizerLoader loader : loaders) {\n        Class<?> finalizer = loader.loadFinalizer();\n        if (finalizer != null) {\n            return finalizer;\n        }\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Iterates through the given loaders until it finds one that can load Finalizer.\n *\n * @return Finalizer.class\n */\n", "repo_name": "guava-master/", "id": 5101, "method_signature": "Class<?> loadFinalizer(FinalizerLoader[])", "filename": "FinalizableReferenceQueue.loadFinalizer.json"}
{"callee_method_names": [], "method_name": "FinalizableReferenceQueue.newLoader", "method_implementation": "{\n    // We use the bootstrap class loader as the parent because Finalizer by design uses\n    // only standard Java classes. That also means that FinalizableReferenceQueueTest\n    // doesn't pick up the wrong version of the Finalizer class.\n    return new URLClassLoader(new URL[] { base }, null);\n}", "repo_id": "5", "comment": "/**\n * Creates a class loader with the given base URL as its classpath.\n */\n", "repo_name": "guava-master/", "id": 5103, "method_signature": "URLClassLoader newLoader(URL)", "filename": "FinalizableReferenceQueue.newLoader.json"}
{"callee_method_names": ["ClassLoader.getParent", "URLClassLoader.loadClass", "Class<?>.getName", "URLClassLoader.loadClass", "Class<?>.getDeclaredField", "Field.setAccessible", "Field.set", "URLClassLoader.loadClass", "Class<?>.getName", "Class<?>.getClassLoader", "Class<?>.getDeclaredConstructor", "Callable<?>.call", "Class<?>.getField", "Field.get", "Semaphore.tryAcquire", "Class<?>.getField", "Field.get", "Closeable.close"], "method_name": "FinalizableReferenceQueueClassLoaderUnloadingTest.doTestUnloadableInStaticFieldIfClosed", "method_implementation": "{\n    final ClassLoader myLoader = getClass().getClassLoader();\n    URLClassLoader sepLoader = new URLClassLoader(getClassPathUrls(), myLoader.getParent());\n    Class<?> frqC = FinalizableReferenceQueue.class;\n    Class<?> sepFrqC = sepLoader.loadClass(frqC.getName());\n    assertNotSame(frqC, sepFrqC);\n    Class<?> sepFrqSystemLoaderC = sepLoader.loadClass(FinalizableReferenceQueue.SystemLoader.class.getName());\n    Field disabled = sepFrqSystemLoaderC.getDeclaredField(\"disabled\");\n    disabled.setAccessible(true);\n    disabled.set(null, true);\n    Class<?> frqUserC = FrqUser.class;\n    Class<?> sepFrqUserC = sepLoader.loadClass(frqUserC.getName());\n    assertNotSame(frqUserC, sepFrqUserC);\n    assertSame(sepLoader, sepFrqUserC.getClassLoader());\n    Callable<?> sepFrqUser = (Callable<?>) sepFrqUserC.getDeclaredConstructor().newInstance();\n    WeakReference<?> finalizableWeakReference = (WeakReference<?>) sepFrqUser.call();\n    GcFinalization.awaitClear(finalizableWeakReference);\n    Field sepFrqUserFinalizedF = sepFrqUserC.getField(\"finalized\");\n    Semaphore finalizeCount = (Semaphore) sepFrqUserFinalizedF.get(null);\n    boolean finalized = finalizeCount.tryAcquire(5, TimeUnit.SECONDS);\n    assertTrue(finalized);\n    Field sepFrqUserFrqF = sepFrqUserC.getField(\"frq\");\n    Closeable frq = (Closeable) sepFrqUserFrqF.get(null);\n    frq.close();\n    return new WeakReference<ClassLoader>(sepLoader);\n}", "repo_id": "5", "comment": "// to null would also work, but only if there are no references to the FRQ anywhere else.)\n", "repo_name": "guava-master/", "id": 3689, "method_signature": "WeakReference<ClassLoader> doTestUnloadableInStaticFieldIfClosed()", "filename": "FinalizableReferenceQueueClassLoaderUnloadingTest.doTestUnloadableInStaticFieldIfClosed.json"}
{"callee_method_names": ["ImmutableList.Builder<URL>.add", "ImmutableList.Builder<URL>.add", "AssertionError.initCause", "ImmutableList.Builder<URL>.build"], "method_name": "FinalizableReferenceQueueClassLoaderUnloadingTest.parseJavaClassPath", "method_implementation": "{\n    ImmutableList.Builder<URL> urls = ImmutableList.builder();\n    for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n        try {\n            try {\n                urls.add(new File(entry).toURI().toURL());\n            } catch (SecurityException e) {\n                // File.toURI checks to see if the file is a directory\n                urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n            }\n        } catch (MalformedURLException e) {\n            AssertionError error = new AssertionError(\"malformed class path entry: \" + entry);\n            error.initCause(e);\n            throw error;\n        }\n    }\n    return urls.build();\n}", "repo_id": "5", "comment": "// TODO(b/65488446): Make this a public API.\n", "repo_name": "guava-master/", "id": 3690, "method_signature": "ImmutableList<URL> parseJavaClassPath()", "filename": "FinalizableReferenceQueueClassLoaderUnloadingTest.parseJavaClassPath.json"}
{"callee_method_names": [], "method_name": "FinalizableReferenceQueueClassLoaderUnloadingTest.testUnloadableWithSecurityManager", "method_implementation": "{\n    if (isJdk9OrHigher()) {\n        return;\n    }\n    Policy oldPolicy = Policy.getPolicy();\n    SecurityManager oldSecurityManager = System.getSecurityManager();\n    try {\n        Policy.setPolicy(new PermissivePolicy());\n        System.setSecurityManager(new SecurityManager());\n        doTestUnloadable();\n    } finally {\n        System.setSecurityManager(oldSecurityManager);\n        Policy.setPolicy(oldPolicy);\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the\n * loader of that class from being garbage-collected even if there is a {@link SecurityManager}.\n * The {@link SecurityManager} environment makes such leaks more likely because when you create a\n * {@link URLClassLoader} with a {@link SecurityManager}, the creating code's {@link\n * java.security.AccessControlContext} is captured, and that references the creating code's {@link\n * ClassLoader}.\n */\n", "repo_name": "guava-master/", "id": 3688, "method_signature": "void testUnloadableWithSecurityManager()", "filename": "FinalizableReferenceQueueClassLoaderUnloadingTest.testUnloadableWithSecurityManager.json"}
{"callee_method_names": [], "method_name": "FinalizableReferenceQueueClassLoaderUnloadingTest.testUnloadableWithoutSecurityManager", "method_implementation": "{\n    if (isJdk9OrHigher()) {\n        return;\n    }\n    SecurityManager oldSecurityManager = System.getSecurityManager();\n    try {\n        System.setSecurityManager(null);\n        doTestUnloadable();\n    } finally {\n        System.setSecurityManager(oldSecurityManager);\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the\n * loader of that class from being garbage-collected.\n */\n", "repo_name": "guava-master/", "id": 3687, "method_signature": "void testUnloadableWithoutSecurityManager()", "filename": "FinalizableReferenceQueueClassLoaderUnloadingTest.testUnloadableWithoutSecurityManager.json"}
{"callee_method_names": [], "method_name": "FinalizableReferenceQueueTest.weaklyReferenceQueue", "method_implementation": "{\n    frq = new FinalizableReferenceQueue();\n    queueReference = new WeakReference<>(frq.queue);\n    /*\n     * Queue and clear a reference for good measure. We test later on that\n     * the finalizer thread stopped, but we should test that it actually\n     * started first.\n     */\n    reference = new FinalizableWeakReference<Object>(new Object(), frq) {\n\n        @Override\n        public void finalizeReferent() {\n            reference = null;\n            frq = null;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Create the FRQ in a method that goes out of scope so that we're sure it will be reclaimed.\n */\n", "repo_name": "guava-master/", "id": 3699, "method_signature": "void weaklyReferenceQueue()", "filename": "FinalizableReferenceQueueTest.weaklyReferenceQueue.json"}
{"callee_method_names": ["ReferenceQueue<Object>.poll"], "method_name": "Finalizer.cleanUp", "method_implementation": "{\n    Method finalizeReferentMethod = getFinalizeReferentMethod();\n    if (finalizeReferentMethod == null) {\n        return false;\n    }\n    if (!finalizeReference(firstReference, finalizeReferentMethod)) {\n        return false;\n    }\n    /*\n     * Loop as long as we have references available so as not to waste CPU looking up the Method\n     * over and over again.\n     */\n    while (true) {\n        Reference<?> furtherReference = queue.poll();\n        if (furtherReference == null) {\n            return true;\n        }\n        if (!finalizeReference(furtherReference, finalizeReferentMethod)) {\n            return false;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Cleans up the given reference and any other references already in the queue. Catches and logs\n * all throwables.\n *\n * @return true if the caller should continue to wait for more references to be added to the\n *     queue, false if the associated FinalizableReferenceQueue is no longer referenced.\n */\n", "repo_name": "guava-master/", "id": 5129, "method_signature": "boolean cleanUp(Reference)", "filename": "Finalizer.cleanUp.json"}
{"callee_method_names": ["Reference<?>.clear", "Method.invoke", "Logger.log"], "method_name": "Finalizer.finalizeReference", "method_implementation": "{\n    /*\n     * This is for the benefit of phantom references. Weak and soft references will have already\n     * been cleared by this point.\n     */\n    reference.clear();\n    if (reference == frqReference) {\n        /*\n       * The client no longer has a reference to the FinalizableReferenceQueue. We can stop.\n       */\n        return false;\n    }\n    try {\n        finalizeReferentMethod.invoke(reference);\n    } catch (Throwable t) {\n        logger.log(Level.SEVERE, \"Error cleaning up after reference.\", t);\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Cleans up the given reference. Catches and logs all throwables.\n *\n * @return true if the caller should continue to clean up references from the queue, false if the\n *     associated FinalizableReferenceQueue is no longer referenced.\n */\n", "repo_name": "guava-master/", "id": 5130, "method_signature": "boolean finalizeReference(Reference, Method)", "filename": "Finalizer.finalizeReference.json"}
{"callee_method_names": ["WeakReference<Class<?>>.get", "Class<?>.getMethod"], "method_name": "Finalizer.getFinalizeReferentMethod", "method_implementation": "{\n    Class<?> finalizableReferenceClass = finalizableReferenceClassReference.get();\n    if (finalizableReferenceClass == null) {\n        /*\n       * FinalizableReference's class loader was reclaimed. While there's a chance that other\n       * finalizable references could be enqueued subsequently (at which point the class loader\n       * would be resurrected by virtue of us having a strong reference to it), we should pretty\n       * much just shut down and make sure we don't keep it alive any longer than necessary.\n       */\n        return null;\n    }\n    try {\n        return finalizableReferenceClass.getMethod(\"finalizeReferent\");\n    } catch (NoSuchMethodException e) {\n        throw new AssertionError(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Looks up FinalizableReference.finalizeReferent() method.\n */\n", "repo_name": "guava-master/", "id": 5131, "method_signature": "Method getFinalizeReferentMethod()", "filename": "Finalizer.getFinalizeReferentMethod.json"}
{"callee_method_names": ["ReferenceQueue<Object>.remove"], "method_name": "Finalizer.run", "method_implementation": "{\n    while (true) {\n        try {\n            if (!cleanUp(queue.remove())) {\n                break;\n            }\n        } catch (InterruptedException e) {\n            // ignore\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Loops continuously, pulling references off the queue and cleaning them up.\n */\n", "repo_name": "guava-master/", "id": 5128, "method_signature": "void run()", "filename": "Finalizer.run.json"}
{"callee_method_names": ["Class<?>.getName", "Constructor<Thread>.newInstance", "Logger.log", "Thread.setDaemon", "Field.set", "Logger.log", "Thread.start"], "method_name": "Finalizer.startFinalizer", "method_implementation": "{\n    /*\n     * We use FinalizableReference.class for two things:\n     *\n     * 1) To invoke FinalizableReference.finalizeReferent()\n     *\n     * 2) To detect when FinalizableReference's class loader has to be garbage collected, at which\n     * point, Finalizer can stop running\n     */\n    if (!finalizableReferenceClass.getName().equals(FINALIZABLE_REFERENCE)) {\n        throw new IllegalArgumentException(\"Expected \" + FINALIZABLE_REFERENCE + \".\");\n    }\n    Finalizer finalizer = new Finalizer(finalizableReferenceClass, queue, frqReference);\n    String threadName = Finalizer.class.getName();\n    Thread thread = null;\n    if (bigThreadConstructor != null) {\n        try {\n            boolean inheritThreadLocals = false;\n            long defaultStackSize = 0;\n            thread = bigThreadConstructor.newInstance((ThreadGroup) null, finalizer, threadName, defaultStackSize, inheritThreadLocals);\n        } catch (Throwable t) {\n            logger.log(Level.INFO, \"Failed to create a thread without inherited thread-local values\", t);\n        }\n    }\n    if (thread == null) {\n        thread = new Thread((ThreadGroup) null, finalizer, threadName);\n    }\n    thread.setDaemon(true);\n    try {\n        if (inheritableThreadLocals != null) {\n            inheritableThreadLocals.set(thread, null);\n        }\n    } catch (Throwable t) {\n        logger.log(Level.INFO, \"Failed to clear thread local values inherited by reference finalizer thread.\", t);\n    }\n    thread.start();\n}", "repo_id": "5", "comment": "/**\n * Starts the Finalizer thread. FinalizableReferenceQueue calls this method reflectively.\n *\n * @param finalizableReferenceClass FinalizableReference.class.\n * @param queue a reference queue that the thread will poll.\n * @param frqReference a phantom reference to the FinalizableReferenceQueue, which will be queued\n *     either when the FinalizableReferenceQueue is no longer referenced anywhere, or when its\n *     close() method is called.\n */\n", "repo_name": "guava-master/", "id": 5127, "method_signature": "void startFinalizer(Class, ReferenceQueue, PhantomReference)", "filename": "Finalizer.startFinalizer.json"}
{"callee_method_names": [], "method_name": "Fingerprint2011.fullFingerprint", "method_implementation": "{\n    // For lengths over 64 bytes we hash the end first, and then as we\n    // loop we keep 56 bytes of state: v, w, x, y, and z.\n    long x = load64(bytes, offset);\n    long y = load64(bytes, offset + length - 16) ^ K1;\n    long z = load64(bytes, offset + length - 56) ^ K0;\n    long[] v = new long[2];\n    long[] w = new long[2];\n    weakHashLength32WithSeeds(bytes, offset + length - 64, length, y, v);\n    weakHashLength32WithSeeds(bytes, offset + length - 32, length * K1, K0, w);\n    z += shiftMix(v[1]) * K1;\n    x = rotateRight(z + x, 39) * K1;\n    y = rotateRight(y, 33) * K1;\n    // Decrease length to the nearest multiple of 64, and operate on 64-byte chunks.\n    length = (length - 1) & ~63;\n    do {\n        x = rotateRight(x + y + v[0] + load64(bytes, offset + 16), 37) * K1;\n        y = rotateRight(y + v[1] + load64(bytes, offset + 48), 42) * K1;\n        x ^= w[1];\n        y ^= v[0];\n        z = rotateRight(z ^ w[0], 33);\n        weakHashLength32WithSeeds(bytes, offset, v[1] * K1, x + w[0], v);\n        weakHashLength32WithSeeds(bytes, offset + 32, z + w[1], y, w);\n        long tmp = z;\n        z = x;\n        x = tmp;\n        offset += 64;\n        length -= 64;\n    } while (length != 0);\n    return hash128to64(hash128to64(v[0], w[0]) + shiftMix(y) * K1 + z, hash128to64(v[1], w[1]) + x);\n}", "repo_id": "5", "comment": "/*\n   * Compute an 8-byte hash of a byte array of length greater than 64 bytes.\n   */\n", "repo_name": "guava-master/", "id": 5215, "method_signature": "long fullFingerprint(byte[], int, int)", "filename": "Fingerprint2011.fullFingerprint.json"}
{"callee_method_names": [], "method_name": "Fingerprint2011.hash128to64", "method_implementation": "{\n    long a = (low ^ high) * K3;\n    a ^= (a >>> 47);\n    long b = (high ^ a) * K3;\n    b ^= (b >>> 47);\n    b *= K3;\n    return b;\n}", "repo_id": "5", "comment": "/**\n * Implementation of Hash128to64 from util/hash/hash128to64.h\n */\n", "repo_name": "guava-master/", "id": 5213, "method_signature": "long hash128to64(long, long)", "filename": "Fingerprint2011.hash128to64.json"}
{"callee_method_names": [], "method_name": "Fingerprint2011.weakHashLength32WithSeeds", "method_implementation": "{\n    long part1 = load64(bytes, offset);\n    long part2 = load64(bytes, offset + 8);\n    long part3 = load64(bytes, offset + 16);\n    long part4 = load64(bytes, offset + 24);\n    seedA += part1;\n    seedB = rotateRight(seedB + seedA + part4, 51);\n    long c = seedA;\n    seedA += part2;\n    seedA += part3;\n    seedB += rotateRight(seedA, 23);\n    output[0] = seedA + part4;\n    output[1] = seedB + c;\n}", "repo_id": "5", "comment": "/**\n * Computes intermediate hash of 32 bytes of byte array from the given offset. Results are\n * returned in the output array - this is 12% faster than allocating new arrays every time.\n */\n", "repo_name": "guava-master/", "id": 5214, "method_signature": "void weakHashLength32WithSeeds(byte[], int, long, long, long[])", "filename": "Fingerprint2011.weakHashLength32WithSeeds.json"}
{"callee_method_names": [], "method_name": "Fingerprint2011Test.testMultipleLengths", "method_implementation": "{\n    int iterations = 800;\n    byte[] buf = new byte[iterations * 4];\n    int bufLen = 0;\n    long h = 0;\n    for (int i = 0; i < iterations; ++i) {\n        h ^= fingerprint(buf, i);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        h ^= fingerprint(buf, i * i % bufLen);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        h ^= fingerprint(buf, i * i * i % bufLen);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        h ^= fingerprint(buf, bufLen);\n        h = remix(h);\n        buf[bufLen++] = getChar(h);\n        int x0 = buf[bufLen - 1] & 0xff;\n        int x1 = buf[bufLen - 2] & 0xff;\n        int x2 = buf[bufLen - 3] & 0xff;\n        int x3 = buf[bufLen / 2] & 0xff;\n        buf[((x0 << 16) + (x1 << 8) + x2) % bufLen] ^= x3;\n        buf[((x1 << 16) + (x2 << 8) + x3) % bufLen] ^= i % 256;\n    }\n    assertEquals(0xeaa3b1c985261632L, h);\n}", "repo_id": "5", "comment": "/**\n * Tests that the Java port of Fingerprint2011 provides the same results on buffers up to 800\n * bytes long as the original implementation in C++. See http://cl/106539598\n */\n", "repo_name": "guava-master/", "id": 3742, "method_signature": "void testMultipleLengths()", "filename": "Fingerprint2011Test.testMultipleLengths.json"}
{"callee_method_names": [], "method_name": "Fingerprint2011Test.testReallySimpleFingerprints", "method_implementation": "{\n    assertEquals(8473225671271759044L, fingerprint(\"test\".getBytes(UTF_8)));\n    // 32 characters long\n    assertEquals(7345148637025587076L, fingerprint(Strings.repeat(\"test\", 8).getBytes(UTF_8)));\n    // 256 characters long\n    assertEquals(4904844928629814570L, fingerprint(Strings.repeat(\"test\", 64).getBytes(UTF_8)));\n}", "repo_id": "5", "comment": "// If this test fails, all bets are off\n", "repo_name": "guava-master/", "id": 3741, "method_signature": "void testReallySimpleFingerprints()", "filename": "Fingerprint2011Test.testReallySimpleFingerprints.json"}
{"callee_method_names": [], "method_name": "Floats.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new FloatArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>The returned list maintains the values, but not the identities, of {@code Float} objects\n * written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for\n * the returned list is unspecified.\n *\n * <p>The returned list may have unexpected behavior if it contains {@code NaN}, or if {@code NaN}\n * is used as a parameter to any of its methods.\n *\n * <p>The returned list is serializable.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4491, "method_signature": "List<Float> asList(float[])", "filename": "Floats.asList.json"}
{"callee_method_names": [], "method_name": "Floats.concat", "method_implementation": "{\n    int length = 0;\n    for (float[] array : arrays) {\n        length += array.length;\n    }\n    float[] result = new float[length];\n    int pos = 0;\n    for (float[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new float[] {a, b}, new float[] {}, new float[] {c}} returns the array {@code {a, b,\n * c}}.\n *\n * @param arrays zero or more {@code float} arrays\n * @return a single array containing all the values from the source arrays, in order\n */\n", "repo_name": "guava-master/", "id": 4484, "method_signature": "float[] concat(float[][])", "filename": "Floats.concat.json"}
{"callee_method_names": [], "method_name": "Floats.constrainToRange", "method_implementation": "{\n    // avoid auto-boxing by not using Preconditions.checkArgument(); see Guava issue 3984\n    // Reject NaN by testing for the good case (min <= max) instead of the bad (min > max).\n    if (min <= max) {\n        return Math.min(Math.max(value, min), max);\n    }\n    throw new IllegalArgumentException(lenientFormat(\"min (%s) must be less than or equal to max (%s)\", min, max));\n}", "repo_id": "5", "comment": "/**\n * Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.\n *\n * <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned\n * unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code\n * value} is greater than {@code max}, {@code max} is returned.\n *\n * @param value the {@code float} value to constrain\n * @param min the lower bound (inclusive) of the range to constrain {@code value} to\n * @param max the upper bound (inclusive) of the range to constrain {@code value} to\n * @throws IllegalArgumentException if {@code min > max}\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 4483, "method_signature": "float constrainToRange(float, float, float)", "filename": "Floats.constrainToRange.json"}
{"callee_method_names": [], "method_name": "Floats.contains", "method_implementation": "{\n    for (float value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}. Note\n * that this always returns {@code false} when {@code target} is {@code NaN}.\n *\n * @param array an array of {@code float} values, possibly empty\n * @param target a primitive {@code float} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4477, "method_signature": "boolean contains(float[], float)", "filename": "Floats.contains.json"}
{"callee_method_names": [], "method_name": "Floats.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4485, "method_signature": "float[] ensureCapacity(float[], int, int)", "filename": "Floats.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Floats.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * <p>Note that this always returns {@code -1} when {@code target} contains {@code NaN}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4479, "method_signature": "int indexOf(float[], float[])", "filename": "Floats.indexOf.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Floats.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 12);\n    builder.append(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code float} values, converted to strings as\n * specified by {@link Float#toString(float)}, and separated by {@code separator}. For example,\n * {@code join(\"-\", 1.0f, 2.0f, 3.0f)} returns the string {@code \"1.0-2.0-3.0\"}.\n *\n * <p>Note that {@link Float#toString(float)} formats {@code float} differently in GWT. In the\n * previous example, it returns the string {@code \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code float} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4486, "method_signature": "String join(String, float[])", "filename": "Floats.join.json"}
{"callee_method_names": [], "method_name": "Floats.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4480, "method_signature": "int lastIndexOf(float[], float, int, int)", "filename": "Floats.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Floats.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    float max = array[0];\n    for (int i = 1; i < array.length; i++) {\n        max = Math.max(max, array[i]);\n    }\n    return max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}, using the same rules of comparison as\n * {@link Math#max(float, float)}.\n *\n * @param array a <i>nonempty</i> array of {@code float} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4482, "method_signature": "float max(float[])", "filename": "Floats.max.json"}
{"callee_method_names": [], "method_name": "Floats.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    float min = array[0];\n    for (int i = 1; i < array.length; i++) {\n        min = Math.min(min, array[i]);\n    }\n    return min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}, using the same rules of comparison as {@link\n * Math#min(float, float)}.\n *\n * @param array a <i>nonempty</i> array of {@code float} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4481, "method_signature": "float min(float[])", "filename": "Floats.min.json"}
{"callee_method_names": [], "method_name": "Floats.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        float tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Floats.asList(array).subList(fromIndex, toIndex))}, but is likely to be\n * more efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4488, "method_signature": "void reverse(float[], int, int)", "filename": "Floats.reverse.json"}
{"callee_method_names": [], "method_name": "Floats.rotate", "method_implementation": "{\n    // See Ints.rotate for more details about possible algorithms here.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Floats.asList(array).subList(fromIndex, toIndex), distance)}, but is\n * considerably faster and avoids allocations and garbage collection.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4489, "method_signature": "void rotate(float[], int, int, int)", "filename": "Floats.rotate.json"}
{"callee_method_names": [], "method_name": "Floats.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    Arrays.sort(array, fromIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order.\n *\n * <p>Note that this method uses the total order imposed by {@link Float#compare}, which treats\n * all NaN values as equal and 0.0 as greater than -0.0.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4487, "method_signature": "void sortDescending(float[], int, int)", "filename": "Floats.sortDescending.json"}
{"callee_method_names": ["Collection<? extends Number>.toArray"], "method_name": "Floats.toArray", "method_implementation": "{\n    if (collection instanceof FloatArrayAsList) {\n        return ((FloatArrayAsList) collection).toFloatArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    float[] array = new float[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = ((Number) checkNotNull(boxedArray[i])).floatValue();\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing each value of {@code collection}, converted to a {@code float}\n * value in the manner of {@link Number#floatValue}.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * @param collection a collection of {@code Number} instances\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n * @since 1.0 (parameter was {@code Collection<Float>} before 12.0)\n */\n", "repo_name": "guava-master/", "id": 4490, "method_signature": "float[] toArray(Collection)", "filename": "Floats.toArray.json"}
{"callee_method_names": [], "method_name": "Floats.tryParse", "method_implementation": "{\n    if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {\n        // TODO(lowasser): could be potentially optimized, but only with\n        // extensive testing\n        try {\n            return Float.parseFloat(string);\n        } catch (NumberFormatException e) {\n            // Float.parseFloat has changed specs several times, so fall through\n            // gracefully\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Parses the specified string as a single-precision floating point value. The ASCII character\n * {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.\n *\n * <p>Unlike {@link Float#parseFloat(String)}, this method returns {@code null} instead of\n * throwing an exception if parsing fails. Valid inputs are exactly those accepted by {@link\n * Float#valueOf(String)}, except that leading and trailing whitespace is not permitted.\n *\n * <p>This implementation is likely to be faster than {@code Float.parseFloat} if many failures\n * are expected.\n *\n * @param string the string representation of a {@code float} value\n * @return the floating point value represented by {@code string}, or {@code null} if {@code\n *     string} has a length of zero or cannot be parsed as a {@code float} value\n * @throws NullPointerException if {@code string} is {@code null}\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4492, "method_signature": "Float tryParse(String)", "filename": "Floats.tryParse.json"}
{"callee_method_names": ["String.trim", "String.length"], "method_name": "FloatsTest.referenceTryParse", "method_implementation": "{\n    if (input.trim().length() < input.length()) {\n        return null;\n    }\n    try {\n        return Float.valueOf(input);\n    } catch (NumberFormatException e) {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * A reference implementation for {@code tryParse} that just catches the exception from {@link\n * Float#valueOf}.\n */\n", "repo_name": "guava-master/", "id": 3551, "method_signature": "Float referenceTryParse(String)", "filename": "FloatsTest.referenceTryParse.json"}
{"callee_method_names": ["List<Float>.subList", "List<Float>.subList"], "method_name": "FloatsTest.testAsList_subList_toArray_roundTrip", "method_implementation": "{\n    float[] array = { (float) 0, (float) 1, (float) 2, (float) 3 };\n    List<Float> list = Floats.asList(array);\n    assertThat(Floats.toArray(list.subList(1, 3))).isEqualTo(new float[] { (float) 1, (float) 2 });\n    assertThat(Floats.toArray(list.subList(2, 2))).isEmpty();\n}", "repo_id": "5", "comment": "// This test stems from a real bug found by andrewk\n", "repo_name": "guava-master/", "id": 3550, "method_signature": "void testAsList_subList_toArray_roundTrip()", "filename": "FloatsTest.testAsList_subList_toArray_roundTrip.json"}
{"callee_method_names": [], "method_name": "FluentFuture.catching", "method_implementation": "{\n    return (FluentFuture<V>) Futures.catching(this, exceptionType, fallback, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Future} whose result is taken from this {@code Future} or, if this {@code\n * Future} fails with the given {@code exceptionType}, from the result provided by the {@code\n * fallback}. {@link Function#apply} is not invoked until the primary input has failed, so if the\n * primary input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n * exception is thrown, this exception is used as the result of the output {@code Future}.\n *\n * <p>Usage example:\n *\n * <pre>{@code\n * // Falling back to a zero counter in case an exception happens when processing the RPC to fetch\n * // counters.\n * ListenableFuture<Integer> faultTolerantFuture =\n *     fetchCounters().catching(FetchException.class, x -> 0, directExecutor());\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n * listeners are also applicable to heavyweight functions passed to this method.\n *\n * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It\n * can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}\n * and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link\n * #transform}.\n *\n * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n *     type is matched against the input's exception. \"The input's exception\" means the cause of\n *     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a\n *     different kind of exception, that exception itself. To avoid hiding bugs and other\n *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n *     Throwable.class} in particular.\n * @param fallback the {@link Function} to be called if the input fails with the expected\n *     exception type. The function's argument is the input's exception. \"The input's exception\"\n *     means the cause of the {@link ExecutionException} thrown by {@code this.get()} or, if\n *     {@code get()} throws a different kind of exception, that exception itself.\n * @param executor the executor that runs {@code fallback} if the input fails\n */\n", "repo_name": "guava-master/", "id": 5358, "method_signature": "FluentFuture<V> catching(Class, Function, Executor)", "filename": "FluentFuture.catching.json"}
{"callee_method_names": [], "method_name": "FluentFuture.catchingAsync", "method_implementation": "{\n    return (FluentFuture<V>) Futures.catchingAsync(this, exceptionType, fallback, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Future} whose result is taken from this {@code Future} or, if this {@code\n * Future} fails with the given {@code exceptionType}, from the result provided by the {@code\n * fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has failed, so if\n * the primary input succeeds, it is never invoked. If, during the invocation of {@code fallback},\n * an exception is thrown, this exception is used as the result of the output {@code Future}.\n *\n * <p>Usage examples:\n *\n * <pre>{@code\n * // Falling back to a zero counter in case an exception happens when processing the RPC to fetch\n * // counters.\n * ListenableFuture<Integer> faultTolerantFuture =\n *     fetchCounters().catchingAsync(\n *         FetchException.class, x -> immediateFuture(0), directExecutor());\n * }</pre>\n *\n * <p>The fallback can also choose to propagate the original exception when desired:\n *\n * <pre>{@code\n * // Falling back to a zero counter only in case the exception was a\n * // TimeoutException.\n * ListenableFuture<Integer> faultTolerantFuture =\n *     fetchCounters().catchingAsync(\n *         FetchException.class,\n *         e -> {\n *           if (omitDataOnFetchFailure) {\n *             return immediateFuture(0);\n *           }\n *           throw e;\n *         },\n *         directExecutor());\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n * listeners are also applicable to heavyweight functions passed to this method. (Specifically,\n * {@code directExecutor} functions should avoid heavyweight operations inside {@code\n * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n * completing the returned {@code Future}.)\n *\n * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It\n * can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}\n * and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link\n * #transform}.\n *\n * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n *     type is matched against the input's exception. \"The input's exception\" means the cause of\n *     the {@link ExecutionException} thrown by {@code this.get()} or, if {@code get()} throws a\n *     different kind of exception, that exception itself. To avoid hiding bugs and other\n *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n *     Throwable.class} in particular.\n * @param fallback the {@link AsyncFunction} to be called if the input fails with the expected\n *     exception type. The function's argument is the input's exception. \"The input's exception\"\n *     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if\n *     {@code get()} throws a different kind of exception, that exception itself.\n * @param executor the executor that runs {@code fallback} if the input fails\n */\n", "repo_name": "guava-master/", "id": 5359, "method_signature": "FluentFuture<V> catchingAsync(Class, AsyncFunction, Executor)", "filename": "FluentFuture.catchingAsync.json"}
{"callee_method_names": [], "method_name": "FluentFuture.from", "method_implementation": "{\n    return future instanceof FluentFuture ? (FluentFuture<V>) future : new ForwardingFluentFuture<V>(future);\n}", "repo_id": "5", "comment": "/**\n * Converts the given {@code ListenableFuture} to an equivalent {@code FluentFuture}.\n *\n * <p>If the given {@code ListenableFuture} is already a {@code FluentFuture}, it is returned\n * directly. If not, it is wrapped in a {@code FluentFuture} that delegates all calls to the\n * original {@code ListenableFuture}.\n */\n", "repo_name": "guava-master/", "id": 5357, "method_signature": "FluentFuture<V> from(ListenableFuture)", "filename": "FluentFuture.from.json"}
{"callee_method_names": [], "method_name": "FluentFuture.withTimeout", "method_implementation": "{\n    return (FluentFuture<V>) Futures.withTimeout(this, timeout, unit, scheduledExecutor);\n}", "repo_id": "5", "comment": "/**\n * Returns a future that delegates to this future but will finish early (via a {@link\n * TimeoutException} wrapped in an {@link ExecutionException}) if the specified timeout expires.\n * If the timeout expires, not only will the output future finish, but also the input future\n * ({@code this}) will be cancelled and interrupted.\n *\n * @param timeout when to time out the future\n * @param unit the time unit of the time parameter\n * @param scheduledExecutor The executor service to enforce the timeout.\n */\n", "repo_name": "guava-master/", "id": 5360, "method_signature": "FluentFuture<V> withTimeout(long, TimeUnit, ScheduledExecutorService)", "filename": "FluentFuture.withTimeout.json"}
{"callee_method_names": ["Iterable<? extends Iterable<? extends T>>.iterator"], "method_name": "FluentIterable.concat", "method_implementation": "{\n    checkNotNull(inputs);\n    return new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return Iterators.concat(Iterators.transform(inputs.iterator(), Iterable::iterator));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a fluent iterable that combines several iterables. The returned iterable has an\n * iterator that traverses the elements of each iterable in {@code inputs}. The input iterators\n * are not polled until necessary.\n *\n * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n * iterator supports it. The methods of the returned iterable may throw {@code\n * NullPointerException} if any of the input iterators is {@code null}.\n *\n * <p><b>{@code Stream} equivalent:</b> {@code streamOfStreams.flatMap(s -> s)} or {@code\n * streamOfIterables.flatMap(Streams::stream)}. (See {@link Streams#stream}.)\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 6403, "method_signature": "FluentIterable<T> concat(Iterable)", "filename": "FluentIterable.concat.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator"], "method_name": "FluentIterable.concatNoDefensiveCopy", "method_implementation": "{\n    for (Iterable<? extends T> input : inputs) {\n        checkNotNull(input);\n    }\n    return new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return Iterators.concat(/* lazily generate the iterators on each input only as needed */\n            new AbstractIndexedListIterator<Iterator<? extends T>>(inputs.length) {\n\n                @Override\n                public Iterator<? extends T> get(int i) {\n                    return inputs[i].iterator();\n                }\n            });\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Concatenates a varargs array of iterables without making a defensive copy of the array.\n */\n", "repo_name": "guava-master/", "id": 6404, "method_signature": "FluentIterable<T> concatNoDefensiveCopy(Iterable<? extends T>[])", "filename": "FluentIterable.concatNoDefensiveCopy.json"}
{"callee_method_names": ["C.addAll", "C.add"], "method_name": "FluentIterable.copyInto", "method_implementation": "{\n    checkNotNull(collection);\n    Iterable<E> iterable = getDelegate();\n    if (iterable instanceof Collection) {\n        collection.addAll((Collection<E>) iterable);\n    } else {\n        for (E item : iterable) {\n            collection.add(item);\n        }\n    }\n    return collection;\n}", "repo_id": "5", "comment": "/**\n * Copies all the elements from this fluent iterable to {@code collection}. This is equivalent to\n * calling {@code Iterables.addAll(collection, this)}.\n *\n * <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or {@code\n * stream.forEach(collection::add)}.\n *\n * @param collection the collection to copy elements to\n * @return {@code collection}, for convenience\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6407, "method_signature": "C copyInto(C)", "filename": "FluentIterable.copyInto.json"}
{"callee_method_names": ["Iterator<E>.hasNext", "Iterator<E>.next"], "method_name": "FluentIterable.first", "method_implementation": "{\n    Iterator<E> iterator = getDelegate().iterator();\n    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.absent();\n}", "repo_id": "5", "comment": "/**\n * Returns an {@link Optional} containing the first element in this fluent iterable. If the\n * iterable is empty, {@code Optional.absent()} is returned.\n *\n * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@link\n * Stream#findAny}; if it must specifically be the <i>first</i> element, {@code Stream#findFirst}.\n *\n * @throws NullPointerException if the first element is null; if this is a possibility, use {@code\n *     iterator().next()} or {@link Iterables#getFirst} instead.\n */\n", "repo_name": "guava-master/", "id": 6405, "method_signature": "Optional<E> first()", "filename": "FluentIterable.first.json"}
{"callee_method_names": [], "method_name": "FluentIterable.from", "method_implementation": "{\n    return checkNotNull(iterable);\n}", "repo_id": "5", "comment": "/**\n * Construct a fluent iterable from another fluent iterable. This is obviously never necessary,\n * but is intended to help call out cases where one migration from {@code Iterable} to {@code\n * FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.\n *\n * @deprecated instances of {@code FluentIterable} don't need to be converted to {@code\n *     FluentIterable}\n */\n", "repo_name": "guava-master/", "id": 6401, "method_signature": "FluentIterable<E> from(FluentIterable)", "filename": "FluentIterable.from.json"}
{"callee_method_names": ["List<E>.isEmpty", "List<E>.get", "List<E>.size", "Iterable<E>.iterator", "Iterator<E>.hasNext", "SortedSet<E>.last", "Iterator<E>.next", "Iterator<E>.hasNext"], "method_name": "FluentIterable.last", "method_implementation": "{\n    // Iterables#getLast was inlined here so we don't have to throw/catch a NSEE\n    // TODO(kevinb): Support a concurrently modified collection?\n    Iterable<E> iterable = getDelegate();\n    if (iterable instanceof List) {\n        List<E> list = (List<E>) iterable;\n        if (list.isEmpty()) {\n            return Optional.absent();\n        }\n        return Optional.of(list.get(list.size() - 1));\n    }\n    Iterator<E> iterator = iterable.iterator();\n    if (!iterator.hasNext()) {\n        return Optional.absent();\n    }\n    /*\n     * TODO(kevinb): consider whether this \"optimization\" is worthwhile. Users with SortedSets tend\n     * to know they are SortedSets and probably would not call this method.\n     */\n    if (iterable instanceof SortedSet) {\n        SortedSet<E> sortedSet = (SortedSet<E>) iterable;\n        return Optional.of(sortedSet.last());\n    }\n    while (true) {\n        E current = iterator.next();\n        if (!iterator.hasNext()) {\n            return Optional.of(current);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an {@link Optional} containing the last element in this fluent iterable. If the\n * iterable is empty, {@code Optional.absent()} is returned. If the underlying {@code iterable} is\n * a {@link List} with {@link java.util.RandomAccess} support, then this operation is guaranteed\n * to be {@code O(1)}.\n *\n * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}.\n *\n * @throws NullPointerException if the last element is null; if this is a possibility, use {@link\n *     Iterables#getLast} instead.\n */\n", "repo_name": "guava-master/", "id": 6406, "method_signature": "Optional<E> last()", "filename": "FluentIterable.last.json"}
{"callee_method_names": [], "method_name": "FluentIterableTest.testConcatIntersectionType", "method_implementation": "{\n    Iterable<A> aIterable = ImmutableList.of();\n    Iterable<B> bIterable = ImmutableList.of();\n    Predicate<X> xPredicate = Predicates.alwaysTrue();\n    Predicate<Y> yPredicate = Predicates.alwaysTrue();\n    FluentIterable<?> unused = FluentIterable.concat(aIterable, bIterable).filter(xPredicate).filter(yPredicate);\n    /* The following fails to compile:\n     *\n     * The method append(Iterable<? extends FluentIterableTest.A>) in the type\n     * FluentIterable<FluentIterableTest.A> is not applicable for the arguments\n     * (Iterable<FluentIterableTest.B>)\n     */\n    // FluentIterable.from(aIterable).append(bIterable);\n    /* The following fails to compile:\n     *\n     * The method filter(Predicate<? super Object>) in the type FluentIterable<Object> is not\n     * applicable for the arguments (Predicate<FluentIterableTest.X>)\n     */\n    // FluentIterable.of().append(aIterable).append(bIterable).filter(xPredicate);\n}", "repo_id": "5", "comment": "/**\n * This test passes if the {@code concat(\u2026).filter(\u2026).filter(\u2026)} statement at the end compiles.\n * That statement compiles only if {@link FluentIterable#concat concat(aIterable, bIterable)}\n * returns a {@link FluentIterable} of elements of an anonymous type whose supertypes are the <a\n * href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.9\">intersection</a> of\n * the supertypes of {@code A} and the supertypes of {@code B}.\n */\n", "repo_name": "guava-master/", "id": 3982, "method_signature": "void testConcatIntersectionType()", "filename": "FluentIterableTest.testConcatIntersectionType.json"}
{"callee_method_names": ["List<Integer>.add", "List<List<Integer>>.add", "FluentIterable<Integer>.toString"], "method_name": "FluentIterableTest.testConcatIterable", "method_implementation": "{\n    List<Integer> list1 = newArrayList(1);\n    List<Integer> list2 = newArrayList(4);\n    List<List<Integer>> input = newArrayList(list1, list2);\n    FluentIterable<Integer> result = FluentIterable.concat(input);\n    assertEquals(asList(1, 4), newArrayList(result));\n    // Now change the inputs and see result dynamically change as well\n    list1.add(2);\n    List<Integer> list3 = newArrayList(3);\n    input.add(1, list3);\n    assertEquals(asList(1, 2, 3, 4), newArrayList(result));\n    assertEquals(\"[1, 2, 3, 4]\", result.toString());\n}", "repo_id": "5", "comment": "// Exhaustive tests are in IteratorsTest. These are copied from IterablesTest.\n", "repo_name": "guava-master/", "id": 3981, "method_signature": "void testConcatIterable()", "filename": "FluentIterableTest.testConcatIterable.json"}
{"callee_method_names": [], "method_name": "FluentIterableTest.testStream", "method_implementation": "{\n    assertThat(FluentIterable.of().stream()).isEmpty();\n    assertThat(FluentIterable.of(\"a\").stream()).containsExactly(\"a\");\n    assertThat(FluentIterable.of(1, 2, 3).stream().filter(n -> n > 1)).containsExactly(2, 3);\n}", "repo_id": "5", "comment": "/*\n   * Full and proper black-box testing of a Stream-returning method is extremely involved, and is\n   * overkill when nearly all Streams are produced using well-tested JDK calls. So, we cheat and\n   * just test that the toArray() contents are as expected.\n   */\n", "repo_name": "guava-master/", "id": 525, "method_signature": "void testStream()", "filename": "FluentIterableTest.testStream.json"}
{"callee_method_names": ["Flushable.flush", "Logger.log"], "method_name": "Flushables.flush", "method_implementation": "{\n    try {\n        flushable.flush();\n    } catch (IOException e) {\n        if (swallowIOException) {\n            logger.log(Level.WARNING, \"IOException thrown while flushing Flushable.\", e);\n        } else {\n            throw e;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Flush a {@link Flushable}, with control over whether an {@code IOException} may be thrown.\n *\n * <p>If {@code swallowIOException} is true, then we don't rethrow {@code IOException}, but merely\n * log it.\n *\n * @param flushable the {@code Flushable} object to be flushed.\n * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code flush}\n *     method\n * @throws IOException if {@code swallowIOException} is false and {@link Flushable#flush} throws\n *     an {@code IOException}.\n * @see Closeables#close\n */\n", "repo_name": "guava-master/", "id": 4738, "method_signature": "void flush(Flushable, boolean)", "filename": "Flushables.flush.json"}
{"callee_method_names": ["Logger.log"], "method_name": "Flushables.flushQuietly", "method_implementation": "{\n    try {\n        flush(flushable, true);\n    } catch (IOException e) {\n        logger.log(Level.SEVERE, \"IOException should not have been thrown.\", e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Equivalent to calling {@code flush(flushable, true)}, but with no {@code IOException} in the\n * signature.\n *\n * @param flushable the {@code Flushable} object to be flushed.\n */\n", "repo_name": "guava-master/", "id": 4739, "method_signature": "void flushQuietly(Flushable)", "filename": "Flushables.flushQuietly.json"}
{"callee_method_names": [], "method_name": "FlushablesTest.doFlush", "method_implementation": "{\n    try {\n        Flushables.flush(flushable, swallowException);\n        if (expectThrown) {\n            fail(\"Didn't throw exception.\");\n        }\n    } catch (IOException e) {\n        if (!expectThrown) {\n            fail(\"Threw exception\");\n        }\n    }\n    verify(flushable).flush();\n}", "repo_id": "5", "comment": "// be thrown by Flushables.flush;\n", "repo_name": "guava-master/", "id": 3635, "method_signature": "void doFlush(Flushable, boolean, boolean)", "filename": "FlushablesTest.doFlush.json"}
{"callee_method_names": [], "method_name": "FlushablesTest.setupFlushable", "method_implementation": "{\n    mockFlushable = mock(Flushable.class);\n    if (shouldThrowOnFlush) {\n        doThrow(new IOException(\"This should only appear in the \" + \"logs. It should not be rethrown.\")).when(mockFlushable).flush();\n    }\n}", "repo_id": "5", "comment": "// throw an exception.\n", "repo_name": "guava-master/", "id": 3634, "method_signature": "void setupFlushable(boolean)", "filename": "FlushablesTest.setupFlushable.json"}
{"callee_method_names": [], "method_name": "ForwardingCache.getAllPresent", "method_implementation": "{\n    return delegate().getAllPresent(keys);\n}", "repo_id": "5", "comment": "/**\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4865, "method_signature": "ImmutableMap<K,V> getAllPresent(Iterable)", "filename": "ForwardingCache.getAllPresent.json"}
{"callee_method_names": [], "method_name": "ForwardingCache.getIfPresent", "method_implementation": "{\n    return delegate().getIfPresent(key);\n}", "repo_id": "5", "comment": "/**\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4864, "method_signature": "V getIfPresent(Object)", "filename": "ForwardingCache.getIfPresent.json"}
{"callee_method_names": [], "method_name": "ForwardingCache.invalidateAll", "method_implementation": "{\n    delegate().invalidateAll(keys);\n}", "repo_id": "5", "comment": "/**\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4866, "method_signature": "void invalidateAll(Iterable)", "filename": "ForwardingCache.invalidateAll.json"}
{"callee_method_names": ["Iterator<E>.hasNext", "Iterator<E>.next", "Iterator<E>.remove"], "method_name": "ForwardingCollection.standardRemove", "method_implementation": "{\n    Iterator<E> iterator = iterator();\n    while (iterator.hasNext()) {\n        if (Objects.equal(iterator.next(), object)) {\n            iterator.remove();\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #remove} in terms of {@link #iterator}, using the iterator's\n * {@code remove} method. If you override {@link #iterator}, you may wish to override {@link\n * #remove} to forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6237, "method_signature": "boolean standardRemove(Object)", "filename": "ForwardingCollection.standardRemove.json"}
{"callee_method_names": ["Iterator<Entry<K, V>>.hasNext", "Iterator<Entry<K, V>>.next", "Entry<K, V>.getKey", "Entry<K, V>.getValue", "Iterator<Entry<K, V>>.remove"], "method_name": "ForwardingMap.standardRemove", "method_implementation": "{\n    Iterator<Entry<K, V>> entryIterator = entrySet().iterator();\n    while (entryIterator.hasNext()) {\n        Entry<K, V> entry = entryIterator.next();\n        if (Objects.equal(entry.getKey(), key)) {\n            V value = entry.getValue();\n            entryIterator.remove();\n            return value;\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * A sensible, albeit inefficient, definition of {@link #remove} in terms of the {@code iterator}\n * method of {@link #entrySet}. If you override {@link #entrySet}, you may wish to override {@link\n * #remove} to forward to this implementation.\n *\n * <p>Alternately, you may wish to override {@link #remove} with {@code keySet().remove}, assuming\n * that approach would not lead to an infinite loop.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 5607, "method_signature": "V standardRemove(Object)", "filename": "ForwardingMap.standardRemove.json"}
{"callee_method_names": ["Entry<?, ?>.getKey", "Entry<?, ?>.getValue"], "method_name": "ForwardingMapEntry.standardEquals", "method_implementation": "{\n    if (object instanceof Entry) {\n        Entry<?, ?> that = (Entry<?, ?>) object;\n        return Objects.equal(this.getKey(), that.getKey()) && Objects.equal(this.getValue(), that.getValue());\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #equals(Object)} in terms of {@link #getKey()} and {@link\n * #getValue()}. If you override either of these methods, you may wish to override {@link\n * #equals(Object)} to forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6161, "method_signature": "boolean standardEquals(Object)", "filename": "ForwardingMapEntry.standardEquals.json"}
{"callee_method_names": ["K.hashCode", "V.hashCode"], "method_name": "ForwardingMapEntry.standardHashCode", "method_implementation": "{\n    K k = getKey();\n    V v = getValue();\n    return ((k == null) ? 0 : k.hashCode()) ^ ((v == null) ? 0 : v.hashCode());\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #hashCode()} in terms of {@link #getKey()} and {@link\n * #getValue()}. If you override either of these methods, you may wish to override {@link\n * #hashCode()} to forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6162, "method_signature": "int standardHashCode()", "filename": "ForwardingMapEntry.standardHashCode.json"}
{"callee_method_names": ["Entry<? extends K,? extends V>.getElement", "Entry<? extends K,? extends V>.getCount"], "method_name": "ForwardingMultiset.standardCount", "method_implementation": "{\n    for (Entry<?> entry : this.entrySet()) {\n        if (Objects.equal(entry.getElement(), object)) {\n            return entry.getCount();\n        }\n    }\n    return 0;\n}", "repo_id": "5", "comment": "/**\n * A sensible, albeit inefficient, definition of {@link #count} in terms of {@link #entrySet}. If\n * you override {@link #entrySet}, you may wish to override {@link #count} to forward to this\n * implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 5802, "method_signature": "int standardCount(Object)", "filename": "ForwardingMultiset.standardCount.json"}
{"callee_method_names": [], "method_name": "ForwardingMultisetTest.create", "method_implementation": "{\n    final Multiset<String> inner = LinkedHashMultiset.create(Arrays.asList(elements));\n    return new ForwardingMultiset<String>() {\n\n        @Override\n        protected Multiset<String> delegate() {\n            return inner;\n        }\n\n        @Override\n        public Set<String> elementSet() {\n            return new StandardElementSet();\n        }\n\n        @Override\n        public int add(String element, int occurrences) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean add(String element) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Set<Entry<String>> entrySet() {\n            final Set<Entry<String>> backingSet = super.entrySet();\n            return new ForwardingSet<Entry<String>>() {\n\n                @Override\n                protected Set<Entry<String>> delegate() {\n                    return backingSet;\n                }\n\n                @Override\n                public boolean add(Entry<String> element) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean addAll(Collection<? extends Entry<String>> collection) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public void clear() {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean contains(Object object) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean containsAll(Collection<?> collection) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean isEmpty() {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean remove(Object object) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean removeAll(Collection<?> collection) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean retainAll(Collection<?> collection) {\n                    throw new UnsupportedOperationException();\n                }\n            };\n        }\n\n        @Override\n        public boolean equals(@Nullable Object object) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean remove(Object element) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean setCount(String element, int oldCount, int newCount) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int setCount(String element, int count) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection<? extends String> collection) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Iterator<String> iterator() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean removeAll(Collection<?> collection) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean retainAll(Collection<?> collection) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int size() {\n            throw new UnsupportedOperationException();\n        }\n    }.elementSet();\n}", "repo_id": "5", "comment": "/**\n * Returns a Multiset that throws an exception on any attempt to use a method not\n * specifically authorized by the elementSet() or hashCode() docs.\n */\n", "repo_name": "guava-master/", "id": 3980, "method_signature": "Set<String> create(String[])", "filename": "ForwardingMultisetTest.create.json"}
{"callee_method_names": ["Entry<K, V>.getKey"], "method_name": "ForwardingNavigableMap.standardFirstKey", "method_implementation": "{\n    Entry<K, V> entry = firstEntry();\n    if (entry == null) {\n        throw new NoSuchElementException();\n    } else {\n        return entry.getKey();\n    }\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #firstKey} in terms of {@code firstEntry}. If you override\n * {@code firstEntry}, you may wish to override {@code firstKey} to forward to this\n * implementation.\n */\n", "repo_name": "guava-master/", "id": 6307, "method_signature": "K standardFirstKey()", "filename": "ForwardingNavigableMap.standardFirstKey.json"}
{"callee_method_names": ["Entry<K, V>.getKey"], "method_name": "ForwardingNavigableMap.standardLastKey", "method_implementation": "{\n    Entry<K, V> entry = lastEntry();\n    if (entry == null) {\n        throw new NoSuchElementException();\n    } else {\n        return entry.getKey();\n    }\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #lastKey} in terms of {@code lastEntry}. If you override {@code\n * lastEntry}, you may wish to override {@code lastKey} to forward to this implementation.\n */\n", "repo_name": "guava-master/", "id": 6308, "method_signature": "K standardLastKey()", "filename": "ForwardingNavigableMap.standardLastKey.json"}
{"callee_method_names": [], "method_name": "ForwardingNavigableMap.standardSubMap", "method_implementation": "{\n    return subMap(fromKey, true, toKey, false);\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #subMap(Object, Object)} in terms of {@link #subMap(Object,\n * boolean, Object, boolean)}. If you override {@code subMap(K, boolean, K, boolean)}, you may\n * wish to override {@code subMap} to forward to this implementation.\n */\n", "repo_name": "guava-master/", "id": 6309, "method_signature": "SortedMap<K,V> standardSubMap(K, K)", "filename": "ForwardingNavigableMap.standardSubMap.json"}
{"callee_method_names": [], "method_name": "ForwardingNavigableSet.standardSubSet", "method_implementation": "{\n    return subSet(fromElement, true, toElement, false);\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #subSet(Object, Object)} in terms of the {@link #subSet(Object,\n * boolean, Object, boolean)} method. If you override {@link #subSet(Object, boolean, Object,\n * boolean)}, you may wish to override {@link #subSet(Object, Object)} to forward to this\n * implementation.\n */\n", "repo_name": "guava-master/", "id": 6003, "method_signature": "SortedSet<E> standardSubSet(E, E)", "filename": "ForwardingNavigableSet.standardSubSet.json"}
{"callee_method_names": ["Class<T>.getInterfaces", "Method.invoke"], "method_name": "ForwardingObjectTester.testForwardingObject", "method_implementation": "{\n    // super interface type of T\n    @SuppressWarnings(\"unchecked\")\n    Class<? super T> interfaceType = (Class<? super T>) Iterables.getOnlyElement(Arrays.asList(forwarderClass.getInterfaces()));\n    new ForwardingWrapperTester().testForwarding(interfaceType, new Function<Object, T>() {\n\n        @Override\n        public T apply(Object delegate) {\n            T mock = mock(forwarderClass, CALLS_REAL_METHODS);\n            try {\n                T stubber = doReturn(delegate).when(mock);\n                DELEGATE_METHOD.invoke(stubber);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n            return mock;\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Ensures that all interface methods of {@code forwarderClass} are forwarded to the {@link\n * ForwardingObject#delegate}. {@code forwarderClass} is assumed to only implement one interface.\n */\n", "repo_name": "guava-master/", "id": 3880, "method_signature": "void testForwardingObject(Class)", "filename": "ForwardingObjectTester.testForwardingObject.json"}
{"callee_method_names": [], "method_name": "ForwardingQueue.standardOffer", "method_implementation": "{\n    try {\n        return add(e);\n    } catch (IllegalStateException caught) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #offer} in terms of {@link #add}. If you override {@link #add},\n * you may wish to override {@link #offer} to forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6171, "method_signature": "boolean standardOffer(E)", "filename": "ForwardingQueue.standardOffer.json"}
{"callee_method_names": [], "method_name": "ForwardingQueue.standardPeek", "method_implementation": "{\n    try {\n        return element();\n    } catch (NoSuchElementException caught) {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #peek} in terms of {@link #element}. If you override {@link\n * #element}, you may wish to override {@link #peek} to forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6172, "method_signature": "E standardPeek()", "filename": "ForwardingQueue.standardPeek.json"}
{"callee_method_names": [], "method_name": "ForwardingQueue.standardPoll", "method_implementation": "{\n    try {\n        return remove();\n    } catch (NoSuchElementException caught) {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #poll} in terms of {@link #remove}. If you override {@link\n * #remove}, you may wish to override {@link #poll} to forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6173, "method_signature": "E standardPoll()", "filename": "ForwardingQueue.standardPoll.json"}
{"callee_method_names": ["SortedMap<@Nullable Object, V>.tailMap"], "method_name": "ForwardingSortedMap.standardContainsKey", "method_implementation": "{\n    try {\n        // any CCE or NPE will be caught\n        @SuppressWarnings({ \"unchecked\", \"nullness\" })\n        SortedMap<@Nullable Object, V> self = (SortedMap<@Nullable Object, V>) this;\n        Object ceilingKey = self.tailMap(key).firstKey();\n        return unsafeCompare(comparator(), ceilingKey, key) == 0;\n    } catch (ClassCastException | NoSuchElementException | NullPointerException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #containsKey} in terms of the {@code firstKey()} method of\n * {@link #tailMap}. If you override {@link #tailMap}, you may wish to override {@link\n * #containsKey} to forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6062, "method_signature": "boolean standardContainsKey(Object)", "filename": "ForwardingSortedMap.standardContainsKey.json"}
{"callee_method_names": [], "method_name": "ForwardingSortedMap.unsafeCompare", "method_implementation": "{\n    if (comparator == null) {\n        return ((Comparable<@Nullable Object>) o1).compareTo(o2);\n    } else {\n        return ((Comparator<@Nullable Object>) comparator).compare(o1, o2);\n    }\n}", "repo_id": "5", "comment": "// unsafe, but worst case is a CCE or NPE is thrown, which callers will be expecting\n", "repo_name": "guava-master/", "id": 6061, "method_signature": "int unsafeCompare(Comparator, Object, Object)", "filename": "ForwardingSortedMap.unsafeCompare.json"}
{"callee_method_names": ["Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Entry<E>.getElement", "Entry<E>.getCount"], "method_name": "ForwardingSortedMultiset.standardFirstEntry", "method_implementation": "{\n    Iterator<Entry<E>> entryIterator = entrySet().iterator();\n    if (!entryIterator.hasNext()) {\n        return null;\n    }\n    Entry<E> entry = entryIterator.next();\n    return Multisets.immutableEntry(entry.getElement(), entry.getCount());\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #firstEntry()} in terms of {@code entrySet().iterator()}.\n *\n * <p>If you override {@link #entrySet()}, you may wish to override {@link #firstEntry()} to\n * forward to this implementation.\n */\n", "repo_name": "guava-master/", "id": 6821, "method_signature": "Entry<E> standardFirstEntry()", "filename": "ForwardingSortedMultiset.standardFirstEntry.json"}
{"callee_method_names": ["Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Entry<E>.getElement", "Entry<E>.getCount"], "method_name": "ForwardingSortedMultiset.standardLastEntry", "method_implementation": "{\n    Iterator<Entry<E>> entryIterator = descendingMultiset().entrySet().iterator();\n    if (!entryIterator.hasNext()) {\n        return null;\n    }\n    Entry<E> entry = entryIterator.next();\n    return Multisets.immutableEntry(entry.getElement(), entry.getCount());\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #lastEntry()} in terms of {@code\n * descendingMultiset().entrySet().iterator()}.\n *\n * <p>If you override {@link #descendingMultiset} or {@link #entrySet()}, you may wish to override\n * {@link #firstEntry()} to forward to this implementation.\n */\n", "repo_name": "guava-master/", "id": 6822, "method_signature": "Entry<E> standardLastEntry()", "filename": "ForwardingSortedMultiset.standardLastEntry.json"}
{"callee_method_names": ["Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Entry<E>.getElement", "Entry<E>.getCount", "Iterator<Entry<E>>.remove"], "method_name": "ForwardingSortedMultiset.standardPollFirstEntry", "method_implementation": "{\n    Iterator<Entry<E>> entryIterator = entrySet().iterator();\n    if (!entryIterator.hasNext()) {\n        return null;\n    }\n    Entry<E> entry = entryIterator.next();\n    entry = Multisets.immutableEntry(entry.getElement(), entry.getCount());\n    entryIterator.remove();\n    return entry;\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #pollFirstEntry()} in terms of {@code entrySet().iterator()}.\n *\n * <p>If you override {@link #entrySet()}, you may wish to override {@link #pollFirstEntry()} to\n * forward to this implementation.\n */\n", "repo_name": "guava-master/", "id": 6823, "method_signature": "Entry<E> standardPollFirstEntry()", "filename": "ForwardingSortedMultiset.standardPollFirstEntry.json"}
{"callee_method_names": ["Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Entry<E>.getElement", "Entry<E>.getCount", "Iterator<Entry<E>>.remove"], "method_name": "ForwardingSortedMultiset.standardPollLastEntry", "method_implementation": "{\n    Iterator<Entry<E>> entryIterator = descendingMultiset().entrySet().iterator();\n    if (!entryIterator.hasNext()) {\n        return null;\n    }\n    Entry<E> entry = entryIterator.next();\n    entry = Multisets.immutableEntry(entry.getElement(), entry.getCount());\n    entryIterator.remove();\n    return entry;\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #pollLastEntry()} in terms of {@code\n * descendingMultiset().entrySet().iterator()}.\n *\n * <p>If you override {@link #descendingMultiset()} or {@link #entrySet()}, you may wish to\n * override {@link #pollLastEntry()} to forward to this implementation.\n */\n", "repo_name": "guava-master/", "id": 6824, "method_signature": "Entry<E> standardPollLastEntry()", "filename": "ForwardingSortedMultiset.standardPollLastEntry.json"}
{"callee_method_names": [], "method_name": "ForwardingSortedMultiset.standardSubMultiset", "method_implementation": "{\n    return tailMultiset(lowerBound, lowerBoundType).headMultiset(upperBound, upperBoundType);\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #subMultiset(Object, BoundType, Object, BoundType)} in terms of\n * {@link #headMultiset(Object, BoundType) headMultiset} and {@link #tailMultiset(Object,\n * BoundType) tailMultiset}.\n *\n * <p>If you override either of these methods, you may wish to override {@link\n * #subMultiset(Object, BoundType, Object, BoundType)} to forward to this implementation.\n */\n", "repo_name": "guava-master/", "id": 6250, "method_signature": "SortedMultiset<E> standardSubMultiset(E, BoundType, E, BoundType)", "filename": "ForwardingSortedMultiset.standardSubMultiset.json"}
{"callee_method_names": ["SortedSet<@Nullable Object>.tailSet"], "method_name": "ForwardingSortedSet.standardContains", "method_implementation": "{\n    try {\n        // any ClassCastExceptions and NullPointerExceptions are caught\n        @SuppressWarnings({ \"unchecked\", \"nullness\" })\n        SortedSet<@Nullable Object> self = (SortedSet<@Nullable Object>) this;\n        Object ceiling = self.tailSet(object).first();\n        return unsafeCompare(comparator(), ceiling, object) == 0;\n    } catch (ClassCastException | NoSuchElementException | NullPointerException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #contains} in terms of the {@code first()} method of {@link\n * #tailSet}. If you override {@link #tailSet}, you may wish to override {@link #contains} to\n * forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 5526, "method_signature": "boolean standardContains(Object)", "filename": "ForwardingSortedSet.standardContains.json"}
{"callee_method_names": ["SortedSet<@Nullable Object>.tailSet", "Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.remove"], "method_name": "ForwardingSortedSet.standardRemove", "method_implementation": "{\n    try {\n        // any ClassCastExceptions and NullPointerExceptions are caught\n        @SuppressWarnings({ \"unchecked\", \"nullness\" })\n        SortedSet<@Nullable Object> self = (SortedSet<@Nullable Object>) this;\n        Iterator<?> iterator = self.tailSet(object).iterator();\n        if (iterator.hasNext()) {\n            Object ceiling = iterator.next();\n            if (unsafeCompare(comparator(), ceiling, object) == 0) {\n                iterator.remove();\n                return true;\n            }\n        }\n    } catch (ClassCastException | NullPointerException e) {\n        return false;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * A sensible definition of {@link #remove} in terms of the {@code iterator()} method of {@link\n * #tailSet}. If you override {@link #tailSet}, you may wish to override {@link #remove} to\n * forward to this implementation.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 5527, "method_signature": "boolean standardRemove(Object)", "filename": "ForwardingSortedSet.standardRemove.json"}
{"callee_method_names": ["Class<?>.getMethods", "Class<?>.getMethod", "Method[].getName", "Method[].getParameterTypes"], "method_name": "ForwardingWrapperTester.getMostConcreteMethods", "method_implementation": "{\n    Method[] methods = type.getMethods();\n    for (int i = 0; i < methods.length; i++) {\n        try {\n            methods[i] = type.getMethod(methods[i].getName(), methods[i].getParameterTypes());\n        } catch (Exception e) {\n            throwIfUnchecked(e);\n            throw new RuntimeException(e);\n        }\n    }\n    return methods;\n}", "repo_id": "5", "comment": "/**\n * Returns the most concrete public methods from {@code type}.\n */\n", "repo_name": "guava-master/", "id": 4109, "method_signature": "Method[] getMostConcreteMethods(Class)", "filename": "ForwardingWrapperTester.getMostConcreteMethods.json"}
{"callee_method_names": [], "method_name": "ForwardingWrapperTester.includingEquals", "method_implementation": "{\n    this.testsEquals = true;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Asks for {@link Object#equals} and {@link Object#hashCode} to be tested. That is, forwarding\n * wrappers of equal instances should be equal.\n */\n", "repo_name": "guava-master/", "id": 4107, "method_signature": "ForwardingWrapperTester includingEquals()", "filename": "ForwardingWrapperTester.includingEquals.json"}
{"callee_method_names": ["Class<T>.isInterface", "Method.getModifiers", "Method.getName", "Method.getParameterTypes", "Method.getParameterTypes", "Method.getName", "Method.getParameterTypes", "Method.getName", "Method.getParameterTypes"], "method_name": "ForwardingWrapperTester.testForwarding", "method_implementation": "{\n    checkNotNull(wrapperFunction);\n    checkArgument(interfaceType.isInterface(), \"%s isn't an interface\", interfaceType);\n    Method[] methods = getMostConcreteMethods(interfaceType);\n    AccessibleObject.setAccessible(methods, true);\n    for (Method method : methods) {\n        // Under java 8, interfaces can have default methods that aren't abstract.\n        // No need to verify them.\n        // Can't check isDefault() for JDK 7 compatibility.\n        if (!Modifier.isAbstract(method.getModifiers())) {\n            continue;\n        }\n        // The interface could be package-private or private.\n        // filter out equals/hashCode/toString\n        if (method.getName().equals(\"equals\") && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == Object.class) {\n            continue;\n        }\n        if (method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0) {\n            continue;\n        }\n        if (method.getName().equals(\"toString\") && method.getParameterTypes().length == 0) {\n            continue;\n        }\n        testSuccessfulForwarding(interfaceType, method, wrapperFunction);\n        testExceptionPropagation(interfaceType, method, wrapperFunction);\n    }\n    if (testsEquals) {\n        testEquals(interfaceType, wrapperFunction);\n    }\n    testToString(interfaceType, wrapperFunction);\n}", "repo_id": "5", "comment": "/**\n * Tests that the forwarding wrapper returned by {@code wrapperFunction} properly forwards method\n * calls with parameters passed as is, return value returned as is, and exceptions propagated as\n * is.\n */\n", "repo_name": "guava-master/", "id": 4108, "method_signature": "void testForwarding(Class, Function)", "filename": "ForwardingWrapperTester.testForwarding.json"}
{"callee_method_names": ["TypeToken<?>.getRawType", "ListMultimap<Class<?>, Object>.get", "Class<?>.isEnum", "Class<?>.getEnumConstants", "TypeToken<?>.isArray", "TypeToken<?>.getComponentType", "TypeToken<?>.getRawType", "ImmutableMap<Class<?>, Method>.get", "HashMap.containsKey", "TypeToken<?>.getType", "HashMap.get", "TypeToken<?>.getType", "AtomicInteger.get", "HashMap.put", "TypeToken<?>.getType", "AtomicInteger.get", "ImmutableMap<Class<?>, Method>.get", "ImmutableList<Parameter>.size", "Class<?>.getTypeParameters", "ImmutableList<Parameter>.size", "TypeToken<?>.resolveType", "List<Object>.add", "List<Object>.toArray"], "method_name": "FreshValueGenerator.generate", "method_implementation": "{\n    Class<?> rawType = type.getRawType();\n    List<Object> samples = sampleInstances.get(rawType);\n    Object sample = pickInstance(samples, null);\n    if (sample != null) {\n        return sample;\n    }\n    if (rawType.isEnum()) {\n        return pickInstance(rawType.getEnumConstants(), null);\n    }\n    if (type.isArray()) {\n        TypeToken<?> componentType = checkNotNull(type.getComponentType());\n        Object array = Array.newInstance(componentType.getRawType(), 1);\n        Array.set(array, 0, generate(componentType));\n        return array;\n    }\n    Method emptyGenerate = EMPTY_GENERATORS.get(rawType);\n    if (emptyGenerate != null) {\n        if (emptyInstanceGenerated.containsKey(type.getType())) {\n            // empty instance already generated\n            if (emptyInstanceGenerated.get(type.getType()).intValue() == freshness.get()) {\n                // same freshness, generate again.\n                return invokeGeneratorMethod(emptyGenerate);\n            } else {\n                // Cannot use empty generator. Proceed with other generators.\n            }\n        } else {\n            // never generated empty instance for this type before.\n            Object emptyInstance = invokeGeneratorMethod(emptyGenerate);\n            emptyInstanceGenerated.put(type.getType(), freshness.get());\n            return emptyInstance;\n        }\n    }\n    Method generate = GENERATORS.get(rawType);\n    if (generate != null) {\n        ImmutableList<Parameter> params = Invokable.from(generate).getParameters();\n        List<Object> args = Lists.newArrayListWithCapacity(params.size());\n        TypeVariable<?>[] typeVars = rawType.getTypeParameters();\n        for (int i = 0; i < params.size(); i++) {\n            TypeToken<?> paramType = type.resolveType(typeVars[i]);\n            // We require all @Generates methods to either be parameter-less or accept non-null\n            // values for their generic parameter types.\n            Object argValue = generate(paramType);\n            if (argValue == null) {\n                // When a parameter of a @Generates method cannot be created,\n                // The type most likely is a collection.\n                // Our distinct proxy doesn't work for collections.\n                // So just refuse to generate.\n                return null;\n            }\n            args.add(argValue);\n        }\n        return invokeGeneratorMethod(generate, args.toArray());\n    }\n    return defaultGenerate(rawType);\n}", "repo_id": "5", "comment": "/**\n * Generates an instance for {@code type} using the current {@link #freshness}. The generated\n * instance may or may not be unique across different calls.\n */\n", "repo_name": "guava-master/", "id": 4119, "method_signature": "Object generate(TypeToken)", "filename": "FreshValueGenerator.generate.json"}
{"callee_method_names": ["AtomicInteger.incrementAndGet"], "method_name": "FreshValueGenerator.generateFresh", "method_implementation": "{\n    Object generated = generate(type);\n    if (generated != null) {\n        freshness.incrementAndGet();\n    }\n    return generated;\n}", "repo_id": "5", "comment": "/**\n * Returns a fresh instance for {@code type} if possible. The returned instance could be:\n *\n * <ul>\n *   <li>exactly of the given type, including generic type parameters, such as {@code\n *       ImmutableList<String>};\n *   <li>of the raw type;\n *   <li>null if no value can be generated.\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 4118, "method_signature": "Object generateFresh(TypeToken)", "filename": "FreshValueGenerator.generateFresh.json"}
{"callee_method_names": ["SettableFuture<String>.setException"], "method_name": "FutureCallbackTest.testSameThreadExecutionException", "method_implementation": "{\n    SettableFuture<String> f = SettableFuture.create();\n    Exception e = new IllegalArgumentException(\"foo not found\");\n    MockCallback callback = new MockCallback(e);\n    addCallback(f, callback, directExecutor());\n    f.setException(e);\n}", "repo_id": "5", "comment": "// Error cases\n", "repo_name": "guava-master/", "id": 3814, "method_signature": "void testSameThreadExecutionException()", "filename": "FutureCallbackTest.testSameThreadExecutionException.json"}
{"callee_method_names": ["Runnable.run"], "method_name": "FutureCombiner.run", "method_implementation": "{\n    return call(new Callable<@Nullable Void>() {\n\n        @Override\n        @CheckForNull\n        public Void call() throws Exception {\n            combiner.run();\n            return null;\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Creates the {@link ListenableFuture} which will return the result of running {@code combiner}\n * when all Futures complete. {@code combiner} will run using {@code executor}.\n *\n * <p>If the combiner throws a {@code CancellationException}, the returned future will be\n * cancelled.\n *\n * <p>Canceling this Future will attempt to cancel all the component futures.\n *\n * @since 23.6\n * @return a future whose result is based on {@code combiner} (or based on the input futures\n *     passed to {@code whenAllSucceed}, if that is the method you used to create this {@code\n *     FutureCombiner}). Even though the future never produces a value other than {@code null},\n *     you should typically check whether it failed: See <a\n *     href=\"https://errorprone.info/bugpattern/FutureReturnValueIgnored\">https://errorprone.info/bugpattern/FutureReturnValueIgnored</a>.\n */\n", "repo_name": "guava-master/", "id": 5515, "method_signature": "ListenableFuture<?> run(Runnable, Executor)", "filename": "FutureCombiner.run.json"}
{"callee_method_names": ["ListenableFuture<V>.addListener"], "method_name": "Futures.addCallback", "method_implementation": "{\n    Preconditions.checkNotNull(callback);\n    future.addListener(new CallbackListener<V>(future, callback), executor);\n}", "repo_id": "5", "comment": "/**\n * Registers separate success and failure callbacks to be run when the {@code Future}'s\n * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n * computation is already complete, immediately.\n *\n * <p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of\n * callbacks, but any callback added through this method is guaranteed to be called once the\n * computation is complete.\n *\n * <p>Exceptions thrown by a {@code callback} will be propagated up to the executor. Any exception\n * thrown during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an\n * exception thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught\n * and logged.\n *\n * <p>Example:\n *\n * <pre>{@code\n * ListenableFuture<QueryResult> future = ...;\n * Executor e = ...\n * addCallback(future,\n *     new FutureCallback<QueryResult>() {\n *       public void onSuccess(QueryResult result) {\n *         storeInCache(result);\n *       }\n *       public void onFailure(Throwable t) {\n *         reportError(t);\n *       }\n *     }, e);\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the warnings the {@link MoreExecutors#directExecutor} documentation.\n *\n * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n * ListenableFuture#addListener addListener}.\n *\n * @param future The future attach the callback to.\n * @param callback The callback to invoke when {@code future} is completed.\n * @param executor The executor to run {@code callback} when the future completes.\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5510, "method_signature": "void addCallback(ListenableFuture, FutureCallback, Executor)", "filename": "Futures.addCallback.json"}
{"callee_method_names": [], "method_name": "Futures.allAsList", "method_implementation": "{\n    ListenableFuture<List<@Nullable V>> nullable = new ListFuture<V>(ImmutableList.copyOf(futures), true);\n    // allAsList ensures that it fills the output list with V instances.\n    @SuppressWarnings(\"nullness\")\n    ListenableFuture<List<V>> nonNull = nullable;\n    return nonNull;\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n * input futures, if all succeed.\n *\n * <p>The list of results is in the same order as the input list.\n *\n * <p>This differs from {@link #successfulAsList(Iterable)} in that it will return a failed future\n * if any of the items fails.\n *\n * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n * provided futures fails or is canceled, this one is, too.\n *\n * @param futures futures to combine\n * @return a future that provides a list of the results of the component futures\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5502, "method_signature": "ListenableFuture<List<V>> allAsList(Iterable)", "filename": "Futures.allAsList.json"}
{"callee_method_names": [], "method_name": "Futures.catching", "method_implementation": "{\n    return AbstractCatchingFuture.create(input, exceptionType, fallback, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n * primary input fails with the given {@code exceptionType}, from the result provided by the\n * {@code fallback}. {@link Function#apply} is not invoked until the primary input has failed, so\n * if the primary input succeeds, it is never invoked. If, during the invocation of {@code\n * fallback}, an exception is thrown, this exception is used as the result of the output {@code\n * Future}.\n *\n * <p>Usage example:\n *\n * <pre>{@code\n * ListenableFuture<Integer> fetchCounterFuture = ...;\n *\n * // Falling back to a zero counter in case an exception happens when\n * // processing the RPC to fetch counters.\n * ListenableFuture<Integer> faultTolerantFuture = Futures.catching(\n *     fetchCounterFuture, FetchException.class, x -> 0, directExecutor());\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the warnings the {@link MoreExecutors#directExecutor} documentation.\n *\n * @param input the primary input {@code Future}\n * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n *     type is matched against the input's exception. \"The input's exception\" means the cause of\n *     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a\n *     different kind of exception, that exception itself. To avoid hiding bugs and other\n *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n *     Throwable.class} in particular.\n * @param fallback the {@link Function} to be called if {@code input} fails with the expected\n *     exception type. The function's argument is the input's exception. \"The input's exception\"\n *     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if\n *     {@code get()} throws a different kind of exception, that exception itself.\n * @param executor the executor that runs {@code fallback} if {@code input} fails\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 5495, "method_signature": "ListenableFuture<V> catching(ListenableFuture, Class, Function, Executor)", "filename": "Futures.catching.json"}
{"callee_method_names": [], "method_name": "Futures.catchingAsync", "method_implementation": "{\n    return AbstractCatchingFuture.create(input, exceptionType, fallback, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n * primary input fails with the given {@code exceptionType}, from the result provided by the\n * {@code fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has\n * failed, so if the primary input succeeds, it is never invoked. If, during the invocation of\n * {@code fallback}, an exception is thrown, this exception is used as the result of the output\n * {@code Future}.\n *\n * <p>Usage examples:\n *\n * <pre>{@code\n * ListenableFuture<Integer> fetchCounterFuture = ...;\n *\n * // Falling back to a zero counter in case an exception happens when\n * // processing the RPC to fetch counters.\n * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n *     fetchCounterFuture, FetchException.class, x -> immediateFuture(0), directExecutor());\n * }</pre>\n *\n * <p>The fallback can also choose to propagate the original exception when desired:\n *\n * <pre>{@code\n * ListenableFuture<Integer> fetchCounterFuture = ...;\n *\n * // Falling back to a zero counter only in case the exception was a\n * // TimeoutException.\n * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n *     fetchCounterFuture,\n *     FetchException.class,\n *     e -> {\n *       if (omitDataOnFetchFailure) {\n *         return immediateFuture(0);\n *       }\n *       throw e;\n *     },\n *     directExecutor());\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the warnings the {@link MoreExecutors#directExecutor} documentation.\n *\n * @param input the primary input {@code Future}\n * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n *     type is matched against the input's exception. \"The input's exception\" means the cause of\n *     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a\n *     different kind of exception, that exception itself. To avoid hiding bugs and other\n *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n *     Throwable.class} in particular.\n * @param fallback the {@link AsyncFunction} to be called if {@code input} fails with the expected\n *     exception type. The function's argument is the input's exception. \"The input's exception\"\n *     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if\n *     {@code get()} throws a different kind of exception, that exception itself.\n * @param executor the executor that runs {@code fallback} if {@code input} fails\n * @since 19.0 (similar functionality in 14.0 as {@code withFallback})\n */\n", "repo_name": "guava-master/", "id": 5496, "method_signature": "ListenableFuture<V> catchingAsync(ListenableFuture, Class, AsyncFunction, Executor)", "filename": "Futures.catchingAsync.json"}
{"callee_method_names": [], "method_name": "Futures.getChecked", "method_implementation": "{\n    return FuturesGetChecked.getChecked(future, exceptionClass, timeout, unit);\n}", "repo_id": "5", "comment": "/**\n * Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new\n * instance of the given checked exception type. This reduces boilerplate for a common use of\n * {@code Future} in which it is unnecessary to programmatically distinguish between exception\n * types or to extract other information from the exception instance.\n *\n * <p>Exceptions from {@code Future.get} are treated as follows:\n *\n * <ul>\n *   <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause\n *       is a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n *       RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n *   <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n *       interrupt).\n *   <li>Any {@link TimeoutException} is wrapped in an {@code X}.\n *   <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n *       RuntimeException} (though {@code get} implementations are discouraged from throwing such\n *       exceptions).\n * </ul>\n *\n * <p>The overall principle is to continue to treat every checked exception as a checked\n * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n * new stack trace matches that of the current thread.\n *\n * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n * (preferring constructors with at least one {@code String}, then preferring constructors with at\n * least one {@code Throwable}) and calling the constructor via reflection. If the exception did\n * not already have a cause, one is set by calling {@link Throwable#initCause(Throwable)} on it.\n * If no such constructor exists, an {@code IllegalArgumentException} is thrown.\n *\n * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n *     whose cause is not itself a checked exception\n * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n *     {@code RuntimeException} as its cause\n * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n *     Error} as its cause\n * @throws CancellationException if {@code get} throws a {@code CancellationException}\n * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n *     does not have a suitable constructor\n * @since 19.0 (in 10.0 as {@code get} and with different parameter order)\n */\n", "repo_name": "guava-master/", "id": 5513, "method_signature": "V getChecked(Future, Class, long, TimeUnit)", "filename": "Futures.getChecked.json"}
{"callee_method_names": ["Future<V>.isDone"], "method_name": "Futures.getDone", "method_implementation": "{\n    /*\n     * We throw IllegalStateException, since the call could succeed later. Perhaps we \"should\" throw\n     * IllegalArgumentException, since the call could succeed with a different argument. Those\n     * exceptions' docs suggest that either is acceptable. Google's Java Practices page recommends\n     * IllegalArgumentException here, in part to keep its recommendation simple: Static methods\n     * should throw IllegalStateException only when they use static state.\n     *\n     * Why do we deviate here? The answer: We want for fluentFuture.getDone() to throw the same\n     * exception as Futures.getDone(fluentFuture).\n     */\n    checkState(future.isDone(), \"Future was expected to be done: %s\", future);\n    return getUninterruptibly(future);\n}", "repo_id": "5", "comment": "/**\n * Returns the result of the input {@code Future}, which must have already completed.\n *\n * <p>The benefits of this method are twofold. First, the name \"getDone\" suggests to readers that\n * the {@code Future} is already done. Second, if buggy code calls {@code getDone} on a {@code\n * Future} that is still pending, the program will throw instead of block. This can be important\n * for APIs like {@link #whenAllComplete whenAllComplete(...)}{@code .}{@link\n * FutureCombiner#call(Callable, Executor) call(...)}, where it is easy to use a new input from\n * the {@code call} implementation but forget to add it to the arguments of {@code\n * whenAllComplete}.\n *\n * <p>If you are looking for a method to determine whether a given {@code Future} is done, use the\n * instance method {@link Future#isDone()}.\n *\n * @throws ExecutionException if the {@code Future} failed with an exception\n * @throws CancellationException if the {@code Future} was cancelled\n * @throws IllegalStateException if the {@code Future} is not done\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 5511, "method_signature": "V getDone(Future)", "filename": "Futures.getDone.json"}
{"callee_method_names": ["Entry<?, ?>.getCause"], "method_name": "Futures.getUnchecked", "method_implementation": "{\n    checkNotNull(future);\n    try {\n        return getUninterruptibly(future);\n    } catch (ExecutionException e) {\n        wrapAndThrowUnchecked(e.getCause());\n        throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the result of calling {@link Future#get()} uninterruptibly on a task known not to throw\n * a checked exception. This makes {@code Future} more suitable for lightweight, fast-running\n * tasks that, barring bugs in the code, will not fail. This gives it exception-handling behavior\n * similar to that of {@code ForkJoinTask.join}.\n *\n * <p>Exceptions from {@code Future.get} are treated as follows:\n *\n * <ul>\n *   <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@link\n *       UncheckedExecutionException} (if the cause is an {@code Exception}) or {@link\n *       ExecutionError} (if the cause is an {@code Error}).\n *   <li>Any {@link InterruptedException} causes a retry of the {@code get} call. The interrupt is\n *       restored before {@code getUnchecked} returns.\n *   <li>Any {@link CancellationException} is propagated untouched. So is any other {@link\n *       RuntimeException} ({@code get} implementations are discouraged from throwing such\n *       exceptions).\n * </ul>\n *\n * <p>The overall principle is to eliminate all checked exceptions: to loop to avoid {@code\n * InterruptedException}, to pass through {@code CancellationException}, and to wrap any exception\n * from the underlying computation in an {@code UncheckedExecutionException} or {@code\n * ExecutionError}.\n *\n * <p>For an uninterruptible {@code get} that preserves other exceptions, see {@link\n * Uninterruptibles#getUninterruptibly(Future)}.\n *\n * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with an\n *     {@code Exception} as its cause\n * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n *     Error} as its cause\n * @throws CancellationException if {@code get} throws a {@code CancellationException}\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5514, "method_signature": "V getUnchecked(Future)", "filename": "Futures.getUnchecked.json"}
{"callee_method_names": ["Collection<ListenableFuture<? extends T>>.toArray"], "method_name": "Futures.gwtCompatibleToArray", "method_implementation": "{\n    final Collection<ListenableFuture<? extends T>> collection;\n    if (futures instanceof Collection) {\n        collection = (Collection<ListenableFuture<? extends T>>) futures;\n    } else {\n        collection = ImmutableList.copyOf(futures);\n    }\n    return (ListenableFuture<? extends T>[]) collection.toArray(new ListenableFuture<?>[0]);\n}", "repo_id": "5", "comment": "/**\n * Can't use Iterables.toArray because it's not gwt compatible\n */\n", "repo_name": "guava-master/", "id": 5509, "method_signature": "ListenableFuture<? extends T>[] gwtCompatibleToArray(Iterable)", "filename": "Futures.gwtCompatibleToArray.json"}
{"callee_method_names": [], "method_name": "Futures.immediateCancelledFuture", "method_implementation": "{\n    ListenableFuture<Object> instance = ImmediateCancelledFuture.INSTANCE;\n    if (instance != null) {\n        return (ListenableFuture<V>) instance;\n    }\n    return new ImmediateCancelledFuture<>();\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code ListenableFuture} which is cancelled immediately upon construction, so that\n * {@code isCancelled()} always returns {@code true}.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 5490, "method_signature": "ListenableFuture<V> immediateCancelledFuture()", "filename": "Futures.immediateCancelledFuture.json"}
{"callee_method_names": [], "method_name": "Futures.immediateFailedFuture", "method_implementation": "{\n    checkNotNull(throwable);\n    return new ImmediateFailedFuture<V>(throwable);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.\n *\n * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n * Throwable} wrapped in an {@code ExecutionException}.\n */\n", "repo_name": "guava-master/", "id": 5489, "method_signature": "ListenableFuture<V> immediateFailedFuture(Throwable)", "filename": "Futures.immediateFailedFuture.json"}
{"callee_method_names": [], "method_name": "Futures.immediateFuture", "method_implementation": "{\n    if (value == null) {\n        // This cast is safe because null is assignable to V for all V (i.e. it is bivariant)\n        @SuppressWarnings(\"unchecked\")\n        ListenableFuture<V> typedNull = (ListenableFuture<V>) ImmediateFuture.NULL;\n        return typedNull;\n    }\n    return new ImmediateFuture<>(value);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The\n * getters just return the value. This {@code Future} can't be canceled or timed out and its\n * {@code isDone()} method always returns {@code true}.\n */\n", "repo_name": "guava-master/", "id": 5488, "method_signature": "ListenableFuture<V> immediateFuture(V)", "filename": "Futures.immediateFuture.json"}
{"callee_method_names": ["ImmutableList.Builder<AbstractFuture<T>>.add", "ImmutableList.Builder<AbstractFuture<T>>.build", "ListenableFuture<? extends T>[].addListener", "InCompletionOrderState<T>.recordInputCompletion"], "method_name": "Futures.inCompletionOrder", "method_implementation": "{\n    ListenableFuture<? extends T>[] copy = gwtCompatibleToArray(futures);\n    final InCompletionOrderState<T> state = new InCompletionOrderState<>(copy);\n    ImmutableList.Builder<AbstractFuture<T>> delegatesBuilder = ImmutableList.builderWithExpectedSize(copy.length);\n    for (int i = 0; i < copy.length; i++) {\n        delegatesBuilder.add(new InCompletionOrderFuture<T>(state));\n    }\n    final ImmutableList<AbstractFuture<T>> delegates = delegatesBuilder.build();\n    for (int i = 0; i < copy.length; i++) {\n        final int localI = i;\n        copy[i].addListener(() -> state.recordInputCompletion(delegates, localI), directExecutor());\n    }\n    @SuppressWarnings(\"unchecked\")\n    ImmutableList<ListenableFuture<T>> delegatesCast = (ImmutableList) delegates;\n    return delegatesCast;\n}", "repo_id": "5", "comment": "/**\n * Returns a list of delegate futures that correspond to the futures received in the order that\n * they complete. Delegate futures return the same value or throw the same exception as the\n * corresponding input future returns/throws.\n *\n * <p>\"In the order that they complete\" means, for practical purposes, about what you would\n * expect, but there are some subtleties. First, we do guarantee that, if the output future at\n * index n is done, the output future at index n-1 is also done. (But as usual with futures, some\n * listeners for future n may complete before some for future n-1.) However, it is possible, if\n * one input completes with result X and another later with result Y, for Y to come before X in\n * the output future list. (Such races are impossible to solve without global synchronization of\n * all future completions. And they should have little practical impact.)\n *\n * <p>Cancelling a delegate future propagates to input futures once all the delegates complete,\n * either from cancellation or because an input future has completed. If N futures are passed in,\n * and M delegates are cancelled, the remaining M input futures will be cancelled once N - M of\n * the input futures complete. If all the delegates are cancelled, all the input futures will be\n * too.\n *\n * @since 17.0\n */\n", "repo_name": "guava-master/", "id": 5508, "method_signature": "ImmutableList<ListenableFuture<T>> inCompletionOrder(Iterable)", "filename": "Futures.inCompletionOrder.json"}
{"callee_method_names": ["Future<I>.cancel", "Future<I>.isCancelled", "Future<I>.isDone", "Future<I>.get", "Future<I>.get", "Function<? super I,? extends O>.apply"], "method_name": "Futures.lazyTransform", "method_implementation": "{\n    checkNotNull(input);\n    checkNotNull(function);\n    return new Future<O>() {\n\n        @Override\n        public boolean cancel(boolean mayInterruptIfRunning) {\n            return input.cancel(mayInterruptIfRunning);\n        }\n\n        @Override\n        public boolean isCancelled() {\n            return input.isCancelled();\n        }\n\n        @Override\n        public boolean isDone() {\n            return input.isDone();\n        }\n\n        @Override\n        public O get() throws InterruptedException, ExecutionException {\n            return applyTransformation(input.get());\n        }\n\n        @Override\n        public O get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n            return applyTransformation(input.get(timeout, unit));\n        }\n\n        private O applyTransformation(I input) throws ExecutionException {\n            try {\n                return function.apply(input);\n            } catch (Throwable t) {\n                // Any Exception is either a RuntimeException or sneaky checked exception.\n                throw new ExecutionException(t);\n            }\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation\n * {@code function} is invoked on each call to {@link Future#get() get()} on the returned future.\n *\n * <p>The returned {@code Future} reflects the input's cancellation state directly, and any\n * attempt to cancel the returned Future is likewise passed through to the input Future.\n *\n * <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get} only apply the timeout\n * to the execution of the underlying {@code Future}, <em>not</em> to the execution of the\n * transformation function.\n *\n * <p>The primary audience of this method is callers of {@code transform} who don't have a {@code\n * ListenableFuture} available and do not mind repeated, lazy function evaluation.\n *\n * @param input The future to transform\n * @param function A Function to transform the results of the provided future to the results of\n *     the returned future.\n * @return A future that returns the result of the transformation.\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5500, "method_signature": "Future<O> lazyTransform(Future, Function)", "filename": "Futures.lazyTransform.json"}
{"callee_method_names": ["ListenableFuture<V>.isDone", "ListenableFuture<V>.addListener"], "method_name": "Futures.nonCancellationPropagating", "method_implementation": "{\n    if (future.isDone()) {\n        return future;\n    }\n    NonCancellationPropagatingFuture<V> output = new NonCancellationPropagatingFuture<>(future);\n    future.addListener(output, directExecutor());\n    return output;\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code ListenableFuture} whose result is set from the supplied future when it\n * completes. Cancelling the supplied future will also cancel the returned future, but cancelling\n * the returned future will have no effect on the supplied future.\n *\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5506, "method_signature": "ListenableFuture<V> nonCancellationPropagating(ListenableFuture)", "filename": "Futures.nonCancellationPropagating.json"}
{"callee_method_names": ["Runnable.run"], "method_name": "Futures.run", "method_implementation": "{\n    return call(new Callable<@Nullable Void>() {\n\n        @Override\n        @CheckForNull\n        public Void call() throws Exception {\n            combiner.run();\n            return null;\n        }\n    }, executor);\n}", "repo_id": "5", "comment": "/**\n * Creates the {@link ListenableFuture} which will return the result of running {@code combiner}\n * when all Futures complete. {@code combiner} will run using {@code executor}.\n *\n * <p>If the combiner throws a {@code CancellationException}, the returned future will be\n * cancelled.\n *\n * <p>Canceling this Future will attempt to cancel all the component futures.\n *\n * @since 23.6\n * @return a future whose result is based on {@code combiner} (or based on the input futures\n *     passed to {@code whenAllSucceed}, if that is the method you used to create this {@code\n *     FutureCombiner}). Even though the future never produces a value other than {@code null},\n *     you should typically check whether it failed: See <a\n *     href=\"https://errorprone.info/bugpattern/FutureReturnValueIgnored\">https://errorprone.info/bugpattern/FutureReturnValueIgnored</a>.\n */\n", "repo_name": "guava-master/", "id": 5505, "method_signature": "ListenableFuture<?> run(Runnable, Executor)", "filename": "Futures.run.json"}
{"callee_method_names": ["ScheduledExecutorService.schedule", "TrustedListenableFutureTask<O>.addListener", "Future<?>.cancel"], "method_name": "Futures.scheduleAsync", "method_implementation": "{\n    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);\n    Future<?> scheduled = executorService.schedule(task, delay, timeUnit);\n    /*\n     * Even when the user interrupts the task, we pass `false` to `cancel` so that we don't\n     * interrupt a second time after the interruption performed by TrustedListenableFutureTask.\n     */\n    task.addListener(() -> scheduled.cancel(false), directExecutor());\n    return task;\n}", "repo_id": "5", "comment": "/**\n * Schedules {@code callable} on the specified {@code executor}, returning a {@code Future}.\n *\n * @throws RejectedExecutionException if the task cannot be scheduled for execution\n * @since 23.0\n */\n", "repo_name": "guava-master/", "id": 5494, "method_signature": "ListenableFuture<O> scheduleAsync(AsyncCallable, long, TimeUnit, ScheduledExecutorService)", "filename": "Futures.scheduleAsync.json"}
{"callee_method_names": ["Executor.execute"], "method_name": "Futures.submit", "method_implementation": "{\n    TrustedListenableFutureTask<@Nullable Void> task = TrustedListenableFutureTask.create(runnable, null);\n    executor.execute(task);\n    return task;\n}", "repo_id": "5", "comment": "/**\n * Executes {@code runnable} on the specified {@code executor}, returning a {@code Future} that\n * will complete after execution.\n *\n * @throws RejectedExecutionException if the task cannot be scheduled for execution\n * @since 28.2\n */\n", "repo_name": "guava-master/", "id": 5492, "method_signature": "ListenableFuture<Void> submit(Runnable, Executor)", "filename": "Futures.submit.json"}
{"callee_method_names": ["Executor.execute"], "method_name": "Futures.submitAsync", "method_implementation": "{\n    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);\n    executor.execute(task);\n    return task;\n}", "repo_id": "5", "comment": "/**\n * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.\n *\n * @throws RejectedExecutionException if the task cannot be scheduled for execution\n * @since 23.0\n */\n", "repo_name": "guava-master/", "id": 5493, "method_signature": "ListenableFuture<O> submitAsync(AsyncCallable, Executor)", "filename": "Futures.submitAsync.json"}
{"callee_method_names": [], "method_name": "Futures.successfulAsList", "method_implementation": "{\n    /*\n     * Another way to express this signature would be to bound <V> by @NonNull and accept\n     * LF<? extends @Nullable V>. That might be better: There's currently no difference between the\n     * outputs users get when calling this with <Foo> and calling it with <@Nullable Foo>. The only\n     * difference is that calling it with <Foo> won't work when an input Future has a @Nullable\n     * type. So why even make that error possible by giving callers the choice?\n     *\n     * On the other hand, the current signature is consistent with the similar allAsList method. And\n     * eventually this method may go away entirely in favor of an API like\n     * whenAllComplete().collectSuccesses(). That API would have a signature more like the current\n     * one.\n     */\n    return new ListFuture<V>(ImmutableList.copyOf(futures), false);\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n * successful input futures. The list of results is in the same order as the input list, and if\n * any of the provided futures fails or is canceled, its corresponding position will contain\n * {@code null} (which is indistinguishable from the future having a successful value of {@code\n * null}).\n *\n * <p>The list of results is in the same order as the input list.\n *\n * <p>This differs from {@link #allAsList(ListenableFuture[])} in that it's tolerant of failed\n * futures for any of the items, representing them as {@code null} in the result list.\n *\n * <p>Canceling this future will attempt to cancel all the component futures.\n *\n * @param futures futures to combine\n * @return a future that provides a list of the results of the component futures\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5507, "method_signature": "ListenableFuture<List<V>> successfulAsList(ListenableFuture<? extends V>[])", "filename": "Futures.successfulAsList.json"}
{"callee_method_names": [], "method_name": "Futures.transform", "method_implementation": "{\n    return AbstractTransformFuture.create(input, function, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code Future} whose result is derived from the result of the given {@code\n * Future}. If {@code input} fails, the returned {@code Future} fails with the same exception (and\n * the function is not invoked). Example usage:\n *\n * <pre>{@code\n * ListenableFuture<QueryResult> queryFuture = ...;\n * ListenableFuture<List<Row>> rowsFuture =\n *     transform(queryFuture, QueryResult::getRows, executor);\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the warnings the {@link MoreExecutors#directExecutor} documentation.\n *\n * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n * in which it will attempt to cancel itself.\n *\n * <p>An example use of this method is to convert a serializable object returned from an RPC into\n * a POJO.\n *\n * @param input The future to transform\n * @param function A Function to transform the results of the provided future to the results of\n *     the returned future.\n * @param executor Executor to run the function in.\n * @return A future that holds result of the transformation.\n * @since 9.0 (in 2.0 as {@code compose})\n */\n", "repo_name": "guava-master/", "id": 5499, "method_signature": "ListenableFuture<O> transform(ListenableFuture, Function, Executor)", "filename": "Futures.transform.json"}
{"callee_method_names": [], "method_name": "Futures.transformAsync", "method_implementation": "{\n    return AbstractTransformFuture.create(input, function, executor);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code Future} whose result is asynchronously derived from the result of the\n * given {@code Future}. If the given {@code Future} fails, the returned {@code Future} fails with\n * the same exception (and the function is not invoked).\n *\n * <p>More precisely, the returned {@code Future} takes its result from a {@code Future} produced\n * by applying the given {@code AsyncFunction} to the result of the original {@code Future}.\n * Example usage:\n *\n * <pre>{@code\n * ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n * ListenableFuture<QueryResult> queryFuture =\n *     transformAsync(rowKeyFuture, dataService::readFuture, executor);\n * }</pre>\n *\n * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n * the warnings the {@link MoreExecutors#directExecutor} documentation.\n *\n * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n * input future and that of the future returned by the chain function. That is, if the returned\n * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n * attempt to cancel itself.\n *\n * @param input The future to transform\n * @param function A function to transform the result of the input future to the result of the\n *     output future\n * @param executor Executor to run the function in.\n * @return A future that holds result of the function (if the input succeeded) or the original\n *     input's failure (if not)\n * @since 19.0 (in 11.0 as {@code transform})\n */\n", "repo_name": "guava-master/", "id": 5498, "method_signature": "ListenableFuture<O> transformAsync(ListenableFuture, AsyncFunction, Executor)", "filename": "Futures.transformAsync.json"}
{"callee_method_names": [], "method_name": "Futures.whenAllComplete", "method_implementation": "{\n    return new FutureCombiner<V>(false, ImmutableList.copyOf(futures));\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link FutureCombiner} that processes the completed futures whether or not they're\n * successful.\n *\n * <p>Any failures from the input futures will not be propagated to the returned future.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 5503, "method_signature": "FutureCombiner<V> whenAllComplete(ListenableFuture<? extends V>[])", "filename": "Futures.whenAllComplete.json"}
{"callee_method_names": [], "method_name": "Futures.whenAllSucceed", "method_implementation": "{\n    return new FutureCombiner<V>(true, ImmutableList.copyOf(futures));\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link FutureCombiner} requiring that all passed in futures are successful.\n *\n * <p>If any input fails, the returned future fails immediately.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 5504, "method_signature": "FutureCombiner<V> whenAllSucceed(ListenableFuture<? extends V>[])", "filename": "Futures.whenAllSucceed.json"}
{"callee_method_names": ["ListenableFuture<V>.isDone"], "method_name": "Futures.withTimeout", "method_implementation": "{\n    if (delegate.isDone()) {\n        return delegate;\n    }\n    return TimeoutFuture.create(delegate, time, unit, scheduledExecutor);\n}", "repo_id": "5", "comment": "/**\n * Returns a future that delegates to another but will finish early (via a {@link\n * TimeoutException} wrapped in an {@link ExecutionException}) if the specified duration expires.\n *\n * <p>The delegate future is interrupted and cancelled if it times out.\n *\n * @param delegate The future to delegate to.\n * @param unit the time unit of the time parameter\n * @param scheduledExecutor The executor service to enforce the timeout.\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 5497, "method_signature": "ListenableFuture<V> withTimeout(ListenableFuture, long, TimeUnit, ScheduledExecutorService)", "filename": "Futures.withTimeout.json"}
{"callee_method_names": ["Class<? extends Enum>.getEnumConstants"], "method_name": "FuturesGetChecked.getBestValidator", "method_implementation": "{\n    try {\n        Class<? extends Enum> theClass = Class.forName(CLASS_VALUE_VALIDATOR_NAME).asSubclass(Enum.class);\n        return (GetCheckedTypeValidator) theClass.getEnumConstants()[0];\n    } catch (ClassNotFoundException | RuntimeException | Error t) {\n        // ensure we really catch *everything*\n        return weakSetValidator();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the ClassValue-using validator, or falls back to the \"weak Set\" implementation if\n * unable to do so.\n */\n", "repo_name": "guava-master/", "id": 1951, "method_signature": "GetCheckedTypeValidator getBestValidator()", "filename": "FuturesGetChecked.getBestValidator.json"}
{"callee_method_names": ["Future<V>.get", "Entry<?, ?>.getCause"], "method_name": "FuturesGetChecked.getChecked", "method_implementation": "{\n    // TODO(cpovirk): benchmark a version of this method that accepts a GetCheckedTypeValidator\n    bestGetCheckedTypeValidator().validateClass(exceptionClass);\n    try {\n        return future.get(timeout, unit);\n    } catch (InterruptedException e) {\n        currentThread().interrupt();\n        throw newWithCause(exceptionClass, e);\n    } catch (TimeoutException e) {\n        throw newWithCause(exceptionClass, e);\n    } catch (ExecutionException e) {\n        wrapAndThrowExceptionOrError(e.getCause(), exceptionClass);\n        throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Implementation of {@link Futures#getChecked(Future, Class, long, TimeUnit)}.\n */\n", "repo_name": "guava-master/", "id": 5355, "method_signature": "V getChecked(Future, Class, long, TimeUnit)", "filename": "FuturesGetChecked.getChecked.json"}
{"callee_method_names": [], "method_name": "FuturesGetChecked.wrapAndThrowExceptionOrError", "method_implementation": "{\n    if (cause instanceof Error) {\n        throw new ExecutionError((Error) cause);\n    }\n    if (cause instanceof RuntimeException) {\n        throw new UncheckedExecutionException(cause);\n    }\n    throw newWithCause(exceptionClass, cause);\n}", "repo_id": "5", "comment": "// TODO(cpovirk): change parameter order to match other helper methods (Class, Throwable)?\n", "repo_name": "guava-master/", "id": 5356, "method_signature": "void wrapAndThrowExceptionOrError(Throwable, Class)", "filename": "FuturesGetChecked.wrapAndThrowExceptionOrError.json"}
{"callee_method_names": [], "method_name": "FuturesGetCheckedTest.doTestClassUnloading", "method_implementation": "{\n    URLClassLoader shadowLoader = new URLClassLoader(parseJavaClassPath(), null);\n    @SuppressWarnings(\"unchecked\")\n    Class<WillBeUnloadedException> shadowClass = (Class<WillBeUnloadedException>) Class.forName(WillBeUnloadedException.class.getName(), false, shadowLoader);\n    assertNotSame(shadowClass, WillBeUnloadedException.class);\n    getChecked(immediateFuture(\"foo\"), shadowClass);\n    return new WeakReference<>(shadowLoader);\n}", "repo_id": "5", "comment": "/**\n * Loads {@link WillBeUnloadedException} in a separate {@code ClassLoader}, calls {@code\n * getChecked(future, WillBeUnloadedException.class)}, and returns the loader. The caller can then\n * test that the {@code ClassLoader} can still be GCed. The test amounts to a test that {@code\n * getChecked} holds no strong references to the class.\n */\n", "repo_name": "guava-master/", "id": 3872, "method_signature": "WeakReference<?> doTestClassUnloading()", "filename": "FuturesGetCheckedTest.doTestClassUnloading.json"}
{"callee_method_names": ["TestFutureBatch.hasDelayed"], "method_name": "FuturesTest.conditionalPseudoTimedGetUninterruptibly", "method_implementation": "{\n    /*\n     * For faster tests (that may hang indefinitely if the class under test has\n     * a bug!), switch the second branch to call untimed future.get() instead of\n     * pseudoTimedGet.\n     */\n    return (inputs.hasDelayed(iFuture, jFuture)) ? pseudoTimedGetUninterruptibly(future, timeout, unit) : pseudoTimedGetUninterruptibly(future, 2500, MILLISECONDS);\n}", "repo_id": "5", "comment": "/**\n * Call the non-timed {@link Future#get()} in a way that allows us to abort if it's expected to\n * hang forever. More precisely, if it's expected to return, we simply call it[*], but if it's\n * expected to hang (because one of the input futures that we know makes it up isn't done yet),\n * then we call it in a separate thread (using pseudoTimedGet). The result is that we wait as long\n * as necessary when the method is expected to return (at the cost of hanging forever if there is\n * a bug in the class under test) but that we time out fairly promptly when the method is expected\n * to hang (possibly too quickly, but too-quick failures should be very unlikely, given that we\n * used to bail after 20ms during the expected-successful tests, and there we saw a failure rate\n * of ~1/5000, meaning that the other thread's get() call nearly always completes within 20ms if\n * it's going to complete at all).\n *\n * <p>[*] To avoid hangs, I've disabled the in-thread calls. This makes the test take (very\n * roughly) 2.5s longer. (2.5s is also the maximum length of time we will wait for a timed get\n * that is expected to succeed; the fact that the numbers match is only a coincidence.) See the\n * comment below for how to restore the fast but hang-y version.\n */\n", "repo_name": "guava-master/", "id": 3810, "method_signature": "List<String> conditionalPseudoTimedGetUninterruptibly(TestFutureBatch, ListenableFuture, ListenableFuture, ListenableFuture, int, TimeUnit)", "filename": "FuturesTest.conditionalPseudoTimedGetUninterruptibly.json"}
{"callee_method_names": ["AssertionError.initCause"], "method_name": "FuturesTest.newAssertionError", "method_implementation": "{\n    AssertionError e = new AssertionError(message);\n    e.initCause(cause);\n    return e;\n}", "repo_id": "5", "comment": "/**\n * Alternative to AssertionError(String, Throwable), which doesn't exist in GWT 2.6.1.\n */\n", "repo_name": "guava-master/", "id": 3800, "method_signature": "AssertionError newAssertionError(String, Throwable)", "filename": "FuturesTest.newAssertionError.json"}
{"callee_method_names": ["ExecutorService.submit", "Future<V>.get", "AssertionError.getCause", "AssertionError.getCause", "ExecutorService.shutdownNow"], "method_name": "FuturesTest.pseudoTimedGetUninterruptibly", "method_implementation": "{\n    ExecutorService executor = newSingleThreadExecutor();\n    Future<V> waiter = executor.submit(new Callable<V>() {\n\n        @Override\n        public V call() throws Exception {\n            return input.get();\n        }\n    });\n    try {\n        return getUninterruptibly(waiter, timeout, unit);\n    } catch (ExecutionException e) {\n        propagateIfInstanceOf(e.getCause(), ExecutionException.class);\n        propagateIfInstanceOf(e.getCause(), CancellationException.class);\n        throw failureWithCause(e, \"Unexpected exception\");\n    } finally {\n        executor.shutdownNow();\n        // TODO(cpovirk): assertTrue(awaitTerminationUninterruptibly(executor, 10, SECONDS));\n    }\n}", "repo_id": "5", "comment": "/**\n * Very rough equivalent of a timed get, produced by calling the no-arg get method in another\n * thread and waiting a short time for it.\n *\n * <p>We need this to test the behavior of no-arg get methods without hanging the main test thread\n * forever in the case of failure.\n */\n", "repo_name": "guava-master/", "id": 3808, "method_signature": "V pseudoTimedGetUninterruptibly(Future, long, TimeUnit)", "filename": "FuturesTest.pseudoTimedGetUninterruptibly.json"}
{"callee_method_names": ["TestFutureBatch.get", "TestFutureBatch.get", "Merger.merged", "ListenableFuture<List<String>>.get", "TestFutureBatch.assertHasImmediateCancel", "TestFutureBatch.assertHasImmediateFailure", "TestFutureBatch.assertHasDelayed", "TestFutureBatch.assertHasImmediateCancel", "TestFutureBatch.assertHasImmediateFailure", "TestFutureBatch.assertHasDelayed", "TestFutureBatch.get", "TestFutureBatch.get", "TestFutureBatch.assertHasCancel", "TestFutureBatch.assertHasFailure"], "method_name": "FuturesTest.runExtensiveMergerTest", "method_implementation": "{\n    int inputCount = new TestFutureBatch().allFutures.size();\n    for (int i = 0; i < inputCount; i++) {\n        for (int j = 0; j < inputCount; j++) {\n            for (boolean iBeforeJ : new boolean[] { true, false }) {\n                TestFutureBatch inputs = new TestFutureBatch();\n                ListenableFuture<String> iFuture = inputs.allFutures.get(i).future;\n                ListenableFuture<String> jFuture = inputs.allFutures.get(j).future;\n                ListenableFuture<List<String>> future = merger.merged(iFuture, jFuture);\n                // Test timed get before we've completed any delayed futures.\n                try {\n                    List<String> result = future.get(0, MILLISECONDS);\n                    assertTrue(\"Got \" + result, asList(\"a\", null).containsAll(result));\n                } catch (CancellationException e) {\n                    assertTrue(merger == Merger.allMerger);\n                    inputs.assertHasImmediateCancel(iFuture, jFuture, e);\n                } catch (ExecutionException e) {\n                    assertTrue(merger == Merger.allMerger);\n                    inputs.assertHasImmediateFailure(iFuture, jFuture, e);\n                } catch (TimeoutException e) {\n                    inputs.assertHasDelayed(iFuture, jFuture, e);\n                }\n                // Same tests with pseudoTimedGet.\n                try {\n                    List<String> result = conditionalPseudoTimedGetUninterruptibly(inputs, iFuture, jFuture, future, 20, MILLISECONDS);\n                    assertTrue(\"Got \" + result, asList(\"a\", null).containsAll(result));\n                } catch (CancellationException e) {\n                    assertTrue(merger == Merger.allMerger);\n                    inputs.assertHasImmediateCancel(iFuture, jFuture, e);\n                } catch (ExecutionException e) {\n                    assertTrue(merger == Merger.allMerger);\n                    inputs.assertHasImmediateFailure(iFuture, jFuture, e);\n                } catch (TimeoutException e) {\n                    inputs.assertHasDelayed(iFuture, jFuture, e);\n                }\n                // Finish the two futures in the currently specified order:\n                inputs.allFutures.get(iBeforeJ ? i : j).finisher.run();\n                inputs.allFutures.get(iBeforeJ ? j : i).finisher.run();\n                // Test untimed get now that we've completed any delayed futures.\n                try {\n                    List<String> result = getDone(future);\n                    assertTrue(\"Got \" + result, asList(\"a\", \"b\", null).containsAll(result));\n                } catch (CancellationException e) {\n                    assertTrue(merger == Merger.allMerger);\n                    inputs.assertHasCancel(iFuture, jFuture, e);\n                } catch (ExecutionException e) {\n                    assertTrue(merger == Merger.allMerger);\n                    inputs.assertHasFailure(iFuture, jFuture, e);\n                }\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * For each possible pair of futures from {@link TestFutureBatch}, for each possible completion\n * order of those futures, test that various get calls (timed before future completion, untimed\n * before future completion, and untimed after future completion) return or throw the proper\n * values.\n */\n", "repo_name": "guava-master/", "id": 3809, "method_signature": "void runExtensiveMergerTest(Merger)", "filename": "FuturesTest.runExtensiveMergerTest.json"}
{"callee_method_names": ["SettableFuture<String>.set", "SettableFuture<String>.set", "SettableFuture<String>.set", "SingleCallListener.expectCall", "ListenableFuture<List<String>>.addListener", "SingleCallListener.wasCalled"], "method_name": "FuturesTest.testAllAsList_doneFutures", "method_implementation": "{\n    // Create input and output\n    SettableFuture<String> future1 = SettableFuture.create();\n    SettableFuture<String> future2 = SettableFuture.create();\n    SettableFuture<String> future3 = SettableFuture.create();\n    // Satisfy each input prior to creating compound and check the output\n    future1.set(DATA1);\n    future2.set(DATA2);\n    future3.set(DATA3);\n    // array is never modified\n    @SuppressWarnings(\"unchecked\")\n    ListenableFuture<List<String>> compound = allAsList(future1, future2, future3);\n    // Attach a listener\n    SingleCallListener listener = new SingleCallListener();\n    listener.expectCall();\n    compound.addListener(listener, directExecutor());\n    assertTrue(listener.wasCalled());\n    List<String> results = getDone(compound);\n    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();\n}", "repo_id": "5", "comment": "/**\n * Test the case where the futures are fulfilled prior to constructing the ListFuture. There was a\n * bug where the loop that connects a Listener to each of the futures would die on the last\n * loop-check as done() on ListFuture nulled out the variable being looped over (the list of\n * futures).\n */\n", "repo_name": "guava-master/", "id": 3801, "method_signature": "void testAllAsList_doneFutures()", "filename": "FuturesTest.testAllAsList_doneFutures.json"}
{"callee_method_names": ["byte[].getCause", "TestLogHandler.getStoredLogRecords", "List<LogRecord>.get"], "method_name": "FuturesTest.testAllAsList_logging_error", "method_implementation": "{\n    try {\n        getDone(allAsList(immediateFailedFuture(new MyError())));\n        fail();\n    } catch (ExecutionException expected) {\n        assertThat(expected.getCause()).isInstanceOf(MyError.class);\n        List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n        // errors are always logged\n        assertThat(logged).hasSize(1);\n        assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensure that errors are always logged.\n */\n", "repo_name": "guava-master/", "id": 3803, "method_signature": "void testAllAsList_logging_error()", "filename": "FuturesTest.testAllAsList_logging_error.json"}
{"callee_method_names": ["byte[].getCause", "TestLogHandler.getStoredLogRecords"], "method_name": "FuturesTest.testAllAsList_logging_exception", "method_implementation": "{\n    try {\n        getDone(allAsList(immediateFailedFuture(new MyException())));\n        fail();\n    } catch (ExecutionException expected) {\n        assertThat(expected.getCause()).isInstanceOf(MyException.class);\n        assertEquals(\"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n    }\n}", "repo_id": "5", "comment": "/**\n * A single non-error failure is not logged because it is reported via the output future.\n */\n", "repo_name": "guava-master/", "id": 3802, "method_signature": "void testAllAsList_logging_exception()", "filename": "FuturesTest.testAllAsList_logging_exception.json"}
{"callee_method_names": ["byte[].getCause", "TestLogHandler.getStoredLogRecords", "List<LogRecord>.get"], "method_name": "FuturesTest.testAllAsList_logging_multipleExceptions_alreadyDone", "method_implementation": "{\n    try {\n        getDone(allAsList(immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException())));\n        fail();\n    } catch (ExecutionException expected) {\n        assertThat(expected.getCause()).isInstanceOf(MyException.class);\n        List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n        // the second failure is logged\n        assertThat(logged).hasSize(1);\n        assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n    }\n}", "repo_id": "5", "comment": "/**\n * All as list will log extra exceptions that have already occurred.\n */\n", "repo_name": "guava-master/", "id": 3804, "method_signature": "void testAllAsList_logging_multipleExceptions_alreadyDone()", "filename": "FuturesTest.testAllAsList_logging_multipleExceptions_alreadyDone.json"}
{"callee_method_names": ["SettableFuture<Object>.setException", "SettableFuture<Object>.setException", "SettableFuture<Object>.setException", "TestLogHandler.getStoredLogRecords", "List<LogRecord>.get", "List<LogRecord>.get"], "method_name": "FuturesTest.testAllAsList_logging_multipleExceptions_doneLater", "method_implementation": "{\n    SettableFuture<Object> future1 = SettableFuture.create();\n    SettableFuture<Object> future2 = SettableFuture.create();\n    SettableFuture<Object> future3 = SettableFuture.create();\n    ListenableFuture<List<Object>> all = allAsList(future1, future2, future3);\n    future1.setException(new MyException());\n    future2.setException(new MyException());\n    future3.setException(new MyException());\n    try {\n        getDone(all);\n        fail();\n    } catch (ExecutionException expected) {\n        List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n        // failures after the first are logged\n        assertThat(logged).hasSize(2);\n        assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n        assertThat(logged.get(1).getThrown()).isInstanceOf(MyException.class);\n    }\n}", "repo_id": "5", "comment": "/**\n * All as list will log extra exceptions that occur later.\n */\n", "repo_name": "guava-master/", "id": 3805, "method_signature": "void testAllAsList_logging_multipleExceptions_doneLater()", "filename": "FuturesTest.testAllAsList_logging_multipleExceptions_doneLater.json"}
{"callee_method_names": ["MyException.initCause", "MyException.initCause", "MyException.initCause", "byte[].getCause", "TestLogHandler.getStoredLogRecords"], "method_name": "FuturesTest.testAllAsList_logging_same_cause", "method_implementation": "{\n    try {\n        MyException exception1 = new MyException();\n        MyException exception2 = new MyException();\n        MyException exception3 = new MyException();\n        MyException sameInstance = new MyException();\n        exception1.initCause(sameInstance);\n        exception2.initCause(sameInstance);\n        exception3.initCause(exception2);\n        getDone(allAsList(immediateFailedFuture(exception1), immediateFailedFuture(exception3)));\n        fail();\n    } catch (ExecutionException expected) {\n        assertThat(expected.getCause()).isInstanceOf(MyException.class);\n        assertEquals(\"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n    }\n}", "repo_id": "5", "comment": "/**\n * Different exceptions happening on multiple futures with the same cause should not be logged.\n */\n", "repo_name": "guava-master/", "id": 3807, "method_signature": "void testAllAsList_logging_same_cause()", "filename": "FuturesTest.testAllAsList_logging_same_cause.json"}
{"callee_method_names": ["byte[].getCause", "TestLogHandler.getStoredLogRecords"], "method_name": "FuturesTest.testAllAsList_logging_same_exception", "method_implementation": "{\n    try {\n        MyException sameInstance = new MyException();\n        getDone(allAsList(immediateFailedFuture(sameInstance), immediateFailedFuture(sameInstance)));\n        fail();\n    } catch (ExecutionException expected) {\n        assertThat(expected.getCause()).isInstanceOf(MyException.class);\n        assertEquals(\"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n    }\n}", "repo_id": "5", "comment": "/**\n * The same exception happening on multiple futures should not be logged.\n */\n", "repo_name": "guava-master/", "id": 3806, "method_signature": "void testAllAsList_logging_same_exception()", "filename": "FuturesTest.testAllAsList_logging_same_exception.json"}
{"callee_method_names": ["SettableFuture<String>.set", "SettableFuture<Long>.set", "SettableFuture<Integer>.set", "ImmutableList<?>.size", "ImmutableList<?>.get", "ImmutableList<ListenableFuture<Object>>.get"], "method_name": "FuturesTest.testCompletionOrderMixedBagOTypes", "method_implementation": "{\n    SettableFuture<Long> future1 = SettableFuture.create();\n    SettableFuture<String> future2 = SettableFuture.create();\n    SettableFuture<Integer> future3 = SettableFuture.create();\n    ImmutableList<? extends ListenableFuture<?>> inputs = ImmutableList.<ListenableFuture<?>>of(future1, future2, future3);\n    ImmutableList<ListenableFuture<Object>> futures = inCompletionOrder(inputs);\n    future2.set(\"1L\");\n    future1.set(2L);\n    future3.set(3);\n    ImmutableList<?> expected = ImmutableList.of(\"1L\", 2L, 3);\n    for (int i = 0; i < expected.size(); i++) {\n        assertEquals(expected.get(i), getDone(futures.get(i)));\n    }\n}", "repo_id": "5", "comment": "// Mostly an example of how it would look like to use a list of mixed types\n", "repo_name": "guava-master/", "id": 3813, "method_signature": "void testCompletionOrderMixedBagOTypes()", "filename": "FuturesTest.testCompletionOrderMixedBagOTypes.json"}
{"callee_method_names": ["TestLogHandler.getStoredLogRecords", "List<LogRecord>.get"], "method_name": "FuturesTest.testSuccessfulAsList_logging_error", "method_implementation": "{\n    assertEquals(newArrayList((Object) null), getDone(successfulAsList(immediateFailedFuture(new MyError()))));\n    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n    // errors are always logged\n    assertThat(logged).hasSize(1);\n    assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n}", "repo_id": "5", "comment": "/**\n * Ensure that errors are always logged.\n */\n", "repo_name": "guava-master/", "id": 3812, "method_signature": "void testSuccessfulAsList_logging_error()", "filename": "FuturesTest.testSuccessfulAsList_logging_error.json"}
{"callee_method_names": ["TestLogHandler.getStoredLogRecords", "TestLogHandler.getStoredLogRecords"], "method_name": "FuturesTest.testSuccessfulAsList_logging_exception", "method_implementation": "{\n    assertEquals(newArrayList((Object) null), getDone(successfulAsList(immediateFailedFuture(new MyException()))));\n    assertWithMessage(\"Nothing should be logged\").that(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();\n    // Not even if there are a bunch of failures.\n    assertEquals(newArrayList(null, null, null), getDone(successfulAsList(immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException()))));\n    assertWithMessage(\"Nothing should be logged\").that(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();\n}", "repo_id": "5", "comment": "/**\n * Non-Error exceptions are never logged.\n */\n", "repo_name": "guava-master/", "id": 3811, "method_signature": "void testSuccessfulAsList_logging_exception()", "filename": "FuturesTest.testSuccessfulAsList_logging_exception.json"}
{"callee_method_names": ["SettableFuture<Object>.set", "SettableFuture<Object>.set"], "method_name": "FuturesTest.testTransformAsync_StackOverflow", "method_implementation": "{\n    {\n        /*\n       * Initialize all relevant classes before running the test, which may otherwise poison any\n       * classes it is trying to load during its stack overflow.\n       */\n        SettableFuture<Object> root = SettableFuture.create();\n        ListenableFuture<Object> unused = transformAsync(root, asyncIdentity(), directExecutor());\n        root.set(\"foo\");\n    }\n    SettableFuture<Object> root = SettableFuture.create();\n    ListenableFuture<Object> output = root;\n    for (int i = 0; i < 10000; i++) {\n        output = transformAsync(output, asyncIdentity(), directExecutor());\n    }\n    try {\n        root.set(\"foo\");\n        fail();\n    } catch (StackOverflowError expected) {\n    }\n}", "repo_id": "5", "comment": "/*\n   * Android does not handle this stack overflow gracefully... though somehow some other\n   * stack-overflow tests work. It must depend on the exact place the error occurs.\n   */\n", "repo_name": "guava-master/", "id": 3797, "method_signature": "void testTransformAsync_StackOverflow()", "filename": "FuturesTest.testTransformAsync_StackOverflow.json"}
{"callee_method_names": ["SettableFuture<Integer>.set", "SettableFuture<Integer>.set"], "method_name": "FuturesTest.testTransformExceptionRemainsMemoized", "method_implementation": "{\n    // We need to test with two input futures since ExecutionList.execute\n    // doesn't catch Errors and we cannot depend on the order that our\n    // transformations run. (So it is possible that the Error being thrown\n    // could prevent our second transformations from running).\n    SettableFuture<Integer> exceptionInput = SettableFuture.create();\n    ListenableFuture<Integer> exceptionComposedFuture = transform(exceptionInput, newOneTimeExceptionThrower(), directExecutor());\n    exceptionInput.set(0);\n    runGetIdempotencyTest(exceptionComposedFuture, MyRuntimeException.class);\n    SettableFuture<Integer> errorInput = SettableFuture.create();\n    ListenableFuture<Integer> errorComposedFuture = transform(errorInput, newOneTimeErrorThrower(), directExecutor());\n    errorInput.set(0);\n    runGetIdempotencyTest(errorComposedFuture, MyError.class);\n    /*\n     * Try again when the input's value is already filled in, since the flow is\n     * slightly different in that case.\n     */\n    exceptionComposedFuture = transform(exceptionInput, newOneTimeExceptionThrower(), directExecutor());\n    runGetIdempotencyTest(exceptionComposedFuture, MyRuntimeException.class);\n    runGetIdempotencyTest(transform(errorInput, newOneTimeErrorThrower(), directExecutor()), MyError.class);\n    runGetIdempotencyTest(errorComposedFuture, MyError.class);\n}", "repo_id": "5", "comment": "/**\n * Test that the function is invoked only once, even if it throws an exception. Also, test that\n * that function's result is wrapped in an ExecutionException.\n */\n", "repo_name": "guava-master/", "id": 3799, "method_signature": "void testTransformExceptionRemainsMemoized()", "filename": "FuturesTest.testTransformExceptionRemainsMemoized.json"}
{"callee_method_names": ["Function<Integer, Integer>.apply", "Function<Integer, Integer>.apply", "Function<Integer, Integer>.apply"], "method_name": "FuturesTest.testTransformValueRemainsMemoized", "method_implementation": "{\n    class Holder {\n\n        int value = 2;\n    }\n    final Holder holder = new Holder();\n    // This function adds the holder's value to the input value.\n    Function<Integer, Integer> adder = new Function<Integer, Integer>() {\n\n        @Override\n        public Integer apply(Integer from) {\n            return from + holder.value;\n        }\n    };\n    // Since holder.value is 2, applying 4 should yield 6.\n    assertEquals(6, adder.apply(4).intValue());\n    ListenableFuture<Integer> immediateFuture = immediateFuture(4);\n    Future<Integer> transformedFuture = transform(immediateFuture, adder, directExecutor());\n    // The composed future also yields 6.\n    assertEquals(6, getDone(transformedFuture).intValue());\n    // Repeated calls yield the same value even though the function's behavior\n    // changes\n    holder.value = 3;\n    assertEquals(6, getDone(transformedFuture).intValue());\n    assertEquals(7, adder.apply(4).intValue());\n    // Once more, with feeling.\n    holder.value = 4;\n    assertEquals(6, getDone(transformedFuture).intValue());\n    assertEquals(8, adder.apply(4).intValue());\n    // Memoized get also retains the value.\n    assertEquals(6, getDoneFromTimeoutOverload(transformedFuture).intValue());\n    // Unsurprisingly, recomposing the future will return an updated value.\n    assertEquals(8, getDone(transform(immediateFuture, adder, directExecutor())).intValue());\n    // Repeating, with the timeout version\n    assertEquals(8, getDoneFromTimeoutOverload(transform(immediateFuture, adder, directExecutor())).intValue());\n}", "repo_id": "5", "comment": "/**\n * Tests that the function is invoked only once, even if it throws an exception.\n */\n", "repo_name": "guava-master/", "id": 3798, "method_signature": "void testTransformValueRemainsMemoized()", "filename": "FuturesTest.testTransformValueRemainsMemoized.json"}
{"callee_method_names": ["SettableFuture<Object>.set", "SettableFuture<Object>.set"], "method_name": "FuturesTest.testTransform_StackOverflow", "method_implementation": "{\n    {\n        /*\n       * Initialize all relevant classes before running the test, which may otherwise poison any\n       * classes it is trying to load during its stack overflow.\n       */\n        SettableFuture<Object> root = SettableFuture.create();\n        ListenableFuture<Object> unused = transform(root, identity(), directExecutor());\n        root.set(\"foo\");\n    }\n    SettableFuture<Object> root = SettableFuture.create();\n    ListenableFuture<Object> output = root;\n    for (int i = 0; i < 10000; i++) {\n        output = transform(output, identity(), directExecutor());\n    }\n    try {\n        root.set(\"foo\");\n        fail();\n    } catch (StackOverflowError expected) {\n    }\n}", "repo_id": "5", "comment": "/*\n   * Android does not handle this stack overflow gracefully... though somehow some other\n   * stack-overflow tests work. It must depend on the exact place the error occurs.\n   */\n", "repo_name": "guava-master/", "id": 3796, "method_signature": "void testTransform_StackOverflow()", "filename": "FuturesTest.testTransform_StackOverflow.json"}
{"callee_method_names": ["CountDownLatch.getCount", "CountDownLatch.getCount", "CountDownLatch.await"], "method_name": "GcFinalization.await", "method_implementation": "{\n    if (latch.getCount() == 0) {\n        return;\n    }\n    long timeoutSeconds = timeoutSeconds();\n    long deadline = System.nanoTime() + SECONDS.toNanos(timeoutSeconds);\n    do {\n        System.runFinalization();\n        if (latch.getCount() == 0) {\n            return;\n        }\n        System.gc();\n        try {\n            if (latch.await(1L, SECONDS)) {\n                return;\n            }\n        } catch (InterruptedException ie) {\n            throw new RuntimeException(\"Unexpected interrupt while waiting for latch\", ie);\n        }\n    } while (System.nanoTime() - deadline < 0);\n    throw formatRuntimeException(\"Latch failed to count down within %d second timeout\", timeoutSeconds);\n}", "repo_id": "5", "comment": "/**\n * Waits until the given latch has {@linkplain CountDownLatch#countDown counted down} to zero,\n * invoking the garbage collector as necessary to try to ensure that this will happen.\n *\n * @throws RuntimeException if timed out or interrupted while waiting\n */\n", "repo_name": "guava-master/", "id": 4114, "method_signature": "void await(CountDownLatch)", "filename": "GcFinalization.await.json"}
{"callee_method_names": ["WeakReference<?>.get"], "method_name": "GcFinalization.awaitClear", "method_implementation": "{\n    awaitDone(new FinalizationPredicate() {\n\n        @Override\n        public boolean isDone() {\n            return ref.get() == null;\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Waits until the given weak reference is cleared, invoking the garbage collector as necessary to\n * try to ensure that this will happen.\n *\n * <p>This is a convenience method, equivalent to:\n *\n * <pre>{@code\n * awaitDone(new FinalizationPredicate() {\n *   public boolean isDone() {\n *     return ref.get() == null;\n *   }\n * });\n * }</pre>\n *\n * @throws RuntimeException if timed out or interrupted while waiting\n */\n", "repo_name": "guava-master/", "id": 4116, "method_signature": "void awaitClear(WeakReference)", "filename": "GcFinalization.awaitClear.json"}
{"callee_method_names": ["FinalizationPredicate.isDone", "FinalizationPredicate.isDone", "FinalizationPredicate.isDone"], "method_name": "GcFinalization.awaitDone", "method_implementation": "{\n    if (predicate.isDone()) {\n        return;\n    }\n    long timeoutSeconds = timeoutSeconds();\n    long deadline = System.nanoTime() + SECONDS.toNanos(timeoutSeconds);\n    do {\n        System.runFinalization();\n        if (predicate.isDone()) {\n            return;\n        }\n        CountDownLatch done = new CountDownLatch(1);\n        createUnreachableLatchFinalizer(done);\n        await(done);\n        if (predicate.isDone()) {\n            return;\n        }\n    } while (System.nanoTime() - deadline < 0);\n    throw formatRuntimeException(\"Predicate did not become true within %d second timeout\", timeoutSeconds);\n}", "repo_id": "5", "comment": "/**\n * Waits until the given predicate returns true, invoking the garbage collector as necessary to\n * try to ensure that this will happen.\n *\n * @throws RuntimeException if timed out or interrupted while waiting\n */\n", "repo_name": "guava-master/", "id": 4113, "method_signature": "void awaitDone(FinalizationPredicate)", "filename": "GcFinalization.awaitDone.json"}
{"callee_method_names": ["CountDownLatch.countDown"], "method_name": "GcFinalization.awaitFullGc", "method_implementation": "{\n    CountDownLatch finalizerRan = new CountDownLatch(1);\n    WeakReference<Object> ref = new WeakReference<>(new Object() {\n\n        @Override\n        protected void finalize() {\n            finalizerRan.countDown();\n        }\n    });\n    await(finalizerRan);\n    awaitClear(ref);\n    // Hope to catch some stragglers queued up behind our finalizable object\n    System.runFinalization();\n}", "repo_id": "5", "comment": "/**\n * Tries to perform a \"full\" garbage collection cycle (including processing of weak references and\n * invocation of finalize methods) and waits for it to complete. Ensures that at least one weak\n * reference has been cleared and one {@code finalize} method has been run before this method\n * returns. This method may be useful when testing the garbage collection mechanism itself, or\n * inhibiting a spontaneous GC initiation in subsequent code.\n *\n * <p>In contrast, a plain call to {@link java.lang.System#gc()} does not ensure finalization\n * processing and may run concurrently, for example, if the JVM flag {@code\n * -XX:+ExplicitGCInvokesConcurrent} is used.\n *\n * <p>Whenever possible, it is preferable to test directly for some observable change resulting\n * from GC, as with {@link #awaitClear}. Because there are no guarantees for the order of GC\n * finalization processing, there may still be some unfinished work for the GC to do after this\n * method returns.\n *\n * <p>This method does not create any memory pressure as would be required to cause soft\n * references to be processed.\n *\n * @throws RuntimeException if timed out or interrupted while waiting\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 4117, "method_signature": "void awaitFullGc()", "filename": "GcFinalization.awaitFullGc.json"}
{"callee_method_names": ["CountDownLatch.countDown"], "method_name": "GcFinalization.createUnreachableLatchFinalizer", "method_implementation": "{\n    Object unused = new Object() {\n\n        @Override\n        protected void finalize() {\n            latch.countDown();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Creates a garbage object that counts down the latch in its finalizer. Sequestered into a\n * separate method to make it somewhat more likely to be unreachable.\n */\n", "repo_name": "guava-master/", "id": 4115, "method_signature": "void createUnreachableLatchFinalizer(CountDownLatch)", "filename": "GcFinalization.createUnreachableLatchFinalizer.json"}
{"callee_method_names": [], "method_name": "GcFinalization.timeoutSeconds", "method_implementation": "{\n    // This class can make no hard guarantees.  The methods in this class are inherently flaky, but\n    // we try hard to make them robust in practice.  We could additionally try to add in a system\n    // load timeout multiplier.  Or we could try to use a CPU time bound instead of wall clock time\n    // bound.  But these ideas are harder to implement.  We do not try to detect or handle a\n    // user-specified -XX:+DisableExplicitGC.\n    //\n    // TODO(user): Consider using\n    // java/lang/management/OperatingSystemMXBean.html#getSystemLoadAverage()\n    //\n    // TODO(user): Consider scaling by number of mutator threads,\n    // e.g. using Thread#activeCount()\n    return Math.max(10L, Runtime.getRuntime().totalMemory() / (32L * 1024L * 1024L));\n}", "repo_id": "5", "comment": "/**\n * 10 seconds ought to be long enough for any object to be GC'ed and finalized. Unless we have a\n * gigantic heap, in which case we scale by heap size.\n */\n", "repo_name": "guava-master/", "id": 4111, "method_signature": "long timeoutSeconds()", "filename": "GcFinalization.timeoutSeconds.json"}
{"callee_method_names": ["CountDownLatch.countDown", "CountDownLatch.getCount", "WeakReference<Object>.get"], "method_name": "GcFinalizationTest.testAwaitFullGc", "method_implementation": "{\n    final CountDownLatch finalizerRan = new CountDownLatch(1);\n    final WeakReference<Object> ref = new WeakReference<Object>(new Object() {\n\n        @Override\n        protected void finalize() {\n            finalizerRan.countDown();\n        }\n    });\n    // Don't copy this into your own test!\n    // Use e.g. awaitClear or await(CountDownLatch) instead.\n    GcFinalization.awaitFullGc();\n    // If this test turns out to be flaky, add a second call to awaitFullGc()\n    // GcFinalization.awaitFullGc();\n    assertEquals(0, finalizerRan.getCount());\n    assertNull(ref.get());\n}", "repo_id": "5", "comment": "/**\n * awaitFullGc() is not quite as reliable a way to ensure calling of a specific finalize method as\n * the more direct await* methods, but should be reliable enough in practice to avoid flakiness of\n * this test. (And if it isn't, we'd like to know about it first!)\n */\n", "repo_name": "guava-master/", "id": 4237, "method_signature": "void testAwaitFullGc()", "filename": "GcFinalizationTest.testAwaitFullGc.json"}
{"callee_method_names": ["Range<T>.hasLowerBound", "Range<T>.lowerEndpoint", "Range<T>.hasLowerBound", "Range<T>.lowerBoundType", "Range<T>.hasUpperBound", "Range<T>.upperEndpoint", "Range<T>.hasUpperBound", "Range<T>.upperBoundType", "Range<T>.hasLowerBound", "Range<T>.hasUpperBound"], "method_name": "GeneralRange.from", "method_implementation": "{\n    T lowerEndpoint = range.hasLowerBound() ? range.lowerEndpoint() : null;\n    BoundType lowerBoundType = range.hasLowerBound() ? range.lowerBoundType() : OPEN;\n    T upperEndpoint = range.hasUpperBound() ? range.upperEndpoint() : null;\n    BoundType upperBoundType = range.hasUpperBound() ? range.upperBoundType() : OPEN;\n    return new GeneralRange<>(Ordering.natural(), range.hasLowerBound(), lowerEndpoint, lowerBoundType, range.hasUpperBound(), upperEndpoint, upperBoundType);\n}", "repo_id": "5", "comment": "/**\n * Converts a Range to a GeneralRange.\n */\n", "repo_name": "guava-master/", "id": 6467, "method_signature": "GeneralRange<T> from(Range)", "filename": "GeneralRange.from.json"}
{"callee_method_names": ["Comparator<? super T>.equals", "GeneralRange<T>.getLowerEndpoint", "GeneralRange<T>.getLowerBoundType", "GeneralRange<T>.hasLowerBound", "Comparator<? super T>.compare", "GeneralRange<T>.getLowerEndpoint", "GeneralRange<T>.getLowerBoundType", "GeneralRange<T>.getLowerEndpoint", "GeneralRange<T>.getLowerBoundType", "GeneralRange<T>.getUpperEndpoint", "GeneralRange<T>.getUpperBoundType", "GeneralRange<T>.hasUpperBound", "Comparator<? super T>.compare", "GeneralRange<T>.getUpperEndpoint", "GeneralRange<T>.getUpperBoundType", "GeneralRange<T>.getUpperEndpoint", "GeneralRange<T>.getUpperBoundType", "Comparator<? super T>.compare"], "method_name": "GeneralRange.intersect", "method_implementation": "{\n    checkNotNull(other);\n    checkArgument(comparator.equals(other.comparator));\n    boolean hasLowBound = this.hasLowerBound;\n    T lowEnd = getLowerEndpoint();\n    BoundType lowType = getLowerBoundType();\n    if (!hasLowerBound()) {\n        hasLowBound = other.hasLowerBound;\n        lowEnd = other.getLowerEndpoint();\n        lowType = other.getLowerBoundType();\n    } else if (other.hasLowerBound()) {\n        int cmp = comparator.compare(getLowerEndpoint(), other.getLowerEndpoint());\n        if (cmp < 0 || (cmp == 0 && other.getLowerBoundType() == OPEN)) {\n            lowEnd = other.getLowerEndpoint();\n            lowType = other.getLowerBoundType();\n        }\n    }\n    boolean hasUpBound = this.hasUpperBound;\n    T upEnd = getUpperEndpoint();\n    BoundType upType = getUpperBoundType();\n    if (!hasUpperBound()) {\n        hasUpBound = other.hasUpperBound;\n        upEnd = other.getUpperEndpoint();\n        upType = other.getUpperBoundType();\n    } else if (other.hasUpperBound()) {\n        int cmp = comparator.compare(getUpperEndpoint(), other.getUpperEndpoint());\n        if (cmp > 0 || (cmp == 0 && other.getUpperBoundType() == OPEN)) {\n            upEnd = other.getUpperEndpoint();\n            upType = other.getUpperBoundType();\n        }\n    }\n    if (hasLowBound && hasUpBound) {\n        int cmp = comparator.compare(lowEnd, upEnd);\n        if (cmp > 0 || (cmp == 0 && lowType == OPEN && upType == OPEN)) {\n            // force allowed empty range\n            lowEnd = upEnd;\n            lowType = OPEN;\n            upType = CLOSED;\n        }\n    }\n    return new GeneralRange<>(comparator, hasLowBound, lowEnd, lowType, hasUpBound, upEnd, upType);\n}", "repo_id": "5", "comment": "/**\n * Returns the intersection of the two ranges, or an empty range if their intersection is empty.\n */\n", "repo_name": "guava-master/", "id": 6469, "method_signature": "GeneralRange<T> intersect(GeneralRange)", "filename": "GeneralRange.intersect.json"}
{"callee_method_names": [], "method_name": "GeneralRange.range", "method_implementation": "{\n    return new GeneralRange<>(comparator, true, lower, lowerType, true, upper, upperType);\n}", "repo_id": "5", "comment": "/**\n * Returns everything between the endpoints relative to the specified comparator, with the\n * specified endpoint behavior.\n */\n", "repo_name": "guava-master/", "id": 6468, "method_signature": "GeneralRange<T> range(Comparator, T, BoundType, T, BoundType)", "filename": "GeneralRange.range.json"}
{"callee_method_names": [], "method_name": "GeneralRange.reverse", "method_implementation": "{\n    GeneralRange<T> result = reverse;\n    if (result == null) {\n        result = new GeneralRange<>(Ordering.from(comparator).reverse(), hasUpperBound, getUpperEndpoint(), getUpperBoundType(), hasLowerBound, getLowerEndpoint(), getLowerBoundType());\n        result.reverse = this;\n        return this.reverse = result;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the same range relative to the reversed comparator.\n */\n", "repo_name": "guava-master/", "id": 6470, "method_signature": "GeneralRange<T> reverse()", "filename": "GeneralRange.reverse.json"}
{"callee_method_names": ["TestSuite.addTest", "TimeoutsToUse.contains", "TestSuite.addTest"], "method_name": "GeneratedMonitorTest.addTests", "method_implementation": "{\n    for (boolean fair : new boolean[] { true, false }) {\n        if (isTimed(method)) {\n            for (Timeout timeout : timeoutsToUse.timeouts) {\n                suite.addTest(new GeneratedMonitorTest(method, scenario, fair, timeout, expectedOutcome));\n            }\n        } else {\n            Timeout implicitTimeout = (isTryEnter(method) ? Timeout.ZERO : Timeout.MAX);\n            if (timeoutsToUse.timeouts.contains(implicitTimeout)) {\n                suite.addTest(new GeneratedMonitorTest(method, scenario, fair, null, expectedOutcome));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Generates test cases for the given combination of scenario and timeouts. For methods that take\n * an explicit timeout value, all of the given timeoutsToUse result in individual test cases. For\n * methods that do not take an explicit timeout value, a single test case is generated only if the\n * implicit timeout of that method matches the given timeoutsToUse. For example, enter() is\n * treated like enter(MAX, MILLIS) and tryEnter() is treated like enter(0, MILLIS).\n */\n", "repo_name": "guava-master/", "id": 3765, "method_signature": "void addTests(TestSuite, Method, Scenario, TimeoutsToUse, Outcome)", "filename": "GeneratedMonitorTest.addTests.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Method.getName", "Monitor.enter", "Method.invoke", "IOException.getTargetException", "Monitor.leave"], "method_name": "GeneratedMonitorTest.generateGuardWithWrongMonitorTestCase", "method_implementation": "{\n    // Not going to bother with all timeouts, just 0ms.\n    final boolean timed = isTimed(method);\n    return new TestCase(method.getName() + (timed ? \"(0ms)\" : \"()\") + \"/WrongMonitor->IMSE\") {\n\n        @Override\n        protected void runTest() throws Throwable {\n            Monitor monitor1 = new Monitor(fair1);\n            Monitor monitor2 = new Monitor(fair2);\n            FlagGuard guard = new FlagGuard(monitor2);\n            Object[] arguments = (timed ? new Object[] { guard, 0L, TimeUnit.MILLISECONDS } : new Object[] { guard });\n            boolean occupyMonitor = isWaitFor(method);\n            if (occupyMonitor) {\n                // If we don't already occupy the monitor, we'll get an IMSE regardless of the guard (see\n                // generateWaitForWhenNotOccupyingTestCase).\n                monitor1.enter();\n            }\n            try {\n                method.invoke(monitor1, arguments);\n                fail(\"expected IllegalMonitorStateException\");\n            } catch (InvocationTargetException e) {\n                assertEquals(IllegalMonitorStateException.class, e.getTargetException().getClass());\n            } finally {\n                if (occupyMonitor) {\n                    monitor1.leave();\n                }\n            }\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Generates a test case verifying that calling any enterXxx, tryEnterXxx, or waitForXxx method\n * with a guard that doesn't match the monitor produces an IllegalMonitorStateException.\n */\n", "repo_name": "guava-master/", "id": 3766, "method_signature": "TestCase generateGuardWithWrongMonitorTestCase(Method, boolean, boolean)", "filename": "GeneratedMonitorTest.generateGuardWithWrongMonitorTestCase.json"}
{"callee_method_names": ["Method.getName", "Method.invoke", "IOException.getTargetException"], "method_name": "GeneratedMonitorTest.generateWaitForWhenNotOccupyingTestCase", "method_implementation": "{\n    // Not going to bother with all timeouts, just 0ms.\n    final boolean timed = isTimed(method);\n    String testName = method.getName() + (fair ? \"(fair)\" : \"(nonfair)\") + (timed ? \"(0ms)\" : \"()\") + \"/NotOccupying->IMSE\";\n    return new TestCase(testName) {\n\n        @Override\n        protected void runTest() throws Throwable {\n            Monitor monitor = new Monitor(fair);\n            FlagGuard guard = new FlagGuard(monitor);\n            Object[] arguments = (timed ? new Object[] { guard, 0L, TimeUnit.MILLISECONDS } : new Object[] { guard });\n            try {\n                method.invoke(monitor, arguments);\n                fail(\"expected IllegalMonitorStateException\");\n            } catch (InvocationTargetException e) {\n                assertEquals(IllegalMonitorStateException.class, e.getTargetException().getClass());\n            }\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Generates a test case verifying that calling any waitForXxx method when not occupying the\n * monitor produces an IllegalMonitorStateException.\n */\n", "repo_name": "guava-master/", "id": 3767, "method_signature": "TestCase generateWaitForWhenNotOccupyingTestCase(Method, boolean)", "filename": "GeneratedMonitorTest.generateWaitForWhenNotOccupyingTestCase.json"}
{"callee_method_names": ["Method.getParameterTypes"], "method_name": "GeneratedMonitorTest.isDurationBased", "method_implementation": "{\n    Class<?>[] parameterTypes = method.getParameterTypes();\n    return parameterTypes.length >= 1 && parameterTypes[parameterTypes.length - 1] == Duration.class;\n}", "repo_id": "5", "comment": "/**\n * Determines whether the given method takes a Duration as its last parameter.\n */\n", "repo_name": "guava-master/", "id": 290, "method_signature": "boolean isDurationBased(Method)", "filename": "GeneratedMonitorTest.isDurationBased.json"}
{"callee_method_names": ["Method.getParameterTypes"], "method_name": "GeneratedMonitorTest.isLongTimeUnitBased", "method_implementation": "{\n    Class<?>[] parameterTypes = method.getParameterTypes();\n    return parameterTypes.length >= 2 && parameterTypes[parameterTypes.length - 2] == long.class && parameterTypes[parameterTypes.length - 1] == TimeUnit.class;\n}", "repo_id": "5", "comment": "/**\n * Determines whether the given method takes a time and unit as its last two parameters.\n */\n", "repo_name": "guava-master/", "id": 289, "method_signature": "boolean isLongTimeUnitBased(Method)", "filename": "GeneratedMonitorTest.isLongTimeUnitBased.json"}
{"callee_method_names": ["Method.getParameterTypes"], "method_name": "GeneratedMonitorTest.isTimed", "method_implementation": "{\n    Class<?>[] parameterTypes = method.getParameterTypes();\n    return parameterTypes.length >= 2 && parameterTypes[parameterTypes.length - 2] == long.class && parameterTypes[parameterTypes.length - 1] == TimeUnit.class;\n}", "repo_id": "5", "comment": "/**\n * Determines whether the given method takes a time and unit as its last two parameters.\n */\n", "repo_name": "guava-master/", "id": 3761, "method_signature": "boolean isTimed(Method)", "filename": "GeneratedMonitorTest.isTimed.json"}
{"callee_method_names": ["AssertionError.initCause"], "method_name": "GeneratedMonitorTest.newAssertionError", "method_implementation": "{\n    AssertionError e = new AssertionError(message);\n    e.initCause(cause);\n    return e;\n}", "repo_id": "5", "comment": "/**\n * Alternative to AssertionError(String, Throwable), which doesn't exist in Java 1.6\n */\n", "repo_name": "guava-master/", "id": 3768, "method_signature": "AssertionError newAssertionError(String, Throwable)", "filename": "GeneratedMonitorTest.newAssertionError.json"}
{"callee_method_names": [], "method_name": "GeneratedMonitorTest.sortMethods", "method_implementation": "{\n    Arrays.sort(methods, new Comparator<Method>() {\n\n        @Override\n        public int compare(Method m1, Method m2) {\n            int nameComparison = m1.getName().compareTo(m2.getName());\n            if (nameComparison != 0) {\n                return nameComparison;\n            } else {\n                return Ints.compare(m1.getParameterTypes().length, m2.getParameterTypes().length);\n            }\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Sorts the given methods primarily by name and secondarily by number of parameters.\n */\n", "repo_name": "guava-master/", "id": 3762, "method_signature": "void sortMethods(Method[])", "filename": "GeneratedMonitorTest.sortMethods.json"}
{"callee_method_names": ["Method.toString", "Method.getParameterTypes", "Method.getReturnType", "Method.getExceptionTypes"], "method_name": "GeneratedMonitorTest.validateMethod", "method_implementation": "{\n    String desc = method.toString();\n    assertTrue(desc, isAnyEnter(method) || isWaitFor(method));\n    switch(method.getParameterTypes().length) {\n        case 0:\n            assertFalse(desc, isGuarded(method));\n            assertFalse(desc, isTimed(method));\n            break;\n        case 1:\n            assertTrue(desc, isGuarded(method));\n            assertFalse(desc, isTimed(method));\n            break;\n        case 2:\n            assertFalse(desc, isGuarded(method));\n            assertTrue(desc, isTimed(method));\n            break;\n        case 3:\n            assertTrue(desc, isGuarded(method));\n            assertTrue(desc, isTimed(method));\n            break;\n        default:\n            fail(desc);\n    }\n    if (method.getReturnType() == void.class) {\n        assertFalse(desc, isBoolean(method));\n    } else {\n        assertTrue(desc, isBoolean(method));\n    }\n    switch(method.getExceptionTypes().length) {\n        case 0:\n            assertFalse(desc, isInterruptible(method));\n            break;\n        case 1:\n            assertTrue(desc, isInterruptible(method));\n            break;\n        default:\n            fail(desc);\n    }\n    if (isEnterIf(method)) {\n        assertTrue(desc, isGuarded(method));\n        assertTrue(desc, isBoolean(method));\n    } else if (isTryEnter(method)) {\n        assertFalse(desc, isTimed(method));\n        assertTrue(desc, isBoolean(method));\n        assertFalse(desc, isInterruptible(method));\n    } else if (isWaitFor(method)) {\n        assertTrue(desc, isGuarded(method));\n        assertEquals(desc, isTimed(method), isBoolean(method));\n    } else {\n        // any other enterXxx method\n        assertEquals(desc, isTimed(method), isBoolean(method));\n    }\n}", "repo_id": "5", "comment": "/**\n * Validates that the given method's signature meets all of our assumptions.\n */\n", "repo_name": "guava-master/", "id": 3763, "method_signature": "void validateMethod(Method)", "filename": "GeneratedMonitorTest.validateMethod.json"}
{"callee_method_names": ["Class<? extends Enum>.getEnumConstants"], "method_name": "GetCheckedTypeValidatorHolder.getBestValidator", "method_implementation": "{\n    try {\n        Class<? extends Enum> theClass = Class.forName(CLASS_VALUE_VALIDATOR_NAME).asSubclass(Enum.class);\n        return (GetCheckedTypeValidator) theClass.getEnumConstants()[0];\n    } catch (ClassNotFoundException | RuntimeException | Error t) {\n        // ensure we really catch *everything*\n        return weakSetValidator();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the ClassValue-using validator, or falls back to the \"weak Set\" implementation if\n * unable to do so.\n */\n", "repo_name": "guava-master/", "id": 1953, "method_signature": "GetCheckedTypeValidator getBestValidator()", "filename": "GetCheckedTypeValidatorHolder.getBestValidator.json"}
{"callee_method_names": [], "method_name": "GraphBuilder.allowsSelfLoops", "method_implementation": "{\n    this.allowsSelfLoops = allowsSelfLoops;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies whether the graph will allow self-loops (edges that connect a node to itself).\n * Attempting to add a self-loop to a graph that does not allow them will throw an {@link\n * UnsupportedOperationException}.\n *\n * <p>The default value is {@code false}.\n */\n", "repo_name": "guava-master/", "id": 6753, "method_signature": "GraphBuilder<N> allowsSelfLoops(boolean)", "filename": "GraphBuilder.allowsSelfLoops.json"}
{"callee_method_names": [], "method_name": "GraphBuilder.expectedNodeCount", "method_implementation": "{\n    this.expectedNodeCount = Optional.of(checkNonNegative(expectedNodeCount));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the expected number of nodes in the graph.\n *\n * @throws IllegalArgumentException if {@code expectedNodeCount} is negative\n */\n", "repo_name": "guava-master/", "id": 6754, "method_signature": "GraphBuilder<N> expectedNodeCount(int)", "filename": "GraphBuilder.expectedNodeCount.json"}
{"callee_method_names": ["Graph<N>.isDirected", "Graph<N>.allowsSelfLoops", "Graph<N>.nodeOrder", "Graph<N>.incidentEdgeOrder"], "method_name": "GraphBuilder.from", "method_implementation": "{\n    return new GraphBuilder<N>(graph.isDirected()).allowsSelfLoops(graph.allowsSelfLoops()).nodeOrder(graph.nodeOrder()).incidentEdgeOrder(graph.incidentEdgeOrder());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link GraphBuilder} initialized with all properties queryable from {@code graph}.\n *\n * <p>The \"queryable\" properties are those that are exposed through the {@link Graph} interface,\n * such as {@link Graph#isDirected()}. Other properties, such as {@link #expectedNodeCount(int)},\n * are not set in the new builder.\n */\n", "repo_name": "guava-master/", "id": 6752, "method_signature": "GraphBuilder<N> from(Graph)", "filename": "GraphBuilder.from.json"}
{"callee_method_names": ["ElementOrder<N1>.type", "ElementOrder<N1>.type"], "method_name": "GraphBuilder.incidentEdgeOrder", "method_implementation": "{\n    checkArgument(incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED || incidentEdgeOrder.type() == ElementOrder.Type.STABLE, \"The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports\" + \" ElementOrder.unordered() and ElementOrder.stable().\", incidentEdgeOrder);\n    GraphBuilder<N1> newBuilder = cast();\n    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n    return newBuilder;\n}", "repo_id": "5", "comment": "/**\n * Specifies the order of iteration for the elements of {@link Graph#edges()}, {@link\n * Graph#adjacentNodes(Object)}, {@link Graph#predecessors(Object)}, {@link\n * Graph#successors(Object)} and {@link Graph#incidentEdges(Object)}.\n *\n * <p>The default value is {@link ElementOrder#unordered() unordered} for mutable graphs. For\n * immutable graphs, this value is ignored; they always have a {@link ElementOrder#stable()\n * stable} order.\n *\n * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code\n *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.\n * @since 29.0\n */\n", "repo_name": "guava-master/", "id": 6756, "method_signature": "GraphBuilder<N1> incidentEdgeOrder(ElementOrder)", "filename": "GraphBuilder.incidentEdgeOrder.json"}
{"callee_method_names": [], "method_name": "GraphBuilder.nodeOrder", "method_implementation": "{\n    GraphBuilder<N1> newBuilder = cast();\n    newBuilder.nodeOrder = checkNotNull(nodeOrder);\n    return newBuilder;\n}", "repo_id": "5", "comment": "/**\n * Specifies the order of iteration for the elements of {@link Graph#nodes()}.\n *\n * <p>The default value is {@link ElementOrder#insertion() insertion order}.\n */\n", "repo_name": "guava-master/", "id": 6755, "method_signature": "GraphBuilder<N1> nodeOrder(ElementOrder)", "filename": "GraphBuilder.nodeOrder.json"}
{"callee_method_names": ["MutableGraph<Integer>.putEdge", "MutableGraph<Integer>.putEdge"], "method_name": "GraphEquivalenceTest.equivalent_directedVsUndirected", "method_implementation": "{\n    graph.putEdge(N1, N2);\n    MutableGraph<Integer> g2 = createGraph(oppositeType(edgeType));\n    g2.putEdge(N1, N2);\n    assertThat(graph).isNotEqualTo(g2);\n}", "repo_id": "5", "comment": "// Node/edge sets are the same, but node/edge connections differ due to edge type.\n", "repo_name": "guava-master/", "id": 4052, "method_signature": "void equivalent_directedVsUndirected()", "filename": "GraphEquivalenceTest.equivalent_directedVsUndirected.json"}
{"callee_method_names": ["GraphBuilder<Integer>.build", "GraphBuilder<Integer>.build", "MutableGraph<Integer>.putEdge", "MutableGraph<Integer>.putEdge", "MutableGraph<Integer>.putEdge", "MutableGraph<Integer>.putEdge"], "method_name": "GraphEquivalenceTest.equivalent_edgeAddOrdersDiffer", "method_implementation": "{\n    GraphBuilder<Integer> builder = GraphBuilder.from(graph);\n    MutableGraph<Integer> g1 = builder.build();\n    MutableGraph<Integer> g2 = builder.build();\n    // for g1, add 1->2 first, then 3->1\n    g1.putEdge(N1, N2);\n    g1.putEdge(N3, N1);\n    // for g2, add 3->1 first, then 1->2\n    g2.putEdge(N3, N1);\n    g2.putEdge(N1, N2);\n    assertThat(g1).isEqualTo(g2);\n}", "repo_id": "5", "comment": "// In this case the graphs are considered equivalent; the edge add orderings are irrelevant.\n", "repo_name": "guava-master/", "id": 4055, "method_signature": "void equivalent_edgeAddOrdersDiffer()", "filename": "GraphEquivalenceTest.equivalent_edgeAddOrdersDiffer.json"}
{"callee_method_names": ["MutableGraph<Integer>.putEdge", "MutableGraph<Integer>.allowsSelfLoops", "MutableGraph<Integer>.putEdge"], "method_name": "GraphEquivalenceTest.equivalent_propertiesDiffer", "method_implementation": "{\n    graph.putEdge(N1, N2);\n    MutableGraph<Integer> g2 = GraphBuilder.from(graph).allowsSelfLoops(!graph.allowsSelfLoops()).build();\n    g2.putEdge(N1, N2);\n    assertThat(graph).isEqualTo(g2);\n}", "repo_id": "5", "comment": "// In this case the graphs are considered equivalent; the property differences are irrelevant.\n", "repo_name": "guava-master/", "id": 4054, "method_signature": "void equivalent_propertiesDiffer()", "filename": "GraphEquivalenceTest.equivalent_propertiesDiffer.json"}
{"callee_method_names": ["MutableGraph<Integer>.putEdge", "MutableGraph<Integer>.putEdge"], "method_name": "GraphEquivalenceTest.equivalent_selfLoop_directedVsUndirected", "method_implementation": "{\n    graph.putEdge(N1, N1);\n    MutableGraph<Integer> g2 = createGraph(oppositeType(edgeType));\n    g2.putEdge(N1, N1);\n    assertThat(graph).isNotEqualTo(g2);\n}", "repo_id": "5", "comment": "// Node/edge sets and node/edge connections are the same, but directedness differs.\n", "repo_name": "guava-master/", "id": 4053, "method_signature": "void equivalent_selfLoop_directedVsUndirected()", "filename": "GraphEquivalenceTest.equivalent_selfLoop_directedVsUndirected.json"}
{"callee_method_names": ["Graph<?>.isDirected"], "method_name": "Graphs.canTraverseWithoutReusingEdge", "method_implementation": "{\n    if (graph.isDirected() || !Objects.equal(previousNode, nextNode)) {\n        return true;\n    }\n    // This falls into the undirected A->B->A case. The Graph interface does not support parallel\n    // edges, so this traversal would require reusing the undirected AB edge.\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Determines whether an edge has already been used during traversal. In the directed case a cycle\n * is always detected before reusing an edge, so no special logic is required. In the undirected\n * case, we must take care not to \"backtrack\" over an edge (i.e. going from A to B and then going\n * from B to A).\n */\n", "repo_name": "guava-master/", "id": 6767, "method_signature": "boolean canTraverseWithoutReusingEdge(Graph, Object, Object)", "filename": "Graphs.canTraverseWithoutReusingEdge.json"}
{"callee_method_names": ["Network<N,E>.nodes", "Network<N,E>.edges", "Network<N,E>.nodes", "MutableNetwork<N, E>.addNode", "Network<N,E>.edges", "Network<N,E>.incidentNodes", "MutableNetwork<N, E>.addEdge", "EndpointPair<N>.nodeU", "EndpointPair<N>.nodeV"], "method_name": "Graphs.copyOf", "method_implementation": "{\n    MutableNetwork<N, E> copy = NetworkBuilder.from(network).expectedNodeCount(network.nodes().size()).expectedEdgeCount(network.edges().size()).build();\n    for (N node : network.nodes()) {\n        copy.addNode(node);\n    }\n    for (E edge : network.edges()) {\n        EndpointPair<N> endpointPair = network.incidentNodes(edge);\n        copy.addEdge(endpointPair.nodeU(), endpointPair.nodeV(), edge);\n    }\n    return copy;\n}", "repo_id": "5", "comment": "/**\n * Creates a mutable copy of {@code network} with the same nodes and edges.\n */\n", "repo_name": "guava-master/", "id": 6777, "method_signature": "MutableNetwork<N,E> copyOf(Network)", "filename": "Graphs.copyOf.json"}
{"callee_method_names": ["Network<?,?>.isDirected", "Network<?,?>.allowsParallelEdges", "Network<?,?>.edges", "Network<?,?>.asGraph", "Network<?,?>.asGraph"], "method_name": "Graphs.hasCycle", "method_implementation": "{\n    // In a directed graph, parallel edges cannot introduce a cycle in an acyclic graph.\n    // However, in an undirected graph, any parallel edge induces a cycle in the graph.\n    if (!network.isDirected() && network.allowsParallelEdges() && network.edges().size() > network.asGraph().edges().size()) {\n        return true;\n    }\n    return hasCycle(network.asGraph());\n}", "repo_id": "5", "comment": "/**\n * Returns true if {@code network} has at least one cycle. A cycle is defined as a non-empty\n * subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)\n * starting and ending with the same node.\n *\n * <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1).\n */\n", "repo_name": "guava-master/", "id": 6765, "method_signature": "boolean hasCycle(Network)", "filename": "Graphs.hasCycle.json"}
{"callee_method_names": ["MutableNetwork<N, E>.addNode", "MutableNetwork<N, E>.nodes", "Network<N,E>.outEdges", "Network<N,E>.incidentNodes", "MutableNetwork<N, E>.nodes", "MutableNetwork<N, E>.addEdge"], "method_name": "Graphs.inducedSubgraph", "method_implementation": "{\n    MutableNetwork<N, E> subgraph = (nodes instanceof Collection) ? NetworkBuilder.from(network).expectedNodeCount(((Collection) nodes).size()).build() : NetworkBuilder.from(network).build();\n    for (N node : nodes) {\n        subgraph.addNode(node);\n    }\n    for (N node : subgraph.nodes()) {\n        for (E edge : network.outEdges(node)) {\n            N successorNode = network.incidentNodes(edge).adjacentNode(node);\n            if (subgraph.nodes().contains(successorNode)) {\n                subgraph.addEdge(node, successorNode, edge);\n            }\n        }\n    }\n    return subgraph;\n}", "repo_id": "5", "comment": "/**\n * Returns the subgraph of {@code network} induced by {@code nodes}. This subgraph is a new graph\n * that contains all of the nodes in {@code nodes}, and all of the {@link Network#edges() edges}\n * from {@code network} for which the {@link Network#incidentNodes(Object) incident nodes} are\n * both contained by {@code nodes}.\n *\n * @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph\n */\n", "repo_name": "guava-master/", "id": 6774, "method_signature": "MutableNetwork<N,E> inducedSubgraph(Network, Iterable)", "filename": "Graphs.inducedSubgraph.json"}
{"callee_method_names": ["Map<Object,NodeVisitState>.get", "Map<Object,NodeVisitState>.put", "Graph<N>.successors", "Map<Object,NodeVisitState>.put"], "method_name": "Graphs.subgraphHasCycle", "method_implementation": "{\n    NodeVisitState state = visitedNodes.get(node);\n    if (state == NodeVisitState.COMPLETE) {\n        return false;\n    }\n    if (state == NodeVisitState.PENDING) {\n        return true;\n    }\n    visitedNodes.put(node, NodeVisitState.PENDING);\n    for (N nextNode : graph.successors(node)) {\n        if (canTraverseWithoutReusingEdge(graph, nextNode, previousNode) && subgraphHasCycle(graph, visitedNodes, nextNode, node)) {\n            return true;\n        }\n    }\n    visitedNodes.put(node, NodeVisitState.COMPLETE);\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Performs a traversal of the nodes reachable from {@code node}. If we ever reach a node we've\n * already visited (following only outgoing edges and without reusing edges), we know there's a\n * cycle in the graph.\n */\n", "repo_name": "guava-master/", "id": 6766, "method_signature": "boolean subgraphHasCycle(Graph, Map, N, N)", "filename": "Graphs.subgraphHasCycle.json"}
{"callee_method_names": ["Graph<N>.isDirected", "Graph<N>.nodes", "MutableGraph<N>.putEdge", "Graph<N>.nodes", "Set<N>.contains", "Set<N>.addAll", "MutableGraph<N>.putEdge"], "method_name": "Graphs.transitiveClosure", "method_implementation": "{\n    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n    if (graph.isDirected()) {\n        // Note: works for both directed and undirected graphs, but we only use in the directed case.\n        for (N node : graph.nodes()) {\n            for (N reachableNode : reachableNodes(graph, node)) {\n                transitiveClosure.putEdge(node, reachableNode);\n            }\n        }\n    } else {\n        // An optimization for the undirected case: for every node B reachable from node A,\n        // node A and node B have the same reachability set.\n        Set<N> visitedNodes = new HashSet<N>();\n        for (N node : graph.nodes()) {\n            if (!visitedNodes.contains(node)) {\n                Set<N> reachableNodes = reachableNodes(graph, node);\n                visitedNodes.addAll(reachableNodes);\n                // start at 1 to include self-loops\n                int pairwiseMatch = 1;\n                for (N nodeU : reachableNodes) {\n                    for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {\n                        transitiveClosure.putEdge(nodeU, nodeV);\n                    }\n                }\n            }\n        }\n    }\n    return transitiveClosure;\n}", "repo_id": "5", "comment": "// TODO(b/31438252): Consider potential optimizations for this algorithm.\n", "repo_name": "guava-master/", "id": 6768, "method_signature": "Graph<N> transitiveClosure(Graph)", "filename": "Graphs.transitiveClosure.json"}
{"callee_method_names": ["Network<N,E>.isDirected"], "method_name": "Graphs.transpose", "method_implementation": "{\n    if (!network.isDirected()) {\n        // the transpose of an undirected network is an identical network\n        return network;\n    }\n    if (network instanceof TransposedNetwork) {\n        return ((TransposedNetwork<N, E>) network).network;\n    }\n    return new TransposedNetwork<>(network);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of {@code network} with the direction (if any) of every edge reversed. All other\n * properties remain intact, and further updates to {@code network} will be reflected in the view.\n */\n", "repo_name": "guava-master/", "id": 6771, "method_signature": "Network<N,E> transpose(Network)", "filename": "Graphs.transpose.json"}
{"callee_method_names": ["HashBasedTable<R, C, V>.putAll"], "method_name": "HashBasedTable.create", "method_implementation": "{\n    HashBasedTable<R, C, V> result = create();\n    result.putAll(table);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code HashBasedTable} with the same mappings as the specified table.\n *\n * @param table the table to copy\n * @throws NullPointerException if any of the row keys, column keys, or values in {@code table} is\n *     null\n */\n", "repo_name": "guava-master/", "id": 6603, "method_signature": "HashBasedTable<R,C,V> create(Table)", "filename": "HashBasedTable.create.json"}
{"callee_method_names": ["Map<? extends K,? extends V>.size", "HashBiMap<K, V>.putAll"], "method_name": "HashBiMap.create", "method_implementation": "{\n    HashBiMap<K, V> bimap = create(map.size());\n    bimap.putAll(map);\n    return bimap;\n}", "repo_id": "5", "comment": "/**\n * Constructs a new bimap containing initial values from {@code map}. The bimap is created with an\n * initial capacity sufficient to hold the mappings in the specified map.\n */\n", "repo_name": "guava-master/", "id": 6223, "method_signature": "HashBiMap<K,V> create(Map)", "filename": "HashBiMap.create.json"}
{"callee_method_names": [], "method_name": "HashBiMap.createFilledWithAbsent", "method_implementation": "{\n    int[] array = new int[size];\n    Arrays.fill(array, ABSENT);\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns an int array of the specified size, filled with ABSENT.\n */\n", "repo_name": "guava-master/", "id": 6224, "method_signature": "int[] createFilledWithAbsent(int)", "filename": "HashBiMap.createFilledWithAbsent.json"}
{"callee_method_names": [], "method_name": "HashBiMap.delete", "method_implementation": "{\n    int keyBucket = entry.keyHash & mask;\n    BiEntry<K, V> prevBucketEntry = null;\n    for (BiEntry<K, V> bucketEntry = hashTableKToV[keyBucket]; true; bucketEntry = bucketEntry.nextInKToVBucket) {\n        if (bucketEntry == entry) {\n            if (prevBucketEntry == null) {\n                hashTableKToV[keyBucket] = entry.nextInKToVBucket;\n            } else {\n                prevBucketEntry.nextInKToVBucket = entry.nextInKToVBucket;\n            }\n            break;\n        }\n        prevBucketEntry = bucketEntry;\n    }\n    int valueBucket = entry.valueHash & mask;\n    prevBucketEntry = null;\n    for (BiEntry<K, V> bucketEntry = hashTableVToK[valueBucket]; true; bucketEntry = bucketEntry.nextInVToKBucket) {\n        if (bucketEntry == entry) {\n            if (prevBucketEntry == null) {\n                hashTableVToK[valueBucket] = entry.nextInVToKBucket;\n            } else {\n                prevBucketEntry.nextInVToKBucket = entry.nextInVToKBucket;\n            }\n            break;\n        }\n        prevBucketEntry = bucketEntry;\n    }\n    if (entry.prevInKeyInsertionOrder == null) {\n        firstInKeyInsertionOrder = entry.nextInKeyInsertionOrder;\n    } else {\n        entry.prevInKeyInsertionOrder.nextInKeyInsertionOrder = entry.nextInKeyInsertionOrder;\n    }\n    if (entry.nextInKeyInsertionOrder == null) {\n        lastInKeyInsertionOrder = entry.prevInKeyInsertionOrder;\n    } else {\n        entry.nextInKeyInsertionOrder.prevInKeyInsertionOrder = entry.prevInKeyInsertionOrder;\n    }\n    size--;\n    modCount++;\n}", "repo_id": "5", "comment": "/**\n * Finds and removes {@code entry} from the bucket linked lists in both the key-to-value direction\n * and the value-to-key direction.\n */\n", "repo_name": "guava-master/", "id": 2867, "method_signature": "void delete(BiEntry)", "filename": "HashBiMap.delete.json"}
{"callee_method_names": [], "method_name": "HashBiMap.deleteFromTableKToV", "method_implementation": "{\n    checkArgument(entry != ABSENT);\n    int keyBucket = bucket(keyHash);\n    if (hashTableKToV[keyBucket] == entry) {\n        hashTableKToV[keyBucket] = nextInBucketKToV[entry];\n        nextInBucketKToV[entry] = ABSENT;\n        return;\n    }\n    int prevInBucket = hashTableKToV[keyBucket];\n    for (int entryInBucket = nextInBucketKToV[prevInBucket]; entryInBucket != ABSENT; entryInBucket = nextInBucketKToV[entryInBucket]) {\n        if (entryInBucket == entry) {\n            nextInBucketKToV[prevInBucket] = nextInBucketKToV[entry];\n            nextInBucketKToV[entry] = ABSENT;\n            return;\n        }\n        prevInBucket = entryInBucket;\n    }\n    throw new AssertionError(\"Expected to find entry with key \" + keys[entry]);\n}", "repo_id": "5", "comment": "/**\n * Updates the K-to-V hash table to remove the entry at the specified index, which is assumed to\n * be present. Does not update any other data structures.\n */\n", "repo_name": "guava-master/", "id": 6230, "method_signature": "void deleteFromTableKToV(int, int)", "filename": "HashBiMap.deleteFromTableKToV.json"}
{"callee_method_names": [], "method_name": "HashBiMap.deleteFromTableVToK", "method_implementation": "{\n    checkArgument(entry != ABSENT);\n    int valueBucket = bucket(valueHash);\n    if (hashTableVToK[valueBucket] == entry) {\n        hashTableVToK[valueBucket] = nextInBucketVToK[entry];\n        nextInBucketVToK[entry] = ABSENT;\n        return;\n    }\n    int prevInBucket = hashTableVToK[valueBucket];\n    for (int entryInBucket = nextInBucketVToK[prevInBucket]; entryInBucket != ABSENT; entryInBucket = nextInBucketVToK[entryInBucket]) {\n        if (entryInBucket == entry) {\n            nextInBucketVToK[prevInBucket] = nextInBucketVToK[entry];\n            nextInBucketVToK[entry] = ABSENT;\n            return;\n        }\n        prevInBucket = entryInBucket;\n    }\n    throw new AssertionError(\"Expected to find entry with value \" + values[entry]);\n}", "repo_id": "5", "comment": "/**\n * Updates the V-to-K hash table to remove the entry at the specified index, which is assumed to\n * be present. Does not update any other data structures.\n */\n", "repo_name": "guava-master/", "id": 6231, "method_signature": "void deleteFromTableVToK(int, int)", "filename": "HashBiMap.deleteFromTableVToK.json"}
{"callee_method_names": [], "method_name": "HashBiMap.ensureCapacity", "method_implementation": "{\n    if (nextInBucketKToV.length < minCapacity) {\n        int oldCapacity = nextInBucketKToV.length;\n        int newCapacity = ImmutableCollection.Builder.expandedCapacity(oldCapacity, minCapacity);\n        keys = Arrays.copyOf(keys, newCapacity);\n        values = Arrays.copyOf(values, newCapacity);\n        nextInBucketKToV = expandAndFillWithAbsent(nextInBucketKToV, newCapacity);\n        nextInBucketVToK = expandAndFillWithAbsent(nextInBucketVToK, newCapacity);\n        prevInInsertionOrder = expandAndFillWithAbsent(prevInInsertionOrder, newCapacity);\n        nextInInsertionOrder = expandAndFillWithAbsent(nextInInsertionOrder, newCapacity);\n    }\n    if (hashTableKToV.length < minCapacity) {\n        int newTableSize = Hashing.closedTableSize(minCapacity, 1.0);\n        hashTableKToV = createFilledWithAbsent(newTableSize);\n        hashTableVToK = createFilledWithAbsent(newTableSize);\n        for (int entryToRehash = 0; entryToRehash < size; entryToRehash++) {\n            int keyHash = Hashing.smearedHash(keys[entryToRehash]);\n            int keyBucket = bucket(keyHash);\n            nextInBucketKToV[entryToRehash] = hashTableKToV[keyBucket];\n            hashTableKToV[keyBucket] = entryToRehash;\n            int valueHash = Hashing.smearedHash(values[entryToRehash]);\n            int valueBucket = bucket(valueHash);\n            nextInBucketVToK[entryToRehash] = hashTableVToK[valueBucket];\n            hashTableVToK[valueBucket] = entryToRehash;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures that all of the internal structures in the HashBiMap are ready for this many elements.\n */\n", "repo_name": "guava-master/", "id": 6226, "method_signature": "void ensureCapacity(int)", "filename": "HashBiMap.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "HashBiMap.expandAndFillWithAbsent", "method_implementation": "{\n    int oldSize = array.length;\n    int[] result = Arrays.copyOf(array, newSize);\n    Arrays.fill(result, oldSize, newSize, ABSENT);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Equivalent to {@code Arrays.copyOf(array, newSize)}, save that the new elements are ABSENT.\n */\n", "repo_name": "guava-master/", "id": 6225, "method_signature": "int[] expandAndFillWithAbsent(int[], int)", "filename": "HashBiMap.expandAndFillWithAbsent.json"}
{"callee_method_names": [], "method_name": "HashBiMap.insertIntoTableKToV", "method_implementation": "{\n    checkArgument(entry != ABSENT);\n    int keyBucket = bucket(keyHash);\n    nextInBucketKToV[entry] = hashTableKToV[keyBucket];\n    hashTableKToV[keyBucket] = entry;\n}", "repo_id": "5", "comment": "/**\n * Updates the K-to-V hash table to include the entry at the specified index, which is assumed to\n * have not yet been added.\n */\n", "repo_name": "guava-master/", "id": 6228, "method_signature": "void insertIntoTableKToV(int, int)", "filename": "HashBiMap.insertIntoTableKToV.json"}
{"callee_method_names": [], "method_name": "HashBiMap.insertIntoTableVToK", "method_implementation": "{\n    checkArgument(entry != ABSENT);\n    int valueBucket = bucket(valueHash);\n    nextInBucketVToK[entry] = hashTableVToK[valueBucket];\n    hashTableVToK[valueBucket] = entry;\n}", "repo_id": "5", "comment": "/**\n * Updates the V-to-K hash table to include the entry at the specified index, which is assumed to\n * have not yet been added.\n */\n", "repo_name": "guava-master/", "id": 6229, "method_signature": "void insertIntoTableVToK(int, int)", "filename": "HashBiMap.insertIntoTableVToK.json"}
{"callee_method_names": [], "method_name": "HashBiMap.moveEntryToIndex", "method_implementation": "{\n    if (src == dest) {\n        return;\n    }\n    int predecessor = prevInInsertionOrder[src];\n    int successor = nextInInsertionOrder[src];\n    setSucceeds(predecessor, dest);\n    setSucceeds(dest, successor);\n    K key = keys[src];\n    V value = values[src];\n    keys[dest] = key;\n    values[dest] = value;\n    // update pointers in hashTableKToV\n    int keyHash = Hashing.smearedHash(key);\n    int keyBucket = bucket(keyHash);\n    if (hashTableKToV[keyBucket] == src) {\n        hashTableKToV[keyBucket] = dest;\n    } else {\n        int prevInBucket = hashTableKToV[keyBucket];\n        for (int entryInBucket = nextInBucketKToV[prevInBucket]; ; /* should never reach end */\n        entryInBucket = nextInBucketKToV[entryInBucket]) {\n            if (entryInBucket == src) {\n                nextInBucketKToV[prevInBucket] = dest;\n                break;\n            }\n            prevInBucket = entryInBucket;\n        }\n    }\n    nextInBucketKToV[dest] = nextInBucketKToV[src];\n    nextInBucketKToV[src] = ABSENT;\n    // update pointers in hashTableVToK\n    int valueHash = Hashing.smearedHash(value);\n    int valueBucket = bucket(valueHash);\n    if (hashTableVToK[valueBucket] == src) {\n        hashTableVToK[valueBucket] = dest;\n    } else {\n        int prevInBucket = hashTableVToK[valueBucket];\n        for (int entryInBucket = nextInBucketVToK[prevInBucket]; ; /* should never reach end*/\n        entryInBucket = nextInBucketVToK[entryInBucket]) {\n            if (entryInBucket == src) {\n                nextInBucketVToK[prevInBucket] = dest;\n                break;\n            }\n            prevInBucket = entryInBucket;\n        }\n    }\n    nextInBucketVToK[dest] = nextInBucketVToK[src];\n    nextInBucketVToK[src] = ABSENT;\n}", "repo_id": "5", "comment": "/**\n * Moves the entry previously positioned at {@code src} to {@code dest}. Assumes the entry\n * previously at {@code src} has already been removed from the data structures.\n */\n", "repo_name": "guava-master/", "id": 6235, "method_signature": "void moveEntryToIndex(int, int)", "filename": "HashBiMap.moveEntryToIndex.json"}
{"callee_method_names": [], "method_name": "HashBiMap.removeEntry", "method_implementation": "{\n    checkArgument(entry != ABSENT);\n    deleteFromTableKToV(entry, keyHash);\n    deleteFromTableVToK(entry, valueHash);\n    int oldPredecessor = prevInInsertionOrder[entry];\n    int oldSuccessor = nextInInsertionOrder[entry];\n    setSucceeds(oldPredecessor, oldSuccessor);\n    moveEntryToIndex(size - 1, entry);\n    keys[size - 1] = null;\n    values[size - 1] = null;\n    size--;\n    modCount++;\n}", "repo_id": "5", "comment": "/**\n * Removes the entry at the specified index, given the hash of its key and value.\n */\n", "repo_name": "guava-master/", "id": 6234, "method_signature": "void removeEntry(int, int, int)", "filename": "HashBiMap.removeEntry.json"}
{"callee_method_names": [], "method_name": "HashBiMap.replaceKeyInEntry", "method_implementation": "{\n    checkArgument(entry != ABSENT);\n    int newKeyHash = Hashing.smearedHash(newKey);\n    int newKeyIndex = findEntryByKey(newKey, newKeyHash);\n    int newPredecessor = lastInInsertionOrder;\n    int newSuccessor = ENDPOINT;\n    if (newKeyIndex != ABSENT) {\n        if (force) {\n            newPredecessor = prevInInsertionOrder[newKeyIndex];\n            newSuccessor = nextInInsertionOrder[newKeyIndex];\n            removeEntryKeyHashKnown(newKeyIndex, newKeyHash);\n            if (entry == size) {\n                // this entry got moved to newKeyIndex\n                entry = newKeyIndex;\n            }\n        } else {\n            throw new IllegalArgumentException(\"Key already present in map: \" + newKey);\n        }\n    }\n    if (newPredecessor == entry) {\n        newPredecessor = prevInInsertionOrder[entry];\n    } else if (newPredecessor == size) {\n        newPredecessor = newKeyIndex;\n    }\n    if (newSuccessor == entry) {\n        newSuccessor = nextInInsertionOrder[entry];\n    } else if (newSuccessor == size) {\n        newSuccessor = newKeyIndex;\n    }\n    int oldPredecessor = prevInInsertionOrder[entry];\n    int oldSuccessor = nextInInsertionOrder[entry];\n    // remove from insertion order linked list\n    setSucceeds(oldPredecessor, oldSuccessor);\n    deleteFromTableKToV(entry, Hashing.smearedHash(keys[entry]));\n    keys[entry] = newKey;\n    insertIntoTableKToV(entry, Hashing.smearedHash(newKey));\n    // insert into insertion order linked list, usually at the end\n    setSucceeds(newPredecessor, entry);\n    setSucceeds(entry, newSuccessor);\n}", "repo_id": "5", "comment": "/**\n * Updates the specified entry to point to the new value: removes the old value from the V-to-K\n * mapping and puts the new one in. The entry is moved to the end of the insertion order, or to\n * the position of the new key if it was previously present.\n */\n", "repo_name": "guava-master/", "id": 6233, "method_signature": "void replaceKeyInEntry(int, K, boolean)", "filename": "HashBiMap.replaceKeyInEntry.json"}
{"callee_method_names": [], "method_name": "HashBiMap.replaceValueInEntry", "method_implementation": "{\n    checkArgument(entry != ABSENT);\n    int newValueHash = Hashing.smearedHash(newValue);\n    int newValueIndex = findEntryByValue(newValue, newValueHash);\n    if (newValueIndex != ABSENT) {\n        if (force) {\n            removeEntryValueHashKnown(newValueIndex, newValueHash);\n            if (entry == size) {\n                // this entry got moved to newValueIndex\n                entry = newValueIndex;\n            }\n        } else {\n            throw new IllegalArgumentException(\"Value already present in map: \" + newValue);\n        }\n    }\n    // we do *not* update insertion order, and it isn't a structural modification!\n    deleteFromTableVToK(entry, Hashing.smearedHash(values[entry]));\n    values[entry] = newValue;\n    insertIntoTableVToK(entry, newValueHash);\n}", "repo_id": "5", "comment": "/**\n * Updates the specified entry to point to the new value: removes the old value from the V-to-K\n * mapping and puts the new one in. The entry does not move in the insertion order of the bimap.\n */\n", "repo_name": "guava-master/", "id": 6232, "method_signature": "void replaceValueInEntry(int, V, boolean)", "filename": "HashBiMap.replaceValueInEntry.json"}
{"callee_method_names": [], "method_name": "HashBiMap.setSucceeds", "method_implementation": "{\n    if (prev == ENDPOINT) {\n        firstInInsertionOrder = next;\n    } else {\n        nextInInsertionOrder[prev] = next;\n    }\n    if (next == ENDPOINT) {\n        lastInInsertionOrder = prev;\n    } else {\n        prevInInsertionOrder[next] = prev;\n    }\n}", "repo_id": "5", "comment": "/**\n * Updates the pointers of the insertion order linked list so that {@code next} follows {@code\n * prev}. {@code ENDPOINT} represents either the first or last entry in the entire map (as\n * appropriate).\n */\n", "repo_name": "guava-master/", "id": 6227, "method_signature": "void setSucceeds(int, int)", "filename": "HashBiMap.setSucceeds.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject"], "method_name": "HashBiMap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    Serialization.writeMap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the number of entries, first key, first value, second key, second value, and so on.\n */\n", "repo_name": "guava-master/", "id": 6236, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "HashBiMap.writeObject.json"}
{"callee_method_names": ["HashCode.bits"], "method_name": "HashCode.equals", "method_implementation": "{\n    if (object instanceof HashCode) {\n        HashCode that = (HashCode) object;\n        return bits() == that.bits() && equalsSameBits(that);\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code object} is a {@link HashCode} instance with the identical byte\n * representation to this hash code.\n *\n * <p><b>Security note:</b> this method uses a constant-time (not short-circuiting) implementation\n * to protect against <a href=\"http://en.wikipedia.org/wiki/Timing_attack\">timing attacks</a>.\n */\n", "repo_name": "guava-master/", "id": 5224, "method_signature": "boolean equals(Object)", "filename": "HashCode.equals.json"}
{"callee_method_names": ["String.length", "String.length", "String.length", "String.length", "String.charAt", "String.charAt"], "method_name": "HashCode.fromString", "method_implementation": "{\n    checkArgument(string.length() >= 2, \"input string (%s) must have at least 2 characters\", string);\n    checkArgument(string.length() % 2 == 0, \"input string (%s) must have an even number of characters\", string);\n    byte[] bytes = new byte[string.length() / 2];\n    for (int i = 0; i < string.length(); i += 2) {\n        int ch1 = decode(string.charAt(i)) << 4;\n        int ch2 = decode(string.charAt(i + 1));\n        bytes[i / 2] = (byte) (ch1 + ch2);\n    }\n    return fromBytesNoCopy(bytes);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code HashCode} from a hexadecimal ({@code base 16}) encoded string. The string must\n * be at least 2 characters long, and contain only valid, lower-cased hexadecimal characters.\n *\n * <p>This method accepts the exact format generated by {@link #toString}. If you require more\n * lenient {@code base 16} decoding, please use {@link com.google.common.io.BaseEncoding#decode}\n * (and pass the result to {@link #fromBytes}).\n *\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5223, "method_signature": "HashCode fromString(String)", "filename": "HashCode.fromString.json"}
{"callee_method_names": [], "method_name": "HashCode.hashCode", "method_implementation": "{\n    // If we have at least 4 bytes (32 bits), just take the first 4 bytes. Since this is\n    // already a (presumably) high-quality hash code, any four bytes of it will do.\n    if (bits() >= 32) {\n        return asInt();\n    }\n    // If we have less than 4 bytes, use them all.\n    byte[] bytes = getBytesInternal();\n    int val = (bytes[0] & 0xFF);\n    for (int i = 1; i < bytes.length; i++) {\n        val |= ((bytes[i] & 0xFF) << (i * 8));\n    }\n    return val;\n}", "repo_id": "5", "comment": "/**\n * Returns a \"Java hash code\" for this {@code HashCode} instance; this is well-defined (so, for\n * example, you can safely put {@code HashCode} instances into a {@code HashSet}) but is otherwise\n * probably not what you want to use.\n */\n", "repo_name": "guava-master/", "id": 5225, "method_signature": "int hashCode()", "filename": "HashCode.hashCode.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.toString"], "method_name": "HashCode.toString", "method_implementation": "{\n    byte[] bytes = getBytesInternal();\n    StringBuilder sb = new StringBuilder(2 * bytes.length);\n    for (byte b : bytes) {\n        sb.append(hexDigits[(b >> 4) & 0xf]).append(hexDigits[b & 0xf]);\n    }\n    return sb.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing each byte of {@link #asBytes}, in order, as a two-digit unsigned\n * hexadecimal number in lower case.\n *\n * <p>Note that if the output is considered to be a single hexadecimal number, whether this string\n * is big-endian or little-endian depends on the byte order of {@link #asBytes}. This may be\n * surprising for implementations of {@code HashCode} that represent the number in big-endian\n * since everything else in the hashing API uniformly treats multibyte values as little-endian.\n *\n * <p>To create a {@code HashCode} from its string representation, see {@link #fromString}.\n */\n", "repo_name": "guava-master/", "id": 5226, "method_signature": "String toString()", "filename": "HashCode.toString.json"}
{"callee_method_names": [], "method_name": "HashCode.writeBytesTo", "method_implementation": "{\n    maxLength = Ints.min(maxLength, bits() / 8);\n    Preconditions.checkPositionIndexes(offset, offset + maxLength, dest.length);\n    writeBytesToImpl(dest, offset, maxLength);\n    return maxLength;\n}", "repo_id": "5", "comment": "/**\n * Copies bytes from this hash code into {@code dest}.\n *\n * @param dest the byte array into which the hash code will be written\n * @param offset the start offset in the data\n * @param maxLength the maximum number of bytes to write\n * @return the number of bytes written to {@code dest}\n * @throws IndexOutOfBoundsException if there is not enough room in {@code dest}\n */\n", "repo_name": "guava-master/", "id": 5222, "method_signature": "int writeBytesTo(byte[], int, int)", "filename": "HashCode.writeBytesTo.json"}
{"callee_method_names": [], "method_name": "HashCodeTest.testFromInt", "method_implementation": "{\n    for (ExpectedHashCode expected : expectedHashCodes) {\n        if (expected.bytes.length == 4) {\n            HashCode fromInt = HashCode.fromInt(expected.asInt);\n            assertExpectedHashCode(expected, fromInt);\n        }\n    }\n}", "repo_id": "5", "comment": "// expectedHashCodes must contain at least one hash code with 4 bytes\n", "repo_name": "guava-master/", "id": 3721, "method_signature": "void testFromInt()", "filename": "HashCodeTest.testFromInt.json"}
{"callee_method_names": [], "method_name": "HashCodeTest.testFromLong", "method_implementation": "{\n    for (ExpectedHashCode expected : expectedHashCodes) {\n        if (expected.bytes.length == 8) {\n            HashCode fromLong = HashCode.fromLong(expected.asLong);\n            assertExpectedHashCode(expected, fromLong);\n        }\n    }\n}", "repo_id": "5", "comment": "// expectedHashCodes must contain at least one hash code with 8 bytes\n", "repo_name": "guava-master/", "id": 3722, "method_signature": "void testFromLong()", "filename": "HashCodeTest.testFromLong.json"}
{"callee_method_ids": [5224, 5225, 5225], "callee_method_names": ["HashCode.equals", "HashCode.hashCode", "HashCode.hashCode"], "method_name": "HashCodeTest.testObjectHashCodeWithSameLowOrderBytes", "method_implementation": "{\n    // These will have the same first 4 bytes (all 0).\n    byte[] bytesA = new byte[5];\n    byte[] bytesB = new byte[5];\n    // Change only the last (5th) byte\n    bytesA[4] = (byte) 0xbe;\n    bytesB[4] = (byte) 0xef;\n    HashCode hashCodeA = HashCode.fromBytes(bytesA);\n    HashCode hashCodeB = HashCode.fromBytes(bytesB);\n    // They aren't equal...\n    assertFalse(hashCodeA.equals(hashCodeB));\n    // But they still have the same Object#hashCode() value.\n    // Technically not a violation of the equals/hashCode contract, but...?\n    assertEquals(hashCodeA.hashCode(), hashCodeB.hashCode());\n}", "repo_id": "5", "comment": "// See https://code.google.com/p/guava-libraries/issues/detail?id=1494\n", "repo_name": "guava-master/", "id": 3723, "method_signature": "void testObjectHashCodeWithSameLowOrderBytes()", "filename": "HashCodeTest.testObjectHashCodeWithSameLowOrderBytes.json"}
{"callee_method_names": ["E.getKey", "Segment<K, V, E, S>.postReadCleanup"], "method_name": "HashIterator.advanceTo", "method_implementation": "{\n    try {\n        K key = entry.getKey();\n        V value = getLiveValue(entry);\n        if (value != null) {\n            nextExternal = new WriteThroughEntry(key, value);\n            return true;\n        } else {\n            // Skip stale entry.\n            return false;\n        }\n    } finally {\n        currentSegment.postReadCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Advances to the given entry. Returns {@code true} if the entry was valid, {@code false} if it\n * should be skipped.\n */\n", "repo_name": "guava-master/", "id": 6284, "method_signature": "boolean advanceTo(E)", "filename": "HashIterator.advanceTo.json"}
{"callee_method_names": ["E.getNext", "E.getNext"], "method_name": "HashIterator.nextInChain", "method_implementation": "{\n    if (nextEntry != null) {\n        for (nextEntry = nextEntry.getNext(); nextEntry != null; nextEntry = nextEntry.getNext()) {\n            if (advanceTo(nextEntry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Finds the next entry in the current chain. Returns {@code true} if an entry was found.\n */\n", "repo_name": "guava-master/", "id": 6282, "method_signature": "boolean nextInChain()", "filename": "HashIterator.nextInChain.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.get"], "method_name": "HashIterator.nextInTable", "method_implementation": "{\n    while (nextTableIndex >= 0) {\n        if ((nextEntry = currentTable.get(nextTableIndex--)) != null) {\n            if (advanceTo(nextEntry) || nextInChain()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Finds the next entry in the current table. Returns {@code true} if an entry was found.\n */\n", "repo_name": "guava-master/", "id": 6283, "method_signature": "boolean nextInTable()", "filename": "HashIterator.nextInTable.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject"], "method_name": "HashMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    Serialization.writeMultimap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData expectedValuesPerKey, number of distinct keys, and then for each distinct key: the\n *     key, number of values for that key, and the key's values\n */\n", "repo_name": "guava-master/", "id": 6466, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "HashMultimap.writeObject.json"}
{"callee_method_names": ["HashMultimap<String, Integer>.put", "HashMultimap<String, Integer>.put", "HashMultimap<String, Integer>.put", "HashMultimap<String, Integer>.get"], "method_name": "HashMultimapTest.testCreate", "method_implementation": "{\n    HashMultimap<String, Integer> multimap = HashMultimap.create();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"bar\", 2);\n    multimap.put(\"foo\", 3);\n    assertEquals(ImmutableSet.of(1, 3), multimap.get(\"foo\"));\n    assertEquals(2, multimap.expectedValuesPerKey);\n}", "repo_id": "5", "comment": "/*\n   * The behavior of toString() is tested by TreeMultimap, which shares a\n   * lot of code with HashMultimap and has deterministic iteration order.\n   */\n", "repo_name": "guava-master/", "id": 3983, "method_signature": "void testCreate()", "filename": "HashMultimapTest.testCreate.json"}
{"callee_method_names": [], "method_name": "HashMultiset.create", "method_implementation": "{\n    HashMultiset<E> multiset = create(Multisets.inferDistinctElements(elements));\n    Iterables.addAll(multiset, elements);\n    return multiset;\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code HashMultiset} containing the specified elements.\n *\n * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.\n *\n * @param elements the elements that the multiset should contain\n */\n", "repo_name": "guava-master/", "id": 6050, "method_signature": "HashMultiset<E> create(Iterable)", "filename": "HashMultiset.create.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject"], "method_name": "HashMultiset.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    Serialization.writeMultiset(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the number of distinct elements, the first element, its count, the second element,\n *     its count, and so on\n */\n", "repo_name": "guava-master/", "id": 2683, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "HashMultiset.writeObject.json"}
{"callee_method_names": ["String.matches", "String.matches", "String.matches", "String.matches", "String.matches", "String.matches"], "method_name": "HashStringBenchmark.decode", "method_implementation": "{\n    try {\n        return Integer.decode(userFriendly);\n    } catch (NumberFormatException ignored) {\n        if (userFriendly.matches(\"(?i)(?:American|English|ASCII)\")) {\n            // 1-byte UTF-8 sequences - \"American\" ASCII text\n            return 0x80;\n        } else if (userFriendly.matches(\"(?i)(?:French|Latin|Western.*European)\")) {\n            // Mostly 1-byte UTF-8 sequences, mixed with occasional 2-byte\n            // sequences - \"Western European\" text\n            return 0x90;\n        } else if (userFriendly.matches(\"(?i)(?:Branch.*Prediction.*Hostile)\")) {\n            // Defeat branch predictor for: c < 0x80 ; branch taken 50% of the time.\n            return 0x100;\n        } else if (userFriendly.matches(\"(?i)(?:Greek|Cyrillic|European|ISO.?8859)\")) {\n            // Mostly 2-byte UTF-8 sequences - \"European\" text\n            return 0x800;\n        } else if (userFriendly.matches(\"(?i)(?:Chinese|Han|Asian|BMP)\")) {\n            // Mostly 3-byte UTF-8 sequences - \"Asian\" text\n            return Character.MIN_SUPPLEMENTARY_CODE_POINT;\n        } else if (userFriendly.matches(\"(?i)(?:Cuneiform|rare|exotic|supplementary.*)\")) {\n            // Mostly 4-byte UTF-8 sequences - \"rare exotic\" text\n            return Character.MAX_CODE_POINT;\n        } else {\n            throw new IllegalArgumentException(\"Can't decode codepoint \" + userFriendly);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Convert the input string to a code point. Accepts regular decimal numerals, hex strings, and\n * some symbolic names meaningful to humans.\n */\n", "repo_name": "guava-master/", "id": 3486, "method_signature": "int decode(String)", "filename": "HashStringBenchmark.decode.json"}
{"callee_method_names": ["Random.nextInt", "StringBuilder.appendCodePoint", "StringBuilder.toString"], "method_name": "HashStringBenchmark.setUp", "method_implementation": "{\n    final long seed = 99;\n    final Random rnd = new Random(seed);\n    strings = new String[SAMPLES];\n    for (int i = 0; i < SAMPLES; i++) {\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < charCount; j++) {\n            int codePoint;\n            // discard illegal surrogate \"codepoints\"\n            do {\n                codePoint = rnd.nextInt(maxCodePoint.value);\n            } while (Character.isSurrogate((char) codePoint));\n            sb.appendCodePoint(codePoint);\n        }\n        strings[i] = sb.toString();\n    }\n}", "repo_id": "5", "comment": "/**\n * Compute arrays of valid unicode text, and store it in 3 forms: byte arrays, Strings, and\n * StringBuilders (in a CharSequence[] to make it a little harder for the JVM).\n */\n", "repo_name": "guava-master/", "id": 3487, "method_signature": "void setUp()", "filename": "HashStringBenchmark.setUp.json"}
{"callee_method_names": ["String.length", "String.length", "String.charAt"], "method_name": "HashTestUtils.ascii", "method_implementation": "{\n    byte[] bytes = new byte[string.length()];\n    for (int i = 0; i < string.length(); i++) {\n        bytes[i] = (byte) string.charAt(i);\n    }\n    return bytes;\n}", "repo_id": "5", "comment": "/**\n * Converts a string, which should contain only ascii-representable characters, to a byte[].\n */\n", "repo_name": "guava-master/", "id": 3746, "method_signature": "byte[] ascii(String)", "filename": "HashTestUtils.ascii.json"}
{"callee_method_names": ["Random.nextInt", "Random.nextBoolean", "HashFunction.hashUnencodedChars", "HashFunction.newHasher"], "method_name": "HashTestUtils.assertHashStringWithSurrogatesEquivalence", "method_implementation": "{\n    int size = random.nextInt(8) + 1;\n    char[] chars = new char[size];\n    for (int i = 0; i < chars.length; i++) {\n        chars[i] = random.nextBoolean() ? randomLowSurrogate(random) : randomHighSurrogate(random);\n    }\n    String string = new String(chars);\n    assertEquals(hashFunction.hashUnencodedChars(string), hashFunction.newHasher().putUnencodedChars(string).hash());\n}", "repo_id": "5", "comment": "/**\n * This verifies that putUnencodedChars(String) and hashUnencodedChars(String) are equivalent,\n * even for funny strings composed by (possibly unmatched, and mostly illegal) surrogate\n * characters. (But doesn't test that they do the right thing - just their consistency).\n */\n", "repo_name": "guava-master/", "id": 3752, "method_signature": "void assertHashStringWithSurrogatesEquivalence(HashFunction, Random)", "filename": "HashTestUtils.assertHashStringWithSurrogatesEquivalence.json"}
{"callee_method_names": ["Random.nextInt", "HashFunction.hashInt", "HashFunction.hashInt", "HashFunction.bits", "HashCode.bits", "HashFunction.bits", "HashCode.asBytes", "Set<HashCode>.add", "Set<HashCode>.size"], "method_name": "HashTestUtils.assertInvariants", "method_implementation": "{\n    int objects = 100;\n    Set<HashCode> hashcodes = Sets.newHashSetWithExpectedSize(objects);\n    Random random = new Random(314159);\n    for (int i = 0; i < objects; i++) {\n        int value = random.nextInt();\n        HashCode hashcode1 = hashFunction.hashInt(value);\n        HashCode hashcode2 = hashFunction.hashInt(value);\n        // idempotent\n        Assert.assertEquals(hashcode1, hashcode2);\n        Assert.assertEquals(hashFunction.bits(), hashcode1.bits());\n        Assert.assertEquals(hashFunction.bits(), hashcode1.asBytes().length * 8);\n        hashcodes.add(hashcode1);\n    }\n    // quite relaxed test\n    Assert.assertTrue(hashcodes.size() > objects * 0.95);\n    assertHashBytesThrowsCorrectExceptions(hashFunction);\n    assertIndependentHashers(hashFunction);\n    assertShortcutsAreEquivalent(hashFunction, 512);\n}", "repo_id": "5", "comment": "/**\n * Checks that a Hasher returns the same HashCode when given the same input, and also that the\n * collision rate looks sane.\n */\n", "repo_name": "guava-master/", "id": 3751, "method_signature": "void assertInvariants(HashFunction)", "filename": "HashTestUtils.assertInvariants.json"}
{"callee_method_names": ["HashFunction.bits", "Random.nextInt", "HashFunction.hashInt", "HashFunction.hashInt"], "method_name": "HashTestUtils.check2BitAvalanche", "method_implementation": "{\n    Random rand = new Random(0);\n    int keyBits = 32;\n    int hashBits = function.bits();\n    for (int bit1 = 0; bit1 < keyBits; bit1++) {\n        for (int bit2 = 0; bit2 < keyBits; bit2++) {\n            if (bit2 <= bit1)\n                continue;\n            int delta = (1 << bit1) | (1 << bit2);\n            int[] same = new int[hashBits];\n            int[] diff = new int[hashBits];\n            // go through trials to compute probability\n            for (int j = 0; j < trials; j++) {\n                int key1 = rand.nextInt();\n                // flip input bit for key2\n                int key2 = key1 ^ delta;\n                // compute hash values\n                int hash1 = function.hashInt(key1).asInt();\n                int hash2 = function.hashInt(key2).asInt();\n                for (int k = 0; k < hashBits; k++) {\n                    if ((hash1 & (1 << k)) == (hash2 & (1 << k))) {\n                        same[k] += 1;\n                    } else {\n                        diff[k] += 1;\n                    }\n                }\n            }\n            // measure probability and assert it's within margin of error\n            for (int j = 0; j < hashBits; j++) {\n                double prob = (double) diff[j] / (double) (diff[j] + same[j]);\n                Assert.assertEquals(0.50d, prob, epsilon);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Test for avalanche with 2-bit deltas. Most probabilities of output bit(j) differing are well\n * within 50%.\n */\n", "repo_name": "guava-master/", "id": 3750, "method_signature": "void check2BitAvalanche(HashFunction, int, double)", "filename": "HashTestUtils.check2BitAvalanche.json"}
{"callee_method_names": ["HashFunction.bits", "Random.nextInt", "HashFunction.hashInt", "HashFunction.hashInt"], "method_name": "HashTestUtils.checkAvalanche", "method_implementation": "{\n    Random rand = new Random(0);\n    int keyBits = 32;\n    int hashBits = function.bits();\n    for (int i = 0; i < keyBits; i++) {\n        int[] same = new int[hashBits];\n        int[] diff = new int[hashBits];\n        // go through trials to compute probability\n        for (int j = 0; j < trials; j++) {\n            int key1 = rand.nextInt();\n            // flip input bit for key2\n            int key2 = key1 ^ (1 << i);\n            // compute hash values\n            int hash1 = function.hashInt(key1).asInt();\n            int hash2 = function.hashInt(key2).asInt();\n            for (int k = 0; k < hashBits; k++) {\n                if ((hash1 & (1 << k)) == (hash2 & (1 << k))) {\n                    same[k] += 1;\n                } else {\n                    diff[k] += 1;\n                }\n            }\n        }\n        // measure probability and assert it's within margin of error\n        for (int j = 0; j < hashBits; j++) {\n            double prob = (double) diff[j] / (double) (diff[j] + same[j]);\n            Assert.assertEquals(0.50d, prob, epsilon);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Test for avalanche. Avalanche means that output bits differ with roughly 1/2 probability on\n * different input keys. This test verifies that each possible 1-bit key delta achieves avalanche.\n *\n * <p>For more information: http://burtleburtle.net/bob/hash/avalanche.html\n */\n", "repo_name": "guava-master/", "id": 3748, "method_signature": "void checkAvalanche(HashFunction, int, double)", "filename": "HashTestUtils.checkAvalanche.json"}
{"callee_method_names": ["Random.nextInt", "HashFunction.hashInt", "HashFunction.hashInt"], "method_name": "HashTestUtils.checkNo2BitCharacteristics", "method_implementation": "{\n    Random rand = new Random(0);\n    int keyBits = 32;\n    // get every one of (keyBits choose 2) deltas:\n    for (int i = 0; i < keyBits; i++) {\n        for (int j = 0; j < keyBits; j++) {\n            if (j <= i)\n                continue;\n            int count = 0;\n            // the probability of error here is minuscule\n            int maxCount = 20;\n            boolean diff = false;\n            while (!diff) {\n                int delta = (1 << i) | (1 << j);\n                int key1 = rand.nextInt();\n                // apply delta\n                int key2 = key1 ^ delta;\n                // get hashes\n                int hash1 = function.hashInt(key1).asInt();\n                int hash2 = function.hashInt(key2).asInt();\n                // this 2-bit candidate delta is not a characteristic\n                // if deltas are different\n                if ((hash1 ^ hash2) != delta) {\n                    diff = true;\n                    continue;\n                }\n                // check if we've exceeded the probabilistically\n                // likely number of trials to have proven 2-bit candidate\n                // is not a characteristic\n                count++;\n                if (count > maxCount) {\n                    Assert.fail(\"2-bit delta (\" + i + \", \" + j + \") is likely a \" + \"characteristic for this hash. This was \" + \"determined after \" + count + \" trials\");\n                }\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Test for 2-bit characteristics. A characteristic is a delta in the input which is repeated in\n * the output. For example, if f() is a block cipher and c is a characteristic, then f(x^c) =\n * f(x)^c with greater than expected probability. The test for funneling is merely a test for\n * 1-bit characteristics.\n *\n * <p>There is more general code provided by Bob Jenkins to test arbitrarily sized characteristics\n * using the magic of gaussian elimination: http://burtleburtle.net/bob/crypto/findingc.html.\n */\n", "repo_name": "guava-master/", "id": 3749, "method_signature": "void checkNo2BitCharacteristics(HashFunction)", "filename": "HashTestUtils.checkNo2BitCharacteristics.json"}
{"callee_method_names": ["HashFunction.bits", "Random.nextInt", "HashFunction.hashInt", "HashFunction.hashInt"], "method_name": "HashTestUtils.checkNoFunnels", "method_implementation": "{\n    Random rand = new Random(0);\n    int keyBits = 32;\n    int hashBits = function.bits();\n    // output loop tests input bit\n    for (int i = 0; i < keyBits; i++) {\n        // bitset for output bits with same values\n        int same = 0x0;\n        // bitset for output bits with different values\n        int diff = 0x0;\n        int count = 0;\n        // originally was 2 * Math.log(...), making it try more times to avoid flakiness issues\n        int maxCount = (int) (4 * Math.log(2 * keyBits * hashBits) + 1);\n        while (same != 0xffffffff || diff != 0xffffffff) {\n            int key1 = rand.nextInt();\n            // flip input bit for key2\n            int key2 = key1 ^ (1 << i);\n            // get hashes\n            int hash1 = function.hashInt(key1).asInt();\n            int hash2 = function.hashInt(key2).asInt();\n            // test whether the hash values have same output bits\n            same |= ~(hash1 ^ hash2);\n            // test whether the hash values have different output bits\n            diff |= (hash1 ^ hash2);\n            count++;\n            // check whether we've exceeded the probabilistically\n            // likely number of trials to have proven no funneling\n            if (count > maxCount) {\n                Assert.fail(\"input bit(\" + i + \") was found not to affect all \" + hashBits + \" output bits; The unaffected bits are \" + \"as follows: \" + ~(same & diff) + \". This was \" + \"determined after \" + count + \" trials.\");\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Test that the hash function contains no funnels. A funnel is a situation where a set of input\n * (key) bits 'affects' a strictly smaller set of output bits. Funneling is bad because it can\n * result in more-than-ideal collisions for a non-uniformly distributed key space. In practice,\n * most key spaces are ANYTHING BUT uniformly distributed. A bit(i) in the input is said to\n * 'affect' a bit(j) in the output if two inputs, identical but for bit(i), will differ at output\n * bit(j) about half the time\n *\n * <p>Funneling is pretty simple to detect. The key idea is to find example keys which\n * unequivocally demonstrate that funneling cannot be occurring. This is done bit-by-bit. For each\n * input bit(i) and output bit(j), two pairs of keys must be found with all bits identical except\n * bit(i). One pair must differ in output bit(j), and one pair must not. This proves that input\n * bit(i) can alter output bit(j).\n */\n", "repo_name": "guava-master/", "id": 3747, "method_signature": "void checkNoFunnels(HashFunction)", "filename": "HashTestUtils.checkNoFunnels.json"}
{"callee_method_names": ["Iterable<HashCode>.iterator", "Iterator<HashCode>.hasNext", "Iterator<HashCode>.next"], "method_name": "Hashing.combineOrdered", "method_implementation": "{\n    Iterator<HashCode> iterator = hashCodes.iterator();\n    checkArgument(iterator.hasNext(), \"Must be at least 1 hash code to combine.\");\n    int bits = iterator.next().bits();\n    byte[] resultBytes = new byte[bits / 8];\n    for (HashCode hashCode : hashCodes) {\n        byte[] nextBytes = hashCode.asBytes();\n        checkArgument(nextBytes.length == resultBytes.length, \"All hashcodes must have the same bit length.\");\n        for (int i = 0; i < nextBytes.length; i++) {\n            resultBytes[i] = (byte) (resultBytes[i] * 37 ^ nextBytes[i]);\n        }\n    }\n    return HashCode.fromBytesNoCopy(resultBytes);\n}", "repo_id": "5", "comment": "/**\n * Returns a hash code, having the same bit length as each of the input hash codes, that combines\n * the information of these hash codes in an ordered fashion. That is, whenever two equal hash\n * codes are produced by two calls to this method, it is <i>as likely as possible</i> that each\n * was computed from the <i>same</i> input hash codes in the <i>same</i> order.\n *\n * @throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes do not all\n *     have the same bit length\n */\n", "repo_name": "guava-master/", "id": 5196, "method_signature": "HashCode combineOrdered(Iterable)", "filename": "Hashing.combineOrdered.json"}
{"callee_method_names": ["Iterable<HashCode>.iterator", "Iterator<HashCode>.hasNext", "Iterator<HashCode>.next"], "method_name": "Hashing.combineUnordered", "method_implementation": "{\n    Iterator<HashCode> iterator = hashCodes.iterator();\n    checkArgument(iterator.hasNext(), \"Must be at least 1 hash code to combine.\");\n    byte[] resultBytes = new byte[iterator.next().bits() / 8];\n    for (HashCode hashCode : hashCodes) {\n        byte[] nextBytes = hashCode.asBytes();\n        checkArgument(nextBytes.length == resultBytes.length, \"All hashcodes must have the same bit length.\");\n        for (int i = 0; i < nextBytes.length; i++) {\n            resultBytes[i] += nextBytes[i];\n        }\n    }\n    return HashCode.fromBytesNoCopy(resultBytes);\n}", "repo_id": "5", "comment": "/**\n * Returns a hash code, having the same bit length as each of the input hash codes, that combines\n * the information of these hash codes in an unordered fashion. That is, whenever two equal hash\n * codes are produced by two calls to this method, it is <i>as likely as possible</i> that each\n * was computed from the <i>same</i> input hash codes in <i>some</i> order.\n *\n * @throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes do not all\n *     have the same bit length\n */\n", "repo_name": "guava-master/", "id": 5197, "method_signature": "HashCode combineUnordered(Iterable)", "filename": "Hashing.combineUnordered.json"}
{"callee_method_names": ["List<HashFunction>.add", "List<HashFunction>.isEmpty", "List<HashFunction>.size", "List<HashFunction>.toArray"], "method_name": "Hashing.concatenating", "method_implementation": "{\n    checkNotNull(hashFunctions);\n    // We can't use Iterables.toArray() here because there's no hash->collect dependency\n    List<HashFunction> list = new ArrayList<>();\n    for (HashFunction hashFunction : hashFunctions) {\n        list.add(hashFunction);\n    }\n    checkArgument(!list.isEmpty(), \"number of hash functions (%s) must be > 0\", list.size());\n    return new ConcatenatedHashFunction(list.toArray(new HashFunction[0]));\n}", "repo_id": "5", "comment": "/**\n * Returns a hash function which computes its hash code by concatenating the hash codes of the\n * underlying hash functions together. This can be useful if you need to generate hash codes of a\n * specific length.\n *\n * <p>For example, if you need 1024-bit hash codes, you could join two {@link Hashing#sha512} hash\n * functions together: {@code Hashing.concatenating(Hashing.sha512(), Hashing.sha512())}.\n *\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 5199, "method_signature": "HashFunction concatenating(Iterable)", "filename": "Hashing.concatenating.json"}
{"callee_method_names": ["LinearCongruentialGenerator.nextDouble"], "method_name": "Hashing.consistentHash", "method_implementation": "{\n    checkArgument(buckets > 0, \"buckets must be positive: %s\", buckets);\n    LinearCongruentialGenerator generator = new LinearCongruentialGenerator(input);\n    int candidate = 0;\n    int next;\n    // Jump from bucket to bucket until we go out of range\n    while (true) {\n        next = (int) ((candidate + 1) / generator.nextDouble());\n        if (next >= 0 && next < buckets) {\n            candidate = next;\n        } else {\n            return candidate;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Assigns to {@code input} a \"bucket\" in the range {@code [0, buckets)}, in a uniform manner that\n * minimizes the need for remapping as {@code buckets} grows. That is, {@code consistentHash(h,\n * n)} equals:\n *\n * <ul>\n *   <li>{@code n - 1}, with approximate probability {@code 1/n}\n *   <li>{@code consistentHash(h, n - 1)}, otherwise (probability {@code 1 - 1/n})\n * </ul>\n *\n * <p>This method is suitable for the common use case of dividing work among buckets that meet the\n * following conditions:\n *\n * <ul>\n *   <li>You want to assign the same fraction of inputs to each bucket.\n *   <li>When you reduce the number of buckets, you can accept that the most recently added\n *       buckets will be removed first. More concretely, if you are dividing traffic among tasks,\n *       you can decrease the number of tasks from 15 and 10, killing off the final 5 tasks, and\n *       {@code consistentHash} will handle it. If, however, you are dividing traffic among\n *       servers {@code alpha}, {@code bravo}, and {@code charlie} and you occasionally need to\n *       take each of the servers offline, {@code consistentHash} will be a poor fit: It provides\n *       no way for you to specify which of the three buckets is disappearing. Thus, if your\n *       buckets change from {@code [alpha, bravo, charlie]} to {@code [bravo, charlie]}, it will\n *       assign all the old {@code alpha} traffic to {@code bravo} and all the old {@code bravo}\n *       traffic to {@code charlie}, rather than letting {@code bravo} keep its traffic.\n * </ul>\n *\n * <p>See the <a href=\"http://en.wikipedia.org/wiki/Consistent_hashing\">Wikipedia article on\n * consistent hashing</a> for more information.\n */\n", "repo_name": "guava-master/", "id": 5195, "method_signature": "int consistentHash(long, int)", "filename": "Hashing.consistentHash.json"}
{"callee_method_names": [], "method_name": "Hashing.goodFastHash", "method_implementation": "{\n    int bits = checkPositiveAndMakeMultipleOf32(minimumBits);\n    if (bits == 32) {\n        return Murmur3_32HashFunction.GOOD_FAST_HASH_32;\n    }\n    if (bits <= 128) {\n        return Murmur3_128HashFunction.GOOD_FAST_HASH_128;\n    }\n    // Otherwise, join together some 128-bit murmur3s\n    int hashFunctionsNeeded = (bits + 127) / 128;\n    HashFunction[] hashFunctions = new HashFunction[hashFunctionsNeeded];\n    hashFunctions[0] = Murmur3_128HashFunction.GOOD_FAST_HASH_128;\n    int seed = GOOD_FAST_HASH_SEED;\n    for (int i = 1; i < hashFunctionsNeeded; i++) {\n        // a prime; shouldn't matter\n        seed += 1500450271;\n        hashFunctions[i] = murmur3_128(seed);\n    }\n    return new ConcatenatedHashFunction(hashFunctions);\n}", "repo_id": "5", "comment": "/**\n * Returns a general-purpose, <b>temporary-use</b>, non-cryptographic hash function. The algorithm\n * the returned function implements is unspecified and subject to change without notice.\n *\n * <p><b>Warning:</b> a new random seed for these functions is chosen each time the {@code\n * Hashing} class is loaded. <b>Do not use this method</b> if hash codes may escape the current\n * process in any way, for example being sent over RPC, or saved to disk. For a general-purpose,\n * non-cryptographic hash function that will never change behavior, we suggest {@link\n * #murmur3_128}.\n *\n * <p>Repeated calls to this method on the same loaded {@code Hashing} class, using the same value\n * for {@code minimumBits}, will return identically-behaving {@link HashFunction} instances.\n *\n * @param minimumBits a positive integer. This can be arbitrarily large. The returned {@link\n *     HashFunction} instance may use memory proportional to this integer.\n * @return a hash function, described above, that produces hash codes of length {@code\n *     minimumBits} or greater\n */\n", "repo_name": "guava-master/", "id": 5194, "method_signature": "HashFunction goodFastHash(int)", "filename": "Hashing.goodFastHash.json"}
{"callee_method_names": ["InputStream.read", "Hasher.putBytes"], "method_name": "HashingInputStream.read", "method_implementation": "{\n    int numOfBytesRead = in.read(bytes, off, len);\n    if (numOfBytesRead != -1) {\n        hasher.putBytes(bytes, off, numOfBytesRead);\n    }\n    return numOfBytesRead;\n}", "repo_id": "5", "comment": "/**\n * Reads the specified bytes of data from the underlying input stream and updates the hasher with\n * the bytes read.\n */\n", "repo_name": "guava-master/", "id": 5212, "method_signature": "int read(byte[], int, int)", "filename": "HashingInputStream.read.json"}
{"callee_method_names": [], "method_name": "HashingTest.testConcatenating_equals", "method_implementation": "{\n    new EqualsTester().addEqualityGroup(Hashing.concatenating(asList(Hashing.md5()))).addEqualityGroup(Hashing.concatenating(asList(Hashing.murmur3_32()))).addEqualityGroup(Hashing.concatenating(Hashing.md5(), Hashing.md5()), Hashing.concatenating(asList(Hashing.md5(), Hashing.md5()))).addEqualityGroup(Hashing.concatenating(Hashing.murmur3_32(), Hashing.md5()), Hashing.concatenating(asList(Hashing.murmur3_32(), Hashing.md5()))).addEqualityGroup(Hashing.concatenating(Hashing.md5(), Hashing.murmur3_32()), Hashing.concatenating(asList(Hashing.md5(), Hashing.murmur3_32()))).testEquals();\n}", "repo_id": "5", "comment": "// This isn't specified by contract, but it'll still be nice to know if this behavior changes.\n", "repo_name": "guava-master/", "id": 3735, "method_signature": "void testConcatenating_equals()", "filename": "HashingTest.testConcatenating_equals.json"}
{"callee_method_names": [], "method_name": "HashingTest.testConsistentHash_linearCongruentialGeneratorCompatibility", "method_implementation": "{\n    int[] golden100 = { 0, 55, 62, 8, 45, 59, 86, 97, 82, 59, 73, 37, 17, 56, 86, 21, 90, 37, 38, 83 };\n    for (int i = 0; i < golden100.length; i++) {\n        assertEquals(golden100[i], Hashing.consistentHash(i, 100));\n    }\n    assertEquals(6, Hashing.consistentHash(10863919174838991L, 11));\n    assertEquals(3, Hashing.consistentHash(2016238256797177309L, 11));\n    assertEquals(5, Hashing.consistentHash(1673758223894951030L, 11));\n    assertEquals(80343, Hashing.consistentHash(2, 100001));\n    assertEquals(22152, Hashing.consistentHash(2201, 100001));\n    assertEquals(15018, Hashing.consistentHash(2202, 100001));\n}", "repo_id": "5", "comment": "/**\n * Check a few \"golden\" values to see that implementations across languages are equivalent.\n */\n", "repo_name": "guava-master/", "id": 3734, "method_signature": "void testConsistentHash_linearCongruentialGeneratorCompatibility()", "filename": "HashingTest.testConsistentHash_linearCongruentialGeneratorCompatibility.json"}
{"callee_method_names": [], "method_name": "HashingTest.testGoodFastHash128", "method_implementation": "{\n    HashTestUtils.check2BitAvalanche(Hashing.goodFastHash(128), 250, 0.20);\n    HashTestUtils.checkAvalanche(Hashing.goodFastHash(128), 500, 0.17);\n    HashTestUtils.checkNo2BitCharacteristics(Hashing.goodFastHash(128));\n    HashTestUtils.checkNoFunnels(Hashing.goodFastHash(128));\n    HashTestUtils.assertInvariants(Hashing.goodFastHash(128));\n}", "repo_id": "5", "comment": "// goodFastHash(128) uses Murmur3_128. Use the same epsilon bounds.\n", "repo_name": "guava-master/", "id": 3732, "method_signature": "void testGoodFastHash128()", "filename": "HashingTest.testGoodFastHash128.json"}
{"callee_method_names": [], "method_name": "HashingTest.testGoodFastHash256", "method_implementation": "{\n    HashTestUtils.check2BitAvalanche(Hashing.goodFastHash(256), 250, 0.20);\n    HashTestUtils.checkAvalanche(Hashing.goodFastHash(256), 500, 0.17);\n    HashTestUtils.checkNo2BitCharacteristics(Hashing.goodFastHash(256));\n    HashTestUtils.checkNoFunnels(Hashing.goodFastHash(256));\n    HashTestUtils.assertInvariants(Hashing.goodFastHash(256));\n}", "repo_id": "5", "comment": "// goodFastHash(256) uses Murmur3_128. Use the same epsilon bounds.\n", "repo_name": "guava-master/", "id": 3733, "method_signature": "void testGoodFastHash256()", "filename": "HashingTest.testGoodFastHash256.json"}
{"callee_method_names": [], "method_name": "HashingTest.testGoodFastHash32", "method_implementation": "{\n    HashTestUtils.check2BitAvalanche(Hashing.goodFastHash(32), 250, 0.20);\n    HashTestUtils.checkAvalanche(Hashing.goodFastHash(32), 250, 0.17);\n    HashTestUtils.checkNo2BitCharacteristics(Hashing.goodFastHash(32));\n    HashTestUtils.checkNoFunnels(Hashing.goodFastHash(32));\n    HashTestUtils.assertInvariants(Hashing.goodFastHash(32));\n}", "repo_id": "5", "comment": "// goodFastHash(32) uses Murmur3_32. Use the same epsilon bounds.\n", "repo_name": "guava-master/", "id": 3731, "method_signature": "void testGoodFastHash32()", "filename": "HashingTest.testGoodFastHash32.json"}
{"callee_method_names": ["HashFunction.toString", "HashFunction.toString", "HashFunction.toString", "HashFunction.toString", "HashFunction.toString", "HashFunction.toString", "HashFunction.toString", "HashFunction.toString"], "method_name": "HashingTest.testGoodFastHashEquals", "method_implementation": "{\n    HashFunction hashFunction1a = Hashing.goodFastHash(1);\n    HashFunction hashFunction1b = Hashing.goodFastHash(32);\n    HashFunction hashFunction2a = Hashing.goodFastHash(33);\n    HashFunction hashFunction2b = Hashing.goodFastHash(128);\n    HashFunction hashFunction3a = Hashing.goodFastHash(129);\n    HashFunction hashFunction3b = Hashing.goodFastHash(256);\n    HashFunction hashFunction4a = Hashing.goodFastHash(257);\n    HashFunction hashFunction4b = Hashing.goodFastHash(384);\n    new EqualsTester().addEqualityGroup(hashFunction1a, hashFunction1b).addEqualityGroup(hashFunction2a, hashFunction2b).addEqualityGroup(hashFunction3a, hashFunction3b).addEqualityGroup(hashFunction4a, hashFunction4b).testEquals();\n    assertEquals(hashFunction1a.toString(), hashFunction1b.toString());\n    assertEquals(hashFunction2a.toString(), hashFunction2b.toString());\n    assertEquals(hashFunction3a.toString(), hashFunction3b.toString());\n    assertEquals(hashFunction4a.toString(), hashFunction4b.toString());\n}", "repo_id": "5", "comment": "/**\n * Tests equality of {@link Hashing#goodFastHash} instances. This test must be separate from\n * {@link #testSeededHashFunctionEquals} because the parameter to {@code goodFastHash} is a size,\n * not a seed, and because that size is rounded up. Thus, {@code goodFastHash} instances with\n * different parameters can be equal. That fact is a problem for {@code\n * testSeededHashFunctionEquals}.\n */\n", "repo_name": "guava-master/", "id": 3736, "method_signature": "void testGoodFastHashEquals()", "filename": "HashingTest.testGoodFastHashEquals.json"}
{"callee_method_ids": [6532], "callee_method_names": ["Heap.bubbleUpAlternatingLevels"], "method_name": "Heap.bubbleUp", "method_implementation": "{\n    int crossOver = crossOverUp(index, x);\n    Heap heap;\n    if (crossOver == index) {\n        heap = this;\n    } else {\n        index = crossOver;\n        heap = otherHeap;\n    }\n    heap.bubbleUpAlternatingLevels(index, x);\n}", "repo_id": "5", "comment": "/**\n * Bubbles a value from {@code index} up the appropriate heap if required.\n */\n", "repo_name": "guava-master/", "id": 6531, "method_signature": "void bubbleUp(int, E)", "filename": "Heap.bubbleUp.json"}
{"callee_method_names": ["Ordering<E>.compare"], "method_name": "Heap.bubbleUpAlternatingLevels", "method_implementation": "{\n    while (index > 2) {\n        int grandParentIndex = getGrandparentIndex(index);\n        E e = elementData(grandParentIndex);\n        if (ordering.compare(e, x) <= 0) {\n            break;\n        }\n        queue[index] = e;\n        index = grandParentIndex;\n    }\n    queue[index] = x;\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Bubbles a value from {@code index} up the levels of this heap, and returns the index the\n * element ended up at.\n */\n", "repo_name": "guava-master/", "id": 6532, "method_signature": "int bubbleUpAlternatingLevels(int, E)", "filename": "Heap.bubbleUpAlternatingLevels.json"}
{"callee_method_names": ["Ordering<E>.compare"], "method_name": "Heap.crossOver", "method_implementation": "{\n    int minChildIndex = findMinChild(index);\n    // TODO(kevinb): split the && into two if's and move crossOverUp so it's\n    // only called when there's no child.\n    if ((minChildIndex > 0) && (ordering.compare(elementData(minChildIndex), x) < 0)) {\n        queue[index] = elementData(minChildIndex);\n        queue[minChildIndex] = x;\n        return minChildIndex;\n    }\n    return crossOverUp(index, x);\n}", "repo_id": "5", "comment": "/**\n * Crosses an element over to the opposite heap by moving it one level down (or up if there are\n * no elements below it).\n *\n * <p>Returns the new position of the element.\n */\n", "repo_name": "guava-master/", "id": 6537, "method_signature": "int crossOver(int, E)", "filename": "Heap.crossOver.json"}
{"callee_method_names": ["Ordering<E>.compare", "Ordering<E>.compare"], "method_name": "Heap.crossOverUp", "method_implementation": "{\n    if (index == 0) {\n        queue[0] = x;\n        return 0;\n    }\n    int parentIndex = getParentIndex(index);\n    E parentElement = elementData(parentIndex);\n    if (parentIndex != 0) {\n        /*\n         * This is a guard for the case of the childless aunt node. Since the end of the array is\n         * actually the middle of the heap, a smaller childless aunt node can become a child of x\n         * when we bubble up alternate levels, violating the invariant.\n         */\n        int grandparentIndex = getParentIndex(parentIndex);\n        int auntIndex = getRightChildIndex(grandparentIndex);\n        if (auntIndex != parentIndex && getLeftChildIndex(auntIndex) >= size) {\n            E auntElement = elementData(auntIndex);\n            if (ordering.compare(auntElement, parentElement) < 0) {\n                parentIndex = auntIndex;\n                parentElement = auntElement;\n            }\n        }\n    }\n    if (ordering.compare(parentElement, x) < 0) {\n        queue[index] = parentElement;\n        queue[parentIndex] = x;\n        return parentIndex;\n    }\n    queue[index] = x;\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Moves an element one level up from a min level to a max level (or vice versa). Returns the\n * new position of the element.\n */\n", "repo_name": "guava-master/", "id": 6535, "method_signature": "int crossOverUp(int, E)", "filename": "Heap.crossOverUp.json"}
{"callee_method_names": [], "method_name": "Heap.fillHoleAt", "method_implementation": "{\n    int minGrandchildIndex;\n    while ((minGrandchildIndex = findMinGrandChild(index)) > 0) {\n        queue[index] = elementData(minGrandchildIndex);\n        index = minGrandchildIndex;\n    }\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Fills the hole at {@code index} by moving in the least of its grandchildren to this position,\n * then recursively filling the new hole created.\n *\n * @return the position of the new hole (where the lowest grandchild moved from, that had no\n *     grandchild to replace it)\n */\n", "repo_name": "guava-master/", "id": 6538, "method_signature": "int fillHoleAt(int)", "filename": "Heap.fillHoleAt.json"}
{"callee_method_names": [], "method_name": "Heap.findMin", "method_implementation": "{\n    if (index >= size) {\n        return -1;\n    }\n    checkState(index > 0);\n    int limit = Math.min(index, size - len) + len;\n    int minIndex = index;\n    for (int i = index + 1; i < limit; i++) {\n        if (compareElements(i, minIndex) < 0) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}", "repo_id": "5", "comment": "/**\n * Returns the index of minimum value between {@code index} and {@code index + len}, or {@code\n * -1} if {@code index} is greater than {@code size}.\n */\n", "repo_name": "guava-master/", "id": 6533, "method_signature": "int findMin(int, int)", "filename": "Heap.findMin.json"}
{"callee_method_names": [], "method_name": "Heap.findMinGrandChild", "method_implementation": "{\n    int leftChildIndex = getLeftChildIndex(index);\n    if (leftChildIndex < 0) {\n        return -1;\n    }\n    return findMin(getLeftChildIndex(leftChildIndex), 4);\n}", "repo_id": "5", "comment": "/**\n * Returns the minimum grand child or -1 if no grand child exists.\n */\n", "repo_name": "guava-master/", "id": 6534, "method_signature": "int findMinGrandChild(int)", "filename": "Heap.findMinGrandChild.json"}
{"callee_method_names": ["Ordering<E>.compare"], "method_name": "Heap.swapWithConceptuallyLastElement", "method_implementation": "{\n    int parentIndex = getParentIndex(size);\n    if (parentIndex != 0) {\n        int grandparentIndex = getParentIndex(parentIndex);\n        int auntIndex = getRightChildIndex(grandparentIndex);\n        if (auntIndex != parentIndex && getLeftChildIndex(auntIndex) >= size) {\n            E auntElement = elementData(auntIndex);\n            if (ordering.compare(auntElement, actualLastElement) < 0) {\n                queue[auntIndex] = actualLastElement;\n                queue[size] = auntElement;\n                return auntIndex;\n            }\n        }\n    }\n    return size;\n}", "repo_id": "5", "comment": "/**\n * Swap {@code actualLastElement} with the conceptually correct last element of the heap.\n * Returns the index that {@code actualLastElement} now resides in.\n *\n * <p>Since the last element of the array is actually in the middle of the sorted structure, a\n * childless aunt node could be smaller, which would corrupt the invariant if this element\n * becomes the new parent of the aunt node. In that case, we first switch the last element with\n * its aunt node, before returning.\n */\n", "repo_name": "guava-master/", "id": 6536, "method_signature": "int swapWithConceptuallyLastElement(E)", "filename": "Heap.swapWithConceptuallyLastElement.json"}
{"callee_method_ids": [6532], "callee_method_names": ["Heap.bubbleUpAlternatingLevels"], "method_name": "Heap.tryCrossOverAndBubbleUp", "method_implementation": "{\n    int crossOver = crossOver(vacated, toTrickle);\n    if (crossOver == vacated) {\n        return null;\n    }\n    // Successfully crossed over from min to max.\n    // Bubble up max levels.\n    E parent;\n    // If toTrickle is moved up to a parent of removeIndex, the parent is\n    // placed in removeIndex position. We must return that to the iterator so\n    // that it knows to skip it.\n    if (crossOver < removeIndex) {\n        // We crossed over to the parent level in crossOver, so the parent\n        // has already been moved.\n        parent = elementData(removeIndex);\n    } else {\n        parent = elementData(getParentIndex(removeIndex));\n    }\n    // bubble it up the opposite heap\n    if (otherHeap.bubbleUpAlternatingLevels(crossOver, toTrickle) < removeIndex) {\n        return new MoveDesc<>(toTrickle, parent);\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Tries to move {@code toTrickle} from a min to a max level and bubble up there. If it moved\n * before {@code removeIndex} this method returns a pair as described in {@link #removeAt}.\n */\n", "repo_name": "guava-master/", "id": 6530, "method_signature": "MoveDesc<E> tryCrossOverAndBubbleUp(int, int, E)", "filename": "Heap.tryCrossOverAndBubbleUp.json"}
{"callee_method_names": [], "method_name": "Helpers.copyToList", "method_implementation": "{\n    List<E> list = new ArrayList<>();\n    addAll(list, elements);\n    return list;\n}", "repo_id": "5", "comment": "// Clone of Lists.newArrayList\n", "repo_name": "guava-master/", "id": 4200, "method_signature": "List<E> copyToList(Iterable)", "filename": "Helpers.copyToList.json"}
{"callee_method_names": [], "method_name": "Helpers.copyToSet", "method_implementation": "{\n    Set<E> set = new LinkedHashSet<>();\n    addAll(set, elements);\n    return set;\n}", "repo_id": "5", "comment": "// Clone of Sets.newLinkedHashSet\n", "repo_name": "guava-master/", "id": 4201, "method_signature": "Set<E> copyToSet(Iterable)", "filename": "Helpers.copyToSet.json"}
{"callee_method_names": ["ArrayList.size", "ArrayList.get", "ArrayList.set", "ArrayList.add", "ArrayList.add", "ArrayList.remove", "ArrayList.toArray"], "method_name": "Helpers.misleadingSizeCollection", "method_implementation": "{\n    // It would be nice to be able to return a real concurrent\n    // collection like ConcurrentLinkedQueue, so that e.g. concurrent\n    // iteration would work, but that would not be GWT-compatible.\n    // We are not \"just\" inheriting from ArrayList here as this doesn't work for J2kt.\n    return new AbstractList<T>() {\n\n        ArrayList<T> data = new ArrayList<>();\n\n        @Override\n        public int size() {\n            return Math.max(0, data.size() + delta);\n        }\n\n        @Override\n        public T get(int index) {\n            return data.get(index);\n        }\n\n        @Override\n        public T set(int index, T element) {\n            return data.set(index, element);\n        }\n\n        @Override\n        public boolean add(T element) {\n            return data.add(element);\n        }\n\n        @Override\n        public void add(int index, T element) {\n            data.add(index, element);\n        }\n\n        @Override\n        public T remove(int index) {\n            return data.remove(index);\n        }\n\n        @Override\n        @Nullable\n        public Object[] toArray() {\n            return data.toArray();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a collection that simulates concurrent modification by having its size method return\n * incorrect values. This is useful for testing methods that must treat the return value from\n * size() as a hint only.\n *\n * @param delta the difference between the true size of the collection and the values returned by\n *     the size method\n */\n", "repo_name": "guava-master/", "id": 4203, "method_signature": "Collection<T> misleadingSizeCollection(int)", "filename": "Helpers.misleadingSizeCollection.json"}
{"callee_method_names": ["Entry<K, V>.setValue", "Entry<K, V>.getKey", "Entry<K, V>.getValue", "K.hashCode", "V.hashCode"], "method_name": "Helpers.nefariousMapEntry", "method_implementation": "{\n    return new Entry<K, V>() {\n\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        @Override\n        public V setValue(V value) {\n            throw new UnsupportedOperationException();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean equals(@Nullable Object o) {\n            if (o instanceof Entry) {\n                Entry<K, V> e = (Entry<K, V>) o;\n                // muhahaha!\n                e.setValue(value);\n                return equal(this.getKey(), e.getKey()) && equal(this.getValue(), e.getValue());\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            K k = getKey();\n            V v = getValue();\n            return ((k == null) ? 0 : k.hashCode()) ^ ((v == null) ? 0 : v.hashCode());\n        }\n\n        @Override\n        public String toString() {\n            return getKey() + \"=\" + getValue();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a \"nefarious\" map entry with the specified key and value, meaning an entry that is\n * suitable for testing that map entries cannot be modified via a nefarious implementation of\n * equals. This is used for testing unmodifiable collections of map entries; for example, it\n * should not be possible to access the raw (modifiable) map entry via a nefarious equals method.\n */\n", "repo_name": "guava-master/", "id": 4204, "method_signature": "Entry<K,V> nefariousMapEntry(K, V)", "filename": "Helpers.nefariousMapEntry.json"}
{"callee_method_names": ["List<T>.size", "List<T>.get", "List<T>.get", "Comparator<? super T>.compare", "Comparator<? super T>.compare", "List<T>.size", "List<T>.get", "Comparator<? super T>.compare"], "method_name": "Helpers.testComparator", "method_implementation": "{\n    // This does an O(n^2) test of all pairs of values in both orders\n    for (int i = 0; i < valuesInExpectedOrder.size(); i++) {\n        T t = valuesInExpectedOrder.get(i);\n        for (int j = 0; j < i; j++) {\n            T lesser = valuesInExpectedOrder.get(j);\n            assertTrue(comparator + \".compare(\" + lesser + \", \" + t + \")\", comparator.compare(lesser, t) < 0);\n        }\n        assertEquals(comparator + \".compare(\" + t + \", \" + t + \")\", 0, comparator.compare(t, t));\n        for (int j = i + 1; j < valuesInExpectedOrder.size(); j++) {\n            T greater = valuesInExpectedOrder.get(j);\n            assertTrue(comparator + \".compare(\" + greater + \", \" + t + \")\", comparator.compare(greater, t) > 0);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Asserts that all pairs of {@code T} values within {@code valuesInExpectedOrder} are ordered\n * consistently between their order within {@code valuesInExpectedOrder} and the order implied by\n * the given {@code comparator}.\n *\n * <p>In detail, this method asserts\n *\n * <ul>\n *   <li><i>reflexivity</i>: {@code comparator.compare(t, t) = 0} for all {@code t} in {@code\n *       valuesInExpectedOrder}; and\n *   <li><i>consistency</i>: {@code comparator.compare(ti, tj) < 0} and {@code\n *       comparator.compare(tj, ti) > 0} for {@code i < j}, where {@code ti =\n *       valuesInExpectedOrder.get(i)} and {@code tj = valuesInExpectedOrder.get(j)}.\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 4202, "method_signature": "void testComparator(Comparator, List)", "filename": "Helpers.testComparator.json"}
{"callee_method_names": ["HostAndPort.hasPort"], "method_name": "HostAndPort.fromHost", "method_implementation": "{\n    HostAndPort parsedHost = fromString(host);\n    checkArgument(!parsedHost.hasPort(), \"Host has a port: %s\", host);\n    return parsedHost;\n}", "repo_id": "5", "comment": "/**\n * Build a HostAndPort instance from a host only.\n *\n * <p>Note: Non-bracketed IPv6 literals are allowed. Use {@link #requireBracketsForIPv6()} to\n * prohibit these.\n *\n * @param host the host-only string to parse. Must not contain a port number.\n * @return if parsing was successful, a populated HostAndPort object.\n * @throws IllegalArgumentException if {@code host} contains a port number.\n * @since 17.0\n */\n", "repo_name": "guava-master/", "id": 6714, "method_signature": "HostAndPort fromHost(String)", "filename": "HostAndPort.fromHost.json"}
{"callee_method_names": ["HostAndPort.hasPort"], "method_name": "HostAndPort.fromParts", "method_implementation": "{\n    checkArgument(isValidPort(port), \"Port out of range: %s\", port);\n    HostAndPort parsedHost = fromString(host);\n    checkArgument(!parsedHost.hasPort(), \"Host has a port: %s\", host);\n    return new HostAndPort(parsedHost.host, port, parsedHost.hasBracketlessColons);\n}", "repo_id": "5", "comment": "/**\n * Build a HostAndPort instance from separate host and port values.\n *\n * <p>Note: Non-bracketed IPv6 literals are allowed. Use {@link #requireBracketsForIPv6()} to\n * prohibit these.\n *\n * @param host the host string to parse. Must not contain a port number.\n * @param port a port number from [0..65535]\n * @return if parsing was successful, a populated HostAndPort object.\n * @throws IllegalArgumentException if {@code host} contains a port number, or {@code port} is out\n *     of range.\n */\n", "repo_name": "guava-master/", "id": 6713, "method_signature": "HostAndPort fromParts(String, int)", "filename": "HostAndPort.fromParts.json"}
{"callee_method_names": ["String.startsWith", "String.indexOf", "String.indexOf", "String.substring", "String.substring", "String.startsWith"], "method_name": "HostAndPort.fromString", "method_implementation": "{\n    checkNotNull(hostPortString);\n    String host;\n    String portString = null;\n    boolean hasBracketlessColons = false;\n    if (hostPortString.startsWith(\"[\")) {\n        String[] hostAndPort = getHostAndPortFromBracketedHost(hostPortString);\n        host = hostAndPort[0];\n        portString = hostAndPort[1];\n    } else {\n        int colonPos = hostPortString.indexOf(':');\n        if (colonPos >= 0 && hostPortString.indexOf(':', colonPos + 1) == -1) {\n            // Exactly 1 colon. Split into host:port.\n            host = hostPortString.substring(0, colonPos);\n            portString = hostPortString.substring(colonPos + 1);\n        } else {\n            // 0 or 2+ colons. Bare hostname or IPv6 literal.\n            host = hostPortString;\n            hasBracketlessColons = (colonPos >= 0);\n        }\n    }\n    int port = NO_PORT;\n    if (!Strings.isNullOrEmpty(portString)) {\n        // Try to parse the whole port string as a number.\n        // JDK7 accepts leading plus signs. We don't want to.\n        checkArgument(!portString.startsWith(\"+\") && CharMatcher.ascii().matchesAllOf(portString), \"Unparseable port number: %s\", hostPortString);\n        try {\n            port = Integer.parseInt(portString);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Unparseable port number: \" + hostPortString);\n        }\n        checkArgument(isValidPort(port), \"Port number out of range: %s\", hostPortString);\n    }\n    return new HostAndPort(host, port, hasBracketlessColons);\n}", "repo_id": "5", "comment": "/**\n * Split a freeform string into a host and port, without strict validation.\n *\n * <p>Note that the host-only formats will leave the port field undefined. You can use {@link\n * #withDefaultPort(int)} to patch in a default value.\n *\n * @param hostPortString the input string to parse.\n * @return if parsing was successful, a populated HostAndPort object.\n * @throws IllegalArgumentException if nothing meaningful could be parsed.\n */\n", "repo_name": "guava-master/", "id": 6715, "method_signature": "HostAndPort fromString(String)", "filename": "HostAndPort.fromString.json"}
{"callee_method_names": ["String.charAt", "String.indexOf", "String.lastIndexOf", "String.substring", "String.length", "String.charAt", "String.length", "String.charAt", "String.substring"], "method_name": "HostAndPort.getHostAndPortFromBracketedHost", "method_implementation": "{\n    checkArgument(hostPortString.charAt(0) == '[', \"Bracketed host-port string must start with a bracket: %s\", hostPortString);\n    int colonIndex = hostPortString.indexOf(':');\n    int closeBracketIndex = hostPortString.lastIndexOf(']');\n    checkArgument(colonIndex > -1 && closeBracketIndex > colonIndex, \"Invalid bracketed host/port: %s\", hostPortString);\n    String host = hostPortString.substring(1, closeBracketIndex);\n    if (closeBracketIndex + 1 == hostPortString.length()) {\n        return new String[] { host, \"\" };\n    } else {\n        checkArgument(hostPortString.charAt(closeBracketIndex + 1) == ':', \"Only a colon may follow a close bracket: %s\", hostPortString);\n        for (int i = closeBracketIndex + 2; i < hostPortString.length(); ++i) {\n            checkArgument(Character.isDigit(hostPortString.charAt(i)), \"Port must be numeric: %s\", hostPortString);\n        }\n        return new String[] { host, hostPortString.substring(closeBracketIndex + 2) };\n    }\n}", "repo_id": "5", "comment": "/**\n * Parses a bracketed host-port string, throwing IllegalArgumentException if parsing fails.\n *\n * @param hostPortString the full bracketed host-port specification. Port might not be specified.\n * @return an array with 2 strings: host and port, in that order.\n * @throws IllegalArgumentException if parsing the bracketed host-port string fails.\n */\n", "repo_name": "guava-master/", "id": 6716, "method_signature": "String[] getHostAndPortFromBracketedHost(String)", "filename": "HostAndPort.getHostAndPortFromBracketedHost.json"}
{"callee_method_names": [], "method_name": "HostAndPort.requireBracketsForIPv6", "method_implementation": "{\n    checkArgument(!hasBracketlessColons, \"Possible bracketless IPv6 literal: %s\", host);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Generate an error if the host might be a non-bracketed IPv6 literal.\n *\n * <p>URI formatting requires that IPv6 literals be surrounded by brackets, like \"[2001:db8::1]\".\n * Chain this call after {@link #fromString(String)} to increase the strictness of the parser, and\n * disallow IPv6 literals that don't contain these brackets.\n *\n * <p>Note that this parser identifies IPv6 literals solely based on the presence of a colon. To\n * perform actual validation of IP addresses, see the {@link InetAddresses#forString(String)}\n * method.\n *\n * @return {@code this}, to enable chaining of calls.\n * @throws IllegalArgumentException if bracketless IPv6 is detected.\n */\n", "repo_name": "guava-master/", "id": 6718, "method_signature": "HostAndPort requireBracketsForIPv6()", "filename": "HostAndPort.requireBracketsForIPv6.json"}
{"callee_method_names": ["String.length", "String.indexOf", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "HostAndPort.toString", "method_implementation": "{\n    // \"[]:12345\" requires 8 extra bytes.\n    StringBuilder builder = new StringBuilder(host.length() + 8);\n    if (host.indexOf(':') >= 0) {\n        builder.append('[').append(host).append(']');\n    } else {\n        builder.append(host);\n    }\n    if (hasPort()) {\n        builder.append(':').append(port);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Rebuild the host:port string, including brackets if necessary.\n */\n", "repo_name": "guava-master/", "id": 6719, "method_signature": "String toString()", "filename": "HostAndPort.toString.json"}
{"callee_method_names": [], "method_name": "HostAndPort.withDefaultPort", "method_implementation": "{\n    checkArgument(isValidPort(defaultPort));\n    if (hasPort()) {\n        return this;\n    }\n    return new HostAndPort(host, defaultPort, hasBracketlessColons);\n}", "repo_id": "5", "comment": "/**\n * Provide a default port if the parsed string contained only a host.\n *\n * <p>You can chain this after {@link #fromString(String)} to include a port in case the port was\n * omitted from the input string. If a port was already provided, then this method is a no-op.\n *\n * @param defaultPort a port number, from [0..65535]\n * @return a HostAndPort instance, guaranteed to have a defined port.\n */\n", "repo_name": "guava-master/", "id": 6717, "method_signature": "HostAndPort withDefaultPort(int)", "filename": "HostAndPort.withDefaultPort.json"}
{"callee_method_names": ["ParseException.initCause"], "method_name": "HostSpecifier.from", "method_implementation": "{\n    try {\n        return fromValid(specifier);\n    } catch (IllegalArgumentException e) {\n        // Since the IAE can originate at several different points inside\n        // fromValid(), we implement this method in terms of that one rather\n        // than the reverse.\n        ParseException parseException = new ParseException(\"Invalid host specifier: \" + specifier, 0);\n        parseException.initCause(e);\n        throw parseException;\n    }\n}", "repo_id": "5", "comment": "/**\n * Attempts to return a {@code HostSpecifier} for the given string, throwing an exception if\n * parsing fails. Always use this method in preference to {@link #fromValid(String)} for a\n * specifier that is not already known to be valid.\n *\n * @throws ParseException if the specifier is not valid.\n */\n", "repo_name": "guava-master/", "id": 6675, "method_signature": "HostSpecifier from(String)", "filename": "HostSpecifier.from.json"}
{"callee_method_names": ["HostAndPort.hasPort", "HostAndPort.getHost", "InternetDomainName.hasPublicSuffix", "InternetDomainName.toString"], "method_name": "HostSpecifier.fromValid", "method_implementation": "{\n    // Verify that no port was specified, and strip optional brackets from\n    // IPv6 literals.\n    HostAndPort parsedHost = HostAndPort.fromString(specifier);\n    Preconditions.checkArgument(!parsedHost.hasPort());\n    String host = parsedHost.getHost();\n    // Try to interpret the specifier as an IP address. Note we build\n    // the address rather than using the .is* methods because we want to\n    // use InetAddresses.toUriString to convert the result to a string in\n    // canonical form.\n    InetAddress addr = null;\n    try {\n        addr = InetAddresses.forString(host);\n    } catch (IllegalArgumentException e) {\n        // It is not an IPv4 or IPv6 literal\n    }\n    if (addr != null) {\n        return new HostSpecifier(InetAddresses.toUriString(addr));\n    }\n    // It is not any kind of IP address; must be a domain name or invalid.\n    // TODO(user): different versions of this for different factories?\n    InternetDomainName domain = InternetDomainName.from(host);\n    if (domain.hasPublicSuffix()) {\n        return new HostSpecifier(domain.toString());\n    }\n    throw new IllegalArgumentException(\"Domain name does not have a recognized public suffix: \" + host);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code HostSpecifier} built from the provided {@code specifier}, which is already\n * known to be valid. If the {@code specifier} might be invalid, use {@link #from(String)}\n * instead.\n *\n * <p>The specifier must be in one of these formats:\n *\n * <ul>\n *   <li>A domain name, like {@code google.com}\n *   <li>A IPv4 address string, like {@code 127.0.0.1}\n *   <li>An IPv6 address string with or without brackets, like {@code [2001:db8::1]} or {@code\n *       2001:db8::1}\n * </ul>\n *\n * @throws IllegalArgumentException if the specifier is not valid.\n */\n", "repo_name": "guava-master/", "id": 6674, "method_signature": "HostSpecifier fromValid(String)", "filename": "HostSpecifier.fromValid.json"}
{"callee_method_names": [], "method_name": "HostSpecifier.isValid", "method_implementation": "{\n    try {\n        HostSpecifier unused = fromValid(specifier);\n        return true;\n    } catch (IllegalArgumentException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Determines whether {@code specifier} represents a valid {@link HostSpecifier} as described in\n * the documentation for {@link #fromValid(String)}.\n */\n", "repo_name": "guava-master/", "id": 6676, "method_signature": "boolean isValid(String)", "filename": "HostSpecifier.isValid.json"}
{"callee_method_names": [], "method_name": "HttpHeadersTest.assertConstantNameMatchesString", "method_implementation": "{\n    for (Field field : relevantFields(clazz)) {\n        assertEquals(upperToHttpHeaderName(field.getName(), specialCases, uppercaseAcronyms), field.get(null));\n    }\n}", "repo_id": "5", "comment": "// Visible for other tests to use\n", "repo_name": "guava-master/", "id": 4045, "method_signature": "void assertConstantNameMatchesString(Class, ImmutableBiMap, ImmutableSet)", "filename": "HttpHeadersTest.assertConstantNameMatchesString.json"}
{"callee_method_names": ["Class<?>.getDeclaredFields", "ImmutableSet.Builder<Field>.add", "ImmutableSet.Builder<Field>.build"], "method_name": "HttpHeadersTest.relevantFields", "method_implementation": "{\n    ImmutableSet.Builder<Field> builder = ImmutableSet.builder();\n    for (Field field : cls.getDeclaredFields()) {\n        /*\n       * Coverage mode generates synthetic fields.  If we ever add private\n       * fields, they will cause similar problems, and we may want to switch\n       * this check to isAccessible().\n       */\n        if (!field.isSynthetic() && field.getType() == String.class) {\n            builder.add(field);\n        }\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "// Visible for other tests to use\n", "repo_name": "guava-master/", "id": 4046, "method_signature": "ImmutableSet<Field> relevantFields(Class)", "filename": "HttpHeadersTest.relevantFields.json"}
{"callee_method_names": [], "method_name": "ImmediateFuture.get", "method_implementation": "{\n    return value;\n}", "repo_id": "5", "comment": "// TODO(lukes): Consider throwing InterruptedException when appropriate.\n", "repo_name": "guava-master/", "id": 5387, "method_signature": "V get()", "filename": "ImmediateFuture.get.json"}
{"callee_method_names": [], "method_name": "ImmutableArrayMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5551, "method_signature": "Object writeReplace()", "filename": "ImmutableArrayMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.buildKeepingLast", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported for bimaps\");\n}", "repo_id": "5", "comment": "/**\n * Throws {@link UnsupportedOperationException}. This method is inherited from {@link\n * ImmutableMap.Builder}, but it does not make sense for bimaps.\n *\n * @throws UnsupportedOperationException always\n * @deprecated This method does not make sense for bimaps and should not be called.\n * @since 31.1\n */\n", "repo_name": "guava-master/", "id": 6360, "method_signature": "ImmutableBiMap<K,V> buildKeepingLast()", "filename": "ImmutableBiMap.buildKeepingLast.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.buildOrThrow", "method_implementation": "{\n    if (size == 0) {\n        return of();\n    }\n    if (valueComparator != null) {\n        if (entriesUsed) {\n            alternatingKeysAndValues = Arrays.copyOf(alternatingKeysAndValues, 2 * size);\n        }\n        sortEntries(alternatingKeysAndValues, size, valueComparator);\n    }\n    entriesUsed = true;\n    return new RegularImmutableBiMap<K, V>(alternatingKeysAndValues, size);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created immutable bimap, or throws an exception if any key or value was added\n * more than once. The iteration order of the returned bimap is the order in which entries were\n * inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case\n * entries are sorted by value.\n *\n * @throws IllegalArgumentException if duplicate keys or values were added\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 6359, "method_signature": "ImmutableBiMap<K,V> buildOrThrow()", "filename": "ImmutableBiMap.buildOrThrow.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.copyOf", "method_implementation": "{\n    int estimatedSize = (entries instanceof Collection) ? ((Collection<?>) entries).size() : ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY;\n    return new Builder<K, V>(estimatedSize).putAll(entries).build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable bimap containing the given entries. The returned bimap iterates over\n * entries in the same order as the original iterable.\n *\n * @throws IllegalArgumentException if two keys have the same value or two values have the same\n *     key\n * @throws NullPointerException if any key, value, or entry is null\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6362, "method_signature": "ImmutableBiMap<K,V> copyOf(Iterable)", "filename": "ImmutableBiMap.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.forcePut", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the bimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6363, "method_signature": "V forcePut(K, V)", "filename": "ImmutableBiMap.forcePut.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.of", "method_implementation": "{\n    checkEntryNotNull(k1, v1);\n    checkEntryNotNull(k2, v2);\n    checkEntryNotNull(k3, v3);\n    checkEntryNotNull(k4, v4);\n    checkEntryNotNull(k5, v5);\n    checkEntryNotNull(k6, v6);\n    checkEntryNotNull(k7, v7);\n    checkEntryNotNull(k8, v8);\n    checkEntryNotNull(k9, v9);\n    checkEntryNotNull(k10, v10);\n    return new RegularImmutableBiMap<K, V>(new Object[] { k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10 }, 10);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the given entries, in order.\n *\n * @throws IllegalArgumentException if duplicate keys or values are added\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 6352, "method_signature": "ImmutableBiMap<K,V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V)", "filename": "ImmutableBiMap.of.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.ofEntries", "method_implementation": "{\n    // we will only ever read these\n    @SuppressWarnings(\"unchecked\")\n    Entry<K, V>[] entries2 = (Entry<K, V>[]) entries;\n    return copyOf(Arrays.asList(entries2));\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the given entries, in order.\n *\n * @throws IllegalArgumentException if duplicate keys or values are provided\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 6353, "method_signature": "ImmutableBiMap<K,V> ofEntries(Entry<? extends K,? extends V>[])", "filename": "ImmutableBiMap.ofEntries.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.orderEntriesByValue", "method_implementation": "{\n    super.orderEntriesByValue(valueComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures this {@code Builder} to order entries by value according to the specified\n * comparator.\n *\n * <p>The sort order is stable, that is, if two entries have values that compare as equivalent,\n * the entry that was inserted first will be first in the built map's iteration order.\n *\n * @throws IllegalStateException if this method was already called\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6358, "method_signature": "Builder<K,V> orderEntriesByValue(Comparator)", "filename": "ImmutableBiMap.orderEntriesByValue.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.put", "method_implementation": "{\n    super.put(entry);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will\n * cause {@link #build} to fail.\n *\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6355, "method_signature": "Builder<K,V> put(Entry)", "filename": "ImmutableBiMap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.putAll", "method_implementation": "{\n    super.putAll(entries);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds all of the given entries to the built bimap. Duplicate keys or values are not allowed,\n * and will cause {@link #build} to fail.\n *\n * @throws NullPointerException if any key, value, or entry is null\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6357, "method_signature": "Builder<K,V> putAll(Iterable)", "filename": "ImmutableBiMap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.toImmutableBiMap", "method_implementation": "{\n    return CollectCollectors.toImmutableBiMap(keyFunction, valueFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose keys\n * and values are the result of applying the provided mapping functions to the input elements.\n * Entries appear in the result {@code ImmutableBiMap} in encounter order.\n *\n * <p>If the mapped keys or values contain duplicates (according to {@link\n * Object#equals(Object)}), an {@code IllegalArgumentException} is thrown when the collection\n * operation is performed. (This differs from the {@code Collector} returned by {@link\n * Collectors#toMap(Function, Function)}, which throws an {@code IllegalStateException}.)\n */\n", "repo_name": "guava-master/", "id": 6343, "method_signature": "Collector<T,?,ImmutableBiMap<K,V>> toImmutableBiMap(Function, Function)", "filename": "ImmutableBiMap.toImmutableBiMap.json"}
{"callee_method_names": [], "method_name": "ImmutableBiMap.toImmutableMap", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. This method does not make sense for {@code BiMap}. This method exists only to\n * hide {@link ImmutableMap#toImmutableMap(Function, Function, BinaryOperator)} from consumers of\n * {@code ImmutableBiMap}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated\n */\n", "repo_name": "guava-master/", "id": 6365, "method_signature": "Collector<T,?,ImmutableMap<K,V>> toImmutableMap(Function, Function, BinaryOperator)", "filename": "ImmutableBiMap.toImmutableMap.json"}
{"callee_method_names": ["ImmutableBiMap.Builder<String, Integer>.combine"], "method_name": "ImmutableBiMapTest.testToImmutableBiMap_exceptionOnDuplicateKey_java7_combine", "method_implementation": "{\n    ImmutableBiMap.Builder<String, Integer> zis = ImmutableBiMap.<String, Integer>builder().put(\"one\", 1).put(\"two\", 2);\n    ImmutableBiMap.Builder<String, Integer> zat = ImmutableBiMap.<String, Integer>builder().put(\"two\", 22).put(\"three\", 3);\n    try {\n        zis.combine(zat).build();\n        fail(\"Expected IllegalArgumentException\");\n    } catch (IllegalArgumentException expected) {\n        // expected\n    }\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableBiMap once CollectorTester is usable to java7.\n", "repo_name": "guava-master/", "id": 3972, "method_signature": "void testToImmutableBiMap_exceptionOnDuplicateKey_java7_combine()", "filename": "ImmutableBiMapTest.testToImmutableBiMap_exceptionOnDuplicateKey_java7_combine.json"}
{"callee_method_names": ["ImmutableBiMap.Builder<String, Integer>.combine"], "method_name": "ImmutableBiMapTest.testToImmutableBiMap_java7_combine", "method_implementation": "{\n    ImmutableBiMap.Builder<String, Integer> zis = ImmutableBiMap.<String, Integer>builder().put(\"one\", 1);\n    ImmutableBiMap.Builder<String, Integer> zat = ImmutableBiMap.<String, Integer>builder().put(\"two\", 2).put(\"three\", 3);\n    ImmutableBiMap<String, Integer> biMap = zis.combine(zat).build();\n    assertMapEquals(biMap, \"one\", 1, \"two\", 2, \"three\", 3);\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableBiMap once CollectorTester is usable to java7.\n", "repo_name": "guava-master/", "id": 3971, "method_signature": "void testToImmutableBiMap_java7_combine()", "filename": "ImmutableBiMapTest.testToImmutableBiMap_java7_combine.json"}
{"callee_method_names": ["ImmutableMap.Builder<Class<? extends B>, B>.buildOrThrow", "ImmutableMap<Class<? extends B>, B>.isEmpty"], "method_name": "ImmutableClassToInstanceMap.build", "method_implementation": "{\n    ImmutableMap<Class<? extends B>, B> map = mapBuilder.buildOrThrow();\n    if (map.isEmpty()) {\n        return of();\n    } else {\n        return new ImmutableClassToInstanceMap<>(map);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a new immutable class-to-instance map containing the entries provided to this\n * builder.\n *\n * @throws IllegalArgumentException if duplicate keys were added\n */\n", "repo_name": "guava-master/", "id": 5827, "method_signature": "ImmutableClassToInstanceMap<B> build()", "filename": "ImmutableClassToInstanceMap.build.json"}
{"callee_method_names": [], "method_name": "ImmutableClassToInstanceMap.copyOf", "method_implementation": "{\n    if (map instanceof ImmutableClassToInstanceMap) {\n        // JDT-based J2KT Java frontend does not permit the direct cast\n        @SuppressWarnings(\"rawtypes\")\n        Map rawMap = map;\n        // covariant casts safe (unmodifiable)\n        @SuppressWarnings(\"unchecked\")\n        ImmutableClassToInstanceMap<B> cast = (ImmutableClassToInstanceMap<B>) rawMap;\n        return cast;\n    }\n    return new Builder<B>().putAll(map).build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the same entries as {@code map}. If {@code map} somehow\n * contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose\n * comparator is not <i>consistent with equals</i>), the results of this method are undefined.\n *\n * <p><b>Note:</b> Despite what the method name suggests, if {@code map} is an {@code\n * ImmutableClassToInstanceMap}, no copy will actually be performed.\n *\n * @throws NullPointerException if any key or value in {@code map} is null\n * @throws ClassCastException if any value is not an instance of the type specified by its key\n */\n", "repo_name": "guava-master/", "id": 5828, "method_signature": "ImmutableClassToInstanceMap<B> copyOf(Map)", "filename": "ImmutableClassToInstanceMap.copyOf.json"}
{"callee_method_names": ["ImmutableMap.Builder<Class<? extends B>, B>.put"], "method_name": "ImmutableClassToInstanceMap.put", "method_implementation": "{\n    mapBuilder.put(key, value);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,\n * and will cause {@link #build} to fail.\n */\n", "repo_name": "guava-master/", "id": 5825, "method_signature": "Builder<B> put(Class, T)", "filename": "ImmutableClassToInstanceMap.put.json"}
{"callee_method_names": ["Map<? extends Class<? extends T>,? extends T>.entrySet", "Entry<? extends K,? extends V>.getKey", "Entry<? extends K,? extends V>.getValue", "ImmutableMap.Builder<Class<? extends B>, B>.put"], "method_name": "ImmutableClassToInstanceMap.putAll", "method_implementation": "{\n    for (Entry<? extends Class<? extends T>, ? extends T> entry : map.entrySet()) {\n        Class<? extends T> type = entry.getKey();\n        T value = entry.getValue();\n        mapBuilder.put(type, cast(type, value));\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Associates all of {@code map's} keys and values in the built map. Duplicate keys are not\n * allowed, and will cause {@link #build} to fail.\n *\n * @throws NullPointerException if any key or value in {@code map} is null\n * @throws ClassCastException if any value is not an instance of the type specified by its key\n */\n", "repo_name": "guava-master/", "id": 5826, "method_signature": "Builder<B> putAll(Map)", "filename": "ImmutableClassToInstanceMap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableClassToInstanceMap.putInstance", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5829, "method_signature": "T putInstance(Class, T)", "filename": "ImmutableClassToInstanceMap.putInstance.json"}
{"callee_method_names": ["ImmutableClassToInstanceMap.Builder<Impl>.put", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue", "ImmutableClassToInstanceMap.Builder<Impl>.build"], "method_name": "ImmutableClassToInstanceMapTest.create", "method_implementation": "{\n    ImmutableClassToInstanceMap.Builder<Impl> builder = ImmutableClassToInstanceMap.builder();\n    for (Object object : elements) {\n        Entry<Class, Impl> entry = (Entry<Class, Impl>) object;\n        builder.put(entry.getKey(), entry.getValue());\n    }\n    return (Map) builder.build();\n}", "repo_id": "5", "comment": "// but here we have to do some serious fudging\n", "repo_name": "guava-master/", "id": 4004, "method_signature": "Map<Class,Impl> create(Object[])", "filename": "ImmutableClassToInstanceMapTest.create.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.add", "method_implementation": "{\n    for (E element : elements) {\n        add(element);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n *\n * <p>Note that each builder class overrides this method in order to covariantly return its own\n * type.\n *\n * @param elements the elements to add\n * @return this {@code Builder} instance\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5905, "method_signature": "Builder<E> add(E[])", "filename": "ImmutableCollection.add.json"}
{"callee_method_names": ["Iterator<? extends E>.hasNext", "Iterator<? extends E>.next"], "method_name": "ImmutableCollection.addAll", "method_implementation": "{\n    while (elements.hasNext()) {\n        add(elements.next());\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n *\n * <p>Note that each builder class overrides this method in order to covariantly return its own\n * type.\n *\n * @param elements the elements to add\n * @return this {@code Builder} instance\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5907, "method_signature": "Builder<E> addAll(Iterator)", "filename": "ImmutableCollection.addAll.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.asList", "method_implementation": "{\n    switch(size()) {\n        case 0:\n            return ImmutableList.of();\n        case 1:\n            return ImmutableList.of(iterator().next());\n        default:\n            return new RegularImmutableAsList<E>(this, toArray());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an {@code ImmutableList} containing the same elements, in the same order, as this\n * collection.\n *\n * <p><b>Performance note:</b> in most cases this method can return quickly without actually\n * copying anything. The exact circumstances under which the copy is performed are undefined and\n * subject to change.\n *\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 2532, "method_signature": "ImmutableList<E> asList()", "filename": "ImmutableCollection.asList.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5903, "method_signature": "void clear()", "filename": "ImmutableCollection.clear.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.copyIntoArray", "method_implementation": "{\n    for (E e : this) {\n        dst[offset++] = e;\n    }\n    return offset;\n}", "repo_id": "5", "comment": "/**\n * Copies the contents of this immutable collection into the specified array at the specified\n * offset. Returns {@code offset + size()}.\n */\n", "repo_name": "guava-master/", "id": 5904, "method_signature": "int copyIntoArray(Object[], int)", "filename": "ImmutableCollection.copyIntoArray.json"}
{"callee_method_names": ["Object[].clone"], "method_name": "ImmutableCollection.getReadyToExpandTo", "method_implementation": "{\n    if (contents.length < minCapacity) {\n        this.contents = Arrays.copyOf(this.contents, expandedCapacity(contents.length, minCapacity));\n        forceCopy = false;\n    } else if (forceCopy) {\n        this.contents = contents.clone();\n        forceCopy = false;\n    }\n}", "repo_id": "5", "comment": "/*\n     * Expand the absolute capacity of the builder so it can accept at least the specified number of\n     * elements without being resized. Also, if we've already built a collection backed by the\n     * current array, create a new array.\n     */\n", "repo_name": "guava-master/", "id": 5908, "method_signature": "void getReadyToExpandTo(int)", "filename": "ImmutableCollection.getReadyToExpandTo.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.internalArray", "method_implementation": "{\n    return null;\n}", "repo_id": "5", "comment": "/**\n * If this collection is backed by an array of its elements in insertion order, returns it.\n */\n", "repo_name": "guava-master/", "id": 5897, "method_signature": "Object[] internalArray()", "filename": "ImmutableCollection.internalArray.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5899, "method_signature": "boolean remove(Object)", "filename": "ImmutableCollection.remove.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.removeAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5901, "method_signature": "boolean removeAll(Collection)", "filename": "ImmutableCollection.removeAll.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.removeIf", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2529, "method_signature": "boolean removeIf(Predicate)", "filename": "ImmutableCollection.removeIf.json"}
{"callee_method_names": [], "method_name": "ImmutableCollection.retainAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5902, "method_signature": "boolean retainAll(Collection)", "filename": "ImmutableCollection.retainAll.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.add", "method_implementation": "{\n    ensureRoomFor(1);\n    array[count] = value;\n    count += 1;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Appends {@code value} to the end of the values the built {@link ImmutableDoubleArray} will\n * contain.\n */\n", "repo_name": "guava-master/", "id": 4496, "method_signature": "Builder add(double)", "filename": "ImmutableDoubleArray.add.json"}
{"callee_method_names": ["ImmutableDoubleArray.length", "ImmutableDoubleArray.length", "ImmutableDoubleArray.length"], "method_name": "ImmutableDoubleArray.addAll", "method_implementation": "{\n    ensureRoomFor(values.length());\n    System.arraycopy(values.array, values.start, array, count, values.length());\n    count += values.length();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Appends {@code values}, in order, to the end of the values the built {@link\n * ImmutableDoubleArray} will contain.\n */\n", "repo_name": "guava-master/", "id": 4500, "method_signature": "Builder addAll(ImmutableDoubleArray)", "filename": "ImmutableDoubleArray.addAll.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.asList", "method_implementation": "{\n    /*\n     * Typically we cache this kind of thing, but much repeated use of this view is a performance\n     * anti-pattern anyway. If we cache, then everyone pays a price in memory footprint even if\n     * they never use this method.\n     */\n    return new AsList(this);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code\n * double} values are boxed into {@link Double} instances on demand, which can be very expensive.\n * The returned list should be used once and discarded. For any usages beyond that, pass the\n * returned list to {@link com.google.common.collect.ImmutableList#copyOf(Collection)\n * ImmutableList.copyOf} and use that list instead.\n */\n", "repo_name": "guava-master/", "id": 4505, "method_signature": "List<Double> asList()", "filename": "ImmutableDoubleArray.asList.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.copyOf", "method_implementation": "{\n    if (values instanceof Collection) {\n        return copyOf((Collection<Double>) values);\n    }\n    return builder().addAll(values).build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable array containing the given values, in order.\n *\n * <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code\n * values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link\n * Builder#addAll(Iterable)}, with all the performance implications associated with that.\n */\n", "repo_name": "guava-master/", "id": 4495, "method_signature": "ImmutableDoubleArray copyOf(Iterable)", "filename": "ImmutableDoubleArray.copyOf.json"}
{"callee_method_names": ["ImmutableDoubleArray.length", "ImmutableDoubleArray.get"], "method_name": "ImmutableDoubleArray.equals", "method_implementation": "{\n    if (object == this) {\n        return true;\n    }\n    if (!(object instanceof ImmutableDoubleArray)) {\n        return false;\n    }\n    ImmutableDoubleArray that = (ImmutableDoubleArray) object;\n    if (this.length() != that.length()) {\n        return false;\n    }\n    for (int i = 0; i < length(); i++) {\n        if (!areEqual(this.get(i), that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code object} is an {@code ImmutableDoubleArray} containing the same\n * values as this one, in the same order. Values are compared as if by {@link Double#equals}.\n */\n", "repo_name": "guava-master/", "id": 4506, "method_signature": "boolean equals(Object)", "filename": "ImmutableDoubleArray.equals.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.expandedCapacity", "method_implementation": "{\n    if (minCapacity < 0) {\n        throw new AssertionError(\"cannot store more than MAX_VALUE elements\");\n    }\n    // careful of overflow!\n    int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;\n    if (newCapacity < minCapacity) {\n        newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;\n    }\n    if (newCapacity < 0) {\n        // guaranteed to be >= newCapacity\n        newCapacity = Integer.MAX_VALUE;\n    }\n    return newCapacity;\n}", "repo_id": "5", "comment": "// Unfortunately this is pasted from ImmutableCollection.Builder.\n", "repo_name": "guava-master/", "id": 4501, "method_signature": "int expandedCapacity(int, int)", "filename": "ImmutableDoubleArray.expandedCapacity.json"}
{"callee_method_names": ["DoubleConsumer.accept"], "method_name": "ImmutableDoubleArray.forEach", "method_implementation": "{\n    checkNotNull(consumer);\n    for (int i = start; i < end; i++) {\n        consumer.accept(array[i]);\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code consumer} for each value contained in this array, in order.\n */\n", "repo_name": "guava-master/", "id": 1066, "method_signature": "void forEach(DoubleConsumer)", "filename": "ImmutableDoubleArray.forEach.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.hashCode", "method_implementation": "{\n    int hash = 1;\n    for (int i = start; i < end; i++) {\n        hash *= 31;\n        hash += Doubles.hashCode(array[i]);\n    }\n    return hash;\n}", "repo_id": "5", "comment": "/**\n * Returns an unspecified hash code for the contents of this immutable array.\n */\n", "repo_name": "guava-master/", "id": 4507, "method_signature": "int hashCode()", "filename": "ImmutableDoubleArray.hashCode.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.indexOf", "method_implementation": "{\n    for (int i = start; i < end; i++) {\n        if (areEqual(array[i], target)) {\n            return i - start;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no\n * such index exists. Values are compared as if by {@link Double#equals}. Equivalent to {@code\n * asList().indexOf(target)}.\n */\n", "repo_name": "guava-master/", "id": 4502, "method_signature": "int indexOf(double)", "filename": "ImmutableDoubleArray.indexOf.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (areEqual(array[i], target)) {\n            return i - start;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no\n * such index exists. Values are compared as if by {@link Double#equals}. Equivalent to {@code\n * asList().lastIndexOf(target)}.\n */\n", "repo_name": "guava-master/", "id": 4503, "method_signature": "int lastIndexOf(double)", "filename": "ImmutableDoubleArray.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.of", "method_implementation": "{\n    checkArgument(rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n    double[] array = new double[rest.length + 1];\n    array[0] = first;\n    System.arraycopy(rest, 0, array, 1, rest.length);\n    return new ImmutableDoubleArray(array);\n}", "repo_id": "5", "comment": "// is okay since we have to copy the just-created array anyway.\n", "repo_name": "guava-master/", "id": 4493, "method_signature": "ImmutableDoubleArray of(double, double[])", "filename": "ImmutableDoubleArray.of.json"}
{"callee_method_names": [], "method_name": "ImmutableDoubleArray.subArray", "method_implementation": "{\n    Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n    return startIndex == endIndex ? EMPTY : new ImmutableDoubleArray(array, start + startIndex, start + endIndex);\n}", "repo_id": "5", "comment": "/**\n * Returns a new immutable array containing the values in the specified range.\n *\n * <p><b>Performance note:</b> The returned array has the same full memory footprint as this one\n * does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,\n * end).trimmed()}.\n */\n", "repo_name": "guava-master/", "id": 4504, "method_signature": "ImmutableDoubleArray subArray(int, int)", "filename": "ImmutableDoubleArray.subArray.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ImmutableDoubleArray.toString", "method_implementation": "{\n    if (isEmpty()) {\n        return \"[]\";\n    }\n    // rough estimate is fine\n    StringBuilder builder = new StringBuilder(length() * 5);\n    builder.append('[').append(array[start]);\n    for (int i = start + 1; i < end; i++) {\n        builder.append(\", \").append(array[i]);\n    }\n    builder.append(']');\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this array in the same form as {@link\n * Arrays#toString(double[])}, for example {@code \"[1, 2, 3]\"}.\n */\n", "repo_name": "guava-master/", "id": 4508, "method_signature": "String toString()", "filename": "ImmutableDoubleArray.toString.json"}
{"callee_method_names": ["Collection<T>.iterator"], "method_name": "ImmutableDoubleArrayTest.iterable", "method_implementation": "{\n    // return collection::iterator;\n    return new Iterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return collection.iterator();\n        }\n    };\n}", "repo_id": "5", "comment": "/*\n   * Whenever an implementation uses `instanceof` on a parameter instance, the test has to know that\n   * (so much for \"black box\") and try instances that both do and don't pass the check. The \"don't\"\n   * half of that is more awkward to arrange...\n   */\n", "repo_name": "guava-master/", "id": 3565, "method_signature": "Iterable<T> iterable(Collection)", "filename": "ImmutableDoubleArrayTest.iterable.json"}
{"callee_method_names": ["Random.nextInt", "AtomicInteger.get", "BuilderOp.doIt", "ImmutableDoubleArray.Builder.build", "ImmutableDoubleArray.length", "ImmutableDoubleArray.get"], "method_name": "ImmutableDoubleArrayTest.testBuilder_bruteForce", "method_implementation": "{\n    for (int i = 0; i < reduceIterationsIfGwt(100); i++) {\n        ImmutableDoubleArray.Builder builder = ImmutableDoubleArray.builder(RANDOM.nextInt(20));\n        AtomicInteger counter = new AtomicInteger(0);\n        while (counter.get() < 1000) {\n            BuilderOp op = BuilderOp.randomOp();\n            op.doIt(builder, counter);\n        }\n        ImmutableDoubleArray iia = builder.build();\n        for (int j = 0; j < iia.length(); j++) {\n            assertThat(iia.get(j)).isEqualTo((double) j);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * If there's a bug in builder growth, we wouldn't know how to expose it. So, brute force the hell\n * out of it for a while and see what happens.\n */\n", "repo_name": "guava-master/", "id": 3564, "method_signature": "void testBuilder_bruteForce()", "filename": "ImmutableDoubleArrayTest.testBuilder_bruteForce.json"}
{"callee_method_ids": [4504, 4504, 4504], "callee_method_names": ["ImmutableDoubleArray.subArray", "ImmutableDoubleArray.subArray", "ImmutableDoubleArray.subArray"], "method_name": "ImmutableDoubleArrayTest.testTrimmed", "method_implementation": "{\n    ImmutableDoubleArray iia = ImmutableDoubleArray.of(0, 1, 3);\n    assertDoesntActuallyTrim(iia);\n    assertDoesntActuallyTrim(iia.subArray(0, 3));\n    assertActuallyTrims(iia.subArray(0, 2));\n    assertActuallyTrims(iia.subArray(1, 3));\n    ImmutableDoubleArray rightSized = ImmutableDoubleArray.builder(3).add(0).add(1).add(3).build();\n    assertDoesntActuallyTrim(rightSized);\n    ImmutableDoubleArray overSized = ImmutableDoubleArray.builder(3).add(0).add(1).build();\n    assertActuallyTrims(overSized);\n    ImmutableDoubleArray underSized = ImmutableDoubleArray.builder(2).add(0).add(1).add(3).build();\n    assertActuallyTrims(underSized);\n}", "repo_id": "5", "comment": "/**\n * This is probably a weird and hacky way to test what we're really trying to test, but hey, it\n * caught a bug.\n */\n", "repo_name": "guava-master/", "id": 3566, "method_signature": "void testTrimmed()", "filename": "ImmutableDoubleArrayTest.testTrimmed.json"}
{"callee_method_names": [], "method_name": "ImmutableEnumMap.writeReplace", "method_implementation": "{\n    return new EnumSerializedForm<>(delegate);\n}", "repo_id": "5", "comment": "// All callers of the constructor are restricted to <K extends Enum<K>>.\n", "repo_name": "guava-master/", "id": 6377, "method_signature": "Object writeReplace()", "filename": "ImmutableEnumMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableEnumSet.writeReplace", "method_implementation": "{\n    return new EnumSerializedForm<E>(delegate);\n}", "repo_id": "5", "comment": "// All callers of the constructor are restricted to <E extends Enum<E>>.\n", "repo_name": "guava-master/", "id": 6001, "method_signature": "Object writeReplace()", "filename": "ImmutableEnumSet.writeReplace.json"}
{"callee_method_names": ["MutableGraph<N>.addNode"], "method_name": "ImmutableGraph.addNode", "method_implementation": "{\n    mutableGraph.addNode(node);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code node} if it is not already present.\n *\n * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.\n *\n * @return this {@code Builder} object\n */\n", "repo_name": "guava-master/", "id": 6779, "method_signature": "Builder<N> addNode(N)", "filename": "ImmutableGraph.addNode.json"}
{"callee_method_names": ["Graph<N>.edges"], "method_name": "ImmutableGraph.copyOf", "method_implementation": "{\n    return (graph instanceof ImmutableGraph) ? (ImmutableGraph<N>) graph : new ImmutableGraph<N>(new StandardValueGraph<N, Presence>(GraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size()));\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable copy of {@code graph}.\n */\n", "repo_name": "guava-master/", "id": 6778, "method_signature": "ImmutableGraph<N> copyOf(Graph)", "filename": "ImmutableGraph.copyOf.json"}
{"callee_method_names": ["MutableGraph<N>.putEdge"], "method_name": "ImmutableGraph.putEdge", "method_implementation": "{\n    mutableGraph.putEdge(endpoints);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds an edge connecting {@code endpoints} (in the order, if any, specified by {@code\n * endpoints}) if one is not already present.\n *\n * <p>If this graph is directed, {@code endpoints} must be ordered and the added edge will be\n * directed; if it is undirected, the added edge will be undirected.\n *\n * <p>If this graph is directed, {@code endpoints} must be ordered.\n *\n * <p>If either or both endpoints are not already present in this graph, this method will\n * silently {@link #addNode(Object) add} each missing endpoint to the graph.\n *\n * @return this {@code Builder} object\n * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n *     #allowsSelfLoops()}\n * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n */\n", "repo_name": "guava-master/", "id": 6781, "method_signature": "Builder<N> putEdge(EndpointPair)", "filename": "ImmutableGraph.putEdge.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.add", "method_implementation": "{\n    ensureRoomFor(1);\n    array[count] = value;\n    count += 1;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Appends {@code value} to the end of the values the built {@link ImmutableIntArray} will\n * contain.\n */\n", "repo_name": "guava-master/", "id": 4370, "method_signature": "Builder add(int)", "filename": "ImmutableIntArray.add.json"}
{"callee_method_names": ["ImmutableIntArray.length", "ImmutableIntArray.length", "ImmutableIntArray.length"], "method_name": "ImmutableIntArray.addAll", "method_implementation": "{\n    ensureRoomFor(values.length());\n    System.arraycopy(values.array, values.start, array, count, values.length());\n    count += values.length();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Appends {@code values}, in order, to the end of the values the built {@link\n * ImmutableIntArray} will contain.\n */\n", "repo_name": "guava-master/", "id": 4374, "method_signature": "Builder addAll(ImmutableIntArray)", "filename": "ImmutableIntArray.addAll.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.asList", "method_implementation": "{\n    /*\n     * Typically we cache this kind of thing, but much repeated use of this view is a performance\n     * anti-pattern anyway. If we cache, then everyone pays a price in memory footprint even if\n     * they never use this method.\n     */\n    return new AsList(this);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code\n * int} values are boxed into {@link Integer} instances on demand, which can be very expensive.\n * The returned list should be used once and discarded. For any usages beyond that, pass the\n * returned list to {@link com.google.common.collect.ImmutableList#copyOf(Collection)\n * ImmutableList.copyOf} and use that list instead.\n */\n", "repo_name": "guava-master/", "id": 4379, "method_signature": "List<Integer> asList()", "filename": "ImmutableIntArray.asList.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.copyOf", "method_implementation": "{\n    if (values instanceof Collection) {\n        return copyOf((Collection<Integer>) values);\n    }\n    return builder().addAll(values).build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable array containing the given values, in order.\n *\n * <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code\n * values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link\n * Builder#addAll(Iterable)}, with all the performance implications associated with that.\n */\n", "repo_name": "guava-master/", "id": 4369, "method_signature": "ImmutableIntArray copyOf(Iterable)", "filename": "ImmutableIntArray.copyOf.json"}
{"callee_method_names": ["ImmutableIntArray.length", "ImmutableIntArray.get"], "method_name": "ImmutableIntArray.equals", "method_implementation": "{\n    if (object == this) {\n        return true;\n    }\n    if (!(object instanceof ImmutableIntArray)) {\n        return false;\n    }\n    ImmutableIntArray that = (ImmutableIntArray) object;\n    if (this.length() != that.length()) {\n        return false;\n    }\n    for (int i = 0; i < length(); i++) {\n        if (this.get(i) != that.get(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code object} is an {@code ImmutableIntArray} containing the same\n * values as this one, in the same order.\n */\n", "repo_name": "guava-master/", "id": 4380, "method_signature": "boolean equals(Object)", "filename": "ImmutableIntArray.equals.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.expandedCapacity", "method_implementation": "{\n    if (minCapacity < 0) {\n        throw new AssertionError(\"cannot store more than MAX_VALUE elements\");\n    }\n    // careful of overflow!\n    int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;\n    if (newCapacity < minCapacity) {\n        newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;\n    }\n    if (newCapacity < 0) {\n        // guaranteed to be >= newCapacity\n        newCapacity = Integer.MAX_VALUE;\n    }\n    return newCapacity;\n}", "repo_id": "5", "comment": "// Unfortunately this is pasted from ImmutableCollection.Builder.\n", "repo_name": "guava-master/", "id": 4375, "method_signature": "int expandedCapacity(int, int)", "filename": "ImmutableIntArray.expandedCapacity.json"}
{"callee_method_names": ["IntConsumer.accept"], "method_name": "ImmutableIntArray.forEach", "method_implementation": "{\n    checkNotNull(consumer);\n    for (int i = start; i < end; i++) {\n        consumer.accept(array[i]);\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code consumer} for each value contained in this array, in order.\n */\n", "repo_name": "guava-master/", "id": 932, "method_signature": "void forEach(IntConsumer)", "filename": "ImmutableIntArray.forEach.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.hashCode", "method_implementation": "{\n    int hash = 1;\n    for (int i = start; i < end; i++) {\n        hash *= 31;\n        hash += Ints.hashCode(array[i]);\n    }\n    return hash;\n}", "repo_id": "5", "comment": "/**\n * Returns an unspecified hash code for the contents of this immutable array.\n */\n", "repo_name": "guava-master/", "id": 4381, "method_signature": "int hashCode()", "filename": "ImmutableIntArray.hashCode.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.indexOf", "method_implementation": "{\n    for (int i = start; i < end; i++) {\n        if (array[i] == target) {\n            return i - start;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no\n * such index exists. Equivalent to {@code asList().indexOf(target)}.\n */\n", "repo_name": "guava-master/", "id": 4376, "method_signature": "int indexOf(int)", "filename": "ImmutableIntArray.indexOf.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i - start;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no\n * such index exists. Equivalent to {@code asList().lastIndexOf(target)}.\n */\n", "repo_name": "guava-master/", "id": 4377, "method_signature": "int lastIndexOf(int)", "filename": "ImmutableIntArray.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.of", "method_implementation": "{\n    checkArgument(rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n    int[] array = new int[rest.length + 1];\n    array[0] = first;\n    System.arraycopy(rest, 0, array, 1, rest.length);\n    return new ImmutableIntArray(array);\n}", "repo_id": "5", "comment": "// okay since we have to copy the just-created array anyway.\n", "repo_name": "guava-master/", "id": 4368, "method_signature": "ImmutableIntArray of(int, int[])", "filename": "ImmutableIntArray.of.json"}
{"callee_method_names": [], "method_name": "ImmutableIntArray.subArray", "method_implementation": "{\n    Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n    return startIndex == endIndex ? EMPTY : new ImmutableIntArray(array, start + startIndex, start + endIndex);\n}", "repo_id": "5", "comment": "/**\n * Returns a new immutable array containing the values in the specified range.\n *\n * <p><b>Performance note:</b> The returned array has the same full memory footprint as this one\n * does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,\n * end).trimmed()}.\n */\n", "repo_name": "guava-master/", "id": 4378, "method_signature": "ImmutableIntArray subArray(int, int)", "filename": "ImmutableIntArray.subArray.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ImmutableIntArray.toString", "method_implementation": "{\n    if (isEmpty()) {\n        return \"[]\";\n    }\n    // rough estimate is fine\n    StringBuilder builder = new StringBuilder(length() * 5);\n    builder.append('[').append(array[start]);\n    for (int i = start + 1; i < end; i++) {\n        builder.append(\", \").append(array[i]);\n    }\n    builder.append(']');\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this array in the same form as {@link\n * Arrays#toString(int[])}, for example {@code \"[1, 2, 3]\"}.\n */\n", "repo_name": "guava-master/", "id": 4382, "method_signature": "String toString()", "filename": "ImmutableIntArray.toString.json"}
{"callee_method_names": ["Collection<T>.iterator"], "method_name": "ImmutableIntArrayTest.iterable", "method_implementation": "{\n    // return collection::iterator;\n    return new Iterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return collection.iterator();\n        }\n    };\n}", "repo_id": "5", "comment": "/*\n   * Whenever an implementation uses `instanceof` on a parameter instance, the test has to know that\n   * (so much for \"black box\") and try instances that both do and don't pass the check. The \"don't\"\n   * half of that is more awkward to arrange...\n   */\n", "repo_name": "guava-master/", "id": 3556, "method_signature": "Iterable<T> iterable(Collection)", "filename": "ImmutableIntArrayTest.iterable.json"}
{"callee_method_names": ["Random.nextInt", "AtomicInteger.get", "BuilderOp.doIt", "ImmutableIntArray.Builder.build", "ImmutableIntArray.length", "ImmutableIntArray.get"], "method_name": "ImmutableIntArrayTest.testBuilder_bruteForce", "method_implementation": "{\n    for (int i = 0; i < reduceIterationsIfGwt(100); i++) {\n        ImmutableIntArray.Builder builder = ImmutableIntArray.builder(RANDOM.nextInt(20));\n        AtomicInteger counter = new AtomicInteger(0);\n        while (counter.get() < 1000) {\n            BuilderOp op = BuilderOp.randomOp();\n            op.doIt(builder, counter);\n        }\n        ImmutableIntArray iia = builder.build();\n        for (int j = 0; j < iia.length(); j++) {\n            assertThat(iia.get(j)).isEqualTo(j);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * If there's a bug in builder growth, we wouldn't know how to expose it. So, brute force the hell\n * out of it for a while and see what happens.\n */\n", "repo_name": "guava-master/", "id": 3555, "method_signature": "void testBuilder_bruteForce()", "filename": "ImmutableIntArrayTest.testBuilder_bruteForce.json"}
{"callee_method_ids": [4378, 4378, 4378], "callee_method_names": ["ImmutableIntArray.subArray", "ImmutableIntArray.subArray", "ImmutableIntArray.subArray"], "method_name": "ImmutableIntArrayTest.testTrimmed", "method_implementation": "{\n    ImmutableIntArray iia = ImmutableIntArray.of(0, 1, 3);\n    assertDoesntActuallyTrim(iia);\n    assertDoesntActuallyTrim(iia.subArray(0, 3));\n    assertActuallyTrims(iia.subArray(0, 2));\n    assertActuallyTrims(iia.subArray(1, 3));\n    ImmutableIntArray rightSized = ImmutableIntArray.builder(3).add(0).add(1).add(3).build();\n    assertDoesntActuallyTrim(rightSized);\n    ImmutableIntArray overSized = ImmutableIntArray.builder(3).add(0).add(1).build();\n    assertActuallyTrims(overSized);\n    ImmutableIntArray underSized = ImmutableIntArray.builder(2).add(0).add(1).add(3).build();\n    assertActuallyTrims(underSized);\n}", "repo_id": "5", "comment": "/**\n * This is probably a weird and hacky way to test what we're really trying to test, but hey, it\n * caught a bug.\n */\n", "repo_name": "guava-master/", "id": 3557, "method_signature": "void testTrimmed()", "filename": "ImmutableIntArrayTest.testTrimmed.json"}
{"callee_method_names": [], "method_name": "ImmutableList.add", "method_implementation": "{\n    super.add(elements);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableList}.\n *\n * @param elements the {@code Iterable} to add to the {@code ImmutableList}\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5736, "method_signature": "Builder<E> add(E[])", "filename": "ImmutableList.add.json"}
{"callee_method_names": [], "method_name": "ImmutableList.addAll", "method_implementation": "{\n    super.addAll(elements);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableList}.\n *\n * @param elements the {@code Iterator} to add to the {@code ImmutableList}\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5738, "method_signature": "Builder<E> addAll(Iterator)", "filename": "ImmutableList.addAll.json"}
{"callee_method_names": [], "method_name": "ImmutableList.asImmutableList", "method_implementation": "{\n    if (length == 0) {\n        return of();\n    }\n    return new RegularImmutableList<E>(elements, length);\n}", "repo_id": "5", "comment": "/**\n * Views the array as an immutable list. Does not check for nulls.\n */\n", "repo_name": "guava-master/", "id": 5726, "method_signature": "ImmutableList<E> asImmutableList(Object[], int)", "filename": "ImmutableList.asImmutableList.json"}
{"callee_method_names": [], "method_name": "ImmutableList.asList", "method_implementation": "{\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Returns this list instance.\n *\n * @since 2.0\n * @deprecated There is no reason to use this; it always returns {@code this}.\n */\n", "repo_name": "guava-master/", "id": 5733, "method_signature": "ImmutableList<E> asList()", "filename": "ImmutableList.asList.json"}
{"callee_method_names": [], "method_name": "ImmutableList.build", "method_implementation": "{\n    forceCopy = true;\n    return asImmutableList(contents, size);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created {@code ImmutableList} based on the contents of the {@code Builder}.\n */\n", "repo_name": "guava-master/", "id": 5739, "method_signature": "ImmutableList<E> build()", "filename": "ImmutableList.build.json"}
{"callee_method_names": ["E[].clone"], "method_name": "ImmutableList.copyOf", "method_implementation": "{\n    return (elements.length == 0) ? ImmutableList.<E>of() : ImmutableList.<E>construct(elements.clone());\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable list containing the given elements, in order.\n *\n * @throws NullPointerException if {@code elements} contains a null element\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 5723, "method_signature": "ImmutableList<E> copyOf(E[])", "filename": "ImmutableList.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableList.of", "method_implementation": "{\n    checkArgument(others.length <= Integer.MAX_VALUE - 12, \"the total number of elements must fit in an int\");\n    Object[] array = new Object[12 + others.length];\n    array[0] = e1;\n    array[1] = e2;\n    array[2] = e3;\n    array[3] = e4;\n    array[4] = e5;\n    array[5] = e6;\n    array[6] = e7;\n    array[7] = e8;\n    array[8] = e9;\n    array[9] = e10;\n    array[10] = e11;\n    array[11] = e12;\n    System.arraycopy(others, 0, array, 12, others.length);\n    return construct(array);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable list containing the given elements, in order.\n *\n * <p>The array {@code others} must not be longer than {@code Integer.MAX_VALUE - 12}.\n *\n * @throws NullPointerException if any element is null\n * @since 3.0 (source-compatible since 2.0)\n */\n", "repo_name": "guava-master/", "id": 5719, "method_signature": "ImmutableList<E> of(E, E, E, E, E, E, E, E, E, E, E, E, E[])", "filename": "ImmutableList.of.json"}
{"callee_method_names": [], "method_name": "ImmutableList.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the list unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5732, "method_signature": "E remove(int)", "filename": "ImmutableList.remove.json"}
{"callee_method_names": [], "method_name": "ImmutableList.replaceAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the list unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2351, "method_signature": "void replaceAll(UnaryOperator)", "filename": "ImmutableList.replaceAll.json"}
{"callee_method_names": [], "method_name": "ImmutableList.set", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the list unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5730, "method_signature": "E set(int, E)", "filename": "ImmutableList.set.json"}
{"callee_method_names": [], "method_name": "ImmutableList.sort", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the list unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2352, "method_signature": "void sort(Comparator)", "filename": "ImmutableList.sort.json"}
{"callee_method_names": [], "method_name": "ImmutableList.sortedCopyOf", "method_implementation": "{\n    checkNotNull(comparator);\n    // all supported methods are covariant\n    @SuppressWarnings(\"unchecked\")\n    E[] array = (E[]) Iterables.toArray(elements);\n    checkElementsNotNull(array);\n    Arrays.sort(array, comparator);\n    return asImmutableList(array);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable list containing the given elements, in sorted order relative to the\n * specified comparator. The sorting algorithm used is stable, so elements that compare as equal\n * will stay in the order in which they appear in the input.\n *\n * <p>If your data has no duplicates, or you wish to deduplicate elements, use {@code\n * ImmutableSortedSet.copyOf(comparator, elements)}; if you want a {@code List} you can use its\n * {@code asList()} view.\n *\n * <p><b>Java 8 users:</b> If you want to convert a {@link java.util.stream.Stream} to a sorted\n * {@code ImmutableList}, use {@code stream.sorted(comparator).collect(toImmutableList())}.\n *\n * @throws NullPointerException if any element in the input is null\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 5725, "method_signature": "ImmutableList<E> sortedCopyOf(Comparator, Iterable)", "filename": "ImmutableList.sortedCopyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableList.subList", "method_implementation": "{\n    checkPositionIndexes(fromIndex, toIndex, size());\n    int length = toIndex - fromIndex;\n    if (length == size()) {\n        return this;\n    } else if (length == 0) {\n        return of();\n    } else {\n        return subListUnchecked(fromIndex, toIndex);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable list of the elements between the specified {@code fromIndex}, inclusive,\n * and {@code toIndex}, exclusive. (If {@code fromIndex} and {@code toIndex} are equal, the empty\n * immutable list is returned.)\n *\n * <p><b>Note:</b> in almost all circumstances, the returned {@link ImmutableList} retains a\n * strong reference to {@code this}, which may prevent the original list from being garbage\n * collected. If you want the original list to be eligible for garbage collection, you should\n * create and use a copy of the sub list (e.g., {@code\n * ImmutableList.copyOf(originalList.subList(...))}).\n */\n", "repo_name": "guava-master/", "id": 5727, "method_signature": "ImmutableList<E> subList(int, int)", "filename": "ImmutableList.subList.json"}
{"callee_method_names": [], "method_name": "ImmutableList.toImmutableList", "method_implementation": "{\n    return CollectCollectors.toImmutableList();\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates the input elements into a new {@code\n * ImmutableList}, in encounter order.\n */\n", "repo_name": "guava-master/", "id": 5718, "method_signature": "Collector<E,?,ImmutableList<E>> toImmutableList()", "filename": "ImmutableList.toImmutableList.json"}
{"callee_method_names": ["List<? extends E>.size", "List<? extends E>.get"], "method_name": "ImmutableList.unsafeDelegateList", "method_implementation": "{\n    switch(list.size()) {\n        case 0:\n            return of();\n        case 1:\n            return of(list.get(0));\n        default:\n            @SuppressWarnings(\"unchecked\")\n            List<E> castedList = (List<E>) list;\n            return new RegularImmutableList<E>(castedList);\n    }\n}", "repo_id": "5", "comment": "// are guaranteed to be non-null.\n", "repo_name": "guava-master/", "id": 6819, "method_signature": "ImmutableList<E> unsafeDelegateList(List)", "filename": "ImmutableList.unsafeDelegateList.json"}
{"callee_method_names": [], "method_name": "ImmutableList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5734, "method_signature": "Object writeReplace()", "filename": "ImmutableList.writeReplace.json"}
{"callee_method_names": ["Iterable<ListFrobber>.iterator", "Set<List<Integer>>.add", "Iterator<ListFrobber>.next", "Set<List<Integer>>.add"], "method_name": "ImmutableListCopyOfConcurrentlyModifiedInputTest.newConcurrentlyMutatedList", "method_implementation": "{\n    InvocationHandler invocationHandler = new InvocationHandler() {\n\n        final CopyOnWriteArrayList<Integer> delegate = new CopyOnWriteArrayList<>(initialContents);\n\n        final Method getAllStatesMethod = getOnlyElement(asList(ConcurrentlyMutatedList.class.getDeclaredMethods()));\n\n        final Iterator<ListFrobber> remainingActions = actionsToPerformConcurrently.iterator();\n\n        final Set<List<Integer>> allStates = newHashSet();\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            return method.equals(getAllStatesMethod) ? getAllStates() : invokeListMethod(method, args);\n        }\n\n        private Set<List<Integer>> getAllStates() {\n            return allStates;\n        }\n\n        private Object invokeListMethod(Method method, Object[] args) throws Throwable {\n            try {\n                Object returnValue = method.invoke(delegate, args);\n                mutateDelegate();\n                return returnValue;\n            } catch (InvocationTargetException e) {\n                throw e.getCause();\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            }\n        }\n\n        private void mutateDelegate() {\n            allStates.add(ImmutableList.copyOf(delegate));\n            remainingActions.next().perform(delegate);\n            allStates.add(ImmutableList.copyOf(delegate));\n        }\n    };\n    @SuppressWarnings(\"unchecked\")\n    ConcurrentlyMutatedList<Integer> list = (ConcurrentlyMutatedList<Integer>) newProxyInstance(ImmutableListCopyOfConcurrentlyModifiedInputTest.class.getClassLoader(), new Class[] { ConcurrentlyMutatedList.class }, invocationHandler);\n    return list;\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link ConcurrentlyMutatedList} that performs the given operations as its concurrent\n * modifications. The mutations occur in the same thread as the triggering method call.\n */\n", "repo_name": "guava-master/", "id": 3991, "method_signature": "ConcurrentlyMutatedList<Integer> newConcurrentlyMutatedList(Collection, Iterable)", "filename": "ImmutableListCopyOfConcurrentlyModifiedInputTest.newConcurrentlyMutatedList.json"}
{"callee_method_names": ["Multimap<? extends K,? extends V>.isEmpty", "ImmutableListMultimap<K, V>.isPartialView", "Multimap<? extends K,? extends V>.asMap"], "method_name": "ImmutableListMultimap.copyOf", "method_implementation": "{\n    if (multimap.isEmpty()) {\n        return of();\n    }\n    // TODO(lowasser): copy ImmutableSetMultimap by using asList() on the sets\n    if (multimap instanceof ImmutableListMultimap) {\n        // safe since multimap is not writable\n        @SuppressWarnings(\"unchecked\")\n        ImmutableListMultimap<K, V> kvMultimap = (ImmutableListMultimap<K, V>) multimap;\n        if (!kvMultimap.isPartialView()) {\n            return kvMultimap;\n        }\n    }\n    return fromMapEntries(multimap.asMap().entrySet(), null);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable multimap containing the same mappings as {@code multimap}. The generated\n * multimap's key and value orderings correspond to the iteration ordering of the {@code\n * multimap.asMap()} view.\n *\n * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n * safe to do so. The exact circumstances under which a copy will or will not be performed are\n * undocumented and subject to change.\n *\n * @throws NullPointerException if any key or value in {@code multimap} is null\n */\n", "repo_name": "guava-master/", "id": 6389, "method_signature": "ImmutableListMultimap<K,V> copyOf(Multimap)", "filename": "ImmutableListMultimap.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.flatteningToImmutableListMultimap", "method_implementation": "{\n    return CollectCollectors.flatteningToImmutableListMultimap(keyFunction, valuesFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} accumulating entries into an {@code ImmutableListMultimap}. Each\n * input element is mapped to a key and a stream of values, each of which are put into the\n * resulting {@code Multimap}, in the encounter order of the stream and the encounter order of the\n * streams of values.\n *\n * <p>Example:\n *\n * <pre>{@code\n * static final ImmutableListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n *         .collect(\n *             flatteningToImmutableListMultimap(\n *                  str -> str.charAt(0),\n *                  str -> str.substring(1).chars().mapToObj(c -> (char) c));\n *\n * // is equivalent to\n *\n * static final ImmutableListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n *     ImmutableListMultimap.<Character, Character>builder()\n *         .putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'))\n *         .putAll('a', Arrays.asList('p', 'p', 'l', 'e'))\n *         .putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'))\n *         .putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'))\n *         .putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'))\n *         .build();\n * }\n * }</pre>\n */\n", "repo_name": "guava-master/", "id": 6379, "method_signature": "Collector<T,?,ImmutableListMultimap<K,V>> flatteningToImmutableListMultimap(Function, Function)", "filename": "ImmutableListMultimap.flatteningToImmutableListMultimap.json"}
{"callee_method_names": ["Collection<? extends Map.Entry<? extends K,? extends Collection<? extends V>>>.isEmpty", "Collection<? extends Map.Entry<? extends K,? extends Collection<? extends V>>>.size", "Entry<? extends K,? extends V>.getKey", "Entry<? extends K,? extends V>.getValue", "ImmutableList<V>.isEmpty", "ImmutableMap.Builder<K, ImmutableList<V>>.put", "ImmutableList<V>.size", "ImmutableMap.Builder<K, ImmutableList<V>>.buildOrThrow"], "method_name": "ImmutableListMultimap.fromMapEntries", "method_implementation": "{\n    if (mapEntries.isEmpty()) {\n        return of();\n    }\n    ImmutableMap.Builder<K, ImmutableList<V>> builder = new ImmutableMap.Builder<>(mapEntries.size());\n    int size = 0;\n    for (Entry<? extends K, ? extends Collection<? extends V>> entry : mapEntries) {\n        K key = entry.getKey();\n        Collection<? extends V> values = entry.getValue();\n        ImmutableList<V> list = (valueComparator == null) ? ImmutableList.copyOf(values) : ImmutableList.sortedCopyOf(valueComparator, values);\n        if (!list.isEmpty()) {\n            builder.put(key, list);\n            size += list.size();\n        }\n    }\n    return new ImmutableListMultimap<>(builder.buildOrThrow(), size);\n}", "repo_id": "5", "comment": "/**\n * Creates an ImmutableListMultimap from an asMap.entrySet.\n */\n", "repo_name": "guava-master/", "id": 6390, "method_signature": "ImmutableListMultimap<K,V> fromMapEntries(Collection, Comparator)", "filename": "ImmutableListMultimap.fromMapEntries.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.get", "method_implementation": "{\n    // This cast is safe as its type is known in constructor.\n    ImmutableList<V> list = (ImmutableList<V>) map.get(key);\n    return (list == null) ? ImmutableList.<V>of() : list;\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable list of the values for the given key. If no mappings in the multimap have\n * the provided key, an empty immutable list is returned. The values are in the same order as the\n * parameters used to build this multimap.\n */\n", "repo_name": "guava-master/", "id": 6391, "method_signature": "ImmutableList<V> get(K)", "filename": "ImmutableListMultimap.get.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.inverse", "method_implementation": "{\n    ImmutableListMultimap<V, K> result = inverse;\n    return (result == null) ? (inverse = invert()) : result;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Because an inverse of a list multimap can contain multiple pairs with the same key and\n * value, this method returns an {@code ImmutableListMultimap} rather than the {@code\n * ImmutableMultimap} specified in the {@code ImmutableMultimap} class.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 6392, "method_signature": "ImmutableListMultimap<V,K> inverse()", "filename": "ImmutableListMultimap.inverse.json"}
{"callee_method_names": ["ImmutableListMultimap.Builder<K, V>.put", "ImmutableListMultimap.Builder<K, V>.put", "ImmutableListMultimap.Builder<K, V>.put", "ImmutableListMultimap.Builder<K, V>.put", "ImmutableListMultimap.Builder<K, V>.put", "ImmutableListMultimap.Builder<K, V>.build"], "method_name": "ImmutableListMultimap.of", "method_implementation": "{\n    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n    builder.put(k1, v1);\n    builder.put(k2, v2);\n    builder.put(k3, v3);\n    builder.put(k4, v4);\n    builder.put(k5, v5);\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable multimap containing the given entries, in order.\n */\n", "repo_name": "guava-master/", "id": 6384, "method_signature": "ImmutableListMultimap<K,V> of(K, V, K, V, K, V, K, V, K, V)", "filename": "ImmutableListMultimap.of.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.orderKeysBy", "method_implementation": "{\n    super.orderKeysBy(keyComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6387, "method_signature": "Builder<K,V> orderKeysBy(Comparator)", "filename": "ImmutableListMultimap.orderKeysBy.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.orderValuesBy", "method_implementation": "{\n    super.orderValuesBy(valueComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6388, "method_signature": "Builder<K,V> orderValuesBy(Comparator)", "filename": "ImmutableListMultimap.orderValuesBy.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.put", "method_implementation": "{\n    super.put(entry);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 6385, "method_signature": "Builder<K,V> put(Entry)", "filename": "ImmutableListMultimap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.putAll", "method_implementation": "{\n    super.putAll(entries);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6386, "method_signature": "Builder<K,V> putAll(Iterable)", "filename": "ImmutableListMultimap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.removeAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6393, "method_signature": "ImmutableList<V> removeAll(Object)", "filename": "ImmutableListMultimap.removeAll.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.replaceValues", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6394, "method_signature": "ImmutableList<V> replaceValues(K, Iterable)", "filename": "ImmutableListMultimap.replaceValues.json"}
{"callee_method_names": [], "method_name": "ImmutableListMultimap.toImmutableListMultimap", "method_implementation": "{\n    return CollectCollectors.toImmutableListMultimap(keyFunction, valueFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} that accumulates elements into an {@code ImmutableListMultimap}\n * whose keys and values are the result of applying the provided mapping functions to the input\n * elements.\n *\n * <p>For streams with defined encounter order (as defined in the Ordering section of the {@link\n * java.util.stream} Javadoc), that order is preserved, but entries are <a\n * href=\"ImmutableMultimap.html#iteration\">grouped by key</a>.\n *\n * <p>Example:\n *\n * <pre>{@code\n * static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n *         .collect(toImmutableListMultimap(str -> str.charAt(0), str -> str.substring(1)));\n *\n * // is equivalent to\n *\n * static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n *     new ImmutableListMultimap.Builder<Character, String>()\n *         .put('b', \"anana\")\n *         .putAll('a', \"pple\", \"sparagus\")\n *         .putAll('c', \"arrot\", \"herry\")\n *         .build();\n * }</pre>\n */\n", "repo_name": "guava-master/", "id": 6378, "method_signature": "Collector<T,?,ImmutableListMultimap<K,V>> toImmutableListMultimap(Function, Function)", "filename": "ImmutableListMultimap.toImmutableListMultimap.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject"], "method_name": "ImmutableListMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    Serialization.writeMultimap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData number of distinct keys, and then for each distinct key: the key, the number of\n *     values for that key, and the key's values\n */\n", "repo_name": "guava-master/", "id": 6395, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "ImmutableListMultimap.writeObject.json"}
{"callee_method_names": ["ImmutableListMultimap.Builder<String, Integer>.combine", "ImmutableListMultimap<String, Integer>.keySet", "ImmutableListMultimap<String, Integer>.values", "ImmutableListMultimap<String, Integer>.get", "ImmutableListMultimap<String, Integer>.get", "ImmutableListMultimap<String, Integer>.get"], "method_name": "ImmutableListMultimapTest.testToImmutableListMultimap_java7_combine", "method_implementation": "{\n    ImmutableListMultimap.Builder<String, Integer> zis = ImmutableListMultimap.<String, Integer>builder().put(\"a\", 1).put(\"b\", 2);\n    ImmutableListMultimap.Builder<String, Integer> zat = ImmutableListMultimap.<String, Integer>builder().put(\"a\", 3).put(\"c\", 4);\n    ImmutableListMultimap<String, Integer> multimap = zis.combine(zat).build();\n    assertThat(multimap.keySet()).containsExactly(\"a\", \"b\", \"c\").inOrder();\n    assertThat(multimap.values()).containsExactly(1, 3, 2, 4).inOrder();\n    assertThat(multimap.get(\"a\")).containsExactly(1, 3).inOrder();\n    assertThat(multimap.get(\"b\")).containsExactly(2);\n    assertThat(multimap.get(\"c\")).containsExactly(4);\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableListMultimap once CollectorTester is usable.\n", "repo_name": "guava-master/", "id": 4029, "method_signature": "void testToImmutableListMultimap_java7_combine()", "filename": "ImmutableListMultimapTest.testToImmutableListMultimap_java7_combine.json"}
{"callee_method_names": ["ImmutableList.Builder<String>.combine"], "method_name": "ImmutableListTest.testToImmutableList_java7_combine", "method_implementation": "{\n    ImmutableList.Builder<String> zis = ImmutableList.<String>builder().add(\"a\", \"b\");\n    ImmutableList.Builder<String> zat = ImmutableList.<String>builder().add(\"c\", \"d\");\n    ImmutableList<String> list = zis.combine(zat).build();\n    assertEquals(asList(\"a\", \"b\", \"c\", \"d\"), list);\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableList once CollectorTester is usable to java7.\n", "repo_name": "guava-master/", "id": 3973, "method_signature": "void testToImmutableList_java7_combine()", "filename": "ImmutableListTest.testToImmutableList_java7_combine.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.add", "method_implementation": "{\n    ensureRoomFor(1);\n    array[count] = value;\n    count += 1;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Appends {@code value} to the end of the values the built {@link ImmutableLongArray} will\n * contain.\n */\n", "repo_name": "guava-master/", "id": 4458, "method_signature": "Builder add(long)", "filename": "ImmutableLongArray.add.json"}
{"callee_method_names": ["ImmutableLongArray.length", "ImmutableLongArray.length", "ImmutableLongArray.length"], "method_name": "ImmutableLongArray.addAll", "method_implementation": "{\n    ensureRoomFor(values.length());\n    System.arraycopy(values.array, values.start, array, count, values.length());\n    count += values.length();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Appends {@code values}, in order, to the end of the values the built {@link\n * ImmutableLongArray} will contain.\n */\n", "repo_name": "guava-master/", "id": 4462, "method_signature": "Builder addAll(ImmutableLongArray)", "filename": "ImmutableLongArray.addAll.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.asList", "method_implementation": "{\n    /*\n     * Typically we cache this kind of thing, but much repeated use of this view is a performance\n     * anti-pattern anyway. If we cache, then everyone pays a price in memory footprint even if\n     * they never use this method.\n     */\n    return new AsList(this);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code\n * long} values are boxed into {@link Long} instances on demand, which can be very expensive. The\n * returned list should be used once and discarded. For any usages beyond that, pass the returned\n * list to {@link com.google.common.collect.ImmutableList#copyOf(Collection) ImmutableList.copyOf}\n * and use that list instead.\n */\n", "repo_name": "guava-master/", "id": 4467, "method_signature": "List<Long> asList()", "filename": "ImmutableLongArray.asList.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.copyOf", "method_implementation": "{\n    if (values instanceof Collection) {\n        return copyOf((Collection<Long>) values);\n    }\n    return builder().addAll(values).build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable array containing the given values, in order.\n *\n * <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code\n * values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link\n * Builder#addAll(Iterable)}, with all the performance implications associated with that.\n */\n", "repo_name": "guava-master/", "id": 4457, "method_signature": "ImmutableLongArray copyOf(Iterable)", "filename": "ImmutableLongArray.copyOf.json"}
{"callee_method_names": ["ImmutableLongArray.length", "ImmutableLongArray.get"], "method_name": "ImmutableLongArray.equals", "method_implementation": "{\n    if (object == this) {\n        return true;\n    }\n    if (!(object instanceof ImmutableLongArray)) {\n        return false;\n    }\n    ImmutableLongArray that = (ImmutableLongArray) object;\n    if (this.length() != that.length()) {\n        return false;\n    }\n    for (int i = 0; i < length(); i++) {\n        if (this.get(i) != that.get(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code object} is an {@code ImmutableLongArray} containing the same\n * values as this one, in the same order.\n */\n", "repo_name": "guava-master/", "id": 4468, "method_signature": "boolean equals(Object)", "filename": "ImmutableLongArray.equals.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.expandedCapacity", "method_implementation": "{\n    if (minCapacity < 0) {\n        throw new AssertionError(\"cannot store more than MAX_VALUE elements\");\n    }\n    // careful of overflow!\n    int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;\n    if (newCapacity < minCapacity) {\n        newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;\n    }\n    if (newCapacity < 0) {\n        // guaranteed to be >= newCapacity\n        newCapacity = Integer.MAX_VALUE;\n    }\n    return newCapacity;\n}", "repo_id": "5", "comment": "// Unfortunately this is pasted from ImmutableCollection.Builder.\n", "repo_name": "guava-master/", "id": 4463, "method_signature": "int expandedCapacity(int, int)", "filename": "ImmutableLongArray.expandedCapacity.json"}
{"callee_method_names": ["LongConsumer.accept"], "method_name": "ImmutableLongArray.forEach", "method_implementation": "{\n    checkNotNull(consumer);\n    for (int i = start; i < end; i++) {\n        consumer.accept(array[i]);\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code consumer} for each value contained in this array, in order.\n */\n", "repo_name": "guava-master/", "id": 1024, "method_signature": "void forEach(LongConsumer)", "filename": "ImmutableLongArray.forEach.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.hashCode", "method_implementation": "{\n    int hash = 1;\n    for (int i = start; i < end; i++) {\n        hash *= 31;\n        hash += Longs.hashCode(array[i]);\n    }\n    return hash;\n}", "repo_id": "5", "comment": "/**\n * Returns an unspecified hash code for the contents of this immutable array.\n */\n", "repo_name": "guava-master/", "id": 4469, "method_signature": "int hashCode()", "filename": "ImmutableLongArray.hashCode.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.indexOf", "method_implementation": "{\n    for (int i = start; i < end; i++) {\n        if (array[i] == target) {\n            return i - start;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no\n * such index exists. Equivalent to {@code asList().indexOf(target)}.\n */\n", "repo_name": "guava-master/", "id": 4464, "method_signature": "int indexOf(long)", "filename": "ImmutableLongArray.indexOf.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i - start;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no\n * such index exists. Equivalent to {@code asList().lastIndexOf(target)}.\n */\n", "repo_name": "guava-master/", "id": 4465, "method_signature": "int lastIndexOf(long)", "filename": "ImmutableLongArray.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.of", "method_implementation": "{\n    checkArgument(rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n    long[] array = new long[rest.length + 1];\n    array[0] = first;\n    System.arraycopy(rest, 0, array, 1, rest.length);\n    return new ImmutableLongArray(array);\n}", "repo_id": "5", "comment": "// okay since we have to copy the just-created array anyway.\n", "repo_name": "guava-master/", "id": 4455, "method_signature": "ImmutableLongArray of(long, long[])", "filename": "ImmutableLongArray.of.json"}
{"callee_method_names": [], "method_name": "ImmutableLongArray.subArray", "method_implementation": "{\n    Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n    return startIndex == endIndex ? EMPTY : new ImmutableLongArray(array, start + startIndex, start + endIndex);\n}", "repo_id": "5", "comment": "/**\n * Returns a new immutable array containing the values in the specified range.\n *\n * <p><b>Performance note:</b> The returned array has the same full memory footprint as this one\n * does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,\n * end).trimmed()}.\n */\n", "repo_name": "guava-master/", "id": 4466, "method_signature": "ImmutableLongArray subArray(int, int)", "filename": "ImmutableLongArray.subArray.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ImmutableLongArray.toString", "method_implementation": "{\n    if (isEmpty()) {\n        return \"[]\";\n    }\n    // rough estimate is fine\n    StringBuilder builder = new StringBuilder(length() * 5);\n    builder.append('[').append(array[start]);\n    for (int i = start + 1; i < end; i++) {\n        builder.append(\", \").append(array[i]);\n    }\n    builder.append(']');\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this array in the same form as {@link\n * Arrays#toString(long[])}, for example {@code \"[1, 2, 3]\"}.\n */\n", "repo_name": "guava-master/", "id": 4470, "method_signature": "String toString()", "filename": "ImmutableLongArray.toString.json"}
{"callee_method_names": ["Collection<T>.iterator"], "method_name": "ImmutableLongArrayTest.iterable", "method_implementation": "{\n    // return collection::iterator;\n    return new Iterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return collection.iterator();\n        }\n    };\n}", "repo_id": "5", "comment": "/*\n   * Whenever an implementation uses `instanceof` on a parameter instance, the test has to know that\n   * (so much for \"black box\") and try instances that both do and don't pass the check. The \"don't\"\n   * half of that is more awkward to arrange...\n   */\n", "repo_name": "guava-master/", "id": 3559, "method_signature": "Iterable<T> iterable(Collection)", "filename": "ImmutableLongArrayTest.iterable.json"}
{"callee_method_names": ["Random.nextInt", "AtomicLong.get", "BuilderOp.doIt", "ImmutableLongArray.Builder.build", "ImmutableLongArray.length", "ImmutableLongArray.get"], "method_name": "ImmutableLongArrayTest.testBuilder_bruteForce", "method_implementation": "{\n    for (int i = 0; i < reduceIterationsIfGwt(100); i++) {\n        ImmutableLongArray.Builder builder = ImmutableLongArray.builder(RANDOM.nextInt(20));\n        AtomicLong counter = new AtomicLong(0);\n        while (counter.get() < 1000) {\n            BuilderOp op = BuilderOp.randomOp();\n            op.doIt(builder, counter);\n        }\n        ImmutableLongArray iia = builder.build();\n        for (int j = 0; j < iia.length(); j++) {\n            assertThat(iia.get(j)).isEqualTo((long) j);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * If there's a bug in builder growth, we wouldn't know how to expose it. So, brute force the hell\n * out of it for a while and see what happens.\n */\n", "repo_name": "guava-master/", "id": 3558, "method_signature": "void testBuilder_bruteForce()", "filename": "ImmutableLongArrayTest.testBuilder_bruteForce.json"}
{"callee_method_ids": [4466, 4466, 4466], "callee_method_names": ["ImmutableLongArray.subArray", "ImmutableLongArray.subArray", "ImmutableLongArray.subArray"], "method_name": "ImmutableLongArrayTest.testTrimmed", "method_implementation": "{\n    ImmutableLongArray iia = ImmutableLongArray.of(0, 1, 3);\n    assertDoesntActuallyTrim(iia);\n    assertDoesntActuallyTrim(iia.subArray(0, 3));\n    assertActuallyTrims(iia.subArray(0, 2));\n    assertActuallyTrims(iia.subArray(1, 3));\n    ImmutableLongArray rightSized = ImmutableLongArray.builder(3).add(0).add(1).add(3).build();\n    assertDoesntActuallyTrim(rightSized);\n    ImmutableLongArray overSized = ImmutableLongArray.builder(3).add(0).add(1).build();\n    assertActuallyTrims(overSized);\n    ImmutableLongArray underSized = ImmutableLongArray.builder(2).add(0).add(1).add(3).build();\n    assertActuallyTrims(underSized);\n}", "repo_id": "5", "comment": "/**\n * This is probably a weird and hacky way to test what we're really trying to test, but hey, it\n * caught a bug.\n */\n", "repo_name": "guava-master/", "id": 3560, "method_signature": "void testTrimmed()", "filename": "ImmutableLongArrayTest.testTrimmed.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.asMultimap", "method_implementation": "{\n    if (isEmpty()) {\n        return ImmutableSetMultimap.of();\n    }\n    ImmutableSetMultimap<K, V> result = multimapView;\n    return (result == null) ? (multimapView = new ImmutableSetMultimap<>(new MapViewOfValuesAsSingletonSets(), size(), null)) : result;\n}", "repo_id": "5", "comment": "/**\n * Returns a multimap view of the map.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6039, "method_signature": "ImmutableSetMultimap<K,V> asMultimap()", "filename": "ImmutableMap.asMultimap.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6034, "method_signature": "void clear()", "filename": "ImmutableMap.clear.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.compute", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2659, "method_signature": "V compute(K, BiFunction)", "filename": "ImmutableMap.compute.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.computeIfAbsent", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2657, "method_signature": "V computeIfAbsent(K, Function)", "filename": "ImmutableMap.computeIfAbsent.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.computeIfPresent", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2658, "method_signature": "V computeIfPresent(K, BiFunction)", "filename": "ImmutableMap.computeIfPresent.json"}
{"callee_method_names": ["ImmutableMap.Builder<K, V>.putAll", "ImmutableMap.Builder<K, V>.build"], "method_name": "ImmutableMap.copyOf", "method_implementation": "{\n    int initialCapacity = (entries instanceof Collection) ? ((Collection<?>) entries).size() : ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY;\n    ImmutableMap.Builder<K, V> builder = new ImmutableMap.Builder<K, V>(initialCapacity);\n    builder.putAll(entries);\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the specified entries. The returned map iterates over\n * entries in the same order as the original iterable.\n *\n * @throws NullPointerException if any key, value, or entry is null\n * @throws IllegalArgumentException if two entries have the same key\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6028, "method_signature": "ImmutableMap<K,V> copyOf(Iterable)", "filename": "ImmutableMap.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.entrySet", "method_implementation": "{\n    ImmutableSet<Entry<K, V>> result = entrySet;\n    return (result == null) ? entrySet = createEntrySet() : result;\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable set of the mappings in this map. The iteration order is specified by the\n * method used to create this map. Typically, this is insertion order.\n */\n", "repo_name": "guava-master/", "id": 6036, "method_signature": "ImmutableSet<Entry<K,V>> entrySet()", "filename": "ImmutableMap.entrySet.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.getOrDefault", "method_implementation": "{\n    /*\n     * Even though it's weird to pass a defaultValue that is null, some callers do so. Those who\n     * pass a literal \"null\" should probably just use `get`, but I would expect other callers to\n     * pass an expression that *might* be null. This could happen with:\n     *\n     * - a `getFooOrDefault(@CheckForNull Foo defaultValue)` method that returns\n     *   `map.getOrDefault(FOO_KEY, defaultValue)`\n     *\n     * - a call that consults a chain of maps, as in `mapA.getOrDefault(key, mapB.getOrDefault(key,\n     *   ...))`\n     *\n     * So it makes sense for the parameter (and thus the return type) to be @CheckForNull.\n     *\n     * Two other points:\n     *\n     * 1. We'll want to use something like @PolyNull once we can make that work for the various\n     * platforms we target.\n     *\n     * 2. Kotlin's Map type has a getOrDefault method that accepts and returns a \"plain V,\" in\n     * contrast to the \"V?\" type that we're using. As a result, Kotlin sees a conflict between the\n     * nullness annotations in ImmutableMap and those in its own Map type. In response, it considers\n     * the parameter and return type both to be platform types. As a result, Kotlin permits calls\n     * that can lead to NullPointerException. That's unfortunate. But hopefully most Kotlin callers\n     * use `get(key) ?: defaultValue` instead of this method, anyway.\n     */\n    V result = get(key);\n    // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.\n    if (result != null) {\n        return result;\n    } else {\n        return defaultValue;\n    }\n}", "repo_id": "5", "comment": "// @Override under Java 8 / API Level 24\n", "repo_name": "guava-master/", "id": 6035, "method_signature": "V getOrDefault(Object, V)", "filename": "ImmutableMap.getOrDefault.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.keySet", "method_implementation": "{\n    ImmutableSet<K> result = keySet;\n    return (result == null) ? keySet = createKeySet() : result;\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable set of the keys in this map, in the same order that they appear in {@link\n * #entrySet}.\n */\n", "repo_name": "guava-master/", "id": 6037, "method_signature": "ImmutableSet<K> keySet()", "filename": "ImmutableMap.keySet.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.merge", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2660, "method_signature": "V merge(K, V, BiFunction)", "filename": "ImmutableMap.merge.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.of", "method_implementation": "{\n    checkEntryNotNull(k1, v1);\n    checkEntryNotNull(k2, v2);\n    checkEntryNotNull(k3, v3);\n    checkEntryNotNull(k4, v4);\n    checkEntryNotNull(k5, v5);\n    checkEntryNotNull(k6, v6);\n    checkEntryNotNull(k7, v7);\n    checkEntryNotNull(k8, v8);\n    checkEntryNotNull(k9, v9);\n    checkEntryNotNull(k10, v10);\n    return RegularImmutableMap.create(10, new Object[] { k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10 });\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the given entries, in order.\n *\n * @throws IllegalArgumentException if duplicate keys are provided\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 6022, "method_signature": "ImmutableMap<K,V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V)", "filename": "ImmutableMap.of.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.ofEntries", "method_implementation": "{\n    // we will only ever read these\n    @SuppressWarnings(\"unchecked\")\n    Entry<K, V>[] entries2 = (Entry<K, V>[]) entries;\n    return copyOf(Arrays.asList(entries2));\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the given entries, in order.\n *\n * @throws IllegalArgumentException if duplicate keys are provided\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 6023, "method_signature": "ImmutableMap<K,V> ofEntries(Entry<? extends K,? extends V>[])", "filename": "ImmutableMap.ofEntries.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.orderEntriesByValue", "method_implementation": "{\n    checkState(this.valueComparator == null, \"valueComparator was already set\");\n    this.valueComparator = checkNotNull(valueComparator, \"valueComparator\");\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures this {@code Builder} to order entries by value according to the specified\n * comparator.\n *\n * <p>The sort order is stable, that is, if two entries have values that compare as equivalent,\n * the entry that was inserted first will be first in the built map's iteration order.\n *\n * @throws IllegalStateException if this method was already called\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6026, "method_signature": "Builder<K,V> orderEntriesByValue(Comparator)", "filename": "ImmutableMap.orderEntriesByValue.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.put", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6031, "method_signature": "V put(K, V)", "filename": "ImmutableMap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.putAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6033, "method_signature": "void putAll(Map)", "filename": "ImmutableMap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.putIfAbsent", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2654, "method_signature": "V putIfAbsent(K, V)", "filename": "ImmutableMap.putIfAbsent.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6032, "method_signature": "V remove(Object)", "filename": "ImmutableMap.remove.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.replace", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2656, "method_signature": "V replace(K, V)", "filename": "ImmutableMap.replace.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.replaceAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2662, "method_signature": "void replaceAll(BiFunction)", "filename": "ImmutableMap.replaceAll.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.toImmutableMap", "method_implementation": "{\n    return CollectCollectors.toImmutableMap(keyFunction, valueFunction, mergeFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n * and values are the result of applying the provided mapping functions to the input elements.\n *\n * <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}), the\n * values are merged using the specified merging function. If the merging function returns {@code\n * null}, then the collector removes the value that has been computed for the key thus far (though\n * future occurrences of the key would reinsert it).\n *\n * <p>Entries will appear in the encounter order of the first occurrence of the key.\n */\n", "repo_name": "guava-master/", "id": 6013, "method_signature": "Collector<T,?,ImmutableMap<K,V>> toImmutableMap(Function, Function, BinaryOperator)", "filename": "ImmutableMap.toImmutableMap.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.values", "method_implementation": "{\n    ImmutableCollection<V> result = values;\n    return (result == null) ? values = createValues() : result;\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable collection of the values in this map, in the same order that they appear\n * in {@link #entrySet}.\n */\n", "repo_name": "guava-master/", "id": 6038, "method_signature": "ImmutableCollection<V> values()", "filename": "ImmutableMap.values.json"}
{"callee_method_names": [], "method_name": "ImmutableMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6040, "method_signature": "Object writeReplace()", "filename": "ImmutableMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableMapEntrySet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5538, "method_signature": "Object writeReplace()", "filename": "ImmutableMapEntrySet.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableMapKeySet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2681, "method_signature": "Object writeReplace()", "filename": "ImmutableMapKeySet.writeReplace.json"}
{"callee_method_names": ["ImmutableMap<Integer, Integer>.keySet", "ImmutableMap<Integer, Integer>.values", "ObjectOutputStream.writeObject", "ObjectOutputStream.flush", "ByteArrayOutputStream.size", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.size"], "method_name": "ImmutableMapTest.ignore_testSerializationNoDuplication_jdkBackedImmutableMap", "method_implementation": "{\n    // Tests that serializing a map, its keySet, and values only writes\n    // the underlying data once.\n    Entry<Integer, Integer>[] entries = (Entry<Integer, Integer>[]) new Entry<?, ?>[1000];\n    for (int i = 0; i < 1000; i++) {\n        entries[i] = ImmutableMap.entryOf(i, i);\n    }\n    ImmutableMap<Integer, Integer> map = JdkBackedImmutableMap.create(entries.length, entries, /* throwIfDuplicateKeys= */\n    true);\n    Set<Integer> keySet = map.keySet();\n    Collection<Integer> values = map.values();\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(bytes);\n    oos.writeObject(map);\n    oos.flush();\n    int mapSize = bytes.size();\n    oos.writeObject(keySet);\n    oos.writeObject(values);\n    oos.close();\n    int finalSize = bytes.size();\n    assertThat(finalSize - mapSize).isLessThan(100);\n}", "repo_id": "5", "comment": "// TODO: Re-enable this test after moving to new serialization format in ImmutableMap.\n", "repo_name": "guava-master/", "id": 536, "method_signature": "void ignore_testSerializationNoDuplication_jdkBackedImmutableMap()", "filename": "ImmutableMapTest.ignore_testSerializationNoDuplication_jdkBackedImmutableMap.json"}
{"callee_method_names": ["ImmutableMap<Integer, Integer>.keySet", "ImmutableMap<Integer, Integer>.values", "ObjectOutputStream.writeObject", "ObjectOutputStream.flush", "ByteArrayOutputStream.size", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.size"], "method_name": "ImmutableMapTest.ignore_testSerializationNoDuplication_regularImmutableMap", "method_implementation": "{\n    // Tests that serializing a map, its keySet, and values only writes the underlying data once.\n    Object[] entries = new Object[2000];\n    for (int i = 0; i < entries.length; i++) {\n        entries[i] = i;\n    }\n    ImmutableMap<Integer, Integer> map = RegularImmutableMap.create(entries.length / 2, entries);\n    Set<Integer> keySet = map.keySet();\n    Collection<Integer> values = map.values();\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(bytes);\n    oos.writeObject(map);\n    oos.flush();\n    int mapSize = bytes.size();\n    oos.writeObject(keySet);\n    oos.writeObject(values);\n    oos.close();\n    int finalSize = bytes.size();\n    assertThat(finalSize - mapSize).isLessThan(100);\n}", "repo_id": "5", "comment": "// TODO: Re-enable this test after moving to new serialization format in ImmutableMap.\n", "repo_name": "guava-master/", "id": 3996, "method_signature": "void ignore_testSerializationNoDuplication_regularImmutableMap()", "filename": "ImmutableMapTest.ignore_testSerializationNoDuplication_regularImmutableMap.json"}
{"callee_method_names": ["Builder<Integer, String>.put", "Map<Integer, String>.put", "Builder<Integer, String>.buildKeepingLast"], "method_name": "ImmutableMapTest.testBuildKeepingLast_bigTable", "method_implementation": "{\n    Builder<Integer, String> builder = ImmutableMap.builder();\n    Map<Integer, String> expected = new LinkedHashMap<>();\n    for (int i = 0; i < 200_000; i++) {\n        // Truncate to even key, so we have put(0, \"0\") then put(0, \"1\"). Half the entries are\n        // duplicates.\n        Integer key = i & ~1;\n        String value = String.valueOf(i);\n        builder.put(key, value);\n        expected.put(key, value);\n    }\n    ImmutableMap<Integer, String> map = builder.buildKeepingLast();\n    assertThat(map).hasSize(100_000);\n    assertThat(map).containsExactlyEntriesIn(expected).inOrder();\n}", "repo_id": "5", "comment": "// This method tests the int case.\n", "repo_name": "guava-master/", "id": 3993, "method_signature": "void testBuildKeepingLast_bigTable()", "filename": "ImmutableMapTest.testBuildKeepingLast_bigTable.json"}
{"callee_method_names": ["Builder<Integer, String>.put", "Map<Integer, String>.put", "Builder<Integer, String>.buildKeepingLast"], "method_name": "ImmutableMapTest.testBuildKeepingLast_shortTable", "method_implementation": "{\n    Builder<Integer, String> builder = ImmutableMap.builder();\n    Map<Integer, String> expected = new LinkedHashMap<>();\n    for (int i = 0; i < 1000; i++) {\n        // Truncate to even key, so we have put(0, \"0\") then put(0, \"1\"). Half the entries are\n        // duplicates.\n        Integer key = i & ~1;\n        String value = String.valueOf(i);\n        builder.put(key, value);\n        expected.put(key, value);\n    }\n    ImmutableMap<Integer, String> map = builder.buildKeepingLast();\n    assertThat(map).hasSize(500);\n    assertThat(map).containsExactlyEntriesIn(expected).inOrder();\n}", "repo_id": "5", "comment": "// case. This method tests the short case.\n", "repo_name": "guava-master/", "id": 3992, "method_signature": "void testBuildKeepingLast_shortTable()", "filename": "ImmutableMapTest.testBuildKeepingLast_shortTable.json"}
{"callee_method_names": ["ImmutableMap.Builder<String, Integer>.combine"], "method_name": "ImmutableMapTest.testToImmutableMap_exceptionOnDuplicateKey_java7_combine", "method_implementation": "{\n    ImmutableMap.Builder<String, Integer> zis = ImmutableMap.<String, Integer>builder().put(\"one\", 1).put(\"two\", 2);\n    ImmutableMap.Builder<String, Integer> zat = ImmutableMap.<String, Integer>builder().put(\"two\", 22).put(\"three\", 3);\n    try {\n        zis.combine(zat).build();\n        fail(\"Expected IllegalArgumentException\");\n    } catch (IllegalArgumentException expected) {\n        // expected\n    }\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableMap once CollectorTester is usable to java7.\n", "repo_name": "guava-master/", "id": 3995, "method_signature": "void testToImmutableMap_exceptionOnDuplicateKey_java7_combine()", "filename": "ImmutableMapTest.testToImmutableMap_exceptionOnDuplicateKey_java7_combine.json"}
{"callee_method_names": ["ImmutableMap.Builder<String, Integer>.combine"], "method_name": "ImmutableMapTest.testToImmutableMap_java7_combine", "method_implementation": "{\n    ImmutableMap.Builder<String, Integer> zis = ImmutableMap.<String, Integer>builder().put(\"one\", 1);\n    ImmutableMap.Builder<String, Integer> zat = ImmutableMap.<String, Integer>builder().put(\"two\", 2).put(\"three\", 3);\n    assertMapEquals(zis.combine(zat).build(), \"one\", 1, \"two\", 2, \"three\", 3);\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableMap once CollectorTester is usable to java7.\n", "repo_name": "guava-master/", "id": 3994, "method_signature": "void testToImmutableMap_java7_combine()", "filename": "ImmutableMapTest.testToImmutableMap_java7_combine.json"}
{"callee_method_names": [], "method_name": "ImmutableMapValues.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6616, "method_signature": "Object writeReplace()", "filename": "ImmutableMapValues.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.asMap", "method_implementation": "{\n    return (ImmutableMap) map;\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map that associates each key with its corresponding values in the\n * multimap. Keys and values appear in the same order as in this multimap.\n */\n", "repo_name": "guava-master/", "id": 6662, "method_signature": "ImmutableMap<K,Collection<V>> asMap()", "filename": "ImmutableMultimap.asMap.json"}
{"callee_method_names": ["Map<K, Collection<V>>.entrySet"], "method_name": "ImmutableMultimap.build", "method_implementation": "{\n    Collection<Map.Entry<K, Collection<V>>> mapEntries = builderMap.entrySet();\n    if (keyComparator != null) {\n        mapEntries = Ordering.from(keyComparator).<K>onKeys().immutableSortedCopy(mapEntries);\n    }\n    return ImmutableListMultimap.fromMapEntries(mapEntries, valueComparator);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created immutable multimap.\n */\n", "repo_name": "guava-master/", "id": 6653, "method_signature": "ImmutableMultimap<K,V> build()", "filename": "ImmutableMultimap.build.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6657, "method_signature": "void clear()", "filename": "ImmutableMultimap.clear.json"}
{"callee_method_names": ["ImmutableMultimap<K, V>.isPartialView"], "method_name": "ImmutableMultimap.copyOf", "method_implementation": "{\n    if (multimap instanceof ImmutableMultimap) {\n        // safe since multimap is not writable\n        @SuppressWarnings(\"unchecked\")\n        ImmutableMultimap<K, V> kvMultimap = (ImmutableMultimap<K, V>) multimap;\n        if (!kvMultimap.isPartialView()) {\n            return kvMultimap;\n        }\n    }\n    return ImmutableListMultimap.copyOf(multimap);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable multimap containing the same mappings as {@code multimap}, in the\n * \"key-grouped\" iteration order described in the class documentation.\n *\n * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n * safe to do so. The exact circumstances under which a copy will or will not be performed are\n * undocumented and subject to change.\n *\n * @throws NullPointerException if any key or value in {@code multimap} is null\n */\n", "repo_name": "guava-master/", "id": 6654, "method_signature": "ImmutableMultimap<K,V> copyOf(Multimap)", "filename": "ImmutableMultimap.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.orderKeysBy", "method_implementation": "{\n    this.keyComparator = checkNotNull(keyComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated multimap's keys.\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6651, "method_signature": "Builder<K,V> orderKeysBy(Comparator)", "filename": "ImmutableMultimap.orderKeysBy.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.orderValuesBy", "method_implementation": "{\n    this.valueComparator = checkNotNull(valueComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated multimap's values for each key.\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6652, "method_signature": "Builder<K,V> orderValuesBy(Comparator)", "filename": "ImmutableMultimap.orderValuesBy.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.put", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6658, "method_signature": "boolean put(K, V)", "filename": "ImmutableMultimap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.putAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6660, "method_signature": "boolean putAll(Multimap)", "filename": "ImmutableMultimap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6661, "method_signature": "boolean remove(Object, Object)", "filename": "ImmutableMultimap.remove.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.removeAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6655, "method_signature": "ImmutableCollection<V> removeAll(Object)", "filename": "ImmutableMultimap.removeAll.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.replaceValues", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6656, "method_signature": "ImmutableCollection<V> replaceValues(K, Iterable)", "filename": "ImmutableMultimap.replaceValues.json"}
{"callee_method_names": [], "method_name": "ImmutableMultimap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6664, "method_signature": "Object writeReplace()", "filename": "ImmutableMultimap.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableMultiset.add", "method_implementation": "{\n    super.add(elements);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableMultiset}.\n *\n * @param elements the elements to add\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5700, "method_signature": "Builder<E> add(E[])", "filename": "ImmutableMultiset.add.json"}
{"callee_method_names": [], "method_name": "ImmutableMultiset.addAll", "method_implementation": "{\n    super.addAll(elements);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableMultiset}.\n *\n * @param elements the elements to add to the {@code ImmutableMultiset}\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5704, "method_signature": "Builder<E> addAll(Iterator)", "filename": "ImmutableMultiset.addAll.json"}
{"callee_method_names": ["ObjectCountHashMap<E>.put", "ObjectCountHashMap<E>.get"], "method_name": "ImmutableMultiset.addCopies", "method_implementation": "{\n    // see the comment on the field\n    requireNonNull(contents);\n    if (occurrences == 0) {\n        return this;\n    }\n    if (buildInvoked) {\n        contents = new ObjectCountHashMap<E>(contents);\n        isLinkedHash = false;\n    }\n    buildInvoked = false;\n    checkNotNull(element);\n    contents.put(element, occurrences + contents.get(element));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds a number of occurrences of an element to this {@code ImmutableMultiset}.\n *\n * @param element the element to add\n * @param occurrences the number of occurrences of the element to add. May be zero, in which\n *     case no change will be made.\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code element} is null\n * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation\n *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element\n */\n", "repo_name": "guava-master/", "id": 5701, "method_signature": "Builder<E> addCopies(E, int)", "filename": "ImmutableMultiset.addCopies.json"}
{"callee_method_names": ["ObjectCountHashMap<E>.size"], "method_name": "ImmutableMultiset.build", "method_implementation": "{\n    // see the comment on the field\n    requireNonNull(contents);\n    if (contents.size() == 0) {\n        return of();\n    }\n    if (isLinkedHash) {\n        // we need ObjectCountHashMap-backed contents, with its keys and values array in direct\n        // insertion order\n        contents = new ObjectCountHashMap<E>(contents);\n        isLinkedHash = false;\n    }\n    buildInvoked = true;\n    // contents is now ObjectCountHashMap, but still guaranteed to be in insertion order!\n    return new RegularImmutableMultiset<E>(contents);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created {@code ImmutableMultiset} based on the contents of the {@code\n * Builder}.\n */\n", "repo_name": "guava-master/", "id": 5706, "method_signature": "ImmutableMultiset<E> build()", "filename": "ImmutableMultiset.build.json"}
{"callee_method_names": ["ImmutableMultiset<E>.isPartialView", "ImmutableMultiset.Builder<E>.addAll", "ImmutableMultiset.Builder<E>.build"], "method_name": "ImmutableMultiset.copyOf", "method_implementation": "{\n    if (elements instanceof ImmutableMultiset) {\n        // all supported methods are covariant\n        @SuppressWarnings(\"unchecked\")\n        ImmutableMultiset<E> result = (ImmutableMultiset<E>) elements;\n        if (!result.isPartialView()) {\n            return result;\n        }\n    }\n    ImmutableMultiset.Builder<E> builder = new ImmutableMultiset.Builder<E>(Multisets.inferDistinctElements(elements));\n    builder.addAll(elements);\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n * described in the class documentation.\n *\n * @throws NullPointerException if any of {@code elements} is null\n */\n", "repo_name": "guava-master/", "id": 5694, "method_signature": "ImmutableMultiset<E> copyOf(Iterable)", "filename": "ImmutableMultiset.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableMultiset.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5696, "method_signature": "int remove(Object, int)", "filename": "ImmutableMultiset.remove.json"}
{"callee_method_names": ["ObjectCountHashMap<E>.remove", "ObjectCountHashMap<E>.put"], "method_name": "ImmutableMultiset.setCount", "method_implementation": "{\n    // see the comment on the field\n    requireNonNull(contents);\n    if (count == 0 && !isLinkedHash) {\n        contents = new ObjectCountLinkedHashMap<E>(contents);\n        isLinkedHash = true;\n        // to preserve insertion order through deletions, we have to switch to an actual linked\n        // implementation at least for now, but this should be a super rare case\n    } else if (buildInvoked) {\n        contents = new ObjectCountHashMap<E>(contents);\n        isLinkedHash = false;\n    }\n    buildInvoked = false;\n    checkNotNull(element);\n    if (count == 0) {\n        contents.remove(element);\n    } else {\n        contents.put(checkNotNull(element), count);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds or removes the necessary occurrences of an element such that the element attains the\n * desired count.\n *\n * @param element the element to add or remove occurrences of\n * @param count the desired count of the element in this multiset\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code element} is null\n * @throws IllegalArgumentException if {@code count} is negative\n */\n", "repo_name": "guava-master/", "id": 5702, "method_signature": "Builder<E> setCount(E, int)", "filename": "ImmutableMultiset.setCount.json"}
{"callee_method_names": [], "method_name": "ImmutableMultiset.toImmutableMultiset", "method_implementation": "{\n    return CollectCollectors.toImmutableMultiset(elementFunction, countFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates elements into an {@code ImmutableMultiset} whose\n * elements are the result of applying {@code elementFunction} to the inputs, with counts equal to\n * the result of applying {@code countFunction} to the inputs.\n *\n * <p>If the mapped elements contain duplicates (according to {@link Object#equals}), the first\n * occurrence in encounter order appears in the resulting multiset, with count equal to the sum of\n * the outputs of {@code countFunction.applyAsInt(t)} for each {@code t} mapped to that element.\n */\n", "repo_name": "guava-master/", "id": 5693, "method_signature": "Collector<T,?,ImmutableMultiset<E>> toImmutableMultiset(Function, ToIntFunction)", "filename": "ImmutableMultiset.toImmutableMultiset.json"}
{"callee_method_names": [], "method_name": "ImmutableMultiset.tryGetMap", "method_implementation": "{\n    if (multiset instanceof RegularImmutableMultiset) {\n        return ((RegularImmutableMultiset<T>) multiset).contents;\n    } else if (multiset instanceof AbstractMapBasedMultiset) {\n        return ((AbstractMapBasedMultiset<T>) multiset).backingMap;\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * If the specified collection is backed by an ObjectCountHashMap, it will be much more\n * efficient to iterate over it by index rather than an entry iterator, which will need to\n * allocate an object for each entry, so we check for that.\n */\n", "repo_name": "guava-master/", "id": 5705, "method_signature": "ObjectCountHashMap<T> tryGetMap(Iterable)", "filename": "ImmutableMultiset.tryGetMap.json"}
{"callee_method_names": [], "method_name": "ImmutableMultiset.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2326, "method_signature": "Object writeReplace()", "filename": "ImmutableMultiset.writeReplace.json"}
{"callee_method_names": ["MutableNetwork<N, E>.addEdge"], "method_name": "ImmutableNetwork.addEdge", "method_implementation": "{\n    mutableNetwork.addEdge(endpoints, edge);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will\n * also connect {@code nodeV} to {@code nodeU}.\n *\n * <p>If this network is directed, {@code edge} will be directed in this network; if it is\n * undirected, {@code edge} will be undirected in this network.\n *\n * <p>If this network is directed, {@code endpoints} must be ordered.\n *\n * <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It\n * must also be non-null.\n *\n * <p>If either or both endpoints are not already present in this network, this method will\n * silently {@link #addNode(Object) add} each missing endpoint to the network.\n *\n * <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this\n * method will have no effect.\n *\n * @return this {@code Builder} object\n * @throws IllegalArgumentException if {@code edge} already exists in the network and connects\n *     some other endpoint pair that is not equal to {@code endpoints}\n * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}\n * @throws IllegalArgumentException if the endpoints are unordered and the network is directed\n */\n", "repo_name": "guava-master/", "id": 6748, "method_signature": "ImmutableNetwork.Builder<N,E> addEdge(EndpointPair, E)", "filename": "ImmutableNetwork.addEdge.json"}
{"callee_method_names": ["MutableNetwork<N, E>.addNode"], "method_name": "ImmutableNetwork.addNode", "method_implementation": "{\n    mutableNetwork.addNode(node);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code node} if it is not already present.\n *\n * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.\n *\n * @return this {@code Builder} object\n */\n", "repo_name": "guava-master/", "id": 6746, "method_signature": "ImmutableNetwork.Builder<N,E> addNode(N)", "filename": "ImmutableNetwork.addNode.json"}
{"callee_method_names": [], "method_name": "ImmutableNetwork.copyOf", "method_implementation": "{\n    return (network instanceof ImmutableNetwork) ? (ImmutableNetwork<N, E>) network : new ImmutableNetwork<N, E>(network);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable copy of {@code network}.\n */\n", "repo_name": "guava-master/", "id": 6745, "method_signature": "ImmutableNetwork<N,E> copyOf(Network)", "filename": "ImmutableNetwork.copyOf.json"}
{"callee_method_names": ["NetworkBuilder<String, Object>.immutable", "NetworkBuilder<String, Object>.allowsSelfLoops", "ImmutableNetwork.Builder<String, Integer>.build", "ImmutableNetwork<String, Integer>.isDirected", "ImmutableNetwork<String, Integer>.allowsSelfLoops", "ImmutableNetwork<String, Integer>.nodeOrder"], "method_name": "ImmutableNetworkTest.immutableNetworkBuilder_copiesNetworkBuilder", "method_implementation": "{\n    NetworkBuilder<String, Object> networkBuilder = NetworkBuilder.directed().allowsSelfLoops(true).<String>nodeOrder(ElementOrder.<String>natural());\n    ImmutableNetwork.Builder<String, Integer> immutableNetworkBuilder = networkBuilder.<String, Integer>immutable();\n    // Update NetworkBuilder, but this shouldn't impact immutableNetworkBuilder\n    networkBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());\n    ImmutableNetwork<String, Integer> emptyNetwork = immutableNetworkBuilder.build();\n    assertThat(emptyNetwork.isDirected()).isTrue();\n    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();\n    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.<String>natural());\n}", "repo_id": "5", "comment": "/**\n * Tests that the ImmutableNetwork.Builder doesn't change when the creating NetworkBuilder\n * changes.\n */\n", "repo_name": "guava-master/", "id": 4048, "method_signature": "void immutableNetworkBuilder_copiesNetworkBuilder()", "filename": "ImmutableNetworkTest.immutableNetworkBuilder_copiesNetworkBuilder.json"}
{"callee_method_names": ["List<Entry<Range<K>, V>>.size", "List<Entry<Range<K>, V>>.size", "List<Entry<Range<K>, V>>.size", "List<Entry<Range<K>, V>>.get", "List<Entry<Range<K>, V>>.get", "Range<K>.isConnected", "Range<K>.intersection", "ImmutableList.Builder<Range<K>>.add", "ImmutableList.Builder<V>.add", "List<Entry<Range<K>, V>>.get", "ImmutableList.Builder<Range<K>>.build", "ImmutableList.Builder<V>.build"], "method_name": "ImmutableRangeMap.build", "method_implementation": "{\n    Collections.sort(entries, Range.<K>rangeLexOrdering().onKeys());\n    ImmutableList.Builder<Range<K>> rangesBuilder = new ImmutableList.Builder<>(entries.size());\n    ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(entries.size());\n    for (int i = 0; i < entries.size(); i++) {\n        Range<K> range = entries.get(i).getKey();\n        if (i > 0) {\n            Range<K> prevRange = entries.get(i - 1).getKey();\n            if (range.isConnected(prevRange) && !range.intersection(prevRange).isEmpty()) {\n                throw new IllegalArgumentException(\"Overlapping ranges: range \" + prevRange + \" overlaps with entry \" + range);\n            }\n        }\n        rangesBuilder.add(range);\n        valuesBuilder.add(entries.get(i).getValue());\n    }\n    return new ImmutableRangeMap<>(rangesBuilder.build(), valuesBuilder.build());\n}", "repo_id": "5", "comment": "/**\n * Returns an {@code ImmutableRangeMap} containing the associations previously added to this\n * builder.\n *\n * @throws IllegalArgumentException if any two ranges inserted into this builder overlap\n */\n", "repo_name": "guava-master/", "id": 6332, "method_signature": "ImmutableRangeMap<K,V> build()", "filename": "ImmutableRangeMap.build.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6336, "method_signature": "void clear()", "filename": "ImmutableRangeMap.clear.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.merge", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2970, "method_signature": "void merge(Range, V, BiFunction)", "filename": "ImmutableRangeMap.merge.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.put", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6333, "method_signature": "void put(Range, V)", "filename": "ImmutableRangeMap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.putAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6335, "method_signature": "void putAll(RangeMap)", "filename": "ImmutableRangeMap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.putCoalescing", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6334, "method_signature": "void putCoalescing(Range, V)", "filename": "ImmutableRangeMap.putCoalescing.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6337, "method_signature": "void remove(Range)", "filename": "ImmutableRangeMap.remove.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.toImmutableRangeMap", "method_implementation": "{\n    return CollectCollectors.toImmutableRangeMap(keyFunction, valueFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates the input elements into a new {@code\n * ImmutableRangeMap}. As in {@link Builder}, overlapping ranges are not permitted.\n */\n", "repo_name": "guava-master/", "id": 6329, "method_signature": "Collector<T,?,ImmutableRangeMap<K,V>> toImmutableRangeMap(Function, Function)", "filename": "ImmutableRangeMap.toImmutableRangeMap.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6339, "method_signature": "Object writeReplace()", "filename": "ImmutableRangeMap.writeReplace.json"}
{"callee_method_names": ["ImmutableRangeMap.Builder<Integer, Integer>.combine", "ImmutableRangeMap<Integer, Integer>.asMapOfRanges"], "method_name": "ImmutableRangeMapTest.testToImmutableRangeMap", "method_implementation": "{\n    Range<Integer> rangeOne = Range.closedOpen(1, 5);\n    Range<Integer> rangeTwo = Range.openClosed(6, 7);\n    ImmutableRangeMap.Builder<Integer, Integer> zis = ImmutableRangeMap.<Integer, Integer>builder().put(rangeOne, 1);\n    ImmutableRangeMap.Builder<Integer, Integer> zat = ImmutableRangeMap.<Integer, Integer>builder().put(rangeTwo, 6);\n    ImmutableRangeMap<Integer, Integer> rangeMap = zis.combine(zat).build();\n    assertThat(rangeMap.asMapOfRanges().entrySet()).containsExactly(Maps.immutableEntry(rangeOne, 1), Maps.immutableEntry(rangeTwo, 6)).inOrder();\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableRangeMap once CollectorTester is usable to java7\n", "repo_name": "guava-master/", "id": 3954, "method_signature": "void testToImmutableRangeMap()", "filename": "ImmutableRangeMapTest.testToImmutableRangeMap.json"}
{"callee_method_names": ["Range<C>.isEmpty", "ImmutableList<Range<C>>.add"], "method_name": "ImmutableRangeSet.add", "method_implementation": "{\n    checkArgument(!range.isEmpty(), \"range must not be empty, but was %s\", range);\n    ranges.add(range);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,\n * but overlapping ranges will cause an exception when {@link #build()} is called.\n *\n * @throws IllegalArgumentException if {@code range} is empty\n */\n", "repo_name": "guava-master/", "id": 6633, "method_signature": "Builder<C> add(Range)", "filename": "ImmutableRangeSet.add.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeSet.addAll", "method_implementation": "{\n    for (Range<C> range : ranges) {\n        add(range);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be\n * merged, but overlapping ranges will cause an exception when {@link #build()} is called.\n *\n * @throws IllegalArgumentException if any inserted ranges are empty\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 6634, "method_signature": "Builder<C> addAll(Iterable)", "filename": "ImmutableRangeSet.addAll.json"}
{"callee_method_names": ["Range<C>.hasLowerBound", "Range<C>.hasUpperBound", "DiscreteDomain<C>.maxValue"], "method_name": "ImmutableRangeSet.asSet", "method_implementation": "{\n    checkNotNull(domain);\n    if (isEmpty()) {\n        return ImmutableSortedSet.of();\n    }\n    Range<C> span = span().canonical(domain);\n    if (!span.hasLowerBound()) {\n        // according to the spec of canonical, neither this ImmutableRangeSet nor\n        // the range have a lower bound\n        throw new IllegalArgumentException(\"Neither the DiscreteDomain nor this range set are bounded below\");\n    } else if (!span.hasUpperBound()) {\n        try {\n            domain.maxValue();\n        } catch (NoSuchElementException e) {\n            throw new IllegalArgumentException(\"Neither the DiscreteDomain nor this range set are bounded above\");\n        }\n    }\n    return new AsSet(domain);\n}", "repo_id": "5", "comment": "/**\n * Returns an {@link ImmutableSortedSet} containing the same values in the given domain\n * {@linkplain RangeSet#contains contained} by this range set.\n *\n * <p><b>Note:</b> {@code a.asSet(d).equals(b.asSet(d))} does not imply {@code a.equals(b)}! For\n * example, {@code a} and {@code b} could be {@code [2..4]} and {@code (1..5)}, or the empty\n * ranges {@code [3..3)} and {@code [4..4)}.\n *\n * <p><b>Warning:</b> Be extremely careful what you do with the {@code asSet} view of a large\n * range set (such as {@code ImmutableRangeSet.of(Range.greaterThan(0))}). Certain operations on\n * such a set can be performed efficiently, but others (such as {@link Set#hashCode} or {@link\n * Collections#frequency}) can cause major performance problems.\n *\n * <p>The returned set's {@link Object#toString} method returns a shorthand form of the set's\n * contents, such as {@code \"[1..100]}\"}.\n *\n * @throws IllegalArgumentException if neither this range nor the domain has a lower bound, or if\n *     neither has an upper bound\n */\n", "repo_name": "guava-master/", "id": 6632, "method_signature": "ImmutableSortedSet<C> asSet(DiscreteDomain)", "filename": "ImmutableRangeSet.asSet.json"}
{"callee_method_names": ["Iterable<Range<C>>.size", "Iterable<Range<C>>.iterator", "PeekingIterator<Range<C>>.hasNext", "PeekingIterator<Range<C>>.next", "PeekingIterator<Range<C>>.hasNext", "PeekingIterator<Range<C>>.peek", "Range<C>.isConnected", "Range<C>.intersection", "Range<C>.span", "PeekingIterator<Range<C>>.next", "ImmutableList.Builder<Range<C>>.add", "ImmutableList.Builder<Range<C>>.build", "ImmutableList<Range<C>>.isEmpty", "ImmutableList<Range<C>>.size"], "method_name": "ImmutableRangeSet.build", "method_implementation": "{\n    ImmutableList.Builder<Range<C>> mergedRangesBuilder = new ImmutableList.Builder<>(ranges.size());\n    Collections.sort(ranges, Range.<C>rangeLexOrdering());\n    PeekingIterator<Range<C>> peekingItr = Iterators.peekingIterator(ranges.iterator());\n    while (peekingItr.hasNext()) {\n        Range<C> range = peekingItr.next();\n        while (peekingItr.hasNext()) {\n            Range<C> nextRange = peekingItr.peek();\n            if (range.isConnected(nextRange)) {\n                checkArgument(range.intersection(nextRange).isEmpty(), \"Overlapping ranges not permitted but found %s overlapping %s\", range, nextRange);\n                range = range.span(peekingItr.next());\n            } else {\n                break;\n            }\n        }\n        mergedRangesBuilder.add(range);\n    }\n    ImmutableList<Range<C>> mergedRanges = mergedRangesBuilder.build();\n    if (mergedRanges.isEmpty()) {\n        return of();\n    } else if (mergedRanges.size() == 1 && Iterables.getOnlyElement(mergedRanges).equals(Range.all())) {\n        return all();\n    } else {\n        return new ImmutableRangeSet<C>(mergedRanges);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an {@code ImmutableRangeSet} containing the ranges added to this builder.\n *\n * @throws IllegalArgumentException if any input ranges have nonempty overlap\n */\n", "repo_name": "guava-master/", "id": 6635, "method_signature": "ImmutableRangeSet<C> build()", "filename": "ImmutableRangeSet.build.json"}
{"callee_method_names": ["RangeSet<C>.isEmpty", "RangeSet<C>.encloses", "ImmutableRangeSet<C>.isPartialView", "RangeSet<C>.asRanges"], "method_name": "ImmutableRangeSet.copyOf", "method_implementation": "{\n    checkNotNull(rangeSet);\n    if (rangeSet.isEmpty()) {\n        return of();\n    } else if (rangeSet.encloses(Range.<C>all())) {\n        return all();\n    }\n    if (rangeSet instanceof ImmutableRangeSet) {\n        ImmutableRangeSet<C> immutableRangeSet = (ImmutableRangeSet<C>) rangeSet;\n        if (!immutableRangeSet.isPartialView()) {\n            return immutableRangeSet;\n        }\n    }\n    return new ImmutableRangeSet<C>(ImmutableList.copyOf(rangeSet.asRanges()));\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable copy of the specified {@code RangeSet}.\n */\n", "repo_name": "guava-master/", "id": 6619, "method_signature": "ImmutableRangeSet<C> copyOf(RangeSet)", "filename": "ImmutableRangeSet.copyOf.json"}
{"callee_method_names": ["RangeSet<C>.removeAll"], "method_name": "ImmutableRangeSet.difference", "method_implementation": "{\n    RangeSet<C> copy = TreeRangeSet.create(this);\n    copy.removeAll(other);\n    return copyOf(copy);\n}", "repo_id": "5", "comment": "/**\n * Returns a new range set consisting of the difference of this range set and {@code other}.\n *\n * <p>This is essentially the same as {@code TreeRangeSet.create(this).removeAll(other)} except it\n * returns an {@code ImmutableRangeSet}.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 6628, "method_signature": "ImmutableRangeSet<C> difference(RangeSet)", "filename": "ImmutableRangeSet.difference.json"}
{"callee_method_names": ["ImmutableList<Range<C>>.isEmpty", "Range<C>.isEmpty", "Range<C>.encloses", "Range<C>.hasLowerBound", "Range<C>.hasUpperBound", "ImmutableList<Range<C>>.size", "ImmutableList<Range<C>>.get", "ImmutableList<Range<C>>.get"], "method_name": "ImmutableRangeSet.intersectRanges", "method_implementation": "{\n    if (ranges.isEmpty() || range.isEmpty()) {\n        return ImmutableList.of();\n    } else if (range.encloses(span())) {\n        return ranges;\n    }\n    final int fromIndex;\n    if (range.hasLowerBound()) {\n        fromIndex = SortedLists.binarySearch(ranges, Range.<C>upperBoundFn(), range.lowerBound, KeyPresentBehavior.FIRST_AFTER, KeyAbsentBehavior.NEXT_HIGHER);\n    } else {\n        fromIndex = 0;\n    }\n    int toIndex;\n    if (range.hasUpperBound()) {\n        toIndex = SortedLists.binarySearch(ranges, Range.<C>lowerBoundFn(), range.upperBound, KeyPresentBehavior.FIRST_PRESENT, KeyAbsentBehavior.NEXT_HIGHER);\n    } else {\n        toIndex = ranges.size();\n    }\n    final int length = toIndex - fromIndex;\n    if (length == 0) {\n        return ImmutableList.of();\n    } else {\n        return new ImmutableList<Range<C>>() {\n\n            @Override\n            public int size() {\n                return length;\n            }\n\n            @Override\n            public Range<C> get(int index) {\n                checkElementIndex(index, length);\n                if (index == 0 || index == length - 1) {\n                    return ranges.get(index + fromIndex).intersection(range);\n                } else {\n                    return ranges.get(index + fromIndex);\n                }\n            }\n\n            @Override\n            boolean isPartialView() {\n                return true;\n            }\n\n            // redeclare to help optimizers with b/310253115\n            @SuppressWarnings(\"RedundantOverride\")\n            @Override\n            // serialization\n            @J2ktIncompatible\n            // serialization\n            @GwtIncompatible\n            Object writeReplace() {\n                return super.writeReplace();\n            }\n        };\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a list containing the nonempty intersections of {@code range} with the ranges in this\n * range set.\n */\n", "repo_name": "guava-master/", "id": 6629, "method_signature": "ImmutableList<Range<C>> intersectRanges(Range)", "filename": "ImmutableRangeSet.intersectRanges.json"}
{"callee_method_names": ["RangeSet<C>.removeAll", "RangeSet<C>.complement"], "method_name": "ImmutableRangeSet.intersection", "method_implementation": "{\n    RangeSet<C> copy = TreeRangeSet.create(this);\n    copy.removeAll(other.complement());\n    return copyOf(copy);\n}", "repo_id": "5", "comment": "/**\n * Returns a new range set consisting of the intersection of this range set and {@code other}.\n *\n * <p>This is essentially the same as {@code\n * TreeRangeSet.create(this).removeAll(other.complement())} except it returns an {@code\n * ImmutableRangeSet}.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 6627, "method_signature": "ImmutableRangeSet<C> intersection(RangeSet)", "filename": "ImmutableRangeSet.intersection.json"}
{"callee_method_names": ["Range<C>.isEmpty", "Range<C>.equals"], "method_name": "ImmutableRangeSet.of", "method_implementation": "{\n    checkNotNull(range);\n    if (range.isEmpty()) {\n        return of();\n    } else if (range.equals(Range.all())) {\n        return all();\n    } else {\n        return new ImmutableRangeSet<C>(ImmutableList.of(range));\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable range set containing the specified single range. If {@link Range#isEmpty()\n * range.isEmpty()}, this is equivalent to {@link ImmutableRangeSet#of()}.\n */\n", "repo_name": "guava-master/", "id": 6618, "method_signature": "ImmutableRangeSet<C> of(Range)", "filename": "ImmutableRangeSet.of.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeSet.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6623, "method_signature": "void remove(Range)", "filename": "ImmutableRangeSet.remove.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeSet.removeAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6625, "method_signature": "void removeAll(Iterable)", "filename": "ImmutableRangeSet.removeAll.json"}
{"callee_method_names": ["Range<C>.encloses", "Range<C>.isConnected"], "method_name": "ImmutableRangeSet.subRangeSet", "method_implementation": "{\n    if (!isEmpty()) {\n        Range<C> span = span();\n        if (range.encloses(span)) {\n            return this;\n        } else if (range.isConnected(span)) {\n            return new ImmutableRangeSet<C>(intersectRanges(range));\n        }\n    }\n    return of();\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the intersection of this range set with the given range.\n */\n", "repo_name": "guava-master/", "id": 6631, "method_signature": "ImmutableRangeSet<C> subRangeSet(Range)", "filename": "ImmutableRangeSet.subRangeSet.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeSet.toImmutableRangeSet", "method_implementation": "{\n    return CollectCollectors.toImmutableRangeSet();\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates the input elements into a new {@code\n * ImmutableRangeSet}. As in {@link Builder}, overlapping ranges are not permitted and adjacent\n * ranges will be merged.\n */\n", "repo_name": "guava-master/", "id": 6617, "method_signature": "Collector<Range<E>,?,ImmutableRangeSet<E>> toImmutableRangeSet()", "filename": "ImmutableRangeSet.toImmutableRangeSet.json"}
{"callee_method_names": [], "method_name": "ImmutableRangeSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6630, "method_signature": "Object writeReplace()", "filename": "ImmutableRangeSet.writeReplace.json"}
{"callee_method_names": ["ImmutableRangeSet.Builder<Integer>.combine", "ImmutableRangeSet<Integer>.asRanges"], "method_name": "ImmutableRangeSetTest.testToImmutableRangeSet_java7_combine", "method_implementation": "{\n    Range<Integer> rangeOne = Range.closedOpen(1, 3);\n    Range<Integer> rangeTwo = Range.closedOpen(7, 9);\n    Range<Integer> rangeThree = Range.closedOpen(4, 5);\n    Range<Integer> rangeFour = Range.closedOpen(6, 7);\n    ImmutableRangeSet.Builder<Integer> zis = ImmutableRangeSet.<Integer>builder().add(rangeOne).add(rangeTwo);\n    ImmutableRangeSet.Builder<Integer> zat = ImmutableRangeSet.<Integer>builder().add(rangeThree).add(rangeFour);\n    ImmutableRangeSet<Integer> rangeSet = zis.combine(zat).build();\n    assertThat(rangeSet.asRanges()).containsExactly(Range.closedOpen(1, 3), Range.closedOpen(4, 5), Range.closedOpen(6, 9)).inOrder();\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableRangeSet once CollectorTester is usable to java7\n", "repo_name": "guava-master/", "id": 4022, "method_signature": "void testToImmutableRangeSet_java7_combine()", "filename": "ImmutableRangeSetTest.testToImmutableRangeSet_java7_combine.json"}
{"callee_method_names": [], "method_name": "ImmutableSet.add", "method_implementation": "{\n    if (hashTable != null) {\n        for (E e : elements) {\n            add(e);\n        }\n    } else {\n        super.add(elements);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableSet}, ignoring duplicate\n * elements (only the first duplicate element is added).\n *\n * @param elements the elements to add\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 6457, "method_signature": "Builder<E> add(E[])", "filename": "ImmutableSet.add.json"}
{"callee_method_names": ["Iterator<? extends E>.hasNext", "Iterator<? extends E>.next"], "method_name": "ImmutableSet.addAll", "method_implementation": "{\n    checkNotNull(elements);\n    while (elements.hasNext()) {\n        add(elements.next());\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableSet}, ignoring duplicate\n * elements (only the first duplicate element is added).\n *\n * @param elements the elements to add to the {@code ImmutableSet}\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 6459, "method_signature": "Builder<E> addAll(Iterator)", "filename": "ImmutableSet.addAll.json"}
{"callee_method_names": ["ImmutableSet<E>.size"], "method_name": "ImmutableSet.build", "method_implementation": "{\n    switch(size) {\n        case 0:\n            return of();\n        case 1:\n            /*\n           * requireNonNull is safe because we ensure that the first `size` elements have been\n           * populated.\n           */\n            return (ImmutableSet<E>) of(requireNonNull(contents[0]));\n        default:\n            ImmutableSet<E> result;\n            if (hashTable != null && chooseTableSize(size) == hashTable.length) {\n                @Nullable\n                Object[] uniqueElements = shouldTrim(size, contents.length) ? Arrays.copyOf(contents, size) : contents;\n                result = new RegularImmutableSet<E>(uniqueElements, hashCode, hashTable, hashTable.length - 1, size);\n            } else {\n                result = construct(size, contents);\n                // construct has the side effect of deduping contents, so we update size\n                // accordingly.\n                size = result.size();\n            }\n            forceCopy = true;\n            hashTable = null;\n            return result;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created {@code ImmutableSet} based on the contents of the {@code Builder}.\n */\n", "repo_name": "guava-master/", "id": 6460, "method_signature": "ImmutableSet<E> build()", "filename": "ImmutableSet.build.json"}
{"callee_method_names": [], "method_name": "ImmutableSet.chooseTableSize", "method_implementation": "{\n    setSize = Math.max(setSize, 2);\n    // Correct the size for open addressing to match desired load factor.\n    if (setSize < CUTOFF) {\n        // Round up to the next highest power of 2.\n        int tableSize = Integer.highestOneBit(setSize - 1) << 1;\n        while (tableSize * DESIRED_LOAD_FACTOR < setSize) {\n            tableSize <<= 1;\n        }\n        return tableSize;\n    }\n    // The table can't be completely full or we'll get infinite reprobes\n    checkArgument(setSize < MAX_TABLE_SIZE, \"collection too large\");\n    return MAX_TABLE_SIZE;\n}", "repo_id": "5", "comment": "/**\n * Returns an array size suitable for the backing array of a hash table that uses open addressing\n * with linear probing in its implementation. The returned size is the smallest power of two that\n * can hold setSize elements with the desired load factor. Always returns at least setSize + 2.\n */\n", "repo_name": "guava-master/", "id": 6451, "method_signature": "int chooseTableSize(int)", "filename": "ImmutableSet.chooseTableSize.json"}
{"callee_method_names": ["SetBuilderImpl<E>.add"], "method_name": "ImmutableSet.combine", "method_implementation": "{\n    SetBuilderImpl<E> result = this;\n    for (int i = 0; i < other.distinct; i++) {\n        /*\n         * requireNonNull is safe because we ensure that the first `distinct` elements have been\n         * populated.\n         */\n        result = result.add(requireNonNull(other.dedupedElements[i]));\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Adds all the elements from the specified SetBuilderImpl to this SetBuilderImpl.\n */\n", "repo_name": "guava-master/", "id": 3087, "method_signature": "SetBuilderImpl<E> combine(SetBuilderImpl)", "filename": "ImmutableSet.combine.json"}
{"callee_method_names": ["E.hashCode", "Object.equals"], "method_name": "ImmutableSet.construct", "method_implementation": "{\n    switch(n) {\n        case 0:\n            return of();\n        case 1:\n            // safe; elements contains only E's\n            @SuppressWarnings(\"unchecked\")\n            E // requireNonNull is safe because the first `n` elements are non-null.\n            elem = (E) requireNonNull(elements[0]);\n            return of(elem);\n        default:\n    }\n    int tableSize = chooseTableSize(n);\n    Object[] table = new Object[tableSize];\n    int mask = tableSize - 1;\n    int hashCode = 0;\n    int uniques = 0;\n    for (int i = 0; i < n; i++) {\n        Object element = checkElementNotNull(elements[i], i);\n        int hash = element.hashCode();\n        for (int j = Hashing.smear(hash); ; j++) {\n            int index = j & mask;\n            Object value = table[index];\n            if (value == null) {\n                // Came to an empty slot. Put the element here.\n                elements[uniques++] = element;\n                table[index] = element;\n                hashCode += hash;\n                break;\n            } else if (value.equals(element)) {\n                break;\n            }\n        }\n    }\n    Arrays.fill(elements, uniques, n, null);\n    if (uniques == 1) {\n        // There is only one element or elements are all duplicates\n        // we are careful to only pass in E\n        @SuppressWarnings(\"unchecked\")\n        E // requireNonNull is safe because the first `uniques` elements are non-null.\n        element = (E) requireNonNull(elements[0]);\n        return new SingletonImmutableSet<E>(element);\n    } else if (chooseTableSize(uniques) < tableSize / 2) {\n        // Resize the table when the array includes too many duplicates.\n        return construct(uniques, elements);\n    } else {\n        @Nullable\n        Object[] uniqueElements = shouldTrim(uniques, elements.length) ? Arrays.copyOf(elements, uniques) : elements;\n        return new RegularImmutableSet<E>(uniqueElements, hashCode, table, mask, uniques);\n    }\n}", "repo_id": "5", "comment": "/**\n * Constructs an {@code ImmutableSet} from the first {@code n} elements of the specified array. If\n * {@code k} is the size of the returned {@code ImmutableSet}, then the unique elements of {@code\n * elements} will be in the first {@code k} positions, and {@code elements[i] == null} for {@code\n * k <= i < n}.\n *\n * <p>After this method returns, {@code elements} will contain no duplicates, but {@code elements}\n * may be the real array backing the returned set, so do not modify it further.\n *\n * <p>{@code elements} may contain only values of type {@code E}.\n *\n * @throws NullPointerException if any of the first {@code n} elements of {@code elements} is null\n */\n", "repo_name": "guava-master/", "id": 6450, "method_signature": "ImmutableSet<E> construct(int, Object[])", "filename": "ImmutableSet.construct.json"}
{"callee_method_names": ["E[].clone"], "method_name": "ImmutableSet.copyOf", "method_implementation": "{\n    switch(elements.length) {\n        case 0:\n            return of();\n        case 1:\n            return of(elements[0]);\n        default:\n            return construct(elements.length, elements.clone());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n * each appears first in the source array.\n *\n * @throws NullPointerException if any of {@code elements} is null\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 6455, "method_signature": "ImmutableSet<E> copyOf(E[])", "filename": "ImmutableSet.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableSet.ensureCapacity", "method_implementation": "{\n    if (minCapacity > dedupedElements.length) {\n        int newCapacity = ImmutableCollection.Builder.expandedCapacity(dedupedElements.length, minCapacity);\n        dedupedElements = Arrays.copyOf(dedupedElements, newCapacity);\n    }\n}", "repo_id": "5", "comment": "/**\n * Resizes internal data structures if necessary to store the specified number of distinct\n * elements.\n */\n", "repo_name": "guava-master/", "id": 3086, "method_signature": "void ensureCapacity(int)", "filename": "ImmutableSet.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "ImmutableSet.hashFloodingDetected", "method_implementation": "{\n    int maxRunBeforeFallback = maxRunBeforeFallback(hashTable.length);\n    int mask = hashTable.length - 1;\n    // Invariant: all elements at indices in [knownRunStart, knownRunEnd) are nonnull.\n    // If knownRunStart == knownRunEnd, this is vacuously true.\n    // When knownRunEnd exceeds hashTable.length, it \"wraps\", detecting runs around the end\n    // of the table.\n    int knownRunStart = 0;\n    int knownRunEnd = 0;\n    outerLoop: while (knownRunStart < hashTable.length) {\n        if (knownRunStart == knownRunEnd && hashTable[knownRunStart] == null) {\n            if (hashTable[(knownRunStart + maxRunBeforeFallback - 1) & mask] == null) {\n                // There are only maxRunBeforeFallback - 1 elements between here and there,\n                // so even if they were all nonnull, we wouldn't detect a hash flood.  Therefore,\n                // we can skip them all.\n                knownRunStart += maxRunBeforeFallback;\n            } else {\n                // the only case in which maxRunEnd doesn't increase by mRBF\n                knownRunStart++;\n                // happens about f * (1-f) for f = DESIRED_LOAD_FACTOR, so around 21% of the time\n            }\n            knownRunEnd = knownRunStart;\n        } else {\n            for (int j = knownRunStart + maxRunBeforeFallback - 1; j >= knownRunEnd; j--) {\n                if (hashTable[j & mask] == null) {\n                    knownRunEnd = knownRunStart + maxRunBeforeFallback;\n                    knownRunStart = j + 1;\n                    continue outerLoop;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Checks the whole hash table for poor hash distribution. Takes O(n) in the worst case, O(n /\n * log n) on average.\n *\n * <p>The online hash flooding detecting in RegularSetBuilderImpl.add can detect e.g. many\n * exactly matching hash codes, which would cause construction to take O(n^2), but can't detect\n * e.g. hash codes adversarially designed to go into ascending table locations, which keeps\n * construction O(n) (as desired) but then can have O(n) queries later.\n *\n * <p>If this returns false, then no query can take more than O(log n).\n *\n * <p>Note that for a RegularImmutableSet with elements with truly random hash codes, contains\n * operations take expected O(1) time but with high probability take O(log n) for at least some\n * element. (https://en.wikipedia.org/wiki/Linear_probing#Analysis)\n *\n * <p>This method may return {@code true} even on truly random input, but {@code\n * ImmutableSetTest} tests that the probability of that is low.\n */\n", "repo_name": "guava-master/", "id": 3090, "method_signature": "boolean hashFloodingDetected(Object[])", "filename": "ImmutableSet.hashFloodingDetected.json"}
{"callee_method_names": [], "method_name": "ImmutableSet.of", "method_implementation": "{\n    checkArgument(others.length <= Integer.MAX_VALUE - 6, \"the total number of elements must fit in an int\");\n    final int paramCount = 6;\n    Object[] elements = new Object[paramCount + others.length];\n    elements[0] = e1;\n    elements[1] = e2;\n    elements[2] = e3;\n    elements[3] = e4;\n    elements[4] = e5;\n    elements[5] = e6;\n    System.arraycopy(others, 0, elements, paramCount, others.length);\n    return construct(elements.length, elements);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n * the first are ignored.\n *\n * <p>The array {@code others} must not be longer than {@code Integer.MAX_VALUE - 6}.\n *\n * @since 3.0 (source-compatible since 2.0)\n */\n", "repo_name": "guava-master/", "id": 6449, "method_signature": "ImmutableSet<E> of(E, E, E, E, E, E, E[])", "filename": "ImmutableSet.of.json"}
{"callee_method_names": ["Object.hashCode"], "method_name": "ImmutableSet.rebuildHashTable", "method_implementation": "{\n    @Nullable\n    Object[] hashTable = new @Nullable Object[newTableSize];\n    int mask = hashTable.length - 1;\n    for (int i = 0; i < n; i++) {\n        // requireNonNull is safe because we ensure that the first n elements have been populated.\n        Object e = requireNonNull(elements[i]);\n        int j0 = Hashing.smear(e.hashCode());\n        for (int j = j0; ; j++) {\n            int index = j & mask;\n            if (hashTable[index] == null) {\n                hashTable[index] = e;\n                break;\n            }\n        }\n    }\n    return hashTable;\n}", "repo_id": "5", "comment": "/**\n * Builds a new open-addressed hash table from the first n objects in elements.\n */\n", "repo_name": "guava-master/", "id": 3089, "method_signature": "Object[] rebuildHashTable(int, Object[], int)", "filename": "ImmutableSet.rebuildHashTable.json"}
{"callee_method_names": [], "method_name": "ImmutableSet.toImmutableSet", "method_implementation": "{\n    return CollectCollectors.toImmutableSet();\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates the input elements into a new {@code\n * ImmutableSet}. Elements appear in the resulting set in the encounter order of the stream; if\n * the stream contains duplicates (according to {@link Object#equals(Object)}), only the first\n * duplicate in encounter order will appear in the result.\n */\n", "repo_name": "guava-master/", "id": 6448, "method_signature": "Collector<E,?,ImmutableSet<E>> toImmutableSet()", "filename": "ImmutableSet.toImmutableSet.json"}
{"callee_method_names": ["Set<E>.size", "Set<E>.iterator"], "method_name": "ImmutableSet.unsafeDelegate", "method_implementation": "{\n    switch(delegate.size()) {\n        case 0:\n            return of();\n        case 1:\n            return new SingletonImmutableSet<E>(delegate.iterator().next());\n        default:\n            return new RegularImmutableSet<E>(delegate);\n    }\n}", "repo_id": "5", "comment": "// the elements are known to be non-null.\n", "repo_name": "guava-master/", "id": 6825, "method_signature": "ImmutableSet<E> unsafeDelegate(Set)", "filename": "ImmutableSet.unsafeDelegate.json"}
{"callee_method_names": [], "method_name": "ImmutableSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 3084, "method_signature": "Object writeReplace()", "filename": "ImmutableSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.build", "method_implementation": "{\n    Collection<Map.Entry<K, Collection<V>>> mapEntries = builderMap.entrySet();\n    if (keyComparator != null) {\n        mapEntries = Ordering.from(keyComparator).<K>onKeys().immutableSortedCopy(mapEntries);\n    }\n    return fromMapEntries(mapEntries, valueComparator);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created immutable set multimap.\n */\n", "repo_name": "guava-master/", "id": 6432, "method_signature": "ImmutableSetMultimap<K,V> build()", "filename": "ImmutableSetMultimap.build.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.entries", "method_implementation": "{\n    ImmutableSet<Entry<K, V>> result = entries;\n    return result == null ? (entries = new EntrySet<>(this)) : result;\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable collection of all key-value pairs in the multimap. Its iterator traverses\n * the values for the first key, the values for the second key, and so on.\n */\n", "repo_name": "guava-master/", "id": 6438, "method_signature": "ImmutableSet<Entry<K,V>> entries()", "filename": "ImmutableSetMultimap.entries.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.flatteningToImmutableSetMultimap", "method_implementation": "{\n    return CollectCollectors.flatteningToImmutableSetMultimap(keyFunction, valuesFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} accumulating entries into an {@code ImmutableSetMultimap}. Each\n * input element is mapped to a key and a stream of values, each of which are put into the\n * resulting {@code Multimap}, in the encounter order of the stream and the encounter order of the\n * streams of values.\n *\n * <p>Example:\n *\n * <pre>{@code\n * static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n *         .collect(\n *             flatteningToImmutableSetMultimap(\n *                  str -> str.charAt(0),\n *                  str -> str.substring(1).chars().mapToObj(c -> (char) c));\n *\n * // is equivalent to\n *\n * static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n *     ImmutableSetMultimap.<Character, Character>builder()\n *         .putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'))\n *         .putAll('a', Arrays.asList('p', 'p', 'l', 'e'))\n *         .putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'))\n *         .putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'))\n *         .putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'))\n *         .build();\n *\n * // after deduplication, the resulting multimap is equivalent to\n *\n * static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n *     ImmutableSetMultimap.<Character, Character>builder()\n *         .putAll('b', Arrays.asList('a', 'n'))\n *         .putAll('a', Arrays.asList('p', 'l', 'e', 's', 'a', 'r', 'g', 'u'))\n *         .putAll('c', Arrays.asList('a', 'r', 'o', 't', 'h', 'e', 'y'))\n *         .build();\n * }\n * }</pre>\n */\n", "repo_name": "guava-master/", "id": 6421, "method_signature": "Collector<T,?,ImmutableSetMultimap<K,V>> flatteningToImmutableSetMultimap(Function, Function)", "filename": "ImmutableSetMultimap.flatteningToImmutableSetMultimap.json"}
{"callee_method_names": ["Collection<? extends Map.Entry<? extends K,? extends Collection<? extends V>>>.isEmpty", "Collection<? extends Map.Entry<? extends K,? extends Collection<? extends V>>>.size", "Entry<? extends K,? extends V>.getKey", "Entry<? extends K,? extends V>.getValue", "ImmutableSet<V>.isEmpty", "ImmutableMap.Builder<K, ImmutableSet<V>>.put", "ImmutableSet<V>.size", "ImmutableMap.Builder<K, ImmutableSet<V>>.buildOrThrow"], "method_name": "ImmutableSetMultimap.fromMapEntries", "method_implementation": "{\n    if (mapEntries.isEmpty()) {\n        return of();\n    }\n    ImmutableMap.Builder<K, ImmutableSet<V>> builder = new ImmutableMap.Builder<>(mapEntries.size());\n    int size = 0;\n    for (Entry<? extends K, ? extends Collection<? extends V>> entry : mapEntries) {\n        K key = entry.getKey();\n        Collection<? extends V> values = entry.getValue();\n        ImmutableSet<V> set = valueSet(valueComparator, values);\n        if (!set.isEmpty()) {\n            builder.put(key, set);\n            size += set.size();\n        }\n    }\n    return new ImmutableSetMultimap<>(builder.buildOrThrow(), size, valueComparator);\n}", "repo_id": "5", "comment": "/**\n * Creates an ImmutableSetMultimap from an asMap.entrySet.\n */\n", "repo_name": "guava-master/", "id": 6433, "method_signature": "ImmutableSetMultimap<K,V> fromMapEntries(Collection, Comparator)", "filename": "ImmutableSetMultimap.fromMapEntries.json"}
{"callee_method_names": ["Map<C, V>.get"], "method_name": "ImmutableSetMultimap.get", "method_implementation": "{\n    // This cast is safe as its type is known in constructor.\n    ImmutableSet<V> set = (ImmutableSet<V>) map.get(key);\n    return MoreObjects.firstNonNull(set, emptySet);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable set of the values for the given key. If no mappings in the multimap have\n * the provided key, an empty immutable set is returned. The values are in the same order as the\n * parameters used to build this multimap.\n */\n", "repo_name": "guava-master/", "id": 6434, "method_signature": "ImmutableSet<V> get(K)", "filename": "ImmutableSetMultimap.get.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.inverse", "method_implementation": "{\n    ImmutableSetMultimap<V, K> result = inverse;\n    return (result == null) ? (inverse = invert()) : result;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Because an inverse of a set multimap cannot contain multiple pairs with the same key and\n * value, this method returns an {@code ImmutableSetMultimap} rather than the {@code\n * ImmutableMultimap} specified in the {@code ImmutableMultimap} class.\n */\n", "repo_name": "guava-master/", "id": 6435, "method_signature": "ImmutableSetMultimap<V,K> inverse()", "filename": "ImmutableSetMultimap.inverse.json"}
{"callee_method_names": ["ImmutableSetMultimap.Builder<K, V>.put", "ImmutableSetMultimap.Builder<K, V>.put", "ImmutableSetMultimap.Builder<K, V>.put", "ImmutableSetMultimap.Builder<K, V>.put", "ImmutableSetMultimap.Builder<K, V>.put", "ImmutableSetMultimap.Builder<K, V>.build"], "method_name": "ImmutableSetMultimap.of", "method_implementation": "{\n    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n    builder.put(k1, v1);\n    builder.put(k2, v2);\n    builder.put(k3, v3);\n    builder.put(k4, v4);\n    builder.put(k5, v5);\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable multimap containing the given entries, in order. Repeated occurrences of\n * an entry (according to {@link Object#equals}) after the first are ignored.\n */\n", "repo_name": "guava-master/", "id": 6426, "method_signature": "ImmutableSetMultimap<K,V> of(K, V, K, V, K, V, K, V, K, V)", "filename": "ImmutableSetMultimap.of.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.orderKeysBy", "method_implementation": "{\n    super.orderKeysBy(keyComparator);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6430, "method_signature": "Builder<K,V> orderKeysBy(Comparator)", "filename": "ImmutableSetMultimap.orderKeysBy.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.orderValuesBy", "method_implementation": "{\n    super.orderValuesBy(valueComparator);\n    return this;\n}", "repo_id": "5", "comment": "// TODO: Make serialization behavior consistent.\n", "repo_name": "guava-master/", "id": 6431, "method_signature": "Builder<K,V> orderValuesBy(Comparator)", "filename": "ImmutableSetMultimap.orderValuesBy.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.put", "method_implementation": "{\n    super.put(entry);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds an entry to the built multimap if it is not already present.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 6428, "method_signature": "Builder<K,V> put(Entry)", "filename": "ImmutableSetMultimap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.putAll", "method_implementation": "{\n    super.putAll(entries);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 6429, "method_signature": "Builder<K,V> putAll(Iterable)", "filename": "ImmutableSetMultimap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.removeAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6436, "method_signature": "ImmutableSet<V> removeAll(Object)", "filename": "ImmutableSetMultimap.removeAll.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.replaceValues", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the multimap unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6437, "method_signature": "ImmutableSet<V> replaceValues(K, Iterable)", "filename": "ImmutableSetMultimap.replaceValues.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.toImmutableSetMultimap", "method_implementation": "{\n    return CollectCollectors.toImmutableSetMultimap(keyFunction, valueFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} that accumulates elements into an {@code ImmutableSetMultimap}\n * whose keys and values are the result of applying the provided mapping functions to the input\n * elements.\n *\n * <p>For streams with defined encounter order (as defined in the Ordering section of the {@link\n * java.util.stream} Javadoc), that order is preserved, but entries are <a\n * href=\"ImmutableMultimap.html#iteration\">grouped by key</a>.\n *\n * <p>Example:\n *\n * <pre>{@code\n * static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n *         .collect(toImmutableSetMultimap(str -> str.charAt(0), str -> str.substring(1)));\n *\n * // is equivalent to\n *\n * static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n *     new ImmutableSetMultimap.Builder<Character, String>()\n *         .put('b', \"anana\")\n *         .putAll('a', \"pple\", \"sparagus\")\n *         .putAll('c', \"arrot\", \"herry\")\n *         .build();\n * }</pre>\n */\n", "repo_name": "guava-master/", "id": 6420, "method_signature": "Collector<T,?,ImmutableSetMultimap<K,V>> toImmutableSetMultimap(Function, Function)", "filename": "ImmutableSetMultimap.toImmutableSetMultimap.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject"], "method_name": "ImmutableSetMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(valueComparator());\n    Serialization.writeMultimap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData number of distinct keys, and then for each distinct key: the key, the number of\n *     values for that key, and the key's values\n */\n", "repo_name": "guava-master/", "id": 6440, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "ImmutableSetMultimap.writeObject.json"}
{"callee_method_names": [], "method_name": "ImmutableSetMultimap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6439, "method_signature": "Object writeReplace()", "filename": "ImmutableSetMultimap.writeReplace.json"}
{"callee_method_names": ["ImmutableSetMultimap.Builder<String, Integer>.combine", "ImmutableSetMultimap<String, Integer>.keySet", "ImmutableSetMultimap<String, Integer>.values", "ImmutableSetMultimap<String, Integer>.get", "ImmutableSetMultimap<String, Integer>.get", "ImmutableSetMultimap<String, Integer>.get"], "method_name": "ImmutableSetMultimapTest.testToImmutableSetMultimap_java7_combine", "method_implementation": "{\n    ImmutableSetMultimap.Builder<String, Integer> zis = ImmutableSetMultimap.<String, Integer>builder().put(\"a\", 1).put(\"b\", 2);\n    ImmutableSetMultimap.Builder<String, Integer> zat = ImmutableSetMultimap.<String, Integer>builder().put(\"a\", 3).put(\"c\", 4);\n    ImmutableSetMultimap<String, Integer> multimap = zis.combine(zat).build();\n    assertThat(multimap.keySet()).containsExactly(\"a\", \"b\", \"c\").inOrder();\n    assertThat(multimap.values()).containsExactly(1, 3, 2, 4).inOrder();\n    assertThat(multimap.get(\"a\")).containsExactly(1, 3).inOrder();\n    assertThat(multimap.get(\"b\")).containsExactly(2);\n    assertThat(multimap.get(\"c\")).containsExactly(4);\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableSetMultimap once CollectorTester is usable.\n", "repo_name": "guava-master/", "id": 4025, "method_signature": "void testToImmutableSetMultimap_java7_combine()", "filename": "ImmutableSetMultimapTest.testToImmutableSetMultimap_java7_combine.json"}
{"callee_method_names": ["ImmutableSet.Builder<String>.combine"], "method_name": "ImmutableSetTest.testToImmutableSet_java7", "method_implementation": "{\n    ImmutableSet.Builder<String> zis = ImmutableSet.<String>builder().add(\"a\", \"b\", \"a\");\n    ImmutableSet.Builder<String> zat = ImmutableSet.<String>builder().add(\"c\", \"b\", \"d\", \"c\");\n    ImmutableSet<String> set = zis.combine(zat).build();\n    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\").inOrder();\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableSet once CollectorTester is usable to java7.\n", "repo_name": "guava-master/", "id": 3937, "method_signature": "void testToImmutableSet_java7()", "filename": "ImmutableSetTest.testToImmutableSet_java7.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedAsList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2461, "method_signature": "Object writeReplace()", "filename": "ImmutableSortedAsList.writeReplace.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.buildKeepingLast", "method_implementation": "{\n    // TODO(emcmanus): implement\n    throw new UnsupportedOperationException(\"ImmutableSortedMap.Builder does not yet implement buildKeepingLast()\");\n}", "repo_id": "5", "comment": "/**\n * Throws UnsupportedOperationException. A future version may support this operation. Then the\n * value for any given key will be the one that was last supplied in a {@code put} operation for\n * that key.\n *\n * @throws UnsupportedOperationException always\n * @since 31.1\n * @deprecated This method is not currently implemented, and may never be.\n */\n", "repo_name": "guava-master/", "id": 5772, "method_signature": "ImmutableSortedMap<K,V> buildKeepingLast()", "filename": "ImmutableSortedMap.buildKeepingLast.json"}
{"callee_method_names": ["Comparator<? super K>.compare"], "method_name": "ImmutableSortedMap.buildOrThrow", "method_implementation": "{\n    switch(size) {\n        case 0:\n            return emptyMap(comparator);\n        case 1:\n            // requireNonNull is safe because the first `size` elements have been filled in.\n            return of(comparator, (K) requireNonNull(keys[0]), (V) requireNonNull(values[0]));\n        default:\n            Object[] sortedKeys = Arrays.copyOf(keys, size);\n            Arrays.sort((K[]) sortedKeys, comparator);\n            Object[] sortedValues = new Object[size];\n            // We might, somehow, be able to reorder values in-place.  But it doesn't seem like\n            // there's a way around creating the separate sortedKeys array, and if we're allocating\n            // one array of size n, we might as well allocate two -- to say nothing of the allocation\n            // done in Arrays.sort.\n            for (int i = 0; i < size; i++) {\n                if (i > 0 && comparator.compare((K) sortedKeys[i - 1], (K) sortedKeys[i]) == 0) {\n                    throw new IllegalArgumentException(\"keys required to be distinct but compared as equal: \" + sortedKeys[i - 1] + \" and \" + sortedKeys[i]);\n                }\n                // requireNonNull is safe because the first `size` elements have been filled in.\n                int index = Arrays.binarySearch((K[]) sortedKeys, (K) requireNonNull(keys[i]), comparator);\n                sortedValues[index] = requireNonNull(values[i]);\n            }\n            return new ImmutableSortedMap<K, V>(new RegularImmutableSortedSet<K>(ImmutableList.<K>asImmutableList(sortedKeys), comparator), ImmutableList.<V>asImmutableList(sortedValues));\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created immutable sorted map, or throws an exception if any two keys are\n * equal.\n *\n * @throws IllegalArgumentException if any two keys are equal according to the comparator (which\n *     might be the keys' natural order)\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 5771, "method_signature": "ImmutableSortedMap<K,V> buildOrThrow()", "filename": "ImmutableSortedMap.buildOrThrow.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.builder", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #naturalOrder}, which offers better type-safety, instead. This method\n * exists only to hide {@link ImmutableMap#builder} from consumers of {@code ImmutableSortedMap}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link ImmutableSortedMap#naturalOrder}, which offers better type-safety.\n */\n", "repo_name": "guava-master/", "id": 5780, "method_signature": "ImmutableSortedMap.Builder<K,V> builder()", "filename": "ImmutableSortedMap.builder.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.builderWithExpectedSize", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported for ImmutableSortedMap.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Not supported for ImmutableSortedMap.\n */\n", "repo_name": "guava-master/", "id": 5781, "method_signature": "ImmutableSortedMap.Builder<K,V> builderWithExpectedSize(int)", "filename": "ImmutableSortedMap.builderWithExpectedSize.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.copyOf", "method_implementation": "{\n    return fromEntries(checkNotNull(comparator), false, entries);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the given entries, with keys sorted by the provided\n * comparator.\n *\n * @throws NullPointerException if any key or value in {@code map} is null\n * @throws IllegalArgumentException if any two keys are equal according to the comparator\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 5763, "method_signature": "ImmutableSortedMap<K,V> copyOf(Iterable, Comparator)", "filename": "ImmutableSortedMap.copyOf.json"}
{"callee_method_names": ["SortedMap<K,? extends V>.comparator", "ImmutableSortedMap<K, V>.isPartialView", "SortedMap<K,? extends V>.entrySet"], "method_name": "ImmutableSortedMap.copyOfSorted", "method_implementation": "{\n    Comparator<? super K> comparator = map.comparator();\n    if (comparator == null) {\n        // If map has a null comparator, the keys should have a natural ordering,\n        // even though K doesn't explicitly implement Comparable.\n        comparator = (Comparator<? super K>) NATURAL_ORDER;\n    }\n    if (map instanceof ImmutableSortedMap) {\n        // TODO(kevinb): Prove that this cast is safe, even though\n        // Collections.unmodifiableSortedMap requires the same key type.\n        @SuppressWarnings(\"unchecked\")\n        ImmutableSortedMap<K, V> kvMap = (ImmutableSortedMap<K, V>) map;\n        if (!kvMap.isPartialView()) {\n            return kvMap;\n        }\n    }\n    return fromEntries(comparator, true, map.entrySet());\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map containing the same entries as the provided sorted map, with the same\n * ordering.\n *\n * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n * safe to do so. The exact circumstances under which a copy will or will not be performed are\n * undocumented and subject to change.\n *\n * @throws NullPointerException if any key or value in {@code map} is null\n */\n", "repo_name": "guava-master/", "id": 5764, "method_signature": "ImmutableSortedMap<K,V> copyOfSorted(SortedMap)", "filename": "ImmutableSortedMap.copyOfSorted.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.fromEntries", "method_implementation": "{\n    // \"adding\" type params to an array of a raw type should be safe as\n    // long as no one can ever cast that same array instance back to a\n    // raw type.\n    @SuppressWarnings(\"unchecked\")\n    Entry<K, V>[] entryArray = (Entry[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);\n    return fromEntries(comparator, sameComparator, entryArray, entryArray.length);\n}", "repo_id": "5", "comment": "/**\n * Accepts a collection of possibly-null entries. If {@code sameComparator}, then it is assumed\n * that they do not need to be sorted or checked for dupes.\n */\n", "repo_name": "guava-master/", "id": 5765, "method_signature": "ImmutableSortedMap<K,V> fromEntries(Comparator, boolean, Iterable)", "filename": "ImmutableSortedMap.fromEntries.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.of", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}\n * keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this\n * dummy version.\n *\n * @throws UnsupportedOperationException always\n * @deprecated <b>Pass keys of type {@code Comparable} to use {@link\n *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,\n *     Comparable, Object, Comparable, Object)}.</b>\n */\n", "repo_name": "guava-master/", "id": 5791, "method_signature": "ImmutableSortedMap<K,V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V)", "filename": "ImmutableSortedMap.of.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.ofEntries", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@code ImmutableSortedMap.copyOf(ImmutableMap.ofEntries(...))}.\n *\n * @deprecated Use {@code ImmutableSortedMap.copyOf(ImmutableMap.ofEntries(...))}.\n */\n", "repo_name": "guava-master/", "id": 5792, "method_signature": "ImmutableSortedMap<K,V> ofEntries(Entry<? extends K,? extends V>[])", "filename": "ImmutableSortedMap.ofEntries.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.orderEntriesByValue", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not available on ImmutableSortedMap.Builder\");\n}", "repo_id": "5", "comment": "/**\n * Throws an {@code UnsupportedOperationException}.\n *\n * @since 19.0\n * @deprecated Unsupported by ImmutableSortedMap.Builder.\n */\n", "repo_name": "guava-master/", "id": 5770, "method_signature": "Builder<K,V> orderEntriesByValue(Comparator)", "filename": "ImmutableSortedMap.orderEntriesByValue.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.pollFirstEntry", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5776, "method_signature": "Entry<K,V> pollFirstEntry()", "filename": "ImmutableSortedMap.pollFirstEntry.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.pollLastEntry", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5777, "method_signature": "Entry<K,V> pollLastEntry()", "filename": "ImmutableSortedMap.pollLastEntry.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.put", "method_implementation": "{\n    super.put(entry);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds the given {@code entry} to the map, making it immutable if necessary. Duplicate keys,\n * according to the comparator (which might be the keys' natural order), are not allowed, and\n * will cause {@link #build} to fail.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 5767, "method_signature": "Builder<K,V> put(Entry)", "filename": "ImmutableSortedMap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.putAll", "method_implementation": "{\n    super.putAll(entries);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds all the given entries to the built map. Duplicate keys, according to the comparator\n * (which might be the keys' natural order), are not allowed, and will cause {@link #build} to\n * fail.\n *\n * @throws NullPointerException if any key, value, or entry is null\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 5769, "method_signature": "Builder<K,V> putAll(Iterable)", "filename": "ImmutableSortedMap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.subMap", "method_implementation": "{\n    checkNotNull(fromKey);\n    checkNotNull(toKey);\n    checkArgument(comparator().compare(fromKey, toKey) <= 0, \"expected fromKey <= toKey but %s > %s\", fromKey, toKey);\n    return headMap(toKey, toInclusive).tailMap(fromKey, fromInclusive);\n}", "repo_id": "5", "comment": "/**\n * This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys ranges\n * from {@code fromKey} to {@code toKey}, inclusive or exclusive as indicated by the boolean\n * flags.\n *\n * <p>The {@link SortedMap#subMap} documentation states that a submap of a submap throws an {@link\n * IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code fromKey}.\n * However, this method doesn't throw an exception in that situation, but instead keeps the\n * original {@code fromKey}. Similarly, this method keeps the original {@code toKey}, instead of\n * throwing an exception, if passed a {@code toKey} greater than an earlier {@code toKey}.\n *\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5775, "method_signature": "ImmutableSortedMap<K,V> subMap(K, boolean, K, boolean)", "filename": "ImmutableSortedMap.subMap.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.toImmutableMap", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #toImmutableSortedMap}, which offers better type-safety, instead.\n * This method exists only to hide {@link ImmutableMap#toImmutableMap} from consumers of {@code\n * ImmutableSortedMap}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.\n */\n", "repo_name": "guava-master/", "id": 5779, "method_signature": "Collector<T,?,ImmutableMap<K,V>> toImmutableMap(Function, Function, BinaryOperator)", "filename": "ImmutableSortedMap.toImmutableMap.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.toImmutableSortedMap", "method_implementation": "{\n    return CollectCollectors.toImmutableSortedMap(comparator, keyFunction, valueFunction, mergeFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} that accumulates elements into an {@code ImmutableSortedMap} whose\n * keys and values are the result of applying the provided mapping functions to the input\n * elements.\n *\n * <p>If the mapped keys contain duplicates (according to the comparator), the values are merged\n * using the specified merging function. Entries will appear in the encounter order of the first\n * occurrence of the key.\n */\n", "repo_name": "guava-master/", "id": 5749, "method_signature": "Collector<T,?,ImmutableSortedMap<K,V>> toImmutableSortedMap(Comparator, Function, Function, BinaryOperator)", "filename": "ImmutableSortedMap.toImmutableSortedMap.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5774, "method_signature": "Object writeReplace()", "filename": "ImmutableSortedMap.writeReplace.json"}
{"callee_method_names": ["ImmutableSortedMap.Builder<String, Integer>.combine", "ImmutableSortedMap.Builder<String, Integer>.build"], "method_name": "ImmutableSortedMapTest.testToImmutableSortedMap_exceptionOnDuplicateKey_java7_combine", "method_implementation": "{\n    ImmutableSortedMap.Builder<String, Integer> zis = ImmutableSortedMap.<String, Integer>naturalOrder().put(\"one\", 1).put(\"two\", 2);\n    ImmutableSortedMap.Builder<String, Integer> zat = ImmutableSortedMap.<String, Integer>naturalOrder().put(\"two\", 22).put(\"three\", 3);\n    try {\n        ImmutableSortedMap.Builder<String, Integer> combined = zis.combine(zat);\n        combined.build();\n        fail(\"Expected IllegalArgumentException\");\n    } catch (IllegalArgumentException expected) {\n        // expected\n    }\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableSortedMap once CollectorTester is usable.\n", "repo_name": "guava-master/", "id": 3950, "method_signature": "void testToImmutableSortedMap_exceptionOnDuplicateKey_java7_combine()", "filename": "ImmutableSortedMapTest.testToImmutableSortedMap_exceptionOnDuplicateKey_java7_combine.json"}
{"callee_method_names": ["ImmutableSortedMap.Builder<String, Integer>.combine"], "method_name": "ImmutableSortedMapTest.testToImmutableSortedMap_java7_combine", "method_implementation": "{\n    ImmutableSortedMap.Builder<String, Integer> zis = ImmutableSortedMap.<String, Integer>naturalOrder().put(\"one\", 1).put(\"four\", 4);\n    ImmutableSortedMap.Builder<String, Integer> zat = ImmutableSortedMap.<String, Integer>naturalOrder().put(\"two\", 2).put(\"three\", 3);\n    ImmutableSortedMap<String, Integer> sortedMap = zis.combine(zat).build();\n    assertMapEquals(sortedMap, \"four\", 4, \"one\", 1, \"three\", 3, \"two\", 2);\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableSortedMap once CollectorTester is usable.\n", "repo_name": "guava-master/", "id": 3949, "method_signature": "void testToImmutableSortedMap_java7_combine()", "filename": "ImmutableSortedMapTest.testToImmutableSortedMap_java7_combine.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.add", "method_implementation": "{\n    for (E element : elements) {\n        add(element);\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n *\n * @param elements the elements to add\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5620, "method_signature": "Builder<E> add(E[])", "filename": "ImmutableSortedMultiset.add.json"}
{"callee_method_names": ["Iterator<? extends E>.hasNext", "Iterator<? extends E>.next"], "method_name": "ImmutableSortedMultiset.addAll", "method_implementation": "{\n    while (elements.hasNext()) {\n        add(elements.next());\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n *\n * @param elements the elements to add to the {@code ImmutableSortedMultiset}\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} is null or contains a null element\n */\n", "repo_name": "guava-master/", "id": 5624, "method_signature": "Builder<E> addAll(Iterator)", "filename": "ImmutableSortedMultiset.addAll.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.addCopies", "method_implementation": "{\n    checkNotNull(element);\n    CollectPreconditions.checkNonnegative(occurrences, \"occurrences\");\n    if (occurrences == 0) {\n        return this;\n    }\n    maintenance();\n    elements[length] = element;\n    counts[length] = occurrences;\n    length++;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.\n *\n * @param element the element to add\n * @param occurrences the number of occurrences of the element to add. May be zero, in which\n *     case no change will be made.\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code element} is null\n * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation\n *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element\n */\n", "repo_name": "guava-master/", "id": 5621, "method_signature": "Builder<E> addCopies(E, int)", "filename": "ImmutableSortedMultiset.addCopies.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.build", "method_implementation": "{\n    dedupAndCoalesceAndDeleteEmpty();\n    if (length == 0) {\n        return emptyMultiset(comparator);\n    }\n    RegularImmutableSortedSet<E> elementSet = (RegularImmutableSortedSet<E>) ImmutableSortedSet.construct(comparator, length, elements);\n    long[] cumulativeCounts = new long[length + 1];\n    for (int i = 0; i < length; i++) {\n        cumulativeCounts[i + 1] = cumulativeCounts[i] + counts[i];\n    }\n    forceCopyElements = true;\n    return new RegularImmutableSortedMultiset<E>(elementSet, cumulativeCounts, 0, length);\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code\n * Builder}.\n */\n", "repo_name": "guava-master/", "id": 5625, "method_signature": "ImmutableSortedMultiset<E> build()", "filename": "ImmutableSortedMultiset.build.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.builder", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #naturalOrder}, which offers better type-safety, instead. This method\n * exists only to hide {@link ImmutableMultiset#builder} from consumers of {@code\n * ImmutableSortedMultiset}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link ImmutableSortedMultiset#naturalOrder}, which offers better type-safety.\n */\n", "repo_name": "guava-master/", "id": 5628, "method_signature": "ImmutableSortedMultiset.Builder<E> builder()", "filename": "ImmutableSortedMultiset.builder.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.copyOf", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. <b>You are attempting to create a multiset that may contain non-{@code\n * Comparable} elements.</b> Proper calls will resolve to the version in {@code\n * ImmutableSortedMultiset}, not this dummy version.\n *\n * @throws UnsupportedOperationException always\n * @deprecated <b>Pass parameters of type {@code Comparable} to use {@link\n *     ImmutableSortedMultiset#copyOf(Comparable[])}.</b>\n */\n", "repo_name": "guava-master/", "id": 5635, "method_signature": "ImmutableSortedMultiset<Z> copyOf(Z[])", "filename": "ImmutableSortedMultiset.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.maintenance", "method_implementation": "{\n    if (length == elements.length) {\n        dedupAndCoalesce(true);\n    } else if (forceCopyElements) {\n        this.elements = Arrays.copyOf(elements, elements.length);\n        // we don't currently need to copy the counts array, because we don't use it directly\n        // in built ISMs\n    }\n    forceCopyElements = false;\n}", "repo_id": "5", "comment": "/**\n * Check if we need to do deduplication and coalescing, and if so, do it.\n */\n", "repo_name": "guava-master/", "id": 5618, "method_signature": "void maintenance()", "filename": "ImmutableSortedMultiset.maintenance.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.of", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. <b>You are attempting to create a multiset that may contain a non-{@code\n * Comparable} element.</b> Proper calls will resolve to the version in {@code\n * ImmutableSortedMultiset}, not this dummy version.\n *\n * @throws UnsupportedOperationException always\n * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link\n *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable,\n *     Comparable, Comparable...)} . </b>\n */\n", "repo_name": "guava-master/", "id": 5634, "method_signature": "ImmutableSortedMultiset<E> of(E, E, E, E, E, E, E[])", "filename": "ImmutableSortedMultiset.of.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.pollFirstEntry", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5616, "method_signature": "Entry<E> pollFirstEntry()", "filename": "ImmutableSortedMultiset.pollFirstEntry.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.pollLastEntry", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5617, "method_signature": "Entry<E> pollLastEntry()", "filename": "ImmutableSortedMultiset.pollLastEntry.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.setCount", "method_implementation": "{\n    checkNotNull(element);\n    CollectPreconditions.checkNonnegative(count, \"count\");\n    maintenance();\n    elements[length] = element;\n    counts[length] = ~count;\n    length++;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds or removes the necessary occurrences of an element such that the element attains the\n * desired count.\n *\n * @param element the element to add or remove occurrences of\n * @param count the desired count of the element in this multiset\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code element} is null\n * @throws IllegalArgumentException if {@code count} is negative\n */\n", "repo_name": "guava-master/", "id": 5622, "method_signature": "Builder<E> setCount(E, int)", "filename": "ImmutableSortedMultiset.setCount.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedMultiset.toImmutableMultiset", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #toImmutableSortedMultiset} instead. This method exists only to hide\n * {@link ImmutableMultiset#toImmutableMultiset} from consumers of {@code\n * ImmutableSortedMultiset}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.\n */\n", "repo_name": "guava-master/", "id": 5627, "method_signature": "Collector<T,?,ImmutableMultiset<E>> toImmutableMultiset(Function, ToIntFunction)", "filename": "ImmutableSortedMultiset.toImmutableMultiset.json"}
{"callee_method_names": ["Multiset<E>.entrySet"], "method_name": "ImmutableSortedMultiset.toImmutableSortedMultiset", "method_implementation": "{\n    checkNotNull(comparator);\n    checkNotNull(elementFunction);\n    checkNotNull(countFunction);\n    return Collector.of(() -> TreeMultiset.create(comparator), (multiset, t) -> mapAndAdd(t, multiset, elementFunction, countFunction), (multiset1, multiset2) -> {\n        multiset1.addAll(multiset2);\n        return multiset1;\n    }, (Multiset<E> multiset) -> copyOfSortedEntries(comparator, multiset.entrySet()));\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates elements into an {@code ImmutableSortedMultiset}\n * whose elements are the result of applying {@code elementFunction} to the inputs, with counts\n * equal to the result of applying {@code countFunction} to the inputs.\n *\n * <p>If the mapped elements contain duplicates (according to {@code comparator}), the first\n * occurrence in encounter order appears in the resulting multiset, with count equal to the sum of\n * the outputs of {@code countFunction.applyAsInt(t)} for each {@code t} mapped to that element.\n */\n", "repo_name": "guava-master/", "id": 5609, "method_signature": "Collector<T,?,ImmutableSortedMultiset<E>> toImmutableSortedMultiset(Comparator, Function, ToIntFunction)", "filename": "ImmutableSortedMultiset.toImmutableSortedMultiset.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.add", "method_implementation": "{\n    super.add(elements);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate\n * elements (only the first duplicate element is added).\n *\n * @param elements the elements to add\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} contains a null element\n */\n", "repo_name": "guava-master/", "id": 5869, "method_signature": "Builder<E> add(E[])", "filename": "ImmutableSortedSet.add.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.addAll", "method_implementation": "{\n    super.addAll(elements);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate\n * elements (only the first duplicate element is added).\n *\n * @param elements the elements to add to the {@code ImmutableSortedSet}\n * @return this {@code Builder} object\n * @throws NullPointerException if {@code elements} contains a null element\n */\n", "repo_name": "guava-master/", "id": 5871, "method_signature": "Builder<E> addAll(Iterator)", "filename": "ImmutableSortedSet.addAll.json"}
{"callee_method_names": ["ImmutableSortedSet<E>.size"], "method_name": "ImmutableSortedSet.build", "method_implementation": "{\n    // we're careful to put only E's in here\n    @SuppressWarnings(\"unchecked\")\n    E[] contentsArray = (E[]) contents;\n    ImmutableSortedSet<E> result = construct(comparator, size, contentsArray);\n    // we eliminated duplicates in-place in contentsArray\n    this.size = result.size();\n    this.forceCopy = true;\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created {@code ImmutableSortedSet} based on the contents of the {@code\n * Builder} and its comparator.\n */\n", "repo_name": "guava-master/", "id": 5872, "method_signature": "ImmutableSortedSet<E> build()", "filename": "ImmutableSortedSet.build.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.builder", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #naturalOrder}, which offers better type-safety, instead. This method\n * exists only to hide {@link ImmutableSet#builder} from consumers of {@code ImmutableSortedSet}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link ImmutableSortedSet#naturalOrder}, which offers better type-safety.\n */\n", "repo_name": "guava-master/", "id": 5882, "method_signature": "ImmutableSortedSet.Builder<E> builder()", "filename": "ImmutableSortedSet.builder.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.builderWithExpectedSize", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. This method exists only to hide {@link ImmutableSet#builderWithExpectedSize}\n * from consumers of {@code ImmutableSortedSet}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Not supported by ImmutableSortedSet.\n */\n", "repo_name": "guava-master/", "id": 5883, "method_signature": "ImmutableSortedSet.Builder<E> builderWithExpectedSize(int)", "filename": "ImmutableSortedSet.builderWithExpectedSize.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.ceiling", "method_implementation": "{\n    return Iterables.<@Nullable E>getFirst(tailSet(e, true), null);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5876, "method_signature": "E ceiling(E)", "filename": "ImmutableSortedSet.ceiling.json"}
{"callee_method_names": ["Comparator<? super E>.compare"], "method_name": "ImmutableSortedSet.construct", "method_implementation": "{\n    if (n == 0) {\n        return emptySet(comparator);\n    }\n    checkElementsNotNull(contents, n);\n    Arrays.sort(contents, 0, n, comparator);\n    int uniques = 1;\n    for (int i = 1; i < n; i++) {\n        E cur = contents[i];\n        E prev = contents[uniques - 1];\n        if (comparator.compare(cur, prev) != 0) {\n            contents[uniques++] = cur;\n        }\n    }\n    Arrays.fill(contents, uniques, n, null);\n    if (uniques < contents.length / 2) {\n        // Deduplication eliminated many of the elements.  We don't want to retain an arbitrarily\n        // large array relative to the number of elements, so we cap the ratio.\n        contents = Arrays.copyOf(contents, uniques);\n    }\n    return new RegularImmutableSortedSet<E>(ImmutableList.<E>asImmutableList(contents, uniques), comparator);\n}", "repo_id": "5", "comment": "/**\n * Constructs an {@code ImmutableSortedSet} from the first {@code n} elements of {@code contents}.\n * If {@code k} is the size of the returned {@code ImmutableSortedSet}, then the sorted unique\n * elements are in the first {@code k} positions of {@code contents}, and {@code contents[i] ==\n * null} for {@code k <= i < n}.\n *\n * <p>This method takes ownership of {@code contents}; do not modify {@code contents} after this\n * returns.\n *\n * @throws NullPointerException if any of the first {@code n} elements of {@code contents} is null\n */\n", "repo_name": "guava-master/", "id": 5867, "method_signature": "ImmutableSortedSet<E> construct(Comparator, int, E[])", "filename": "ImmutableSortedSet.construct.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.copyOf", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. <b>You are attempting to create a set that may contain non-{@code Comparable}\n * elements.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this\n * dummy version.\n *\n * @throws UnsupportedOperationException always\n * @deprecated <b>Pass parameters of type {@code Comparable} to use {@link\n *     ImmutableSortedSet#copyOf(Comparable[])}.</b>\n */\n", "repo_name": "guava-master/", "id": 5890, "method_signature": "ImmutableSortedSet<Z> copyOf(Z[])", "filename": "ImmutableSortedSet.copyOf.json"}
{"callee_method_names": ["ImmutableList<E>.isEmpty"], "method_name": "ImmutableSortedSet.copyOfSorted", "method_implementation": "{\n    Comparator<? super E> comparator = SortedIterables.comparator(sortedSet);\n    ImmutableList<E> list = ImmutableList.copyOf(sortedSet);\n    if (list.isEmpty()) {\n        return emptySet(comparator);\n    } else {\n        return new RegularImmutableSortedSet<E>(list, comparator);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable sorted set containing the elements of a sorted set, sorted by the same\n * {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always uses the\n * natural ordering of the elements.\n *\n * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n * safe to do so. The exact circumstances under which a copy will or will not be performed are\n * undocumented and subject to change.\n *\n * <p>This method is safe to use even when {@code sortedSet} is a synchronized or concurrent\n * collection that is currently being modified by another thread.\n *\n * @throws NullPointerException if {@code sortedSet} or any of its elements is null\n */\n", "repo_name": "guava-master/", "id": 5866, "method_signature": "ImmutableSortedSet<E> copyOfSorted(SortedSet)", "filename": "ImmutableSortedSet.copyOfSorted.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.descendingSet", "method_implementation": "{\n    // racy single-check idiom\n    ImmutableSortedSet<E> result = descendingSet;\n    if (result == null) {\n        result = descendingSet = createDescendingSet();\n        result.descendingSet = this;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5880, "method_signature": "ImmutableSortedSet<E> descendingSet()", "filename": "ImmutableSortedSet.descendingSet.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.floor", "method_implementation": "{\n    return Iterators.<@Nullable E>getNext(headSet(e, true).descendingIterator(), null);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5875, "method_signature": "E floor(E)", "filename": "ImmutableSortedSet.floor.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.higher", "method_implementation": "{\n    return Iterables.<@Nullable E>getFirst(tailSet(e, false), null);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5877, "method_signature": "E higher(E)", "filename": "ImmutableSortedSet.higher.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.lower", "method_implementation": "{\n    return Iterators.<@Nullable E>getNext(headSet(e, false).descendingIterator(), null);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5874, "method_signature": "E lower(E)", "filename": "ImmutableSortedSet.lower.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.of", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable}\n * element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this\n * dummy version.\n *\n * @throws UnsupportedOperationException always\n * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link\n *     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable, Comparable,\n *     Comparable, Comparable...)}. </b>\n */\n", "repo_name": "guava-master/", "id": 5889, "method_signature": "ImmutableSortedSet<E> of(E, E, E, E, E, E, E[])", "filename": "ImmutableSortedSet.of.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.pollFirst", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the set unmodified.\n *\n * @since 12.0\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5878, "method_signature": "E pollFirst()", "filename": "ImmutableSortedSet.pollFirst.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.pollLast", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the set unmodified.\n *\n * @since 12.0\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5879, "method_signature": "E pollLast()", "filename": "ImmutableSortedSet.pollLast.json"}
{"callee_method_names": ["Comparator<? super E>.compare"], "method_name": "ImmutableSortedSet.subSet", "method_implementation": "{\n    checkNotNull(fromElement);\n    checkNotNull(toElement);\n    checkArgument(comparator.compare(fromElement, toElement) <= 0);\n    return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);\n}", "repo_id": "5", "comment": "/**\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5873, "method_signature": "ImmutableSortedSet<E> subSet(E, boolean, E, boolean)", "filename": "ImmutableSortedSet.subSet.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.toImmutableSet", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #toImmutableSortedSet} instead. This method exists only to hide\n * {@link ImmutableSet#toImmutableSet} from consumers of {@code ImmutableSortedSet}.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Use {@link ImmutableSortedSet#toImmutableSortedSet}.\n */\n", "repo_name": "guava-master/", "id": 5881, "method_signature": "Collector<E,?,ImmutableSet<E>> toImmutableSet()", "filename": "ImmutableSortedSet.toImmutableSet.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSet.toImmutableSortedSet", "method_implementation": "{\n    return CollectCollectors.toImmutableSortedSet(comparator);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates the input elements into a new {@code\n * ImmutableSortedSet}, ordered by the specified comparator.\n *\n * <p>If the elements contain duplicates (according to the comparator), only the first duplicate\n * in encounter order will appear in the result.\n */\n", "repo_name": "guava-master/", "id": 5859, "method_signature": "Collector<E,?,ImmutableSortedSet<E>> toImmutableSortedSet(Comparator)", "filename": "ImmutableSortedSet.toImmutableSortedSet.json"}
{"callee_method_names": ["SortedSet<E>.isEmpty", "SortedSet<E>.comparator"], "method_name": "ImmutableSortedSet.unsafeDelegateSortedSet", "method_implementation": "{\n    return delegate.isEmpty() ? emptySet(delegate.comparator()) : new RegularImmutableSortedSet<E>(delegate, isSubset);\n}", "repo_id": "5", "comment": "// Assumes that delegate doesn't have null elements and comparator.\n", "repo_name": "guava-master/", "id": 6820, "method_signature": "ImmutableSortedSet<E> unsafeDelegateSortedSet(SortedSet, boolean)", "filename": "ImmutableSortedSet.unsafeDelegateSortedSet.json"}
{"callee_method_names": [], "method_name": "ImmutableSortedSetTest.assertNotEqualLenient", "method_implementation": "{\n    try {\n        assertThat(actual).isNotEqualTo(unexpected);\n    } catch (ClassCastException accepted) {\n    }\n}", "repo_id": "5", "comment": "// valid result thrown by java.util.TreeSet#equals.\n", "repo_name": "guava-master/", "id": 3990, "method_signature": "void assertNotEqualLenient(TreeSet, SortedSet)", "filename": "ImmutableSortedSetTest.assertNotEqualLenient.json"}
{"callee_method_names": ["ImmutableSortedSet<Interface>.toArray", "ImmutableSortedSet<Interface>.toArray"], "method_name": "ImmutableSortedSetTest.testOf_gwtArraycopyBug", "method_implementation": "{\n    /*\n     * The test requires:\n     *\n     * 1) An interface I extending Comparable<I> so that the created array is of\n     * an interface type. 2) An instance of a class implementing that interface\n     * so that we can pass non-null instances of the interface.\n     *\n     * (Currently it's safe to pass instances for which compareTo() always\n     * returns 0, but if we had a SingletonImmutableSortedSet, this might no\n     * longer be the case.)\n     *\n     * javax.naming.Name and java.util.concurrent.Delayed might work, but\n     * they're fairly obscure, we've invented our own interface and class.\n     */\n    Interface a = new Impl();\n    Interface b = new Impl();\n    ImmutableSortedSet<Interface> set = ImmutableSortedSet.of(a, b);\n    Object[] unused1 = set.toArray();\n    Object[] unused2 = set.toArray(new Object[2]);\n}", "repo_id": "5", "comment": "// TODO: test other collections for this problem\n", "repo_name": "guava-master/", "id": 3987, "method_signature": "void testOf_gwtArraycopyBug()", "filename": "ImmutableSortedSetTest.testOf_gwtArraycopyBug.json"}
{"callee_method_names": ["ImmutableSortedSet.Builder<String>.combine"], "method_name": "ImmutableSortedSetTest.testToImmutableSortedSet_customComparator_java7", "method_implementation": "{\n    // Note that a Collector should generally enforce consistent comparator between builders.\n    // So no tests for non-matching comparator shenanigans.\n    ImmutableSortedSet.Builder<String> zis = ImmutableSortedSet.<String>orderedBy(STRING_LENGTH).add(\"ccc\", \"bb\", \"ccc\");\n    ImmutableSortedSet.Builder<String> zat = ImmutableSortedSet.<String>orderedBy(STRING_LENGTH).add(\"a\", \"bb\", \"dddd\", \"ccc\");\n    ImmutableSortedSet<String> sortedSet = zis.combine(zat).build();\n    assertThat(sortedSet).containsExactly(\"a\", \"bb\", \"ccc\", \"dddd\").inOrder();\n}", "repo_id": "5", "comment": "//  is usable to java7.\n", "repo_name": "guava-master/", "id": 3989, "method_signature": "void testToImmutableSortedSet_customComparator_java7()", "filename": "ImmutableSortedSetTest.testToImmutableSortedSet_customComparator_java7.json"}
{"callee_method_names": ["ImmutableSortedSet.Builder<String>.combine"], "method_name": "ImmutableSortedSetTest.testToImmutableSortedSet_java7", "method_implementation": "{\n    // Note that a Collector should generally enforce consistent comparator between builders\n    ImmutableSortedSet.Builder<String> zis = ImmutableSortedSet.<String>naturalOrder().add(\"c\", \"b\", \"c\");\n    ImmutableSortedSet.Builder<String> zat = ImmutableSortedSet.<String>naturalOrder().add(\"a\", \"b\", \"d\", \"c\");\n    ImmutableSortedSet<String> sortedSet = zis.combine(zat).build();\n    assertThat(sortedSet).containsExactly(\"a\", \"b\", \"c\", \"d\").inOrder();\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableSortedSet once CollectorTester is usable.\n", "repo_name": "guava-master/", "id": 3988, "method_signature": "void testToImmutableSortedSet_java7()", "filename": "ImmutableSortedSetTest.testToImmutableSortedSet_java7.json"}
{"callee_method_names": ["List<Cell<R, C, V>>.size"], "method_name": "ImmutableTable.buildOrThrow", "method_implementation": "{\n    int size = cells.size();\n    switch(size) {\n        case 0:\n            return of();\n        case 1:\n            return new SingletonImmutableTable<>(Iterables.getOnlyElement(cells));\n        default:\n            return RegularImmutableTable.forCells(cells, rowComparator, columnComparator);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a newly-created immutable table, or throws an exception if duplicate key pairs were\n * added.\n *\n * @throws IllegalArgumentException if duplicate key pairs were added\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 5812, "method_signature": "ImmutableTable<R,C,V> buildOrThrow()", "filename": "ImmutableTable.buildOrThrow.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.cellOf", "method_implementation": "{\n    return Tables.immutableCell(checkNotNull(rowKey, \"rowKey\"), checkNotNull(columnKey, \"columnKey\"), checkNotNull(value, \"value\"));\n}", "repo_id": "5", "comment": "/**\n * Verifies that {@code rowKey}, {@code columnKey} and {@code value} are non-null, and returns a\n * new entry with those values.\n */\n", "repo_name": "guava-master/", "id": 5806, "method_signature": "Cell<R,C,V> cellOf(R, C, V)", "filename": "ImmutableTable.cellOf.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the table unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5815, "method_signature": "void clear()", "filename": "ImmutableTable.clear.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.column", "method_implementation": "{\n    checkNotNull(columnKey, \"columnKey\");\n    return MoreObjects.firstNonNull((ImmutableMap<R, V>) columnMap().get(columnKey), ImmutableMap.<R, V>of());\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @throws NullPointerException if {@code columnKey} is {@code null}\n */\n", "repo_name": "guava-master/", "id": 5813, "method_signature": "ImmutableMap<R,V> column(C)", "filename": "ImmutableTable.column.json"}
{"callee_method_names": ["Table<? extends R,? extends C,? extends V>.cellSet"], "method_name": "ImmutableTable.copyOf", "method_implementation": "{\n    if (table instanceof ImmutableTable) {\n        @SuppressWarnings(\"unchecked\")\n        ImmutableTable<R, C, V> parameterizedTable = (ImmutableTable<R, C, V>) table;\n        return parameterizedTable;\n    } else {\n        return copyOf(table.cellSet());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable copy of the provided table.\n *\n * <p>The {@link Table#cellSet()} iteration order of the provided table determines the iteration\n * ordering of all views in the returned table. Note that some views of the original table and the\n * copied table may have different iteration orders. For more control over the ordering, create a\n * {@link Builder} and call {@link Builder#orderRowsBy}, {@link Builder#orderColumnsBy}, and\n * {@link Builder#putAll}\n *\n * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n * safe to do so. The exact circumstances under which a copy will or will not be performed are\n * undocumented and subject to change.\n */\n", "repo_name": "guava-master/", "id": 5805, "method_signature": "ImmutableTable<R,C,V> copyOf(Table)", "filename": "ImmutableTable.copyOf.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.orderColumnsBy", "method_implementation": "{\n    this.columnComparator = checkNotNull(columnComparator, \"columnComparator\");\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated table's columns.\n */\n", "repo_name": "guava-master/", "id": 5808, "method_signature": "Builder<R,C,V> orderColumnsBy(Comparator)", "filename": "ImmutableTable.orderColumnsBy.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.orderRowsBy", "method_implementation": "{\n    this.rowComparator = checkNotNull(rowComparator, \"rowComparator\");\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the ordering of the generated table's rows.\n */\n", "repo_name": "guava-master/", "id": 5807, "method_signature": "Builder<R,C,V> orderRowsBy(Comparator)", "filename": "ImmutableTable.orderRowsBy.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.put", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the table unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5816, "method_signature": "V put(R, C, V)", "filename": "ImmutableTable.put.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.putAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the table unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5817, "method_signature": "void putAll(Table)", "filename": "ImmutableTable.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the table unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5818, "method_signature": "V remove(Object, Object)", "filename": "ImmutableTable.remove.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.row", "method_implementation": "{\n    checkNotNull(rowKey, \"rowKey\");\n    return MoreObjects.firstNonNull((ImmutableMap<C, V>) rowMap().get(rowKey), ImmutableMap.<C, V>of());\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * @throws NullPointerException if {@code rowKey} is {@code null}\n */\n", "repo_name": "guava-master/", "id": 5814, "method_signature": "ImmutableMap<C,V> row(R)", "filename": "ImmutableTable.row.json"}
{"callee_method_names": [], "method_name": "ImmutableTable.toImmutableTable", "method_implementation": "{\n    return TableCollectors.toImmutableTable(rowFunction, columnFunction, valueFunction, mergeFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates elements into an {@code ImmutableTable}. Each\n * input element is mapped to one cell in the returned table, with the rows, columns, and values\n * generated by applying the specified functions. If multiple inputs are mapped to the same row\n * and column pair, they will be combined with the specified merging function in encounter order.\n *\n * <p>The returned {@code Collector} will throw a {@code NullPointerException} at collection time\n * if the row, column, value, or merging functions return null on any input.\n */\n", "repo_name": "guava-master/", "id": 5804, "method_signature": "Collector<T,?,ImmutableTable<R,C,V>> toImmutableTable(Function, Function, Function, BinaryOperator)", "filename": "ImmutableTable.toImmutableTable.json"}
{"callee_method_names": [], "method_name": "ImmutableTableTest.testToImmutableTableSanityTest", "method_implementation": "{\n    Collector<Cell<String, String, Integer>, ?, ImmutableTable<String, String, Integer>> collector = TableCollectors.toImmutableTable(Cell::getRowKey, Cell::getColumnKey, Cell::getValue);\n    CollectorTester.of(collector).expectCollects(ImmutableTable.of()).expectCollects(ImmutableTable.of(\"one\", \"uno\", 1), Tables.immutableCell(\"one\", \"uno\", 1));\n}", "repo_id": "5", "comment": "// This gives minimal coverage to the forwarding functions\n", "repo_name": "guava-master/", "id": 543, "method_signature": "void testToImmutableTableSanityTest()", "filename": "ImmutableTableTest.testToImmutableTableSanityTest.json"}
{"callee_method_names": ["ImmutableTable.Builder<String, String, Integer>.combine"], "method_name": "ImmutableTableTest.testToImmutableTable_java7_combine", "method_implementation": "{\n    ImmutableTable.Builder<String, String, Integer> zis = ImmutableTable.<String, String, Integer>builder().put(\"one\", \"uno\", 1).put(\"two\", \"dos\", 2);\n    ImmutableTable.Builder<String, String, Integer> zat = ImmutableTable.<String, String, Integer>builder().put(\"one\", \"eins\", 1).put(\"two\", \"twei\", 2);\n    ImmutableTable<String, String, Integer> table = zis.combine(zat).build();\n    ImmutableTable<String, String, Integer> expected = ImmutableTable.<String, String, Integer>builder().put(\"one\", \"uno\", 1).put(\"two\", \"dos\", 2).put(\"one\", \"eins\", 1).put(\"two\", \"twei\", 2).build();\n    assertThat(table).isEqualTo(expected);\n}", "repo_id": "5", "comment": "// TODO(b/172823566): Use mainline testToImmutableMap once CollectorTester is usable to java7.\n", "repo_name": "guava-master/", "id": 4003, "method_signature": "void testToImmutableTable_java7_combine()", "filename": "ImmutableTableTest.testToImmutableTable_java7_combine.json"}
{"callee_method_names": [], "method_name": "ImmutableTypeToInstanceMap.put", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @deprecated unsupported operation\n * @throws UnsupportedOperationException always\n */\n", "repo_name": "guava-master/", "id": 4730, "method_signature": "B put(TypeToken, B)", "filename": "ImmutableTypeToInstanceMap.put.json"}
{"callee_method_names": [], "method_name": "ImmutableTypeToInstanceMap.putAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @deprecated unsupported operation\n * @throws UnsupportedOperationException always\n */\n", "repo_name": "guava-master/", "id": 4731, "method_signature": "void putAll(Map)", "filename": "ImmutableTypeToInstanceMap.putAll.json"}
{"callee_method_names": [], "method_name": "ImmutableTypeToInstanceMap.putInstance", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the map unmodified.\n *\n * @deprecated unsupported operation\n * @throws UnsupportedOperationException always\n */\n", "repo_name": "guava-master/", "id": 4729, "method_signature": "T putInstance(Class, T)", "filename": "ImmutableTypeToInstanceMap.putInstance.json"}
{"callee_method_names": ["ImmutableTypeToInstanceMap.Builder<Object>.put", "Entry<TypeToken, Object>.getKey", "Entry<TypeToken, Object>.getValue", "ImmutableTypeToInstanceMap.Builder<Object>.build"], "method_name": "ImmutableTypeToInstanceMapTest.create", "method_implementation": "{\n    ImmutableTypeToInstanceMap.Builder<Object> builder = ImmutableTypeToInstanceMap.builder();\n    for (Object object : elements) {\n        Entry<TypeToken, Object> entry = (Entry<TypeToken, Object>) object;\n        builder.put(entry.getKey(), entry.getValue());\n    }\n    return (Map) builder.build();\n}", "repo_id": "5", "comment": "// but here we have to do some serious fudging\n", "repo_name": "guava-master/", "id": 3618, "method_signature": "Map<TypeToken,Object> create(Object[])", "filename": "ImmutableTypeToInstanceMapTest.create.json"}
{"callee_method_names": ["MutableValueGraph<N, V>.addNode"], "method_name": "ImmutableValueGraph.addNode", "method_implementation": "{\n    mutableValueGraph.addNode(node);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code node} if it is not already present.\n *\n * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.\n *\n * @return this {@code Builder} object\n */\n", "repo_name": "guava-master/", "id": 6786, "method_signature": "ImmutableValueGraph.Builder<N,V> addNode(N)", "filename": "ImmutableValueGraph.addNode.json"}
{"callee_method_names": [], "method_name": "ImmutableValueGraph.copyOf", "method_implementation": "{\n    return (graph instanceof ImmutableValueGraph) ? (ImmutableValueGraph<N, V>) graph : new ImmutableValueGraph<N, V>(graph);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable copy of {@code graph}.\n */\n", "repo_name": "guava-master/", "id": 6785, "method_signature": "ImmutableValueGraph<N,V> copyOf(ValueGraph)", "filename": "ImmutableValueGraph.copyOf.json"}
{"callee_method_names": ["MutableValueGraph<N, V>.putEdgeValue"], "method_name": "ImmutableValueGraph.putEdgeValue", "method_implementation": "{\n    mutableValueGraph.putEdgeValue(endpoints, value);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Adds an edge connecting {@code endpoints} if one is not already present, and sets a value for\n * that edge to {@code value} (overwriting the existing value, if any).\n *\n * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n * undirected.\n *\n * <p>If this graph is directed, {@code endpoints} must be ordered.\n *\n * <p>Values do not have to be unique. However, values must be non-null.\n *\n * <p>If either or both endpoints are not already present in this graph, this method will\n * silently {@link #addNode(Object) add} each missing endpoint to the graph.\n *\n * @return this {@code Builder} object\n * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n *     #allowsSelfLoops()}\n * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n */\n", "repo_name": "guava-master/", "id": 6788, "method_signature": "ImmutableValueGraph.Builder<N,V> putEdgeValue(EndpointPair, V)", "filename": "ImmutableValueGraph.putEdgeValue.json"}
{"callee_method_names": ["ValueGraphBuilder<String, Object>.immutable", "ValueGraphBuilder<String, Object>.allowsSelfLoops", "ImmutableValueGraph.Builder<String, Integer>.build", "ImmutableValueGraph<String, Integer>.isDirected", "ImmutableValueGraph<String, Integer>.allowsSelfLoops", "ImmutableValueGraph<String, Integer>.nodeOrder"], "method_name": "ImmutableValueGraphTest.immutableValueGraphBuilder_copiesGraphBuilder", "method_implementation": "{\n    ValueGraphBuilder<String, Object> graphBuilder = ValueGraphBuilder.directed().allowsSelfLoops(true).<String>nodeOrder(ElementOrder.<String>natural());\n    ImmutableValueGraph.Builder<String, Integer> immutableValueGraphBuilder = graphBuilder.<String, Integer>immutable();\n    // Update ValueGraphBuilder, but this shouldn't impact immutableValueGraphBuilder\n    graphBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());\n    ImmutableValueGraph<String, Integer> emptyGraph = immutableValueGraphBuilder.build();\n    assertThat(emptyGraph.isDirected()).isTrue();\n    assertThat(emptyGraph.allowsSelfLoops()).isTrue();\n    assertThat(emptyGraph.nodeOrder()).isEqualTo(ElementOrder.<String>natural());\n}", "repo_id": "5", "comment": "/**\n * Tests that the ImmutableValueGraph.Builder doesn't change when the creating ValueGraphBuilder\n * changes.\n */\n", "repo_name": "guava-master/", "id": 4070, "method_signature": "void immutableValueGraphBuilder_copiesGraphBuilder()", "filename": "ImmutableValueGraphTest.immutableValueGraphBuilder_copiesGraphBuilder.json"}
{"callee_method_names": [], "method_name": "Indexed.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 3093, "method_signature": "Object writeReplace()", "filename": "Indexed.writeReplace.json"}
{"callee_method_names": [], "method_name": "IndexedImmutableSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6008, "method_signature": "Object writeReplace()", "filename": "IndexedImmutableSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "InetAddresses.bytesToInetAddress", "method_implementation": "{\n    try {\n        return InetAddress.getByAddress(addr);\n    } catch (UnknownHostException e) {\n        throw new AssertionError(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Convert a byte array into an InetAddress.\n *\n * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n * who already know that addr is an array of length 4 or 16.\n *\n * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n * @return an InetAddress object created from the raw IP address\n */\n", "repo_name": "guava-master/", "id": 6692, "method_signature": "InetAddress bytesToInetAddress(byte[])", "filename": "InetAddresses.bytesToInetAddress.json"}
{"callee_method_names": [], "method_name": "InetAddresses.compressLongestRunOfZeroes", "method_implementation": "{\n    int bestRunStart = -1;\n    int bestRunLength = -1;\n    int runStart = -1;\n    for (int i = 0; i < hextets.length + 1; i++) {\n        if (i < hextets.length && hextets[i] == 0) {\n            if (runStart < 0) {\n                runStart = i;\n            }\n        } else if (runStart >= 0) {\n            int runLength = i - runStart;\n            if (runLength > bestRunLength) {\n                bestRunStart = runStart;\n                bestRunLength = runLength;\n            }\n            runStart = -1;\n        }\n    }\n    if (bestRunLength >= 2) {\n        Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n    }\n}", "repo_id": "5", "comment": "/**\n * Identify and mark the longest run of zeroes in an IPv6 address.\n *\n * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n *\n * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n */\n", "repo_name": "guava-master/", "id": 6694, "method_signature": "void compressLongestRunOfZeroes(int[])", "filename": "InetAddresses.compressLongestRunOfZeroes.json"}
{"callee_method_names": ["InetAddress.getAddress"], "method_name": "InetAddresses.decrement", "method_implementation": "{\n    byte[] addr = address.getAddress();\n    int i = addr.length - 1;\n    while (i >= 0 && addr[i] == (byte) 0x00) {\n        addr[i] = (byte) 0xff;\n        i--;\n    }\n    checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n    addr[i]--;\n    return bytesToInetAddress(addr);\n}", "repo_id": "5", "comment": "/**\n * Returns a new InetAddress that is one less than the passed in address. This method works for\n * both IPv4 and IPv6 addresses.\n *\n * @param address the InetAddress to decrement\n * @return a new InetAddress that is one less than the passed in address\n * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n * @since 18.0\n */\n", "repo_name": "guava-master/", "id": 6710, "method_signature": "InetAddress decrement(InetAddress)", "filename": "InetAddresses.decrement.json"}
{"callee_method_names": [], "method_name": "InetAddresses.forString", "method_implementation": "{\n    byte[] addr = ipStringToBytes(ipString);\n    // The argument was malformed, i.e. not an IP string literal.\n    if (addr == null) {\n        throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n    }\n    return bytesToInetAddress(addr);\n}", "repo_id": "5", "comment": "/**\n * Returns the {@link InetAddress} having the given string representation.\n *\n * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n *\n * <p>Anything after a {@code %} in an IPv6 address is ignored (assumed to be a Scope ID).\n *\n * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n * want to accept ASCII digits only, you can use something like {@code\n * CharMatcher.ascii().matchesAllOf(ipString)}.\n *\n * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n * @return {@link InetAddress} representing the argument\n * @throws IllegalArgumentException if the argument is not a valid IP string literal\n */\n", "repo_name": "guava-master/", "id": 6689, "method_signature": "InetAddress forString(String)", "filename": "InetAddresses.forString.json"}
{"callee_method_names": [], "method_name": "InetAddresses.forUriString", "method_implementation": "{\n    InetAddress addr = forUriStringNoThrow(hostAddr);\n    if (addr == null) {\n        throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n    }\n    return addr;\n}", "repo_id": "5", "comment": "/**\n * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n * the format specified by RFC 3986 section 3.2.2.\n *\n * <p>This method is similar to {@link InetAddresses#forString(String)}, however, it requires that\n * IPv6 addresses are surrounded by square brackets.\n *\n * <p>This method is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n *\n * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n * want to accept ASCII digits only, you can use something like {@code\n * CharMatcher.ascii().matchesAllOf(ipString)}.\n *\n * @param hostAddr an RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n * @return an InetAddress representing the address in {@code hostAddr}\n * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n *     address surrounded by square brackets\n */\n", "repo_name": "guava-master/", "id": 6697, "method_signature": "InetAddress forUriString(String)", "filename": "InetAddresses.forUriString.json"}
{"callee_method_names": ["BigInteger.signum", "BigInteger.toByteArray"], "method_name": "InetAddresses.fromBigInteger", "method_implementation": "{\n    checkArgument(address.signum() >= 0, \"BigInteger must be greater than or equal to 0\");\n    int numBytes = isIpv6 ? 16 : 4;\n    byte[] addressBytes = address.toByteArray();\n    byte[] targetCopyArray = new byte[numBytes];\n    int srcPos = Math.max(0, addressBytes.length - numBytes);\n    int copyLength = addressBytes.length - srcPos;\n    int destPos = numBytes - copyLength;\n    // Check the extra bytes in the BigInteger are all zero.\n    for (int i = 0; i < srcPos; i++) {\n        if (addressBytes[i] != 0x00) {\n            throw formatIllegalArgumentException(\"BigInteger cannot be converted to InetAddress because it has more than %d\" + \" bytes: %s\", numBytes, address);\n        }\n    }\n    // Copy the bytes into the least significant positions.\n    System.arraycopy(addressBytes, srcPos, targetCopyArray, destPos, copyLength);\n    try {\n        return InetAddress.getByAddress(targetCopyArray);\n    } catch (UnknownHostException impossible) {\n        throw new AssertionError(impossible);\n    }\n}", "repo_id": "5", "comment": "/**\n * Converts a BigInteger to either an IPv4 or IPv6 address. If the IP is IPv4, it must be\n * constrained to 32 bits, otherwise it is constrained to 128 bits.\n *\n * @param address the address represented as a big integer\n * @param isIpv6 whether the created address should be IPv4 or IPv6\n * @return the BigInteger converted to an address\n * @throws IllegalArgumentException if the BigInteger is not between 0 and maximum value for IPv4\n *     or IPv6 respectively\n */\n", "repo_name": "guava-master/", "id": 6708, "method_signature": "InetAddress fromBigInteger(BigInteger, boolean)", "filename": "InetAddresses.fromBigInteger.json"}
{"callee_method_names": [], "method_name": "InetAddresses.fromLittleEndianByteArray", "method_implementation": "{\n    byte[] reversed = new byte[addr.length];\n    for (int i = 0; i < addr.length; i++) {\n        reversed[i] = addr[addr.length - i - 1];\n    }\n    return InetAddress.getByAddress(reversed);\n}", "repo_id": "5", "comment": "/**\n * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n * InetAddress#getByAddress} expects).\n *\n * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n *\n * @param addr the raw IP address in little-endian byte order\n * @return an InetAddress object created from the raw IP address\n * @throws UnknownHostException if IP address is of illegal length\n */\n", "repo_name": "guava-master/", "id": 6709, "method_signature": "InetAddress fromLittleEndianByteArray(byte[])", "filename": "InetAddresses.fromLittleEndianByteArray.json"}
{"callee_method_names": ["Inet6Address.getAddress"], "method_name": "InetAddresses.get6to4IPv4Address", "method_implementation": "{\n    checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n}", "repo_id": "5", "comment": "/**\n * Returns the IPv4 address embedded in a 6to4 address.\n *\n * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n */\n", "repo_name": "guava-master/", "id": 6700, "method_signature": "Inet4Address get6to4IPv4Address(Inet6Address)", "filename": "InetAddresses.get6to4IPv4Address.json"}
{"callee_method_names": ["InetAddress.getAddress", "Inet6Address.getAddress"], "method_name": "InetAddresses.getCoercedIPv4Address", "method_implementation": "{\n    if (ip instanceof Inet4Address) {\n        return (Inet4Address) ip;\n    }\n    // Special cases:\n    byte[] bytes = ip.getAddress();\n    boolean leadingBytesOfZero = true;\n    for (int i = 0; i < 15; ++i) {\n        if (bytes[i] != 0) {\n            leadingBytesOfZero = false;\n            break;\n        }\n    }\n    if (leadingBytesOfZero && (bytes[15] == 1)) {\n        // ::1\n        return LOOPBACK4;\n    } else if (leadingBytesOfZero && (bytes[15] == 0)) {\n        // ::0\n        return ANY4;\n    }\n    Inet6Address ip6 = (Inet6Address) ip;\n    long addressAsLong = 0;\n    if (hasEmbeddedIPv4ClientAddress(ip6)) {\n        addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n    } else {\n        // Just extract the high 64 bits (assuming the rest is user-modifiable).\n        addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n    }\n    // Many strategies for hashing are possible. This might suffice for now.\n    int coercedHash = Hashing.murmur3_32_fixed().hashLong(addressAsLong).asInt();\n    // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n    coercedHash |= 0xe0000000;\n    // Fixup to avoid some \"illegal\" values. Currently the only potential\n    // illegal value is 255.255.255.255.\n    if (coercedHash == 0xffffffff) {\n        coercedHash = 0xfffffffe;\n    }\n    return getInet4Address(Ints.toByteArray(coercedHash));\n}", "repo_id": "5", "comment": "/**\n * Coerces an IPv6 address into an IPv4 address.\n *\n * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n * This method does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits\n * into 29 bits):\n *\n * <ul>\n *   <li>If the IPv6 address contains an embedded IPv4 address, the function hashes that.\n *   <li>Otherwise, it hashes the upper 64 bits of the IPv6 address.\n * </ul>\n *\n * <p>A \"coerced\" IPv4 address is equivalent to itself.\n *\n * <p>NOTE: This method is failsafe for security purposes: ALL IPv6 addresses (except localhost\n * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n * address that might permit elevated privileges.\n *\n * @param ip {@link InetAddress} to \"coerce\"\n * @return {@link Inet4Address} represented \"coerced\" address\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6707, "method_signature": "Inet4Address getCoercedIPv4Address(InetAddress)", "filename": "InetAddresses.getCoercedIPv4Address.json"}
{"callee_method_names": ["Inet6Address.getAddress"], "method_name": "InetAddresses.getCompatIPv4Address", "method_implementation": "{\n    checkArgument(isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n}", "repo_id": "5", "comment": "/**\n * Returns the IPv4 address embedded in an IPv4 compatible address.\n *\n * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n * @return {@link Inet4Address} of the embedded IPv4 address\n * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n */\n", "repo_name": "guava-master/", "id": 6699, "method_signature": "Inet4Address getCompatIPv4Address(Inet6Address)", "filename": "InetAddresses.getCompatIPv4Address.json"}
{"callee_method_names": [], "method_name": "InetAddresses.getEmbeddedIPv4ClientAddress", "method_implementation": "{\n    if (isCompatIPv4Address(ip)) {\n        return getCompatIPv4Address(ip);\n    }\n    if (is6to4Address(ip)) {\n        return get6to4IPv4Address(ip);\n    }\n    if (isTeredoAddress(ip)) {\n        return getTeredoInfo(ip).getClient();\n    }\n    throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n}", "repo_id": "5", "comment": "/**\n * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n *\n * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n * BGP routing table.\n *\n * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n * @return {@link Inet4Address} of embedded IPv4 client address\n * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n */\n", "repo_name": "guava-master/", "id": 6705, "method_signature": "Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address)", "filename": "InetAddresses.getEmbeddedIPv4ClientAddress.json"}
{"callee_method_names": [], "method_name": "InetAddresses.getInet4Address", "method_implementation": "{\n    checkArgument(bytes.length == 4, \"Byte array has invalid length for an IPv4 address: %s != 4.\", bytes.length);\n    // Given a 4-byte array, this cast should always succeed.\n    return (Inet4Address) bytesToInetAddress(bytes);\n}", "repo_id": "5", "comment": "/**\n * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n *\n * @param bytes byte array representing an IPv4 address (should be of length 4)\n * @return {@link Inet4Address} corresponding to the supplied byte array\n * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n */\n", "repo_name": "guava-master/", "id": 6688, "method_signature": "Inet4Address getInet4Address(byte[])", "filename": "InetAddresses.getInet4Address.json"}
{"callee_method_names": ["Inet6Address.getAddress"], "method_name": "InetAddresses.getIsatapIPv4Address", "method_implementation": "{\n    checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n}", "repo_id": "5", "comment": "/**\n * Returns the IPv4 address embedded in an ISATAP address.\n *\n * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n */\n", "repo_name": "guava-master/", "id": 6704, "method_signature": "Inet4Address getIsatapIPv4Address(Inet6Address)", "filename": "InetAddresses.getIsatapIPv4Address.json"}
{"callee_method_names": ["Inet6Address.getAddress"], "method_name": "InetAddresses.getTeredoInfo", "method_implementation": "{\n    checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n    byte[] bytes = ip.getAddress();\n    Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n    int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n    // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n    int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n    byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n    for (int i = 0; i < clientBytes.length; i++) {\n        // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n        clientBytes[i] = (byte) ~clientBytes[i];\n    }\n    Inet4Address client = getInet4Address(clientBytes);\n    return new TeredoInfo(server, client, port, flags);\n}", "repo_id": "5", "comment": "/**\n * Returns the Teredo information embedded in a Teredo address.\n *\n * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n * @return extracted {@code TeredoInfo}\n * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n */\n", "repo_name": "guava-master/", "id": 6702, "method_signature": "TeredoInfo getTeredoInfo(Inet6Address)", "filename": "InetAddresses.getTeredoInfo.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "InetAddresses.hextetsToIPv6String", "method_implementation": "{\n    // While scanning the array, handle these state transitions:\n    //   start->num => \"num\"     start->gap => \"::\"\n    //   num->num   => \":num\"    num->gap   => \"::\"\n    //   gap->num   => \"num\"     gap->gap   => \"\"\n    StringBuilder buf = new StringBuilder(39);\n    boolean lastWasNumber = false;\n    for (int i = 0; i < hextets.length; i++) {\n        boolean thisIsNumber = hextets[i] >= 0;\n        if (thisIsNumber) {\n            if (lastWasNumber) {\n                buf.append(':');\n            }\n            buf.append(Integer.toHexString(hextets[i]));\n        } else {\n            if (i == 0 || lastWasNumber) {\n                buf.append(\"::\");\n            }\n        }\n        lastWasNumber = thisIsNumber;\n    }\n    return buf.toString();\n}", "repo_id": "5", "comment": "/**\n * Convert a list of hextets into a human-readable IPv6 address.\n *\n * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n * place of the elided zeroes.\n *\n * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n */\n", "repo_name": "guava-master/", "id": 6695, "method_signature": "String hextetsToIPv6String(int[])", "filename": "InetAddresses.hextetsToIPv6String.json"}
{"callee_method_names": ["InetAddress.getAddress"], "method_name": "InetAddresses.increment", "method_implementation": "{\n    byte[] addr = address.getAddress();\n    int i = addr.length - 1;\n    while (i >= 0 && addr[i] == (byte) 0xff) {\n        addr[i] = 0;\n        i--;\n    }\n    checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n    addr[i]++;\n    return bytesToInetAddress(addr);\n}", "repo_id": "5", "comment": "/**\n * Returns a new InetAddress that is one more than the passed in address. This method works for\n * both IPv4 and IPv6 addresses.\n *\n * @param address the InetAddress to increment\n * @return a new InetAddress that is one more than the passed in address\n * @throws IllegalArgumentException if InetAddress is at the end of its range\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6711, "method_signature": "InetAddress increment(InetAddress)", "filename": "InetAddresses.increment.json"}
{"callee_method_names": ["String.length", "String.charAt", "String.substring"], "method_name": "InetAddresses.ipStringToBytes", "method_implementation": "{\n    String ipString = ipStringParam;\n    // Make a first pass to categorize the characters in this string.\n    boolean hasColon = false;\n    boolean hasDot = false;\n    int percentIndex = -1;\n    for (int i = 0; i < ipString.length(); i++) {\n        char c = ipString.charAt(i);\n        if (c == '.') {\n            hasDot = true;\n        } else if (c == ':') {\n            if (hasDot) {\n                // Colons must not appear after dots.\n                return null;\n            }\n            hasColon = true;\n        } else if (c == '%') {\n            percentIndex = i;\n            // everything after a '%' is ignored (it's a Scope ID): http://superuser.com/a/99753\n            break;\n        } else if (Character.digit(c, 16) == -1) {\n            // Everything else must be a decimal or hex digit.\n            return null;\n        }\n    }\n    // Now decide which address family to parse.\n    if (hasColon) {\n        if (hasDot) {\n            ipString = convertDottedQuadToHex(ipString);\n            if (ipString == null) {\n                return null;\n            }\n        }\n        if (percentIndex != -1) {\n            ipString = ipString.substring(0, percentIndex);\n        }\n        return textToNumericFormatV6(ipString);\n    } else if (hasDot) {\n        if (percentIndex != -1) {\n            // Scope IDs are not supported for IPV4\n            return null;\n        }\n        return textToNumericFormatV4(ipString);\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code null} if unable to parse into a {@code byte[]}.\n */\n", "repo_name": "guava-master/", "id": 6690, "method_signature": "byte[] ipStringToBytes(String)", "filename": "InetAddresses.ipStringToBytes.json"}
{"callee_method_names": ["Inet6Address.isIPv4CompatibleAddress", "Inet6Address.getAddress"], "method_name": "InetAddresses.isCompatIPv4Address", "method_implementation": "{\n    if (!ip.isIPv4CompatibleAddress()) {\n        return false;\n    }\n    byte[] bytes = ip.getAddress();\n    if ((bytes[12] == 0) && (bytes[13] == 0) && (bytes[14] == 0) && ((bytes[15] == 0) || (bytes[15] == 1))) {\n        return false;\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Evaluates whether the argument is an IPv6 \"compat\" address.\n *\n * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n *\n * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n *\n * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n *\n * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n * @return {@code true} if the argument is a valid \"compat\" address\n */\n", "repo_name": "guava-master/", "id": 6698, "method_signature": "boolean isCompatIPv4Address(Inet6Address)", "filename": "InetAddresses.isCompatIPv4Address.json"}
{"callee_method_names": ["Inet6Address.getAddress"], "method_name": "InetAddresses.isIsatapAddress", "method_implementation": "{\n    // If it's a Teredo address with the right port (41217, or 0xa101)\n    // which would be encoded as 0x5efe then it can't be an ISATAP address.\n    if (isTeredoAddress(ip)) {\n        return false;\n    }\n    byte[] bytes = ip.getAddress();\n    if ((bytes[8] | (byte) 0x03) != (byte) 0x03) {\n        // Verify that high byte of the 64 bit identifier is zero, modulo\n        // the U/L and G bits, with which we are not concerned.\n        return false;\n    }\n    return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n}", "repo_id": "5", "comment": "/**\n * Evaluates whether the argument is an ISATAP address.\n *\n * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n * IPv4 address in network byte order [...]\"\n *\n * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n *\n * @param ip {@link Inet6Address} to be examined for ISATAP address format\n * @return {@code true} if the argument is an ISATAP address\n */\n", "repo_name": "guava-master/", "id": 6703, "method_signature": "boolean isIsatapAddress(Inet6Address)", "filename": "InetAddresses.isIsatapAddress.json"}
{"callee_method_names": [], "method_name": "InetAddresses.isMappedIPv4Address", "method_implementation": "{\n    byte[] bytes = ipStringToBytes(ipString);\n    if (bytes != null && bytes.length == 16) {\n        for (int i = 0; i < 10; i++) {\n            if (bytes[i] != 0) {\n                return false;\n            }\n        }\n        for (int i = 10; i < 12; i++) {\n            if (bytes[i] != (byte) 0xff) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n *\n * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n *\n * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n *\n * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n * poorly-documented feature.)\n *\n * <p>This method accepts non-ASCII digits. That is consistent with {@link InetAddress}, but not\n * with various RFCs. If you want to accept ASCII digits only, you can use something like {@code\n * CharMatcher.ascii().matchesAllOf(ipString)}.\n *\n * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n * @return {@code true} if the argument is a valid \"mapped\" address\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6706, "method_signature": "boolean isMappedIPv4Address(String)", "filename": "InetAddresses.isMappedIPv4Address.json"}
{"callee_method_names": ["InetAddress.getAddress"], "method_name": "InetAddresses.isMaximum", "method_implementation": "{\n    byte[] addr = address.getAddress();\n    for (byte b : addr) {\n        if (b != (byte) 0xff) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n *\n * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6712, "method_signature": "boolean isMaximum(InetAddress)", "filename": "InetAddresses.isMaximum.json"}
{"callee_method_names": ["Inet6Address.getAddress"], "method_name": "InetAddresses.isTeredoAddress", "method_implementation": "{\n    byte[] bytes = ip.getAddress();\n    return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x01) && (bytes[2] == 0) && (bytes[3] == 0);\n}", "repo_id": "5", "comment": "/**\n * Evaluates whether the argument is a Teredo address.\n *\n * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n *\n * @param ip {@link Inet6Address} to be examined for Teredo address format\n * @return {@code true} if the argument is a Teredo address\n */\n", "repo_name": "guava-master/", "id": 6701, "method_signature": "boolean isTeredoAddress(Inet6Address)", "filename": "InetAddresses.isTeredoAddress.json"}
{"callee_method_names": ["String.charAt"], "method_name": "InetAddresses.parseHextet", "method_implementation": "{\n    // Note: we already verified that this string contains only hex digits.\n    int length = end - start;\n    if (length <= 0 || length > 4) {\n        throw new NumberFormatException();\n    }\n    int hextet = 0;\n    for (int i = start; i < end; i++) {\n        hextet = hextet << 4;\n        hextet |= Character.digit(ipString.charAt(i), 16);\n    }\n    return (short) hextet;\n}", "repo_id": "5", "comment": "// Parse a hextet out of the ipString from start (inclusive) to end (exclusive)\n", "repo_name": "guava-master/", "id": 6691, "method_signature": "short parseHextet(String, int, int)", "filename": "InetAddresses.parseHextet.json"}
{"callee_method_names": ["InetAddress.getHostAddress", "InetAddress.getAddress"], "method_name": "InetAddresses.toAddrString", "method_implementation": "{\n    checkNotNull(ip);\n    if (ip instanceof Inet4Address) {\n        // For IPv4, Java's formatting is good enough.\n        // requireNonNull accommodates Android's @RecentlyNullable annotation on getHostAddress\n        return requireNonNull(ip.getHostAddress());\n    }\n    checkArgument(ip instanceof Inet6Address);\n    byte[] bytes = ip.getAddress();\n    int[] hextets = new int[IPV6_PART_COUNT];\n    for (int i = 0; i < hextets.length; i++) {\n        hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n    }\n    compressLongestRunOfZeroes(hextets);\n    return hextetsToIPv6String(hextets);\n}", "repo_id": "5", "comment": "/**\n * Returns the string representation of an {@link InetAddress}.\n *\n * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n * uses the uncompressed form.\n *\n * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n * such as \"::c000:201\". The output does not include a Scope ID.\n *\n * @param ip {@link InetAddress} to be converted to an address string\n * @return {@code String} containing the text-formatted IP address\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6693, "method_signature": "String toAddrString(InetAddress)", "filename": "InetAddresses.toAddrString.json"}
{"callee_method_names": [], "method_name": "InetAddresses.toUriString", "method_implementation": "{\n    if (ip instanceof Inet6Address) {\n        return \"[\" + toAddrString(ip) + \"]\";\n    }\n    return toAddrString(ip);\n}", "repo_id": "5", "comment": "/**\n * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n *\n * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n * \"[2001:db8::1]\"}.\n *\n * <p>Per section 3.2.2 of <a target=\"_parent\"\n * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n *\n * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n * this method is recommended over {@link InetAddress#toString()} when an IP address string\n * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n * IP address string joined by a \"/\".\n *\n * @param ip {@link InetAddress} to be converted to URI string literal\n * @return {@code String} containing URI-safe string literal\n */\n", "repo_name": "guava-master/", "id": 6696, "method_signature": "String toUriString(InetAddress)", "filename": "InetAddresses.toUriString.json"}
{"callee_method_names": [], "method_name": "InetAddressesTest.checkBigIntegerConversion", "method_implementation": "{\n    InetAddress address = InetAddresses.forString(ip);\n    boolean isIpv6 = address instanceof Inet6Address;\n    assertEquals(bigIntegerIp, InetAddresses.toBigInteger(address));\n    assertEquals(address, isIpv6 ? InetAddresses.fromIPv6BigInteger(bigIntegerIp) : InetAddresses.fromIPv4BigInteger(bigIntegerIp));\n}", "repo_id": "5", "comment": "/**\n * Checks that the IP converts to the big integer and the big integer converts to the IP.\n */\n", "repo_name": "guava-master/", "id": 4041, "method_signature": "void checkBigIntegerConversion(String, BigInteger)", "filename": "InetAddressesTest.checkBigIntegerConversion.json"}
{"callee_method_names": [], "method_name": "IntMath.binomial", "method_implementation": "{\n    checkNonNegative(\"n\", n);\n    checkNonNegative(\"k\", k);\n    checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n    if (k > (n >> 1)) {\n        k = n - k;\n    }\n    if (k >= biggestBinomials.length || n > biggestBinomials[k]) {\n        return Integer.MAX_VALUE;\n    }\n    switch(k) {\n        case 0:\n            return 1;\n        case 1:\n            return n;\n        default:\n            long result = 1;\n            for (int i = 0; i < k; i++) {\n                result *= n - i;\n                result /= i + 1;\n            }\n            return (int) result;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and\n * {@code k}, or {@link Integer#MAX_VALUE} if the result does not fit in an {@code int}.\n *\n * @throws IllegalArgumentException if {@code n < 0}, {@code k < 0} or {@code k > n}\n */\n", "repo_name": "guava-master/", "id": 4541, "method_signature": "int binomial(int, int)", "filename": "IntMath.binomial.json"}
{"callee_method_names": [], "method_name": "IntMath.ceilingPowerOfTwo", "method_implementation": "{\n    checkPositive(\"x\", x);\n    if (x > MAX_SIGNED_POWER_OF_TWO) {\n        throw new ArithmeticException(\"ceilingPowerOfTwo(\" + x + \") not representable as an int\");\n    }\n    return 1 << -Integer.numberOfLeadingZeros(x - 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to\n * {@code checkedPow(2, log2(x, CEILING))}.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException of the next-higher power of two is not representable as an {@code\n *     int}, i.e. when {@code x > 2^30}\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4527, "method_signature": "int ceilingPowerOfTwo(int)", "filename": "IntMath.ceilingPowerOfTwo.json"}
{"callee_method_names": [], "method_name": "IntMath.checkedAdd", "method_implementation": "{\n    long result = (long) a + b;\n    checkNoOverflow(result == (int) result, \"checkedAdd\", a, b);\n    return (int) result;\n}", "repo_id": "5", "comment": "/**\n * Returns the sum of {@code a} and {@code b}, provided it does not overflow.\n *\n * @throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4536, "method_signature": "int checkedAdd(int, int)", "filename": "IntMath.checkedAdd.json"}
{"callee_method_names": [], "method_name": "IntMath.checkedMultiply", "method_implementation": "{\n    long result = (long) a * b;\n    checkNoOverflow(result == (int) result, \"checkedMultiply\", a, b);\n    return (int) result;\n}", "repo_id": "5", "comment": "/**\n * Returns the product of {@code a} and {@code b}, provided it does not overflow.\n *\n * @throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4538, "method_signature": "int checkedMultiply(int, int)", "filename": "IntMath.checkedMultiply.json"}
{"callee_method_names": [], "method_name": "IntMath.checkedPow", "method_implementation": "{\n    checkNonNegative(\"exponent\", k);\n    switch(b) {\n        case 0:\n            return (k == 0) ? 1 : 0;\n        case 1:\n            return 1;\n        case (-1):\n            return ((k & 1) == 0) ? 1 : -1;\n        case 2:\n            checkNoOverflow(k < Integer.SIZE - 1, \"checkedPow\", b, k);\n            return 1 << k;\n        case (-2):\n            checkNoOverflow(k < Integer.SIZE, \"checkedPow\", b, k);\n            return ((k & 1) == 0) ? 1 << k : -1 << k;\n        default:\n    }\n    int accum = 1;\n    while (true) {\n        switch(k) {\n            case 0:\n                return accum;\n            case 1:\n                return checkedMultiply(accum, b);\n            default:\n                if ((k & 1) != 0) {\n                    accum = checkedMultiply(accum, b);\n                }\n                k >>= 1;\n                if (k > 0) {\n                    checkNoOverflow(-FLOOR_SQRT_MAX_INT <= b & b <= FLOOR_SQRT_MAX_INT, \"checkedPow\", b, k);\n                    b *= b;\n                }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code b} to the {@code k}th power, provided it does not overflow.\n *\n * <p>{@link #pow} may be faster, but does not check for overflow.\n *\n * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed {@code\n *     int} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4539, "method_signature": "int checkedPow(int, int)", "filename": "IntMath.checkedPow.json"}
{"callee_method_names": [], "method_name": "IntMath.checkedSubtract", "method_implementation": "{\n    long result = (long) a - b;\n    checkNoOverflow(result == (int) result, \"checkedSubtract\", a, b);\n    return (int) result;\n}", "repo_id": "5", "comment": "/**\n * Returns the difference of {@code a} and {@code b}, provided it does not overflow.\n *\n * @throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4537, "method_signature": "int checkedSubtract(int, int)", "filename": "IntMath.checkedSubtract.json"}
{"callee_method_names": [], "method_name": "IntMath.divide", "method_implementation": "{\n    checkNotNull(mode);\n    if (q == 0) {\n        // for GWT\n        throw new ArithmeticException(\"/ by zero\");\n    }\n    int div = p / q;\n    // equal to p % q\n    int rem = p - q * div;\n    if (rem == 0) {\n        return div;\n    }\n    /*\n     * Normal Java division rounds towards 0, consistently with RoundingMode.DOWN. We just have to\n     * deal with the cases where rounding towards 0 is wrong, which typically depends on the sign of\n     * p / q.\n     *\n     * signum is 1 if p and q are both nonnegative or both negative, and -1 otherwise.\n     */\n    int signum = 1 | ((p ^ q) >> (Integer.SIZE - 1));\n    boolean increment;\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(rem == 0);\n        // fall through\n        case DOWN:\n            increment = false;\n            break;\n        case UP:\n            increment = true;\n            break;\n        case CEILING:\n            increment = signum > 0;\n            break;\n        case FLOOR:\n            increment = signum < 0;\n            break;\n        case HALF_EVEN:\n        case HALF_DOWN:\n        case HALF_UP:\n            int absRem = abs(rem);\n            int cmpRemToHalfDivisor = absRem - (abs(q) - absRem);\n            // subtracting two nonnegative ints can't overflow\n            // cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).\n            if (cmpRemToHalfDivisor == 0) {\n                // exactly on the half mark\n                increment = (mode == HALF_UP || (mode == HALF_EVEN & (div & 1) != 0));\n            } else {\n                // closer to the UP value\n                increment = cmpRemToHalfDivisor > 0;\n            }\n            break;\n        default:\n            throw new AssertionError();\n    }\n    return increment ? div + signum : div;\n}", "repo_id": "5", "comment": "/**\n * Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code\n * RoundingMode}.\n *\n * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n *     is not an integer multiple of {@code b}\n */\n", "repo_name": "guava-master/", "id": 4533, "method_signature": "int divide(int, int, RoundingMode)", "filename": "IntMath.divide.json"}
{"callee_method_names": [], "method_name": "IntMath.gcd", "method_implementation": "{\n    /*\n     * The reason we require both arguments to be >= 0 is because otherwise, what do you return on\n     * gcd(0, Integer.MIN_VALUE)? BigInteger.gcd would return positive 2^31, but positive 2^31 isn't\n     * an int.\n     */\n    checkNonNegative(\"a\", a);\n    checkNonNegative(\"b\", b);\n    if (a == 0) {\n        // 0 % b == 0, so b divides a, but the converse doesn't hold.\n        // BigInteger.gcd is consistent with this decision.\n        return b;\n    } else if (b == 0) {\n        // similar logic\n        return a;\n    }\n    /*\n     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm. This is\n     * >40% faster than the Euclidean algorithm in benchmarks.\n     */\n    int aTwos = Integer.numberOfTrailingZeros(a);\n    // divide out all 2s\n    a >>= aTwos;\n    int bTwos = Integer.numberOfTrailingZeros(b);\n    // divide out all 2s\n    b >>= bTwos;\n    while (a != b) {\n        // both a, b are odd\n        // The key to the binary GCD algorithm is as follows:\n        // Both a and b are odd. Assume a > b; then gcd(a - b, b) = gcd(a, b).\n        // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.\n        // We bend over backwards to avoid branching, adapting a technique from\n        // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax\n        // can't overflow, since a and b are nonnegative\n        int delta = a - b;\n        int minDeltaOrZero = delta & (delta >> (Integer.SIZE - 1));\n        // equivalent to Math.min(delta, 0)\n        // sets a to Math.abs(a - b)\n        a = delta - minDeltaOrZero - minDeltaOrZero;\n        // a is now nonnegative and even\n        // sets b to min(old a, b)\n        b += minDeltaOrZero;\n        // divide out all 2s, since 2 doesn't divide b\n        a >>= Integer.numberOfTrailingZeros(a);\n    }\n    return a << min(aTwos, bTwos);\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if {@code a == 0 && b ==\n * 0}.\n *\n * @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}\n */\n", "repo_name": "guava-master/", "id": 4535, "method_signature": "int gcd(int, int)", "filename": "IntMath.gcd.json"}
{"callee_method_names": [], "method_name": "IntMath.isPrime", "method_implementation": "{\n    return LongMath.isPrime(n);\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code n} is a <a\n * href=\"http://mathworld.wolfram.com/PrimeNumber.html\">prime number</a>: an integer <i>greater\n * than one</i> that cannot be factored into a product of <i>smaller</i> positive integers.\n * Returns {@code false} if {@code n} is zero, one, or a composite number (one which <i>can</i> be\n * factored into smaller positive integers).\n *\n * <p>To test larger numbers, use {@link LongMath#isPrime} or {@link BigInteger#isProbablePrime}.\n *\n * @throws IllegalArgumentException if {@code n} is negative\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4543, "method_signature": "boolean isPrime(int)", "filename": "IntMath.isPrime.json"}
{"callee_method_names": [], "method_name": "IntMath.lessThanBranchFree", "method_implementation": "{\n    // The double negation is optimized away by normal Java, but is necessary for GWT\n    // to make sure bit twiddling works as expected.\n    return ~~(x - y) >>> (Integer.SIZE - 1);\n}", "repo_id": "5", "comment": "/**\n * Returns 1 if {@code x < y} as unsigned integers, and 0 otherwise. Assumes that x - y fits into\n * a signed int. The implementation is branch-free, and benchmarks suggest it is measurably (if\n * narrowly) faster than the straightforward ternary expression.\n */\n", "repo_name": "guava-master/", "id": 4528, "method_signature": "int lessThanBranchFree(int, int)", "filename": "IntMath.lessThanBranchFree.json"}
{"callee_method_names": [], "method_name": "IntMath.log10", "method_implementation": "{\n    checkPositive(\"x\", x);\n    int logFloor = log10Floor(x);\n    int floorPow = powersOf10[logFloor];\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(x == floorPow);\n        // fall through\n        case FLOOR:\n        case DOWN:\n            return logFloor;\n        case CEILING:\n        case UP:\n            return logFloor + lessThanBranchFree(floorPow, x);\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            // sqrt(10) is irrational, so log10(x) - logFloor is never exactly 0.5\n            return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not a power of ten\n */\n", "repo_name": "guava-master/", "id": 4530, "method_signature": "int log10(int, RoundingMode)", "filename": "IntMath.log10.json"}
{"callee_method_names": [], "method_name": "IntMath.log2", "method_implementation": "{\n    checkPositive(\"x\", x);\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(isPowerOfTwo(x));\n        // fall through\n        case DOWN:\n        case FLOOR:\n            return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);\n        case UP:\n        case CEILING:\n            return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n            int leadingZeros = Integer.numberOfLeadingZeros(x);\n            int cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n            // floor(2^(logFloor + 0.5))\n            int logFloor = (Integer.SIZE - 1) - leadingZeros;\n            return logFloor + lessThanBranchFree(cmp, x);\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not a power of two\n */\n", "repo_name": "guava-master/", "id": 4529, "method_signature": "int log2(int, RoundingMode)", "filename": "IntMath.log2.json"}
{"callee_method_names": [], "method_name": "IntMath.mean", "method_implementation": "{\n    // Efficient method for computing the arithmetic mean.\n    // The alternative (x + y) / 2 fails for large values.\n    // The alternative (x + y) >>> 1 fails for negative values.\n    return (x & y) + ((x ^ y) >> 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the arithmetic mean of {@code x} and {@code y}, rounded towards negative infinity. This\n * method is overflow resilient.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4542, "method_signature": "int mean(int, int)", "filename": "IntMath.mean.json"}
{"callee_method_names": [], "method_name": "IntMath.mod", "method_implementation": "{\n    if (m <= 0) {\n        throw new ArithmeticException(\"Modulus \" + m + \" must be > 0\");\n    }\n    int result = x % m;\n    return (result >= 0) ? result : result + m;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %\n * m}, which might be negative.\n *\n * <p>For example:\n *\n * <pre>{@code\n * mod(7, 4) == 3\n * mod(-7, 4) == 1\n * mod(-1, 4) == 3\n * mod(-8, 4) == 0\n * mod(8, 4) == 0\n * }</pre>\n *\n * @throws ArithmeticException if {@code m <= 0}\n * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3\">\n *     Remainder Operator</a>\n */\n", "repo_name": "guava-master/", "id": 4534, "method_signature": "int mod(int, int)", "filename": "IntMath.mod.json"}
{"callee_method_names": [], "method_name": "IntMath.pow", "method_implementation": "{\n    checkNonNegative(\"exponent\", k);\n    switch(b) {\n        case 0:\n            return (k == 0) ? 1 : 0;\n        case 1:\n            return 1;\n        case (-1):\n            return ((k & 1) == 0) ? 1 : -1;\n        case 2:\n            return (k < Integer.SIZE) ? (1 << k) : 0;\n        case (-2):\n            if (k < Integer.SIZE) {\n                return ((k & 1) == 0) ? (1 << k) : -(1 << k);\n            } else {\n                return 0;\n            }\n        default:\n    }\n    for (int accum = 1; ; k >>= 1) {\n        switch(k) {\n            case 0:\n                return accum;\n            case 1:\n                return b * accum;\n            default:\n                accum *= ((k & 1) == 0) ? 1 : b;\n                b *= b;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to\n * {@code BigInteger.valueOf(b).pow(k).intValue()}. This implementation runs in {@code O(log k)}\n * time.\n *\n * <p>Compare {@link #checkedPow}, which throws an {@link ArithmeticException} upon overflow.\n *\n * @throws IllegalArgumentException if {@code k < 0}\n */\n", "repo_name": "guava-master/", "id": 4531, "method_signature": "int pow(int, int)", "filename": "IntMath.pow.json"}
{"callee_method_names": [], "method_name": "IntMath.saturatedPow", "method_implementation": "{\n    checkNonNegative(\"exponent\", k);\n    switch(b) {\n        case 0:\n            return (k == 0) ? 1 : 0;\n        case 1:\n            return 1;\n        case (-1):\n            return ((k & 1) == 0) ? 1 : -1;\n        case 2:\n            if (k >= Integer.SIZE - 1) {\n                return Integer.MAX_VALUE;\n            }\n            return 1 << k;\n        case (-2):\n            if (k >= Integer.SIZE) {\n                return Integer.MAX_VALUE + (k & 1);\n            }\n            return ((k & 1) == 0) ? 1 << k : -1 << k;\n        default:\n    }\n    int accum = 1;\n    // if b is negative and k is odd then the limit is MIN otherwise the limit is MAX\n    int limit = Integer.MAX_VALUE + ((b >>> Integer.SIZE - 1) & (k & 1));\n    while (true) {\n        switch(k) {\n            case 0:\n                return accum;\n            case 1:\n                return saturatedMultiply(accum, b);\n            default:\n                if ((k & 1) != 0) {\n                    accum = saturatedMultiply(accum, b);\n                }\n                k >>= 1;\n                if (k > 0) {\n                    if (-FLOOR_SQRT_MAX_INT > b | b > FLOOR_SQRT_MAX_INT) {\n                        return limit;\n                    }\n                    b *= b;\n                }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code b} to the {@code k}th power, unless it would overflow or underflow in which\n * case {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4540, "method_signature": "int saturatedPow(int, int)", "filename": "IntMath.saturatedPow.json"}
{"callee_method_names": [], "method_name": "IntMath.sqrt", "method_implementation": "{\n    checkNonNegative(\"x\", x);\n    int sqrtFloor = sqrtFloor(x);\n    switch(mode) {\n        case UNNECESSARY:\n            // fall through\n            checkRoundingUnnecessary(sqrtFloor * sqrtFloor == x);\n        case FLOOR:\n        case DOWN:\n            return sqrtFloor;\n        case CEILING:\n        case UP:\n            return sqrtFloor + lessThanBranchFree(sqrtFloor * sqrtFloor, x);\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            int halfSquare = sqrtFloor * sqrtFloor + sqrtFloor;\n            /*\n         * We wish to test whether or not x <= (sqrtFloor + 0.5)^2 = halfSquare + 0.25. Since both x\n         * and halfSquare are integers, this is equivalent to testing whether or not x <=\n         * halfSquare. (We have to deal with overflow, though.)\n         *\n         * If we treat halfSquare as an unsigned int, we know that\n         *            sqrtFloor^2 <= x < (sqrtFloor + 1)^2\n         * halfSquare - sqrtFloor <= x < halfSquare + sqrtFloor + 1\n         * so |x - halfSquare| <= sqrtFloor.  Therefore, it's safe to treat x - halfSquare as a\n         * signed int, so lessThanBranchFree is safe for use.\n         */\n            return sqrtFloor + lessThanBranchFree(halfSquare, x);\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the square root of {@code x}, rounded with the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x < 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code\n *     sqrt(x)} is not an integer\n */\n", "repo_name": "guava-master/", "id": 4532, "method_signature": "int sqrt(int, RoundingMode)", "filename": "IntMath.sqrt.json"}
{"callee_method_names": [], "method_name": "IntMathTest.assertMean", "method_implementation": "{\n    int expectedMean = computeMeanSafely(x, y);\n    assertEquals(expectedMean, IntMath.mean(x, y));\n    assertEquals(\"The mean of x and y should equal the mean of y and x\", expectedMean, IntMath.mean(y, x));\n}", "repo_id": "5", "comment": "/**\n * Helper method that asserts the arithmetic mean of x and y is equal to the result of\n * computeMeanSafely.\n */\n", "repo_name": "guava-master/", "id": 3583, "method_signature": "void assertMean(int, int)", "filename": "IntMathTest.assertMean.json"}
{"callee_method_names": ["BigInteger.add", "BigDecimal.toString"], "method_name": "IntMathTest.computeMeanSafely", "method_implementation": "{\n    BigInteger bigX = BigInteger.valueOf(x);\n    BigInteger bigY = BigInteger.valueOf(y);\n    BigDecimal bigMean = new BigDecimal(bigX.add(bigY)).divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\n    // parseInt blows up on overflow as opposed to intValue() which does not.\n    return Integer.parseInt(bigMean.toString());\n}", "repo_id": "5", "comment": "/**\n * Computes the mean in a way that is obvious and resilient to overflow by using BigInteger\n * arithmetic.\n */\n", "repo_name": "guava-master/", "id": 3584, "method_signature": "int computeMeanSafely(int, int)", "filename": "IntMathTest.computeMeanSafely.json"}
{"callee_method_names": ["BigInteger.intValue"], "method_name": "IntMathTest.testBinomial", "method_implementation": "{\n    for (int n = 0; n <= 50; n++) {\n        for (int k = 0; k <= n; k++) {\n            BigInteger expectedBig = BigIntegerMath.binomial(n, k);\n            int expectedInt = fitsInInt(expectedBig) ? expectedBig.intValue() : Integer.MAX_VALUE;\n            assertEquals(expectedInt, IntMath.binomial(n, k));\n        }\n    }\n}", "repo_id": "5", "comment": "// Depends on the correctness of BigIntegerMath.binomial.\n", "repo_name": "guava-master/", "id": 3581, "method_signature": "void testBinomial()", "filename": "IntMathTest.testBinomial.json"}
{"callee_method_names": ["BigInteger.intValue"], "method_name": "IntMathTest.testFactorial", "method_implementation": "{\n    for (int n = 0; n <= 50; n++) {\n        BigInteger expectedBig = BigIntegerMath.factorial(n);\n        int expectedInt = fitsInInt(expectedBig) ? expectedBig.intValue() : Integer.MAX_VALUE;\n        assertEquals(expectedInt, IntMath.factorial(n));\n    }\n}", "repo_id": "5", "comment": "// Depends on the correctness of BigIntegerMath.factorial.\n", "repo_name": "guava-master/", "id": 3580, "method_signature": "void testFactorial()", "filename": "IntMathTest.testFactorial.json"}
{"callee_method_names": [], "method_name": "IntMathTest.testLog10Exact", "method_implementation": "{\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n        int floor = IntMath.log10(x, FLOOR);\n        boolean expectSuccess = IntMath.pow(10, floor) == x;\n        try {\n            assertEquals(floor, IntMath.log10(x, UNNECESSARY));\n            assertTrue(expectSuccess);\n        } catch (ArithmeticException e) {\n            assertFalse(expectSuccess);\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of log10(int, FLOOR) and of pow(int, int).\n", "repo_name": "guava-master/", "id": 3576, "method_signature": "void testLog10Exact()", "filename": "IntMathTest.testLog10Exact.json"}
{"callee_method_names": [], "method_name": "IntMathTest.testLog10MatchesBigInteger", "method_implementation": "{\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n            // The BigInteger implementation is tested separately, use it as the reference.\n            assertEquals(BigIntegerMath.log10(valueOf(x), mode), IntMath.log10(x, mode));\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of BigIntegerMath.log10 for all modes except UNNECESSARY.\n", "repo_name": "guava-master/", "id": 3575, "method_signature": "void testLog10MatchesBigInteger()", "filename": "IntMathTest.testLog10MatchesBigInteger.json"}
{"callee_method_names": [], "method_name": "IntMathTest.testLog2Exact", "method_implementation": "{\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n        // We only expect an exception if x was not a power of 2.\n        boolean isPowerOf2 = IntMath.isPowerOfTwo(x);\n        try {\n            assertEquals(x, 1 << IntMath.log2(x, UNNECESSARY));\n            assertTrue(isPowerOf2);\n        } catch (ArithmeticException e) {\n            assertFalse(isPowerOf2);\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of isPowerOfTwo(int).\n", "repo_name": "guava-master/", "id": 3574, "method_signature": "void testLog2Exact()", "filename": "IntMathTest.testLog2Exact.json"}
{"callee_method_names": [], "method_name": "IntMathTest.testLog2MatchesBigInteger", "method_implementation": "{\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n            assertEquals(BigIntegerMath.log2(valueOf(x), mode), IntMath.log2(x, mode));\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of BigIntegerMath.log2 for all modes except UNNECESSARY.\n", "repo_name": "guava-master/", "id": 3573, "method_signature": "void testLog2MatchesBigInteger()", "filename": "IntMathTest.testLog2MatchesBigInteger.json"}
{"callee_method_names": [], "method_name": "IntMathTest.testSqrtExactMatchesFloorOrThrows", "method_implementation": "{\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n        int floor = IntMath.sqrt(x, FLOOR);\n        // We only expect an exception if x was not a perfect square.\n        boolean isPerfectSquare = (floor * floor == x);\n        try {\n            assertEquals(floor, IntMath.sqrt(x, UNNECESSARY));\n            assertTrue(isPerfectSquare);\n        } catch (ArithmeticException e) {\n            assertFalse(isPerfectSquare);\n        }\n    }\n}", "repo_id": "5", "comment": "/* Relies on the correctness of sqrt(int, FLOOR). */\n", "repo_name": "guava-master/", "id": 3579, "method_signature": "void testSqrtExactMatchesFloorOrThrows()", "filename": "IntMathTest.testSqrtExactMatchesFloorOrThrows.json"}
{"callee_method_names": [], "method_name": "IntMathTest.testSqrtMatchesBigInteger", "method_implementation": "{\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n            // The BigInteger implementation is tested separately, use it as the reference.\n            // Promote the int value (rather than using intValue() on the expected value) to avoid\n            // any risk of truncation which could lead to a false positive.\n            assertEquals(BigIntegerMath.sqrt(valueOf(x), mode), valueOf(IntMath.sqrt(x, mode)));\n        }\n    }\n}", "repo_id": "5", "comment": "/* Relies on the correctness of BigIntegerMath.sqrt for all modes except UNNECESSARY. */\n", "repo_name": "guava-master/", "id": 3578, "method_signature": "void testSqrtMatchesBigInteger()", "filename": "IntMathTest.testSqrtMatchesBigInteger.json"}
{"callee_method_names": [], "method_name": "IntMathTest.testSqrtZeroAlwaysZero", "method_implementation": "{\n    for (RoundingMode mode : ALL_ROUNDING_MODES) {\n        assertEquals(0, IntMath.sqrt(0, mode));\n    }\n}", "repo_id": "5", "comment": "// Simple test to cover sqrt(0) for all types and all modes.\n", "repo_name": "guava-master/", "id": 3577, "method_signature": "void testSqrtZeroAlwaysZero()", "filename": "IntMathTest.testSqrtZeroAlwaysZero.json"}
{"callee_method_names": ["Duration.toNanos", "Duration.isNegative"], "method_name": "Internal.toNanosSaturated", "method_implementation": "{\n    // Using a try/catch seems lazy, but the catch block will rarely get invoked (except for\n    // durations longer than approximately +/- 292 years).\n    try {\n        return duration.toNanos();\n    } catch (ArithmeticException tooBig) {\n        return duration.isNegative() ? Long.MIN_VALUE : Long.MAX_VALUE;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the number of nanoseconds of the given duration without throwing or overflowing.\n *\n * <p>Instead of throwing {@link ArithmeticException}, this method silently saturates to either\n * {@link Long#MAX_VALUE} or {@link Long#MIN_VALUE}. This behavior can be useful when decomposing\n * a duration in order to call a legacy API which requires a {@code long, TimeUnit} pair.\n */\n", "repo_name": "guava-master/", "id": 5099, "method_signature": "long toNanosSaturated(Duration)", "filename": "Internal.toNanosSaturated.json"}
{"callee_method_names": [], "method_name": "InternerBuilder.weak", "method_implementation": "{\n    this.strong = false;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Instructs the {@link InternerBuilder} to build a weak interner.\n *\n * @see Interners#newWeakInterner()\n */\n", "repo_name": "guava-master/", "id": 5541, "method_signature": "InternerBuilder weak()", "filename": "InternerBuilder.weak.json"}
{"callee_method_names": [], "method_name": "Interners.weak", "method_implementation": "{\n    this.strong = false;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Instructs the {@link InternerBuilder} to build a weak interner.\n *\n * @see Interners#newWeakInterner()\n */\n", "repo_name": "guava-master/", "id": 5540, "method_signature": "InternerBuilder weak()", "filename": "Interners.weak.json"}
{"callee_method_names": [], "method_name": "InternetDomainName.equals", "method_implementation": "{\n    if (object == this) {\n        return true;\n    }\n    if (object instanceof InternetDomainName) {\n        InternetDomainName that = (InternetDomainName) object;\n        return this.name.equals(that.name);\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Equality testing is based on the text supplied by the caller, after normalization as described\n * in the class documentation. For example, a non-ASCII Unicode domain name and the Punycode\n * version of the same domain name would not be considered equal.\n */\n", "repo_name": "guava-master/", "id": 6728, "method_signature": "boolean equals(Object)", "filename": "InternetDomainName.equals.json"}
{"callee_method_ids": [4980], "callee_method_names": ["ImmutableList<String>.size", "Joiner.join", "ImmutableList<String>.subList"], "method_name": "InternetDomainName.findSuffixOfType", "method_implementation": "{\n    int partsSize = parts.size();\n    for (int i = 0; i < partsSize; i++) {\n        String ancestorName = DOT_JOINER.join(parts.subList(i, partsSize));\n        if (i > 0 && matchesType(desiredType, Optional.fromNullable(PublicSuffixPatterns.UNDER.get(ancestorName)))) {\n            return i - 1;\n        }\n        if (matchesType(desiredType, Optional.fromNullable(PublicSuffixPatterns.EXACT.get(ancestorName)))) {\n            return i;\n        }\n        // Excluded domains (e.g. !nhs.uk) use the next highest\n        // domain as the effective public suffix (e.g. uk).\n        if (PublicSuffixPatterns.EXCLUDED.containsKey(ancestorName)) {\n            return i + 1;\n        }\n    }\n    return NO_SUFFIX_FOUND;\n}", "repo_id": "5", "comment": "/**\n * Returns the index of the leftmost part of the suffix, or -1 if not found. Note that the value\n * defined as a suffix may not produce {@code true} results from {@link #isPublicSuffix()} or\n * {@link #isRegistrySuffix()} if the domain ends with an excluded domain pattern such as {@code\n * \"nhs.uk\"}.\n *\n * <p>If a {@code desiredType} is specified, this method only finds suffixes of the given type.\n * Otherwise, it finds the first suffix of any type.\n */\n", "repo_name": "guava-master/", "id": 6722, "method_signature": "int findSuffixOfType(Optional)", "filename": "InternetDomainName.findSuffixOfType.json"}
{"callee_method_names": [], "method_name": "InternetDomainName.isValid", "method_implementation": "{\n    try {\n        InternetDomainName unused = from(name);\n        return true;\n    } catch (IllegalArgumentException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Indicates whether the argument is a syntactically valid domain name using lenient validation.\n * Specifically, validation against <a href=\"http://www.ietf.org/rfc/rfc3490.txt\">RFC 3490</a>\n * (\"Internationalizing Domain Names in Applications\") is skipped.\n *\n * <p>The following two code snippets are equivalent:\n *\n * <pre>{@code\n * domainName = InternetDomainName.isValid(name)\n *     ? InternetDomainName.from(name)\n *     : DEFAULT_DOMAIN;\n * }</pre>\n *\n * <pre>{@code\n * try {\n *   domainName = InternetDomainName.from(name);\n * } catch (IllegalArgumentException e) {\n *   domainName = DEFAULT_DOMAIN;\n * }\n * }</pre>\n *\n * @since 8.0 (previously named {@code isValidLenient})\n */\n", "repo_name": "guava-master/", "id": 6727, "method_signature": "boolean isValid(String)", "filename": "InternetDomainName.isValid.json"}
{"callee_method_names": [], "method_name": "InternetDomainName.publicSuffixIndex", "method_implementation": "{\n    int publicSuffixIndexLocal = publicSuffixIndexCache;\n    if (publicSuffixIndexLocal == SUFFIX_NOT_INITIALIZED) {\n        publicSuffixIndexCache = publicSuffixIndexLocal = findSuffixOfType(Optional.<PublicSuffixType>absent());\n    }\n    return publicSuffixIndexLocal;\n}", "repo_id": "5", "comment": "/**\n * The index in the {@link #parts()} list at which the public suffix begins. For example, for the\n * domain name {@code myblog.blogspot.co.uk}, the value would be 1 (the index of the {@code\n * blogspot} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no public\n * suffix was found.\n */\n", "repo_name": "guava-master/", "id": 6720, "method_signature": "int publicSuffixIndex()", "filename": "InternetDomainName.publicSuffixIndex.json"}
{"callee_method_names": [], "method_name": "InternetDomainName.registrySuffixIndex", "method_implementation": "{\n    int registrySuffixIndexLocal = registrySuffixIndexCache;\n    if (registrySuffixIndexLocal == SUFFIX_NOT_INITIALIZED) {\n        registrySuffixIndexCache = registrySuffixIndexLocal = findSuffixOfType(Optional.of(PublicSuffixType.REGISTRY));\n    }\n    return registrySuffixIndexLocal;\n}", "repo_id": "5", "comment": "/**\n * The index in the {@link #parts()} list at which the registry suffix begins. For example, for\n * the domain name {@code myblog.blogspot.co.uk}, the value would be 2 (the index of the {@code\n * co} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no registry suffix\n * was found.\n */\n", "repo_name": "guava-master/", "id": 6721, "method_signature": "int registrySuffixIndex()", "filename": "InternetDomainName.registrySuffixIndex.json"}
{"callee_method_names": [], "method_name": "InternetDomainName.topDomainUnderRegistrySuffix", "method_implementation": "{\n    if (isTopDomainUnderRegistrySuffix()) {\n        return this;\n    }\n    checkState(isUnderRegistrySuffix(), \"Not under a registry suffix: %s\", name);\n    return ancestor(registrySuffixIndex() - 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the portion of this domain name that is one level beneath the {@linkplain\n * #isRegistrySuffix() registry suffix}. For example, for {@code x.adwords.google.co.uk} it\n * returns {@code google.co.uk}, since {@code co.uk} is a registry suffix. Similarly, for {@code\n * myblog.blogspot.com} it returns {@code blogspot.com}, since {@code com} is a registry suffix.\n *\n * <p>If {@link #isTopDomainUnderRegistrySuffix()} is true, the current domain name instance is\n * returned.\n *\n * <p><b>Warning:</b> This method should not be used to determine whether a domain is probably the\n * highest level for which cookies may be set. Use {@link #isTopPrivateDomain()} for that purpose.\n *\n * @throws IllegalStateException if this domain does not end with a registry suffix\n * @since 23.3\n */\n", "repo_name": "guava-master/", "id": 6726, "method_signature": "InternetDomainName topDomainUnderRegistrySuffix()", "filename": "InternetDomainName.topDomainUnderRegistrySuffix.json"}
{"callee_method_names": [], "method_name": "InternetDomainName.topPrivateDomain", "method_implementation": "{\n    if (isTopPrivateDomain()) {\n        return this;\n    }\n    checkState(isUnderPublicSuffix(), \"Not under a public suffix: %s\", name);\n    return ancestor(publicSuffixIndex() - 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the portion of this domain name that is one level beneath the {@linkplain\n * #isPublicSuffix() public suffix}. For example, for {@code x.adwords.google.co.uk} it returns\n * {@code google.co.uk}, since {@code co.uk} is a public suffix. Similarly, for {@code\n * myblog.blogspot.com} it returns the same domain, {@code myblog.blogspot.com}, since {@code\n * blogspot.com} is a public suffix.\n *\n * <p>If {@link #isTopPrivateDomain()} is true, the current domain name instance is returned.\n *\n * <p>This method can be used to determine the probable highest level parent domain for which\n * cookies may be set, though even that depends on individual browsers' implementations of cookie\n * controls.\n *\n * @throws IllegalStateException if this domain does not end with a public suffix\n * @since 6.0\n */\n", "repo_name": "guava-master/", "id": 6725, "method_signature": "InternetDomainName topPrivateDomain()", "filename": "InternetDomainName.topPrivateDomain.json"}
{"callee_method_ids": [5085], "callee_method_names": ["String.length", "String.length", "CharMatcher.matchesAllOf", "CharMatcher.matches", "String.charAt", "CharMatcher.matches", "String.charAt", "String.length", "CharMatcher.matches", "String.charAt"], "method_name": "InternetDomainName.validatePart", "method_implementation": "{\n    // These tests could be collapsed into one big boolean expression, but\n    // they have been left as independent tests for clarity.\n    if (part.length() < 1 || part.length() > MAX_DOMAIN_PART_LENGTH) {\n        return false;\n    }\n    /*\n     * GWT claims to support java.lang.Character's char-classification methods, but it actually only\n     * works for ASCII. So for now, assume any non-ASCII characters are valid. The only place this\n     * seems to be documented is here:\n     * https://groups.google.com/d/topic/google-web-toolkit-contributors/1UEzsryq1XI\n     *\n     * <p>ASCII characters in the part are expected to be valid per RFC 1035, with underscore also\n     * being allowed due to widespread practice.\n     */\n    String asciiChars = CharMatcher.ascii().retainFrom(part);\n    if (!PART_CHAR_MATCHER.matchesAllOf(asciiChars)) {\n        return false;\n    }\n    // No initial or final dashes or underscores.\n    if (DASH_MATCHER.matches(part.charAt(0)) || DASH_MATCHER.matches(part.charAt(part.length() - 1))) {\n        return false;\n    }\n    /*\n     * Note that we allow (in contravention of a strict interpretation of the relevant RFCs) domain\n     * parts other than the last may begin with a digit (for example, \"3com.com\"). It's important to\n     * disallow an initial digit in the last part; it's the only thing that stops an IPv4 numeric\n     * address like 127.0.0.1 from looking like a valid domain name.\n     */\n    if (isFinalPart && DIGIT_MATCHER.matches(part.charAt(0))) {\n        return false;\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Helper method for {@link #validateSyntax(List)}. Validates that one part of a domain name is\n * valid.\n *\n * @param part The domain name part to be validated\n * @param isFinalPart Is this the final (rightmost) domain part?\n * @return Whether the part is valid\n */\n", "repo_name": "guava-master/", "id": 6724, "method_signature": "boolean validatePart(String, boolean)", "filename": "InternetDomainName.validatePart.json"}
{"callee_method_names": ["List<String>.size", "List<String>.get", "List<String>.get"], "method_name": "InternetDomainName.validateSyntax", "method_implementation": "{\n    int lastIndex = parts.size() - 1;\n    // Validate the last part specially, as it has different syntax rules.\n    if (!validatePart(parts.get(lastIndex), true)) {\n        return false;\n    }\n    for (int i = 0; i < lastIndex; i++) {\n        String part = parts.get(i);\n        if (!validatePart(part, false)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Validation method used by {@code from} to ensure that the domain name is syntactically valid\n * according to RFC 1035.\n *\n * @return Is the domain name syntactically valid?\n */\n", "repo_name": "guava-master/", "id": 6723, "method_signature": "boolean validateSyntax(List)", "filename": "InternetDomainName.validateSyntax.json"}
{"callee_method_names": ["Blocker.setOwner"], "method_name": "InterruptibleTask.interruptTask", "method_implementation": "{\n    // Since the Thread is replaced by DONE before run() invokes listeners or returns, if we succeed\n    // in this CAS, there's no risk of interrupting the wrong thread or interrupting a thread that\n    // isn't currently executing this task.\n    Runnable currentRunner = get();\n    if (currentRunner instanceof Thread) {\n        Blocker blocker = new Blocker(this);\n        blocker.setOwner(Thread.currentThread());\n        if (compareAndSet(currentRunner, blocker)) {\n            // Thread.interrupt can throw arbitrary exceptions due to the nio InterruptibleChannel API\n            // This will make sure that tasks don't get stuck busy waiting.\n            // Some of this is fixed in jdk11 (see https://bugs.openjdk.java.net/browse/JDK-8198692) but\n            // not all.  See the test cases for examples on how this can happen.\n            try {\n                ((Thread) currentRunner).interrupt();\n            } finally {\n                Runnable prev = getAndSet(DONE);\n                if (prev == PARKED) {\n                    LockSupport.unpark((Thread) currentRunner);\n                }\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Interrupts the running task. Because this internally calls {@link Thread#interrupt()} which can\n * in turn invoke arbitrary code it is not safe to call while holding a lock.\n */\n", "repo_name": "guava-master/", "id": 5240, "method_signature": "void interruptTask()", "filename": "InterruptibleTask.interruptTask.json"}
{"callee_method_names": ["Thread.getState"], "method_name": "InterruptibleTaskTest.awaitBlockedOnInstanceOf", "method_implementation": "{\n    while (!isThreadBlockedOnInstanceOf(t, blocker)) {\n        if (t.getState() == Thread.State.TERMINATED) {\n            throw new RuntimeException(\"Thread \" + t + \" exited unexpectedly\");\n        }\n        Thread.sleep(1);\n    }\n}", "repo_id": "5", "comment": "// waits for the given thread to be blocked on the given object\n", "repo_name": "guava-master/", "id": 3892, "method_signature": "void awaitBlockedOnInstanceOf(Thread, Class)", "filename": "InterruptibleTaskTest.awaitBlockedOnInstanceOf.json"}
{"callee_method_names": ["SlowChannel.doBegin", "CountDownLatch.countDown", "Thread.start", "CountDownLatch.await", "InterruptibleTask<@Nullable Void>.interruptTask", "Thread.start", "Blocker.getOwner", "SlowChannel.countDown", "Thread.join"], "method_name": "InterruptibleTaskTest.testInterruptIsSlow", "method_implementation": "{\n    final CountDownLatch isInterruptibleRegistered = new CountDownLatch(1);\n    final SlowChannel slowChannel = new SlowChannel();\n    final InterruptibleTask<@Nullable Void> task = new InterruptibleTask<@Nullable Void>() {\n\n        @Override\n        @Nullable\n        Void runInterruptibly() throws Exception {\n            slowChannel.doBegin();\n            isInterruptibleRegistered.countDown();\n            try {\n                // the interrupt will wake us up\n                new CountDownLatch(1).await();\n            } catch (InterruptedException ie) {\n                // continue\n            }\n            // simulate a spurious wakeup.\n            LockSupport.unpark(Thread.currentThread());\n            return null;\n        }\n\n        @Override\n        boolean isDone() {\n            return false;\n        }\n\n        @Override\n        String toPendingString() {\n            return \"\";\n        }\n\n        @Override\n        void afterRanInterruptiblySuccess(@Nullable Void result) {\n        }\n\n        @Override\n        void afterRanInterruptiblyFailure(Throwable error) {\n        }\n    };\n    Thread runner = new Thread(task, \"runner\");\n    runner.start();\n    isInterruptibleRegistered.await();\n    // trigger the interrupt on another thread since it will block\n    Thread interrupter = new Thread(\"Interrupter\") {\n\n        @Override\n        public void run() {\n            task.interruptTask();\n        }\n    };\n    interrupter.start();\n    // this will happen once the interrupt has been set which means that\n    // 1. the runner has been woken up\n    // 2. the interrupter is stuck in the call the Thread.interrupt()\n    // after some period of time the runner thread should become blocked on the task because it is\n    // waiting for the slow interrupting thread to complete Thread.interrupt\n    awaitBlockedOnInstanceOf(runner, InterruptibleTask.Blocker.class);\n    Blocker blocker = (Blocker) LockSupport.getBlocker(runner);\n    Thread owner = blocker.getOwner();\n    assertThat(owner).isSameInstanceAs(interrupter);\n    // release the interrupter\n    slowChannel.exitClose.countDown();\n    // We need to wait for the runner to exit.  To make sure that the interrupting thread wakes it\n    // back up.\n    runner.join(TimeUnit.SECONDS.toMillis(10));\n}", "repo_id": "5", "comment": "/*\n   * This test hangs (or maybe is just *very* slow) under Android.\n   *\n   * TODO(b/218700094): Ideally, get this to pass under Android. Failing that, convince ourselves\n   * that the test isn't exposing a real problem with InterruptibleTask, one that could matter in\n   * prod.\n   */\n", "repo_name": "guava-master/", "id": 3891, "method_signature": "void testInterruptIsSlow()", "filename": "InterruptibleTaskTest.testInterruptIsSlow.json"}
{"callee_method_names": ["BrokenChannel.doBegin", "CountDownLatch.countDown", "Thread.start", "CountDownLatch.await", "InterruptibleTask<@Nullable Void>.interruptTask", "Thread.join"], "method_name": "InterruptibleTaskTest.testInterruptThrows", "method_implementation": "{\n    final CountDownLatch isInterruptibleRegistered = new CountDownLatch(1);\n    InterruptibleTask<@Nullable Void> task = new InterruptibleTask<@Nullable Void>() {\n\n        @Override\n        @Nullable\n        Void runInterruptibly() throws Exception {\n            BrokenChannel bc = new BrokenChannel();\n            bc.doBegin();\n            isInterruptibleRegistered.countDown();\n            // the interrupt will wake us up\n            new CountDownLatch(1).await();\n            return null;\n        }\n\n        @Override\n        boolean isDone() {\n            return false;\n        }\n\n        @Override\n        String toPendingString() {\n            return \"\";\n        }\n\n        @Override\n        void afterRanInterruptiblySuccess(@Nullable Void result) {\n        }\n\n        @Override\n        void afterRanInterruptiblyFailure(Throwable error) {\n        }\n    };\n    Thread runner = new Thread(task);\n    runner.start();\n    isInterruptibleRegistered.await();\n    RuntimeException expected = assertThrows(RuntimeException.class, () -> task.interruptTask());\n    assertThat(expected).hasMessageThat().isEqualTo(\"I bet you didn't think Thread.interrupt could throw\");\n    // We need to wait for the runner to exit.  It used to be that the runner would get stuck in the\n    // busy loop when interrupt threw.\n    runner.join(TimeUnit.SECONDS.toMillis(10));\n}", "repo_id": "5", "comment": "// transition to DONE\n", "repo_name": "guava-master/", "id": 3890, "method_signature": "void testInterruptThrows()", "filename": "InterruptibleTaskTest.testInterruptThrows.json"}
{"callee_method_names": ["TimeUnit.toNanos"], "method_name": "InterruptionUtil.joinUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(timeout);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                // TimeUnit.timedJoin() treats negative timeouts just like zero.\n                NANOSECONDS.timedJoin(thread, remainingNanos);\n                return;\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "// TODO(cpovirk): promote to Uninterruptibles, and add untimed version\n", "repo_name": "guava-master/", "id": 3882, "method_signature": "void joinUninterruptibly(Thread, long, TimeUnit)", "filename": "InterruptionUtil.joinUninterruptibly.json"}
{"callee_method_names": ["TimeUnit.sleep", "Thread.interrupt"], "method_name": "InterruptionUtil.requestInterruptIn", "method_implementation": "{\n    checkNotNull(unit);\n    final Thread interruptee = Thread.currentThread();\n    new Thread(new Runnable() {\n\n        @Override\n        public void run() {\n            try {\n                unit.sleep(time);\n            } catch (InterruptedException wontHappen) {\n                throw new AssertionError(wontHappen);\n            }\n            interruptee.interrupt();\n        }\n    }).start();\n}", "repo_id": "5", "comment": "/**\n * Interrupts the current thread after sleeping for the specified delay.\n */\n", "repo_name": "guava-master/", "id": 3881, "method_signature": "void requestInterruptIn(long, TimeUnit)", "filename": "InterruptionUtil.requestInterruptIn.json"}
{"callee_method_names": [], "method_name": "Ints.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new IntArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>The returned list maintains the values, but not the identities, of {@code Integer} objects\n * written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for\n * the returned list is unspecified.\n *\n * <p>The returned list is serializable.\n *\n * <p><b>Note:</b> when possible, you should represent your data as an {@link ImmutableIntArray}\n * instead, which has an {@link ImmutableIntArray#asList asList} view.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4349, "method_signature": "List<Integer> asList(int[])", "filename": "Ints.asList.json"}
{"callee_method_names": [], "method_name": "Ints.checkedCast", "method_implementation": "{\n    int result = (int) value;\n    checkArgument(result == value, \"Out of range: %s\", value);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code int} value that is equal to {@code value}, if possible.\n *\n * @param value any value in the range of the {@code int} type\n * @return the {@code int} value that equals {@code value}\n * @throws IllegalArgumentException if {@code value} is greater than {@link Integer#MAX_VALUE} or\n *     less than {@link Integer#MIN_VALUE}\n */\n", "repo_name": "guava-master/", "id": 4333, "method_signature": "int checkedCast(long)", "filename": "Ints.checkedCast.json"}
{"callee_method_names": [], "method_name": "Ints.concat", "method_implementation": "{\n    int length = 0;\n    for (int[] array : arrays) {\n        length += array.length;\n    }\n    int[] result = new int[length];\n    int pos = 0;\n    for (int[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new int[] {a, b}, new int[] {}, new int[] {c}} returns the array {@code {a, b, c}}.\n *\n * @param arrays zero or more {@code int} arrays\n * @return a single array containing all the values from the source arrays, in order\n */\n", "repo_name": "guava-master/", "id": 4341, "method_signature": "int[] concat(int[][])", "filename": "Ints.concat.json"}
{"callee_method_names": [], "method_name": "Ints.contains", "method_implementation": "{\n    for (int value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.\n *\n * @param array an array of {@code int} values, possibly empty\n * @param target a primitive {@code int} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4335, "method_signature": "boolean contains(int[], int)", "filename": "Ints.contains.json"}
{"callee_method_names": [], "method_name": "Ints.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4343, "method_signature": "int[] ensureCapacity(int[], int, int)", "filename": "Ints.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Ints.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4337, "method_signature": "int indexOf(int[], int[])", "filename": "Ints.indexOf.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Ints.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 5);\n    builder.append(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code int} values separated by {@code separator}. For\n * example, {@code join(\"-\", 1, 2, 3)} returns the string {@code \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code int} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4344, "method_signature": "String join(String, int[])", "filename": "Ints.join.json"}
{"callee_method_names": [], "method_name": "Ints.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4338, "method_signature": "int lastIndexOf(int[], int, int, int)", "filename": "Ints.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Ints.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    int max = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code int} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4340, "method_signature": "int max(int[])", "filename": "Ints.max.json"}
{"callee_method_names": [], "method_name": "Ints.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    int min = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] < min) {\n            min = array[i];\n        }\n    }\n    return min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code int} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4339, "method_signature": "int min(int[])", "filename": "Ints.min.json"}
{"callee_method_names": [], "method_name": "Ints.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        int tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Ints.asList(array).subList(fromIndex, toIndex))}, but is likely to be more\n * efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4346, "method_signature": "void reverse(int[], int, int)", "filename": "Ints.reverse.json"}
{"callee_method_names": [], "method_name": "Ints.rotate", "method_implementation": "{\n    // There are several well-known algorithms for rotating part of an array (or, equivalently,\n    // exchanging two blocks of memory). This classic text by Gries and Mills mentions several:\n    // https://ecommons.cornell.edu/bitstream/handle/1813/6292/81-452.pdf.\n    // (1) \"Reversal\", the one we have here.\n    // (2) \"Dolphin\". If we're rotating an array a of size n by a distance of d, then element a[0]\n    //     ends up at a[d], which in turn ends up at a[2d], and so on until we get back to a[0].\n    //     (All indices taken mod n.) If d and n are mutually prime, all elements will have been\n    //     moved at that point. Otherwise, we can rotate the cycle a[1], a[1 + d], a[1 + 2d], etc,\n    //     then a[2] etc, and so on until we have rotated all elements. There are gcd(d, n) cycles\n    //     in all.\n    // (3) \"Successive\". We can consider that we are exchanging a block of size d (a[0..d-1]) with a\n    //     block of size n-d (a[d..n-1]), where in general these blocks have different sizes. If we\n    //     imagine a line separating the first block from the second, we can proceed by exchanging\n    //     the smaller of these blocks with the far end of the other one. That leaves us with a\n    //     smaller version of the same problem.\n    //     Say we are rotating abcdefgh by 5. We start with abcde|fgh. The smaller block is [fgh]:\n    //     [abc]de|[fgh] -> [fgh]de|[abc]. Now [fgh] is in the right place, but we need to swap [de]\n    //     with [abc]: fgh[de]|a[bc] -> fgh[bc]|a[de]. Now we need to swap [a] with [bc]:\n    //     fgh[b]c|[a]de -> fgh[a]c|[b]de. Finally we need to swap [c] with [b]:\n    //     fgha[c]|[b]de -> fgha[b]|[c]de. Because these two blocks are the same size, we are done.\n    // The Dolphin algorithm is attractive because it does the fewest array reads and writes: each\n    // array slot is read and written exactly once. However, it can have very poor memory locality:\n    // benchmarking shows it can take 7 times longer than the other two in some cases. The other two\n    // do n swaps, minus a delta (0 or 2 for Reversal, gcd(d, n) for Successive), so that's about\n    // twice as many reads and writes. But benchmarking shows that they usually perform better than\n    // Dolphin. Reversal is about as good as Successive on average, and it is much simpler,\n    // especially since we already have a `reverse` method.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Ints.asList(array).subList(fromIndex, toIndex), distance)}, but is\n * considerably faster and avoids allocations and garbage collection.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4347, "method_signature": "void rotate(int[], int, int, int)", "filename": "Ints.rotate.json"}
{"callee_method_names": [], "method_name": "Ints.saturatedCast", "method_implementation": "{\n    if (value > Integer.MAX_VALUE) {\n        return Integer.MAX_VALUE;\n    }\n    if (value < Integer.MIN_VALUE) {\n        return Integer.MIN_VALUE;\n    }\n    return (int) value;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code int} nearest in value to {@code value}.\n *\n * @param value any {@code long} value\n * @return the same value cast to {@code int} if it is in the range of the {@code int} type,\n *     {@link Integer#MAX_VALUE} if it is too large, or {@link Integer#MIN_VALUE} if it is too\n *     small\n */\n", "repo_name": "guava-master/", "id": 4334, "method_signature": "int saturatedCast(long)", "filename": "Ints.saturatedCast.json"}
{"callee_method_names": [], "method_name": "Ints.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    Arrays.sort(array, fromIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4345, "method_signature": "void sortDescending(int[], int, int)", "filename": "Ints.sortDescending.json"}
{"callee_method_names": ["Collection<? extends Number>.toArray"], "method_name": "Ints.toArray", "method_implementation": "{\n    if (collection instanceof IntArrayAsList) {\n        return ((IntArrayAsList) collection).toIntArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    int[] array = new int[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = ((Number) checkNotNull(boxedArray[i])).intValue();\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing each value of {@code collection}, converted to a {@code int} value\n * in the manner of {@link Number#intValue}.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * @param collection a collection of {@code Number} instances\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n * @since 1.0 (parameter was {@code Collection<Integer>} before 12.0)\n */\n", "repo_name": "guava-master/", "id": 4348, "method_signature": "int[] toArray(Collection)", "filename": "Ints.toArray.json"}
{"callee_method_names": [], "method_name": "Ints.toByteArray", "method_implementation": "{\n    return new byte[] { (byte) (value >> 24), (byte) (value >> 16), (byte) (value >> 8), (byte) value };\n}", "repo_id": "5", "comment": "/**\n * Returns a big-endian representation of {@code value} in a 4-element byte array; equivalent to\n * {@code ByteBuffer.allocate(4).putInt(value).array()}. For example, the input value {@code\n * 0x12131415} would yield the byte array {@code {0x12, 0x13, 0x14, 0x15}}.\n *\n * <p>If you need to convert and concatenate several values (possibly even of different types),\n * use a shared {@link java.nio.ByteBuffer} instance, or use {@link\n * com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.\n */\n", "repo_name": "guava-master/", "id": 4342, "method_signature": "byte[] toByteArray(int)", "filename": "Ints.toByteArray.json"}
{"callee_method_names": ["Long.longValue", "Long.intValue", "Long.intValue"], "method_name": "Ints.tryParse", "method_implementation": "{\n    Long result = Longs.tryParse(string, radix);\n    if (result == null || result.longValue() != result.intValue()) {\n        return null;\n    } else {\n        return result.intValue();\n    }\n}", "repo_id": "5", "comment": "/**\n * Parses the specified string as a signed integer value using the specified radix. The ASCII\n * character {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.\n *\n * <p>Unlike {@link Integer#parseInt(String, int)}, this method returns {@code null} instead of\n * throwing an exception if parsing fails. Additionally, this method only accepts ASCII digits,\n * and returns {@code null} if non-ASCII digits are present in the string.\n *\n * <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even under JDK 7, despite\n * the change to {@link Integer#parseInt(String, int)} for that version.\n *\n * @param string the string representation of an integer value\n * @param radix the radix to use when parsing\n * @return the integer value represented by {@code string} using {@code radix}, or {@code null} if\n *     {@code string} has a length of zero or cannot be parsed as an integer value\n * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >\n *     Character.MAX_RADIX}\n * @throws NullPointerException if {@code string} is {@code null}\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 4350, "method_signature": "Integer tryParse(String, int)", "filename": "Ints.tryParse.json"}
{"callee_method_names": [], "method_name": "IntsTest.radixEncodeParseAndAssertEquals", "method_implementation": "{\n    assertWithMessage(\"Radix: \" + radix).that(Ints.tryParse(Integer.toString(value, radix), radix)).isEqualTo(value);\n}", "repo_id": "5", "comment": "/**\n * Encodes an integer as a string with given radix, then uses {@link Ints#tryParse(String, int)}\n * to parse the result. Asserts the result is the same as what we started with.\n */\n", "repo_name": "guava-master/", "id": 3563, "method_signature": "void radixEncodeParseAndAssertEquals(Integer, int)", "filename": "IntsTest.radixEncodeParseAndAssertEquals.json"}
{"callee_method_names": ["List<Integer>.subList", "List<Integer>.subList"], "method_name": "IntsTest.testAsList_subList_toArray_roundTrip", "method_implementation": "{\n    int[] array = { (int) 0, (int) 1, (int) 2, (int) 3 };\n    List<Integer> list = Ints.asList(array);\n    assertThat(Ints.toArray(list.subList(1, 3))).isEqualTo(new int[] { (int) 1, (int) 2 });\n    assertThat(Ints.toArray(list.subList(2, 2))).isEqualTo(new int[] {});\n}", "repo_id": "5", "comment": "// This test stems from a real bug found by andrewk\n", "repo_name": "guava-master/", "id": 3562, "method_signature": "void testAsList_subList_toArray_roundTrip()", "filename": "IntsTest.testAsList_subList_toArray_roundTrip.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject"], "method_name": "Inverse.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(inverse());\n}", "repo_id": "5", "comment": "/**\n * @serialData the forward bimap\n */\n", "repo_name": "guava-master/", "id": 6160, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "Inverse.writeObject.json"}
{"callee_method_names": [], "method_name": "Inverse.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2697, "method_signature": "Object writeReplace()", "filename": "Inverse.writeReplace.json"}
{"callee_method_names": [], "method_name": "InverseEntries.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 3147, "method_signature": "Object writeReplace()", "filename": "InverseEntries.writeReplace.json"}
{"callee_method_names": [], "method_name": "InverseEntrySet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2699, "method_signature": "Object writeReplace()", "filename": "InverseEntrySet.writeReplace.json"}
{"callee_method_names": ["ImmutableList.Builder<TypeToken<? extends Throwable>>.add", "ImmutableList.Builder<TypeToken<? extends Throwable>>.build"], "method_name": "Invokable.getExceptionTypes", "method_implementation": "{\n    ImmutableList.Builder<TypeToken<? extends Throwable>> builder = ImmutableList.builder();\n    for (Type type : getGenericExceptionTypes()) {\n        // getGenericExceptionTypes() will never return a type that's not exception\n        @SuppressWarnings(\"unchecked\")\n        TypeToken<? extends Throwable> exceptionType = (TypeToken<? extends Throwable>) TypeToken.of(type);\n        builder.add(exceptionType);\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns all declared exception types of this {@code Invokable}.\n */\n", "repo_name": "guava-master/", "id": 4718, "method_signature": "ImmutableList<TypeToken<? extends Throwable>> getExceptionTypes()", "filename": "Invokable.getExceptionTypes.json"}
{"callee_method_names": ["Class<?>.getTypeParameters"], "method_name": "Invokable.getGenericReturnType", "method_implementation": "{\n    Class<?> declaringClass = getDeclaringClass();\n    TypeVariable<?>[] typeParams = declaringClass.getTypeParameters();\n    if (typeParams.length > 0) {\n        return Types.newParameterizedType(declaringClass, typeParams);\n    } else {\n        return declaringClass;\n    }\n}", "repo_id": "5", "comment": "/**\n * If the class is parameterized, such as {@link java.util.ArrayList ArrayList}, this returns\n * {@code ArrayList<E>}.\n */\n", "repo_name": "guava-master/", "id": 4720, "method_signature": "Type getGenericReturnType()", "filename": "Invokable.getGenericReturnType.json"}
{"callee_method_names": ["ImmutableList.Builder<Parameter>.add", "ImmutableList.Builder<Parameter>.build"], "method_name": "Invokable.getParameters", "method_implementation": "{\n    Type[] parameterTypes = getGenericParameterTypes();\n    Annotation[][] annotations = getParameterAnnotations();\n    @Nullable\n    Object[] annotatedTypes = new Object[parameterTypes.length];\n    ImmutableList.Builder<Parameter> builder = ImmutableList.builder();\n    for (int i = 0; i < parameterTypes.length; i++) {\n        builder.add(new Parameter(this, i, TypeToken.of(parameterTypes[i]), annotations[i], annotatedTypes[i]));\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns all declared parameters of this {@code Invokable}. Note that if this is a constructor\n * of a non-static inner class, unlike {@link Constructor#getParameterTypes}, the hidden {@code\n * this} parameter of the enclosing class is excluded from the returned parameters.\n */\n", "repo_name": "guava-master/", "id": 4717, "method_signature": "ImmutableList<Parameter> getParameters()", "filename": "Invokable.getParameters.json"}
{"callee_method_names": ["Constructor<?>.getTypeParameters"], "method_name": "Invokable.getTypeParameters", "method_implementation": "{\n    TypeVariable<?>[] declaredByClass = getDeclaringClass().getTypeParameters();\n    TypeVariable<?>[] declaredByConstructor = constructor.getTypeParameters();\n    TypeVariable<?>[] result = new TypeVariable<?>[declaredByClass.length + declaredByConstructor.length];\n    System.arraycopy(declaredByClass, 0, result, 0, declaredByClass.length);\n    System.arraycopy(declaredByConstructor, 0, result, declaredByClass.length, declaredByConstructor.length);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>{@code [<E>]} will be returned for ArrayList's constructor. When both the class and the\n * constructor have type parameters, the class parameters are prepended before those of the\n * constructor's. This is an arbitrary rule since no existing language spec mandates one way or\n * the other. From the declaration syntax, the class type parameter appears first, but the call\n * syntax may show up in opposite order such as {@code new <A>Foo<B>()}.\n */\n", "repo_name": "guava-master/", "id": 4721, "method_signature": "TypeVariable<?>[] getTypeParameters()", "filename": "Invokable.getTypeParameters.json"}
{"callee_method_names": [], "method_name": "Invokable.invoke", "method_implementation": "{\n    return (R) invokeInternal(receiver, checkNotNull(args));\n}", "repo_id": "5", "comment": "// All subclasses are owned by us and we'll make sure to get the R type right, including nullness.\n", "repo_name": "guava-master/", "id": 4716, "method_signature": "R invoke(T, Object[])", "filename": "Invokable.invoke.json"}
{"callee_method_names": ["TypeToken<R1>.isSupertypeOf"], "method_name": "Invokable.returning", "method_implementation": "{\n    if (!returnType.isSupertypeOf(getReturnType())) {\n        throw new IllegalArgumentException(\"Invokable is known to return \" + getReturnType() + \", not \" + returnType);\n    }\n    // guarded by previous check\n    @SuppressWarnings(\"unchecked\")\n    Invokable<T, R1> specialized = (Invokable<T, R1>) this;\n    return specialized;\n}", "repo_id": "5", "comment": "/**\n * Explicitly specifies the return type of this {@code Invokable}.\n */\n", "repo_name": "guava-master/", "id": 4719, "method_signature": "Invokable<T,R1> returning(TypeToken)", "filename": "Invokable.returning.json"}
{"callee_method_names": ["AccessibleObject.setAccessible"], "method_name": "Invokable.trySetAccessible", "method_implementation": "{\n    // We can't call accessibleObject.trySetAccessible since that was added in Java 9 and this code\n    // should work on Java 8. So we emulate it this way.\n    try {\n        accessibleObject.setAccessible(true);\n        return true;\n    } catch (Exception e) {\n        // sneaky checked exception\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * See {@link java.lang.reflect.AccessibleObject#trySetAccessible()}.\n */\n", "repo_name": "guava-master/", "id": 4715, "method_signature": "boolean trySetAccessible()", "filename": "Invokable.trySetAccessible.json"}
{"callee_method_names": [], "method_name": "InvokableTest.testApiCompatibleWithAccessibleObject", "method_implementation": "{\n    ImmutableSet<String> invokableMethods = publicMethodSignatures(Invokable.class, ImmutableSet.<String>of());\n    ImmutableSet<String> accessibleObjectMethods = publicMethodSignatures(AccessibleObject.class, ImmutableSet.of(\"canAccess\"));\n    assertThat(invokableMethods).containsAtLeastElementsIn(accessibleObjectMethods);\n    Class<?> genericDeclaration;\n    try {\n        genericDeclaration = Class.forName(\"java.lang.reflect.GenericDeclaration\");\n        ImmutableSet<String> genericDeclarationMethods = publicMethodSignatures(genericDeclaration, ImmutableSet.<String>of());\n        assertThat(invokableMethods).containsAtLeastElementsIn(genericDeclarationMethods);\n    } catch (ClassNotFoundException e) {\n        // OK: we're on Java 7, which doesn't have this class\n    }\n}", "repo_id": "5", "comment": "// `boolean canAccess(Object)`.\n", "repo_name": "guava-master/", "id": 3614, "method_signature": "void testApiCompatibleWithAccessibleObject()", "filename": "InvokableTest.testApiCompatibleWithAccessibleObject.json"}
{"callee_method_names": ["File.delete", "File.mkdir", "Set<File>.add"], "method_name": "IoTestCase.createTempDir", "method_implementation": "{\n    File tempFile = File.createTempFile(\"IoTestCase\", \"\");\n    if (!tempFile.delete() || !tempFile.mkdir()) {\n        throw new IOException(\"failed to create temp dir\");\n    }\n    filesToDelete.add(tempFile);\n    return tempFile;\n}", "repo_id": "5", "comment": "/**\n * Creates a new temp dir for testing. The returned directory and all contents of it will be\n * deleted in the tear-down for this test.\n */\n", "repo_name": "guava-master/", "id": 3651, "method_signature": "File createTempDir()", "filename": "IoTestCase.createTempDir.json"}
{"callee_method_names": [], "method_name": "IoTestCase.getTempDir", "method_implementation": "{\n    if (tempDir == null) {\n        tempDir = createTempDir();\n    }\n    return tempDir;\n}", "repo_id": "5", "comment": "/**\n * Gets a temp dir for testing. The returned directory and all contents of it will be deleted in\n * the tear-down for this test. Subsequent invocations of this method will return the same\n * directory.\n */\n", "repo_name": "guava-master/", "id": 3652, "method_signature": "File getTempDir()", "filename": "IoTestCase.getTempDir.json"}
{"callee_method_names": ["File.exists"], "method_name": "IoTestCase.getTestFile", "method_implementation": "{\n    File file = new File(getTestDir(), name);\n    if (!file.exists()) {\n        URL resourceUrl = IoTestCase.class.getResource(\"testdata/\" + name);\n        if (resourceUrl == null) {\n            return null;\n        }\n        copy(resourceUrl, file);\n    }\n    return file;\n}", "repo_id": "5", "comment": "/**\n * Returns the file with the given name under the testdata directory.\n */\n", "repo_name": "guava-master/", "id": 3650, "method_signature": "File getTestFile(String)", "filename": "IoTestCase.getTestFile.json"}
{"callee_method_names": [], "method_name": "IoTestCase.newPreFilledByteArray", "method_implementation": "{\n    byte[] array = new byte[size];\n    for (int i = 0; i < size; i++) {\n        array[i] = (byte) (offset + i);\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns a byte array of length size that has values offset .. offset + size - 1.\n */\n", "repo_name": "guava-master/", "id": 3653, "method_signature": "byte[] newPreFilledByteArray(int, int)", "filename": "IoTestCase.newPreFilledByteArray.json"}
{"callee_method_names": ["Collection<T>.addAll"], "method_name": "Iterables.addAll", "method_implementation": "{\n    if (elementsToAdd instanceof Collection) {\n        Collection<? extends T> c = (Collection<? extends T>) elementsToAdd;\n        return addTo.addAll(c);\n    }\n    return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());\n}", "repo_id": "5", "comment": "/**\n * Adds all elements in {@code iterable} to {@code collection}.\n *\n * @return {@code true} if {@code collection} was modified as a result of this operation.\n */\n", "repo_name": "guava-master/", "id": 5980, "method_signature": "boolean addAll(Collection, Iterable)", "filename": "Iterables.addAll.json"}
{"callee_method_names": ["Iterable<E>.iterator"], "method_name": "Iterables.castOrCopyToCollection", "method_implementation": "{\n    return (iterable instanceof Collection) ? (Collection<E>) iterable : Lists.newArrayList(iterable.iterator());\n}", "repo_id": "5", "comment": "/**\n * Converts an iterable into a collection. If the iterable is already a collection, it is\n * returned. Otherwise, an {@link java.util.ArrayList} is created with the contents of the\n * iterable in the same iteration order.\n */\n", "repo_name": "guava-master/", "id": 5979, "method_signature": "Collection<E> castOrCopyToCollection(Iterable)", "filename": "Iterables.castOrCopyToCollection.json"}
{"callee_method_names": [], "method_name": "Iterables.concat", "method_implementation": "{\n    return FluentIterable.concat(a, b, c, d);\n}", "repo_id": "5", "comment": "/**\n * Combines four iterables into a single iterable. The returned iterable has an iterator that\n * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the\n * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not\n * polled until necessary.\n *\n * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n * iterator supports it.\n *\n * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n * Streams.concat(a, b, c, d)}.\n */\n", "repo_name": "guava-master/", "id": 5983, "method_signature": "Iterable<T> concat(Iterable, Iterable, Iterable, Iterable)", "filename": "Iterables.concat.json"}
{"callee_method_names": ["Iterable<T>.iterator"], "method_name": "Iterables.consumingIterable", "method_implementation": "{\n    checkNotNull(iterable);\n    return new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return (iterable instanceof Queue) ? new ConsumingQueueIterator<>((Queue<T>) iterable) : Iterators.consumingIterator(iterable.iterator());\n        }\n\n        @Override\n        public String toString() {\n            return \"Iterables.consumingIterable(...)\";\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the supplied iterable that wraps each generated {@link Iterator} through\n * {@link Iterators#consumingIterator(Iterator)}.\n *\n * <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will instead use {@link\n * Queue#isEmpty} and {@link Queue#remove()}, since {@link Queue}'s iteration order is undefined.\n * Calling {@link Iterator#hasNext()} on a generated iterator from the returned iterable may cause\n * an item to be immediately dequeued for return on a subsequent call to {@link Iterator#next()}.\n *\n * <p>Whether the input {@code iterable} is a {@link Queue} or not, the returned {@code Iterable}\n * is not thread-safe.\n *\n * @param iterable the iterable to wrap\n * @return a view of the supplied iterable that wraps each generated iterator through {@link\n *     Iterators#consumingIterator(Iterator)}; for queues, an iterable that generates iterators\n *     that return and consume the queue's elements in queue order\n * @see Iterators#consumingIterator(Iterator)\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 5998, "method_signature": "Iterable<T> consumingIterable(Iterable)", "filename": "Iterables.consumingIterable.json"}
{"callee_method_names": ["Iterable<? extends Object>.iterator"], "method_name": "Iterables.contains", "method_implementation": "{\n    if (iterable instanceof Collection) {\n        Collection<?> collection = (Collection<?>) iterable;\n        return Collections2.safeContains(collection, element);\n    }\n    return Iterators.contains(iterable.iterator(), element);\n}", "repo_id": "5", "comment": "// <? extends @Nullable Object> instead of <?> because of Kotlin b/189937072, discussed in Joiner.\n", "repo_name": "guava-master/", "id": 5971, "method_signature": "boolean contains(Iterable, Object)", "filename": "Iterables.contains.json"}
{"callee_method_names": ["Iterable<T>.toString"], "method_name": "Iterables.cycle", "method_implementation": "{\n    checkNotNull(iterable);\n    return new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return Iterators.cycle(iterable);\n        }\n\n        @Override\n        public String toString() {\n            return iterable.toString() + \" (cycled)\";\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}.\n *\n * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code\n * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n * is empty.\n *\n * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n * should use an explicit {@code break} or be certain that you will eventually remove all the\n * elements.\n *\n * <p>To cycle over the iterable {@code n} times, use the following: {@code\n * Iterables.concat(Collections.nCopies(n, iterable))}\n *\n * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n * Stream.generate(() -> iterable).flatMap(Streams::stream)}.\n */\n", "repo_name": "guava-master/", "id": 5982, "method_signature": "Iterable<T> cycle(Iterable)", "filename": "Iterables.cycle.json"}
{"callee_method_names": ["Collection<?>.size", "Collection<?>.size", "Iterable<?>.iterator", "Iterable<?>.iterator"], "method_name": "Iterables.elementsEqual", "method_implementation": "{\n    if (iterable1 instanceof Collection && iterable2 instanceof Collection) {\n        Collection<?> collection1 = (Collection<?>) iterable1;\n        Collection<?> collection2 = (Collection<?>) iterable2;\n        if (collection1.size() != collection2.size()) {\n            return false;\n        }\n    }\n    return Iterators.elementsEqual(iterable1.iterator(), iterable2.iterator());\n}", "repo_id": "5", "comment": "/**\n * Determines whether two iterables contain equal elements in the same order. More specifically,\n * this method returns {@code true} if {@code iterable1} and {@code iterable2} contain the same\n * number of elements and every element of {@code iterable1} is equal to the corresponding element\n * of {@code iterable2}.\n */\n", "repo_name": "guava-master/", "id": 5976, "method_signature": "boolean elementsEqual(Iterable, Iterable)", "filename": "Iterables.elementsEqual.json"}
{"callee_method_names": [], "method_name": "Iterables.filter", "method_implementation": "{\n    checkNotNull(unfiltered);\n    checkNotNull(desiredType);\n    return (Iterable<T>) filter(unfiltered, Predicates.instanceOf(desiredType));\n}", "repo_id": "5", "comment": "/**\n * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n * desiredType}. The returned iterable's iterator does not support {@code remove()}.\n *\n * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.\n * This does perform a little more work than necessary, so another option is to insert an\n * unchecked cast at some later point:\n *\n * <pre>\n * {@code @SuppressWarnings(\"unchecked\") // safe because of ::isInstance check\n * ImmutableList<NewType> result =\n *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}\n * </pre>\n */\n", "repo_name": "guava-master/", "id": 5987, "method_signature": "Iterable<T> filter(Iterable, Class)", "filename": "Iterables.filter.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator"], "method_name": "Iterables.find", "method_implementation": "{\n    return Iterators.find(iterable.iterator(), predicate, defaultValue);\n}", "repo_id": "5", "comment": "// - @JointlyNullable means \"@Nullable or no annotation\"\n", "repo_name": "guava-master/", "id": 5989, "method_signature": "T find(Iterable, Predicate, T)", "filename": "Iterables.find.json"}
{"callee_method_names": ["Iterable<?>.iterator"], "method_name": "Iterables.frequency", "method_implementation": "{\n    if ((iterable instanceof Multiset)) {\n        return ((Multiset<?>) iterable).count(element);\n    } else if ((iterable instanceof Set)) {\n        return ((Set<?>) iterable).contains(element) ? 1 : 0;\n    }\n    return Iterators.frequency(iterable.iterator(), element);\n}", "repo_id": "5", "comment": "/**\n * Returns the number of elements in the specified iterable that equal the specified object. This\n * implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}.\n *\n * <p><b>Java 8 users:</b> In most cases, the {@code Stream} equivalent of this method is {@code\n * stream.filter(element::equals).count()}. If {@code element} might be null, use {@code\n * stream.filter(Predicate.isEqual(element)).count()} instead.\n *\n * @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,\n *     Object)\n */\n", "repo_name": "guava-master/", "id": 5981, "method_signature": "int frequency(Iterable, Object)", "filename": "Iterables.frequency.json"}
{"callee_method_names": ["List<? extends T>.size", "List<? extends T>.get", "Iterable<? extends T>.iterator"], "method_name": "Iterables.get", "method_implementation": "{\n    checkNotNull(iterable);\n    Iterators.checkNonnegative(position);\n    if (iterable instanceof List) {\n        List<? extends T> list = Lists.cast(iterable);\n        return (position < list.size()) ? list.get(position) : defaultValue;\n    } else {\n        Iterator<? extends T> iterator = iterable.iterator();\n        Iterators.advance(iterator, position);\n        return Iterators.getNext(iterator, defaultValue);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the element at the specified position in an iterable or a default value otherwise.\n *\n * <p><b>{@code Stream} equivalent:</b> {@code\n * stream.skip(position).findFirst().orElse(defaultValue)} (returns the default value if the index\n * is out of bounds)\n *\n * @param position position of the element to return\n * @param defaultValue the default value to return if {@code position} is greater than or equal to\n *     the size of the iterable\n * @return the element at the specified position in {@code iterable} or {@code defaultValue} if\n *     {@code iterable} contains fewer than {@code position + 1} elements.\n * @throws IndexOutOfBoundsException if {@code position} is negative\n * @since 4.0\n */\n", "repo_name": "guava-master/", "id": 5992, "method_signature": "T get(Iterable, int, T)", "filename": "Iterables.get.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator"], "method_name": "Iterables.getFirst", "method_implementation": "{\n    return Iterators.getNext(iterable.iterator(), defaultValue);\n}", "repo_id": "5", "comment": "/**\n * Returns the first element in {@code iterable} or {@code defaultValue} if the iterable is empty.\n * The {@link Iterators} analog to this method is {@link Iterators#getNext}.\n *\n * <p>If no default value is desired (and the caller instead wants a {@link\n * NoSuchElementException} to be thrown), it is recommended that {@code\n * iterable.iterator().next()} is used instead.\n *\n * <p>To get the only element in a single-element {@code Iterable}, consider using {@link\n * #getOnlyElement(Iterable)} or {@link #getOnlyElement(Iterable, Object)} instead.\n *\n * <p><b>{@code Stream} equivalent:</b> {@code stream.findFirst().orElse(defaultValue)}\n *\n * @param defaultValue the default value to return if the iterable is empty\n * @return the first element of {@code iterable} or the default value\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 5993, "method_signature": "T getFirst(Iterable, T)", "filename": "Iterables.getFirst.json"}
{"callee_method_names": ["Collection<? extends T>.isEmpty", "Iterable<? extends T>.iterator"], "method_name": "Iterables.getLast", "method_implementation": "{\n    if (iterable instanceof Collection) {\n        Collection<? extends T> c = (Collection<? extends T>) iterable;\n        if (c.isEmpty()) {\n            return defaultValue;\n        } else if (iterable instanceof List) {\n            return getLastInNonemptyList(Lists.cast(iterable));\n        }\n    }\n    return Iterators.getLast(iterable.iterator(), defaultValue);\n}", "repo_id": "5", "comment": "/**\n * Returns the last element of {@code iterable} or {@code defaultValue} if the iterable is empty.\n * If {@code iterable} is a {@link List} with {@link RandomAccess} support, then this operation is\n * guaranteed to be {@code O(1)}.\n *\n * <p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}\n *\n * @param defaultValue the value to return if {@code iterable} is empty\n * @return the last element of {@code iterable} or the default value\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 5995, "method_signature": "T getLast(Iterable, T)", "filename": "Iterables.getLast.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator"], "method_name": "Iterables.getOnlyElement", "method_implementation": "{\n    return Iterators.getOnlyElement(iterable.iterator(), defaultValue);\n}", "repo_id": "5", "comment": "/**\n * Returns the single element contained in {@code iterable}, or {@code defaultValue} if the\n * iterable is empty.\n *\n * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code\n * stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}.\n *\n * @throws IllegalArgumentException if the iterator contains multiple elements\n */\n", "repo_name": "guava-master/", "id": 5977, "method_signature": "T getOnlyElement(Iterable, T)", "filename": "Iterables.getOnlyElement.json"}
{"callee_method_names": ["Iterable<?>.iterator"], "method_name": "Iterables.isEmpty", "method_implementation": "{\n    if (iterable instanceof Collection) {\n        return ((Collection<?>) iterable).isEmpty();\n    }\n    return !iterable.iterator().hasNext();\n}", "repo_id": "5", "comment": "/**\n * Determines if the given iterable contains no elements.\n *\n * <p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an\n * iterator whether it has any elements <i>remaining</i> (which one does using {@link\n * Iterator#hasNext}).\n *\n * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n *\n * @return {@code true} if the iterable contains no elements\n */\n", "repo_name": "guava-master/", "id": 5999, "method_signature": "boolean isEmpty(Iterable)", "filename": "Iterables.isEmpty.json"}
{"callee_method_names": ["Iterable<T>.iterator"], "method_name": "Iterables.limit", "method_implementation": "{\n    checkNotNull(iterable);\n    checkArgument(limitSize >= 0, \"limit is negative\");\n    return new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return Iterators.limit(iterable.iterator(), limitSize);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view of {@code iterable} containing its first {@code limitSize} elements. If {@code\n * iterable} contains fewer than {@code limitSize} elements, the returned view contains all of its\n * elements. The returned iterable's iterator supports {@code remove()} if {@code iterable}'s\n * iterator does.\n *\n * <p><b>{@code Stream} equivalent:</b> {@link Stream#limit}\n *\n * @param iterable the iterable to limit\n * @param limitSize the maximum number of elements in the returned iterable\n * @throws IllegalArgumentException if {@code limitSize} is negative\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 5997, "method_signature": "Iterable<T> limit(Iterable, int)", "filename": "Iterables.limit.json"}
{"callee_method_names": [], "method_name": "Iterables.mergeSorted", "method_implementation": "{\n    checkNotNull(iterables, \"iterables\");\n    checkNotNull(comparator, \"comparator\");\n    Iterable<T> iterable = new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return Iterators.mergeSorted(Iterables.transform(iterables, Iterable::iterator), comparator);\n        }\n    };\n    return new UnmodifiableIterable<>(iterable);\n}", "repo_id": "5", "comment": "/**\n * Returns an iterable over the merged contents of all given {@code iterables}. Equivalent entries\n * will not be de-duplicated.\n *\n * <p>Callers must ensure that the source {@code iterables} are in non-descending order as this\n * method does not sort its input.\n *\n * <p>For any equivalent elements across all {@code iterables}, it is undefined which element is\n * returned first.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 6000, "method_signature": "Iterable<T> mergeSorted(Iterable, Comparator)", "filename": "Iterables.mergeSorted.json"}
{"callee_method_names": ["Iterable<T>.iterator"], "method_name": "Iterables.paddedPartition", "method_implementation": "{\n    checkNotNull(iterable);\n    checkArgument(size > 0);\n    return new FluentIterable<List<@Nullable T>>() {\n\n        @Override\n        public Iterator<List<@Nullable T>> iterator() {\n            return Iterators.paddedPartition(iterable.iterator(), size);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Divides an iterable into unmodifiable sublists of the given size, padding the final iterable\n * with null values if necessary. For example, partitioning an iterable containing {@code [a, b,\n * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer\n * iterable containing two inner lists of three elements each, all in the original order.\n *\n * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n * method.\n *\n * @param iterable the iterable to return a partitioned view of\n * @param size the desired size of each partition\n * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n *     into partitions (the final iterable may have trailing null elements)\n * @throws IllegalArgumentException if {@code size} is nonpositive\n */\n", "repo_name": "guava-master/", "id": 5985, "method_signature": "Iterable<List<T>> paddedPartition(Iterable, int)", "filename": "Iterables.paddedPartition.json"}
{"callee_method_names": ["Iterable<T>.iterator"], "method_name": "Iterables.partition", "method_implementation": "{\n    checkNotNull(iterable);\n    checkArgument(size > 0);\n    return new FluentIterable<List<T>>() {\n\n        @Override\n        public Iterator<List<T>> iterator() {\n            return Iterators.partition(iterable.iterator(), size);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Divides an iterable into unmodifiable sublists of the given size (the final iterable may be\n * smaller). For example, partitioning an iterable containing {@code [a, b, c, d, e]} with a\n * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterable containing two\n * inner lists of three and two elements, all in the original order.\n *\n * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n * method. The returned lists implement {@link RandomAccess}, whether or not the input list does.\n *\n * <p><b>Note:</b> The current implementation eagerly allocates storage for {@code size} elements.\n * As a consequence, passing values like {@code Integer.MAX_VALUE} can lead to {@link\n * OutOfMemoryError}.\n *\n * <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link Lists#partition(List, int)}\n * instead.\n *\n * @param iterable the iterable to return a partitioned view of\n * @param size the desired size of each partition (the last may be smaller)\n * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n *     into partitions\n * @throws IllegalArgumentException if {@code size} is nonpositive\n */\n", "repo_name": "guava-master/", "id": 5984, "method_signature": "Iterable<List<T>> partition(Iterable, int)", "filename": "Iterables.partition.json"}
{"callee_method_names": ["Iterable<?>.iterator"], "method_name": "Iterables.removeAll", "method_implementation": "{\n    return (removeFrom instanceof Collection) ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove)) : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);\n}", "repo_id": "5", "comment": "/**\n * Removes, from an iterable, every element that belongs to the provided collection.\n *\n * <p>This method calls {@link Collection#removeAll} if {@code iterable} is a collection, and\n * {@link Iterators#removeAll} otherwise.\n *\n * @param removeFrom the iterable to (potentially) remove elements from\n * @param elementsToRemove the elements to remove\n * @return {@code true} if any element was removed from {@code iterable}\n */\n", "repo_name": "guava-master/", "id": 5972, "method_signature": "boolean removeAll(Iterable, Collection)", "filename": "Iterables.removeAll.json"}
{"callee_method_names": ["Iterable<T>.iterator", "Iterator<T>.hasNext", "Iterator<T>.next", "Predicate<? super T>.apply", "Iterator<T>.remove"], "method_name": "Iterables.removeFirstMatching", "method_implementation": "{\n    checkNotNull(predicate);\n    Iterator<T> iterator = removeFrom.iterator();\n    while (iterator.hasNext()) {\n        T next = iterator.next();\n        if (predicate.apply(next)) {\n            iterator.remove();\n            return next;\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Removes and returns the first matching element, or returns {@code null} if there is none.\n */\n", "repo_name": "guava-master/", "id": 5975, "method_signature": "T removeFirstMatching(Iterable, Predicate)", "filename": "Iterables.removeFirstMatching.json"}
{"callee_method_names": ["Iterable<T>.iterator"], "method_name": "Iterables.removeIf", "method_implementation": "{\n    if (removeFrom instanceof RandomAccess && removeFrom instanceof List) {\n        return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n    }\n    return Iterators.removeIf(removeFrom.iterator(), predicate);\n}", "repo_id": "5", "comment": "/**\n * Removes, from an iterable, every element that satisfies the provided predicate.\n *\n * <p>Removals may or may not happen immediately as each element is tested against the predicate.\n * The behavior of this method is not specified if {@code predicate} is dependent on {@code\n * removeFrom}.\n *\n * @param removeFrom the iterable to (potentially) remove elements from\n * @param predicate a predicate that determines whether an element should be removed\n * @return {@code true} if any elements were removed from the iterable\n * @throws UnsupportedOperationException if the iterable does not support {@code remove()}.\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 5974, "method_signature": "boolean removeIf(Iterable, Predicate)", "filename": "Iterables.removeIf.json"}
{"callee_method_names": ["Iterable<?>.iterator"], "method_name": "Iterables.retainAll", "method_implementation": "{\n    return (removeFrom instanceof Collection) ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain)) : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);\n}", "repo_id": "5", "comment": "/**\n * Removes, from an iterable, every element that does not belong to the provided collection.\n *\n * <p>This method calls {@link Collection#retainAll} if {@code iterable} is a collection, and\n * {@link Iterators#retainAll} otherwise.\n *\n * @param removeFrom the iterable to (potentially) remove elements from\n * @param elementsToRetain the elements to retain\n * @return {@code true} if any element was removed from {@code iterable}\n */\n", "repo_name": "guava-master/", "id": 5973, "method_signature": "boolean retainAll(Iterable, Collection)", "filename": "Iterables.retainAll.json"}
{"callee_method_names": ["Iterable<?>.iterator"], "method_name": "Iterables.size", "method_implementation": "{\n    return (iterable instanceof Collection) ? ((Collection<?>) iterable).size() : Iterators.size(iterable.iterator());\n}", "repo_id": "5", "comment": "/**\n * Returns the number of elements in {@code iterable}.\n */\n", "repo_name": "guava-master/", "id": 5970, "method_signature": "int size(Iterable)", "filename": "Iterables.size.json"}
{"callee_method_names": ["List<T>.size", "List<T>.subList", "List<T>.size", "Iterable<T>.iterator", "Iterator<T>.hasNext", "Iterator<T>.next", "Iterator<T>.remove"], "method_name": "Iterables.skip", "method_implementation": "{\n    checkNotNull(iterable);\n    checkArgument(numberToSkip >= 0, \"number to skip cannot be negative\");\n    return new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            if (iterable instanceof List) {\n                final List<T> list = (List<T>) iterable;\n                int toSkip = Math.min(list.size(), numberToSkip);\n                return list.subList(toSkip, list.size()).iterator();\n            }\n            final Iterator<T> iterator = iterable.iterator();\n            Iterators.advance(iterator, numberToSkip);\n            /*\n         * We can't just return the iterator because an immediate call to its\n         * remove() method would remove one of the skipped elements instead of\n         * throwing an IllegalStateException.\n         */\n            return new Iterator<T>() {\n\n                boolean atStart = true;\n\n                @Override\n                public boolean hasNext() {\n                    return iterator.hasNext();\n                }\n\n                @Override\n                @ParametricNullness\n                public T next() {\n                    T result = iterator.next();\n                    // not called if next() fails\n                    atStart = false;\n                    return result;\n                }\n\n                @Override\n                public void remove() {\n                    checkRemove(!atStart);\n                    iterator.remove();\n                }\n            };\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view of {@code iterable} that skips its first {@code numberToSkip} elements. If\n * {@code iterable} contains fewer than {@code numberToSkip} elements, the returned iterable skips\n * all of its elements.\n *\n * <p>Modifications to the underlying {@link Iterable} before a call to {@code iterator()} are\n * reflected in the returned iterator. That is, the iterator skips the first {@code numberToSkip}\n * elements that exist when the {@code Iterator} is created, not when {@code skip()} is called.\n *\n * <p>The returned iterable's iterator supports {@code remove()} if the iterator of the underlying\n * iterable supports it. Note that it is <i>not</i> possible to delete the last skipped element by\n * immediately calling {@code remove()} on that iterator, as the {@code Iterator} contract states\n * that a call to {@code remove()} before a call to {@code next()} will throw an {@link\n * IllegalStateException}.\n *\n * <p><b>{@code Stream} equivalent:</b> {@link Stream#skip}\n *\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 5996, "method_signature": "Iterable<T> skip(Iterable, int)", "filename": "Iterables.skip.json"}
{"callee_method_names": [], "method_name": "Iterables.toArray", "method_implementation": "{\n    return toArray(iterable, ObjectArrays.newArray(type, 0));\n}", "repo_id": "5", "comment": "/**\n * Copies an iterable's elements into an array.\n *\n * @param iterable the iterable to copy\n * @param type the type of the elements\n * @return a newly-allocated array into which all the elements of the iterable have been copied\n */\n", "repo_name": "guava-master/", "id": 5978, "method_signature": "T[] toArray(Iterable, Class)", "filename": "Iterables.toArray.json"}
{"callee_method_names": ["Iterable<F>.iterator"], "method_name": "Iterables.transform", "method_implementation": "{\n    checkNotNull(fromIterable);\n    checkNotNull(function);\n    return new FluentIterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return Iterators.transform(fromIterable.iterator(), function);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view containing the result of applying {@code function} to each element of {@code\n * fromIterable}.\n *\n * <p>The returned iterable's iterator supports {@code remove()} if {@code fromIterable}'s\n * iterator does. After a successful {@code remove()} call, {@code fromIterable} no longer\n * contains the corresponding element.\n *\n * <p>If the input {@code Iterable} is known to be a {@code List} or other {@code Collection},\n * consider {@link Lists#transform} and {@link Collections2#transform}.\n *\n * <p><b>{@code Stream} equivalent:</b> {@link Stream#map}\n */\n", "repo_name": "guava-master/", "id": 5990, "method_signature": "Iterable<T> transform(Iterable, Function)", "filename": "Iterables.transform.json"}
{"callee_method_names": [], "method_name": "Iterables.unmodifiableIterable", "method_implementation": "{\n    checkNotNull(iterable);\n    if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection) {\n        // Since it's unmodifiable, the covariant cast is safe\n        @SuppressWarnings(\"unchecked\")\n        Iterable<T> result = (Iterable<T>) iterable;\n        return result;\n    }\n    return new UnmodifiableIterable<>(iterable);\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of {@code iterable}.\n */\n", "repo_name": "guava-master/", "id": 5969, "method_signature": "Iterable<T> unmodifiableIterable(Iterable)", "filename": "Iterables.unmodifiableIterable.json"}
{"callee_method_names": ["List<String>.iterator"], "method_name": "IterablesTest.create", "method_implementation": "{\n    final List<String> list = asList(strings);\n    return new FluentIterable<String>() {\n\n        @Override\n        public Iterator<String> iterator() {\n            return list.iterator();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a new iterable over the specified strings.\n */\n", "repo_name": "guava-master/", "id": 3943, "method_signature": "Iterable<String> create(String[])", "filename": "IterablesTest.create.json"}
{"callee_method_names": [], "method_name": "IterablesTest.testAddAllToList", "method_implementation": "{\n    List<String> alreadyThere = newArrayList(\"already\", \"there\");\n    List<String> freshlyAdded = newArrayList(\"freshly\", \"added\");\n    boolean changed = Iterables.addAll(alreadyThere, freshlyAdded);\n    assertThat(alreadyThere).containsExactly(\"already\", \"there\", \"freshly\", \"added\").inOrder();\n    assertTrue(changed);\n}", "repo_id": "5", "comment": "// More tests in IteratorsTest\n", "repo_name": "guava-master/", "id": 3941, "method_signature": "void testAddAllToList()", "filename": "IterablesTest.testAddAllToList.json"}
{"callee_method_names": ["List<Integer>.add", "List<List<Integer>>.add", "Iterable<Integer>.toString"], "method_name": "IterablesTest.testConcatIterable", "method_implementation": "{\n    List<Integer> list1 = newArrayList(1);\n    List<Integer> list2 = newArrayList(4);\n    @SuppressWarnings(\"unchecked\")\n    List<List<Integer>> input = newArrayList(list1, list2);\n    Iterable<Integer> result = Iterables.concat(input);\n    assertEquals(asList(1, 4), newArrayList(result));\n    // Now change the inputs and see result dynamically change as well\n    list1.add(2);\n    List<Integer> list3 = newArrayList(3);\n    input.add(1, list3);\n    assertEquals(asList(1, 2, 3, 4), newArrayList(result));\n    assertEquals(\"[1, 2, 3, 4]\", result.toString());\n}", "repo_id": "5", "comment": "// Again, the exhaustive tests are in IteratorsTest\n", "repo_name": "guava-master/", "id": 3940, "method_signature": "void testConcatIterable()", "filename": "IterablesTest.testConcatIterable.json"}
{"callee_method_names": ["Iterable<String>.toString"], "method_name": "IterablesTest.testCycle", "method_implementation": "{\n    Iterable<String> cycle = Iterables.cycle(\"a\", \"b\");\n    int howManyChecked = 0;\n    for (String string : cycle) {\n        String expected = (howManyChecked % 2 == 0) ? \"a\" : \"b\";\n        assertEquals(expected, string);\n        if (howManyChecked++ == 5) {\n            break;\n        }\n    }\n    // We left the last iterator pointing to \"b\". But a new iterator should\n    // always point to \"a\".\n    for (String string : cycle) {\n        assertEquals(\"a\", string);\n        break;\n    }\n    assertEquals(\"[a, b] (cycled)\", cycle.toString());\n}", "repo_id": "5", "comment": "// Far less exhaustive than the tests in IteratorsTest\n", "repo_name": "guava-master/", "id": 3939, "method_signature": "void testCycle()", "filename": "IterablesTest.testCycle.json"}
{"callee_method_names": [], "method_name": "IterablesTest.testElementsEqual", "method_implementation": "{\n    Iterable<?> a;\n    Iterable<?> b;\n    // A few elements.\n    a = asList(4, 8, 15, 16, 23, 42);\n    b = asList(4, 8, 15, 16, 23, 42);\n    assertTrue(Iterables.elementsEqual(a, b));\n    // An element differs.\n    a = asList(4, 8, 15, 12, 23, 42);\n    b = asList(4, 8, 15, 16, 23, 42);\n    assertFalse(Iterables.elementsEqual(a, b));\n    // null versus non-null.\n    a = asList(4, 8, 15, null, 23, 42);\n    b = asList(4, 8, 15, 16, 23, 42);\n    assertFalse(Iterables.elementsEqual(a, b));\n    assertFalse(Iterables.elementsEqual(b, a));\n    // Different lengths.\n    a = asList(4, 8, 15, 16, 23);\n    b = asList(4, 8, 15, 16, 23, 42);\n    assertFalse(Iterables.elementsEqual(a, b));\n    assertFalse(Iterables.elementsEqual(b, a));\n}", "repo_id": "5", "comment": "// More exhaustive tests are in IteratorsTest.\n", "repo_name": "guava-master/", "id": 3942, "method_signature": "void testElementsEqual()", "filename": "IterablesTest.testElementsEqual.json"}
{"callee_method_names": ["List<Integer>.add", "List<Integer>.add", "List<Iterable<Integer>>.add"], "method_name": "IterablesTest.testMergeSorted_skipping_pyramid", "method_implementation": "{\n    List<Iterable<Integer>> iterables = Lists.newLinkedList();\n    List<Integer> allIntegers = Lists.newArrayList();\n    for (int i = 0; i < 20; i++) {\n        List<Integer> list = Lists.newLinkedList();\n        for (int j = 0; j < i; j++) {\n            list.add(j * i);\n            allIntegers.add(j * i);\n        }\n        iterables.add(Ordering.natural().sortedCopy(list));\n    }\n    verifyMergeSorted(iterables, allIntegers);\n}", "repo_id": "5", "comment": "// Like the pyramid, but creates more unique values, along with repeated ones.\n", "repo_name": "guava-master/", "id": 3944, "method_signature": "void testMergeSorted_skipping_pyramid()", "filename": "IterablesTest.testMergeSorted_skipping_pyramid.json"}
{"callee_method_names": [], "method_name": "IteratorBasedImmutableMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6045, "method_signature": "Object writeReplace()", "filename": "IteratorBasedImmutableMap.writeReplace.json"}
{"callee_method_names": ["Iterator<? extends T>.hasNext", "Collection<T>.add", "Iterator<? extends T>.next"], "method_name": "Iterators.addAll", "method_implementation": "{\n    checkNotNull(addTo);\n    checkNotNull(iterator);\n    boolean wasModified = false;\n    while (iterator.hasNext()) {\n        wasModified |= addTo.add(iterator.next());\n    }\n    return wasModified;\n}", "repo_id": "5", "comment": "/**\n * Adds all elements in {@code iterator} to {@code collection}. The iterator will be left\n * exhausted: its {@code hasNext()} method will return {@code false}.\n *\n * @return {@code true} if {@code collection} was modified as a result of this operation\n */\n", "repo_name": "guava-master/", "id": 5658, "method_signature": "boolean addAll(Collection, Iterator)", "filename": "Iterators.addAll.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.next"], "method_name": "Iterators.advance", "method_implementation": "{\n    checkNotNull(iterator);\n    checkArgument(numberToAdvance >= 0, \"numberToAdvance must be nonnegative\");\n    int i;\n    for (i = 0; i < numberToAdvance && iterator.hasNext(); i++) {\n        iterator.next();\n    }\n    return i;\n}", "repo_id": "5", "comment": "/**\n * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times or until {@code\n * hasNext()} returns {@code false}, whichever comes first.\n *\n * @return the number of elements the iterator was advanced\n * @since 13.0 (since 3.0 as {@code Iterators.skip})\n */\n", "repo_name": "guava-master/", "id": 5679, "method_signature": "int advance(Iterator, int)", "filename": "Iterators.advance.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Iterator<T>.next", "Predicate<? super T>.apply"], "method_name": "Iterators.all", "method_implementation": "{\n    checkNotNull(predicate);\n    while (iterator.hasNext()) {\n        T element = iterator.next();\n        if (!predicate.apply(element)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if every element returned by {@code iterator} satisfies the given\n * predicate. If {@code iterator} is empty, {@code true} is returned.\n */\n", "repo_name": "guava-master/", "id": 5668, "method_signature": "boolean all(Iterator, Predicate)", "filename": "Iterators.all.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Iterator<T>.next"], "method_name": "Iterators.asEnumeration", "method_implementation": "{\n    checkNotNull(iterator);\n    return new Enumeration<T>() {\n\n        @Override\n        public boolean hasMoreElements() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        @ParametricNullness\n        public T nextElement() {\n            return iterator.next();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Adapts an {@code Iterator} to the {@code Enumeration} interface.\n *\n * <p>The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if\n * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.\n */\n", "repo_name": "guava-master/", "id": 5686, "method_signature": "Enumeration<T> asEnumeration(Iterator)", "filename": "Iterators.asEnumeration.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.remove"], "method_name": "Iterators.clear", "method_implementation": "{\n    checkNotNull(iterator);\n    while (iterator.hasNext()) {\n        iterator.next();\n        iterator.remove();\n    }\n}", "repo_id": "5", "comment": "/**\n * Clears the iterator using its remove method.\n */\n", "repo_name": "guava-master/", "id": 5683, "method_signature": "void clear(Iterator)", "filename": "Iterators.clear.json"}
{"callee_method_names": [], "method_name": "Iterators.concat", "method_implementation": "{\n    checkNotNull(a);\n    checkNotNull(b);\n    checkNotNull(c);\n    checkNotNull(d);\n    return concat(consumingForArray(a, b, c, d));\n}", "repo_id": "5", "comment": "/**\n * Combines four iterators into a single iterator. The returned iterator iterates across the\n * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in\n * {@code c}, followed by the elements in {@code d}. The source iterators are not polled until\n * necessary.\n *\n * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n * supports it.\n */\n", "repo_name": "guava-master/", "id": 5664, "method_signature": "Iterator<T> concat(Iterator, Iterator, Iterator, Iterator)", "filename": "Iterators.concat.json"}
{"callee_method_names": [], "method_name": "Iterators.concatNoDefensiveCopy", "method_implementation": "{\n    for (Iterator<? extends T> input : checkNotNull(inputs)) {\n        checkNotNull(input);\n    }\n    return concat(consumingForArray(inputs));\n}", "repo_id": "5", "comment": "/**\n * Concats a varargs array of iterators without making a defensive copy of the array.\n */\n", "repo_name": "guava-master/", "id": 5665, "method_signature": "Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>[])", "filename": "Iterators.concatNoDefensiveCopy.json"}
{"callee_method_names": [], "method_name": "Iterators.consumingForArray", "method_implementation": "{\n    return new UnmodifiableIterator<I>() {\n\n        int index = 0;\n\n        @Override\n        public boolean hasNext() {\n            return index < elements.length;\n        }\n\n        @Override\n        public I next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            /*\n         * requireNonNull is safe because our callers always pass non-null arguments. Each element\n         * of the array becomes null only when we iterate past it and then clear it.\n         */\n            I result = requireNonNull(elements[index]);\n            elements[index] = null;\n            index++;\n            return result;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an Iterator that walks the specified array, nulling out elements behind it. This can\n * avoid memory leaks when an element is no longer necessary.\n *\n * <p>This method accepts an array with element type {@code @Nullable T}, but callers must pass an\n * array whose contents are initially non-null. The {@code @Nullable} annotation indicates that\n * this method will write nulls into the array during iteration.\n *\n * <p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.\n */\n", "repo_name": "guava-master/", "id": 5661, "method_signature": "Iterator<I> consumingForArray(I[])", "filename": "Iterators.consumingForArray.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Iterator<T>.next", "Iterator<T>.remove"], "method_name": "Iterators.consumingIterator", "method_implementation": "{\n    checkNotNull(iterator);\n    return new UnmodifiableIterator<T>() {\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        @ParametricNullness\n        public T next() {\n            T next = iterator.next();\n            iterator.remove();\n            return next;\n        }\n\n        @Override\n        public String toString() {\n            return \"Iterators.consumingIterator(...)\";\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the supplied {@code iterator} that removes each element from the supplied\n * {@code iterator} as it is returned.\n *\n * <p>The provided iterator must support {@link Iterator#remove()} or else the returned iterator\n * will fail on the first call to {@code next}. The returned {@link Iterator} is also not\n * thread-safe.\n *\n * @param iterator the iterator to remove and return elements from\n * @return an iterator that removes and returns elements from the supplied iterator\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 5681, "method_signature": "Iterator<T> consumingIterator(Iterator)", "filename": "Iterators.consumingIterator.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.hasNext", "Object.equals", "Iterator<?>.next"], "method_name": "Iterators.contains", "method_implementation": "{\n    if (element == null) {\n        while (iterator.hasNext()) {\n            if (iterator.next() == null) {\n                return true;\n            }\n        }\n    } else {\n        while (iterator.hasNext()) {\n            if (element.equals(iterator.next())) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code iterator} contains {@code element}.\n */\n", "repo_name": "guava-master/", "id": 5649, "method_signature": "boolean contains(Iterator, Object)", "filename": "Iterators.contains.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterable<T>.iterator", "Iterator<?>.hasNext", "Iterable<T>.iterator", "Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.remove"], "method_name": "Iterators.cycle", "method_implementation": "{\n    checkNotNull(iterable);\n    return new Iterator<T>() {\n\n        Iterator<T> iterator = emptyModifiableIterator();\n\n        @Override\n        public boolean hasNext() {\n            /*\n         * Don't store a new Iterator until we know the user can't remove() the last returned\n         * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating\n         * the new one. The result is a ConcurrentModificationException or other bad behavior.\n         *\n         * (If we decide that we really, really hate allocating two Iterators per cycle instead of\n         * one, we can optimistically store the new Iterator and then be willing to throw it out if\n         * the user calls remove().)\n         */\n            return iterator.hasNext() || iterable.iterator().hasNext();\n        }\n\n        @Override\n        @ParametricNullness\n        public T next() {\n            if (!iterator.hasNext()) {\n                iterator = iterable.iterator();\n                if (!iterator.hasNext()) {\n                    throw new NoSuchElementException();\n                }\n            }\n            return iterator.next();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an iterator that cycles indefinitely over the elements of {@code iterable}.\n *\n * <p>The returned iterator supports {@code remove()} if the provided iterator does. After {@code\n * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n * is empty.\n *\n * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n * should use an explicit {@code break} or be certain that you will eventually remove all the\n * elements.\n */\n", "repo_name": "guava-master/", "id": 5660, "method_signature": "Iterator<T> cycle(Iterable)", "filename": "Iterators.cycle.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.next", "Iterator<?>.hasNext"], "method_name": "Iterators.elementsEqual", "method_implementation": "{\n    while (iterator1.hasNext()) {\n        if (!iterator2.hasNext()) {\n            return false;\n        }\n        Object o1 = iterator1.next();\n        Object o2 = iterator2.next();\n        if (!Objects.equal(o1, o2)) {\n            return false;\n        }\n    }\n    return !iterator2.hasNext();\n}", "repo_id": "5", "comment": "/**\n * Determines whether two iterators contain equal elements in the same order. More specifically,\n * this method returns {@code true} if {@code iterator1} and {@code iterator2} contain the same\n * number of elements and every element of {@code iterator1} is equal to the corresponding element\n * of {@code iterator2}.\n *\n * <p>Note that this will modify the supplied iterators, since they will have been advanced some\n * number of elements forward.\n */\n", "repo_name": "guava-master/", "id": 5653, "method_signature": "boolean elementsEqual(Iterator, Iterator)", "filename": "Iterators.elementsEqual.json"}
{"callee_method_names": [], "method_name": "Iterators.filter", "method_implementation": "{\n    return (UnmodifiableIterator<T>) filter(unfiltered, instanceOf(desiredType));\n}", "repo_id": "5", "comment": "/**\n * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n * desiredType}.\n */\n", "repo_name": "guava-master/", "id": 5667, "method_signature": "UnmodifiableIterator<T> filter(Iterator, Class)", "filename": "Iterators.filter.json"}
{"callee_method_names": ["Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Predicate<? super T>.apply"], "method_name": "Iterators.find", "method_implementation": "{\n    checkNotNull(iterator);\n    checkNotNull(predicate);\n    while (iterator.hasNext()) {\n        T t = iterator.next();\n        if (predicate.apply(t)) {\n            return t;\n        }\n    }\n    return defaultValue;\n}", "repo_id": "5", "comment": "// For discussion of this signature, see the corresponding overload of *Iterables*.find.\n", "repo_name": "guava-master/", "id": 5670, "method_signature": "T find(Iterator, Predicate, T)", "filename": "Iterators.find.json"}
{"callee_method_names": [], "method_name": "Iterators.forArrayWithPosition", "method_implementation": "{\n    if (array.length == 0) {\n        // otherwise checked in ArrayItr\n        Preconditions.checkPositionIndex(position, array.length);\n        return emptyListIterator();\n    }\n    return new ArrayItr<>(array, position);\n}", "repo_id": "5", "comment": "/**\n * Returns a list iterator containing the elements in the specified {@code array} in order,\n * starting at the specified {@code position}.\n *\n * <p>The {@code Iterable} equivalent of this method is {@code\n * Arrays.asList(array).listIterator(position)}.\n */\n", "repo_name": "guava-master/", "id": 5684, "method_signature": "UnmodifiableListIterator<T> forArrayWithPosition(T[], int)", "filename": "Iterators.forArrayWithPosition.json"}
{"callee_method_names": ["Enumeration<T>.hasMoreElements", "Enumeration<T>.nextElement"], "method_name": "Iterators.forEnumeration", "method_implementation": "{\n    checkNotNull(enumeration);\n    return new UnmodifiableIterator<T>() {\n\n        @Override\n        public boolean hasNext() {\n            return enumeration.hasMoreElements();\n        }\n\n        @Override\n        @ParametricNullness\n        public T next() {\n            return enumeration.nextElement();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Adapts an {@code Enumeration} to the {@code Iterator} interface.\n *\n * <p>This method has no equivalent in {@link Iterables} because viewing an {@code Enumeration} as\n * an {@code Iterable} is impossible. However, the contents can be <i>copied</i> into a collection\n * using {@link Collections#list}.\n *\n * <p><b>Java 9 users:</b> use {@code enumeration.asIterator()} instead, unless it is important to\n * return an {@code UnmodifiableIterator} instead of a plain {@code Iterator}.\n */\n", "repo_name": "guava-master/", "id": 5685, "method_signature": "UnmodifiableIterator<T> forEnumeration(Enumeration)", "filename": "Iterators.forEnumeration.json"}
{"callee_method_names": [], "method_name": "Iterators.frequency", "method_implementation": "{\n    int count = 0;\n    while (contains(iterator, element)) {\n        // Since it lives in the same class, we know contains gets to the element and then stops,\n        // though that isn't currently publicly documented.\n        count++;\n    }\n    return count;\n}", "repo_id": "5", "comment": "/**\n * Returns the number of elements in the specified iterator that equal the specified object. The\n * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n *\n * @see Collections#frequency\n */\n", "repo_name": "guava-master/", "id": 5659, "method_signature": "int frequency(Iterator, Object)", "filename": "Iterators.frequency.json"}
{"callee_method_names": [], "method_name": "Iterators.get", "method_implementation": "{\n    checkNonnegative(position);\n    advance(iterator, position);\n    return getNext(iterator, defaultValue);\n}", "repo_id": "5", "comment": "/**\n * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code\n * position}th position or {@code defaultValue} otherwise.\n *\n * @param position position of the element to return\n * @param defaultValue the default value to return if the iterator is empty or if {@code position}\n *     is greater than the number of elements remaining in {@code iterator}\n * @return the element at the specified position in {@code iterator} or {@code defaultValue} if\n *     {@code iterator} produces fewer than {@code position + 1} elements.\n * @throws IndexOutOfBoundsException if {@code position} is negative\n * @since 4.0\n */\n", "repo_name": "guava-master/", "id": 5675, "method_signature": "T get(Iterator, int, T)", "filename": "Iterators.get.json"}
{"callee_method_names": ["Iterator<? extends T>.hasNext"], "method_name": "Iterators.getLast", "method_implementation": "{\n    return iterator.hasNext() ? getLast(iterator) : defaultValue;\n}", "repo_id": "5", "comment": "/**\n * Advances {@code iterator} to the end, returning the last element or {@code defaultValue} if the\n * iterator is empty.\n *\n * @param defaultValue the default value to return if the iterator is empty\n * @return the last element of {@code iterator}\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 5678, "method_signature": "T getLast(Iterator, T)", "filename": "Iterators.getLast.json"}
{"callee_method_names": ["Iterator<? extends T>.hasNext", "Iterator<? extends T>.next"], "method_name": "Iterators.getNext", "method_implementation": "{\n    return iterator.hasNext() ? iterator.next() : defaultValue;\n}", "repo_id": "5", "comment": "/**\n * Returns the next element in {@code iterator} or {@code defaultValue} if the iterator is empty.\n * The {@link Iterables} analog to this method is {@link Iterables#getFirst}.\n *\n * @param defaultValue the default value to return if the iterator is empty\n * @return the next element of {@code iterator} or the default value\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 5676, "method_signature": "T getNext(Iterator, T)", "filename": "Iterators.getNext.json"}
{"callee_method_names": ["Iterator<? extends T>.hasNext"], "method_name": "Iterators.getOnlyElement", "method_implementation": "{\n    return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;\n}", "repo_id": "5", "comment": "/**\n * Returns the single element contained in {@code iterator}, or {@code defaultValue} if the\n * iterator is empty.\n *\n * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the\n *     iterator is unspecified.\n */\n", "repo_name": "guava-master/", "id": 5656, "method_signature": "T getOnlyElement(Iterator, T)", "filename": "Iterators.getOnlyElement.json"}
{"callee_method_names": ["Iterator<? extends Iterator<? extends T>>.hasNext", "Deque<Iterator<? extends Iterator<? extends T>>>.isEmpty", "Deque<Iterator<? extends Iterator<? extends T>>>.removeFirst"], "method_name": "Iterators.getTopMetaIterator", "method_implementation": "{\n    while (topMetaIterator == null || !topMetaIterator.hasNext()) {\n        if (metaIterators != null && !metaIterators.isEmpty()) {\n            topMetaIterator = metaIterators.removeFirst();\n        } else {\n            return null;\n        }\n    }\n    return topMetaIterator;\n}", "repo_id": "5", "comment": "// Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.\n", "repo_name": "guava-master/", "id": 5690, "method_signature": "Iterator<? extends Iterator<? extends T>> getTopMetaIterator()", "filename": "Iterators.getTopMetaIterator.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Iterator<T>.next", "Predicate<? super T>.apply"], "method_name": "Iterators.indexOf", "method_implementation": "{\n    checkNotNull(predicate, \"predicate\");\n    for (int i = 0; iterator.hasNext(); i++) {\n        T current = iterator.next();\n        if (predicate.apply(current)) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the index in {@code iterator} of the first element that satisfies the provided {@code\n * predicate}, or {@code -1} if the Iterator has no such elements.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code\n * predicate.apply(Iterators.get(iterator, i))} returns {@code true}, or {@code -1} if there is no\n * such index.\n *\n * <p>If -1 is returned, the iterator will be left exhausted: its {@code hasNext()} method will\n * return {@code false}. Otherwise, the iterator will be set to the element which satisfies the\n * {@code predicate}.\n *\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 5672, "method_signature": "int indexOf(Iterator, Predicate)", "filename": "Iterators.indexOf.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Iterator<T>.next", "Iterator<T>.remove"], "method_name": "Iterators.limit", "method_implementation": "{\n    checkNotNull(iterator);\n    checkArgument(limitSize >= 0, \"limit is negative\");\n    return new Iterator<T>() {\n\n        private int count;\n\n        @Override\n        public boolean hasNext() {\n            return count < limitSize && iterator.hasNext();\n        }\n\n        @Override\n        @ParametricNullness\n        public T next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            count++;\n            return iterator.next();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view containing the first {@code limitSize} elements of {@code iterator}. If {@code\n * iterator} contains fewer than {@code limitSize} elements, the returned view contains all of its\n * elements. The returned iterator supports {@code remove()} if {@code iterator} does.\n *\n * @param iterator the iterator to limit\n * @param limitSize the maximum number of elements in the returned iterator\n * @throws IllegalArgumentException if {@code limitSize} is negative\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 5680, "method_signature": "Iterator<T> limit(Iterator, int)", "filename": "Iterators.limit.json"}
{"callee_method_names": [], "method_name": "Iterators.mergeSorted", "method_implementation": "{\n    checkNotNull(iterators, \"iterators\");\n    checkNotNull(comparator, \"comparator\");\n    return new MergingIterator<>(iterators, comparator);\n}", "repo_id": "5", "comment": "/**\n * Returns an iterator over the merged contents of all given {@code iterators}, traversing every\n * element of the input iterators. Equivalent entries will not be de-duplicated.\n *\n * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n * method does not sort its input.\n *\n * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n * returned first.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 5689, "method_signature": "UnmodifiableIterator<T> mergeSorted(Iterable, Comparator)", "filename": "Iterators.mergeSorted.json"}
{"callee_method_names": [], "method_name": "Iterators.peekingIterator", "method_implementation": "{\n    return checkNotNull(iterator);\n}", "repo_id": "5", "comment": "/**\n * Simply returns its argument.\n *\n * @deprecated no need to use this\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5688, "method_signature": "PeekingIterator<T> peekingIterator(PeekingIterator)", "filename": "Iterators.peekingIterator.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Iterator<T>.next", "Iterator<T>.remove"], "method_name": "Iterators.pollNext", "method_implementation": "{\n    if (iterator.hasNext()) {\n        T result = iterator.next();\n        iterator.remove();\n        return result;\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Deletes and returns the next value from the iterator, or returns {@code null} if there is no\n * such value.\n */\n", "repo_name": "guava-master/", "id": 5682, "method_signature": "T pollNext(Iterator)", "filename": "Iterators.pollNext.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Collection<?>.contains", "Iterator<?>.next", "Iterator<?>.remove"], "method_name": "Iterators.removeAll", "method_implementation": "{\n    checkNotNull(elementsToRemove);\n    boolean result = false;\n    while (removeFrom.hasNext()) {\n        if (elementsToRemove.contains(removeFrom.next())) {\n            removeFrom.remove();\n            result = true;\n        }\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Traverses an iterator and removes every element that belongs to the provided collection. The\n * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n *\n * @param removeFrom the iterator to (potentially) remove elements from\n * @param elementsToRemove the elements to remove\n * @return {@code true} if any element was removed from {@code iterator}\n */\n", "repo_name": "guava-master/", "id": 5650, "method_signature": "boolean removeAll(Iterator, Collection)", "filename": "Iterators.removeAll.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Predicate<? super T>.apply", "Iterator<T>.next", "Iterator<T>.remove"], "method_name": "Iterators.removeIf", "method_implementation": "{\n    checkNotNull(predicate);\n    boolean modified = false;\n    while (removeFrom.hasNext()) {\n        if (predicate.apply(removeFrom.next())) {\n            removeFrom.remove();\n            modified = true;\n        }\n    }\n    return modified;\n}", "repo_id": "5", "comment": "/**\n * Removes every element that satisfies the provided predicate from the iterator. The iterator\n * will be left exhausted: its {@code hasNext()} method will return {@code false}.\n *\n * @param removeFrom the iterator to (potentially) remove elements from\n * @param predicate a predicate that determines whether an element should be removed\n * @return {@code true} if any elements were removed from the iterator\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 5651, "method_signature": "boolean removeIf(Iterator, Predicate)", "filename": "Iterators.removeIf.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Collection<?>.contains", "Iterator<?>.next", "Iterator<?>.remove"], "method_name": "Iterators.retainAll", "method_implementation": "{\n    checkNotNull(elementsToRetain);\n    boolean result = false;\n    while (removeFrom.hasNext()) {\n        if (!elementsToRetain.contains(removeFrom.next())) {\n            removeFrom.remove();\n            result = true;\n        }\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Traverses an iterator and removes every element that does not belong to the provided\n * collection. The iterator will be left exhausted: its {@code hasNext()} method will return\n * {@code false}.\n *\n * @param removeFrom the iterator to (potentially) remove elements from\n * @param elementsToRetain the elements to retain\n * @return {@code true} if any element was removed from {@code iterator}\n */\n", "repo_name": "guava-master/", "id": 5652, "method_signature": "boolean retainAll(Iterator, Collection)", "filename": "Iterators.retainAll.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.next"], "method_name": "Iterators.size", "method_implementation": "{\n    long count = 0L;\n    while (iterator.hasNext()) {\n        iterator.next();\n        count++;\n    }\n    return Ints.saturatedCast(count);\n}", "repo_id": "5", "comment": "/**\n * Returns the number of elements remaining in {@code iterator}. The iterator will be left\n * exhausted: its {@code hasNext()} method will return {@code false}.\n */\n", "repo_name": "guava-master/", "id": 5648, "method_signature": "int size(Iterator)", "filename": "Iterators.size.json"}
{"callee_method_names": [], "method_name": "Iterators.toArray", "method_implementation": "{\n    List<T> list = Lists.newArrayList(iterator);\n    return Iterables.<T>toArray(list, type);\n}", "repo_id": "5", "comment": "/**\n * Copies an iterator's elements into an array. The iterator will be left exhausted: its {@code\n * hasNext()} method will return {@code false}.\n *\n * @param iterator the iterator to copy\n * @param type the type of the elements\n * @return a newly-allocated array into which all the elements of the iterator have been copied\n */\n", "repo_name": "guava-master/", "id": 5657, "method_signature": "T[] toArray(Iterator, Class)", "filename": "Iterators.toArray.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "StringBuilder.append", "StringBuilder.append", "Iterator<?>.next", "StringBuilder.append"], "method_name": "Iterators.toString", "method_implementation": "{\n    StringBuilder sb = new StringBuilder().append('[');\n    boolean first = true;\n    while (iterator.hasNext()) {\n        if (!first) {\n            sb.append(\", \");\n        }\n        first = false;\n        sb.append(iterator.next());\n    }\n    return sb.append(']').toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of {@code iterator}, with the format {@code [e1, e2, ..., en]}.\n * The iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n */\n", "repo_name": "guava-master/", "id": 5654, "method_signature": "String toString(Iterator)", "filename": "Iterators.toString.json"}
{"callee_method_names": ["Function<? super F,? extends T>.apply"], "method_name": "Iterators.transform", "method_implementation": "{\n    checkNotNull(function);\n    return new TransformedIterator<F, T>(fromIterator) {\n\n        @ParametricNullness\n        @Override\n        T transform(@ParametricNullness F from) {\n            return function.apply(from);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view containing the result of applying {@code function} to each element of {@code\n * fromIterator}.\n *\n * <p>The returned iterator supports {@code remove()} if {@code fromIterator} does. After a\n * successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding\n * element.\n */\n", "repo_name": "guava-master/", "id": 5673, "method_signature": "Iterator<T> transform(Iterator, Function)", "filename": "Iterators.transform.json"}
{"callee_method_names": ["Iterator<T>.hasNext", "Iterator<T>.next", "Predicate<? super T>.apply"], "method_name": "Iterators.tryFind", "method_implementation": "{\n    checkNotNull(iterator);\n    checkNotNull(predicate);\n    while (iterator.hasNext()) {\n        T t = iterator.next();\n        if (predicate.apply(t)) {\n            return Optional.of(t);\n        }\n    }\n    return Optional.absent();\n}", "repo_id": "5", "comment": "/**\n * Returns an {@link Optional} containing the first element in {@code iterator} that satisfies the\n * given predicate, if such an element exists. If no such element is found, an empty {@link\n * Optional} will be returned from this method and the iterator will be left exhausted: its {@code\n * hasNext()} method will return {@code false}.\n *\n * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n * is matched in {@code iterator}, a NullPointerException will be thrown.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 5671, "method_signature": "Optional<T> tryFind(Iterator, Predicate)", "filename": "Iterators.tryFind.json"}
{"callee_method_names": [], "method_name": "Iterators.unmodifiableIterator", "method_implementation": "{\n    return checkNotNull(iterator);\n}", "repo_id": "5", "comment": "/**\n * Simply returns its argument.\n *\n * @deprecated no need to use this\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5647, "method_signature": "UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator)", "filename": "Iterators.unmodifiableIterator.json"}
{"callee_method_names": ["Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.hasNext", "Iterator<Integer>.next"], "method_name": "IteratorsTest.testConcatContainingNull", "method_implementation": "{\n    @SuppressWarnings(\"unchecked\")\n    Iterator<Iterator<Integer>> input = asList(iterateOver(1, 2), null, iterateOver(3)).iterator();\n    Iterator<Integer> result = Iterators.concat(input);\n    assertEquals(1, (int) result.next());\n    assertEquals(2, (int) result.next());\n    try {\n        result.hasNext();\n        fail(\"no exception thrown\");\n    } catch (NullPointerException e) {\n    }\n    try {\n        result.next();\n        fail(\"no exception thrown\");\n    } catch (NullPointerException e) {\n    }\n    // There is no way to get \"through\" to the 3.  Buh-bye\n}", "repo_id": "5", "comment": "/**\n * Illustrates the somewhat bizarre behavior when a null is passed in.\n */\n", "repo_name": "guava-master/", "id": 4032, "method_signature": "void testConcatContainingNull()", "filename": "IteratorsTest.testConcatContainingNull.json"}
{"callee_method_names": [], "method_name": "Itr.checkNext", "method_implementation": "{\n    if (nextIndex == putIndex) {\n        nextIndex = -1;\n        nextItem = null;\n    } else {\n        nextItem = items[nextIndex];\n        if (nextItem == null)\n            nextIndex = -1;\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks whether nextIndex is valid; if so setting nextItem. Stops iterator when either hits\n * putIndex or sees null item.\n */\n", "repo_name": "guava-master/", "id": 3509, "method_signature": "void checkNext()", "filename": "Itr.checkNext.json"}
{"callee_method_names": ["Future.get", "Future.cancel"], "method_name": "JSR166TestCase.assertFutureTimesOut", "method_implementation": "{\n    long startTime = System.nanoTime();\n    try {\n        future.get(timeoutMillis, MILLISECONDS);\n        shouldThrow();\n    } catch (TimeoutException success) {\n    } catch (Exception e) {\n        threadUnexpectedException(e);\n    } finally {\n        future.cancel(true);\n    }\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis);\n}", "repo_id": "5", "comment": "/**\n * Checks that future.get times out, with the given millisecond timeout.\n */\n", "repo_name": "guava-master/", "id": 3783, "method_signature": "void assertFutureTimesOut(Future, long)", "filename": "JSR166TestCase.assertFutureTimesOut.json"}
{"callee_method_names": ["Thread.isAlive"], "method_name": "JSR166TestCase.assertThreadStaysAlive", "method_implementation": "{\n    try {\n        // No need to optimize the failing case via Thread.join.\n        delay(millis);\n        assertTrue(thread.isAlive());\n    } catch (InterruptedException ie) {\n        fail(\"Unexpected InterruptedException\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks that thread does not terminate within the given millisecond delay.\n */\n", "repo_name": "guava-master/", "id": 3781, "method_signature": "void assertThreadStaysAlive(Thread, long)", "filename": "JSR166TestCase.assertThreadStaysAlive.json"}
{"callee_method_names": ["Thread.isAlive"], "method_name": "JSR166TestCase.assertThreadsStayAlive", "method_implementation": "{\n    try {\n        // No need to optimize the failing case via Thread.join.\n        delay(millis);\n        for (Thread thread : threads) assertTrue(thread.isAlive());\n    } catch (InterruptedException ie) {\n        fail(\"Unexpected InterruptedException\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks that the threads do not terminate within the given millisecond delay.\n */\n", "repo_name": "guava-master/", "id": 3782, "method_signature": "void assertThreadsStayAlive(long, Thread[])", "filename": "JSR166TestCase.assertThreadsStayAlive.json"}
{"callee_method_names": ["Thread.join", "Thread.getState", "Thread.interrupt"], "method_name": "JSR166TestCase.awaitTermination", "method_implementation": "{\n    try {\n        t.join(timeoutMillis);\n    } catch (InterruptedException ie) {\n        threadUnexpectedException(ie);\n    } finally {\n        if (t.getState() != Thread.State.TERMINATED) {\n            t.interrupt();\n            fail(\"Test timed out\");\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Waits for the specified time (in milliseconds) for the thread to terminate (using {@link\n * Thread#join(long)}), else interrupts the thread (in the hope that it may terminate later) and\n * fails.\n */\n", "repo_name": "guava-master/", "id": 3789, "method_signature": "void awaitTermination(Thread, long)", "filename": "JSR166TestCase.awaitTermination.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.delay", "method_implementation": "{\n    long startTime = System.nanoTime();\n    long ns = millis * 1000 * 1000;\n    for (; ; ) {\n        if (millis > 0L)\n            Thread.sleep(millis);\n        else\n            // too short to sleep\n            Thread.yield();\n        long d = ns - (System.nanoTime() - startTime);\n        if (d > 0L)\n            millis = d / (1000 * 1000);\n        else\n            break;\n    }\n}", "repo_id": "5", "comment": "/**\n * Delays, via Thread.sleep, for the given millisecond delay, but if the sleep is shorter than\n * specified, may re-sleep or yield until time elapses.\n */\n", "repo_name": "guava-master/", "id": 3779, "method_signature": "void delay(long)", "filename": "JSR166TestCase.delay.json"}
{"callee_method_names": ["ExecutorService.shutdown", "ExecutorService.awaitTermination"], "method_name": "JSR166TestCase.joinPool", "method_implementation": "{\n    try {\n        exec.shutdown();\n        assertTrue(\"ExecutorService did not terminate in a timely manner\", exec.awaitTermination(2 * LONG_DELAY_MS, MILLISECONDS));\n    } catch (SecurityException ok) {\n        // Allowed in case test doesn't have privs\n    } catch (InterruptedException ie) {\n        fail(\"Unexpected InterruptedException\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Waits out termination of a thread pool or fails doing so.\n */\n", "repo_name": "guava-master/", "id": 3780, "method_signature": "void joinPool(ExecutorService)", "filename": "JSR166TestCase.joinPool.json"}
{"callee_method_names": ["Thread.setDaemon", "Thread.start"], "method_name": "JSR166TestCase.newStartedThread", "method_implementation": "{\n    Thread t = new Thread(runnable);\n    t.setDaemon(true);\n    t.start();\n    return t;\n}", "repo_id": "5", "comment": "/**\n * Returns a new started daemon Thread running the given runnable.\n */\n", "repo_name": "guava-master/", "id": 3788, "method_signature": "Thread newStartedThread(Runnable)", "filename": "JSR166TestCase.newStartedThread.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.permissivePolicy", "method_implementation": "{\n    return new AdjustablePolicy(// Permissions j.u.c. needs directly\n    new RuntimePermission(\"modifyThread\"), new RuntimePermission(\"getClassLoader\"), new RuntimePermission(\"setContextClassLoader\"), // Permissions needed to change permissions!\n    new SecurityPermission(\"getPolicy\"), new SecurityPermission(\"setPolicy\"), new RuntimePermission(\"setSecurityManager\"), // Permissions needed by the junit test harness\n    new RuntimePermission(\"accessDeclaredMembers\"), new PropertyPermission(\"*\", \"read\"), new java.io.FilePermission(\"<<ALL FILES>>\", \"read\"));\n}", "repo_id": "5", "comment": "/**\n * Returns a policy containing all the permissions we ever need.\n */\n", "repo_name": "guava-master/", "id": 3785, "method_signature": "Policy permissivePolicy()", "filename": "JSR166TestCase.permissivePolicy.json"}
{"callee_method_names": ["Runnable.run", "Runnable.run", "AdjustablePolicy.addPermission"], "method_name": "JSR166TestCase.runWithPermissions", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm == null) {\n        r.run();\n        Policy savedPolicy = Policy.getPolicy();\n        try {\n            Policy.setPolicy(permissivePolicy());\n            System.setSecurityManager(new SecurityManager());\n            runWithPermissions(r, permissions);\n        } finally {\n            System.setSecurityManager(null);\n            Policy.setPolicy(savedPolicy);\n        }\n    } else {\n        Policy savedPolicy = Policy.getPolicy();\n        AdjustablePolicy policy = new AdjustablePolicy(permissions);\n        Policy.setPolicy(policy);\n        try {\n            r.run();\n        } finally {\n            policy.addPermission(new SecurityPermission(\"setPolicy\"));\n            Policy.setPolicy(savedPolicy);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Runs Runnable r with a security policy that permits precisely the specified permissions. If\n * there is no current security manager, the runnable is run twice, both with and without a\n * security manager. We require that any security manager permit getPolicy/setPolicy.\n */\n", "repo_name": "guava-master/", "id": 3784, "method_signature": "void runWithPermissions(Runnable, Permission[])", "filename": "JSR166TestCase.runWithPermissions.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.setDelays", "method_implementation": "{\n    SHORT_DELAY_MS = getShortDelay();\n    SMALL_DELAY_MS = SHORT_DELAY_MS * 5;\n    MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;\n    LONG_DELAY_MS = SHORT_DELAY_MS * 200;\n}", "repo_id": "5", "comment": "/**\n * Sets delays as multiples of SHORT_DELAY.\n */\n", "repo_name": "guava-master/", "id": 3769, "method_signature": "void setDelays()", "filename": "JSR166TestCase.setDelays.json"}
{"callee_method_names": ["AssertionFailedError.initCause"], "method_name": "JSR166TestCase.sleep", "method_implementation": "{\n    try {\n        delay(millis);\n    } catch (InterruptedException ie) {\n        AssertionFailedError afe = new AssertionFailedError(\"Unexpected InterruptedException\");\n        afe.initCause(ie);\n        throw afe;\n    }\n}", "repo_id": "5", "comment": "/**\n * Sleeps until the given time has elapsed. Throws AssertionFailedError if interrupted.\n */\n", "repo_name": "guava-master/", "id": 3786, "method_signature": "void sleep(long)", "filename": "JSR166TestCase.sleep.json"}
{"callee_method_names": ["AtomicReference.getAndSet", "Throwable.toString", "AssertionFailedError.initCause"], "method_name": "JSR166TestCase.tearDown", "method_implementation": "{\n    Throwable t = threadFailure.getAndSet(null);\n    if (t != null) {\n        if (t instanceof Error)\n            throw (Error) t;\n        else if (t instanceof RuntimeException)\n            throw (RuntimeException) t;\n        else if (t instanceof Exception)\n            throw (Exception) t;\n        else {\n            AssertionFailedError afe = new AssertionFailedError(t.toString());\n            afe.initCause(t);\n            throw afe;\n        }\n    }\n    if (Thread.interrupted())\n        throw new AssertionFailedError(\"interrupt status set in main thread\");\n}", "repo_id": "5", "comment": "/**\n * Extra checks that get done for all test cases.\n *\n * <p>Triggers test case failure if any thread assertions have failed, by rethrowing, in the test\n * harness thread, any exception recorded earlier by threadRecordFailure.\n *\n * <p>Triggers test case failure if interrupt status is set in the main thread.\n */\n", "repo_name": "guava-master/", "id": 3770, "method_signature": "void tearDown()", "filename": "JSR166TestCase.tearDown.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.threadAssertEquals", "method_implementation": "{\n    try {\n        assertEquals(x, y);\n    } catch (AssertionFailedError t) {\n        threadRecordFailure(t);\n        throw t;\n    } catch (Throwable t) {\n        threadUnexpectedException(t);\n    }\n}", "repo_id": "5", "comment": "/**\n * Just like assertEquals(x, y), but additionally recording (using threadRecordFailure) any\n * AssertionFailedError thrown, so that the current testcase will fail.\n */\n", "repo_name": "guava-master/", "id": 3776, "method_signature": "void threadAssertEquals(Object, Object)", "filename": "JSR166TestCase.threadAssertEquals.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.threadAssertFalse", "method_implementation": "{\n    try {\n        assertFalse(b);\n    } catch (AssertionFailedError t) {\n        threadRecordFailure(t);\n        throw t;\n    }\n}", "repo_id": "5", "comment": "/**\n * Just like assertFalse(b), but additionally recording (using threadRecordFailure) any\n * AssertionFailedError thrown, so that the current testcase will fail.\n */\n", "repo_name": "guava-master/", "id": 3773, "method_signature": "void threadAssertFalse(boolean)", "filename": "JSR166TestCase.threadAssertFalse.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.threadAssertNull", "method_implementation": "{\n    try {\n        assertNull(x);\n    } catch (AssertionFailedError t) {\n        threadRecordFailure(t);\n        throw t;\n    }\n}", "repo_id": "5", "comment": "/**\n * Just like assertNull(x), but additionally recording (using threadRecordFailure) any\n * AssertionFailedError thrown, so that the current testcase will fail.\n */\n", "repo_name": "guava-master/", "id": 3774, "method_signature": "void threadAssertNull(Object)", "filename": "JSR166TestCase.threadAssertNull.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.threadAssertSame", "method_implementation": "{\n    try {\n        assertSame(x, y);\n    } catch (AssertionFailedError t) {\n        threadRecordFailure(t);\n        throw t;\n    }\n}", "repo_id": "5", "comment": "/**\n * Just like assertSame(x, y), but additionally recording (using threadRecordFailure) any\n * AssertionFailedError thrown, so that the current testcase will fail.\n */\n", "repo_name": "guava-master/", "id": 3777, "method_signature": "void threadAssertSame(Object, Object)", "filename": "JSR166TestCase.threadAssertSame.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.threadAssertTrue", "method_implementation": "{\n    try {\n        assertTrue(b);\n    } catch (AssertionFailedError t) {\n        threadRecordFailure(t);\n        throw t;\n    }\n}", "repo_id": "5", "comment": "/**\n * Just like assertTrue(b), but additionally recording (using threadRecordFailure) any\n * AssertionFailedError thrown, so that the current testcase will fail.\n */\n", "repo_name": "guava-master/", "id": 3772, "method_signature": "void threadAssertTrue(boolean)", "filename": "JSR166TestCase.threadAssertTrue.json"}
{"callee_method_names": [], "method_name": "JSR166TestCase.threadFail", "method_implementation": "{\n    try {\n        fail(reason);\n    } catch (AssertionFailedError t) {\n        threadRecordFailure(t);\n        fail(reason);\n    }\n}", "repo_id": "5", "comment": "/**\n * Just like fail(reason), but additionally recording (using threadRecordFailure) any\n * AssertionFailedError thrown, so that the current testcase will fail.\n */\n", "repo_name": "guava-master/", "id": 3771, "method_signature": "void threadFail(String)", "filename": "JSR166TestCase.threadFail.json"}
{"callee_method_names": ["Throwable.printStackTrace", "AssertionFailedError.initCause"], "method_name": "JSR166TestCase.threadUnexpectedException", "method_implementation": "{\n    threadRecordFailure(t);\n    t.printStackTrace();\n    if (t instanceof RuntimeException)\n        throw (RuntimeException) t;\n    else if (t instanceof Error)\n        throw (Error) t;\n    else {\n        AssertionFailedError afe = new AssertionFailedError(\"unexpected exception: \" + t);\n        afe.initCause(t);\n        throw afe;\n    }\n}", "repo_id": "5", "comment": "/**\n * Records the given exception using {@link #threadRecordFailure}, then rethrows the exception,\n * wrapping it in an AssertionFailedError if necessary.\n */\n", "repo_name": "guava-master/", "id": 3778, "method_signature": "void threadUnexpectedException(Throwable)", "filename": "JSR166TestCase.threadUnexpectedException.json"}
{"callee_method_names": ["Thread.getState", "Thread.isAlive"], "method_name": "JSR166TestCase.waitForThreadToEnterWaitState", "method_implementation": "{\n    long startTime = System.nanoTime();\n    for (; ; ) {\n        Thread.State s = thread.getState();\n        if (s == Thread.State.BLOCKED || s == Thread.State.WAITING || s == Thread.State.TIMED_WAITING)\n            return;\n        else if (s == Thread.State.TERMINATED)\n            fail(\"Unexpected thread termination\");\n        else if (millisElapsedSince(startTime) > timeoutMillis) {\n            threadAssertTrue(thread.isAlive());\n            return;\n        }\n        Thread.yield();\n    }\n}", "repo_id": "5", "comment": "/**\n * Spin-waits up to the specified number of milliseconds for the given thread to enter a wait\n * state: BLOCKED, WAITING, or TIMED_WAITING.\n */\n", "repo_name": "guava-master/", "id": 3787, "method_signature": "void waitForThreadToEnterWaitState(Thread, long)", "filename": "JSR166TestCase.waitForThreadToEnterWaitState.json"}
{"callee_method_names": [], "method_name": "JdkBackedImmutableBiMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 3146, "method_signature": "Object writeReplace()", "filename": "JdkBackedImmutableBiMap.writeReplace.json"}
{"callee_method_names": ["Entry<K,V>[].getKey", "Entry<K,V>[].getValue", "Map<K, V>.put", "Entry<K,V>[].getKey", "Map<K, @Nullable V>.put", "Entry<K, V>.getKey", "Map<K, @Nullable V>.containsKey", "Map<K, @Nullable V>.get", "Map<K, @Nullable V>.put"], "method_name": "JdkBackedImmutableMap.create", "method_implementation": "{\n    Map<K, V> delegateMap = Maps.newHashMapWithExpectedSize(n);\n    // If duplicates are allowed, this map will track the last value for each duplicated key.\n    // A second pass will retain only the first entry for that key, but with this last value. The\n    // value will then be replaced by null, signaling that later entries with the same key should\n    // be deleted.\n    Map<K, @Nullable V> duplicates = null;\n    int dupCount = 0;\n    for (int i = 0; i < n; i++) {\n        // requireNonNull is safe because the first `n` elements have been filled in.\n        entryArray[i] = makeImmutable(requireNonNull(entryArray[i]));\n        K key = entryArray[i].getKey();\n        V value = entryArray[i].getValue();\n        V oldValue = delegateMap.put(key, value);\n        if (oldValue != null) {\n            if (throwIfDuplicateKeys) {\n                throw conflictException(\"key\", entryArray[i], entryArray[i].getKey() + \"=\" + oldValue);\n            }\n            if (duplicates == null) {\n                duplicates = new HashMap<>();\n            }\n            duplicates.put(key, value);\n            dupCount++;\n        }\n    }\n    if (duplicates != null) {\n        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n        Entry<K, V>[] newEntryArray = new Entry[n - dupCount];\n        for (int inI = 0, outI = 0; inI < n; inI++) {\n            Entry<K, V> entry = requireNonNull(entryArray[inI]);\n            K key = entry.getKey();\n            if (duplicates.containsKey(key)) {\n                V value = duplicates.get(key);\n                if (value == null) {\n                    // delete this duplicate\n                    continue;\n                }\n                entry = new ImmutableMapEntry<>(key, value);\n                duplicates.put(key, null);\n            }\n            newEntryArray[outI++] = entry;\n        }\n        entryArray = newEntryArray;\n    }\n    return new JdkBackedImmutableMap<>(delegateMap, ImmutableList.asImmutableList(entryArray, n));\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code ImmutableMap} backed by a JDK HashMap. Used when probable hash flooding is\n * detected. This implementation may replace the entries in entryArray with its own entry objects\n * (though they will have the same key/value contents), and will take ownership of entryArray.\n */\n", "repo_name": "guava-master/", "id": 2265, "method_signature": "ImmutableMap<K,V> create(int, Entry<K,V>[], boolean)", "filename": "JdkBackedImmutableMap.create.json"}
{"callee_method_names": [], "method_name": "JdkBackedImmutableMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2266, "method_signature": "Object writeReplace()", "filename": "JdkBackedImmutableMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "JdkBackedImmutableMultiset.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2775, "method_signature": "Object writeReplace()", "filename": "JdkBackedImmutableMultiset.writeReplace.json"}
{"callee_method_names": [], "method_name": "JdkBackedImmutableSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 3265, "method_signature": "Object writeReplace()", "filename": "JdkBackedImmutableSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "JdkFutureAdapters.listenInPoolThread", "method_implementation": "{\n    checkNotNull(executor);\n    if (future instanceof ListenableFuture) {\n        return (ListenableFuture<V>) future;\n    }\n    return new ListenableFutureAdapter<>(future, executor);\n}", "repo_id": "5", "comment": "/**\n * Submits a blocking task for the given {@link Future} to provide {@link ListenableFuture}\n * functionality.\n *\n * <p><b>Warning:</b> If the input future does not already implement {@code ListenableFuture}, the\n * returned future will emulate {@link ListenableFuture#addListener} by submitting a task to the\n * given executor at the first call to {@code addListener}. The task must be started by the\n * executor promptly, or else the returned {@code ListenableFuture} may fail to work. The task's\n * execution consists of blocking until the input future is {@linkplain Future#isDone() done}, so\n * each call to this method may claim and hold a thread for an arbitrary length of time. Use of\n * bounded executors or other executors that may fail to execute a task promptly may result in\n * deadlocks.\n *\n * <p>Prefer to create {@code ListenableFuture} instances with {@link SettableFuture}, {@link\n * MoreExecutors#listeningDecorator( java.util.concurrent.ExecutorService)}, {@link\n * ListenableFutureTask}, {@link AbstractFuture}, and other utilities over creating plain {@code\n * Future} instances to be upgraded to {@code ListenableFuture} after the fact.\n *\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5332, "method_signature": "ListenableFuture<V> listenInPoolThread(Future, Executor)", "filename": "JdkFutureAdapters.listenInPoolThread.json"}
{"callee_method_names": ["CountDownLatch.getCount", "CountDownLatch.countDown"], "method_name": "JdkFutureAdaptersTest.run", "method_implementation": "{\n    checkState(wasRun.getCount() > 0);\n    wasRun.countDown();\n}", "repo_id": "5", "comment": "// synchronized so that checkState works as expected.\n", "repo_name": "guava-master/", "id": 3919, "method_signature": "void run()", "filename": "JdkFutureAdaptersTest.run.json"}
{"callee_method_names": [], "method_name": "Joiner.appendTo", "method_implementation": "{\n    try {\n        appendTo((Appendable) builder, entries);\n    } catch (IOException impossible) {\n        throw new AssertionError(impossible);\n    }\n    return builder;\n}", "repo_id": "5", "comment": "/**\n * Appends the string representation of each entry in {@code entries}, using the previously\n * configured separator and key-value separator, to {@code builder}. Identical to {@link\n * #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4985, "method_signature": "StringBuilder appendTo(StringBuilder, Iterator)", "filename": "Joiner.appendTo.json"}
{"callee_method_names": [], "method_name": "Joiner.join", "method_implementation": "{\n    // TODO: b/316358623 - Remove suppression after fixing checker\n    @SuppressWarnings(\"nullness\")\n    List<?> partsList = Arrays.<@Nullable Object>asList(parts);\n    return join(partsList);\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the string representation of each of {@code parts}, using the\n * previously configured separator between each.\n */\n", "repo_name": "guava-master/", "id": 4980, "method_signature": "String join(Object[])", "filename": "Joiner.join.json"}
{"callee_method_names": ["Object[].hasNext", "Object[].next", "A.append", "Object[].hasNext", "Object[].next", "A.append", "A.append"], "method_name": "Joiner.skipNulls", "method_implementation": "{\n    return new Joiner(this) {\n\n        @Override\n        public <A extends Appendable> A appendTo(A appendable, Iterator<? extends @Nullable Object> parts) throws IOException {\n            checkNotNull(appendable, \"appendable\");\n            checkNotNull(parts, \"parts\");\n            while (parts.hasNext()) {\n                Object part = parts.next();\n                if (part != null) {\n                    appendable.append(Joiner.this.toString(part));\n                    break;\n                }\n            }\n            while (parts.hasNext()) {\n                Object part = parts.next();\n                if (part != null) {\n                    appendable.append(separator);\n                    appendable.append(Joiner.this.toString(part));\n                }\n            }\n            return appendable;\n        }\n\n        @Override\n        public Joiner useForNull(String nullText) {\n            throw new UnsupportedOperationException(\"already specified skipNulls\");\n        }\n\n        @Override\n        public MapJoiner withKeyValueSeparator(String kvs) {\n            throw new UnsupportedOperationException(\"can't use .skipNulls() with maps\");\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a joiner with the same behavior as this joiner, except automatically skipping over any\n * provided null elements.\n */\n", "repo_name": "guava-master/", "id": 4982, "method_signature": "Joiner skipNulls()", "filename": "Joiner.skipNulls.json"}
{"callee_method_names": [], "method_name": "Joiner.useForNull", "method_implementation": "{\n    checkNotNull(nullText);\n    return new Joiner(this) {\n\n        @Override\n        CharSequence toString(@CheckForNull Object part) {\n            return (part == null) ? nullText : Joiner.this.toString(part);\n        }\n\n        @Override\n        public Joiner useForNull(String nullText) {\n            throw new UnsupportedOperationException(\"already specified useForNull\");\n        }\n\n        @Override\n        public Joiner skipNulls() {\n            throw new UnsupportedOperationException(\"already specified useForNull\");\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a joiner with the same behavior as this one, except automatically substituting {@code\n * nullText} for any provided null elements.\n */\n", "repo_name": "guava-master/", "id": 4981, "method_signature": "Joiner useForNull(String)", "filename": "Joiner.useForNull.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.length", "StringBuilder.setLength", "StringBuilder.length", "String.length", "StringBuilder.toString"], "method_name": "JoinerBenchmark.alwaysAppendThenBackUp", "method_implementation": "{\n    int dummy = 0;\n    for (int i = 0; i < reps; i++) {\n        StringBuilder sb = new StringBuilder();\n        for (String comp : components) {\n            sb.append(comp);\n            sb.append(DELIMITER_STRING);\n        }\n        if (sb.length() > 0) {\n            sb.setLength(sb.length() - DELIMITER_STRING.length());\n        }\n        dummy ^= sb.toString().length();\n    }\n    return dummy;\n}", "repo_id": "5", "comment": "/**\n * Always append the delimiter after the component, and in the very end shortens the buffer to get\n * rid of the extra trailing delimiter.\n */\n", "repo_name": "guava-master/", "id": 3484, "method_signature": "int alwaysAppendThenBackUp(int)", "filename": "JoinerBenchmark.alwaysAppendThenBackUp.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JoinerBenchmark.assignDelimiter", "method_implementation": "{\n    int dummy = 0;\n    for (int i = 0; i < reps; i++) {\n        StringBuilder sb = new StringBuilder();\n        String delim = \"\";\n        for (String comp : components) {\n            sb.append(delim);\n            sb.append(comp);\n            delim = DELIMITER_STRING;\n        }\n        dummy ^= sb.toString().length();\n    }\n    return dummy;\n}", "repo_id": "5", "comment": "/**\n * Starts with an empty delimiter and changes to the desired value at the end of the iteration.\n */\n", "repo_name": "guava-master/", "id": 3483, "method_signature": "int assignDelimiter(int)", "filename": "JoinerBenchmark.assignDelimiter.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JoinerBenchmark.booleanIfFirst", "method_implementation": "{\n    int dummy = 0;\n    for (int i = 0; i < reps; i++) {\n        StringBuilder sb = new StringBuilder();\n        boolean append = false;\n        for (String comp : components) {\n            if (append) {\n                sb.append(DELIMITER_STRING);\n            }\n            sb.append(comp);\n            append = true;\n        }\n        dummy ^= sb.toString().length();\n    }\n    return dummy;\n}", "repo_id": "5", "comment": "/**\n * Similar to the above, but keeps a boolean flag rather than checking for the string accumulated\n * so far being empty. As a result, it does not have the above-mentioned bug.\n */\n", "repo_name": "guava-master/", "id": 3482, "method_signature": "int booleanIfFirst(int)", "filename": "JoinerBenchmark.booleanIfFirst.json"}
{"callee_method_names": ["Iterable<String>.iterator", "Iterator<String>.hasNext", "StringBuilder.append", "Iterator<String>.next", "Iterator<String>.hasNext", "StringBuilder.append", "StringBuilder.append", "Iterator<String>.next", "StringBuilder.toString"], "method_name": "JoinerBenchmark.joinerInlined", "method_implementation": "{\n    int dummy = 0;\n    for (int i = 0; i < reps; i++) {\n        StringBuilder sb = new StringBuilder();\n        Iterator<String> iterator = components.iterator();\n        if (iterator.hasNext()) {\n            sb.append(iterator.next().toString());\n            while (iterator.hasNext()) {\n                sb.append(DELIMITER_STRING);\n                sb.append(iterator.next());\n            }\n        }\n        dummy ^= sb.toString().length();\n    }\n    return dummy;\n}", "repo_id": "5", "comment": "/**\n * Mimics what the {@link Joiner} class does internally when no extra options like ignoring {@code\n * null} values are used.\n */\n", "repo_name": "guava-master/", "id": 3480, "method_signature": "int joinerInlined(int)", "filename": "JoinerBenchmark.joinerInlined.json"}
{"callee_method_ids": [4980], "callee_method_names": ["Joiner.join"], "method_name": "JoinerBenchmark.joinerWithCharacterDelimiter", "method_implementation": "{\n    int dummy = 0;\n    for (int i = 0; i < reps; i++) {\n        dummy ^= JOINER_ON_CHARACTER.join(components).length();\n    }\n    return dummy;\n}", "repo_id": "5", "comment": "/**\n * {@link Joiner} with a character delimiter.\n */\n", "repo_name": "guava-master/", "id": 3479, "method_signature": "int joinerWithCharacterDelimiter(int)", "filename": "JoinerBenchmark.joinerWithCharacterDelimiter.json"}
{"callee_method_ids": [4980], "callee_method_names": ["Joiner.join"], "method_name": "JoinerBenchmark.joinerWithStringDelimiter", "method_implementation": "{\n    int dummy = 0;\n    for (int i = 0; i < reps; i++) {\n        dummy ^= JOINER_ON_STRING.join(components).length();\n    }\n    return dummy;\n}", "repo_id": "5", "comment": "/**\n * {@link Joiner} with a string delimiter.\n */\n", "repo_name": "guava-master/", "id": 3478, "method_signature": "int joinerWithStringDelimiter(int)", "filename": "JoinerBenchmark.joinerWithStringDelimiter.json"}
{"callee_method_names": ["StringBuilder.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JoinerBenchmark.stringBuilderIsEmpty", "method_implementation": "{\n    int dummy = 0;\n    for (int i = 0; i < reps; i++) {\n        StringBuilder sb = new StringBuilder();\n        for (String comp : components) {\n            if (sb.length() > 0) {\n                sb.append(DELIMITER_STRING);\n            }\n            sb.append(comp);\n        }\n        dummy ^= sb.toString().length();\n    }\n    return dummy;\n}", "repo_id": "5", "comment": "/**\n * Only appends delimiter if the accumulated string is non-empty. Note: this isn't a candidate\n * implementation for Joiner since it fails on leading empty components.\n */\n", "repo_name": "guava-master/", "id": 3481, "method_signature": "int stringBuilderIsEmpty(int)", "filename": "JoinerBenchmark.stringBuilderIsEmpty.json"}
{"callee_method_names": [], "method_name": "KeySet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5931, "method_signature": "Object writeReplace()", "filename": "KeySet.writeReplace.json"}
{"callee_method_names": [], "method_name": "KeysOrValuesAsList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5930, "method_signature": "Object writeReplace()", "filename": "KeysOrValuesAsList.writeReplace.json"}
{"callee_method_names": [], "method_name": "LenientSerializableTester.reserializeAndAssertLenient", "method_implementation": "{\n    Set<E> copy = reserialize(original);\n    assertEquals(original, copy);\n    assertTrue(copy instanceof ImmutableSet);\n    return copy;\n}", "repo_id": "5", "comment": "/*\n   * TODO(cpovirk): move this to c.g.c.testing if we allow for c.g.c.annotations dependencies so\n   * that it can be GWTified?\n   */\n", "repo_name": "guava-master/", "id": 4023, "method_signature": "Set<E> reserializeAndAssertLenient(Set)", "filename": "LenientSerializableTester.reserializeAndAssertLenient.json"}
{"callee_method_names": ["Class<?>.getEnumConstants"], "method_name": "LexicographicalComparatorHolder.getBestComparator", "method_implementation": "{\n    try {\n        Class<?> theClass = Class.forName(UNSAFE_COMPARATOR_NAME);\n        // requireNonNull is safe because the class is an enum.\n        Object[] constants = requireNonNull(theClass.getEnumConstants());\n        // yes, UnsafeComparator does implement Comparator<byte[]>\n        @SuppressWarnings(\"unchecked\")\n        Comparator<byte[]> comparator = (Comparator<byte[]>) constants[0];\n        return comparator;\n    } catch (Throwable t) {\n        // ensure we really catch *everything*\n        return lexicographicalComparatorJavaImpl();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the Unsafe-using Comparator, or falls back to the pure-Java implementation if unable\n * to do so.\n */\n", "repo_name": "guava-master/", "id": 4319, "method_signature": "Comparator<byte[]> getBestComparator()", "filename": "LexicographicalComparatorHolder.getBestComparator.json"}
{"callee_method_names": ["Class<sun.misc.Unsafe>.getDeclaredFields", "Class<sun.misc.Unsafe>.isInstance", "Class<sun.misc.Unsafe>.cast", "Entry<K, V>.getCause"], "method_name": "LexicographicalComparatorHolder.getUnsafe", "method_implementation": "{\n    try {\n        return sun.misc.Unsafe.getUnsafe();\n    } catch (SecurityException e) {\n        // that's okay; try reflection instead\n    }\n    try {\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n\n            @Override\n            public sun.misc.Unsafe run() throws Exception {\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n                    f.setAccessible(true);\n                    Object x = f.get(null);\n                    if (k.isInstance(x)) {\n                        return k.cast(x);\n                    }\n                }\n                throw new NoSuchFieldError(\"the Unsafe\");\n            }\n        });\n    } catch (java.security.PrivilegedActionException e) {\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple\n * call to Unsafe.getUnsafe when integrating into a jdk.\n *\n * @return a sun.misc.Unsafe\n */\n", "repo_name": "guava-master/", "id": 4318, "method_signature": "sun.misc.Unsafe getUnsafe()", "filename": "LexicographicalComparatorHolder.getUnsafe.json"}
{"callee_method_names": ["InputStream.mark"], "method_name": "LimitedInputStream.mark", "method_implementation": "{\n    in.mark(readLimit);\n    mark = left;\n}", "repo_id": "5", "comment": "// it's okay to mark even if mark isn't supported, as reset won't work\n", "repo_name": "guava-master/", "id": 4824, "method_signature": "void mark(int)", "filename": "LimitedInputStream.mark.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "LineBuffer.add", "method_implementation": "{\n    int pos = off;\n    if (sawReturn && len > 0) {\n        // Last call to add ended with a CR; we can handle the line now.\n        if (finishLine(cbuf[pos] == '\\n')) {\n            pos++;\n        }\n    }\n    int start = pos;\n    for (int end = off + len; pos < end; pos++) {\n        switch(cbuf[pos]) {\n            case '\\r':\n                line.append(cbuf, start, pos - start);\n                sawReturn = true;\n                if (pos + 1 < end) {\n                    if (finishLine(cbuf[pos + 1] == '\\n')) {\n                        pos++;\n                    }\n                }\n                start = pos + 1;\n                break;\n            case '\\n':\n                line.append(cbuf, start, pos - start);\n                finishLine(true);\n                start = pos + 1;\n                break;\n            default:\n        }\n    }\n    line.append(cbuf, start, off + len - start);\n}", "repo_id": "5", "comment": "/**\n * Process additional characters from the stream. When a line separator is found the contents of\n * the line and the line separator itself are passed to the abstract {@link #handleLine} method.\n *\n * @param cbuf the character buffer to process\n * @param off the offset into the buffer\n * @param len the number of characters to process\n * @throws IOException if an I/O error occurs\n * @see #finish\n */\n", "repo_name": "guava-master/", "id": 4853, "method_signature": "void add(char[], int, int)", "filename": "LineBuffer.add.json"}
{"callee_method_names": ["StringBuilder.length"], "method_name": "LineBuffer.finish", "method_implementation": "{\n    if (sawReturn || line.length() > 0) {\n        finishLine(false);\n    }\n}", "repo_id": "5", "comment": "/**\n * Subclasses must call this method after finishing character processing, in order to ensure that\n * any unterminated line in the buffer is passed to {@link #handleLine}.\n *\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4855, "method_signature": "void finish()", "filename": "LineBuffer.finish.json"}
{"callee_method_names": ["StringBuilder.toString"], "method_name": "LineBuffer.finishLine", "method_implementation": "{\n    String separator = sawReturn ? (sawNewline ? \"\\r\\n\" : \"\\r\") : (sawNewline ? \"\\n\" : \"\");\n    handleLine(line.toString(), separator);\n    line = new StringBuilder();\n    sawReturn = false;\n    return sawNewline;\n}", "repo_id": "5", "comment": "/**\n * Called when a line is complete.\n */\n", "repo_name": "guava-master/", "id": 4854, "method_signature": "boolean finishLine(boolean)", "filename": "LineBuffer.finishLine.json"}
{"callee_method_names": ["Reader.read"], "method_name": "LineBufferTest.getChunkedReadable", "method_implementation": "{\n    final Reader reader = getChunkedReader(input, chunk);\n    return new Readable() {\n\n        @Override\n        public int read(CharBuffer cbuf) throws IOException {\n            return reader.read(cbuf);\n        }\n    };\n}", "repo_id": "5", "comment": "// Returns a Readable that is *not* a Reader.\n", "repo_name": "guava-master/", "id": 3649, "method_signature": "Readable getChunkedReadable(String, int)", "filename": "LineBufferTest.getChunkedReadable.json"}
{"callee_method_ids": [4855, 4853], "callee_method_names": ["ArrayDeque.peek", "Reader.read", "Readable.read", "LineBuffer.finish", "LineBuffer.add", "ArrayDeque.poll"], "method_name": "LineReader.readLine", "method_implementation": "{\n    while (lines.peek() == null) {\n        Java8Compatibility.clear(cbuf);\n        // The default implementation of Reader#read(CharBuffer) allocates a\n        // temporary char[], so we call Reader#read(char[], int, int) instead.\n        int read = (reader != null) ? reader.read(buf, 0, buf.length) : readable.read(cbuf);\n        if (read == -1) {\n            lineBuf.finish();\n            break;\n        }\n        lineBuf.add(buf, 0, read);\n    }\n    return lines.poll();\n}", "repo_id": "5", "comment": "/**\n * Reads a line of text. A line is considered to be terminated by any one of a line feed ({@code\n * '\\n'}), a carriage return ({@code '\\r'}), or a carriage return followed immediately by a\n * linefeed ({@code \"\\r\\n\"}).\n *\n * @return a {@code String} containing the contents of the line, not including any\n *     line-termination characters, or {@code null} if the end of the stream has been reached.\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4856, "method_signature": "String readLine()", "filename": "LineReader.readLine.json"}
{"callee_method_names": [], "method_name": "LinearTransformation.and", "method_implementation": "{\n    checkArgument(isFinite(x2) && isFinite(y2));\n    if (x2 == x1) {\n        checkArgument(y2 != y1);\n        return new VerticalLinearTransformation(x1);\n    } else {\n        return withSlope((y2 - y1) / (x2 - x1));\n    }\n}", "repo_id": "5", "comment": "/**\n * Finish building an instance which also maps {@code x = x2} to {@code y = y2}. These values\n * must not both be identical to the values given in the first mapping. If only the {@code x}\n * values are identical, the transformation is vertical. If only the {@code y} values are\n * identical, the transformation is horizontal (i.e. the slope is zero).\n */\n", "repo_name": "guava-master/", "id": 4544, "method_signature": "LinearTransformation and(double, double)", "filename": "LinearTransformation.and.json"}
{"callee_method_names": [], "method_name": "LinearTransformation.horizontal", "method_implementation": "{\n    checkArgument(isFinite(y));\n    double slope = 0.0;\n    return new RegularLinearTransformation(slope, y);\n}", "repo_id": "5", "comment": "/**\n * Builds an instance representing a horizontal transformation with a constant value of {@code y}.\n * (The inverse of this will be a vertical transformation.)\n */\n", "repo_name": "guava-master/", "id": 4546, "method_signature": "LinearTransformation horizontal(double)", "filename": "LinearTransformation.horizontal.json"}
{"callee_method_names": [], "method_name": "LinearTransformation.withSlope", "method_implementation": "{\n    checkArgument(!Double.isNaN(slope));\n    if (isFinite(slope)) {\n        double yIntercept = y1 - x1 * slope;\n        return new RegularLinearTransformation(slope, yIntercept);\n    } else {\n        return new VerticalLinearTransformation(x1);\n    }\n}", "repo_id": "5", "comment": "/**\n * Finish building an instance with the given slope, i.e. the rate of change of {@code y} with\n * respect to {@code x}. The slope must not be {@code NaN}. It may be infinite, in which case\n * the transformation is vertical. (If it is zero, the transformation is horizontal.)\n */\n", "repo_name": "guava-master/", "id": 4545, "method_signature": "LinearTransformation withSlope(double)", "filename": "LinearTransformation.withSlope.json"}
{"callee_method_names": [], "method_name": "LinearTransformationBuilder.and", "method_implementation": "{\n    checkArgument(isFinite(x2) && isFinite(y2));\n    if (x2 == x1) {\n        checkArgument(y2 != y1);\n        return new VerticalLinearTransformation(x1);\n    } else {\n        return withSlope((y2 - y1) / (x2 - x1));\n    }\n}", "repo_id": "5", "comment": "/**\n * Finish building an instance which also maps {@code x = x2} to {@code y = y2}. These values\n * must not both be identical to the values given in the first mapping. If only the {@code x}\n * values are identical, the transformation is vertical. If only the {@code y} values are\n * identical, the transformation is horizontal (i.e. the slope is zero).\n */\n", "repo_name": "guava-master/", "id": 4547, "method_signature": "LinearTransformation and(double, double)", "filename": "LinearTransformationBuilder.and.json"}
{"callee_method_names": [], "method_name": "LinearTransformationBuilder.withSlope", "method_implementation": "{\n    checkArgument(!Double.isNaN(slope));\n    if (isFinite(slope)) {\n        double yIntercept = y1 - x1 * slope;\n        return new RegularLinearTransformation(slope, yIntercept);\n    } else {\n        return new VerticalLinearTransformation(x1);\n    }\n}", "repo_id": "5", "comment": "/**\n * Finish building an instance with the given slope, i.e. the rate of change of {@code y} with\n * respect to {@code x}. The slope must not be {@code NaN}. It may be infinite, in which case\n * the transformation is vertical. (If it is zero, the transformation is horizontal.)\n */\n", "repo_name": "guava-master/", "id": 4548, "method_signature": "LinearTransformation withSlope(double)", "filename": "LinearTransformationBuilder.withSlope.json"}
{"callee_method_names": ["Multimap<? extends K,? extends V>.keySet", "LinkedHashMultimap<K, V>.putAll"], "method_name": "LinkedHashMultimap.create", "method_implementation": "{\n    LinkedHashMultimap<K, V> result = create(multimap.keySet().size(), DEFAULT_VALUE_SET_CAPACITY);\n    result.putAll(multimap);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Constructs a {@code LinkedHashMultimap} with the same mappings as the specified multimap. If a\n * key-value mapping appears multiple times in the input multimap, it only appears once in the\n * constructed multimap. The new multimap has the same {@link Multimap#entries()} iteration order\n * as the input multimap, except for excluding duplicate mappings.\n *\n * @param multimap the multimap whose contents are copied to this multimap\n */\n", "repo_name": "guava-master/", "id": 5557, "method_signature": "LinkedHashMultimap<K,V> create(Multimap)", "filename": "LinkedHashMultimap.create.json"}
{"callee_method_names": [], "method_name": "LinkedHashMultimap.replaceValues", "method_implementation": "{\n    return super.replaceValues(key, values);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If {@code values} is not empty and the multimap already contains a mapping for {@code key},\n * the {@code keySet()} ordering is unchanged. However, the provided values always come last in\n * the {@link #entries()} and {@link #values()} iteration orderings.\n */\n", "repo_name": "guava-master/", "id": 5558, "method_signature": "Set<V> replaceValues(K, Iterable)", "filename": "LinkedHashMultimap.replaceValues.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeInt", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeInt", "ObjectOutputStream.writeObject", "Entry<K, AtomicLong>.getKey", "ObjectOutputStream.writeObject", "Entry<K, AtomicLong>.getValue"], "method_name": "LinkedHashMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeInt(keySet().size());\n    for (K key : keySet()) {\n        stream.writeObject(key);\n    }\n    stream.writeInt(size());\n    for (Entry<K, V> entry : entries()) {\n        stream.writeObject(entry.getKey());\n        stream.writeObject(entry.getValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * @serialData the expected values per key, the number of distinct keys, the number of entries,\n *     and the entries in order\n */\n", "repo_name": "guava-master/", "id": 5559, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "LinkedHashMultimap.writeObject.json"}
{"callee_method_names": [], "method_name": "LinkedHashMultiset.create", "method_implementation": "{\n    LinkedHashMultiset<E> multiset = create(Multisets.inferDistinctElements(elements));\n    Iterables.addAll(multiset, elements);\n    return multiset;\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code LinkedHashMultiset} containing the specified elements.\n *\n * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.\n *\n * @param elements the elements that the multiset should contain\n */\n", "repo_name": "guava-master/", "id": 5951, "method_signature": "LinkedHashMultiset<E> create(Iterable)", "filename": "LinkedHashMultiset.create.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject"], "method_name": "LinkedHashMultiset.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    Serialization.writeMultiset(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the number of distinct elements, the first element, its count, the second element,\n *     its count, and so on\n */\n", "repo_name": "guava-master/", "id": 2576, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "LinkedHashMultiset.writeObject.json"}
{"callee_method_names": ["Map<K, KeyList<K, V>>.put", "Map<K, KeyList<K, V>>.get", "Map<K, KeyList<K, V>>.put", "Map<K, KeyList<K, V>>.get"], "method_name": "LinkedListMultimap.addNode", "method_implementation": "{\n    Node<K, V> node = new Node<>(key, value);\n    if (head == null) {\n        // empty list\n        head = tail = node;\n        keyToKeyList.put(key, new KeyList<K, V>(node));\n        modCount++;\n    } else if (nextSibling == null) {\n        // non-empty list, add to tail\n        // requireNonNull is safe because the list is non-empty.\n        requireNonNull(tail).next = node;\n        node.previous = tail;\n        tail = node;\n        KeyList<K, V> keyList = keyToKeyList.get(key);\n        if (keyList == null) {\n            keyToKeyList.put(key, keyList = new KeyList<>(node));\n            modCount++;\n        } else {\n            keyList.count++;\n            Node<K, V> keyTail = keyList.tail;\n            keyTail.nextSibling = node;\n            node.previousSibling = keyTail;\n            keyList.tail = node;\n        }\n    } else {\n        // non-empty list, insert before nextSibling\n        /*\n       * requireNonNull is safe as long as callers pass a nextSibling that (a) has the same key and\n       * (b) is present in the multimap. (And they do, except maybe in case of concurrent\n       * modification, in which case all bets are off.)\n       */\n        KeyList<K, V> keyList = requireNonNull(keyToKeyList.get(key));\n        keyList.count++;\n        node.previous = nextSibling.previous;\n        node.previousSibling = nextSibling.previousSibling;\n        node.next = nextSibling;\n        node.nextSibling = nextSibling;\n        if (nextSibling.previousSibling == null) {\n            // nextSibling was key head\n            keyList.head = node;\n        } else {\n            nextSibling.previousSibling.nextSibling = node;\n        }\n        if (nextSibling.previous == null) {\n            // nextSibling was head\n            head = node;\n        } else {\n            nextSibling.previous.next = node;\n        }\n        nextSibling.previous = node;\n        nextSibling.previousSibling = node;\n    }\n    size++;\n    return node;\n}", "repo_id": "5", "comment": "/**\n * Adds a new node for the specified key-value pair before the specified {@code nextSibling}\n * element, or at the end of the list if {@code nextSibling} is null. Note: if {@code nextSibling}\n * is specified, it MUST be for a node for the same {@code key}!\n */\n", "repo_name": "guava-master/", "id": 6640, "method_signature": "Node<K,V> addNode(K, V, Node)", "filename": "LinkedListMultimap.addNode.json"}
{"callee_method_names": ["Map<K, KeyList<K, V>>.get"], "method_name": "LinkedListMultimap.get", "method_implementation": "{\n    return new AbstractSequentialList<V>() {\n\n        @Override\n        public int size() {\n            KeyList<K, V> keyList = keyToKeyList.get(key);\n            return (keyList == null) ? 0 : keyList.count;\n        }\n\n        @Override\n        public ListIterator<V> listIterator(int index) {\n            return new ValueForKeyIterator(key, index);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If the multimap is modified while an iteration over the list is in progress (except through\n * the iterator's own {@code add}, {@code set} or {@code remove} operations) the results of the\n * iteration are undefined.\n *\n * <p>The returned list is not serializable and does not have random access.\n */\n", "repo_name": "guava-master/", "id": 6645, "method_signature": "List<V> get(K)", "filename": "LinkedListMultimap.get.json"}
{"callee_method_names": [], "method_name": "LinkedListMultimap.put", "method_implementation": "{\n    addNode(key, value, null);\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Stores a key-value pair in the multimap.\n *\n * @param key key to store in the multimap\n * @param value value to store in the multimap\n * @return {@code true} always\n */\n", "repo_name": "guava-master/", "id": 6642, "method_signature": "boolean put(K, V)", "filename": "LinkedListMultimap.put.json"}
{"callee_method_names": [], "method_name": "LinkedListMultimap.removeAll", "method_implementation": "{\n    /*\n     * Safe because all we do is remove values for the key, not add them. (If we wanted to make sure\n     * to call getCopy and removeAllNodes only with a true K, then we could check containsKey first.\n     * But that check wouldn't eliminate the warnings.)\n     */\n    @SuppressWarnings({ \"unchecked\", \"nullness\" })\n    K castKey = (K) key;\n    List<V> oldValues = getCopy(castKey);\n    removeAllNodes(castKey);\n    return oldValues;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>The returned list is immutable and implements {@link java.util.RandomAccess}.\n */\n", "repo_name": "guava-master/", "id": 6644, "method_signature": "List<V> removeAll(Object)", "filename": "LinkedListMultimap.removeAll.json"}
{"callee_method_names": ["Map<K, KeyList<K, V>>.remove", "Map<K, KeyList<K, V>>.get"], "method_name": "LinkedListMultimap.removeNode", "method_implementation": "{\n    if (node.previous != null) {\n        node.previous.next = node.next;\n    } else {\n        // node was head\n        head = node.next;\n    }\n    if (node.next != null) {\n        node.next.previous = node.previous;\n    } else {\n        // node was tail\n        tail = node.previous;\n    }\n    if (node.previousSibling == null && node.nextSibling == null) {\n        /*\n       * requireNonNull is safe as long as we call removeNode only for nodes that are still in the\n       * Multimap. This should be the case (except in case of concurrent modification, when all bets\n       * are off).\n       */\n        KeyList<K, V> keyList = requireNonNull(keyToKeyList.remove(node.key));\n        keyList.count = 0;\n        modCount++;\n    } else {\n        // requireNonNull is safe (under the conditions listed in the comment in the branch above).\n        KeyList<K, V> keyList = requireNonNull(keyToKeyList.get(node.key));\n        keyList.count--;\n        if (node.previousSibling == null) {\n            // requireNonNull is safe because we checked that not *both* siblings were null.\n            keyList.head = requireNonNull(node.nextSibling);\n        } else {\n            node.previousSibling.nextSibling = node.nextSibling;\n        }\n        if (node.nextSibling == null) {\n            // requireNonNull is safe because we checked that not *both* siblings were null.\n            keyList.tail = requireNonNull(node.previousSibling);\n        } else {\n            node.nextSibling.previousSibling = node.previousSibling;\n        }\n    }\n    size--;\n}", "repo_id": "5", "comment": "/**\n * Removes the specified node from the linked list. This method is only intended to be used from\n * the {@code Iterator} classes. See also {@link LinkedListMultimap#removeAllNodes(Object)}.\n */\n", "repo_name": "guava-master/", "id": 6641, "method_signature": "void removeNode(Node)", "filename": "LinkedListMultimap.removeNode.json"}
{"callee_method_names": ["Iterable<? extends V>.iterator", "ListIterator<V>.hasNext", "Iterator<? extends V>.hasNext", "ListIterator<V>.next", "ListIterator<V>.set", "Iterator<? extends V>.next", "ListIterator<V>.hasNext", "ListIterator<V>.next", "ListIterator<V>.remove", "Iterator<? extends V>.hasNext", "ListIterator<V>.add", "Iterator<? extends V>.next"], "method_name": "LinkedListMultimap.replaceValues", "method_implementation": "{\n    List<V> oldValues = getCopy(key);\n    ListIterator<V> keyValues = new ValueForKeyIterator(key);\n    Iterator<? extends V> newValues = values.iterator();\n    // Replace existing values, if any.\n    while (keyValues.hasNext() && newValues.hasNext()) {\n        keyValues.next();\n        keyValues.set(newValues.next());\n    }\n    // Remove remaining old values, if any.\n    while (keyValues.hasNext()) {\n        keyValues.next();\n        keyValues.remove();\n    }\n    // Add remaining new values, if any.\n    while (newValues.hasNext()) {\n        keyValues.add(newValues.next());\n    }\n    return oldValues;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If any entries for the specified {@code key} already exist in the multimap, their values are\n * changed in-place without affecting the iteration order.\n *\n * <p>The returned list is immutable and implements {@link java.util.RandomAccess}.\n */\n", "repo_name": "guava-master/", "id": 6643, "method_signature": "List<V> replaceValues(K, Iterable)", "filename": "LinkedListMultimap.replaceValues.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeInt", "ObjectOutputStream.writeObject", "long.getKey", "ObjectOutputStream.writeObject", "long.getValue"], "method_name": "LinkedListMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeInt(size());\n    for (Entry<K, V> entry : entries()) {\n        stream.writeObject(entry.getKey());\n        stream.writeObject(entry.getValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * @serialData the number of distinct keys, and then for each distinct key: the first key, the\n *     number of values for that key, and the key's values, followed by successive keys and values\n *     from the entries() ordering\n */\n", "repo_name": "guava-master/", "id": 6646, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "LinkedListMultimap.writeObject.json"}
{"callee_method_names": ["Multimap<String, Integer>.put", "Multimap<String, Integer>.put", "Multimap<String, Integer>.get", "Multimap<String, Integer>.get"], "method_name": "LinkedListMultimapTest.testGetRandomAccess", "method_implementation": "{\n    Multimap<String, Integer> multimap = create();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 3);\n    assertFalse(multimap.get(\"foo\") instanceof RandomAccess);\n    assertFalse(multimap.get(\"bar\") instanceof RandomAccess);\n}", "repo_id": "5", "comment": "/**\n * Confirm that get() returns a List that doesn't implement RandomAccess.\n */\n", "repo_name": "guava-master/", "id": 3997, "method_signature": "void testGetRandomAccess()", "filename": "LinkedListMultimapTest.testGetRandomAccess.json"}
{"callee_method_names": ["Multimap<String, Integer>.put", "Multimap<String, Integer>.put", "Multimap<String, Integer>.removeAll", "Multimap<String, Integer>.removeAll"], "method_name": "LinkedListMultimapTest.testRemoveAllRandomAccess", "method_implementation": "{\n    Multimap<String, Integer> multimap = create();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 3);\n    assertTrue(multimap.removeAll(\"foo\") instanceof RandomAccess);\n    assertTrue(multimap.removeAll(\"bar\") instanceof RandomAccess);\n}", "repo_id": "5", "comment": "/**\n * Confirm that removeAll() returns a List that implements RandomAccess, even though get()\n * doesn't.\n */\n", "repo_name": "guava-master/", "id": 3998, "method_signature": "void testRemoveAllRandomAccess()", "filename": "LinkedListMultimapTest.testRemoveAllRandomAccess.json"}
{"callee_method_names": ["Multimap<String, Integer>.put", "Multimap<String, Integer>.put", "Multimap<String, Integer>.replaceValues", "Multimap<String, Integer>.replaceValues"], "method_name": "LinkedListMultimapTest.testReplaceValuesRandomAccess", "method_implementation": "{\n    Multimap<String, Integer> multimap = create();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 3);\n    assertTrue(multimap.replaceValues(\"foo\", Arrays.asList(2, 4)) instanceof RandomAccess);\n    assertTrue(multimap.replaceValues(\"bar\", Arrays.asList(2, 4)) instanceof RandomAccess);\n}", "repo_id": "5", "comment": "/**\n * Confirm that replaceValues() returns a List that implements RandomAccess, even though get()\n * doesn't.\n */\n", "repo_name": "guava-master/", "id": 3999, "method_signature": "void testReplaceValuesRandomAccess()", "filename": "LinkedListMultimapTest.testReplaceValuesRandomAccess.json"}
{"callee_method_names": [], "method_name": "ListListIteratorTester.testListIterator_fullyModifiable", "method_implementation": "{\n    runListIteratorTest(MODIFIABLE);\n}", "repo_id": "5", "comment": "/*\n   * For now, we don't cope with testing this when the list supports only some\n   * modification operations.\n   */\n", "repo_name": "guava-master/", "id": 4190, "method_signature": "void testListIterator_fullyModifiable()", "filename": "ListListIteratorTester.testListIterator_fullyModifiable.json"}
{"callee_method_names": [], "method_name": "ListTestSuiteBuilder.createTestSuite", "method_implementation": "{\n    withFeatures(KNOWN_ORDER);\n    return super.createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Specifies {@link CollectionFeature#KNOWN_ORDER} for all list tests, since lists have an\n * iteration ordering corresponding to the insertion order.\n */\n", "repo_name": "guava-master/", "id": 4161, "method_signature": "TestSuite createTestSuite()", "filename": "ListTestSuiteBuilder.createTestSuite.json"}
{"callee_method_names": [], "method_name": "ListenableFuture.then", "method_implementation": "{\n    return new Promise<V>((resolve, reject) -> {\n        Futures.addCallback(this, new FutureCallback<V>() {\n\n            @Override\n            public void onSuccess(V value) {\n                resolve.onInvoke(value);\n            }\n\n            @Override\n            public void onFailure(Throwable throwable) {\n                reject.onInvoke(throwable.getBackingJsObject());\n            }\n        }, MoreExecutors.directExecutor());\n    }).then(onFulfilled, onRejected);\n}", "repo_id": "5", "comment": "/**\n * Note that this method is not expected to be overridden.\n */\n", "repo_name": "guava-master/", "id": 6816, "method_signature": "IThenable<R> then(IThenOnFulfilledCallbackFn, IThenOnRejectedCallbackFn)", "filename": "ListenableFuture.then.json"}
{"callee_method_names": ["List<PerListenerQueue<L>>.add"], "method_name": "ListenerCallQueue.addListener", "method_implementation": "{\n    checkNotNull(listener, \"listener\");\n    checkNotNull(executor, \"executor\");\n    listeners.add(new PerListenerQueue<>(listener, executor));\n}", "repo_id": "5", "comment": "/**\n * Adds a listener that will be called using the given executor when events are later {@link\n * #enqueue enqueued} and {@link #dispatch dispatched}.\n */\n", "repo_name": "guava-master/", "id": 5519, "method_signature": "void addListener(L, Executor)", "filename": "ListenerCallQueue.addListener.json"}
{"callee_method_names": ["Executor.execute", "LazyLogger.get"], "method_name": "ListenerCallQueue.dispatch", "method_implementation": "{\n    boolean scheduleEventRunner = false;\n    synchronized (this) {\n        if (!isThreadScheduled) {\n            isThreadScheduled = true;\n            scheduleEventRunner = true;\n        }\n    }\n    if (scheduleEventRunner) {\n        try {\n            executor.execute(this);\n        } catch (Exception e) {\n            // sneaky checked exception\n            // reset state in case of an error so that later dispatch calls will actually do something\n            synchronized (this) {\n                isThreadScheduled = false;\n            }\n            // Log it and keep going.\n            logger.get().log(Level.SEVERE, \"Exception while running callbacks for \" + listener + \" on \" + executor, e);\n            throw e;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Dispatches all listeners {@linkplain #enqueue enqueued} prior to this call, serially and in\n * order.\n */\n", "repo_name": "guava-master/", "id": 5521, "method_signature": "void dispatch()", "filename": "ListenerCallQueue.dispatch.json"}
{"callee_method_names": [], "method_name": "ListeningExecutorService.invokeAll", "method_implementation": "{\n    return invokeAll(tasks, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);\n}", "repo_id": "5", "comment": "/**\n * Duration-based overload of {@link #invokeAll(Collection, long, TimeUnit)}.\n *\n * @since 32.1.0\n */\n", "repo_name": "guava-master/", "id": 1991, "method_signature": "List<Future<T>> invokeAll(Collection, Duration)", "filename": "ListeningExecutorService.invokeAll.json"}
{"callee_method_names": [], "method_name": "ListeningExecutorService.invokeAny", "method_implementation": "{\n    return invokeAny(tasks, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);\n}", "repo_id": "5", "comment": "/**\n * Duration-based overload of {@link #invokeAny(Collection, long, TimeUnit)}.\n *\n * @since 32.1.0\n */\n", "repo_name": "guava-master/", "id": 1992, "method_signature": "T invokeAny(Collection, Duration)", "filename": "ListeningExecutorService.invokeAny.json"}
{"callee_method_names": [], "method_name": "ListeningScheduledExecutorService.scheduleAtFixedRate", "method_implementation": "{\n    return scheduleAtFixedRate(command, toNanosSaturated(initialDelay), toNanosSaturated(period), TimeUnit.NANOSECONDS);\n}", "repo_id": "5", "comment": "/**\n * Duration-based overload of {@link #scheduleAtFixedRate(Runnable, long, long, TimeUnit)}.\n *\n * @since 29.0\n */\n", "repo_name": "guava-master/", "id": 1954, "method_signature": "ListenableScheduledFuture<?> scheduleAtFixedRate(Runnable, Duration, Duration)", "filename": "ListeningScheduledExecutorService.scheduleAtFixedRate.json"}
{"callee_method_names": [], "method_name": "ListeningScheduledExecutorService.scheduleWithFixedDelay", "method_implementation": "{\n    return scheduleWithFixedDelay(command, toNanosSaturated(initialDelay), toNanosSaturated(delay), TimeUnit.NANOSECONDS);\n}", "repo_id": "5", "comment": "/**\n * Duration-based overload of {@link #scheduleWithFixedDelay(Runnable, long, long, TimeUnit)}.\n *\n * @since 29.0\n */\n", "repo_name": "guava-master/", "id": 1955, "method_signature": "ListenableScheduledFuture<?> scheduleWithFixedDelay(Runnable, Duration, Duration)", "filename": "ListeningScheduledExecutorService.scheduleWithFixedDelay.json"}
{"callee_method_names": ["List<E>.listIterator", "ListIterator<E>.add"], "method_name": "Lists.addAllImpl", "method_implementation": "{\n    boolean changed = false;\n    ListIterator<E> listIterator = list.listIterator(index);\n    for (E e : elements) {\n        listIterator.add(e);\n        changed = true;\n    }\n    return changed;\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link List#addAll(int, Collection)}.\n */\n", "repo_name": "guava-master/", "id": 6302, "method_signature": "boolean addAllImpl(List, int, Iterable)", "filename": "Lists.addAllImpl.json"}
{"callee_method_names": ["List<?>.size", "List<?>.size", "List<?>.get", "List<?>.get", "List<?>.iterator", "List<?>.iterator"], "method_name": "Lists.equalsImpl", "method_implementation": "{\n    if (other == checkNotNull(thisList)) {\n        return true;\n    }\n    if (!(other instanceof List)) {\n        return false;\n    }\n    List<?> otherList = (List<?>) other;\n    int size = thisList.size();\n    if (size != otherList.size()) {\n        return false;\n    }\n    if (thisList instanceof RandomAccess && otherList instanceof RandomAccess) {\n        // avoid allocation and use the faster loop\n        for (int i = 0; i < size; i++) {\n            if (!Objects.equal(thisList.get(i), otherList.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return Iterators.elementsEqual(thisList.iterator(), otherList.iterator());\n    }\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link List#equals(Object)}.\n */\n", "repo_name": "guava-master/", "id": 6301, "method_signature": "boolean equalsImpl(List, Object)", "filename": "Lists.equalsImpl.json"}
{"callee_method_names": ["Object.hashCode"], "method_name": "Lists.hashCodeImpl", "method_implementation": "{\n    // TODO(lowasser): worth optimizing for RandomAccess?\n    int hashCode = 1;\n    for (Object o : list) {\n        hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());\n        hashCode = ~~hashCode;\n        // needed to deal with GWT integer overflow\n    }\n    return hashCode;\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link List#hashCode()}.\n */\n", "repo_name": "guava-master/", "id": 6300, "method_signature": "int hashCodeImpl(List)", "filename": "Lists.hashCodeImpl.json"}
{"callee_method_names": ["List<?>.listIterator", "ListIterator<?>.hasNext", "ListIterator<?>.next", "ListIterator<?>.previousIndex"], "method_name": "Lists.indexOfImpl", "method_implementation": "{\n    if (list instanceof RandomAccess) {\n        return indexOfRandomAccess(list, element);\n    } else {\n        ListIterator<?> listIterator = list.listIterator();\n        while (listIterator.hasNext()) {\n            if (Objects.equal(element, listIterator.next())) {\n                return listIterator.previousIndex();\n            }\n        }\n        return -1;\n    }\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link List#indexOf(Object)}.\n */\n", "repo_name": "guava-master/", "id": 6303, "method_signature": "int indexOfImpl(List, Object)", "filename": "Lists.indexOfImpl.json"}
{"callee_method_names": ["List<?>.listIterator", "List<?>.size", "ListIterator<?>.hasPrevious", "ListIterator<?>.previous", "ListIterator<?>.nextIndex"], "method_name": "Lists.lastIndexOfImpl", "method_implementation": "{\n    if (list instanceof RandomAccess) {\n        return lastIndexOfRandomAccess(list, element);\n    } else {\n        ListIterator<?> listIterator = list.listIterator(list.size());\n        while (listIterator.hasPrevious()) {\n            if (Objects.equal(element, listIterator.previous())) {\n                return listIterator.nextIndex();\n            }\n        }\n        return -1;\n    }\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link List#lastIndexOf(Object)}.\n */\n", "repo_name": "guava-master/", "id": 6304, "method_signature": "int lastIndexOfImpl(List, Object)", "filename": "Lists.lastIndexOfImpl.json"}
{"callee_method_names": [], "method_name": "Lists.newArrayList", "method_implementation": "{\n    ArrayList<E> list = newArrayList();\n    Iterators.addAll(list, elements);\n    return list;\n}", "repo_id": "5", "comment": "/**\n * Creates a <i>mutable</i> {@code ArrayList} instance containing the given elements; a very thin\n * shortcut for creating an empty list and then calling {@link Iterators#addAll}.\n *\n * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n * ImmutableList#copyOf(Iterator)} instead.\n */\n", "repo_name": "guava-master/", "id": 6290, "method_signature": "ArrayList<E> newArrayList(Iterator)", "filename": "Lists.newArrayList.json"}
{"callee_method_names": [], "method_name": "Lists.newArrayListWithCapacity", "method_implementation": "{\n    // for GWT.\n    checkNonnegative(initialArraySize, \"initialArraySize\");\n    return new ArrayList<>(initialArraySize);\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code ArrayList} instance backed by an array with the specified initial size;\n * simply delegates to {@link ArrayList#ArrayList(int)}.\n *\n * <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,\n * use {@code new }{@link ArrayList#ArrayList(int) ArrayList}{@code <>(int)} directly, taking\n * advantage of <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>. (Unlike here, there is no risk\n * of overload ambiguity, since the {@code ArrayList} constructors very wisely did not accept\n * varargs.)\n *\n * @param initialArraySize the exact size of the initial backing array for the returned array list\n *     ({@code ArrayList} documentation calls this value the \"capacity\")\n * @return a new, empty {@code ArrayList} which is guaranteed not to resize itself unless its size\n *     reaches {@code initialArraySize + 1}\n * @throws IllegalArgumentException if {@code initialArraySize} is negative\n */\n", "repo_name": "guava-master/", "id": 6291, "method_signature": "ArrayList<E> newArrayListWithCapacity(int)", "filename": "Lists.newArrayListWithCapacity.json"}
{"callee_method_names": [], "method_name": "Lists.newArrayListWithExpectedSize", "method_implementation": "{\n    return new ArrayList<>(computeArrayListCapacity(estimatedSize));\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code ArrayList} instance to hold {@code estimatedSize} elements, <i>plus</i> an\n * unspecified amount of padding; you almost certainly mean to call {@link\n * #newArrayListWithCapacity} (see that method for further advice on usage).\n *\n * <p><b>Note:</b> This method will soon be deprecated. Even in the rare case that you do want\n * some amount of padding, it's best if you choose your desired amount explicitly.\n *\n * @param estimatedSize an estimate of the eventual {@link List#size()} of the new list\n * @return a new, empty {@code ArrayList}, sized appropriately to hold the estimated number of\n *     elements\n * @throws IllegalArgumentException if {@code estimatedSize} is negative\n */\n", "repo_name": "guava-master/", "id": 6292, "method_signature": "ArrayList<E> newArrayListWithExpectedSize(int)", "filename": "Lists.newArrayListWithExpectedSize.json"}
{"callee_method_names": [], "method_name": "Lists.newCopyOnWriteArrayList", "method_implementation": "{\n    // We copy elements to an ArrayList first, rather than incurring the\n    // quadratic cost of adding them to the COWAL directly.\n    Collection<? extends E> elementsCollection = (elements instanceof Collection) ? (Collection<? extends E>) elements : newArrayList(elements);\n    return new CopyOnWriteArrayList<>(elementsCollection);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code CopyOnWriteArrayList} instance containing the given elements.\n *\n * @param elements the elements that the list should contain, in order\n * @return a new {@code CopyOnWriteArrayList} containing those elements\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 6295, "method_signature": "CopyOnWriteArrayList<E> newCopyOnWriteArrayList(Iterable)", "filename": "Lists.newCopyOnWriteArrayList.json"}
{"callee_method_names": [], "method_name": "Lists.newLinkedList", "method_implementation": "{\n    LinkedList<E> list = newLinkedList();\n    Iterables.addAll(list, elements);\n    return list;\n}", "repo_id": "5", "comment": "/**\n * Creates a <i>mutable</i> {@code LinkedList} instance containing the given elements; a very thin\n * shortcut for creating an empty list then calling {@link Iterables#addAll}.\n *\n * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n * ImmutableList#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link\n * FluentIterable} and call {@code elements.toList()}.)\n *\n * <p><b>Performance note:</b> {@link ArrayList} and {@link java.util.ArrayDeque} consistently\n * outperform {@code LinkedList} except in certain rare and specific situations. Unless you have\n * spent a lot of time benchmarking your specific needs, use one of those instead.\n *\n * <p><b>Note:</b> if {@code elements} is a {@link Collection}, you don't need this method. Use\n * the {@code LinkedList} {@linkplain LinkedList#LinkedList(Collection) constructor} directly,\n * taking advantage of <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n */\n", "repo_name": "guava-master/", "id": 6293, "method_signature": "LinkedList<E> newLinkedList(Iterable)", "filename": "Lists.newLinkedList.json"}
{"callee_method_names": [], "method_name": "Lists.partition", "method_implementation": "{\n    checkNotNull(list);\n    checkArgument(size > 0);\n    return (list instanceof RandomAccess) ? new RandomAccessPartition<>(list, size) : new Partition<>(list, size);\n}", "repo_id": "5", "comment": "/**\n * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list, each of the same\n * size (the final list may be smaller). For example, partitioning a list containing {@code [a, b,\n * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list\n * containing two inner lists of three and two elements, all in the original order.\n *\n * <p>The outer list is unmodifiable, but reflects the latest state of the source list. The inner\n * lists are sublist views of the original list, produced on demand using {@link List#subList(int,\n * int)}, and are subject to all the usual caveats about modification as explained in that API.\n *\n * @param list the list to return consecutive sublists of\n * @param size the desired size of each sublist (the last may be smaller)\n * @return a list of consecutive sublists\n * @throws IllegalArgumentException if {@code partitionSize} is nonpositive\n */\n", "repo_name": "guava-master/", "id": 6297, "method_signature": "List<List<T>> partition(List, int)", "filename": "Lists.partition.json"}
{"callee_method_names": [], "method_name": "Lists.reverse", "method_implementation": "{\n    if (list instanceof ImmutableList) {\n        // Avoid nullness warnings.\n        List<?> reversed = ((ImmutableList<?>) list).reverse();\n        @SuppressWarnings(\"unchecked\")\n        List<T> result = (List<T>) reversed;\n        return result;\n    } else if (list instanceof ReverseList) {\n        return ((ReverseList<T>) list).getForwardList();\n    } else if (list instanceof RandomAccess) {\n        return new RandomAccessReverseList<>(list);\n    } else {\n        return new ReverseList<>(list);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a reversed view of the specified list. For example, {@code\n * Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3, 2, 1}. The returned\n * list is backed by this list, so changes in the returned list are reflected in this list, and\n * vice-versa. The returned list supports all of the optional list operations supported by this\n * list.\n *\n * <p>The returned list is random-access if the specified list is random access.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6299, "method_signature": "List<T> reverse(List)", "filename": "Lists.reverse.json"}
{"callee_method_names": ["List<E>.listIterator", "List<E>.listIterator", "List<E>.subList"], "method_name": "Lists.subListImpl", "method_implementation": "{\n    List<E> wrapper;\n    if (list instanceof RandomAccess) {\n        wrapper = new RandomAccessListWrapper<E>(list) {\n\n            @Override\n            public ListIterator<E> listIterator(int index) {\n                return backingList.listIterator(index);\n            }\n\n            @J2ktIncompatible\n            private static final long serialVersionUID = 0;\n        };\n    } else {\n        wrapper = new AbstractListWrapper<E>(list) {\n\n            @Override\n            public ListIterator<E> listIterator(int index) {\n                return backingList.listIterator(index);\n            }\n\n            @J2ktIncompatible\n            private static final long serialVersionUID = 0;\n        };\n    }\n    return wrapper.subList(fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link List#subList(int, int)}.\n */\n", "repo_name": "guava-master/", "id": 6305, "method_signature": "List<E> subListImpl(List, int, int)", "filename": "Lists.subListImpl.json"}
{"callee_method_names": [], "method_name": "Lists.transform", "method_implementation": "{\n    return (fromList instanceof RandomAccess) ? new TransformingRandomAccessList<>(fromList, function) : new TransformingSequentialList<>(fromList, function);\n}", "repo_id": "5", "comment": "/**\n * Returns a list that applies {@code function} to each element of {@code fromList}. The returned\n * list is a transformed view of {@code fromList}; changes to {@code fromList} will be reflected\n * in the returned list and vice versa.\n *\n * <p>Since functions are not reversible, the transform is one-way and new items cannot be stored\n * in the returned list. The {@code add}, {@code addAll} and {@code set} methods are unsupported\n * in the returned list.\n *\n * <p>The function is applied lazily, invoked when needed. This is necessary for the returned list\n * to be a view, but it means that the function will be applied many times for bulk operations\n * like {@link List#contains} and {@link List#hashCode}. For this to perform well, {@code\n * function} should be fast. To avoid lazy evaluation when the returned list doesn't need to be a\n * view, copy the returned list into a new list of your choosing.\n *\n * <p>If {@code fromList} implements {@link RandomAccess}, so will the returned list. The returned\n * list is threadsafe if the supplied list and function are.\n *\n * <p>If only a {@code Collection} or {@code Iterable} input is available, use {@link\n * Collections2#transform} or {@link Iterables#transform}.\n *\n * <p><b>Note:</b> serializing the returned list is implemented by serializing {@code fromList},\n * its contents, and {@code function} -- <i>not</i> by serializing the transformed values. This\n * can lead to surprising behavior, so serializing the returned list is <b>not recommended</b>.\n * Instead, copy the list using {@link ImmutableList#copyOf(Collection)} (for example), then\n * serialize the copy. Other methods similar to this do not implement serialization at all for\n * this reason.\n *\n * <p><b>Java 8 users:</b> many use cases for this method are better addressed by {@link\n * java.util.stream.Stream#map}. This method is not being deprecated, but we gently encourage you\n * to migrate to streams.\n */\n", "repo_name": "guava-master/", "id": 6296, "method_signature": "List<T> transform(List, Function)", "filename": "Lists.transform.json"}
{"callee_method_names": [], "method_name": "Lists.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6298, "method_signature": "Object writeReplace()", "filename": "Lists.writeReplace.json"}
{"callee_method_names": ["List<String>.set", "List<String>.get", "List<String>.add", "List<String>.remove"], "method_name": "ListsTest.testArraysAsList", "method_implementation": "{\n    List<String> ourWay = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n    List<String> otherWay = asList(\"foo\", \"bar\", \"baz\");\n    // They're logically equal\n    assertEquals(ourWay, otherWay);\n    // The result of Arrays.asList() is mutable\n    otherWay.set(0, \"FOO\");\n    assertEquals(\"FOO\", otherWay.get(0));\n    // But it can't grow\n    try {\n        otherWay.add(\"nope\");\n        fail(\"no exception thrown\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    // And it can't shrink\n    try {\n        otherWay.remove(2);\n        fail(\"no exception thrown\");\n    } catch (UnsupportedOperationException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * This is just here to illustrate how {@code Arrays#asList} differs from {@code\n * Lists#newArrayList}.\n */\n", "repo_name": "guava-master/", "id": 4009, "method_signature": "void testArraysAsList()", "filename": "ListsTest.testArraysAsList.json"}
{"callee_method_names": [], "method_name": "ListsTest.testTransformedSequentialIterationUsesBackingListIterationOnly", "method_implementation": "{\n    List<Integer> randomAccessList = Lists.newArrayList(SOME_SEQUENTIAL_LIST);\n    List<Integer> listIteratorOnlyList = new ListIterationOnlyList<>(randomAccessList);\n    List<String> transform = Lists.transform(listIteratorOnlyList, SOME_FUNCTION);\n    assertTrue(Iterables.elementsEqual(transform, Lists.transform(randomAccessList, SOME_FUNCTION)));\n}", "repo_id": "5", "comment": "/**\n * This test depends on the fact that {@code AbstractSequentialList.iterator} transforms the\n * {@code iterator()} call into a call on {@code listIterator(int)}. This is fine because the\n * behavior is clearly documented so it's not expected to change.\n */\n", "repo_name": "guava-master/", "id": 4010, "method_signature": "void testTransformedSequentialIterationUsesBackingListIterationOnly()", "filename": "ListsTest.testTransformedSequentialIterationUsesBackingListIterationOnly.json"}
{"callee_method_names": ["Class<Unsafe>.getDeclaredFields", "Function<A, ? extends B>.setAccessible", "Function<A, ? extends B>.get", "Class<Unsafe>.isInstance", "Class<Unsafe>.cast", "Entry<?, ?>.getCause"], "method_name": "LittleEndianByteArray.getUnsafe", "method_implementation": "{\n    try {\n        return Unsafe.getUnsafe();\n    } catch (SecurityException tryReflectionInstead) {\n        // We'll try reflection instead.\n    }\n    try {\n        return AccessController.doPrivileged((PrivilegedExceptionAction<Unsafe>) () -> {\n            Class<Unsafe> k = Unsafe.class;\n            for (Field f : k.getDeclaredFields()) {\n                f.setAccessible(true);\n                Object x = f.get(null);\n                if (k.isInstance(x)) {\n                    return k.cast(x);\n                }\n            }\n            throw new NoSuchFieldError(\"the Unsafe\");\n        });\n    } catch (PrivilegedActionException e) {\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an Unsafe. Suitable for use in a 3rd party package. Replace with a simple call to\n * Unsafe.getUnsafe when integrating into a JDK.\n *\n * @return an Unsafe instance if successful\n */\n", "repo_name": "guava-master/", "id": 5204, "method_signature": "Unsafe getUnsafe()", "filename": "LittleEndianByteArray.getUnsafe.json"}
{"callee_method_names": [], "method_name": "LittleEndianByteArray.load32", "method_implementation": "{\n    // TODO(user): Measure the benefit of delegating this to LittleEndianBytes also.\n    return (source[offset] & 0xFF) | ((source[offset + 1] & 0xFF) << 8) | ((source[offset + 2] & 0xFF) << 16) | ((source[offset + 3] & 0xFF) << 24);\n}", "repo_id": "5", "comment": "/**\n * Load 4 bytes from the provided array at the indicated offset.\n *\n * @param source the input bytes\n * @param offset the offset into the array at which to start\n * @return the value found in the array in the form of a long\n */\n", "repo_name": "guava-master/", "id": 5203, "method_signature": "int load32(byte[], int)", "filename": "LittleEndianByteArray.load32.json"}
{"callee_method_names": ["LittleEndianBytes.getLongLittleEndian"], "method_name": "LittleEndianByteArray.load64", "method_implementation": "{\n    // We don't want this in production code as this is the most critical part of the loop.\n    assert input.length >= offset + 8;\n    // Delegates to the fast (unsafe) version or the fallback.\n    return byteArray.getLongLittleEndian(input, offset);\n}", "repo_id": "5", "comment": "/**\n * Load 8 bytes into long in a little endian manner, from the substring between position and\n * position + 8. The array must have at least 8 bytes from offset (inclusive).\n *\n * @param input the input bytes\n * @param offset the offset into the array at which to start\n * @return a long of a concatenated 8 bytes\n */\n", "repo_name": "guava-master/", "id": 5200, "method_signature": "long load64(byte[], int)", "filename": "LittleEndianByteArray.load64.json"}
{"callee_method_names": [], "method_name": "LittleEndianByteArray.load64Safely", "method_implementation": "{\n    long result = 0;\n    // Due to the way we shift, we can stop iterating once we've run out of data, the rest\n    // of the result already being filled with zeros.\n    // This loop is critical to performance, so please check HashBenchmark if altering it.\n    int limit = Math.min(length, 8);\n    for (int i = 0; i < limit; i++) {\n        // Shift value left while iterating logically through the array.\n        result |= (input[offset + i] & 0xFFL) << (i * 8);\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes. This\n * has to explicitly reverse the order of the bytes as it packs them into the result which makes\n * it slower than the native version.\n *\n * @param input the input bytes\n * @param offset the offset into the array at which to start reading\n * @param length the number of bytes from the input to read\n * @return a long of a concatenated 8 bytes\n */\n", "repo_name": "guava-master/", "id": 5201, "method_signature": "long load64Safely(byte[], int, int)", "filename": "LittleEndianByteArray.load64Safely.json"}
{"callee_method_names": ["LittleEndianBytes.putLongLittleEndian"], "method_name": "LittleEndianByteArray.store64", "method_implementation": "{\n    // We don't want to assert in production code.\n    assert offset >= 0 && offset + 8 <= sink.length;\n    // Delegates to the fast (unsafe)version or the fallback.\n    byteArray.putLongLittleEndian(sink, offset, value);\n}", "repo_id": "5", "comment": "/**\n * Store 8 bytes into the provided array at the indicated offset, using the value provided.\n *\n * @param sink the output byte array\n * @param offset the offset into the array at which to start writing\n * @param value the value to write\n */\n", "repo_name": "guava-master/", "id": 5202, "method_signature": "void store64(byte[], int, long)", "filename": "LittleEndianByteArray.store64.json"}
{"callee_method_names": ["InputStream.read"], "method_name": "LittleEndianDataInputStream.readAndCheckByte", "method_implementation": "{\n    int b1 = in.read();\n    if (-1 == b1) {\n        throw new EOFException();\n    }\n    return (byte) b1;\n}", "repo_id": "5", "comment": "/**\n * Reads a byte from the input stream checking that the end of file (EOF) has not been\n * encountered.\n *\n * @return byte read from input\n * @throws IOException if an error is encountered while reading\n * @throws EOFException if the end of file (EOF) is encountered.\n */\n", "repo_name": "guava-master/", "id": 4781, "method_signature": "byte readAndCheckByte()", "filename": "LittleEndianDataInputStream.readAndCheckByte.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readChar", "method_implementation": "{\n    return (char) readUnsignedShort();\n}", "repo_id": "5", "comment": "/**\n * Reads a char as specified by {@link DataInputStream#readChar()}, except using little-endian\n * byte order.\n *\n * @return the next two bytes of the input stream, interpreted as a {@code char} in little-endian\n *     byte order\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4780, "method_signature": "char readChar()", "filename": "LittleEndianDataInputStream.readChar.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readDouble", "method_implementation": "{\n    return Double.longBitsToDouble(readLong());\n}", "repo_id": "5", "comment": "/**\n * Reads a {@code double} as specified by {@link DataInputStream#readDouble()}, except using\n * little-endian byte order.\n *\n * @return the next eight bytes of the input stream, interpreted as a {@code double} in\n *     little-endian byte order\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4778, "method_signature": "double readDouble()", "filename": "LittleEndianDataInputStream.readDouble.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readFloat", "method_implementation": "{\n    return Float.intBitsToFloat(readInt());\n}", "repo_id": "5", "comment": "/**\n * Reads a {@code float} as specified by {@link DataInputStream#readFloat()}, except using\n * little-endian byte order.\n *\n * @return the next four bytes of the input stream, interpreted as a {@code float} in\n *     little-endian byte order\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4777, "method_signature": "float readFloat()", "filename": "LittleEndianDataInputStream.readFloat.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readInt", "method_implementation": "{\n    byte b1 = readAndCheckByte();\n    byte b2 = readAndCheckByte();\n    byte b3 = readAndCheckByte();\n    byte b4 = readAndCheckByte();\n    return Ints.fromBytes(b4, b3, b2, b1);\n}", "repo_id": "5", "comment": "/**\n * Reads an integer as specified by {@link DataInputStream#readInt()}, except using little-endian\n * byte order.\n *\n * @return the next four bytes of the input stream, interpreted as an {@code int} in little-endian\n *     byte order\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4775, "method_signature": "int readInt()", "filename": "LittleEndianDataInputStream.readInt.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readLine", "method_implementation": "{\n    throw new UnsupportedOperationException(\"readLine is not supported\");\n}", "repo_id": "5", "comment": "/**\n * This method will throw an {@link UnsupportedOperationException}.\n */\n", "repo_name": "guava-master/", "id": 4773, "method_signature": "String readLine()", "filename": "LittleEndianDataInputStream.readLine.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readLong", "method_implementation": "{\n    byte b1 = readAndCheckByte();\n    byte b2 = readAndCheckByte();\n    byte b3 = readAndCheckByte();\n    byte b4 = readAndCheckByte();\n    byte b5 = readAndCheckByte();\n    byte b6 = readAndCheckByte();\n    byte b7 = readAndCheckByte();\n    byte b8 = readAndCheckByte();\n    return Longs.fromBytes(b8, b7, b6, b5, b4, b3, b2, b1);\n}", "repo_id": "5", "comment": "/**\n * Reads a {@code long} as specified by {@link DataInputStream#readLong()}, except using\n * little-endian byte order.\n *\n * @return the next eight bytes of the input stream, interpreted as a {@code long} in\n *     little-endian byte order\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4776, "method_signature": "long readLong()", "filename": "LittleEndianDataInputStream.readLong.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readShort", "method_implementation": "{\n    return (short) readUnsignedShort();\n}", "repo_id": "5", "comment": "/**\n * Reads a {@code short} as specified by {@link DataInputStream#readShort()}, except using\n * little-endian byte order.\n *\n * @return the next two bytes of the input stream, interpreted as a {@code short} in little-endian\n *     byte order.\n * @throws IOException if an I/O error occurs.\n */\n", "repo_name": "guava-master/", "id": 4779, "method_signature": "short readShort()", "filename": "LittleEndianDataInputStream.readShort.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataInputStream.readUnsignedShort", "method_implementation": "{\n    byte b1 = readAndCheckByte();\n    byte b2 = readAndCheckByte();\n    return Ints.fromBytes((byte) 0, (byte) 0, b2, b1);\n}", "repo_id": "5", "comment": "/**\n * Reads an unsigned {@code short} as specified by {@link DataInputStream#readUnsignedShort()},\n * except using little-endian byte order.\n *\n * @return the next two bytes of the input stream, interpreted as an unsigned 16-bit integer in\n *     little-endian byte order\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4774, "method_signature": "int readUnsignedShort()", "filename": "LittleEndianDataInputStream.readUnsignedShort.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataOutputStream.writeBytes", "method_implementation": "{\n    ((DataOutputStream) out).writeBytes(s);\n}", "repo_id": "5", "comment": "/**\n * @deprecated The semantics of {@code writeBytes(String s)} are considered dangerous. Please use\n *     {@link #writeUTF(String s)}, {@link #writeChars(String s)} or another write method instead.\n */\n", "repo_name": "guava-master/", "id": 4768, "method_signature": "void writeBytes(String)", "filename": "LittleEndianDataOutputStream.writeBytes.json"}
{"callee_method_names": ["String.length", "String.charAt"], "method_name": "LittleEndianDataOutputStream.writeChars", "method_implementation": "{\n    for (int i = 0; i < s.length(); i++) {\n        writeChar(s.charAt(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * Writes a {@code String} as specified by {@link DataOutputStream#writeChars(String)}, except\n * each character is written using little-endian byte order.\n *\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4769, "method_signature": "void writeChars(String)", "filename": "LittleEndianDataOutputStream.writeChars.json"}
{"callee_method_names": ["OutputStream.write", "OutputStream.write", "OutputStream.write", "OutputStream.write"], "method_name": "LittleEndianDataOutputStream.writeInt", "method_implementation": "{\n    out.write(0xFF & v);\n    out.write(0xFF & (v >> 8));\n    out.write(0xFF & (v >> 16));\n    out.write(0xFF & (v >> 24));\n}", "repo_id": "5", "comment": "/**\n * Writes an {@code int} as specified by {@link DataOutputStream#writeInt(int)}, except using\n * little-endian byte order.\n *\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4770, "method_signature": "void writeInt(int)", "filename": "LittleEndianDataOutputStream.writeInt.json"}
{"callee_method_names": [], "method_name": "LittleEndianDataOutputStream.writeLong", "method_implementation": "{\n    byte[] bytes = Longs.toByteArray(Long.reverseBytes(v));\n    write(bytes, 0, bytes.length);\n}", "repo_id": "5", "comment": "/**\n * Writes a {@code long} as specified by {@link DataOutputStream#writeLong(long)}, except using\n * little-endian byte order.\n *\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4771, "method_signature": "void writeLong(long)", "filename": "LittleEndianDataOutputStream.writeLong.json"}
{"callee_method_names": ["OutputStream.write", "OutputStream.write"], "method_name": "LittleEndianDataOutputStream.writeShort", "method_implementation": "{\n    out.write(0xFF & v);\n    out.write(0xFF & (v >> 8));\n}", "repo_id": "5", "comment": "/**\n * Writes a {@code short} as specified by {@link DataOutputStream#writeShort(int)}, except using\n * little-endian byte order.\n *\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4772, "method_signature": "void writeShort(int)", "filename": "LittleEndianDataOutputStream.writeShort.json"}
{"callee_method_names": ["Ticker.read", "ReferenceEntry<K,V>.getKey", "Segment<K, V>.postReadCleanup"], "method_name": "LocalCache.advanceTo", "method_implementation": "{\n    try {\n        long now = ticker.read();\n        K key = entry.getKey();\n        V value = getLiveValue(entry, now);\n        if (value != null) {\n            nextExternal = new WriteThroughEntry(key, value);\n            return true;\n        } else {\n            // Skip stale entry.\n            return false;\n        }\n    } finally {\n        currentSegment.postReadCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Advances to the given entry. Returns true if the entry was valid, false if it should be\n * skipped.\n */\n", "repo_name": "guava-master/", "id": 4938, "method_signature": "boolean advanceTo(ReferenceEntry)", "filename": "LocalCache.advanceTo.json"}
{"callee_method_names": ["LocalCache<K, V>.usesKeyReferences", "LocalCache<K, V>.usesValueReferences"], "method_name": "LocalCache.clearReferenceQueues", "method_implementation": "{\n    if (map.usesKeyReferences()) {\n        clearKeyReferenceQueue();\n    }\n    if (map.usesValueReferences()) {\n        clearValueReferenceQueue();\n    }\n}", "repo_id": "5", "comment": "/**\n * Clears all entries from the key and value reference queues.\n */\n", "repo_name": "guava-master/", "id": 4919, "method_signature": "void clearReferenceQueues()", "filename": "LocalCache.clearReferenceQueues.json"}
{"callee_method_names": ["LocalCache<K, V>.read", "AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.get", "ReferenceEntry<K, V>.getNext", "LocalCache<K, V>.equivalent"], "method_name": "LocalCache.containsValue", "method_implementation": "{\n    try {\n        if (count != 0) {\n            // read-volatile\n            long now = map.ticker.read();\n            AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n            int length = table.length();\n            for (int i = 0; i < length; ++i) {\n                for (ReferenceEntry<K, V> e = table.get(i); e != null; e = e.getNext()) {\n                    V entryValue = getLiveValue(e, now);\n                    if (entryValue == null) {\n                        continue;\n                    }\n                    if (map.valueEquivalence.equivalent(value, entryValue)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    } finally {\n        postReadCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * This method is a convenience for testing. Code should call {@link LocalCache#containsValue}\n * directly.\n */\n", "repo_name": "guava-master/", "id": 4929, "method_signature": "boolean containsValue(Object)", "filename": "LocalCache.containsValue.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.setAccessTime", "ReferenceEntry<K,V>.getAccessTime", "ReferenceEntry<K,V>.getPreviousInAccessQueue", "ReferenceEntry<K,V>.getNextInAccessQueue"], "method_name": "LocalCache.copyAccessEntry", "method_implementation": "{\n    // TODO(fry): when we link values instead of entries this method can go\n    // away, as can connectAccessOrder, nullifyAccessOrder.\n    newEntry.setAccessTime(original.getAccessTime());\n    connectAccessOrder(original.getPreviousInAccessQueue(), newEntry);\n    connectAccessOrder(newEntry, original.getNextInAccessQueue());\n    nullifyAccessOrder(original);\n}", "repo_id": "5", "comment": "// Guarded By Segment.this\n", "repo_name": "guava-master/", "id": 4901, "method_signature": "void copyAccessEntry(ReferenceEntry, ReferenceEntry)", "filename": "LocalCache.copyAccessEntry.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.getKey", "ReferenceEntry<K,V>.getValueReference", "ValueReference<K, V>.get", "ValueReference<K, V>.isActive", "LocalCache<K, V>.copyEntry", "ReferenceEntry<K, V>.setValueReference", "ValueReference<K, V>.copyFor"], "method_name": "LocalCache.copyEntry", "method_implementation": "{\n    K key = original.getKey();\n    if (key == null) {\n        // key collected\n        return null;\n    }\n    ValueReference<K, V> valueReference = original.getValueReference();\n    V value = valueReference.get();\n    if ((value == null) && valueReference.isActive()) {\n        // value collected\n        return null;\n    }\n    ReferenceEntry<K, V> newEntry = map.entryFactory.copyEntry(this, original, newNext, key);\n    newEntry.setValueReference(valueReference.copyFor(this.valueReferenceQueue, value, newEntry));\n    return newEntry;\n}", "repo_id": "5", "comment": "/**\n * Copies {@code original} into a new entry chained to {@code newNext}. Returns the new entry,\n * or {@code null} if {@code original} was already garbage collected.\n */\n", "repo_name": "guava-master/", "id": 4912, "method_signature": "ReferenceEntry<K,V> copyEntry(ReferenceEntry, ReferenceEntry)", "filename": "LocalCache.copyEntry.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.setWriteTime", "ReferenceEntry<K,V>.getWriteTime", "ReferenceEntry<K,V>.getPreviousInWriteQueue", "ReferenceEntry<K,V>.getNextInWriteQueue"], "method_name": "LocalCache.copyWriteEntry", "method_implementation": "{\n    // TODO(fry): when we link values instead of entries this method can go\n    // away, as can connectWriteOrder, nullifyWriteOrder.\n    newEntry.setWriteTime(original.getWriteTime());\n    connectWriteOrder(original.getPreviousInWriteQueue(), newEntry);\n    connectWriteOrder(newEntry, original.getNextInWriteQueue());\n    nullifyWriteOrder(original);\n}", "repo_id": "5", "comment": "// Guarded By Segment.this\n", "repo_name": "guava-master/", "id": 4902, "method_signature": "void copyWriteEntry(ReferenceEntry, ReferenceEntry)", "filename": "LocalCache.copyWriteEntry.json"}
{"callee_method_names": ["Queue<ReferenceEntry<K, V>>.poll", "Queue<ReferenceEntry<K, V>>.contains", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "LocalCache.drainRecencyQueue", "method_implementation": "{\n    ReferenceEntry<K, V> e;\n    while ((e = recencyQueue.poll()) != null) {\n        // An entry may be in the recency queue despite it being removed from\n        // the map . This can occur when the entry was concurrently read while a\n        // writer is removing it from the segment or after a clear has removed\n        // all the segment's entries.\n        if (accessQueue.contains(e)) {\n            accessQueue.add(e);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Drains the recency queue, updating eviction metadata that the entries therein were read in\n * the specified relative order. This currently amounts to adding them to relevant eviction\n * lists (accounting for the fact that they could have been removed from the map since being\n * added to the recency queue).\n */\n", "repo_name": "guava-master/", "id": 4923, "method_signature": "void drainRecencyQueue()", "filename": "LocalCache.drainRecencyQueue.json"}
{"callee_method_names": ["LocalCache<K, V>.usesKeyReferences", "LocalCache<K, V>.usesValueReferences"], "method_name": "LocalCache.drainReferenceQueues", "method_implementation": "{\n    if (map.usesKeyReferences()) {\n        drainKeyReferenceQueue();\n    }\n    if (map.usesValueReferences()) {\n        drainValueReferenceQueue();\n    }\n}", "repo_id": "5", "comment": "/**\n * Drain the key and value reference queues, cleaning up internal entries containing garbage\n * collected keys or values.\n */\n", "repo_name": "guava-master/", "id": 4918, "method_signature": "void drainReferenceQueues()", "filename": "LocalCache.drainReferenceQueues.json"}
{"callee_method_names": ["LocalCache<K, V>.evictsBySize", "ReferenceEntry<K,V>.getValueReference", "ReferenceEntry<K,V>.getHash", "ReferenceEntry<K, V>.getHash"], "method_name": "LocalCache.evictEntries", "method_implementation": "{\n    if (!map.evictsBySize()) {\n        return;\n    }\n    drainRecencyQueue();\n    // If the newest entry by itself is too heavy for the segment, don't bother evicting\n    // anything else, just that\n    if (newest.getValueReference().getWeight() > maxSegmentWeight) {\n        if (!removeEntry(newest, newest.getHash(), RemovalCause.SIZE)) {\n            throw new AssertionError();\n        }\n    }\n    while (totalWeight > maxSegmentWeight) {\n        ReferenceEntry<K, V> e = getNextEvictable();\n        if (!removeEntry(e, e.getHash(), RemovalCause.SIZE)) {\n            throw new AssertionError();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs eviction if the segment is over capacity. Avoids flushing the entire cache if the\n * newest entry exceeds the maximum weight all on its own.\n *\n * @param newest the most recently added entry\n */\n", "repo_name": "guava-master/", "id": 4925, "method_signature": "void evictEntries(ReferenceEntry)", "filename": "LocalCache.evictEntries.json"}
{"callee_method_names": ["AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.get", "ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getHash", "AtomicReferenceArray<ReferenceEntry<K, V>>.set", "ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getHash", "AtomicReferenceArray<ReferenceEntry<K, V>>.set", "ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getHash", "AtomicReferenceArray<ReferenceEntry<K, V>>.get", "AtomicReferenceArray<ReferenceEntry<K, V>>.set"], "method_name": "LocalCache.expand", "method_implementation": "{\n    AtomicReferenceArray<ReferenceEntry<K, V>> oldTable = table;\n    int oldCapacity = oldTable.length();\n    if (oldCapacity >= MAXIMUM_CAPACITY) {\n        return;\n    }\n    /*\n       * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the\n       * elements from each bin must either stay at same index, or move with a power of two offset.\n       * We eliminate unnecessary node creation by catching cases where old nodes can be reused\n       * because their next fields won't change. Statistically, at the default threshold, only about\n       * one-sixth of them need cloning when a table doubles. The nodes they replace will be garbage\n       * collectable as soon as they are no longer referenced by any reader thread that may be in\n       * the midst of traversing table right now.\n       */\n    int newCount = count;\n    AtomicReferenceArray<ReferenceEntry<K, V>> newTable = newEntryArray(oldCapacity << 1);\n    threshold = newTable.length() * 3 / 4;\n    int newMask = newTable.length() - 1;\n    for (int oldIndex = 0; oldIndex < oldCapacity; ++oldIndex) {\n        // We need to guarantee that any existing reads of old Map can\n        // proceed. So we cannot yet null out each bin.\n        ReferenceEntry<K, V> head = oldTable.get(oldIndex);\n        if (head != null) {\n            ReferenceEntry<K, V> next = head.getNext();\n            int headIndex = head.getHash() & newMask;\n            // Single node on list\n            if (next == null) {\n                newTable.set(headIndex, head);\n            } else {\n                // Reuse the consecutive sequence of nodes with the same target\n                // index from the end of the list. tail points to the first\n                // entry in the reusable list.\n                ReferenceEntry<K, V> tail = head;\n                int tailIndex = headIndex;\n                for (ReferenceEntry<K, V> e = next; e != null; e = e.getNext()) {\n                    int newIndex = e.getHash() & newMask;\n                    if (newIndex != tailIndex) {\n                        // The index changed. We'll need to copy the previous entry.\n                        tailIndex = newIndex;\n                        tail = e;\n                    }\n                }\n                newTable.set(tailIndex, tail);\n                // Clone nodes leading up to the tail.\n                for (ReferenceEntry<K, V> e = head; e != tail; e = e.getNext()) {\n                    int newIndex = e.getHash() & newMask;\n                    ReferenceEntry<K, V> newNext = newTable.get(newIndex);\n                    ReferenceEntry<K, V> newFirst = copyEntry(e, newNext);\n                    if (newFirst != null) {\n                        newTable.set(newIndex, newFirst);\n                    } else {\n                        removeCollectedEntry(e);\n                        newCount--;\n                    }\n                }\n            }\n        }\n    }\n    table = newTable;\n    this.count = newCount;\n}", "repo_id": "5", "comment": "/**\n * Expands the table if possible.\n */\n", "repo_name": "guava-master/", "id": 4930, "method_signature": "void expand()", "filename": "LocalCache.expand.json"}
{"callee_method_names": ["StatsCounter.recordLoadSuccess", "LoadingValueReference<K,V>.elapsedNanos", "StatsCounter.recordLoadException", "LoadingValueReference<K,V>.elapsedNanos"], "method_name": "LocalCache.getAndRecordStats", "method_implementation": "{\n    V value = null;\n    try {\n        value = getUninterruptibly(newValue);\n        if (value == null) {\n            throw new InvalidCacheLoadException(\"CacheLoader returned null for key \" + key + \".\");\n        }\n        statsCounter.recordLoadSuccess(loadingValueReference.elapsedNanos());\n        storeLoadedValue(key, hash, loadingValueReference, value);\n        return value;\n    } finally {\n        if (value == null) {\n            statsCounter.recordLoadException(loadingValueReference.elapsedNanos());\n            removeLoadingValue(key, hash, loadingValueReference);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Waits uninterruptibly for {@code newValue} to be loaded, and then records loading stats.\n */\n", "repo_name": "guava-master/", "id": 4914, "method_signature": "V getAndRecordStats(K, int, LoadingValueReference, ListenableFuture)", "filename": "LocalCache.getAndRecordStats.json"}
{"callee_method_names": [], "method_name": "LocalCache.getEntry", "method_implementation": "{\n    // does not impact recency ordering\n    if (key == null) {\n        return null;\n    }\n    int hash = hash(key);\n    return segmentFor(hash).getEntry(key, hash);\n}", "repo_id": "5", "comment": "/**\n * Returns the internal entry for the specified key. The entry may be loading, expired, or\n * partially collected.\n */\n", "repo_name": "guava-master/", "id": 4935, "method_signature": "ReferenceEntry<K,V> getEntry(Object)", "filename": "LocalCache.getEntry.json"}
{"callee_method_names": ["AtomicReferenceArray<ReferenceEntry<K, V>>.get", "AtomicReferenceArray<ReferenceEntry<K, V>>.length"], "method_name": "LocalCache.getFirst", "method_implementation": "{\n    // read this volatile field only once\n    AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n    return table.get(hash & (table.length() - 1));\n}", "repo_id": "5", "comment": "/**\n * Returns first entry of bin for given hash.\n */\n", "repo_name": "guava-master/", "id": 4927, "method_signature": "ReferenceEntry<K,V> getFirst(int)", "filename": "LocalCache.getFirst.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.getKey", "ReferenceEntry<K,V>.getValueReference", "LocalCache<K, V>.isExpired"], "method_name": "LocalCache.getLiveValue", "method_implementation": "{\n    if (entry.getKey() == null) {\n        tryDrainReferenceQueues();\n        return null;\n    }\n    V value = entry.getValueReference().get();\n    if (value == null) {\n        tryDrainReferenceQueues();\n        return null;\n    }\n    if (map.isExpired(entry, now)) {\n        tryExpireEntries(now);\n        return null;\n    }\n    return value;\n}", "repo_id": "5", "comment": "/**\n * Gets the value from an entry. Returns null if the entry is invalid, partially-collected,\n * loading, or expired.\n */\n", "repo_name": "guava-master/", "id": 4928, "method_signature": "V getLiveValue(ReferenceEntry, long)", "filename": "LocalCache.getLiveValue.json"}
{"callee_method_names": ["ReferenceEntry<K, V>.getValueReference"], "method_name": "LocalCache.getNextEvictable", "method_implementation": "{\n    for (ReferenceEntry<K, V> e : accessQueue) {\n        int weight = e.getValueReference().getWeight();\n        if (weight > 0) {\n            return e;\n        }\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "// TODO(fry): instead implement this with an eviction head\n", "repo_name": "guava-master/", "id": 4926, "method_signature": "ReferenceEntry<K,V> getNextEvictable()", "filename": "LocalCache.getNextEvictable.json"}
{"callee_method_names": ["LocalCache<K, V>.read", "AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.get", "ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getKey", "ReferenceEntry<K, V>.getHash", "LocalCache<K, V>.equivalent", "ReferenceEntry<K, V>.getValueReference", "ValueReference<K, V>.isLoading", "ReferenceEntry<K, V>.getWriteTime", "ReferenceEntry<K, V>.setValueReference", "ReferenceEntry<K, V>.setValueReference", "AtomicReferenceArray<ReferenceEntry<K, V>>.set"], "method_name": "LocalCache.insertLoadingValueReference", "method_implementation": "{\n    ReferenceEntry<K, V> e = null;\n    lock();\n    try {\n        long now = map.ticker.read();\n        preWriteCleanup(now);\n        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n        int index = hash & (table.length() - 1);\n        ReferenceEntry<K, V> first = table.get(index);\n        // Look for an existing entry.\n        for (e = first; e != null; e = e.getNext()) {\n            K entryKey = e.getKey();\n            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key, entryKey)) {\n                // We found an existing entry.\n                ValueReference<K, V> valueReference = e.getValueReference();\n                if (valueReference.isLoading() || (checkTime && (now - e.getWriteTime() < map.refreshNanos))) {\n                    // refresh is a no-op if loading is pending\n                    // if checkTime, we want to check *after* acquiring the lock if refresh still needs\n                    // to be scheduled\n                    return null;\n                }\n                // continue returning old value while loading\n                ++modCount;\n                LoadingValueReference<K, V> loadingValueReference = new LoadingValueReference<>(valueReference);\n                e.setValueReference(loadingValueReference);\n                return loadingValueReference;\n            }\n        }\n        ++modCount;\n        LoadingValueReference<K, V> loadingValueReference = new LoadingValueReference<>();\n        e = newEntry(key, hash, first);\n        e.setValueReference(loadingValueReference);\n        table.set(index, e);\n        return loadingValueReference;\n    } finally {\n        unlock();\n        postWriteCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a newly inserted {@code LoadingValueReference}, or null if the live value reference\n * is already loading.\n */\n", "repo_name": "guava-master/", "id": 4916, "method_signature": "LoadingValueReference<K,V> insertLoadingValueReference(K, int, boolean)", "filename": "LocalCache.insertLoadingValueReference.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.getAccessTime", "ReferenceEntry<K,V>.getWriteTime"], "method_name": "LocalCache.isExpired", "method_implementation": "{\n    checkNotNull(entry);\n    if (expiresAfterAccess() && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {\n        return true;\n    }\n    if (expiresAfterWrite() && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {\n        return true;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns true if the entry has expired.\n */\n", "repo_name": "guava-master/", "id": 4908, "method_signature": "boolean isExpired(ReferenceEntry, long)", "filename": "LocalCache.isExpired.json"}
{"callee_method_ids": [1784, 1784, 5188, 1784, 1784], "callee_method_names": ["CacheLoader<? super K,V>.loadAll", "StatsCounter.recordLoadException", "Stopwatch.elapsed", "StatsCounter.recordLoadException", "Stopwatch.elapsed", "Stopwatch.stop", "Map<K, V>.entrySet", "ReferenceEntry<K,V>.getKey", "ReferenceEntry<K,V>.getValue", "StatsCounter.recordLoadException", "Stopwatch.elapsed", "StatsCounter.recordLoadSuccess", "Stopwatch.elapsed"], "method_name": "LocalCache.loadAll", "method_implementation": "{\n    checkNotNull(loader);\n    checkNotNull(keys);\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    Map<K, V> result;\n    boolean success = false;\n    try {\n        // safe since all keys extend K\n        @SuppressWarnings(\"unchecked\")\n        Map<K, V> map = (Map<K, V>) loader.loadAll(keys);\n        result = map;\n        success = true;\n    } catch (UnsupportedLoadingOperationException e) {\n        success = true;\n        throw e;\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ExecutionException(e);\n    } catch (RuntimeException e) {\n        throw new UncheckedExecutionException(e);\n    } catch (Exception e) {\n        throw new ExecutionException(e);\n    } catch (Error e) {\n        throw new ExecutionError(e);\n    } finally {\n        if (!success) {\n            globalStatsCounter.recordLoadException(stopwatch.elapsed(NANOSECONDS));\n        }\n    }\n    if (result == null) {\n        globalStatsCounter.recordLoadException(stopwatch.elapsed(NANOSECONDS));\n        throw new InvalidCacheLoadException(loader + \" returned null map from loadAll\");\n    }\n    stopwatch.stop();\n    // TODO(fry): batch by segment\n    boolean nullsPresent = false;\n    for (Entry<K, V> entry : result.entrySet()) {\n        K key = entry.getKey();\n        V value = entry.getValue();\n        if (key == null || value == null) {\n            // delay failure until non-null entries are stored\n            nullsPresent = true;\n        } else {\n            put(key, value);\n        }\n    }\n    if (nullsPresent) {\n        globalStatsCounter.recordLoadException(stopwatch.elapsed(NANOSECONDS));\n        throw new InvalidCacheLoadException(loader + \" returned null keys or values from loadAll\");\n    }\n    // TODO(fry): record count of loaded entries\n    globalStatsCounter.recordLoadSuccess(stopwatch.elapsed(NANOSECONDS));\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the result of calling {@link CacheLoader#loadAll}, or null if {@code loader} doesn't\n * implement {@code loadAll}.\n */\n", "repo_name": "guava-master/", "id": 4934, "method_signature": "Map<K,V> loadAll(Set, CacheLoader)", "filename": "LocalCache.loadAll.json"}
{"callee_method_names": ["Segment<K, V>.lock", "Segment<K, V>.newEntry", "Segment<K, V>.unlock"], "method_name": "LocalCache.newEntry", "method_implementation": "{\n    Segment<K, V> segment = segmentFor(hash);\n    segment.lock();\n    try {\n        return segment.newEntry(key, hash, next);\n    } finally {\n        segment.unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * This method is a convenience for testing. Code should call {@link Segment#newEntry} directly.\n */\n", "repo_name": "guava-master/", "id": 4904, "method_signature": "ReferenceEntry<K,V> newEntry(K, int, ReferenceEntry)", "filename": "LocalCache.newEntry.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.getHash", "Strength.referenceValue"], "method_name": "LocalCache.newValueReference", "method_implementation": "{\n    int hash = entry.getHash();\n    return valueStrength.referenceValue(segmentFor(hash), entry, checkNotNull(value), weight);\n}", "repo_id": "5", "comment": "// Guarded By Segment.this\n", "repo_name": "guava-master/", "id": 4906, "method_signature": "ValueReference<K,V> newValueReference(ReferenceEntry, V, int)", "filename": "LocalCache.newValueReference.json"}
{"callee_method_names": ["ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getNext"], "method_name": "LocalCache.nextInChain", "method_implementation": "{\n    if (nextEntry != null) {\n        for (nextEntry = nextEntry.getNext(); nextEntry != null; nextEntry = nextEntry.getNext()) {\n            if (advanceTo(nextEntry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Finds the next entry in the current chain. Returns true if an entry was found.\n */\n", "repo_name": "guava-master/", "id": 4936, "method_signature": "boolean nextInChain()", "filename": "LocalCache.nextInChain.json"}
{"callee_method_names": ["AtomicReferenceArray<ReferenceEntry<K, V>>.get"], "method_name": "LocalCache.nextInTable", "method_implementation": "{\n    while (nextTableIndex >= 0) {\n        if ((nextEntry = currentTable.get(nextTableIndex--)) != null) {\n            if (advanceTo(nextEntry) || nextInChain()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Finds the next entry in the current table. Returns true if an entry was found.\n */\n", "repo_name": "guava-master/", "id": 4937, "method_signature": "boolean nextInTable()", "filename": "LocalCache.nextInTable.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.setNextInAccessQueue", "ReferenceEntry<K,V>.setPreviousInAccessQueue"], "method_name": "LocalCache.nullifyAccessOrder", "method_implementation": "{\n    ReferenceEntry<K, V> nullEntry = nullEntry();\n    nulled.setNextInAccessQueue(nullEntry);\n    nulled.setPreviousInAccessQueue(nullEntry);\n}", "repo_id": "5", "comment": "// Guarded By Segment.this\n", "repo_name": "guava-master/", "id": 4909, "method_signature": "void nullifyAccessOrder(ReferenceEntry)", "filename": "LocalCache.nullifyAccessOrder.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.setNextInWriteQueue", "ReferenceEntry<K,V>.setPreviousInWriteQueue"], "method_name": "LocalCache.nullifyWriteOrder", "method_implementation": "{\n    ReferenceEntry<K, V> nullEntry = nullEntry();\n    nulled.setNextInWriteQueue(nullEntry);\n    nulled.setPreviousInWriteQueue(nullEntry);\n}", "repo_id": "5", "comment": "// Guarded By Segment.this\n", "repo_name": "guava-master/", "id": 4910, "method_signature": "void nullifyWriteOrder(ReferenceEntry)", "filename": "LocalCache.nullifyWriteOrder.json"}
{"callee_method_names": ["AtomicInteger.incrementAndGet"], "method_name": "LocalCache.postReadCleanup", "method_implementation": "{\n    if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {\n        cleanUp();\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs routine cleanup following a read. Normally cleanup happens during writes. If cleanup\n * is not observed after a sufficient number of reads, try cleaning up from the read thread.\n */\n", "repo_name": "guava-master/", "id": 4933, "method_signature": "void postReadCleanup()", "filename": "LocalCache.postReadCleanup.json"}
{"callee_method_names": ["Queue<RemovalNotification<K, V>>.poll", "RemovalListener<? super K, ? super V>.onRemoval", "Logger.log"], "method_name": "LocalCache.processPendingNotifications", "method_implementation": "{\n    RemovalNotification<K, V> notification;\n    while ((notification = removalNotificationQueue.poll()) != null) {\n        try {\n            removalListener.onRemoval(notification);\n        } catch (Throwable e) {\n            logger.log(Level.WARNING, \"Exception thrown by removal listener\", e);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Notifies listeners that an entry has been automatically removed due to expiration, eviction, or\n * eligibility for garbage collection. This should be called every time expireEntries or\n * evictEntry is called (once the lock is released).\n */\n", "repo_name": "guava-master/", "id": 4911, "method_signature": "void processPendingNotifications()", "filename": "LocalCache.processPendingNotifications.json"}
{"callee_method_names": ["AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.get", "ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getKey", "ReferenceEntry<K, V>.getValueReference", "ReferenceEntry<K, V>.getValueReference", "AtomicReferenceArray<ReferenceEntry<K, V>>.set"], "method_name": "LocalCache.reclaimKey", "method_implementation": "{\n    lock();\n    try {\n        int newCount = count - 1;\n        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n        int index = hash & (table.length() - 1);\n        ReferenceEntry<K, V> first = table.get(index);\n        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {\n            if (e == entry) {\n                ++modCount;\n                ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, e.getKey(), hash, e.getValueReference().get(), e.getValueReference(), RemovalCause.COLLECTED);\n                newCount = this.count - 1;\n                table.set(index, newFirst);\n                // write-volatile\n                this.count = newCount;\n                return true;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n        postWriteCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes an entry whose key has been garbage collected.\n */\n", "repo_name": "guava-master/", "id": 4931, "method_signature": "boolean reclaimKey(ReferenceEntry, int)", "filename": "LocalCache.reclaimKey.json"}
{"callee_method_names": ["AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.get", "ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getKey", "ReferenceEntry<K, V>.getHash", "LocalCache<K, V>.equivalent", "ReferenceEntry<K, V>.getValueReference", "ValueReference<K,V>.get", "AtomicReferenceArray<ReferenceEntry<K, V>>.set"], "method_name": "LocalCache.reclaimValue", "method_implementation": "{\n    lock();\n    try {\n        int newCount = this.count - 1;\n        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n        int index = hash & (table.length() - 1);\n        ReferenceEntry<K, V> first = table.get(index);\n        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {\n            K entryKey = e.getKey();\n            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key, entryKey)) {\n                ValueReference<K, V> v = e.getValueReference();\n                if (v == valueReference) {\n                    ++modCount;\n                    ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, entryKey, hash, valueReference.get(), valueReference, RemovalCause.COLLECTED);\n                    newCount = this.count - 1;\n                    table.set(index, newFirst);\n                    // write-volatile\n                    this.count = newCount;\n                    return true;\n                }\n                return false;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n        if (!isHeldByCurrentThread()) {\n            // don't clean up inside of put\n            postWriteCleanup();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes an entry whose value has been garbage collected.\n */\n", "repo_name": "guava-master/", "id": 4932, "method_signature": "boolean reclaimValue(K, int, ValueReference)", "filename": "LocalCache.reclaimValue.json"}
{"callee_method_names": ["LocalCache<K, V>.recordsAccess", "ReferenceEntry<K,V>.setAccessTime", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "LocalCache.recordLockedRead", "method_implementation": "{\n    if (map.recordsAccess()) {\n        entry.setAccessTime(now);\n    }\n    accessQueue.add(entry);\n}", "repo_id": "5", "comment": "/**\n * Updates the eviction metadata that {@code entry} was just read. This currently amounts to\n * adding {@code entry} to relevant eviction lists.\n *\n * <p>Note: this method should only be called under lock, as it directly manipulates the\n * eviction queues. Unlocked reads should use {@link #recordRead}.\n */\n", "repo_name": "guava-master/", "id": 4921, "method_signature": "void recordLockedRead(ReferenceEntry, long)", "filename": "LocalCache.recordLockedRead.json"}
{"callee_method_names": ["LocalCache<K, V>.recordsAccess", "ReferenceEntry<K,V>.setAccessTime", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "LocalCache.recordRead", "method_implementation": "{\n    if (map.recordsAccess()) {\n        entry.setAccessTime(now);\n    }\n    recencyQueue.add(entry);\n}", "repo_id": "5", "comment": "/**\n * Records the relative order in which this read was performed by adding {@code entry} to the\n * recency queue. At write-time, or when the queue is full past the threshold, the queue will be\n * drained and the entries therein processed.\n *\n * <p>Note: locked reads should use {@link #recordLockedRead}.\n */\n", "repo_name": "guava-master/", "id": 4920, "method_signature": "void recordRead(ReferenceEntry, long)", "filename": "LocalCache.recordRead.json"}
{"callee_method_names": ["LocalCache<K, V>.recordsAccess", "ReferenceEntry<K,V>.setAccessTime", "LocalCache<K, V>.recordsWrite", "ReferenceEntry<K,V>.setWriteTime", "Queue<ReferenceEntry<K, V>>.add", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "LocalCache.recordWrite", "method_implementation": "{\n    // we are already under lock, so drain the recency queue immediately\n    drainRecencyQueue();\n    totalWeight += weight;\n    if (map.recordsAccess()) {\n        entry.setAccessTime(now);\n    }\n    if (map.recordsWrite()) {\n        entry.setWriteTime(now);\n    }\n    accessQueue.add(entry);\n    writeQueue.add(entry);\n}", "repo_id": "5", "comment": "/**\n * Updates eviction metadata that {@code entry} was just written. This currently amounts to\n * adding {@code entry} to relevant eviction lists.\n */\n", "repo_name": "guava-master/", "id": 4922, "method_signature": "void recordWrite(ReferenceEntry, int, long)", "filename": "LocalCache.recordWrite.json"}
{"callee_method_names": ["ListenableFuture<V>.isDone"], "method_name": "LocalCache.refresh", "method_implementation": "{\n    final LoadingValueReference<K, V> loadingValueReference = insertLoadingValueReference(key, hash, checkTime);\n    if (loadingValueReference == null) {\n        return null;\n    }\n    ListenableFuture<V> result = loadAsync(key, hash, loadingValueReference, loader);\n    if (result.isDone()) {\n        try {\n            return Uninterruptibles.getUninterruptibly(result);\n        } catch (Throwable t) {\n            // don't let refresh exceptions propagate; error was already logged\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Refreshes the value associated with {@code key}, unless another thread is already doing so.\n * Returns the newly refreshed value associated with {@code key} if it was refreshed inline, or\n * {@code null} if another thread is performing the refresh or if an error occurs during\n * refresh.\n */\n", "repo_name": "guava-master/", "id": 4915, "method_signature": "V refresh(K, int, CacheLoader, boolean)", "filename": "LocalCache.refresh.json"}
{"callee_method_names": [], "method_name": "LocalCache.rehash", "method_implementation": "{\n    // Spread bits to regularize both segment and index locations,\n    // using variant of single-word Wang/Jenkins hash.\n    // TODO(kevinb): use Hashing/move this to Hashing?\n    h += (h << 15) ^ 0xffffcd7d;\n    h ^= (h >>> 10);\n    h += (h << 3);\n    h ^= (h >>> 6);\n    h += (h << 2) + (h << 14);\n    return h ^ (h >>> 16);\n}", "repo_id": "5", "comment": "/**\n * Applies a supplemental hash function to a given hash code, which defends against poor quality\n * hash functions. This is critical when the concurrent hash map uses power-of-two length hash\n * tables, that otherwise encounter collisions for hash codes that do not differ in lower or upper\n * bits.\n *\n * @param h hash code\n */\n", "repo_name": "guava-master/", "id": 4903, "method_signature": "int rehash(int)", "filename": "LocalCache.rehash.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.getValueReference", "LocalCache<K, V>.weigh", "LocalCache<K, V>.referenceValue", "ReferenceEntry<K,V>.setValueReference", "ValueReference<K, V>.notifyNewValue"], "method_name": "LocalCache.setValue", "method_implementation": "{\n    ValueReference<K, V> previous = entry.getValueReference();\n    int weight = map.weigher.weigh(key, value);\n    checkState(weight >= 0, \"Weights must be non-negative\");\n    ValueReference<K, V> valueReference = map.valueStrength.referenceValue(this, entry, value, weight);\n    entry.setValueReference(valueReference);\n    recordWrite(entry, weight, now);\n    previous.notifyNewValue(value);\n}", "repo_id": "5", "comment": "/**\n * Sets a new value of an entry. Adds newly created entries at the end of the access queue.\n */\n", "repo_name": "guava-master/", "id": 4913, "method_signature": "void setValue(ReferenceEntry, K, V, long)", "filename": "LocalCache.setValue.json"}
{"callee_method_names": [], "method_name": "LocalCache.tryDrainReferenceQueues", "method_implementation": "{\n    if (tryLock()) {\n        try {\n            drainReferenceQueues();\n        } finally {\n            unlock();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Cleanup collected entries when the lock is available.\n */\n", "repo_name": "guava-master/", "id": 4917, "method_signature": "void tryDrainReferenceQueues()", "filename": "LocalCache.tryDrainReferenceQueues.json"}
{"callee_method_names": [], "method_name": "LocalCache.tryExpireEntries", "method_implementation": "{\n    if (tryLock()) {\n        try {\n            expireEntries(now);\n        } finally {\n            unlock();\n            // don't call postWriteCleanup as we're in a read\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Cleanup expired entries when the lock is available.\n */\n", "repo_name": "guava-master/", "id": 4924, "method_signature": "void tryExpireEntries(long)", "filename": "LocalCache.tryExpireEntries.json"}
{"callee_method_names": ["List<CacheBuilder<Object, Object>>.add", "CacheBuilder<? super String, ? super String>.maximumSize", "List<CacheBuilder<Object, Object>>.add", "CacheBuilder<? super String, ? super String>.expireAfterAccess", "List<CacheBuilder<Object, Object>>.add", "CacheBuilder<? super String, ? super String>.expireAfterWrite", "List<CacheBuilder<Object, Object>>.add", "CacheBuilder<? super String, ? super String>.maximumSize", "List<CacheBuilder<Object, Object>>.add", "CacheBuilder<? super String, ? super String>.maximumSize"], "method_name": "LocalCacheTest.allEntryTypeMakers", "method_implementation": "{\n    List<CacheBuilder<Object, Object>> result = newArrayList(allKeyValueStrengthMakers());\n    for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n        result.add(builder.maximumSize(SMALL_MAX_SIZE));\n    }\n    for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n        result.add(builder.expireAfterAccess(99999, SECONDS));\n    }\n    for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n        result.add(builder.expireAfterWrite(99999, SECONDS));\n    }\n    for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n        result.add(builder.maximumSize(SMALL_MAX_SIZE).expireAfterAccess(99999, SECONDS));\n    }\n    for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n        result.add(builder.maximumSize(SMALL_MAX_SIZE).expireAfterWrite(99999, SECONDS));\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns an iterable containing all combinations of maximumSize, expireAfterAccess/Write,\n * weakKeys and weak/softValues.\n */\n", "repo_name": "guava-master/", "id": 3662, "method_signature": "Iterable<CacheBuilder<Object,Object>> allEntryTypeMakers()", "filename": "LocalCacheTest.allEntryTypeMakers.json"}
{"callee_method_names": [], "method_name": "LocalCacheTest.allEvictingMakers", "method_implementation": "{\n    return ImmutableList.of(createCacheBuilder().maximumSize(SMALL_MAX_SIZE), createCacheBuilder().expireAfterAccess(99999, SECONDS), createCacheBuilder().expireAfterWrite(99999, SECONDS), createCacheBuilder().maximumSize(SMALL_MAX_SIZE).expireAfterAccess(SMALL_MAX_SIZE, TimeUnit.SECONDS), createCacheBuilder().maximumSize(SMALL_MAX_SIZE).expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n}", "repo_id": "5", "comment": "/**\n * Returns an iterable containing all combinations of maximumSize and expireAfterAccess/Write.\n */\n", "repo_name": "guava-master/", "id": 3663, "method_signature": "Iterable<CacheBuilder<Object,Object>> allEvictingMakers()", "filename": "LocalCacheTest.allEvictingMakers.json"}
{"callee_method_names": [], "method_name": "LocalCacheTest.allKeyValueStrengthMakers", "method_implementation": "{\n    return ImmutableList.of(createCacheBuilder(), createCacheBuilder().weakValues(), createCacheBuilder().softValues(), createCacheBuilder().weakKeys(), createCacheBuilder().weakKeys().weakValues(), createCacheBuilder().weakKeys().softValues());\n}", "repo_id": "5", "comment": "/**\n * Returns an iterable containing all combinations weakKeys and weak/softValues.\n */\n", "repo_name": "guava-master/", "id": 3664, "method_signature": "Iterable<CacheBuilder<Object,Object>> allKeyValueStrengthMakers()", "filename": "LocalCacheTest.allKeyValueStrengthMakers.json"}
{"callee_method_names": ["LocalLoadingCache<Object, Object>.asMap", "LocalLoadingCache<Object, Object>.getUnchecked", "Segment<Object, Object>.isEmpty", "ConcurrentMap<Object, Object>.get", "Segment<Object, Object>.peek", "LocalLoadingCache<Object, Object>.getUnchecked", "Segment<Object, Object>.isEmpty"], "method_name": "LocalLoadingCacheTest.testAsMapRecency", "method_implementation": "{\n    CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1).maximumSize(SMALL_MAX_SIZE);\n    LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n    Segment<Object, Object> segment = cache.localCache.segments[0];\n    ConcurrentMap<Object, Object> map = cache.asMap();\n    Object one = new Object();\n    assertSame(one, cache.getUnchecked(one));\n    assertTrue(segment.recencyQueue.isEmpty());\n    assertSame(one, map.get(one));\n    assertSame(one, segment.recencyQueue.peek().getKey());\n    assertSame(one, cache.getUnchecked(one));\n    assertFalse(segment.recencyQueue.isEmpty());\n}", "repo_id": "5", "comment": "/**\n * Lookups on the map view shouldn't impact the recency queue.\n */\n", "repo_name": "guava-master/", "id": 3673, "method_signature": "void testAsMapRecency()", "filename": "LocalLoadingCacheTest.testAsMapRecency.json"}
{"callee_method_names": ["File.listFiles", "Logger.warning", "Set<File>.add", "Set<File>.remove", "String.equals", "ImmutableSet.Builder<ResourceInfo>.add"], "method_name": "LocationInfo.scanDirectory", "method_implementation": "{\n    File[] files = directory.listFiles();\n    if (files == null) {\n        logger.warning(\"Cannot read directory \" + directory);\n        // IO error, just skip the directory\n        return;\n    }\n    for (File f : files) {\n        String name = f.getName();\n        if (f.isDirectory()) {\n            File deref = f.getCanonicalFile();\n            if (currentPath.add(deref)) {\n                scanDirectory(deref, packagePrefix + name + \"/\", currentPath, builder);\n                currentPath.remove(deref);\n            }\n        } else {\n            String resourceName = packagePrefix + name;\n            if (!resourceName.equals(JarFile.MANIFEST_NAME)) {\n                builder.add(ResourceInfo.of(f, resourceName, classloader));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Recursively scan the given directory, adding resources for each file encountered. Symlinks\n * which have already been traversed in the current tree path will be skipped to eliminate\n * cycles; otherwise symlinks are traversed.\n *\n * @param directory the root of the directory to scan\n * @param packagePrefix resource path prefix inside {@code classloader} for any files found\n *     under {@code directory}\n * @param currentPath canonical files already visited in the current directory tree path, for\n *     cycle elimination\n */\n", "repo_name": "guava-master/", "id": 4712, "method_signature": "void scanDirectory(File, String, Set, ImmutableSet.Builder)", "filename": "LocationInfo.scanDirectory.json"}
{"callee_method_names": ["Set<File>.add", "ImmutableSet.Builder<ResourceInfo>.build"], "method_name": "LocationInfo.scanResources", "method_implementation": "{\n    ImmutableSet.Builder<ResourceInfo> builder = ImmutableSet.builder();\n    scannedFiles.add(home);\n    scan(home, scannedFiles, builder);\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Scans this location and returns all scanned resources.\n *\n * <p>This file and jar files from \"Class-Path\" entry in the scanned manifest files will be\n * added to {@code scannedFiles}.\n *\n * <p>A file will be scanned at most once even if specified multiple times by one or multiple\n * jar files' \"Class-Path\" manifest entries. Particularly, if a jar file from the \"Class-Path\"\n * manifest entry is already in {@code scannedFiles}, either because it was scanned earlier, or\n * it was intentionally added to the set by the caller, it will not be scanned again.\n *\n * <p>Note that when you call {@code location.scanResources(scannedFiles)}, the location will\n * always be scanned even if {@code scannedFiles} already contains it.\n */\n", "repo_name": "guava-master/", "id": 4711, "method_signature": "ImmutableSet<ResourceInfo> scanResources(Set)", "filename": "LocationInfo.scanResources.json"}
{"callee_method_names": ["AtomicLongArray.length", "LockFreeBitArray.length", "AtomicLongArray.length", "LockFreeBitArray.length", "AtomicLongArray.length", "LockFreeBitArray.get"], "method_name": "LockFreeBitArray.putAll", "method_implementation": "{\n    checkArgument(data.length() == other.data.length(), \"BitArrays must be of equal length (%s != %s)\", data.length(), other.data.length());\n    for (int i = 0; i < data.length(); i++) {\n        putData(i, other.data.get(i));\n    }\n}", "repo_id": "5", "comment": "/**\n * Combines the two BitArrays using bitwise OR.\n *\n * <p>NOTE: Because of the use of atomics, if the other LockFreeBitArray is being mutated while\n * this operation is executing, not all of those new 1's may be set in the final state of this\n * LockFreeBitArray. The ONLY guarantee provided is that all the bits that were set in the other\n * LockFreeBitArray at the start of this method will be set in this LockFreeBitArray at the end\n * of this method.\n */\n", "repo_name": "guava-master/", "id": 5207, "method_signature": "void putAll(LockFreeBitArray)", "filename": "LockFreeBitArray.putAll.json"}
{"callee_method_names": ["AtomicLongArray.get", "AtomicLongArray.compareAndSet", "LongAddable.add"], "method_name": "LockFreeBitArray.putData", "method_implementation": "{\n    long ourLongOld;\n    long ourLongNew;\n    boolean changedAnyBits = true;\n    do {\n        ourLongOld = data.get(i);\n        ourLongNew = ourLongOld | longValue;\n        if (ourLongOld == ourLongNew) {\n            changedAnyBits = false;\n            break;\n        }\n    } while (!data.compareAndSet(i, ourLongOld, ourLongNew));\n    if (changedAnyBits) {\n        int bitsAdded = Long.bitCount(ourLongNew) - Long.bitCount(ourLongOld);\n        bitCount.add(bitsAdded);\n    }\n}", "repo_id": "5", "comment": "/**\n * ORs the bits encoded in the {@code i}th {@code long} in the underlying {@link\n * AtomicLongArray} with the given value.\n */\n", "repo_name": "guava-master/", "id": 5208, "method_signature": "void putData(int, long)", "filename": "LockFreeBitArray.putData.json"}
{"callee_method_names": ["AtomicLongArray.get", "AtomicLongArray.compareAndSet", "LongAddable.increment"], "method_name": "LockFreeBitArray.set", "method_implementation": "{\n    if (get(bitIndex)) {\n        return false;\n    }\n    int longIndex = (int) (bitIndex >>> LONG_ADDRESSABLE_BITS);\n    // only cares about low 6 bits of bitIndex\n    long mask = 1L << bitIndex;\n    long oldValue;\n    long newValue;\n    do {\n        oldValue = data.get(longIndex);\n        newValue = oldValue | mask;\n        if (oldValue == newValue) {\n            return false;\n        }\n    } while (!data.compareAndSet(longIndex, oldValue, newValue));\n    // We turned the bit on, so increment bitCount.\n    bitCount.increment();\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns true if the bit changed value.\n */\n", "repo_name": "guava-master/", "id": 5205, "method_signature": "boolean set(long)", "filename": "LockFreeBitArray.set.json"}
{"callee_method_names": ["AtomicLongArray.length", "AtomicLongArray.get"], "method_name": "LockFreeBitArray.toPlainArray", "method_implementation": "{\n    long[] array = new long[atomicLongArray.length()];\n    for (int i = 0; i < array.length; ++i) {\n        array[i] = atomicLongArray.get(i);\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Careful here: if threads are mutating the atomicLongArray while this method is executing, the\n * final long[] will be a \"rolling snapshot\" of the state of the bit array. This is usually good\n * enough, but should be kept in mind.\n */\n", "repo_name": "guava-master/", "id": 5206, "method_signature": "long[] toPlainArray(AtomicLongArray)", "filename": "LockFreeBitArray.toPlainArray.json"}
{"callee_method_ids": [5482], "callee_method_names": ["LockGraphNode.getLockName", "Map<LockGraphNode, ExampleStackTrace>.containsKey", "Map<LockGraphNode, PotentialDeadlockException>.get", "PotentialDeadlockException.getConflictingStackTrace", "Policy.handlePotentialDeadlock", "LockGraphNode.findPathTo", "Map<LockGraphNode, ExampleStackTrace>.put", "Map<LockGraphNode, PotentialDeadlockException>.put", "Policy.handlePotentialDeadlock"], "method_name": "LockGraphNode.checkAcquiredLock", "method_implementation": "{\n    // checkAcquiredLock() should never be invoked by a lock that has already\n    // been acquired. For unordered locks, aboutToAcquire() ensures this by\n    // checking isAcquiredByCurrentThread(). For ordered locks, however, this\n    // can happen because multiple locks may share the same LockGraphNode. In\n    // this situation, throw an IllegalStateException as defined by contract\n    // described in the documentation of WithExplicitOrdering.\n    Preconditions.checkState(this != acquiredLock, \"Attempted to acquire multiple locks with the same rank %s\", acquiredLock.getLockName());\n    if (allowedPriorLocks.containsKey(acquiredLock)) {\n        // The acquisition ordering from \"acquiredLock\" to \"this\" has already\n        // been verified as safe. In a properly written application, this is\n        // the common case.\n        return;\n    }\n    PotentialDeadlockException previousDeadlockException = disallowedPriorLocks.get(acquiredLock);\n    if (previousDeadlockException != null) {\n        // Previously determined to be an unsafe lock acquisition.\n        // Create a new PotentialDeadlockException with the same causal chain\n        // (the example cycle) as that of the cached exception.\n        PotentialDeadlockException exception = new PotentialDeadlockException(acquiredLock, this, previousDeadlockException.getConflictingStackTrace());\n        policy.handlePotentialDeadlock(exception);\n        return;\n    }\n    // Otherwise, it's the first time seeing this lock relationship. Look for\n    // a path from the acquiredLock to this.\n    Set<LockGraphNode> seen = Sets.newIdentityHashSet();\n    ExampleStackTrace path = acquiredLock.findPathTo(this, seen);\n    if (path == null) {\n        // this can be safely acquired after the acquiredLock.\n        //\n        // Note that there is a race condition here which can result in missing\n        // a cyclic edge: it's possible for two threads to simultaneous find\n        // \"safe\" edges which together form a cycle. Preventing this race\n        // condition efficiently without _introducing_ deadlock is probably\n        // tricky. For now, just accept the race condition---missing a warning\n        // now and then is still better than having no deadlock detection.\n        allowedPriorLocks.put(acquiredLock, new ExampleStackTrace(acquiredLock, this));\n    } else {\n        // Unsafe acquisition order detected. Create and cache a\n        // PotentialDeadlockException.\n        PotentialDeadlockException exception = new PotentialDeadlockException(acquiredLock, this, path);\n        disallowedPriorLocks.put(acquiredLock, exception);\n        policy.handlePotentialDeadlock(exception);\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks the acquisition-ordering between {@code this}, which is about to be acquired, and the\n * specified {@code acquiredLock}.\n *\n * <p>When this method returns, the {@code acquiredLock} should be in either the {@code\n * preAcquireLocks} map, for the case in which it is safe to acquire {@code this} after the\n * {@code acquiredLock}, or in the {@code disallowedPriorLocks} map, in which case it is not\n * safe.\n */\n", "repo_name": "guava-master/", "id": 5481, "method_signature": "void checkAcquiredLock(Policy, LockGraphNode)", "filename": "LockGraphNode.checkAcquiredLock.json"}
{"callee_method_ids": [5482], "callee_method_names": ["Set<LockGraphNode>.add", "Map<LockGraphNode, ExampleStackTrace>.get", "Map<LockGraphNode, ExampleStackTrace>.entrySet", "Entry<K, AtomicLong>.getKey", "LockGraphNode.findPathTo", "ExampleStackTrace.setStackTrace", "Entry<K, AtomicLong>.getValue", "ExampleStackTrace.initCause"], "method_name": "LockGraphNode.findPathTo", "method_implementation": "{\n    if (!seen.add(this)) {\n        // Already traversed this node.\n        return null;\n    }\n    ExampleStackTrace found = allowedPriorLocks.get(node);\n    if (found != null) {\n        // Found a path ending at the node!\n        return found;\n    }\n    // Recurse the edges.\n    for (Entry<LockGraphNode, ExampleStackTrace> entry : allowedPriorLocks.entrySet()) {\n        LockGraphNode preAcquiredLock = entry.getKey();\n        found = preAcquiredLock.findPathTo(node, seen);\n        if (found != null) {\n            // One of this node's allowedPriorLocks found a path. Prepend an\n            // ExampleStackTrace(preAcquiredLock, this) to the returned chain of\n            // ExampleStackTraces.\n            ExampleStackTrace path = new ExampleStackTrace(preAcquiredLock, this);\n            path.setStackTrace(entry.getValue().getStackTrace());\n            path.initCause(found);\n            return path;\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Performs a depth-first traversal of the graph edges defined by each node's {@code\n * allowedPriorLocks} to find a path between {@code this} and the specified {@code lock}.\n *\n * @return If a path was found, a chained {@link ExampleStackTrace} illustrating the path to the\n *     {@code lock}, or {@code null} if no path was found.\n */\n", "repo_name": "guava-master/", "id": 5482, "method_signature": "ExampleStackTrace findPathTo(LockGraphNode, Set)", "filename": "LockGraphNode.findPathTo.json"}
{"callee_method_names": ["ThreadLocal.get", "Cell.cas"], "method_name": "LongAdder.add", "method_implementation": "{\n    Cell[] as;\n    long b, v;\n    int[] hc;\n    Cell a;\n    int n;\n    if ((as = cells) != null || !casBase(b = base, b + x)) {\n        boolean uncontended = true;\n        if ((hc = threadHashCode.get()) == null || as == null || (n = as.length) < 1 || (a = as[(n - 1) & hc[0]]) == null || !(uncontended = a.cas(v = a.value, v + x)))\n            retryUpdate(x, hc, uncontended);\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds the given value.\n *\n * @param x the value to add\n */\n", "repo_name": "guava-master/", "id": 5216, "method_signature": "void add(long)", "filename": "LongAdder.add.json"}
{"callee_method_names": [], "method_name": "LongAdder.sum", "method_implementation": "{\n    long sum = base;\n    Cell[] as = cells;\n    if (as != null) {\n        int n = as.length;\n        for (int i = 0; i < n; ++i) {\n            Cell a = as[i];\n            if (a != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}", "repo_id": "5", "comment": "/**\n * Returns the current sum. The returned value is <em>NOT</em> an atomic snapshot; invocation in\n * the absence of concurrent updates returns an accurate result, but concurrent updates that occur\n * while the sum is being calculated might not be incorporated.\n *\n * @return the sum\n */\n", "repo_name": "guava-master/", "id": 5217, "method_signature": "long sum()", "filename": "LongAdder.sum.json"}
{"callee_method_names": [], "method_name": "LongAdder.sumThenReset", "method_implementation": "{\n    long sum = base;\n    Cell[] as = cells;\n    base = 0L;\n    if (as != null) {\n        int n = as.length;\n        for (int i = 0; i < n; ++i) {\n            Cell a = as[i];\n            if (a != null) {\n                sum += a.value;\n                a.value = 0L;\n            }\n        }\n    }\n    return sum;\n}", "repo_id": "5", "comment": "/**\n * Equivalent in effect to {@link #sum} followed by {@link #reset}. This method may apply for\n * example during quiescent points between multithreaded computations. If there are updates\n * concurrent with this method, the returned value is <em>not</em> guaranteed to be the final\n * value occurring before the reset.\n *\n * @return the sum\n */\n", "repo_name": "guava-master/", "id": 5218, "method_signature": "long sumThenReset()", "filename": "LongAdder.sumThenReset.json"}
{"callee_method_names": [], "method_name": "LongMath.binomial", "method_implementation": "{\n    checkNonNegative(\"n\", n);\n    checkNonNegative(\"k\", k);\n    checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n    if (k > (n >> 1)) {\n        k = n - k;\n    }\n    switch(k) {\n        case 0:\n            return 1;\n        case 1:\n            return n;\n        default:\n            if (n < factorials.length) {\n                return factorials[n] / (factorials[k] * factorials[n - k]);\n            } else if (k >= biggestBinomials.length || n > biggestBinomials[k]) {\n                return Long.MAX_VALUE;\n            } else if (k < biggestSimpleBinomials.length && n <= biggestSimpleBinomials[k]) {\n                // guaranteed not to overflow\n                long result = n--;\n                for (int i = 2; i <= k; n--, i++) {\n                    result *= n;\n                    result /= i;\n                }\n                return result;\n            } else {\n                int nBits = LongMath.log2(n, RoundingMode.CEILING);\n                long result = 1;\n                long numerator = n--;\n                long denominator = 1;\n                int numeratorBits = nBits;\n                // This is an upper bound on log2(numerator, ceiling).\n                /*\n           * We want to do this in long math for speed, but want to avoid overflow. We adapt the\n           * technique previously used by BigIntegerMath: maintain separate numerator and\n           * denominator accumulators, multiplying the fraction into result when near overflow.\n           */\n                for (int i = 2; i <= k; i++, n--) {\n                    if (numeratorBits + nBits < Long.SIZE - 1) {\n                        // It's definitely safe to multiply into numerator and denominator.\n                        numerator *= n;\n                        denominator *= i;\n                        numeratorBits += nBits;\n                    } else {\n                        // It might not be safe to multiply into numerator and denominator,\n                        // so multiply (numerator / denominator) into result.\n                        result = multiplyFraction(result, numerator, denominator);\n                        numerator = n;\n                        denominator = i;\n                        numeratorBits = nBits;\n                    }\n                }\n                return multiplyFraction(result, numerator, denominator);\n            }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and\n * {@code k}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.\n *\n * @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}\n */\n", "repo_name": "guava-master/", "id": 4630, "method_signature": "long binomial(int, int)", "filename": "LongMath.binomial.json"}
{"callee_method_names": [], "method_name": "LongMath.ceilingPowerOfTwo", "method_implementation": "{\n    checkPositive(\"x\", x);\n    if (x > MAX_SIGNED_POWER_OF_TWO) {\n        throw new ArithmeticException(\"ceilingPowerOfTwo(\" + x + \") is not representable as a long\");\n    }\n    return 1L << -Long.numberOfLeadingZeros(x - 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to\n * {@code checkedPow(2, log2(x, CEILING))}.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException of the next-higher power of two is not representable as a {@code\n *     long}, i.e. when {@code x > 2^62}\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4610, "method_signature": "long ceilingPowerOfTwo(long)", "filename": "LongMath.ceilingPowerOfTwo.json"}
{"callee_method_names": [], "method_name": "LongMath.checkedAdd", "method_implementation": "{\n    long result = a + b;\n    checkNoOverflow((a ^ b) < 0 | (a ^ result) >= 0, \"checkedAdd\", a, b);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the sum of {@code a} and {@code b}, provided it does not overflow.\n *\n * @throws ArithmeticException if {@code a + b} overflows in signed {@code long} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4621, "method_signature": "long checkedAdd(long, long)", "filename": "LongMath.checkedAdd.json"}
{"callee_method_names": [], "method_name": "LongMath.checkedMultiply", "method_implementation": "{\n    // Hacker's Delight, Section 2-12\n    int leadingZeros = Long.numberOfLeadingZeros(a) + Long.numberOfLeadingZeros(~a) + Long.numberOfLeadingZeros(b) + Long.numberOfLeadingZeros(~b);\n    /*\n     * If leadingZeros > Long.SIZE + 1 it's definitely fine, if it's < Long.SIZE it's definitely\n     * bad. We do the leadingZeros check to avoid the division below if at all possible.\n     *\n     * Otherwise, if b == Long.MIN_VALUE, then the only allowed values of a are 0 and 1. We take\n     * care of all a < 0 with their own check, because in particular, the case a == -1 will\n     * incorrectly pass the division check below.\n     *\n     * In all other cases, we check that either a is 0 or the result is consistent with division.\n     */\n    if (leadingZeros > Long.SIZE + 1) {\n        return a * b;\n    }\n    checkNoOverflow(leadingZeros >= Long.SIZE, \"checkedMultiply\", a, b);\n    checkNoOverflow(a >= 0 | b != Long.MIN_VALUE, \"checkedMultiply\", a, b);\n    long result = a * b;\n    checkNoOverflow(a == 0 || result / a == b, \"checkedMultiply\", a, b);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the product of {@code a} and {@code b}, provided it does not overflow.\n *\n * @throws ArithmeticException if {@code a * b} overflows in signed {@code long} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4623, "method_signature": "long checkedMultiply(long, long)", "filename": "LongMath.checkedMultiply.json"}
{"callee_method_names": [], "method_name": "LongMath.checkedPow", "method_implementation": "{\n    checkNonNegative(\"exponent\", k);\n    if (b >= -2 & b <= 2) {\n        switch((int) b) {\n            case 0:\n                return (k == 0) ? 1 : 0;\n            case 1:\n                return 1;\n            case (-1):\n                return ((k & 1) == 0) ? 1 : -1;\n            case 2:\n                checkNoOverflow(k < Long.SIZE - 1, \"checkedPow\", b, k);\n                return 1L << k;\n            case (-2):\n                checkNoOverflow(k < Long.SIZE, \"checkedPow\", b, k);\n                return ((k & 1) == 0) ? (1L << k) : (-1L << k);\n            default:\n                throw new AssertionError();\n        }\n    }\n    long accum = 1;\n    while (true) {\n        switch(k) {\n            case 0:\n                return accum;\n            case 1:\n                return checkedMultiply(accum, b);\n            default:\n                if ((k & 1) != 0) {\n                    accum = checkedMultiply(accum, b);\n                }\n                k >>= 1;\n                if (k > 0) {\n                    checkNoOverflow(-FLOOR_SQRT_MAX_LONG <= b && b <= FLOOR_SQRT_MAX_LONG, \"checkedPow\", b, k);\n                    b *= b;\n                }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code b} to the {@code k}th power, provided it does not overflow.\n *\n * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed {@code\n *     long} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4624, "method_signature": "long checkedPow(long, int)", "filename": "LongMath.checkedPow.json"}
{"callee_method_names": [], "method_name": "LongMath.checkedSubtract", "method_implementation": "{\n    long result = a - b;\n    checkNoOverflow((a ^ b) >= 0 | (a ^ result) >= 0, \"checkedSubtract\", a, b);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the difference of {@code a} and {@code b}, provided it does not overflow.\n *\n * @throws ArithmeticException if {@code a - b} overflows in signed {@code long} arithmetic\n */\n", "repo_name": "guava-master/", "id": 4622, "method_signature": "long checkedSubtract(long, long)", "filename": "LongMath.checkedSubtract.json"}
{"callee_method_names": [], "method_name": "LongMath.divide", "method_implementation": "{\n    checkNotNull(mode);\n    // throws if q == 0\n    long div = p / q;\n    // equals p % q\n    long rem = p - q * div;\n    if (rem == 0) {\n        return div;\n    }\n    /*\n     * Normal Java division rounds towards 0, consistently with RoundingMode.DOWN. We just have to\n     * deal with the cases where rounding towards 0 is wrong, which typically depends on the sign of\n     * p / q.\n     *\n     * signum is 1 if p and q are both nonnegative or both negative, and -1 otherwise.\n     */\n    int signum = 1 | (int) ((p ^ q) >> (Long.SIZE - 1));\n    boolean increment;\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(rem == 0);\n        // fall through\n        case DOWN:\n            increment = false;\n            break;\n        case UP:\n            increment = true;\n            break;\n        case CEILING:\n            increment = signum > 0;\n            break;\n        case FLOOR:\n            increment = signum < 0;\n            break;\n        case HALF_EVEN:\n        case HALF_DOWN:\n        case HALF_UP:\n            long absRem = abs(rem);\n            long cmpRemToHalfDivisor = absRem - (abs(q) - absRem);\n            // subtracting two nonnegative longs can't overflow\n            // cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).\n            if (cmpRemToHalfDivisor == 0) {\n                // exactly on the half mark\n                increment = (mode == HALF_UP || (mode == HALF_EVEN && (div & 1) != 0));\n            } else {\n                // closer to the UP value\n                increment = cmpRemToHalfDivisor > 0;\n            }\n            break;\n        default:\n            throw new AssertionError();\n    }\n    return increment ? div + signum : div;\n}", "repo_id": "5", "comment": "/**\n * Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code\n * RoundingMode}.\n *\n * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n *     is not an integer multiple of {@code b}\n */\n", "repo_name": "guava-master/", "id": 4617, "method_signature": "long divide(long, long, RoundingMode)", "filename": "LongMath.divide.json"}
{"callee_method_names": [], "method_name": "LongMath.factorial", "method_implementation": "{\n    checkNonNegative(\"n\", n);\n    return (n < factorials.length) ? factorials[n] : Long.MAX_VALUE;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if\n * {@code n == 0}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.\n *\n * @throws IllegalArgumentException if {@code n < 0}\n */\n", "repo_name": "guava-master/", "id": 4629, "method_signature": "long factorial(int)", "filename": "LongMath.factorial.json"}
{"callee_method_names": [], "method_name": "LongMath.floorPowerOfTwo", "method_implementation": "{\n    checkPositive(\"x\", x);\n    // Long.highestOneBit was buggy on GWT.  We've fixed it, but I'm not certain when the fix will\n    // be released.\n    return 1L << ((Long.SIZE - 1) - Long.numberOfLeadingZeros(x));\n}", "repo_id": "5", "comment": "/**\n * Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code\n * checkedPow(2, log2(x, FLOOR))}.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4611, "method_signature": "long floorPowerOfTwo(long)", "filename": "LongMath.floorPowerOfTwo.json"}
{"callee_method_names": [], "method_name": "LongMath.gcd", "method_implementation": "{\n    /*\n     * The reason we require both arguments to be >= 0 is because otherwise, what do you return on\n     * gcd(0, Long.MIN_VALUE)? BigInteger.gcd would return positive 2^63, but positive 2^63 isn't an\n     * int.\n     */\n    checkNonNegative(\"a\", a);\n    checkNonNegative(\"b\", b);\n    if (a == 0) {\n        // 0 % b == 0, so b divides a, but the converse doesn't hold.\n        // BigInteger.gcd is consistent with this decision.\n        return b;\n    } else if (b == 0) {\n        // similar logic\n        return a;\n    }\n    /*\n     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm. This is\n     * >60% faster than the Euclidean algorithm in benchmarks.\n     */\n    int aTwos = Long.numberOfTrailingZeros(a);\n    // divide out all 2s\n    a >>= aTwos;\n    int bTwos = Long.numberOfTrailingZeros(b);\n    // divide out all 2s\n    b >>= bTwos;\n    while (a != b) {\n        // both a, b are odd\n        // The key to the binary GCD algorithm is as follows:\n        // Both a and b are odd. Assume a > b; then gcd(a - b, b) = gcd(a, b).\n        // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.\n        // We bend over backwards to avoid branching, adapting a technique from\n        // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax\n        // can't overflow, since a and b are nonnegative\n        long delta = a - b;\n        long minDeltaOrZero = delta & (delta >> (Long.SIZE - 1));\n        // equivalent to Math.min(delta, 0)\n        // sets a to Math.abs(a - b)\n        a = delta - minDeltaOrZero - minDeltaOrZero;\n        // a is now nonnegative and even\n        // sets b to min(old a, b)\n        b += minDeltaOrZero;\n        // divide out all 2s, since 2 doesn't divide b\n        a >>= Long.numberOfTrailingZeros(a);\n    }\n    return a << min(aTwos, bTwos);\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if {@code a == 0 && b ==\n * 0}.\n *\n * @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}\n */\n", "repo_name": "guava-master/", "id": 4620, "method_signature": "long gcd(long, long)", "filename": "LongMath.gcd.json"}
{"callee_method_names": [], "method_name": "LongMath.isPrime", "method_implementation": "{\n    if (n < 2) {\n        checkNonNegative(\"n\", n);\n        return false;\n    }\n    if (n < 66) {\n        // Encode all primes less than 66 into mask without 0 and 1.\n        long mask = (1L << (2 - 2)) | (1L << (3 - 2)) | (1L << (5 - 2)) | (1L << (7 - 2)) | (1L << (11 - 2)) | (1L << (13 - 2)) | (1L << (17 - 2)) | (1L << (19 - 2)) | (1L << (23 - 2)) | (1L << (29 - 2)) | (1L << (31 - 2)) | (1L << (37 - 2)) | (1L << (41 - 2)) | (1L << (43 - 2)) | (1L << (47 - 2)) | (1L << (53 - 2)) | (1L << (59 - 2)) | (1L << (61 - 2));\n        // Look up n within the mask.\n        return ((mask >> ((int) n - 2)) & 1) != 0;\n    }\n    if ((SIEVE_30 & (1 << (n % 30))) != 0) {\n        return false;\n    }\n    if (n % 7 == 0 || n % 11 == 0 || n % 13 == 0) {\n        return false;\n    }\n    if (n < 17 * 17) {\n        return true;\n    }\n    for (long[] baseSet : millerRabinBaseSets) {\n        if (n <= baseSet[0]) {\n            for (int i = 1; i < baseSet.length; i++) {\n                if (!MillerRabinTester.test(baseSet[i], n)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code n} is a <a\n * href=\"http://mathworld.wolfram.com/PrimeNumber.html\">prime number</a>: an integer <i>greater\n * than one</i> that cannot be factored into a product of <i>smaller</i> positive integers.\n * Returns {@code false} if {@code n} is zero, one, or a composite number (one which <i>can</i> be\n * factored into smaller positive integers).\n *\n * <p>To test larger numbers, use {@link BigInteger#isProbablePrime}.\n *\n * @throws IllegalArgumentException if {@code n} is negative\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4633, "method_signature": "boolean isPrime(long)", "filename": "LongMath.isPrime.json"}
{"callee_method_names": [], "method_name": "LongMath.lessThanBranchFree", "method_implementation": "{\n    // Returns the sign bit of x - y.\n    return (int) (~~(x - y) >>> (Long.SIZE - 1));\n}", "repo_id": "5", "comment": "/**\n * Returns 1 if {@code x < y} as unsigned longs, and 0 otherwise. Assumes that x - y fits into a\n * signed long. The implementation is branch-free, and benchmarks suggest it is measurably faster\n * than the straightforward ternary expression.\n */\n", "repo_name": "guava-master/", "id": 4612, "method_signature": "int lessThanBranchFree(long, long)", "filename": "LongMath.lessThanBranchFree.json"}
{"callee_method_names": [], "method_name": "LongMath.log10", "method_implementation": "{\n    checkPositive(\"x\", x);\n    int logFloor = log10Floor(x);\n    long floorPow = powersOf10[logFloor];\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(x == floorPow);\n        // fall through\n        case FLOOR:\n        case DOWN:\n            return logFloor;\n        case CEILING:\n        case UP:\n            return logFloor + lessThanBranchFree(floorPow, x);\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            // sqrt(10) is irrational, so log10(x)-logFloor is never exactly 0.5\n            return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not a power of ten\n */\n", "repo_name": "guava-master/", "id": 4614, "method_signature": "int log10(long, RoundingMode)", "filename": "LongMath.log10.json"}
{"callee_method_names": [], "method_name": "LongMath.log2", "method_implementation": "{\n    checkPositive(\"x\", x);\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(isPowerOfTwo(x));\n        // fall through\n        case DOWN:\n        case FLOOR:\n            return (Long.SIZE - 1) - Long.numberOfLeadingZeros(x);\n        case UP:\n        case CEILING:\n            return Long.SIZE - Long.numberOfLeadingZeros(x - 1);\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n            int leadingZeros = Long.numberOfLeadingZeros(x);\n            long cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n            // floor(2^(logFloor + 0.5))\n            int logFloor = (Long.SIZE - 1) - leadingZeros;\n            return logFloor + lessThanBranchFree(cmp, x);\n    }\n    throw new AssertionError(\"impossible\");\n}", "repo_id": "5", "comment": "/**\n * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x <= 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not a power of two\n */\n", "repo_name": "guava-master/", "id": 4613, "method_signature": "int log2(long, RoundingMode)", "filename": "LongMath.log2.json"}
{"callee_method_names": [], "method_name": "LongMath.mean", "method_implementation": "{\n    // Efficient method for computing the arithmetic mean.\n    // The alternative (x + y) / 2 fails for large values.\n    // The alternative (x + y) >>> 1 fails for negative values.\n    return (x & y) + ((x ^ y) >> 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the arithmetic mean of {@code x} and {@code y}, rounded toward negative infinity. This\n * method is resilient to overflow.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4632, "method_signature": "long mean(long, long)", "filename": "LongMath.mean.json"}
{"callee_method_names": [], "method_name": "LongMath.mod", "method_implementation": "{\n    if (m <= 0) {\n        throw new ArithmeticException(\"Modulus must be positive\");\n    }\n    long result = x % m;\n    return (result >= 0) ? result : result + m;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %\n * m}, which might be negative.\n *\n * <p>For example:\n *\n * <pre>{@code\n * mod(7, 4) == 3\n * mod(-7, 4) == 1\n * mod(-1, 4) == 3\n * mod(-8, 4) == 0\n * mod(8, 4) == 0\n * }</pre>\n *\n * @throws ArithmeticException if {@code m <= 0}\n * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3\">\n *     Remainder Operator</a>\n */\n", "repo_name": "guava-master/", "id": 4619, "method_signature": "long mod(long, long)", "filename": "LongMath.mod.json"}
{"callee_method_names": [], "method_name": "LongMath.multiplyFraction", "method_implementation": "{\n    if (x == 1) {\n        return numerator / denominator;\n    }\n    long commonDivisor = gcd(x, denominator);\n    x /= commonDivisor;\n    denominator /= commonDivisor;\n    // We know gcd(x, denominator) = 1, and x * numerator / denominator is exact,\n    // so denominator must be a divisor of numerator.\n    return x * (numerator / denominator);\n}", "repo_id": "5", "comment": "/**\n * Returns (x * numerator / denominator), which is assumed to come out to an integral value.\n */\n", "repo_name": "guava-master/", "id": 4631, "method_signature": "long multiplyFraction(long, long, long)", "filename": "LongMath.multiplyFraction.json"}
{"callee_method_names": [], "method_name": "LongMath.pow", "method_implementation": "{\n    checkNonNegative(\"exponent\", k);\n    if (-2 <= b && b <= 2) {\n        switch((int) b) {\n            case 0:\n                return (k == 0) ? 1 : 0;\n            case 1:\n                return 1;\n            case (-1):\n                return ((k & 1) == 0) ? 1 : -1;\n            case 2:\n                return (k < Long.SIZE) ? 1L << k : 0;\n            case (-2):\n                if (k < Long.SIZE) {\n                    return ((k & 1) == 0) ? 1L << k : -(1L << k);\n                } else {\n                    return 0;\n                }\n            default:\n                throw new AssertionError();\n        }\n    }\n    for (long accum = 1; ; k >>= 1) {\n        switch(k) {\n            case 0:\n                return accum;\n            case 1:\n                return accum * b;\n            default:\n                accum *= ((k & 1) == 0) ? 1 : b;\n                b *= b;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to\n * {@code BigInteger.valueOf(b).pow(k).longValue()}. This implementation runs in {@code O(log k)}\n * time.\n *\n * @throws IllegalArgumentException if {@code k < 0}\n */\n", "repo_name": "guava-master/", "id": 4615, "method_signature": "long pow(long, int)", "filename": "LongMath.pow.json"}
{"callee_method_names": [], "method_name": "LongMath.powMod", "method_implementation": "{\n    long res = 1;\n    for (; p != 0; p >>= 1) {\n        if ((p & 1) != 0) {\n            res = mulMod(res, a, m);\n        }\n        a = squareMod(a, m);\n    }\n    return res;\n}", "repo_id": "5", "comment": "/**\n * Returns a^p mod m.\n */\n", "repo_name": "guava-master/", "id": 4634, "method_signature": "long powMod(long, long, long)", "filename": "LongMath.powMod.json"}
{"callee_method_names": [], "method_name": "LongMath.roundToDouble", "method_implementation": "{\n    // Logic adapted from ToDoubleRounder.\n    double roundArbitrarily = (double) x;\n    long roundArbitrarilyAsLong = (long) roundArbitrarily;\n    int cmpXToRoundArbitrarily;\n    if (roundArbitrarilyAsLong == Long.MAX_VALUE) {\n        /*\n       * For most values, the conversion from roundArbitrarily to roundArbitrarilyAsLong is\n       * lossless. In that case we can compare x to roundArbitrarily using Longs.compare(x,\n       * roundArbitrarilyAsLong). The exception is for values where the conversion to double rounds\n       * up to give roundArbitrarily equal to 2^63, so the conversion back to long overflows and\n       * roundArbitrarilyAsLong is Long.MAX_VALUE. (This is the only way this condition can occur as\n       * otherwise the conversion back to long pads with zero bits.) In this case we know that\n       * roundArbitrarily > x. (This is important when x == Long.MAX_VALUE ==\n       * roundArbitrarilyAsLong.)\n       */\n        cmpXToRoundArbitrarily = -1;\n    } else {\n        cmpXToRoundArbitrarily = Longs.compare(x, roundArbitrarilyAsLong);\n    }\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(cmpXToRoundArbitrarily == 0);\n            return roundArbitrarily;\n        case FLOOR:\n            return (cmpXToRoundArbitrarily >= 0) ? roundArbitrarily : DoubleUtils.nextDown(roundArbitrarily);\n        case CEILING:\n            return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n        case DOWN:\n            if (x >= 0) {\n                return (cmpXToRoundArbitrarily >= 0) ? roundArbitrarily : DoubleUtils.nextDown(roundArbitrarily);\n            } else {\n                return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n            }\n        case UP:\n            if (x >= 0) {\n                return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n            } else {\n                return (cmpXToRoundArbitrarily >= 0) ? roundArbitrarily : DoubleUtils.nextDown(roundArbitrarily);\n            }\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            {\n                long roundFloor;\n                double roundFloorAsDouble;\n                long roundCeiling;\n                double roundCeilingAsDouble;\n                if (cmpXToRoundArbitrarily >= 0) {\n                    roundFloorAsDouble = roundArbitrarily;\n                    roundFloor = roundArbitrarilyAsLong;\n                    roundCeilingAsDouble = Math.nextUp(roundArbitrarily);\n                    roundCeiling = (long) Math.ceil(roundCeilingAsDouble);\n                } else {\n                    roundCeilingAsDouble = roundArbitrarily;\n                    roundCeiling = roundArbitrarilyAsLong;\n                    roundFloorAsDouble = DoubleUtils.nextDown(roundArbitrarily);\n                    roundFloor = (long) Math.floor(roundFloorAsDouble);\n                }\n                long deltaToFloor = x - roundFloor;\n                long deltaToCeiling = roundCeiling - x;\n                if (roundCeiling == Long.MAX_VALUE) {\n                    // correct for Long.MAX_VALUE as discussed above: roundCeilingAsDouble must be 2^63, but\n                    // roundCeiling is 2^63-1.\n                    deltaToCeiling++;\n                }\n                int diff = Longs.compare(deltaToFloor, deltaToCeiling);\n                if (diff < 0) {\n                    // closer to floor\n                    return roundFloorAsDouble;\n                } else if (diff > 0) {\n                    // closer to ceiling\n                    return roundCeilingAsDouble;\n                }\n                // halfway between the representable values; do the half-whatever logic\n                switch(mode) {\n                    case HALF_EVEN:\n                        return ((DoubleUtils.getSignificand(roundFloorAsDouble) & 1L) == 0) ? roundFloorAsDouble : roundCeilingAsDouble;\n                    case HALF_DOWN:\n                        return (x >= 0) ? roundFloorAsDouble : roundCeilingAsDouble;\n                    case HALF_UP:\n                        return (x >= 0) ? roundCeilingAsDouble : roundFloorAsDouble;\n                    default:\n                        throw new AssertionError(\"impossible\");\n                }\n            }\n    }\n    throw new AssertionError(\"impossible\");\n}", "repo_id": "5", "comment": "/**\n * Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}\n * is precisely representable as a {@code double}, its {@code double} value will be returned;\n * otherwise, the rounding will choose between the two nearest representable values with {@code\n * mode}.\n *\n * <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754\n * default rounding mode: if the two nearest representable values are equally near, the one with\n * the least significant bit zero is chosen. (In such cases, both of the nearest representable\n * values are even integers; this method returns the one that is a multiple of a greater power of\n * two.)\n *\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n *     is not precisely representable as a {@code double}\n * @since 30.0\n */\n", "repo_name": "guava-master/", "id": 4637, "method_signature": "double roundToDouble(long, RoundingMode)", "filename": "LongMath.roundToDouble.json"}
{"callee_method_names": [], "method_name": "LongMath.saturatedAdd", "method_implementation": "{\n    long naiveSum = a + b;\n    if ((a ^ b) < 0 | (a ^ naiveSum) >= 0) {\n        // If a and b have different signs or a has the same sign as the result then there was no\n        // overflow, return.\n        return naiveSum;\n    }\n    // we did over/under flow, if the sign is negative we should return MAX otherwise MIN\n    return Long.MAX_VALUE + ((naiveSum >>> (Long.SIZE - 1)) ^ 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the sum of {@code a} and {@code b} unless it would overflow or underflow in which case\n * {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4625, "method_signature": "long saturatedAdd(long, long)", "filename": "LongMath.saturatedAdd.json"}
{"callee_method_names": [], "method_name": "LongMath.saturatedMultiply", "method_implementation": "{\n    // see checkedMultiply for explanation\n    int leadingZeros = Long.numberOfLeadingZeros(a) + Long.numberOfLeadingZeros(~a) + Long.numberOfLeadingZeros(b) + Long.numberOfLeadingZeros(~b);\n    if (leadingZeros > Long.SIZE + 1) {\n        return a * b;\n    }\n    // the return value if we will overflow (which we calculate by overflowing a long :) )\n    long limit = Long.MAX_VALUE + ((a ^ b) >>> (Long.SIZE - 1));\n    if (leadingZeros < Long.SIZE | (a < 0 & b == Long.MIN_VALUE)) {\n        // overflow\n        return limit;\n    }\n    long result = a * b;\n    if (a == 0 || result / a == b) {\n        return result;\n    }\n    return limit;\n}", "repo_id": "5", "comment": "/**\n * Returns the product of {@code a} and {@code b} unless it would overflow or underflow in which\n * case {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4627, "method_signature": "long saturatedMultiply(long, long)", "filename": "LongMath.saturatedMultiply.json"}
{"callee_method_names": [], "method_name": "LongMath.saturatedPow", "method_implementation": "{\n    checkNonNegative(\"exponent\", k);\n    if (b >= -2 & b <= 2) {\n        switch((int) b) {\n            case 0:\n                return (k == 0) ? 1 : 0;\n            case 1:\n                return 1;\n            case (-1):\n                return ((k & 1) == 0) ? 1 : -1;\n            case 2:\n                if (k >= Long.SIZE - 1) {\n                    return Long.MAX_VALUE;\n                }\n                return 1L << k;\n            case (-2):\n                if (k >= Long.SIZE) {\n                    return Long.MAX_VALUE + (k & 1);\n                }\n                return ((k & 1) == 0) ? (1L << k) : (-1L << k);\n            default:\n                throw new AssertionError();\n        }\n    }\n    long accum = 1;\n    // if b is negative and k is odd then the limit is MIN otherwise the limit is MAX\n    long limit = Long.MAX_VALUE + ((b >>> (Long.SIZE - 1)) & (k & 1));\n    while (true) {\n        switch(k) {\n            case 0:\n                return accum;\n            case 1:\n                return saturatedMultiply(accum, b);\n            default:\n                if ((k & 1) != 0) {\n                    accum = saturatedMultiply(accum, b);\n                }\n                k >>= 1;\n                if (k > 0) {\n                    if (-FLOOR_SQRT_MAX_LONG > b | b > FLOOR_SQRT_MAX_LONG) {\n                        return limit;\n                    }\n                    b *= b;\n                }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code b} to the {@code k}th power, unless it would overflow or underflow in which\n * case {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4628, "method_signature": "long saturatedPow(long, int)", "filename": "LongMath.saturatedPow.json"}
{"callee_method_names": [], "method_name": "LongMath.saturatedSubtract", "method_implementation": "{\n    long naiveDifference = a - b;\n    if ((a ^ b) >= 0 | (a ^ naiveDifference) >= 0) {\n        // If a and b have the same signs or a has the same sign as the result then there was no\n        // overflow, return.\n        return naiveDifference;\n    }\n    // we did over/under flow\n    return Long.MAX_VALUE + ((naiveDifference >>> (Long.SIZE - 1)) ^ 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the difference of {@code a} and {@code b} unless it would overflow or underflow in\n * which case {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 4626, "method_signature": "long saturatedSubtract(long, long)", "filename": "LongMath.saturatedSubtract.json"}
{"callee_method_names": [], "method_name": "LongMath.sqrt", "method_implementation": "{\n    checkNonNegative(\"x\", x);\n    if (fitsInInt(x)) {\n        return IntMath.sqrt((int) x, mode);\n    }\n    /*\n     * Let k be the true value of floor(sqrt(x)), so that\n     *\n     *            k * k <= x          <  (k + 1) * (k + 1)\n     * (double) (k * k) <= (double) x <= (double) ((k + 1) * (k + 1))\n     *          since casting to double is nondecreasing.\n     *          Note that the right-hand inequality is no longer strict.\n     * Math.sqrt(k * k) <= Math.sqrt(x) <= Math.sqrt((k + 1) * (k + 1))\n     *          since Math.sqrt is monotonic.\n     * (long) Math.sqrt(k * k) <= (long) Math.sqrt(x) <= (long) Math.sqrt((k + 1) * (k + 1))\n     *          since casting to long is monotonic\n     * k <= (long) Math.sqrt(x) <= k + 1\n     *          since (long) Math.sqrt(k * k) == k, as checked exhaustively in\n     *          {@link LongMathTest#testSqrtOfPerfectSquareAsDoubleIsPerfect}\n     */\n    long guess = (long) Math.sqrt((double) x);\n    // Note: guess is always <= FLOOR_SQRT_MAX_LONG.\n    long guessSquared = guess * guess;\n    // Note (2013-2-26): benchmarks indicate that, inscrutably enough, using if statements is\n    // faster here than using lessThanBranchFree.\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(guessSquared == x);\n            return guess;\n        case FLOOR:\n        case DOWN:\n            if (x < guessSquared) {\n                return guess - 1;\n            }\n            return guess;\n        case CEILING:\n        case UP:\n            if (x > guessSquared) {\n                return guess + 1;\n            }\n            return guess;\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            long sqrtFloor = guess - ((x < guessSquared) ? 1 : 0);\n            long halfSquare = sqrtFloor * sqrtFloor + sqrtFloor;\n            /*\n         * We wish to test whether or not x <= (sqrtFloor + 0.5)^2 = halfSquare + 0.25. Since both x\n         * and halfSquare are integers, this is equivalent to testing whether or not x <=\n         * halfSquare. (We have to deal with overflow, though.)\n         *\n         * If we treat halfSquare as an unsigned long, we know that\n         *            sqrtFloor^2 <= x < (sqrtFloor + 1)^2\n         * halfSquare - sqrtFloor <= x < halfSquare + sqrtFloor + 1\n         * so |x - halfSquare| <= sqrtFloor.  Therefore, it's safe to treat x - halfSquare as a\n         * signed long, so lessThanBranchFree is safe for use.\n         */\n            return sqrtFloor + lessThanBranchFree(halfSquare, x);\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Returns the square root of {@code x}, rounded with the specified rounding mode.\n *\n * @throws IllegalArgumentException if {@code x < 0}\n * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code\n *     sqrt(x)} is not an integer\n */\n", "repo_name": "guava-master/", "id": 4616, "method_signature": "long sqrt(long, RoundingMode)", "filename": "LongMath.sqrt.json"}
{"callee_method_names": [], "method_name": "LongMath.testWitness", "method_implementation": "{\n    int r = Long.numberOfTrailingZeros(n - 1);\n    long d = (n - 1) >> r;\n    base %= n;\n    if (base == 0) {\n        return true;\n    }\n    // Calculate a := base^d mod n.\n    long a = powMod(base, d, n);\n    // n passes this test if\n    //    base^d = 1 (mod n)\n    // or base^(2^j * d) = -1 (mod n) for some 0 <= j < r.\n    if (a == 1) {\n        return true;\n    }\n    int j = 0;\n    while (a != n - 1) {\n        if (++j == r) {\n            return false;\n        }\n        a = squareMod(a, n);\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns true if n is a strong probable prime relative to the specified base.\n */\n", "repo_name": "guava-master/", "id": 4635, "method_signature": "boolean testWitness(long, long)", "filename": "LongMath.testWitness.json"}
{"callee_method_names": [], "method_name": "LongMath.times2ToThe32Mod", "method_implementation": "{\n    int remainingPowersOf2 = 32;\n    do {\n        int shift = min(remainingPowersOf2, Long.numberOfLeadingZeros(a));\n        // shift is either the number of powers of 2 left to multiply a by, or the biggest shift\n        // possible while keeping a in an unsigned long.\n        a = UnsignedLongs.remainder(a << shift, m);\n        remainingPowersOf2 -= shift;\n    } while (remainingPowersOf2 > 0);\n    return a;\n}", "repo_id": "5", "comment": "/**\n * Returns (a * 2^32) mod m. a may be any unsigned long.\n */\n", "repo_name": "guava-master/", "id": 4636, "method_signature": "long times2ToThe32Mod(long, long)", "filename": "LongMath.times2ToThe32Mod.json"}
{"callee_method_names": [], "method_name": "LongMathTest.assertMean", "method_implementation": "{\n    long expectedMean = computeMeanSafely(x, y);\n    assertEquals(expectedMean, LongMath.mean(x, y));\n    assertEquals(\"The mean of x and y should equal the mean of y and x\", expectedMean, LongMath.mean(y, x));\n}", "repo_id": "5", "comment": "/**\n * Helper method that asserts the arithmetic mean of x and y is equal to the result of\n * computeMeanSafely.\n */\n", "repo_name": "guava-master/", "id": 3599, "method_signature": "void assertMean(long, long)", "filename": "LongMathTest.assertMean.json"}
{"callee_method_names": ["BigInteger.add", "BigDecimal.toString"], "method_name": "LongMathTest.computeMeanSafely", "method_implementation": "{\n    BigInteger bigX = BigInteger.valueOf(x);\n    BigInteger bigY = BigInteger.valueOf(y);\n    BigDecimal bigMean = new BigDecimal(bigX.add(bigY)).divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\n    // parseInt blows up on overflow as opposed to intValue() which does not.\n    return Long.parseLong(bigMean.toString());\n}", "repo_id": "5", "comment": "/**\n * Computes the mean in a way that is obvious and resilient to overflow by using BigInteger\n * arithmetic.\n */\n", "repo_name": "guava-master/", "id": 3600, "method_signature": "long computeMeanSafely(long, long)", "filename": "LongMathTest.computeMeanSafely.json"}
{"callee_method_names": [], "method_name": "LongMathTest.simpleBinomial", "method_implementation": "{\n    long accum = 1;\n    for (int i = 0; i < k; i++) {\n        accum = LongMath.checkedMultiply(accum, n - i);\n        accum /= i + 1;\n    }\n    return accum;\n}", "repo_id": "5", "comment": "// Throws an ArithmeticException if \"the simple implementation\" of binomial coefficients overflows\n", "repo_name": "guava-master/", "id": 3589, "method_signature": "long simpleBinomial(int, int)", "filename": "LongMathTest.simpleBinomial.json"}
{"callee_method_names": ["BigInteger.longValue"], "method_name": "LongMathTest.testBinomial", "method_implementation": "{\n    for (int n = 0; n <= 70; n++) {\n        for (int k = 0; k <= n; k++) {\n            BigInteger expectedBig = BigIntegerMath.binomial(n, k);\n            long expectedLong = fitsInLong(expectedBig) ? expectedBig.longValue() : Long.MAX_VALUE;\n            assertEquals(expectedLong, LongMath.binomial(n, k));\n        }\n    }\n}", "repo_id": "5", "comment": "// Depends on the correctness of BigIntegerMath.binomial.\n", "repo_name": "guava-master/", "id": 3597, "method_signature": "void testBinomial()", "filename": "LongMathTest.testBinomial.json"}
{"callee_method_names": ["BigInteger.longValue"], "method_name": "LongMathTest.testFactorial", "method_implementation": "{\n    for (int n = 0; n <= 50; n++) {\n        BigInteger expectedBig = BigIntegerMath.factorial(n);\n        long expectedLong = fitsInLong(expectedBig) ? expectedBig.longValue() : Long.MAX_VALUE;\n        assertEquals(expectedLong, LongMath.factorial(n));\n    }\n}", "repo_id": "5", "comment": "// Depends on the correctness of BigIntegerMath.factorial.\n", "repo_name": "guava-master/", "id": 3596, "method_signature": "void testFactorial()", "filename": "LongMathTest.testFactorial.json"}
{"callee_method_names": [], "method_name": "LongMathTest.testLog10Exact", "method_implementation": "{\n    for (long x : POSITIVE_LONG_CANDIDATES) {\n        int floor = LongMath.log10(x, FLOOR);\n        boolean expectedSuccess = LongMath.pow(10, floor) == x;\n        try {\n            assertEquals(floor, LongMath.log10(x, UNNECESSARY));\n            assertTrue(expectedSuccess);\n        } catch (ArithmeticException e) {\n            if (expectedSuccess) {\n                failFormat(\"expected log10(%s, UNNECESSARY) = %s; got ArithmeticException\", x, floor);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of log10(long, FLOOR) and of pow(long, int).\n", "repo_name": "guava-master/", "id": 3593, "method_signature": "void testLog10Exact()", "filename": "LongMathTest.testLog10Exact.json"}
{"callee_method_names": [], "method_name": "LongMathTest.testLog10MatchesBigInteger", "method_implementation": "{\n    for (long x : POSITIVE_LONG_CANDIDATES) {\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n            assertEquals(BigIntegerMath.log10(valueOf(x), mode), LongMath.log10(x, mode));\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of BigIntegerMath.log10 for all modes except UNNECESSARY.\n", "repo_name": "guava-master/", "id": 3592, "method_signature": "void testLog10MatchesBigInteger()", "filename": "LongMathTest.testLog10MatchesBigInteger.json"}
{"callee_method_names": [], "method_name": "LongMathTest.testLog2Exact", "method_implementation": "{\n    for (long x : POSITIVE_LONG_CANDIDATES) {\n        // We only expect an exception if x was not a power of 2.\n        boolean isPowerOf2 = LongMath.isPowerOfTwo(x);\n        try {\n            assertEquals(x, 1L << LongMath.log2(x, UNNECESSARY));\n            assertTrue(isPowerOf2);\n        } catch (ArithmeticException e) {\n            assertFalse(isPowerOf2);\n        }\n    }\n}", "repo_id": "5", "comment": "/* Relies on the correctness of isPowerOfTwo(long). */\n", "repo_name": "guava-master/", "id": 3591, "method_signature": "void testLog2Exact()", "filename": "LongMathTest.testLog2Exact.json"}
{"callee_method_names": [], "method_name": "LongMathTest.testLog2MatchesBigInteger", "method_implementation": "{\n    for (long x : POSITIVE_LONG_CANDIDATES) {\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n            // The BigInteger implementation is tested separately, use it as the reference.\n            assertEquals(BigIntegerMath.log2(valueOf(x), mode), LongMath.log2(x, mode));\n        }\n    }\n}", "repo_id": "5", "comment": "/* Relies on the correctness of BigIntegerMath.log2 for all modes except UNNECESSARY. */\n", "repo_name": "guava-master/", "id": 3590, "method_signature": "void testLog2MatchesBigInteger()", "filename": "LongMathTest.testLog2MatchesBigInteger.json"}
{"callee_method_names": [], "method_name": "LongMathTest.testSqrtExactMatchesFloorOrThrows", "method_implementation": "{\n    for (long x : POSITIVE_LONG_CANDIDATES) {\n        long sqrtFloor = LongMath.sqrt(x, FLOOR);\n        // We only expect an exception if x was not a perfect square.\n        boolean isPerfectSquare = (sqrtFloor * sqrtFloor == x);\n        try {\n            assertEquals(sqrtFloor, LongMath.sqrt(x, UNNECESSARY));\n            assertTrue(isPerfectSquare);\n        } catch (ArithmeticException e) {\n            assertFalse(isPerfectSquare);\n        }\n    }\n}", "repo_id": "5", "comment": "/* Relies on the correctness of sqrt(long, FLOOR). */\n", "repo_name": "guava-master/", "id": 3595, "method_signature": "void testSqrtExactMatchesFloorOrThrows()", "filename": "LongMathTest.testSqrtExactMatchesFloorOrThrows.json"}
{"callee_method_names": [], "method_name": "LongMathTest.testSqrtMatchesBigInteger", "method_implementation": "{\n    for (long x : POSITIVE_LONG_CANDIDATES) {\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n            // Promote the long value (rather than using longValue() on the expected value) to avoid\n            // any risk of truncation which could lead to a false positive.\n            assertEquals(BigIntegerMath.sqrt(valueOf(x), mode), valueOf(LongMath.sqrt(x, mode)));\n        }\n    }\n}", "repo_id": "5", "comment": "// Relies on the correctness of BigIntegerMath.sqrt for all modes except UNNECESSARY.\n", "repo_name": "guava-master/", "id": 3594, "method_signature": "void testSqrtMatchesBigInteger()", "filename": "LongMathTest.testSqrtMatchesBigInteger.json"}
{"callee_method_names": [], "method_name": "Longs.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new LongArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>The returned list maintains the values, but not the identities, of {@code Long} objects\n * written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for\n * the returned list is unspecified.\n *\n * <p>The returned list is serializable.\n *\n * <p><b>Note:</b> when possible, you should represent your data as an {@link ImmutableLongArray}\n * instead, which has an {@link ImmutableLongArray#asList asList} view.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4406, "method_signature": "List<Long> asList(long[])", "filename": "Longs.asList.json"}
{"callee_method_names": [], "method_name": "Longs.concat", "method_implementation": "{\n    long length = 0;\n    for (long[] array : arrays) {\n        length += array.length;\n    }\n    long[] result = new long[checkNoOverflow(length)];\n    int pos = 0;\n    for (long[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new long[] {a, b}, new long[] {}, new long[] {c}} returns the array {@code {a, b, c}}.\n *\n * @param arrays zero or more {@code long} arrays\n * @return a single array containing all the values from the source arrays, in order\n * @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit\n *     in an {@code int}\n */\n", "repo_name": "guava-master/", "id": 4395, "method_signature": "long[] concat(long[][])", "filename": "Longs.concat.json"}
{"callee_method_names": [], "method_name": "Longs.contains", "method_implementation": "{\n    for (long value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.\n *\n * @param array an array of {@code long} values, possibly empty\n * @param target a primitive {@code long} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4389, "method_signature": "boolean contains(long[], long)", "filename": "Longs.contains.json"}
{"callee_method_names": [], "method_name": "Longs.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4400, "method_signature": "long[] ensureCapacity(long[], int, int)", "filename": "Longs.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Longs.fromByteArray", "method_implementation": "{\n    checkArgument(bytes.length >= BYTES, \"array too small: %s < %s\", bytes.length, BYTES);\n    return fromBytes(bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]);\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code long} value whose big-endian representation is stored in the first 8 bytes\n * of {@code bytes}; equivalent to {@code ByteBuffer.wrap(bytes).getLong()}. For example, the\n * input byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}} would yield the\n * {@code long} value {@code 0x1213141516171819L}.\n *\n * <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that library exposes much more\n * flexibility at little cost in readability.\n *\n * @throws IllegalArgumentException if {@code bytes} has fewer than 8 elements\n */\n", "repo_name": "guava-master/", "id": 4397, "method_signature": "long fromByteArray(byte[])", "filename": "Longs.fromByteArray.json"}
{"callee_method_names": [], "method_name": "Longs.fromBytes", "method_implementation": "{\n    return (b1 & 0xFFL) << 56 | (b2 & 0xFFL) << 48 | (b3 & 0xFFL) << 40 | (b4 & 0xFFL) << 32 | (b5 & 0xFFL) << 24 | (b6 & 0xFFL) << 16 | (b7 & 0xFFL) << 8 | (b8 & 0xFFL);\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code long} value whose byte representation is the given 8 bytes, in big-endian\n * order; equivalent to {@code Longs.fromByteArray(new byte[] {b1, b2, b3, b4, b5, b6, b7, b8})}.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 4398, "method_signature": "long fromBytes(byte, byte, byte, byte, byte, byte, byte, byte)", "filename": "Longs.fromBytes.json"}
{"callee_method_names": [], "method_name": "Longs.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4391, "method_signature": "int indexOf(long[], long[])", "filename": "Longs.indexOf.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Longs.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 10);\n    builder.append(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code long} values separated by {@code separator}.\n * For example, {@code join(\"-\", 1L, 2L, 3L)} returns the string {@code \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code long} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4401, "method_signature": "String join(String, long[])", "filename": "Longs.join.json"}
{"callee_method_names": [], "method_name": "Longs.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4392, "method_signature": "int lastIndexOf(long[], long, int, int)", "filename": "Longs.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Longs.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    long max = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code long} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4394, "method_signature": "long max(long[])", "filename": "Longs.max.json"}
{"callee_method_names": [], "method_name": "Longs.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    long min = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] < min) {\n            min = array[i];\n        }\n    }\n    return min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code long} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4393, "method_signature": "long min(long[])", "filename": "Longs.min.json"}
{"callee_method_names": [], "method_name": "Longs.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        long tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Longs.asList(array).subList(fromIndex, toIndex))}, but is likely to be more\n * efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4403, "method_signature": "void reverse(long[], int, int)", "filename": "Longs.reverse.json"}
{"callee_method_names": [], "method_name": "Longs.rotate", "method_implementation": "{\n    // See Ints.rotate for more details about possible algorithms here.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Longs.asList(array).subList(fromIndex, toIndex), distance)}, but is\n * considerably faster and avoids allocations and garbage collection.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4404, "method_signature": "void rotate(long[], int, int, int)", "filename": "Longs.rotate.json"}
{"callee_method_names": [], "method_name": "Longs.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    Arrays.sort(array, fromIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4402, "method_signature": "void sortDescending(long[], int, int)", "filename": "Longs.sortDescending.json"}
{"callee_method_names": ["Collection<? extends Number>.toArray"], "method_name": "Longs.toArray", "method_implementation": "{\n    if (collection instanceof LongArrayAsList) {\n        return ((LongArrayAsList) collection).toLongArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    long[] array = new long[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = ((Number) checkNotNull(boxedArray[i])).longValue();\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing each value of {@code collection}, converted to a {@code long} value\n * in the manner of {@link Number#longValue}.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * @param collection a collection of {@code Number} instances\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n * @since 1.0 (parameter was {@code Collection<Long>} before 12.0)\n */\n", "repo_name": "guava-master/", "id": 4405, "method_signature": "long[] toArray(Collection)", "filename": "Longs.toArray.json"}
{"callee_method_names": [], "method_name": "Longs.toByteArray", "method_implementation": "{\n    // Note that this code needs to stay compatible with GWT, which has known\n    // bugs when narrowing byte casts of long values occur.\n    byte[] result = new byte[8];\n    for (int i = 7; i >= 0; i--) {\n        result[i] = (byte) (value & 0xffL);\n        value >>= 8;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a big-endian representation of {@code value} in an 8-element byte array; equivalent to\n * {@code ByteBuffer.allocate(8).putLong(value).array()}. For example, the input value {@code\n * 0x1213141516171819L} would yield the byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n * 0x18, 0x19}}.\n *\n * <p>If you need to convert and concatenate several values (possibly even of different types),\n * use a shared {@link java.nio.ByteBuffer} instance, or use {@link\n * com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.\n */\n", "repo_name": "guava-master/", "id": 4396, "method_signature": "byte[] toByteArray(long)", "filename": "Longs.toByteArray.json"}
{"callee_method_names": ["String.charAt", "String.length", "String.charAt", "String.length", "String.charAt"], "method_name": "Longs.tryParse", "method_implementation": "{\n    if (checkNotNull(string).isEmpty()) {\n        return null;\n    }\n    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {\n        throw new IllegalArgumentException(\"radix must be between MIN_RADIX and MAX_RADIX but was \" + radix);\n    }\n    boolean negative = string.charAt(0) == '-';\n    int index = negative ? 1 : 0;\n    if (index == string.length()) {\n        return null;\n    }\n    int digit = AsciiDigits.digit(string.charAt(index++));\n    if (digit < 0 || digit >= radix) {\n        return null;\n    }\n    long accum = -digit;\n    long cap = Long.MIN_VALUE / radix;\n    while (index < string.length()) {\n        digit = AsciiDigits.digit(string.charAt(index++));\n        if (digit < 0 || digit >= radix || accum < cap) {\n            return null;\n        }\n        accum *= radix;\n        if (accum < Long.MIN_VALUE + digit) {\n            return null;\n        }\n        accum -= digit;\n    }\n    if (negative) {\n        return accum;\n    } else if (accum == Long.MIN_VALUE) {\n        return null;\n    } else {\n        return -accum;\n    }\n}", "repo_id": "5", "comment": "/**\n * Parses the specified string as a signed long value using the specified radix. The ASCII\n * character {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.\n *\n * <p>Unlike {@link Long#parseLong(String, int)}, this method returns {@code null} instead of\n * throwing an exception if parsing fails. Additionally, this method only accepts ASCII digits,\n * and returns {@code null} if non-ASCII digits are present in the string.\n *\n * <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even under JDK 7, despite\n * the change to {@link Long#parseLong(String, int)} for that version.\n *\n * @param string the string representation of a long value\n * @param radix the radix to use when parsing\n * @return the long value represented by {@code string} using {@code radix}, or {@code null} if\n *     {@code string} has a length of zero or cannot be parsed as a long value\n * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >\n *     Character.MAX_RADIX}\n * @throws NullPointerException if {@code string} is {@code null}\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 4399, "method_signature": "Long tryParse(String, int)", "filename": "Longs.tryParse.json"}
{"callee_method_names": [], "method_name": "LongsTest.radixEncodeParseAndAssertEquals", "method_implementation": "{\n    assertWithMessage(\"Radix: \" + radix).that(Longs.tryParse(Long.toString(value, radix), radix)).isEqualTo(value);\n}", "repo_id": "5", "comment": "/**\n * Encodes the long as a string with given radix, then uses {@link Longs#tryParse(String, int)} to\n * parse the result. Asserts the result is the same as what we started with.\n */\n", "repo_name": "guava-master/", "id": 3554, "method_signature": "void radixEncodeParseAndAssertEquals(Long, int)", "filename": "LongsTest.radixEncodeParseAndAssertEquals.json"}
{"callee_method_names": ["List<Long>.subList", "List<Long>.subList"], "method_name": "LongsTest.testAsList_subList_toArray_roundTrip", "method_implementation": "{\n    long[] array = { (long) 0, (long) 1, (long) 2, (long) 3 };\n    List<Long> list = Longs.asList(array);\n    assertThat(Longs.toArray(list.subList(1, 3))).isEqualTo(new long[] { (long) 1, (long) 2 });\n    assertThat(Longs.toArray(list.subList(2, 2))).isEqualTo(new long[] {});\n}", "repo_id": "5", "comment": "// This test stems from a real bug found by andrewk\n", "repo_name": "guava-master/", "id": 3553, "method_signature": "void testAsList_subList_toArray_roundTrip()", "filename": "LongsTest.testAsList_subList_toArray_roundTrip.json"}
{"callee_method_names": ["Map<K,V>.keySet", "Map<K,V>.values", "Map<K,V>.entrySet", "Map<K,V>.size", "Map<K,V>.isEmpty", "Map<K,V>.size", "Set<K>.size", "Set<K>.size", "Set<K>.isEmpty", "Set<K>.isEmpty", "Set<K>.iterator", "Map<K,V>.get", "K.hashCode", "Map<K,V>.containsKey", "Map<K,V>.containsValue", "Collection<V>.contains", "Collection<V>.containsAll", "Set<Entry<K, V>>.contains", "Set<K>.hashCode", "Map<K,V>.size", "Collection<V>.size", "Collection<V>.size", "Collection<V>.isEmpty", "Collection<V>.isEmpty", "Collection<V>.iterator", "Map<K,V>.containsValue", "Map<K,V>.size", "Set<Entry<K, V>>.size", "Set<Entry<K, V>>.size", "Set<Entry<K, V>>.isEmpty", "Set<Entry<K, V>>.isEmpty", "Set<Entry<K, V>>.iterator", "Map<K,V>.containsKey", "Entry<Class, Impl>.getKey", "Map<K,V>.containsValue", "Entry<Class, Impl>.getValue", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue", "Entry<Class, Impl>.getValue", "Entry<Class, Impl>.hashCode", "Set<Entry<K, V>>.hashCode", "Set<Entry<K, V>>.containsAll", "Set<Entry<K, V>>.equals", "Set<Entry<K, V>>.toArray", "Map<K,V>.size", "Map<K,V>.size", "Map<K,V>.size", "Set<Entry<K, V>>.toArray", "Map<K,V>.size", "Collection<V>.toArray", "Map<K,V>.size", "Map<K,V>.size", "Map<K,V>.size", "Collection<V>.toArray", "Map<K,V>.size", "Entry<Class, Impl>.hashCode", "Map<K,V>.hashCode"], "method_name": "MapInterfaceTest.assertInvariants", "method_implementation": "{\n    Set<K> keySet = map.keySet();\n    Collection<V> valueCollection = map.values();\n    Set<Entry<K, V>> entrySet = map.entrySet();\n    assertEquals(map.size() == 0, map.isEmpty());\n    assertEquals(map.size(), keySet.size());\n    assertEquals(keySet.size() == 0, keySet.isEmpty());\n    assertEquals(!keySet.isEmpty(), keySet.iterator().hasNext());\n    int expectedKeySetHash = 0;\n    for (K key : keySet) {\n        V value = map.get(key);\n        expectedKeySetHash += key != null ? key.hashCode() : 0;\n        assertTrue(map.containsKey(key));\n        assertTrue(map.containsValue(value));\n        assertTrue(valueCollection.contains(value));\n        assertTrue(valueCollection.containsAll(Collections.singleton(value)));\n        assertTrue(entrySet.contains(mapEntry(key, value)));\n        assertTrue(allowsNullKeys || (key != null));\n    }\n    assertEquals(expectedKeySetHash, keySet.hashCode());\n    assertEquals(map.size(), valueCollection.size());\n    assertEquals(valueCollection.size() == 0, valueCollection.isEmpty());\n    assertEquals(!valueCollection.isEmpty(), valueCollection.iterator().hasNext());\n    for (V value : valueCollection) {\n        assertTrue(map.containsValue(value));\n        assertTrue(allowsNullValues || (value != null));\n    }\n    assertEquals(map.size(), entrySet.size());\n    assertEquals(entrySet.size() == 0, entrySet.isEmpty());\n    assertEquals(!entrySet.isEmpty(), entrySet.iterator().hasNext());\n    assertEntrySetNotContainsString(entrySet);\n    boolean supportsValuesHashCode = supportsValuesHashCode(map);\n    if (supportsValuesHashCode) {\n        int expectedEntrySetHash = 0;\n        for (Entry<K, V> entry : entrySet) {\n            assertTrue(map.containsKey(entry.getKey()));\n            assertTrue(map.containsValue(entry.getValue()));\n            int expectedHash = (entry.getKey() == null ? 0 : entry.getKey().hashCode()) ^ (entry.getValue() == null ? 0 : entry.getValue().hashCode());\n            assertEquals(expectedHash, entry.hashCode());\n            expectedEntrySetHash += expectedHash;\n        }\n        assertEquals(expectedEntrySetHash, entrySet.hashCode());\n        assertTrue(entrySet.containsAll(new HashSet<Entry<K, V>>(entrySet)));\n        assertTrue(entrySet.equals(new HashSet<Entry<K, V>>(entrySet)));\n    }\n    Object[] entrySetToArray1 = entrySet.toArray();\n    assertEquals(map.size(), entrySetToArray1.length);\n    assertTrue(Arrays.asList(entrySetToArray1).containsAll(entrySet));\n    Entry<?, ?>[] entrySetToArray2 = new Entry<?, ?>[map.size() + 2];\n    entrySetToArray2[map.size()] = mapEntry(\"foo\", 1);\n    assertSame(entrySetToArray2, entrySet.toArray(entrySetToArray2));\n    assertNull(entrySetToArray2[map.size()]);\n    assertTrue(Arrays.asList(entrySetToArray2).containsAll(entrySet));\n    Object[] valuesToArray1 = valueCollection.toArray();\n    assertEquals(map.size(), valuesToArray1.length);\n    assertTrue(Arrays.asList(valuesToArray1).containsAll(valueCollection));\n    Object[] valuesToArray2 = new Object[map.size() + 2];\n    valuesToArray2[map.size()] = \"foo\";\n    assertSame(valuesToArray2, valueCollection.toArray(valuesToArray2));\n    assertNull(valuesToArray2[map.size()]);\n    assertTrue(Arrays.asList(valuesToArray2).containsAll(valueCollection));\n    if (supportsValuesHashCode) {\n        int expectedHash = 0;\n        for (Entry<K, V> entry : entrySet) {\n            expectedHash += entry.hashCode();\n        }\n        assertEquals(expectedHash, map.hashCode());\n    }\n    assertMoreInvariants(map);\n}", "repo_id": "5", "comment": "/**\n * Checks all the properties that should always hold of a map. Also calls {@link\n * #assertMoreInvariants} to check invariants that are peculiar to specific implementations.\n *\n * @see #assertMoreInvariants\n * @param map the map to check.\n */\n", "repo_name": "guava-master/", "id": 4215, "method_signature": "void assertInvariants(Map)", "filename": "MapInterfaceTest.assertInvariants.json"}
{"callee_method_names": [], "method_name": "MapInterfaceTest.makeEitherMap", "method_implementation": "{\n    try {\n        return makePopulatedMap();\n    } catch (UnsupportedOperationException e) {\n        return makeEmptyMap();\n    }\n}", "repo_id": "5", "comment": "/**\n * Used by tests that require a map, but don't care whether it's populated or not.\n *\n * @return a new map instance.\n */\n", "repo_name": "guava-master/", "id": 4214, "method_signature": "Map<K,V> makeEitherMap()", "filename": "MapInterfaceTest.makeEitherMap.json"}
{"callee_method_names": [], "method_name": "MapJoiner.appendTo", "method_implementation": "{\n    try {\n        appendTo((Appendable) builder, entries);\n    } catch (IOException impossible) {\n        throw new AssertionError(impossible);\n    }\n    return builder;\n}", "repo_id": "5", "comment": "/**\n * Appends the string representation of each entry in {@code entries}, using the previously\n * configured separator and key-value separator, to {@code builder}. Identical to {@link\n * #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4988, "method_signature": "StringBuilder appendTo(StringBuilder, Iterator)", "filename": "MapJoiner.appendTo.json"}
{"callee_method_names": [], "method_name": "MapMaker.concurrencyLevel", "method_implementation": "{\n    checkState(this.concurrencyLevel == UNSET_INT, \"concurrency level was already set to %s\", this.concurrencyLevel);\n    checkArgument(concurrencyLevel > 0);\n    this.concurrencyLevel = concurrencyLevel;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The\n * table is internally partitioned to try to permit the indicated number of concurrent updates\n * without contention. Because assignment of entries to these partitions is not necessarily\n * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to\n * accommodate as many threads as will ever concurrently modify the table. Using a significantly\n * higher value than you need can waste space and time, and a significantly lower value can lead\n * to thread contention. But overestimates and underestimates within an order of magnitude do not\n * usually have much noticeable impact. A value of one permits only one thread to modify the map\n * at a time, but since read operations can proceed concurrently, this still yields higher\n * concurrency than full synchronization. Defaults to 4.\n *\n * <p><b>Note:</b> Prior to Guava release 9.0, the default was 16. It is possible the default will\n * change again in the future. If you care about this value, you should always choose it\n * explicitly.\n *\n * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive\n * @throws IllegalStateException if a concurrency level was already set\n */\n", "repo_name": "guava-master/", "id": 6492, "method_signature": "MapMaker concurrencyLevel(int)", "filename": "MapMaker.concurrencyLevel.json"}
{"callee_method_names": [], "method_name": "MapMaker.initialCapacity", "method_implementation": "{\n    checkState(this.initialCapacity == UNSET_INT, \"initial capacity was already set to %s\", this.initialCapacity);\n    checkArgument(initialCapacity >= 0);\n    this.initialCapacity = initialCapacity;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the minimum total size for the internal hash tables. For example, if the initial capacity\n * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each\n * having a hash table of size eight. Providing a large enough estimate at construction time\n * avoids the need for expensive resizing operations later, but setting this value unnecessarily\n * high wastes memory.\n *\n * @throws IllegalArgumentException if {@code initialCapacity} is negative\n * @throws IllegalStateException if an initial capacity was already set\n */\n", "repo_name": "guava-master/", "id": 6491, "method_signature": "MapMaker initialCapacity(int)", "filename": "MapMaker.initialCapacity.json"}
{"callee_method_names": [], "method_name": "MapMaker.keyEquivalence", "method_implementation": "{\n    checkState(keyEquivalence == null, \"key equivalence was already set to %s\", keyEquivalence);\n    keyEquivalence = checkNotNull(equivalence);\n    this.useCustomMap = true;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets a custom {@code Equivalence} strategy for comparing keys.\n *\n * <p>By default, the map uses {@link Equivalence#identity} to determine key equality when {@link\n * #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this is\n * used is in {@link Interners.WeakInterner}.\n */\n", "repo_name": "guava-master/", "id": 6490, "method_signature": "MapMaker keyEquivalence(Equivalence)", "filename": "MapMaker.keyEquivalence.json"}
{"callee_method_names": [], "method_name": "MapMaker.makeMap", "method_implementation": "{\n    if (!useCustomMap) {\n        return new ConcurrentHashMap<>(getInitialCapacity(), 0.75f, getConcurrencyLevel());\n    }\n    return MapMakerInternalMap.create(this);\n}", "repo_id": "5", "comment": "/**\n * Builds a thread-safe map. This method does not alter the state of this {@code MapMaker}\n * instance, so it can be invoked again to create multiple independent maps.\n *\n * <p>The bulk operations {@code putAll}, {@code equals}, and {@code clear} are not guaranteed to\n * be performed atomically on the returned map. Additionally, {@code size} and {@code\n * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent\n * writes.\n *\n * @return a serializable concurrent map having the requested features\n */\n", "repo_name": "guava-master/", "id": 6495, "method_signature": "ConcurrentMap<K,V> makeMap()", "filename": "MapMaker.makeMap.json"}
{"callee_method_names": ["MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "MoreObjects.ToStringHelper.add", "Strength.toString", "MoreObjects.ToStringHelper.add", "Strength.toString", "MoreObjects.ToStringHelper.addValue", "MoreObjects.ToStringHelper.toString"], "method_name": "MapMaker.toString", "method_implementation": "{\n    MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n    if (initialCapacity != UNSET_INT) {\n        s.add(\"initialCapacity\", initialCapacity);\n    }\n    if (concurrencyLevel != UNSET_INT) {\n        s.add(\"concurrencyLevel\", concurrencyLevel);\n    }\n    if (keyStrength != null) {\n        s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n    }\n    if (valueStrength != null) {\n        s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n    }\n    if (keyEquivalence != null) {\n        s.addValue(\"keyEquivalence\");\n    }\n    return s.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation for this MapMaker instance. The exact form of the returned\n * string is not specified.\n */\n", "repo_name": "guava-master/", "id": 6496, "method_signature": "String toString()", "filename": "MapMaker.toString.json"}
{"callee_method_names": [], "method_name": "MapMaker.weakKeys", "method_implementation": "{\n    return setKeyStrength(Strength.WEAK);\n}", "repo_id": "5", "comment": "/**\n * Specifies that each key (not value) stored in the map should be wrapped in a {@link\n * WeakReference} (by default, strong references are used).\n *\n * <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})\n * comparison to determine equality of keys, which is a technical violation of the {@link Map}\n * specification, and may not be what you expect.\n *\n * @throws IllegalStateException if the key strength was already set\n * @see WeakReference\n */\n", "repo_name": "guava-master/", "id": 6493, "method_signature": "MapMaker weakKeys()", "filename": "MapMaker.weakKeys.json"}
{"callee_method_names": [], "method_name": "MapMaker.weakValues", "method_implementation": "{\n    return setValueStrength(Strength.WEAK);\n}", "repo_id": "5", "comment": "/**\n * Specifies that each value (not key) stored in the map should be wrapped in a {@link\n * WeakReference} (by default, strong references are used).\n *\n * <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor\n * candidate for caching.\n *\n * <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})\n * comparison to determine equality of values. This technically violates the specifications of the\n * methods {@link Map#containsValue containsValue}, {@link ConcurrentMap#remove(Object, Object)\n * remove(Object, Object)} and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V,\n * V)}, and may not be what you expect.\n *\n * @throws IllegalStateException if the value strength was already set\n * @see WeakReference\n */\n", "repo_name": "guava-master/", "id": 6494, "method_signature": "MapMaker weakValues()", "filename": "MapMaker.weakValues.json"}
{"callee_method_names": ["E.getKey", "Segment<K, V, E, S>.postReadCleanup"], "method_name": "MapMakerInternalMap.advanceTo", "method_implementation": "{\n    try {\n        K key = entry.getKey();\n        V value = getLiveValue(entry);\n        if (value != null) {\n            nextExternal = new WriteThroughEntry(key, value);\n            return true;\n        } else {\n            // Skip stale entry.\n            return false;\n        }\n    } finally {\n        currentSegment.postReadCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Advances to the given entry. Returns {@code true} if the entry was valid, {@code false} if it\n * should be skipped.\n */\n", "repo_name": "guava-master/", "id": 6270, "method_signature": "boolean advanceTo(E)", "filename": "MapMakerInternalMap.advanceTo.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "E.getKey", "E.getHash", "MapMakerInternalMap<K, V, E, S>.equivalent", "AtomicReferenceArray<E>.set"], "method_name": "MapMakerInternalMap.clearValueForTesting", "method_implementation": "{\n    lock();\n    try {\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n            K entryKey = e.getKey();\n            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key, entryKey)) {\n                WeakValueReference<K, V, E> v = ((WeakValueEntry<K, V, E>) e).getValueReference();\n                if (v == valueReference) {\n                    E newFirst = removeFromChain(first, e);\n                    table.set(index, newFirst);\n                    return true;\n                }\n                return false;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Clears a value that has not yet been set, and thus does not require count to be modified.\n */\n", "repo_name": "guava-master/", "id": 6264, "method_signature": "boolean clearValueForTesting(K, int, WeakValueReference)", "filename": "MapMakerInternalMap.clearValueForTesting.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "MapMakerInternalMap<K, V, E, S>.valueEquivalence"], "method_name": "MapMakerInternalMap.containsValue", "method_implementation": "{\n    try {\n        if (count != 0) {\n            // read-volatile\n            AtomicReferenceArray<E> table = this.table;\n            int length = table.length();\n            for (int i = 0; i < length; ++i) {\n                for (E e = table.get(i); e != null; e = e.getNext()) {\n                    V entryValue = getLiveValue(e);\n                    if (entryValue == null) {\n                        continue;\n                    }\n                    if (map.valueEquivalence().equivalent(value, entryValue)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    } finally {\n        postReadCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * This method is a convenience for testing. Code should call {@link\n * MapMakerInternalMap#containsValue} directly.\n */\n", "repo_name": "guava-master/", "id": 6259, "method_signature": "boolean containsValue(Object)", "filename": "MapMakerInternalMap.containsValue.json"}
{"callee_method_names": ["E.getHash"], "method_name": "MapMakerInternalMap.copyEntry", "method_implementation": "{\n    int hash = original.getHash();\n    return segmentFor(hash).copyEntry(original, newNext);\n}", "repo_id": "5", "comment": "// Guarded By Segment.this\n", "repo_name": "guava-master/", "id": 6254, "method_signature": "E copyEntry(E, E)", "filename": "MapMakerInternalMap.copyEntry.json"}
{"callee_method_names": ["MapMaker.getKeyStrength", "MapMaker.getValueStrength", "MapMaker.getKeyStrength", "MapMaker.getValueStrength", "MapMaker.getKeyStrength", "MapMaker.getValueStrength", "MapMaker.getKeyStrength", "MapMaker.getValueStrength"], "method_name": "MapMakerInternalMap.create", "method_implementation": "{\n    if (builder.getKeyStrength() == Strength.STRONG && builder.getValueStrength() == Strength.STRONG) {\n        return new MapMakerInternalMap<>(builder, StrongKeyStrongValueEntry.Helper.<K, V>instance());\n    }\n    if (builder.getKeyStrength() == Strength.STRONG && builder.getValueStrength() == Strength.WEAK) {\n        return new MapMakerInternalMap<>(builder, StrongKeyWeakValueEntry.Helper.<K, V>instance());\n    }\n    if (builder.getKeyStrength() == Strength.WEAK && builder.getValueStrength() == Strength.STRONG) {\n        return new MapMakerInternalMap<>(builder, WeakKeyStrongValueEntry.Helper.<K, V>instance());\n    }\n    if (builder.getKeyStrength() == Strength.WEAK && builder.getValueStrength() == Strength.WEAK) {\n        return new MapMakerInternalMap<>(builder, WeakKeyWeakValueEntry.Helper.<K, V>instance());\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Returns a fresh {@link MapMakerInternalMap} as specified by the given {@code builder}.\n */\n", "repo_name": "guava-master/", "id": 6251, "method_signature": "MapMakerInternalMap<K,V,? extends InternalEntry<K,V,?>,?> create(MapMaker)", "filename": "MapMakerInternalMap.create.json"}
{"callee_method_names": ["MapMaker.getKeyStrength", "MapMaker.getValueStrength", "MapMaker.getKeyStrength", "MapMaker.getValueStrength", "MapMaker.getValueStrength"], "method_name": "MapMakerInternalMap.createWithDummyValues", "method_implementation": "{\n    if (builder.getKeyStrength() == Strength.STRONG && builder.getValueStrength() == Strength.STRONG) {\n        return new MapMakerInternalMap<>(builder, StrongKeyDummyValueEntry.Helper.<K>instance());\n    }\n    if (builder.getKeyStrength() == Strength.WEAK && builder.getValueStrength() == Strength.STRONG) {\n        return new MapMakerInternalMap<>(builder, WeakKeyDummyValueEntry.Helper.<K>instance());\n    }\n    if (builder.getValueStrength() == Strength.WEAK) {\n        throw new IllegalArgumentException(\"Map cannot have both weak and dummy values\");\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Returns a fresh {@link MapMakerInternalMap} with {@link MapMaker.Dummy} values but otherwise as\n * specified by the given {@code builder}. The returned {@link MapMakerInternalMap} will be\n * optimized to saved memory. Since {@link MapMaker.Dummy} is a singleton, we don't need to store\n * any values at all. Because of this optimization, {@code build.getValueStrength()} must be\n * {@link Strength#STRONG}.\n *\n * <p>This method is intended to only be used by the internal implementation of {@link Interners},\n * since a map of dummy values is the exact use case there.\n */\n", "repo_name": "guava-master/", "id": 6252, "method_signature": "MapMakerInternalMap<K,Dummy,? extends InternalEntry<K,Dummy,?>,?> createWithDummyValues(MapMaker)", "filename": "MapMakerInternalMap.createWithDummyValues.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "E.getHash", "AtomicReferenceArray<E>.set", "E.getNext", "E.getHash", "AtomicReferenceArray<E>.set", "E.getNext", "E.getHash", "AtomicReferenceArray<E>.get", "AtomicReferenceArray<E>.set"], "method_name": "MapMakerInternalMap.expand", "method_implementation": "{\n    AtomicReferenceArray<E> oldTable = table;\n    int oldCapacity = oldTable.length();\n    if (oldCapacity >= MAXIMUM_CAPACITY) {\n        return;\n    }\n    /*\n       * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the\n       * elements from each bin must either stay at same index, or move with a power of two offset.\n       * We eliminate unnecessary node creation by catching cases where old nodes can be reused\n       * because their next fields won't change. Statistically, at the default threshold, only\n       * about one-sixth of them need cloning when a table doubles. The nodes they replace will be\n       * garbage collectable as soon as they are no longer referenced by any reader thread that may\n       * be in the midst of traversing table right now.\n       */\n    int newCount = count;\n    AtomicReferenceArray<E> newTable = newEntryArray(oldCapacity << 1);\n    threshold = newTable.length() * 3 / 4;\n    int newMask = newTable.length() - 1;\n    for (int oldIndex = 0; oldIndex < oldCapacity; ++oldIndex) {\n        // We need to guarantee that any existing reads of old Map can\n        // proceed. So we cannot yet null out each bin.\n        E head = oldTable.get(oldIndex);\n        if (head != null) {\n            E next = head.getNext();\n            int headIndex = head.getHash() & newMask;\n            // Single node on list\n            if (next == null) {\n                newTable.set(headIndex, head);\n            } else {\n                // Reuse the consecutive sequence of nodes with the same target\n                // index from the end of the list. tail points to the first\n                // entry in the reusable list.\n                E tail = head;\n                int tailIndex = headIndex;\n                for (E e = next; e != null; e = e.getNext()) {\n                    int newIndex = e.getHash() & newMask;\n                    if (newIndex != tailIndex) {\n                        // The index changed. We'll need to copy the previous entry.\n                        tailIndex = newIndex;\n                        tail = e;\n                    }\n                }\n                newTable.set(tailIndex, tail);\n                // Clone nodes leading up to the tail.\n                for (E e = head; e != tail; e = e.getNext()) {\n                    int newIndex = e.getHash() & newMask;\n                    E newNext = newTable.get(newIndex);\n                    E newFirst = copyEntry(e, newNext);\n                    if (newFirst != null) {\n                        newTable.set(newIndex, newFirst);\n                    } else {\n                        newCount--;\n                    }\n                }\n            }\n        }\n    }\n    table = newTable;\n    this.count = newCount;\n}", "repo_id": "5", "comment": "/**\n * Expands the table if possible.\n */\n", "repo_name": "guava-master/", "id": 6260, "method_signature": "void expand()", "filename": "MapMakerInternalMap.expand.json"}
{"callee_method_names": [], "method_name": "MapMakerInternalMap.getEntry", "method_implementation": "{\n    if (key == null) {\n        return null;\n    }\n    int hash = hash(key);\n    return segmentFor(hash).getEntry(key, hash);\n}", "repo_id": "5", "comment": "/**\n * Returns the internal entry for the specified key. The entry may be computing or partially\n * collected. Does not impact recency ordering.\n */\n", "repo_name": "guava-master/", "id": 6267, "method_signature": "E getEntry(Object)", "filename": "MapMakerInternalMap.getEntry.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.get", "AtomicReferenceArray<E>.length"], "method_name": "MapMakerInternalMap.getFirst", "method_implementation": "{\n    // read this volatile field only once\n    AtomicReferenceArray<E> table = this.table;\n    return table.get(hash & (table.length() - 1));\n}", "repo_id": "5", "comment": "/**\n * Returns first entry of bin for given hash.\n */\n", "repo_name": "guava-master/", "id": 6258, "method_signature": "E getFirst(int)", "filename": "MapMakerInternalMap.getFirst.json"}
{"callee_method_names": ["E.getKey", "E.getValue"], "method_name": "MapMakerInternalMap.getLiveValue", "method_implementation": "{\n    if (entry.getKey() == null) {\n        tryDrainReferenceQueues();\n        return null;\n    }\n    V value = entry.getValue();\n    if (value == null) {\n        tryDrainReferenceQueues();\n        return null;\n    }\n    return value;\n}", "repo_id": "5", "comment": "/**\n * Gets the value from an entry. Returns {@code null} if the entry is invalid or\n * partially-collected.\n */\n", "repo_name": "guava-master/", "id": 6265, "method_signature": "V getLiveValue(E)", "filename": "MapMakerInternalMap.getLiveValue.json"}
{"callee_method_names": ["E.getNext", "E.getNext"], "method_name": "MapMakerInternalMap.nextInChain", "method_implementation": "{\n    if (nextEntry != null) {\n        for (nextEntry = nextEntry.getNext(); nextEntry != null; nextEntry = nextEntry.getNext()) {\n            if (advanceTo(nextEntry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Finds the next entry in the current chain. Returns {@code true} if an entry was found.\n */\n", "repo_name": "guava-master/", "id": 6268, "method_signature": "boolean nextInChain()", "filename": "MapMakerInternalMap.nextInChain.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.get"], "method_name": "MapMakerInternalMap.nextInTable", "method_implementation": "{\n    while (nextTableIndex >= 0) {\n        if ((nextEntry = currentTable.get(nextTableIndex--)) != null) {\n            if (advanceTo(nextEntry) || nextInChain()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Finds the next entry in the current table. Returns {@code true} if an entry was found.\n */\n", "repo_name": "guava-master/", "id": 6269, "method_signature": "boolean nextInTable()", "filename": "MapMakerInternalMap.nextInTable.json"}
{"callee_method_names": ["AtomicInteger.incrementAndGet"], "method_name": "MapMakerInternalMap.postReadCleanup", "method_implementation": "{\n    if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {\n        runCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs routine cleanup following a read. Normally cleanup happens during writes, or from\n * the cleanupExecutor. If cleanup is not observed after a sufficient number of reads, try\n * cleaning up from the read thread.\n */\n", "repo_name": "guava-master/", "id": 6266, "method_signature": "void postReadCleanup()", "filename": "MapMakerInternalMap.postReadCleanup.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "AtomicReferenceArray<E>.set"], "method_name": "MapMakerInternalMap.reclaimKey", "method_implementation": "{\n    lock();\n    try {\n        int newCount = count - 1;\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n            if (e == entry) {\n                ++modCount;\n                E newFirst = removeFromChain(first, e);\n                newCount = this.count - 1;\n                table.set(index, newFirst);\n                // write-volatile\n                this.count = newCount;\n                return true;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes an entry whose key has been garbage collected.\n */\n", "repo_name": "guava-master/", "id": 6262, "method_signature": "boolean reclaimKey(E, int)", "filename": "MapMakerInternalMap.reclaimKey.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "E.getKey", "E.getHash", "MapMakerInternalMap<K, V, E, S>.equivalent", "AtomicReferenceArray<E>.set"], "method_name": "MapMakerInternalMap.reclaimValue", "method_implementation": "{\n    lock();\n    try {\n        int newCount = this.count - 1;\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n            K entryKey = e.getKey();\n            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key, entryKey)) {\n                WeakValueReference<K, V, E> v = ((WeakValueEntry<K, V, E>) e).getValueReference();\n                if (v == valueReference) {\n                    ++modCount;\n                    E newFirst = removeFromChain(first, e);\n                    newCount = this.count - 1;\n                    table.set(index, newFirst);\n                    // write-volatile\n                    this.count = newCount;\n                    return true;\n                }\n                return false;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes an entry whose value has been garbage collected.\n */\n", "repo_name": "guava-master/", "id": 6263, "method_signature": "boolean reclaimValue(K, int, WeakValueReference)", "filename": "MapMakerInternalMap.reclaimValue.json"}
{"callee_method_names": [], "method_name": "MapMakerInternalMap.rehash", "method_implementation": "{\n    // Spread bits to regularize both segment and index locations,\n    // using variant of single-word Wang/Jenkins hash.\n    // TODO(kevinb): use Hashing/move this to Hashing?\n    h += (h << 15) ^ 0xffffcd7d;\n    h ^= (h >>> 10);\n    h += (h << 3);\n    h ^= (h >>> 6);\n    h += (h << 2) + (h << 14);\n    return h ^ (h >>> 16);\n}", "repo_id": "5", "comment": "/**\n * Applies a supplemental hash function to a given hash code, which defends against poor quality\n * hash functions. This is critical when the concurrent hash map uses power-of-two length hash\n * tables, that otherwise encounter collisions for hash codes that do not differ in lower or upper\n * bits.\n *\n * @param h hash code\n */\n", "repo_name": "guava-master/", "id": 6253, "method_signature": "int rehash(int)", "filename": "MapMakerInternalMap.rehash.json"}
{"callee_method_names": ["E.getNext", "E.getNext"], "method_name": "MapMakerInternalMap.removeFromChain", "method_implementation": "{\n    int newCount = count;\n    E newFirst = entry.getNext();\n    for (E e = first; e != entry; e = e.getNext()) {\n        E next = copyEntry(e, newFirst);\n        if (next != null) {\n            newFirst = next;\n        } else {\n            newCount--;\n        }\n    }\n    this.count = newCount;\n    return newFirst;\n}", "repo_id": "5", "comment": "/**\n * Removes an entry from within a table. All entries following the removed node can stay, but\n * all preceding ones need to be cloned.\n *\n * <p>This method does not decrement count for the removed entry, but does decrement count for\n * all partially collected entries which are skipped. As such callers which are modifying count\n * must re-read it after calling removeFromChain.\n *\n * @param first the first entry of the table\n * @param entry the entry being removed from the table\n * @return the new first entry for the table\n */\n", "repo_name": "guava-master/", "id": 6261, "method_signature": "E removeFromChain(E, E)", "filename": "MapMakerInternalMap.removeFromChain.json"}
{"callee_method_names": [], "method_name": "MapMakerInternalMap.setWeakValueReferenceForTesting", "method_implementation": "{\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Unsafely sets the weak value reference inside the given {@code entry} to be the given {@code\n * valueReference}\n */\n", "repo_name": "guava-master/", "id": 6256, "method_signature": "void setWeakValueReferenceForTesting(InternalEntry, WeakValueReference)", "filename": "MapMakerInternalMap.setWeakValueReferenceForTesting.json"}
{"callee_method_names": [], "method_name": "MapMakerInternalMap.tryDrainReferenceQueues", "method_implementation": "{\n    if (tryLock()) {\n        try {\n            maybeDrainReferenceQueues();\n        } finally {\n            unlock();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Cleanup collected entries when the lock is available.\n */\n", "repo_name": "guava-master/", "id": 6257, "method_signature": "void tryDrainReferenceQueues()", "filename": "MapMakerInternalMap.tryDrainReferenceQueues.json"}
{"callee_method_ids": [6491], "callee_method_names": ["MapMaker.initialCapacity"], "method_name": "MapMakerTest.xtestInitialCapacity_setTwice", "method_implementation": "{\n    MapMaker maker = new MapMaker().initialCapacity(16);\n    try {\n        // even to the same value is not allowed\n        maker.initialCapacity(16);\n        fail();\n    } catch (IllegalStateException expected) {\n    }\n}", "repo_id": "5", "comment": "// TODO(cpovirk): enable when ready (apparently after a change to our GWT emulation)\n", "repo_name": "guava-master/", "id": 4000, "method_signature": "void xtestInitialCapacity_setTwice()", "filename": "MapMakerTest.xtestInitialCapacity_setTwice.json"}
{"callee_method_names": ["Map<String, Map<Integer, Character>>.keySet", "Map<String, Map<Integer, Character>>.size", "Map<String, Map<Integer, Character>>.get", "Map<String, Map<Integer, Character>>.remove", "Map<String, Map<Integer, Character>>.containsKey", "Map<String, Map<Integer, Character>>.size", "Map<String, Map<Integer, Character>>.remove"], "method_name": "MapMapTests.testRemove", "method_implementation": "{\n    final Map<String, Map<Integer, Character>> map;\n    final String keyToRemove;\n    try {\n        map = makePopulatedMap();\n    } catch (UnsupportedOperationException e) {\n        return;\n    }\n    keyToRemove = map.keySet().iterator().next();\n    if (supportsRemove) {\n        int initialSize = map.size();\n        map.get(keyToRemove);\n        map.remove(keyToRemove);\n        // This line doesn't hold - see the Javadoc comments above.\n        // assertEquals(expectedValue, oldValue);\n        assertFalse(map.containsKey(keyToRemove));\n        assertEquals(initialSize - 1, map.size());\n    } else {\n        try {\n            map.remove(keyToRemove);\n            fail(\"Expected UnsupportedOperationException.\");\n        } catch (UnsupportedOperationException expected) {\n        }\n    }\n    assertInvariants(map);\n}", "repo_id": "5", "comment": "/**\n * The version of this test supplied by {@link MapInterfaceTest} fails for this particular map\n * implementation, because {@code map.get()} returns a view collection that changes in the\n * course of a call to {@code remove()}. Thus, the expectation doesn't hold that {@code\n * map.remove(x)} returns the same value which {@code map.get(x)} did immediately beforehand.\n */\n", "repo_name": "guava-master/", "id": 3970, "method_signature": "void testRemove()", "filename": "MapMapTests.testRemove.json"}
{"callee_method_ids": [5001], "callee_method_names": ["Splitter.split", "Splitter.splittingIterator", "Iterator<String>.hasNext", "Iterator<String>.next", "Map<String, String>.containsKey", "Iterator<String>.hasNext", "Iterator<String>.next", "Map<String, String>.put", "Iterator<String>.hasNext"], "method_name": "MapSplitter.split", "method_implementation": "{\n    Map<String, String> map = new LinkedHashMap<>();\n    for (String entry : outerSplitter.split(sequence)) {\n        Iterator<String> entryFields = entrySplitter.splittingIterator(entry);\n        checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n        String key = entryFields.next();\n        checkArgument(!map.containsKey(key), \"Duplicate key [%s] found.\", key);\n        checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n        String value = entryFields.next();\n        map.put(key, value);\n        checkArgument(!entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n    }\n    return Collections.unmodifiableMap(map);\n}", "repo_id": "5", "comment": "/**\n * Splits {@code sequence} into substrings, splits each substring into an entry, and returns an\n * unmodifiable map with each of the entries. For example, {@code\n * Splitter.on(';').trimResults().withKeyValueSeparator(\"=>\").split(\"a=>b ; c=>b\")} will return\n * a mapping from {@code \"a\"} to {@code \"b\"} and {@code \"c\"} to {@code \"b\"}.\n *\n * <p>The returned map preserves the order of the entries from {@code sequence}.\n *\n * @throws IllegalArgumentException if the specified sequence does not split into valid map\n *     entries, or if there are duplicate keys\n */\n", "repo_name": "guava-master/", "id": 5002, "method_signature": "Map<String,String> split(CharSequence)", "filename": "MapSplitter.split.json"}
{"callee_method_names": ["AtomicBoolean.getAndSet", "AtomicBoolean.getAndSet"], "method_name": "MapTestSuiteBuilderTests.testsForSetUpTearDown", "method_implementation": "{\n    final AtomicBoolean setUpRan = new AtomicBoolean();\n    Runnable setUp = new Runnable() {\n\n        @Override\n        public void run() {\n            assertFalse(\"previous tearDown should have run before setUp\", setUpRan.getAndSet(true));\n        }\n    };\n    Runnable tearDown = new Runnable() {\n\n        @Override\n        public void run() {\n            assertTrue(\"setUp should have run\", setUpRan.getAndSet(false));\n        }\n    };\n    return MapTestSuiteBuilder.using(new CheckSetUpHashMapGenerator(setUpRan)).named(\"setUpTearDown\").withFeatures(MapFeature.GENERAL_PURPOSE, MapFeature.ALLOWS_NULL_KEYS, MapFeature.ALLOWS_NULL_VALUES, CollectionFeature.SERIALIZABLE, CollectionFeature.SUPPORTS_ITERATOR_REMOVE, CollectionSize.ANY).withSetUp(setUp).withTearDown(tearDown).createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Verifies that {@code setUp} and {@code tearDown} are called in all map test cases.\n */\n", "repo_name": "guava-master/", "id": 4249, "method_signature": "Test testsForSetUpTearDown()", "filename": "MapTestSuiteBuilderTests.testsForSetUpTearDown.json"}
{"callee_method_names": [], "method_name": "MapViewOfValuesAsSingletonSets.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6047, "method_signature": "Object writeReplace()", "filename": "MapViewOfValuesAsSingletonSets.writeReplace.json"}
{"callee_method_names": [], "method_name": "Maps.asEntryToEntryFunction", "method_implementation": "{\n    checkNotNull(transformer);\n    return new Function<Entry<K, V1>, Entry<K, V2>>() {\n\n        @Override\n        public Entry<K, V2> apply(final Entry<K, V1> entry) {\n            return transformEntry(transformer, entry);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Views an entry transformer as a function from entries to entries.\n */\n", "repo_name": "guava-master/", "id": 6567, "method_signature": "Function<Entry<K,V1>,Entry<K,V2>> asEntryToEntryFunction(EntryTransformer)", "filename": "Maps.asEntryToEntryFunction.json"}
{"callee_method_names": ["EntryTransformer<? super K,? super V1,V2>.transformEntry", "Entry<? extends K,? extends V>.getKey", "Entry<? extends K,? extends V>.getValue"], "method_name": "Maps.asEntryToValueFunction", "method_implementation": "{\n    checkNotNull(transformer);\n    return new Function<Entry<K, V1>, V2>() {\n\n        @Override\n        @ParametricNullness\n        public V2 apply(Entry<K, V1> entry) {\n            return transformer.transformEntry(entry.getKey(), entry.getValue());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Views an entry transformer as a function from {@code Entry} to values.\n */\n", "repo_name": "guava-master/", "id": 6565, "method_signature": "Function<Entry<K,V1>,V2> asEntryToValueFunction(EntryTransformer)", "filename": "Maps.asEntryToValueFunction.json"}
{"callee_method_names": ["Function<? super V1,V2>.apply"], "method_name": "Maps.asEntryTransformer", "method_implementation": "{\n    checkNotNull(function);\n    return new EntryTransformer<K, V1, V2>() {\n\n        @Override\n        @ParametricNullness\n        public V2 transformEntry(@ParametricNullness K key, @ParametricNullness V1 value) {\n            return function.apply(value);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Views a function as an entry transformer that ignores the entry key.\n */\n", "repo_name": "guava-master/", "id": 6564, "method_signature": "EntryTransformer<K,V1,V2> asEntryTransformer(Function)", "filename": "Maps.asEntryTransformer.json"}
{"callee_method_names": [], "method_name": "Maps.asMap", "method_implementation": "{\n    return new NavigableAsMapView<>(set, function);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the navigable set as a map, mapping keys from the set according to the\n * specified function.\n *\n * <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping\n * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code\n * entrySet} views of the returned map iterate in the same order as the backing set.\n *\n * <p>Modifications to the backing set are read through to the returned map. The returned map\n * supports removal operations if the backing set does. Removal operations write through to the\n * backing set. The returned map does not support put operations.\n *\n * <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the\n * set does not contain {@code null}, because the view cannot stop {@code null} from being added\n * to the set.\n *\n * <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},\n * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for\n * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when\n * calling methods on the resulting map view.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6551, "method_signature": "NavigableMap<K,V> asMap(NavigableSet, Function)", "filename": "Maps.asMap.json"}
{"callee_method_names": [], "method_name": "Maps.capacity", "method_implementation": "{\n    if (expectedSize < 3) {\n        checkNonnegative(expectedSize, \"expectedSize\");\n        return expectedSize + 1;\n    }\n    if (expectedSize < Ints.MAX_POWER_OF_TWO) {\n        // This seems to be consistent across JDKs. The capacity argument to HashMap and LinkedHashMap\n        // ends up being used to compute a \"threshold\" size, beyond which the internal table\n        // will be resized. That threshold is ceilingPowerOfTwo(capacity*loadFactor), where\n        // loadFactor is 0.75 by default. So with the calculation here we ensure that the\n        // threshold is equal to ceilingPowerOfTwo(expectedSize). There is a separate code\n        // path when the first operation on the new map is putAll(otherMap). There, prior to\n        // https://github.com/openjdk/jdk/commit/3e393047e12147a81e2899784b943923fc34da8e, a bug\n        // meant that sometimes a too-large threshold is calculated. However, this new threshold is\n        // independent of the initial capacity, except that it won't be lower than the threshold\n        // computed from that capacity. Because the internal table is only allocated on the first\n        // write, we won't see copying because of the new threshold. So it is always OK to use the\n        // calculation here.\n        return (int) Math.ceil(expectedSize / 0.75);\n    }\n    // any large value\n    return Integer.MAX_VALUE;\n}", "repo_id": "5", "comment": "/**\n * Returns a capacity that is sufficient to keep the map from being resized as long as it grows no\n * larger than expectedSize and the load factor is \u2265 its default (0.75).\n */\n", "repo_name": "guava-master/", "id": 6545, "method_signature": "int capacity(int)", "filename": "Maps.capacity.json"}
{"callee_method_names": [], "method_name": "Maps.computeIfPresent", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/*\n     * TODO(cpovirk): Uncomment the @NonNull annotations below once our JDK stubs and J2KT\n     * emulations include them.\n     */\n", "repo_name": "guava-master/", "id": 3245, "method_signature": "V computeIfPresent(K, BiFunction)", "filename": "Maps.computeIfPresent.json"}
{"callee_method_names": ["Collection<Entry<K,V>>.contains"], "method_name": "Maps.containsEntryImpl", "method_implementation": "{\n    if (!(o instanceof Entry)) {\n        return false;\n    }\n    return c.contains(unmodifiableEntry((Entry<?, ?>) o));\n}", "repo_id": "5", "comment": "/**\n * Implements {@code Collection.contains} safely for forwarding collections of map entries. If\n * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to\n * protect against a possible nefarious equals method.\n *\n * <p>Note that {@code c} is the backing (delegate) collection, rather than the forwarding\n * collection.\n *\n * @param c the delegate (unwrapped) collection of map entries\n * @param o the object that might be contained in {@code c}\n * @return {@code true} if {@code c} contains {@code o}\n */\n", "repo_name": "guava-master/", "id": 6590, "method_signature": "boolean containsEntryImpl(Collection, Object)", "filename": "Maps.containsEntryImpl.json"}
{"callee_method_names": ["BiMap<K,V>.containsKey", "Predicate<? super K>.apply"], "method_name": "Maps.containsKey", "method_implementation": "{\n    return unfiltered.containsKey(key) && keyPredicate.apply((K) key);\n}", "repo_id": "5", "comment": "// that key is a K.\n", "repo_name": "guava-master/", "id": 6584, "method_signature": "boolean containsKey(Object)", "filename": "Maps.containsKey.json"}
{"callee_method_names": ["SortedMap<K,? extends V>.comparator", "SortedMap<K, V>.putAll"], "method_name": "Maps.difference", "method_implementation": "{\n    checkNotNull(left);\n    checkNotNull(right);\n    Comparator<? super K> comparator = orNaturalOrder(left.comparator());\n    SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);\n    SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);\n    // will whittle it down\n    onlyOnRight.putAll(right);\n    SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);\n    SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);\n    doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);\n    return new SortedMapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n}", "repo_id": "5", "comment": "/**\n * Computes the difference between two sorted maps, using the comparator of the left map, or\n * {@code Ordering.natural()} if the left map uses the natural ordering of its elements. This\n * difference is an immutable snapshot of the state of the maps at the time this method is called.\n * It will never change, even if the maps change at a later time.\n *\n * <p>Since this method uses {@code TreeMap} instances internally, the keys of the right map must\n * all compare as distinct according to the comparator of the left map.\n *\n * <p><b>Note:</b>If you only need to know whether two sorted maps have the same mappings, call\n * {@code left.equals(right)} instead of this method.\n *\n * @param left the map to treat as the \"left\" map for purposes of comparison\n * @param right the map to treat as the \"right\" map for purposes of comparison\n * @return the difference between the two maps\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 6549, "method_signature": "SortedMapDifference<K,V> difference(SortedMap, Map)", "filename": "Maps.difference.json"}
{"callee_method_names": ["Map<?,?>.entrySet", "Map<?, ?>.entrySet"], "method_name": "Maps.equalsImpl", "method_implementation": "{\n    if (map == object) {\n        return true;\n    } else if (object instanceof Map) {\n        Map<?, ?> o = (Map<?, ?>) object;\n        return map.entrySet().equals(o.entrySet());\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Map#equals}.\n */\n", "repo_name": "guava-master/", "id": 6592, "method_signature": "boolean equalsImpl(Map, Object)", "filename": "Maps.equalsImpl.json"}
{"callee_method_names": [], "method_name": "Maps.filterEntries", "method_implementation": "{\n    checkNotNull(unfiltered);\n    checkNotNull(entryPredicate);\n    return (unfiltered instanceof FilteredEntryBiMap) ? filterFiltered((FilteredEntryBiMap<K, V>) unfiltered, entryPredicate) : new FilteredEntryBiMap<K, V>(unfiltered, entryPredicate);\n}", "repo_id": "5", "comment": "/**\n * Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n * returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n *\n * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n * and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's\n * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n * IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue} method\n * that throws an {@link IllegalArgumentException} when the existing key and the provided value\n * don't satisfy the predicate.\n *\n * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n * bimap.\n *\n * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key/value\n * mapping in the underlying bimap and determine which satisfy the filter. When a live view is\n * <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.\n *\n * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n * at {@link Predicate#apply}.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6579, "method_signature": "BiMap<K,V> filterEntries(BiMap, Predicate)", "filename": "Maps.filterEntries.json"}
{"callee_method_names": ["FilteredEntryBiMap<K,V>.unfiltered"], "method_name": "Maps.filterFiltered", "method_implementation": "{\n    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n    return new FilteredEntryBiMap<>(map.unfiltered(), predicate);\n}", "repo_id": "5", "comment": "/**\n * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n * map.\n */\n", "repo_name": "guava-master/", "id": 6583, "method_signature": "BiMap<K,V> filterFiltered(FilteredEntryBiMap, Predicate)", "filename": "Maps.filterFiltered.json"}
{"callee_method_names": [], "method_name": "Maps.filterKeys", "method_implementation": "{\n    checkNotNull(keyPredicate);\n    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n}", "repo_id": "5", "comment": "/**\n * Returns a bimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate.\n * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n *\n * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n * and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code put()},\n * {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n *\n * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n * bimap.\n *\n * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key in\n * the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i>\n * needed, it may be faster to copy the filtered bimap and use the copy.\n *\n * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n * at {@link Predicate#apply}.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6573, "method_signature": "BiMap<K,V> filterKeys(BiMap, Predicate)", "filename": "Maps.filterKeys.json"}
{"callee_method_names": [], "method_name": "Maps.filterValues", "method_implementation": "{\n    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n}", "repo_id": "5", "comment": "/**\n * Returns a navigable map containing the mappings in {@code unfiltered} whose values satisfy a\n * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n * other.\n *\n * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n * iterators that don't support {@code remove()}, but all other methods are supported by the map\n * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},\n * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.\n *\n * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n * or its views, only mappings whose values satisfy the filter will be removed from the underlying\n * map.\n *\n * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n * mapping in the underlying map and determine which satisfy the filter. When a live view is\n * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n *\n * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6575, "method_signature": "NavigableMap<K,V> filterValues(NavigableMap, Predicate)", "filename": "Maps.filterValues.json"}
{"callee_method_names": ["Properties.propertyNames", "E.hasMoreElements", "E.nextElement", "ImmutableMap.Builder<String, String>.put", "Properties.getProperty", "ImmutableMap.Builder<String, String>.buildOrThrow"], "method_name": "Maps.fromProperties", "method_implementation": "{\n    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {\n        /*\n       * requireNonNull is safe because propertyNames contains only non-null elements.\n       *\n       * Accordingly, we have it annotated as returning `Enumeration<? extends Object>` in our\n       * prototype checker's JDK. However, the checker still sees the return type as plain\n       * `Enumeration<?>`, probably because of one of the following two bugs (and maybe those two\n       * bugs are themselves just symptoms of the same underlying problem):\n       *\n       * https://github.com/typetools/checker-framework/issues/3030\n       *\n       * https://github.com/typetools/checker-framework/issues/3236\n       */\n        String key = (String) requireNonNull(e.nextElement());\n        /*\n       * requireNonNull is safe because the key came from propertyNames...\n       *\n       * ...except that it's possible for users to insert a string key with a non-string value, and\n       * in that case, getProperty *will* return null.\n       *\n       * TODO(b/192002623): Handle that case: Either:\n       *\n       * - Skip non-string keys and values entirely, as proposed in the linked bug.\n       *\n       * - Throw ClassCastException instead of NullPointerException, as documented in the current\n       *   Javadoc. (Note that we can't necessarily \"just\" change our call to `getProperty` to `get`\n       *   because `get` does not consult the default properties.)\n       */\n        builder.put(key, requireNonNull(properties.getProperty(key)));\n    }\n    return builder.buildOrThrow();\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code ImmutableMap<String, String>} from a {@code Properties} instance. Properties\n * normally derive from {@code Map<Object, Object>}, but they typically contain strings, which is\n * awkward. This method lets you get a plain-old-{@code Map} out of a {@code Properties}.\n *\n * @param properties a {@code Properties} object to be converted\n * @return an immutable map containing all the entries in {@code properties}\n * @throws ClassCastException if any key in {@code properties} is not a {@code String}\n * @throws NullPointerException if any key or value in {@code properties} is null\n */\n", "repo_name": "guava-master/", "id": 6555, "method_signature": "ImmutableMap<String,String> fromProperties(Properties)", "filename": "Maps.fromProperties.json"}
{"callee_method_names": ["NavigableMap<K,V1>.get", "NavigableMap<K,V1>.containsKey", "EntryTransformer<? super K,? super V1,V2>.transformEntry"], "method_name": "Maps.get", "method_implementation": "{\n    V1 value = fromMap.get(key);\n    if (value != null || fromMap.containsKey(key)) {\n        // The cast is safe because of the containsKey check.\n        return transformer.transformEntry((K) key, uncheckedCastNullableTToT(value));\n    }\n    return null;\n}", "repo_id": "5", "comment": "// safe as long as the user followed the <b>Warning</b> in the javadoc\n", "repo_name": "guava-master/", "id": 6568, "method_signature": "V2 get(Object)", "filename": "Maps.get.json"}
{"callee_method_names": ["NavigableMap<K,V1>.get", "NavigableMap<K,V1>.containsKey", "EntryTransformer<? super K,? super V1,V2>.transformEntry"], "method_name": "Maps.getOrDefault", "method_implementation": "{\n    V1 value = fromMap.get(key);\n    if (value != null || fromMap.containsKey(key)) {\n        // The cast is safe because of the containsKey check.\n        return transformer.transformEntry((K) key, uncheckedCastNullableTToT(value));\n    }\n    return defaultValue;\n}", "repo_id": "5", "comment": "// safe as long as the user followed the <b>Warning</b> in the javadoc\n", "repo_name": "guava-master/", "id": 3227, "method_signature": "V2 getOrDefault(Object, V2)", "filename": "Maps.getOrDefault.json"}
{"callee_method_names": [], "method_name": "Maps.immutableEntry", "method_implementation": "{\n    return new ImmutableEntry<>(key, value);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map entry with the specified key and value. The {@link Entry#setValue}\n * operation throws an {@link UnsupportedOperationException}.\n *\n * <p>The returned entry is serializable.\n *\n * <p><b>Java 9 users:</b> consider using {@code java.util.Map.entry(key, value)} if the key and\n * value are non-null and the entry does not need to be serializable.\n *\n * @param key the key to be associated with the returned entry\n * @param value the value to be associated with the returned entry\n */\n", "repo_name": "guava-master/", "id": 6556, "method_signature": "Entry<K,V> immutableEntry(K, V)", "filename": "Maps.immutableEntry.json"}
{"callee_method_names": ["Map<K,? extends V>.entrySet", "Iterator<? extends Entry<K, ? extends V>>.hasNext", "Iterator<? extends Entry<K, ? extends V>>.next", "Entry<K, ? extends V>.getKey", "Entry<K, ? extends V>.getValue", "Iterator<? extends Entry<K, ? extends V>>.hasNext", "Iterator<? extends Entry<K, ? extends V>>.next", "Entry<K, ? extends V>.getKey", "Entry<K, ? extends V>.getValue", "EnumMap<K, V>.put"], "method_name": "Maps.immutableEnumMap", "method_implementation": "{\n    if (map instanceof ImmutableEnumMap) {\n        // safe covariant cast\n        @SuppressWarnings(\"unchecked\")\n        ImmutableEnumMap<K, V> result = (ImmutableEnumMap<K, V>) map;\n        return result;\n    }\n    Iterator<? extends Entry<K, ? extends V>> entryItr = map.entrySet().iterator();\n    if (!entryItr.hasNext()) {\n        return ImmutableMap.of();\n    }\n    Entry<K, ? extends V> entry1 = entryItr.next();\n    K key1 = entry1.getKey();\n    V value1 = entry1.getValue();\n    checkEntryNotNull(key1, value1);\n    // Do something that works for j2cl, where we can't call getDeclaredClass():\n    EnumMap<K, V> enumMap = new EnumMap<>(singletonMap(key1, value1));\n    while (entryItr.hasNext()) {\n        Entry<K, ? extends V> entry = entryItr.next();\n        K key = entry.getKey();\n        V value = entry.getValue();\n        checkEntryNotNull(key, value);\n        enumMap.put(key, value);\n    }\n    return ImmutableEnumMap.asImmutable(enumMap);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map instance containing the given entries. Internally, the returned map\n * will be backed by an {@link EnumMap}.\n *\n * <p>The iteration order of the returned map follows the enum's iteration order, not the order in\n * which the elements appear in the given map.\n *\n * @param map the map to make an immutable copy of\n * @return an immutable map containing those entries\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6542, "method_signature": "ImmutableMap<K,V> immutableEnumMap(Map)", "filename": "Maps.immutableEnumMap.json"}
{"callee_method_names": ["Collection<E>.size", "ImmutableMap.Builder<E, Integer>.put", "ImmutableMap.Builder<E, Integer>.buildOrThrow"], "method_name": "Maps.indexMap", "method_implementation": "{\n    ImmutableMap.Builder<E, Integer> builder = new ImmutableMap.Builder<>(list.size());\n    int i = 0;\n    for (E e : list) {\n        builder.put(e, i++);\n    }\n    return builder.buildOrThrow();\n}", "repo_id": "5", "comment": "/**\n * Returns a map from the ith element of list to i.\n */\n", "repo_name": "guava-master/", "id": 6595, "method_signature": "ImmutableMap<E,Integer> indexMap(Collection)", "filename": "Maps.indexMap.json"}
{"callee_method_names": [], "method_name": "Maps.newTreeMap", "method_implementation": "{\n    // Ideally, the extra type parameter \"C\" shouldn't be necessary. It is a\n    // work-around of a compiler type inference quirk that prevents the\n    // following code from being compiled:\n    // Comparator<Class<?>> comparator = null;\n    // Map<Class<? extends Throwable>, String> map = newTreeMap(comparator);\n    return new TreeMap<>(comparator);\n}", "repo_id": "5", "comment": "/**\n * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given comparator.\n *\n * <p><b>Note:</b> if mutability is not required, use {@code\n * ImmutableSortedMap.orderedBy(comparator).build()} instead.\n *\n * <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,\n * use the {@code TreeMap} constructor directly, taking advantage of <a\n * href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n *\n * @param comparator the comparator to sort the keys with\n * @return a new, empty {@code TreeMap}\n */\n", "repo_name": "guava-master/", "id": 6546, "method_signature": "TreeMap<K,V> newTreeMap(Comparator)", "filename": "Maps.newTreeMap.json"}
{"callee_method_names": [], "method_name": "Maps.orNaturalOrder", "method_implementation": "{\n    if (comparator != null) {\n        // can't use ? : because of javac bug 5080917\n        return comparator;\n    }\n    return (Comparator<E>) Ordering.natural();\n}", "repo_id": "5", "comment": "/**\n * Returns the specified comparator if not null; otherwise returns {@code Ordering.natural()}.\n * This method is an abomination of generics; the only purpose of this method is to contain the\n * ugly type-casting in one place.\n */\n", "repo_name": "guava-master/", "id": 6550, "method_signature": "Comparator<? super E> orNaturalOrder(Comparator)", "filename": "Maps.orNaturalOrder.json"}
{"callee_method_names": ["Map<? extends K,? extends V>.entrySet", "Map<K,V>.put", "Entry<K,V1>.getKey", "Entry<K,V1>.getValue"], "method_name": "Maps.putAllImpl", "method_implementation": "{\n    for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n        self.put(entry.getKey(), entry.getValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Map#putAll}.\n */\n", "repo_name": "guava-master/", "id": 6594, "method_signature": "void putAllImpl(Map, Map)", "filename": "Maps.putAllImpl.json"}
{"callee_method_names": ["NavigableMap<K,V1>.containsKey", "EntryTransformer<? super K,? super V1,V2>.transformEntry", "NavigableMap<K,V1>.remove"], "method_name": "Maps.remove", "method_implementation": "{\n    return fromMap.containsKey(key) ? // The cast is safe because of the containsKey check.\n    transformer.transformEntry((K) key, uncheckedCastNullableTToT(fromMap.remove(key))) : null;\n}", "repo_id": "5", "comment": "// safe as long as the user followed the <b>Warning</b> in the javadoc\n", "repo_name": "guava-master/", "id": 6569, "method_signature": "V2 remove(Object)", "filename": "Maps.remove.json"}
{"callee_method_names": ["Collection<Entry<K,V>>.remove"], "method_name": "Maps.removeEntryImpl", "method_implementation": "{\n    if (!(o instanceof Entry)) {\n        return false;\n    }\n    return c.remove(unmodifiableEntry((Entry<?, ?>) o));\n}", "repo_id": "5", "comment": "/**\n * Implements {@code Collection.remove} safely for forwarding collections of map entries. If\n * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to\n * protect against a possible nefarious equals method.\n *\n * <p>Note that {@code c} is backing (delegate) collection, rather than the forwarding collection.\n *\n * @param c the delegate (unwrapped) collection of map entries\n * @param o the object to remove from {@code c}\n * @return {@code true} if {@code c} was changed\n */\n", "repo_name": "guava-master/", "id": 6591, "method_signature": "boolean removeEntryImpl(Collection, Object)", "filename": "Maps.removeEntryImpl.json"}
{"callee_method_names": ["Map<?,?>.containsKey"], "method_name": "Maps.safeContainsKey", "method_implementation": "{\n    checkNotNull(map);\n    try {\n        return map.containsKey(key);\n    } catch (ClassCastException | NullPointerException e) {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code ClassCastException} and\n * {@code NullPointerException}.\n */\n", "repo_name": "guava-master/", "id": 6588, "method_signature": "boolean safeContainsKey(Map, Object)", "filename": "Maps.safeContainsKey.json"}
{"callee_method_names": ["Map<?,V>.get"], "method_name": "Maps.safeGet", "method_implementation": "{\n    checkNotNull(map);\n    try {\n        return map.get(key);\n    } catch (ClassCastException | NullPointerException e) {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Delegates to {@link Map#get}. Returns {@code null} on {@code ClassCastException} and {@code\n * NullPointerException}.\n */\n", "repo_name": "guava-master/", "id": 6587, "method_signature": "V safeGet(Map, Object)", "filename": "Maps.safeGet.json"}
{"callee_method_names": ["Map<?,V>.remove"], "method_name": "Maps.safeRemove", "method_implementation": "{\n    checkNotNull(map);\n    try {\n        return map.remove(key);\n    } catch (ClassCastException | NullPointerException e) {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Delegates to {@link Map#remove}. Returns {@code null} on {@code ClassCastException} and {@code\n * NullPointerException}.\n */\n", "repo_name": "guava-master/", "id": 6589, "method_signature": "V safeRemove(Map, Object)", "filename": "Maps.safeRemove.json"}
{"callee_method_names": ["NavigableMap<K,V>.comparator", "NavigableMap<K,V>.comparator", "Range<K>.hasLowerBound", "Range<K>.hasUpperBound", "NavigableMap<K,V>.comparator", "Range<K>.lowerEndpoint", "Range<K>.upperEndpoint", "Range<K>.hasLowerBound", "Range<K>.hasUpperBound", "NavigableMap<K,V>.subMap", "Range<K>.lowerEndpoint", "Range<K>.lowerBoundType", "Range<K>.upperEndpoint", "Range<K>.upperBoundType", "Range<K>.hasLowerBound", "NavigableMap<K,V>.tailMap", "Range<K>.lowerEndpoint", "Range<K>.lowerBoundType", "Range<K>.hasUpperBound", "NavigableMap<K,V>.headMap", "Range<K>.upperEndpoint", "Range<K>.upperBoundType"], "method_name": "Maps.subMap", "method_implementation": "{\n    if (map.comparator() != null && map.comparator() != Ordering.natural() && range.hasLowerBound() && range.hasUpperBound()) {\n        checkArgument(map.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) <= 0, \"map is using a custom comparator which is inconsistent with the natural ordering.\");\n    }\n    if (range.hasLowerBound() && range.hasUpperBound()) {\n        return map.subMap(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED, range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);\n    } else if (range.hasLowerBound()) {\n        return map.tailMap(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);\n    } else if (range.hasUpperBound()) {\n        return map.headMap(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);\n    }\n    return checkNotNull(map);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the portion of {@code map} whose keys are contained by {@code range}.\n *\n * <p>This method delegates to the appropriate methods of {@link NavigableMap} (namely {@link\n * NavigableMap#subMap(Object, boolean, Object, boolean) subMap()}, {@link\n * NavigableMap#tailMap(Object, boolean) tailMap()}, and {@link NavigableMap#headMap(Object,\n * boolean) headMap()}) to actually construct the view. Consult these methods for a full\n * description of the returned view's behavior.\n *\n * <p><b>Warning:</b> {@code Range}s always represent a range of values using the values' natural\n * ordering. {@code NavigableMap} on the other hand can specify a custom ordering via a {@link\n * Comparator}, which can violate the natural ordering. Using this method (or in general using\n * {@code Range}) with unnaturally-ordered maps can lead to unexpected and undefined behavior.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 6596, "method_signature": "NavigableMap<K,V> subMap(NavigableMap, Range)", "filename": "Maps.subMap.json"}
{"callee_method_names": [], "method_name": "Maps.synchronizedNavigableMap", "method_implementation": "{\n    return Synchronized.navigableMap(navigableMap);\n}", "repo_id": "5", "comment": "/**\n * Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In\n * order to guarantee serial access, it is critical that <b>all</b> access to the backing\n * navigable map is accomplished through the returned navigable map (or its views).\n *\n * <p>It is imperative that the user manually synchronize on the returned navigable map when\n * iterating over any of its collection views, or the collections views of any of its {@code\n * descendingMap}, {@code subMap}, {@code headMap} or {@code tailMap} views.\n *\n * <pre>{@code\n * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n *\n * // Needn't be in synchronized block\n * NavigableSet<K> set = map.navigableKeySet();\n *\n * synchronized (map) { // Synchronizing on map, not set!\n *   Iterator<K> it = set.iterator(); // Must be in synchronized block\n *   while (it.hasNext()) {\n *     foo(it.next());\n *   }\n * }\n * }</pre>\n *\n * <p>or:\n *\n * <pre>{@code\n * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n * NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);\n *\n * // Needn't be in synchronized block\n * NavigableSet<K> set2 = map2.descendingKeySet();\n *\n * synchronized (map) { // Synchronizing on map, not map2 or set2!\n *   Iterator<K> it = set2.iterator(); // Must be in synchronized block\n *   while (it.hasNext()) {\n *     foo(it.next());\n *   }\n * }\n * }</pre>\n *\n * <p>Failure to follow this advice may result in non-deterministic behavior.\n *\n * <p>The returned navigable map will be serializable if the specified navigable map is\n * serializable.\n *\n * @param navigableMap the navigable map to be \"wrapped\" in a synchronized navigable map.\n * @return a synchronized view of the specified navigable map.\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 6586, "method_signature": "NavigableMap<K,V> synchronizedNavigableMap(NavigableMap)", "filename": "Maps.synchronizedNavigableMap.json"}
{"callee_method_names": [], "method_name": "Maps.toImmutableEnumMap", "method_implementation": "{\n    return CollectCollectors.toImmutableEnumMap(keyFunction, valueFunction, mergeFunction);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n * and values are the result of applying the provided mapping functions to the input elements. The\n * resulting implementation is specialized for enum key types. The returned map and its views will\n * iterate over keys in their enum definition order, not encounter order.\n *\n * <p>If the mapped keys contain duplicates, the values are merged using the specified merging\n * function.\n */\n", "repo_name": "guava-master/", "id": 6544, "method_signature": "Collector<T,?,ImmutableMap<K,V>> toImmutableEnumMap(java.util.function.Function, java.util.function.Function, BinaryOperator)", "filename": "Maps.toImmutableEnumMap.json"}
{"callee_method_names": ["Iterator<K>.hasNext", "Iterator<K>.next", "ImmutableMap.Builder<K, V>.put", "Function<? super K,V>.apply", "ImmutableMap.Builder<K, V>.buildKeepingLast"], "method_name": "Maps.toMap", "method_implementation": "{\n    checkNotNull(valueFunction);\n    ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();\n    while (keys.hasNext()) {\n        K key = keys.next();\n        builder.put(key, valueFunction.apply(key));\n    }\n    // Using buildKeepingLast() so as not to fail on duplicate keys\n    return builder.buildKeepingLast();\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value\n * for each key was computed by {@code valueFunction}. The map's iteration order is the order of\n * the first appearance of each key in {@code keys}.\n *\n * <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code\n * valueFunction} will be applied to more than one instance of that key and, if it is, which\n * result will be mapped to that key in the returned map.\n *\n * @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code\n *     valueFunction} produces {@code null} for any key\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6552, "method_signature": "ImmutableMap<K,V> toMap(Iterator, Function)", "filename": "Maps.toMap.json"}
{"callee_method_names": ["Map<?,?>.size", "Map<?,?>.entrySet", "StringBuilder.append", "StringBuilder.append", "Entry<K,V1>.getKey", "Entry<K,V1>.getValue", "StringBuilder.append"], "method_name": "Maps.toStringImpl", "method_implementation": "{\n    StringBuilder sb = Collections2.newStringBuilderForCollection(map.size()).append('{');\n    boolean first = true;\n    for (Entry<?, ?> entry : map.entrySet()) {\n        if (!first) {\n            sb.append(\", \");\n        }\n        first = false;\n        sb.append(entry.getKey()).append('=').append(entry.getValue());\n    }\n    return sb.append('}').toString();\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Map#toString}.\n */\n", "repo_name": "guava-master/", "id": 6593, "method_signature": "String toStringImpl(Map)", "filename": "Maps.toStringImpl.json"}
{"callee_method_names": [], "method_name": "Maps.transformEntries", "method_implementation": "{\n    return new TransformedEntriesNavigableMap<>(fromMap, transformer);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of a navigable map whose values are derived from the original navigable map's\n * entries. In contrast to {@link #transformValues}, this method's entry-transformation logic may\n * depend on the key as well as the value.\n *\n * <p>All other properties of the transformed map, such as iteration order, are left intact. For\n * example, the code:\n *\n * <pre>{@code\n * NavigableMap<String, Boolean> options = Maps.newTreeMap();\n * options.put(\"verbose\", false);\n * options.put(\"sort\", true);\n * EntryTransformer<String, Boolean, String> flagPrefixer =\n *     new EntryTransformer<String, Boolean, String>() {\n *       public String transformEntry(String key, Boolean value) {\n *         return value ? key : (\"yes\" + key);\n *       }\n *     };\n * NavigableMap<String, String> transformed =\n *     LabsMaps.transformNavigableEntries(options, flagPrefixer);\n * System.out.println(transformed);\n * }</pre>\n *\n * ... prints {@code {sort=yessort, verbose=verbose}}.\n *\n * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n * removal operations, and these are reflected in the underlying map.\n *\n * <p>It's acceptable for the underlying map to contain null keys and null values provided that\n * the transformer is capable of accepting null inputs. The transformed map might contain null\n * values if the transformer sometimes gives a null result.\n *\n * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n *\n * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n * map to be a view, but it means that the transformer will be applied many times for bulk\n * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform\n * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map\n * doesn't need to be a view, copy the returned map into a new map of your choosing.\n *\n * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n * transformed map.\n *\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 6563, "method_signature": "NavigableMap<K,V2> transformEntries(NavigableMap, EntryTransformer)", "filename": "Maps.transformEntries.json"}
{"callee_method_names": ["Entry<K,V1>.getKey", "EntryTransformer<? super K,? super V1,V2>.transformEntry", "Entry<K,V1>.getKey", "Entry<K,V1>.getValue"], "method_name": "Maps.transformEntry", "method_implementation": "{\n    checkNotNull(transformer);\n    checkNotNull(entry);\n    return new AbstractMapEntry<K, V2>() {\n\n        @Override\n        @ParametricNullness\n        public K getKey() {\n            return entry.getKey();\n        }\n\n        @Override\n        @ParametricNullness\n        public V2 getValue() {\n            return transformer.transformEntry(entry.getKey(), entry.getValue());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a view of an entry transformed by the specified transformer.\n */\n", "repo_name": "guava-master/", "id": 6566, "method_signature": "Entry<K,V2> transformEntry(EntryTransformer, Entry)", "filename": "Maps.transformEntry.json"}
{"callee_method_names": [], "method_name": "Maps.transformValues", "method_implementation": "{\n    return transformEntries(fromMap, asEntryTransformer(function));\n}", "repo_id": "5", "comment": "/**\n * Returns a view of a navigable map where each value is transformed by a function. All other\n * properties of the map, such as iteration order, are left intact. For example, the code:\n *\n * <pre>{@code\n * NavigableMap<String, Integer> map = Maps.newTreeMap();\n * map.put(\"a\", 4);\n * map.put(\"b\", 9);\n * Function<Integer, Double> sqrt =\n *     new Function<Integer, Double>() {\n *       public Double apply(Integer in) {\n *         return Math.sqrt((int) in);\n *       }\n *     };\n * NavigableMap<String, Double> transformed =\n *      Maps.transformNavigableValues(map, sqrt);\n * System.out.println(transformed);\n * }</pre>\n *\n * ... prints {@code {a=2.0, b=3.0}}.\n *\n * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n * removal operations, and these are reflected in the underlying map.\n *\n * <p>It's acceptable for the underlying map to contain null keys, and even null values provided\n * that the function is capable of accepting null input. The transformed map might contain null\n * values, if the function sometimes gives a null result.\n *\n * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n *\n * <p>The function is applied lazily, invoked when needed. This is necessary for the returned map\n * to be a view, but it means that the function will be applied many times for bulk operations\n * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code\n * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a\n * view, copy the returned map into a new map of your choosing.\n *\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 6560, "method_signature": "NavigableMap<K,V2> transformValues(NavigableMap, Function)", "filename": "Maps.transformValues.json"}
{"callee_method_names": [], "method_name": "Maps.uniqueIndex", "method_implementation": "{\n    return uniqueIndex(values, keyFunction, ImmutableMap.builder());\n}", "repo_id": "5", "comment": "/**\n * Returns a map with the given {@code values}, indexed by keys derived from those values. In\n * other words, each input value produces an entry in the map whose key is the result of applying\n * {@code keyFunction} to that value. These entries appear in the same order as the input values.\n * Example usage:\n *\n * <pre>{@code\n * Color red = new Color(\"red\", 255, 0, 0);\n * ...\n * Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n *\n * Map<String, Color> colorForName =\n *     uniqueIndex(allColors, toStringFunction());\n * assertThat(colorForName).containsEntry(\"red\", red);\n * }</pre>\n *\n * <p>If your index may associate multiple values with each key, use {@link\n * Multimaps#index(Iterator, Function) Multimaps.index}.\n *\n * @param values the values to use when constructing the {@code Map}\n * @param keyFunction the function used to produce the key for each value\n * @return a map mapping the result of evaluating the function {@code keyFunction} on each value\n *     in the input collection to that value\n * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one\n *     value in the input collection\n * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code\n *     keyFunction} produces {@code null} for any value\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6554, "method_signature": "ImmutableMap<K,V> uniqueIndex(Iterator, Function)", "filename": "Maps.uniqueIndex.json"}
{"callee_method_names": ["Entry<? extends K,? extends V>.getKey", "Entry<? extends K,? extends V>.getValue"], "method_name": "Maps.unmodifiableEntry", "method_implementation": "{\n    checkNotNull(entry);\n    return new AbstractMapEntry<K, V>() {\n\n        @Override\n        @ParametricNullness\n        public K getKey() {\n            return entry.getKey();\n        }\n\n        @Override\n        @ParametricNullness\n        public V getValue() {\n            return entry.getValue();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified map entry. The {@link Entry#setValue} operation\n * throws an {@link UnsupportedOperationException}. This also has the side effect of redefining\n * {@code equals} to comply with the Entry contract, to avoid a possible nefarious implementation\n * of equals.\n *\n * @param entry the entry for which to return an unmodifiable view\n * @return an unmodifiable view of the entry\n */\n", "repo_name": "guava-master/", "id": 6557, "method_signature": "Entry<K,V> unmodifiableEntry(Entry)", "filename": "Maps.unmodifiableEntry.json"}
{"callee_method_names": [], "method_name": "Maps.unmodifiableNavigableMap", "method_implementation": "{\n    checkNotNull(map);\n    if (map instanceof UnmodifiableNavigableMap) {\n        // covariant\n        @SuppressWarnings(\"unchecked\")\n        NavigableMap<K, V> result = (NavigableMap<K, V>) map;\n        return result;\n    } else {\n        return new UnmodifiableNavigableMap<>(map);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified navigable map. Query operations on the returned\n * map read through to the specified map, and attempts to modify the returned map, whether direct\n * or via its views, result in an {@code UnsupportedOperationException}.\n *\n * <p>The returned navigable map will be serializable if the specified navigable map is\n * serializable.\n *\n * <p>This method's signature will not permit you to convert a {@code NavigableMap<? extends K,\n * V>} to a {@code NavigableMap<K, V>}. If it permitted this, the returned map's {@code\n * comparator()} method might return a {@code Comparator<? extends K>}, which works only on a\n * particular subtype of {@code K}, but promise that it's a {@code Comparator<? super K>}, which\n * must work on any type of {@code K}.\n *\n * @param map the navigable map for which an unmodifiable view is to be returned\n * @return an unmodifiable view of the specified navigable map\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 6585, "method_signature": "NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap)", "filename": "Maps.unmodifiableNavigableMap.json"}
{"callee_method_names": [], "method_name": "MapsTest.sortedNotNavigable", "method_implementation": "{\n    return new ForwardingSortedMap<K, V>() {\n\n        @Override\n        protected SortedMap<K, V> delegate() {\n            return map;\n        }\n    };\n}", "repo_id": "5", "comment": "// Logically this would accept a NavigableMap, but that won't work under GWT.\n", "repo_name": "guava-master/", "id": 4020, "method_signature": "SortedMap<K,V> sortedNotNavigable(SortedMap)", "filename": "MapsTest.sortedNotNavigable.json"}
{"callee_method_names": [], "method_name": "MapsTest.testIdentityHashMap", "method_implementation": "{\n    IdentityHashMap<Integer, Integer> map = Maps.newIdentityHashMap();\n    assertEquals(Collections.emptyMap(), map);\n}", "repo_id": "5", "comment": "// Intentionally using IdentityHashMap to test creation.\n", "repo_name": "guava-master/", "id": 4015, "method_signature": "void testIdentityHashMap()", "filename": "MapsTest.testIdentityHashMap.json"}
{"callee_method_names": [], "method_name": "MapsTest.testNewHashMapWithExpectedSize_wontGrow", "method_implementation": "{\n    // before jdk7u40: creates one-bucket table\n    // after  jdk7u40: creates empty table\n    assertTrue(bucketsOf(Maps.newHashMapWithExpectedSize(0)) <= 1);\n    for (int size = 1; size < 200; size++) {\n        assertWontGrow(size, new HashMap<>(), Maps.newHashMapWithExpectedSize(size), Maps.newHashMapWithExpectedSize(size));\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests that nHMWES makes hash maps large enough that adding the expected number of elements\n * won't cause a rehash.\n *\n * <p>As of jdk7u40, HashMap has an empty-map optimization. The argument to new HashMap(int) is\n * noted, but the initial table is a zero-length array.\n *\n * <p>This test may fail miserably on non-OpenJDK environments...\n */\n", "repo_name": "guava-master/", "id": 4013, "method_signature": "void testNewHashMapWithExpectedSize_wontGrow()", "filename": "MapsTest.testNewHashMapWithExpectedSize_wontGrow.json"}
{"callee_method_names": [], "method_name": "MapsTest.testNewLinkedHashMapWithExpectedSize_wontGrow", "method_implementation": "{\n    assertTrue(bucketsOf(Maps.newLinkedHashMapWithExpectedSize(0)) <= 1);\n    for (int size = 1; size < 200; size++) {\n        assertWontGrow(size, new LinkedHashMap<>(), Maps.newLinkedHashMapWithExpectedSize(size), Maps.newLinkedHashMapWithExpectedSize(size));\n    }\n}", "repo_id": "5", "comment": "/**\n * Same test as above but for newLinkedHashMapWithExpectedSize\n */\n", "repo_name": "guava-master/", "id": 4014, "method_signature": "void testNewLinkedHashMapWithExpectedSize_wontGrow()", "filename": "MapsTest.testNewLinkedHashMapWithExpectedSize_wontGrow.json"}
{"callee_method_names": ["BiMap<String, Integer>.put", "BiMap<String, Integer>.put", "BiMap<String, Integer>.put", "BiMap<String, Integer>.inverse", "BiMap<String, Integer>.inverse"], "method_name": "MapsTest.testSynchronizedBiMap", "method_implementation": "{\n    BiMap<String, Integer> bimap = HashBiMap.create();\n    bimap.put(\"one\", 1);\n    BiMap<String, Integer> sync = Maps.synchronizedBiMap(bimap);\n    bimap.put(\"two\", 2);\n    sync.put(\"three\", 3);\n    assertEquals(ImmutableSet.of(1, 2, 3), bimap.inverse().keySet());\n    assertEquals(ImmutableSet.of(1, 2, 3), sync.inverse().keySet());\n}", "repo_id": "5", "comment": "/**\n * See {@link SynchronizedBiMapTest} for more tests.\n */\n", "repo_name": "guava-master/", "id": 4019, "method_signature": "void testSynchronizedBiMap()", "filename": "MapsTest.testSynchronizedBiMap.json"}
{"callee_method_names": ["ImmutableTable<String, String, Integer>.getMessage"], "method_name": "MapsTest.testUniqueIndexDuplicates", "method_implementation": "{\n    try {\n        Map<Integer, String> unused = Maps.uniqueIndex(ImmutableSet.of(\"one\", \"uno\"), Functions.constant(1));\n        fail();\n    } catch (IllegalArgumentException expected) {\n        assertThat(expected.getMessage()).contains(\"Multimaps.index\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Can't create the map if more than one value maps to the same key.\n */\n", "repo_name": "guava-master/", "id": 4016, "method_signature": "void testUniqueIndexDuplicates()", "filename": "MapsTest.testUniqueIndexDuplicates.json"}
{"callee_method_names": [], "method_name": "MapsTest.testUniqueIndexNullKey", "method_implementation": "{\n    List<String> oneStringList = Lists.newArrayList(\"foo\");\n    try {\n        Maps.uniqueIndex(oneStringList, Functions.constant(null));\n        fail();\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Null keys aren't allowed either.\n */\n", "repo_name": "guava-master/", "id": 4018, "method_signature": "void testUniqueIndexNullKey()", "filename": "MapsTest.testUniqueIndexNullKey.json"}
{"callee_method_names": [], "method_name": "MapsTest.testUniqueIndexNullValue", "method_implementation": "{\n    List<String> listWithNull = Lists.newArrayList((String) null);\n    try {\n        Maps.uniqueIndex(listWithNull, Functions.constant(1));\n        fail();\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Null values are not allowed.\n */\n", "repo_name": "guava-master/", "id": 4017, "method_signature": "void testUniqueIndexNullValue()", "filename": "MapsTest.testUniqueIndexNullValue.json"}
{"callee_method_names": ["Map<?,?>.hashCode", "Map<?,?>.hashCode", "Map<?,?>.entrySet", "Map<?,?>.entrySet", "Map<?,?>.values", "Map<?,?>.values", "Collection<?>.size", "Collection<?>.size", "Collection<?>.containsAll", "Collection<?>.containsAll"], "method_name": "MapsTransformValuesUnmodifiableIteratorTest.assertMapsEqual", "method_implementation": "{\n    assertEquals(expected, map);\n    assertEquals(expected.hashCode(), map.hashCode());\n    assertEquals(expected.entrySet(), map.entrySet());\n    // Assert that expectedValues > mapValues and that\n    // mapValues > expectedValues; i.e. that expectedValues == mapValues.\n    Collection<?> expectedValues = expected.values();\n    Collection<?> mapValues = map.values();\n    assertEquals(expectedValues.size(), mapValues.size());\n    assertTrue(expectedValues.containsAll(mapValues));\n    assertTrue(mapValues.containsAll(expectedValues));\n}", "repo_id": "5", "comment": "/**\n * Helper assertion comparing two maps\n */\n", "repo_name": "guava-master/", "id": 4033, "method_signature": "void assertMapsEqual(Map, Map)", "filename": "MapsTransformValuesUnmodifiableIteratorTest.assertMapsEqual.json"}
{"callee_method_names": ["Random.nextBoolean", "BigInteger.signum"], "method_name": "MathBenchmarking.randomBigInteger", "method_implementation": "{\n    while (true) {\n        if (RANDOM_SOURCE.nextBoolean()) {\n            return randomNonNegativeBigInteger(numBits);\n        }\n        BigInteger neg = randomNonNegativeBigInteger(numBits).negate();\n        if (neg.signum() != 0) {\n            return neg;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Chooses a number in (-2^numBits, 2^numBits) at random, with density concentrated in numbers of\n * lower magnitude.\n */\n", "repo_name": "guava-master/", "id": 3587, "method_signature": "BigInteger randomBigInteger(int)", "filename": "MathBenchmarking.randomBigInteger.json"}
{"callee_method_names": ["Random.nextDouble", "Random.nextInt", "Random.nextBoolean"], "method_name": "MathBenchmarking.randomDouble", "method_implementation": "{\n    double result = RANDOM_SOURCE.nextDouble();\n    result = Math.scalb(result, RANDOM_SOURCE.nextInt(maxExponent + 1));\n    return RANDOM_SOURCE.nextBoolean() ? result : -result;\n}", "repo_id": "5", "comment": "/**\n * Generates a number in [0, 2^numBits) with an exponential distribution. The floor of the log2 of\n * the absolute value of the result is chosen uniformly at random in [0, numBits), and then the\n * result is chosen from those possibilities uniformly at random.\n *\n * <p>Zero is treated as having log2 == 0.\n */\n", "repo_name": "guava-master/", "id": 3588, "method_signature": "double randomDouble(int)", "filename": "MathBenchmarking.randomDouble.json"}
{"callee_method_names": ["Random.nextInt"], "method_name": "MathBenchmarking.randomNonNegativeBigInteger", "method_implementation": "{\n    int digits = RANDOM_SOURCE.nextInt(numBits);\n    if (digits == 0) {\n        return new BigInteger(1, RANDOM_SOURCE);\n    } else {\n        return new BigInteger(digits, RANDOM_SOURCE).setBit(digits);\n    }\n}", "repo_id": "5", "comment": "/**\n * Generates a number in [0, 2^numBits) with an exponential distribution. The floor of the log2 of\n * the result is chosen uniformly at random in [0, numBits), and then the result is chosen in that\n * range uniformly at random. Zero is treated as having log2 == 0.\n */\n", "repo_name": "guava-master/", "id": 3586, "method_signature": "BigInteger randomNonNegativeBigInteger(int)", "filename": "MathBenchmarking.randomNonNegativeBigInteger.json"}
{"callee_method_names": ["BigInteger.signum"], "method_name": "MathBenchmarking.randomPositiveBigInteger", "method_implementation": "{\n    BigInteger result;\n    do {\n        result = randomNonNegativeBigInteger(numBits);\n    } while (result.signum() == 0);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Generates values in a distribution equivalent to randomNonNegativeBigInteger but omitting zero.\n */\n", "repo_name": "guava-master/", "id": 3585, "method_signature": "BigInteger randomPositiveBigInteger(int)", "filename": "MathBenchmarking.randomPositiveBigInteger.json"}
{"callee_method_names": ["String.matches", "String.matches", "String.matches", "String.matches", "String.matches", "String.matches"], "method_name": "MaxCodePoint.decode", "method_implementation": "{\n    try {\n        return Integer.decode(userFriendly);\n    } catch (NumberFormatException ignored) {\n        if (userFriendly.matches(\"(?i)(?:American|English|ASCII)\")) {\n            // 1-byte UTF-8 sequences - \"American\" ASCII text\n            return 0x80;\n        } else if (userFriendly.matches(\"(?i)(?:French|Latin|Western.*European)\")) {\n            // Mostly 1-byte UTF-8 sequences, mixed with occasional 2-byte\n            // sequences - \"Western European\" text\n            return 0x90;\n        } else if (userFriendly.matches(\"(?i)(?:Branch.*Prediction.*Hostile)\")) {\n            // Defeat branch predictor for: c < 0x80 ; branch taken 50% of the time.\n            return 0x100;\n        } else if (userFriendly.matches(\"(?i)(?:Greek|Cyrillic|European|ISO.?8859)\")) {\n            // Mostly 2-byte UTF-8 sequences - \"European\" text\n            return 0x800;\n        } else if (userFriendly.matches(\"(?i)(?:Chinese|Han|Asian|BMP)\")) {\n            // Mostly 3-byte UTF-8 sequences - \"Asian\" text\n            return Character.MIN_SUPPLEMENTARY_CODE_POINT;\n        } else if (userFriendly.matches(\"(?i)(?:Cuneiform|rare|exotic|supplementary.*)\")) {\n            // Mostly 4-byte UTF-8 sequences - \"rare exotic\" text\n            return Character.MAX_CODE_POINT;\n        } else {\n            throw new IllegalArgumentException(\"Can't decode codepoint \" + userFriendly);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Convert the input string to a code point. Accepts regular decimal numerals, hex strings, and\n * some symbolic names meaningful to humans.\n */\n", "repo_name": "guava-master/", "id": 3488, "method_signature": "int decode(String)", "filename": "MaxCodePoint.decode.json"}
{"callee_method_names": ["ImmutableListMultimap<String, String>.get", "String.equals"], "method_name": "MediaType.charset", "method_implementation": "{\n    // racy single-check idiom, this is safe because Optional is immutable.\n    Optional<Charset> local = parsedCharset;\n    if (local == null) {\n        String value = null;\n        local = Optional.absent();\n        for (String currentValue : parameters.get(CHARSET_ATTRIBUTE)) {\n            if (value == null) {\n                value = currentValue;\n                local = Optional.of(Charset.forName(value));\n            } else if (!value.equals(currentValue)) {\n                throw new IllegalStateException(\"Multiple charset values defined: \" + value + \", \" + currentValue);\n            }\n        }\n        parsedCharset = local;\n    }\n    return local;\n}", "repo_id": "5", "comment": "/**\n * Returns an optional charset for the value of the charset parameter if it is specified.\n *\n * @throws IllegalStateException if multiple charset values have been set for this media type\n * @throws IllegalCharsetNameException if a charset value is present, but illegal\n * @throws UnsupportedCharsetException if a charset value is present, but no support is available\n *     in this instance of the Java virtual machine\n */\n", "repo_name": "guava-master/", "id": 6681, "method_signature": "Optional<Charset> charset()", "filename": "MediaType.charset.json"}
{"callee_method_names": [], "method_name": "MediaType.create", "method_implementation": "{\n    MediaType mediaType = create(type, subtype, ImmutableListMultimap.<String, String>of());\n    mediaType.parsedCharset = Optional.absent();\n    return mediaType;\n}", "repo_id": "5", "comment": "/**\n * Creates a new media type with the given type and subtype.\n *\n * @throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the\n *     type, but not the subtype.\n */\n", "repo_name": "guava-master/", "id": 6685, "method_signature": "MediaType create(String, String)", "filename": "MediaType.create.json"}
{"callee_method_names": ["MediaType.equals", "MediaType.equals", "MediaType.equals", "MediaType.equals", "MediaType.entries"], "method_name": "MediaType.is", "method_implementation": "{\n    return (mediaTypeRange.type.equals(WILDCARD) || mediaTypeRange.type.equals(this.type)) && (mediaTypeRange.subtype.equals(WILDCARD) || mediaTypeRange.subtype.equals(this.subtype)) && this.parameters.entries().containsAll(mediaTypeRange.parameters.entries());\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if this instance falls within the range (as defined by <a\n * href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">the HTTP Accept header</a>) given\n * by the argument according to three criteria:\n *\n * <ol>\n *   <li>The type of the argument is the wildcard or equal to the type of this instance.\n *   <li>The subtype of the argument is the wildcard or equal to the subtype of this instance.\n *   <li>All of the parameters present in the argument are present in this instance.\n * </ol>\n *\n * <p>For example:\n *\n * <pre>{@code\n * PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8) // true\n * PLAIN_TEXT_UTF_8.is(HTML_UTF_8) // false\n * PLAIN_TEXT_UTF_8.is(ANY_TYPE) // true\n * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE) // true\n * PLAIN_TEXT_UTF_8.is(ANY_IMAGE_TYPE) // false\n * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_8)) // true\n * PLAIN_TEXT_UTF_8.withoutParameters().is(ANY_TEXT_TYPE.withCharset(UTF_8)) // false\n * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_16)) // false\n * }</pre>\n *\n * <p>Note that while it is possible to have the same parameter declared multiple times within a\n * media type this method does not consider the number of occurrences of a parameter. For example,\n * {@code \"text/plain; charset=UTF-8\"} satisfies {@code \"text/plain; charset=UTF-8;\n * charset=UTF-8\"}.\n */\n", "repo_name": "guava-master/", "id": 6684, "method_signature": "boolean is(MediaType)", "filename": "MediaType.is.json"}
{"callee_method_names": ["Tokenizer.consumeToken", "Tokenizer.consumeToken", "Tokenizer.hasMore", "Tokenizer.consumeToken", "Tokenizer.previewChar", "Tokenizer.consumeCharacter", "Tokenizer.previewChar", "Tokenizer.previewChar", "Tokenizer.consumeCharacter", "StringBuilder.append", "Tokenizer.consumeCharacter", "StringBuilder.append", "Tokenizer.consumeToken", "StringBuilder.toString", "Tokenizer.consumeCharacter", "Tokenizer.consumeToken", "ImmutableListMultimap.Builder<String, String>.put", "ImmutableListMultimap.Builder<String, String>.build"], "method_name": "MediaType.parse", "method_implementation": "{\n    checkNotNull(input);\n    Tokenizer tokenizer = new Tokenizer(input);\n    try {\n        String type = tokenizer.consumeToken(TOKEN_MATCHER);\n        consumeSeparator(tokenizer, '/');\n        String subtype = tokenizer.consumeToken(TOKEN_MATCHER);\n        ImmutableListMultimap.Builder<String, String> parameters = ImmutableListMultimap.builder();\n        while (tokenizer.hasMore()) {\n            consumeSeparator(tokenizer, ';');\n            String attribute = tokenizer.consumeToken(TOKEN_MATCHER);\n            consumeSeparator(tokenizer, '=');\n            String value;\n            if ('\"' == tokenizer.previewChar()) {\n                tokenizer.consumeCharacter('\"');\n                StringBuilder valueBuilder = new StringBuilder();\n                while ('\"' != tokenizer.previewChar()) {\n                    if ('\\\\' == tokenizer.previewChar()) {\n                        tokenizer.consumeCharacter('\\\\');\n                        valueBuilder.append(tokenizer.consumeCharacter(ascii()));\n                    } else {\n                        valueBuilder.append(tokenizer.consumeToken(QUOTED_TEXT_MATCHER));\n                    }\n                }\n                value = valueBuilder.toString();\n                tokenizer.consumeCharacter('\"');\n            } else {\n                value = tokenizer.consumeToken(TOKEN_MATCHER);\n            }\n            parameters.put(attribute, value);\n        }\n        return create(type, subtype, parameters.build());\n    } catch (IllegalStateException e) {\n        throw new IllegalArgumentException(\"Could not parse '\" + input + \"'\", e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Parses a media type from its string representation.\n *\n * @throws IllegalArgumentException if the input is not parsable\n */\n", "repo_name": "guava-master/", "id": 6686, "method_signature": "MediaType parse(String)", "filename": "MediaType.parse.json"}
{"callee_method_names": [], "method_name": "MediaType.toString", "method_implementation": "{\n    // racy single-check idiom, safe because String is immutable\n    String result = toString;\n    if (result == null) {\n        result = computeToString();\n        toString = result;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the string representation of this media type in the format described in <a\n * href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>.\n */\n", "repo_name": "guava-master/", "id": 6687, "method_signature": "String toString()", "filename": "MediaType.toString.json"}
{"callee_method_names": ["Charset.name"], "method_name": "MediaType.withCharset", "method_implementation": "{\n    checkNotNull(charset);\n    MediaType withCharset = withParameter(CHARSET_ATTRIBUTE, charset.name());\n    // precache the charset so we don't need to parse it\n    withCharset.parsedCharset = Optional.of(charset);\n    return withCharset;\n}", "repo_id": "5", "comment": "/**\n * Returns a new instance with the same type and subtype as this instance, with the {@code\n * charset} parameter set to the {@link Charset#name name} of the given charset. Only one {@code\n * charset} parameter will be present on the new instance regardless of the number set on this\n * one.\n *\n * <p>If a charset must be specified that is not supported on this JVM (and thus is not\n * representable as a {@link Charset} instance), use {@link #withParameter}.\n */\n", "repo_name": "guava-master/", "id": 6683, "method_signature": "MediaType withCharset(Charset)", "filename": "MediaType.withCharset.json"}
{"callee_method_names": ["ImmutableListMultimap<String, String>.entries", "long.getKey", "String.equals", "ImmutableListMultimap.Builder<String, String>.put", "long.getValue", "ImmutableListMultimap.Builder<String, String>.put", "ImmutableListMultimap.Builder<String, String>.build", "String.equals", "Map<MediaType, MediaType>.get"], "method_name": "MediaType.withParameters", "method_implementation": "{\n    checkNotNull(attribute);\n    checkNotNull(values);\n    String normalizedAttribute = normalizeToken(attribute);\n    ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\n    for (Entry<String, String> entry : parameters.entries()) {\n        String key = entry.getKey();\n        if (!normalizedAttribute.equals(key)) {\n            builder.put(key, entry.getValue());\n        }\n    }\n    for (String value : values) {\n        builder.put(normalizedAttribute, normalizeParameterValue(normalizedAttribute, value));\n    }\n    MediaType mediaType = new MediaType(type, subtype, builder.build());\n    // if the attribute isn't charset, we can just inherit the current parsedCharset\n    if (!normalizedAttribute.equals(CHARSET_ATTRIBUTE)) {\n        mediaType.parsedCharset = this.parsedCharset;\n    }\n    // Return one of the constants if the media type is a known type.\n    return MoreObjects.firstNonNull(KNOWN_TYPES.get(mediaType), mediaType);\n}", "repo_id": "5", "comment": "/**\n * <em>Replaces</em> all parameters with the given attribute with parameters using the given\n * values. If there are no values, any existing parameters with the given attribute are removed.\n *\n * @throws IllegalArgumentException if either {@code attribute} or {@code values} is invalid\n * @since 24.0\n */\n", "repo_name": "guava-master/", "id": 6682, "method_signature": "MediaType withParameters(String, Iterable)", "filename": "MediaType.withParameters.json"}
{"callee_method_names": [], "method_name": "MediaTypeTest.testParse_spaceInParameterSeparator", "method_implementation": "{\n    assertThat(MediaType.parse(\"text/plain; charset =utf-8\").charset()).hasValue(UTF_8);\n    assertThat(MediaType.parse(\"text/plain; charset= utf-8\").charset()).hasValue(UTF_8);\n    assertThat(MediaType.parse(\"text/plain; charset = utf-8\").charset()).hasValue(UTF_8);\n    assertThat(MediaType.parse(\"text/plain;charset =utf-8\").charset()).hasValue(UTF_8);\n}", "repo_id": "5", "comment": "// https://github.com/google/guava/issues/6663\n", "repo_name": "guava-master/", "id": 4042, "method_signature": "void testParse_spaceInParameterSeparator()", "filename": "MediaTypeTest.testParse_spaceInParameterSeparator.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.add", "method_implementation": "{\n    offer(element);\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n * element} the queue will automatically evict its greatest element (according to its comparator),\n * which may be {@code element} itself.\n *\n * @return {@code true} always\n */\n", "repo_name": "guava-master/", "id": 6505, "method_signature": "boolean add(E)", "filename": "MinMaxPriorityQueue.add.json"}
{"callee_method_ids": [6532], "callee_method_names": ["Heap.bubbleUpAlternatingLevels"], "method_name": "MinMaxPriorityQueue.bubbleUp", "method_implementation": "{\n    int crossOver = crossOverUp(index, x);\n    Heap heap;\n    if (crossOver == index) {\n        heap = this;\n    } else {\n        index = crossOver;\n        heap = otherHeap;\n    }\n    heap.bubbleUpAlternatingLevels(index, x);\n}", "repo_id": "5", "comment": "/**\n * Bubbles a value from {@code index} up the appropriate heap if required.\n */\n", "repo_name": "guava-master/", "id": 6515, "method_signature": "void bubbleUp(int, E)", "filename": "MinMaxPriorityQueue.bubbleUp.json"}
{"callee_method_names": ["Ordering<E>.compare"], "method_name": "MinMaxPriorityQueue.bubbleUpAlternatingLevels", "method_implementation": "{\n    while (index > 2) {\n        int grandParentIndex = getGrandparentIndex(index);\n        E e = elementData(grandParentIndex);\n        if (ordering.compare(e, x) <= 0) {\n            break;\n        }\n        queue[index] = e;\n        index = grandParentIndex;\n    }\n    queue[index] = x;\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Bubbles a value from {@code index} up the levels of this heap, and returns the index the\n * element ended up at.\n */\n", "repo_name": "guava-master/", "id": 6516, "method_signature": "int bubbleUpAlternatingLevels(int, E)", "filename": "MinMaxPriorityQueue.bubbleUpAlternatingLevels.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.calculateNewCapacity", "method_implementation": "{\n    int oldCapacity = queue.length;\n    int newCapacity = (oldCapacity < 64) ? (oldCapacity + 1) * 2 : IntMath.checkedMultiply(oldCapacity / 2, 3);\n    return capAtMaximumSize(newCapacity, maximumSize);\n}", "repo_id": "5", "comment": "/**\n * Returns ~2x the old capacity if small; ~1.5x otherwise.\n */\n", "repo_name": "guava-master/", "id": 6526, "method_signature": "int calculateNewCapacity()", "filename": "MinMaxPriorityQueue.calculateNewCapacity.json"}
{"callee_method_names": ["MinMaxPriorityQueue<T>.offer"], "method_name": "MinMaxPriorityQueue.create", "method_implementation": "{\n    MinMaxPriorityQueue<T> queue = new MinMaxPriorityQueue<>(this, initialQueueSize(expectedSize, maximumSize, initialContents));\n    for (T element : initialContents) {\n        queue.offer(element);\n    }\n    return queue;\n}", "repo_id": "5", "comment": "/**\n * Builds a new min-max priority queue using the previously specified options, and having the\n * given initial elements.\n */\n", "repo_name": "guava-master/", "id": 6504, "method_signature": "MinMaxPriorityQueue<T> create(Iterable)", "filename": "MinMaxPriorityQueue.create.json"}
{"callee_method_names": ["Ordering<E>.compare"], "method_name": "MinMaxPriorityQueue.crossOver", "method_implementation": "{\n    int minChildIndex = findMinChild(index);\n    // TODO(kevinb): split the && into two if's and move crossOverUp so it's\n    // only called when there's no child.\n    if ((minChildIndex > 0) && (ordering.compare(elementData(minChildIndex), x) < 0)) {\n        queue[index] = elementData(minChildIndex);\n        queue[minChildIndex] = x;\n        return minChildIndex;\n    }\n    return crossOverUp(index, x);\n}", "repo_id": "5", "comment": "/**\n * Crosses an element over to the opposite heap by moving it one level down (or up if there are\n * no elements below it).\n *\n * <p>Returns the new position of the element.\n */\n", "repo_name": "guava-master/", "id": 6521, "method_signature": "int crossOver(int, E)", "filename": "MinMaxPriorityQueue.crossOver.json"}
{"callee_method_names": ["Ordering<E>.compare", "Ordering<E>.compare"], "method_name": "MinMaxPriorityQueue.crossOverUp", "method_implementation": "{\n    if (index == 0) {\n        queue[0] = x;\n        return 0;\n    }\n    int parentIndex = getParentIndex(index);\n    E parentElement = elementData(parentIndex);\n    if (parentIndex != 0) {\n        /*\n         * This is a guard for the case of the childless aunt node. Since the end of the array is\n         * actually the middle of the heap, a smaller childless aunt node can become a child of x\n         * when we bubble up alternate levels, violating the invariant.\n         */\n        int grandparentIndex = getParentIndex(parentIndex);\n        int auntIndex = getRightChildIndex(grandparentIndex);\n        if (auntIndex != parentIndex && getLeftChildIndex(auntIndex) >= size) {\n            E auntElement = elementData(auntIndex);\n            if (ordering.compare(auntElement, parentElement) < 0) {\n                parentIndex = auntIndex;\n                parentElement = auntElement;\n            }\n        }\n    }\n    if (ordering.compare(parentElement, x) < 0) {\n        queue[index] = parentElement;\n        queue[parentIndex] = x;\n        return parentIndex;\n    }\n    queue[index] = x;\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Moves an element one level up from a min level to a max level (or vice versa). Returns the\n * new position of the element.\n */\n", "repo_name": "guava-master/", "id": 6519, "method_signature": "int crossOverUp(int, E)", "filename": "MinMaxPriorityQueue.crossOverUp.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.expectedSize", "method_implementation": "{\n    checkArgument(expectedSize >= 0);\n    this.expectedSize = expectedSize;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures this builder to build min-max priority queues with an initial expected size of\n * {@code expectedSize}.\n */\n", "repo_name": "guava-master/", "id": 6502, "method_signature": "Builder<B> expectedSize(int)", "filename": "MinMaxPriorityQueue.expectedSize.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.fillHoleAt", "method_implementation": "{\n    int minGrandchildIndex;\n    while ((minGrandchildIndex = findMinGrandChild(index)) > 0) {\n        queue[index] = elementData(minGrandchildIndex);\n        index = minGrandchildIndex;\n    }\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Fills the hole at {@code index} by moving in the least of its grandchildren to this position,\n * then recursively filling the new hole created.\n *\n * @return the position of the new hole (where the lowest grandchild moved from, that had no\n *     grandchild to replace it)\n */\n", "repo_name": "guava-master/", "id": 6522, "method_signature": "int fillHoleAt(int)", "filename": "MinMaxPriorityQueue.fillHoleAt.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.findMin", "method_implementation": "{\n    if (index >= size) {\n        return -1;\n    }\n    checkState(index > 0);\n    int limit = Math.min(index, size - len) + len;\n    int minIndex = index;\n    for (int i = index + 1; i < limit; i++) {\n        if (compareElements(i, minIndex) < 0) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}", "repo_id": "5", "comment": "/**\n * Returns the index of minimum value between {@code index} and {@code index + len}, or {@code\n * -1} if {@code index} is greater than {@code size}.\n */\n", "repo_name": "guava-master/", "id": 6517, "method_signature": "int findMin(int, int)", "filename": "MinMaxPriorityQueue.findMin.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.findMinGrandChild", "method_implementation": "{\n    int leftChildIndex = getLeftChildIndex(index);\n    if (leftChildIndex < 0) {\n        return -1;\n    }\n    return findMin(getLeftChildIndex(leftChildIndex), 4);\n}", "repo_id": "5", "comment": "/**\n * Returns the minimum grand child or -1 if no grand child exists.\n */\n", "repo_name": "guava-master/", "id": 6518, "method_signature": "int findMinGrandChild(int)", "filename": "MinMaxPriorityQueue.findMinGrandChild.json"}
{"callee_method_names": ["Iterable<E>.iterator", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Iterator<? extends T>.remove"], "method_name": "MinMaxPriorityQueue.foundAndRemovedExactReference", "method_implementation": "{\n    for (Iterator<E> it = elements.iterator(); it.hasNext(); ) {\n        E element = it.next();\n        if (element == target) {\n            it.remove();\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns true if an exact reference (==) was found and removed from the supplied iterable.\n */\n", "repo_name": "guava-master/", "id": 6523, "method_signature": "boolean foundAndRemovedExactReference(Iterable, E)", "filename": "MinMaxPriorityQueue.foundAndRemovedExactReference.json"}
{"callee_method_names": ["Heap.compareElements"], "method_name": "MinMaxPriorityQueue.getMaxElementIndex", "method_implementation": "{\n    switch(size) {\n        case 1:\n            // The lone element in the queue is the maximum.\n            return 0;\n        case 2:\n            // The lone element in the maxHeap is the maximum.\n            return 1;\n        default:\n            // The max element must sit on the first level of the maxHeap. It is\n            // actually the *lesser* of the two from the maxHeap's perspective.\n            return (maxHeap.compareElements(1, 2) <= 0) ? 1 : 2;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the index of the max element.\n */\n", "repo_name": "guava-master/", "id": 6507, "method_signature": "int getMaxElementIndex()", "filename": "MinMaxPriorityQueue.getMaxElementIndex.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.isIntact", "method_implementation": "{\n    for (int i = 1; i < size; i++) {\n        if (!heapForIndex(i).verifyIndex(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if the MinMax heap structure holds. This is only used in testing.\n *\n * <p>TODO(kevinb): move to the test class?\n */\n", "repo_name": "guava-master/", "id": 6513, "method_signature": "boolean isIntact()", "filename": "MinMaxPriorityQueue.isIntact.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.maximumSize", "method_implementation": "{\n    checkArgument(maximumSize > 0);\n    this.maximumSize = maximumSize;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures this builder to build {@code MinMaxPriorityQueue} instances that are limited to\n * {@code maximumSize} elements. Each time a queue grows beyond this bound, it immediately\n * removes its greatest element (according to its comparator), which might be the element that\n * was just added.\n */\n", "repo_name": "guava-master/", "id": 6503, "method_signature": "Builder<B> maximumSize(int)", "filename": "MinMaxPriorityQueue.maximumSize.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.nextNotInSkipMe", "method_implementation": "{\n    if (nextCursor < c) {\n        if (skipMe != null) {\n            while (c < size() && foundAndRemovedExactReference(skipMe, elementData(c))) {\n                c++;\n            }\n        }\n        nextCursor = c;\n    }\n}", "repo_id": "5", "comment": "/**\n * Advances nextCursor to the index of the first element after {@code c} that is not in {@code\n * skipMe} and returns {@code size()} if there is no such element.\n */\n", "repo_name": "guava-master/", "id": 6525, "method_signature": "void nextNotInSkipMe(int)", "filename": "MinMaxPriorityQueue.nextNotInSkipMe.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.offer", "method_implementation": "{\n    checkNotNull(element);\n    modCount++;\n    int insertIndex = size++;\n    growIfNeeded();\n    // Adds the element to the end of the heap and bubbles it up to the correct\n    // position.\n    heapForIndex(insertIndex).bubbleUp(insertIndex, element);\n    return size <= maximumSize || pollLast() != element;\n}", "repo_id": "5", "comment": "/**\n * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n * element} the queue will automatically evict its greatest element (according to its comparator),\n * which may be {@code element} itself.\n */\n", "repo_name": "guava-master/", "id": 6506, "method_signature": "boolean offer(E)", "filename": "MinMaxPriorityQueue.offer.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.pollFirst", "method_implementation": "{\n    return poll();\n}", "repo_id": "5", "comment": "/**\n * Removes and returns the least element of this queue, or returns {@code null} if the queue is\n * empty.\n */\n", "repo_name": "guava-master/", "id": 6508, "method_signature": "E pollFirst()", "filename": "MinMaxPriorityQueue.pollFirst.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.pollLast", "method_implementation": "{\n    return isEmpty() ? null : removeAndGet(getMaxElementIndex());\n}", "repo_id": "5", "comment": "/**\n * Removes and returns the greatest element of this queue, or returns {@code null} if the queue is\n * empty.\n */\n", "repo_name": "guava-master/", "id": 6509, "method_signature": "E pollLast()", "filename": "MinMaxPriorityQueue.pollLast.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.removeAndGet", "method_implementation": "{\n    E value = elementData(index);\n    removeAt(index);\n    return value;\n}", "repo_id": "5", "comment": "/**\n * Removes and returns the value at {@code index}.\n */\n", "repo_name": "guava-master/", "id": 6512, "method_signature": "E removeAndGet(int)", "filename": "MinMaxPriorityQueue.removeAndGet.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.removeAt", "method_implementation": "{\n    checkPositionIndex(index, size);\n    modCount++;\n    size--;\n    if (size == index) {\n        queue[size] = null;\n        return null;\n    }\n    E actualLastElement = elementData(size);\n    int lastElementAt = heapForIndex(size).swapWithConceptuallyLastElement(actualLastElement);\n    if (lastElementAt == index) {\n        // 'actualLastElement' is now at 'lastElementAt', and the element that was at 'lastElementAt'\n        // is now at the end of queue. If that's the element we wanted to remove in the first place,\n        // don't try to (incorrectly) trickle it. Instead, just delete it and we're done.\n        queue[size] = null;\n        return null;\n    }\n    E toTrickle = elementData(size);\n    queue[size] = null;\n    MoveDesc<E> changes = fillHole(index, toTrickle);\n    if (lastElementAt < index) {\n        // Last element is moved to before index, swapped with trickled element.\n        if (changes == null) {\n            // The trickled element is still after index.\n            return new MoveDesc<>(actualLastElement, toTrickle);\n        } else {\n            // The trickled element is back before index, but the replaced element\n            // has now been moved after index.\n            return new MoveDesc<>(actualLastElement, changes.replaced);\n        }\n    }\n    // Trickled element was after index to begin with, no adjustment needed.\n    return changes;\n}", "repo_id": "5", "comment": "/**\n * Removes the element at position {@code index}.\n *\n * <p>Normally this method leaves the elements at up to {@code index - 1}, inclusive, untouched.\n * Under these circumstances, it returns {@code null}.\n *\n * <p>Occasionally, in order to maintain the heap invariant, it must swap a later element of the\n * list with one before {@code index}. Under these circumstances it returns a pair of elements as\n * a {@link MoveDesc}. The first one is the element that was previously at the end of the heap and\n * is now at some position before {@code index}. The second element is the one that was swapped\n * down to replace the element at {@code index}. This fact is used by iterator.remove so as to\n * visit elements during a traversal once and only once.\n */\n", "repo_name": "guava-master/", "id": 6511, "method_signature": "MoveDesc<E> removeAt(int)", "filename": "MinMaxPriorityQueue.removeAt.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.removeExact", "method_implementation": "{\n    for (int i = 0; i < size; i++) {\n        if (queue[i] == target) {\n            removeAt(i);\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Removes only this exact instance, not others that are equals()\n */\n", "repo_name": "guava-master/", "id": 6524, "method_signature": "boolean removeExact(Object)", "filename": "MinMaxPriorityQueue.removeExact.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueue.removeLast", "method_implementation": "{\n    if (isEmpty()) {\n        throw new NoSuchElementException();\n    }\n    return removeAndGet(getMaxElementIndex());\n}", "repo_id": "5", "comment": "/**\n * Removes and returns the greatest element of this queue.\n *\n * @throws NoSuchElementException if the queue is empty\n */\n", "repo_name": "guava-master/", "id": 6510, "method_signature": "E removeLast()", "filename": "MinMaxPriorityQueue.removeLast.json"}
{"callee_method_names": ["Ordering<E>.compare"], "method_name": "MinMaxPriorityQueue.swapWithConceptuallyLastElement", "method_implementation": "{\n    int parentIndex = getParentIndex(size);\n    if (parentIndex != 0) {\n        int grandparentIndex = getParentIndex(parentIndex);\n        int auntIndex = getRightChildIndex(grandparentIndex);\n        if (auntIndex != parentIndex && getLeftChildIndex(auntIndex) >= size) {\n            E auntElement = elementData(auntIndex);\n            if (ordering.compare(auntElement, actualLastElement) < 0) {\n                queue[auntIndex] = actualLastElement;\n                queue[size] = auntElement;\n                return auntIndex;\n            }\n        }\n    }\n    return size;\n}", "repo_id": "5", "comment": "/**\n * Swap {@code actualLastElement} with the conceptually correct last element of the heap.\n * Returns the index that {@code actualLastElement} now resides in.\n *\n * <p>Since the last element of the array is actually in the middle of the sorted structure, a\n * childless aunt node could be smaller, which would corrupt the invariant if this element\n * becomes the new parent of the aunt node. In that case, we first switch the last element with\n * its aunt node, before returning.\n */\n", "repo_name": "guava-master/", "id": 6520, "method_signature": "int swapWithConceptuallyLastElement(E)", "filename": "MinMaxPriorityQueue.swapWithConceptuallyLastElement.json"}
{"callee_method_ids": [6532], "callee_method_names": ["Heap.bubbleUpAlternatingLevels"], "method_name": "MinMaxPriorityQueue.tryCrossOverAndBubbleUp", "method_implementation": "{\n    int crossOver = crossOver(vacated, toTrickle);\n    if (crossOver == vacated) {\n        return null;\n    }\n    // Successfully crossed over from min to max.\n    // Bubble up max levels.\n    E parent;\n    // If toTrickle is moved up to a parent of removeIndex, the parent is\n    // placed in removeIndex position. We must return that to the iterator so\n    // that it knows to skip it.\n    if (crossOver < removeIndex) {\n        // We crossed over to the parent level in crossOver, so the parent\n        // has already been moved.\n        parent = elementData(removeIndex);\n    } else {\n        parent = elementData(getParentIndex(removeIndex));\n    }\n    // bubble it up the opposite heap\n    if (otherHeap.bubbleUpAlternatingLevels(crossOver, toTrickle) < removeIndex) {\n        return new MoveDesc<>(toTrickle, parent);\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Tries to move {@code toTrickle} from a min to a max level and bubble up there. If it moved\n * before {@code removeIndex} this method returns a pair as described in {@link #removeAt}.\n */\n", "repo_name": "guava-master/", "id": 6514, "method_signature": "MoveDesc<E> tryCrossOverAndBubbleUp(int, int, E)", "filename": "MinMaxPriorityQueue.tryCrossOverAndBubbleUp.json"}
{"callee_method_names": [], "method_name": "MinMaxPriorityQueueTest.insertRandomly", "method_implementation": "{\n    long seed = new Random().nextLong();\n    Random random = new Random(seed);\n    insertRandomly(elements, q, random);\n    return seed;\n}", "repo_id": "5", "comment": "/**\n * Returns the seed used for the randomization.\n */\n", "repo_name": "guava-master/", "id": 3963, "method_signature": "long insertRandomly(ArrayList, MinMaxPriorityQueue)", "filename": "MinMaxPriorityQueueTest.insertRandomly.json"}
{"callee_method_names": ["MinMaxPriorityQueue<Integer>.isEmpty", "ArrayList<Integer>.add", "MinMaxPriorityQueue<Integer>.pollFirst"], "method_name": "MinMaxPriorityQueueTest.testCorrectOrdering_73ElementBug", "method_implementation": "{\n    int size = 73;\n    long seed = 7522346378524621981L;\n    ArrayList<Integer> elements = createOrderedList(size);\n    List<Integer> expected = ImmutableList.copyOf(elements);\n    MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create();\n    insertRandomly(elements, q, new Random(seed));\n    assertIntact(q);\n    while (!q.isEmpty()) {\n        elements.add(q.pollFirst());\n        assertIntact(q);\n    }\n    assertEqualsUsingSeed(seed, expected, elements);\n}", "repo_id": "5", "comment": "/**\n * Regression test for bug found in random testing.\n */\n", "repo_name": "guava-master/", "id": 3960, "method_signature": "void testCorrectOrdering_73ElementBug()", "filename": "MinMaxPriorityQueueTest.testCorrectOrdering_73ElementBug.json"}
{"callee_method_names": ["List<Integer>.size", "List<Integer>.add", "MinMaxPriorityQueue<Integer>.pollFirst"], "method_name": "MinMaxPriorityQueueTest.testCorrectOrdering_regression", "method_implementation": "{\n    MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create(ImmutableList.of(3, 5, 1, 4, 7));\n    List<Integer> expected = ImmutableList.of(1, 3, 4, 5, 7);\n    List<Integer> actual = new ArrayList<>(5);\n    for (int i = 0; i < expected.size(); i++) {\n        actual.add(q.pollFirst());\n    }\n    assertEquals(expected, actual);\n}", "repo_id": "5", "comment": "/**\n * Regression test for bug found.\n */\n", "repo_name": "guava-master/", "id": 3959, "method_signature": "void testCorrectOrdering_regression()", "filename": "MinMaxPriorityQueueTest.testCorrectOrdering_regression.json"}
{"callee_method_names": ["MinMaxPriorityQueue<Integer>.addAll", "MinMaxPriorityQueue<Integer>.size", "MinMaxPriorityQueue<Integer>.isIntact", "MinMaxPriorityQueue<Integer>.remove", "MinMaxPriorityQueue<Integer>.size", "MinMaxPriorityQueue<Integer>.isIntact"], "method_name": "MinMaxPriorityQueueTest.testInvalidatingRemove", "method_implementation": "{\n    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\n    mmHeap.addAll(Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600));\n    assertEquals(15, mmHeap.size());\n    assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\n    mmHeap.remove(12);\n    assertEquals(14, mmHeap.size());\n    assertTrue(\"Heap is not intact after remove()\", mmHeap.isIntact());\n}", "repo_id": "5", "comment": "/**\n * This tests a special case of the removeAt() call. Moving an element sideways on the heap could\n * break the invariants. Sometimes we need to bubble an element up instead of trickling down. See\n * implementation.\n */\n", "repo_name": "guava-master/", "id": 3956, "method_signature": "void testInvalidatingRemove()", "filename": "MinMaxPriorityQueueTest.testInvalidatingRemove.json"}
{"callee_method_names": ["MinMaxPriorityQueue<Integer>.addAll", "MinMaxPriorityQueue<Integer>.size", "MinMaxPriorityQueue<Integer>.isIntact", "MinMaxPriorityQueue<Integer>.remove", "MinMaxPriorityQueue<Integer>.size", "MinMaxPriorityQueue<Integer>.isIntact", "List<Integer>.removeAll", "List<Integer>.size", "MinMaxPriorityQueue<Integer>.size", "List<Integer>.containsAll", "MinMaxPriorityQueue<Integer>.containsAll"], "method_name": "MinMaxPriorityQueueTest.testInvalidatingRemove2", "method_implementation": "{\n    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\n    List<Integer> values = Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600, 4, 5, 6, 7, 8, 9, 4, 5, 200, 250);\n    mmHeap.addAll(values);\n    assertEquals(25, mmHeap.size());\n    assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\n    mmHeap.remove(2);\n    assertEquals(24, mmHeap.size());\n    assertTrue(\"Heap is not intact after remove()\", mmHeap.isIntact());\n    values.removeAll(Lists.newArrayList(2));\n    assertEquals(values.size(), mmHeap.size());\n    assertTrue(values.containsAll(mmHeap));\n    assertTrue(mmHeap.containsAll(values));\n}", "repo_id": "5", "comment": "/**\n * This tests a more obscure special case, but otherwise similar to above.\n */\n", "repo_name": "guava-master/", "id": 3957, "method_signature": "void testInvalidatingRemove2()", "filename": "MinMaxPriorityQueueTest.testInvalidatingRemove2.json"}
{"callee_method_names": ["MinMaxPriorityQueue<Integer>.addAll", "MinMaxPriorityQueue<Integer>.isIntact", "MinMaxPriorityQueue<Integer>.iterator", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.remove", "MinMaxPriorityQueue<Integer>.isIntact", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.remove", "MinMaxPriorityQueue<Integer>.isIntact", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next", "Iterator<Integer>.next"], "method_name": "MinMaxPriorityQueueTest.testIteratorInvalidatingIteratorRemove2", "method_implementation": "{\n    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\n    mmHeap.addAll(Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 200, 300, 500, 400));\n    assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\n    Iterator<Integer> it = mmHeap.iterator();\n    assertEquals((Integer) 1, it.next());\n    assertEquals((Integer) 20, it.next());\n    assertEquals((Integer) 1000, it.next());\n    assertEquals((Integer) 2, it.next());\n    it.remove();\n    // After this remove, 400 has moved up and 20 down past cursor\n    assertTrue(\"Heap is not intact after remove\", mmHeap.isIntact());\n    assertEquals((Integer) 10, it.next());\n    assertEquals((Integer) 3, it.next());\n    it.remove();\n    // After this remove, 400 moved down again and 500 up past the cursor\n    assertTrue(\"Heap is not intact after remove\", mmHeap.isIntact());\n    assertEquals((Integer) 12, it.next());\n    assertEquals((Integer) 30, it.next());\n    assertEquals((Integer) 40, it.next());\n    // Skipping 20\n    assertEquals((Integer) 11, it.next());\n    // Not skipping 400, because it moved back down\n    assertEquals((Integer) 400, it.next());\n    assertEquals((Integer) 13, it.next());\n    assertEquals((Integer) 200, it.next());\n    assertEquals((Integer) 300, it.next());\n    // Last from forgetMeNot.\n    assertEquals((Integer) 500, it.next());\n}", "repo_id": "5", "comment": "/**\n * This tests a special case where removeAt has to trickle an element first down one level from a\n * min to a max level, then up one level above the index of the removed element. It also tests\n * that skipMe in the iterator plays nicely with forgetMeNot.\n */\n", "repo_name": "guava-master/", "id": 3958, "method_signature": "void testIteratorInvalidatingIteratorRemove2()", "filename": "MinMaxPriorityQueueTest.testIteratorInvalidatingIteratorRemove2.json"}
{"callee_method_names": ["MinMaxPriorityQueue<Integer>.remove", "MinMaxPriorityQueue<Integer>.remove", "MinMaxPriorityQueue<Integer>.remove", "ArrayList<Integer>.size", "MinMaxPriorityQueue<Integer>.iterator", "List<Integer>.add"], "method_name": "MinMaxPriorityQueueTest.testIteratorRegressionChildlessUncle", "method_implementation": "{\n    final ArrayList<Integer> initial = Lists.newArrayList(1, 15, 13, 8, 9, 10, 11, 14);\n    MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create(initial);\n    assertIntact(q);\n    q.remove(9);\n    q.remove(11);\n    q.remove(10);\n    // Now we're in the critical state: [1, 15, 13, 8, 14]\n    // Removing 8 while iterating caused duplicates in iteration result.\n    List<Integer> result = Lists.newArrayListWithCapacity(initial.size());\n    for (Iterator<Integer> iter = q.iterator(); iter.hasNext(); ) {\n        Integer value = iter.next();\n        result.add(value);\n        if (value == 8) {\n            iter.remove();\n        }\n    }\n    assertIntact(q);\n    assertThat(result).containsExactly(1, 15, 13, 8, 14);\n}", "repo_id": "5", "comment": "/**\n * Tests a failure caused by fix to childless uncle issue.\n */\n", "repo_name": "guava-master/", "id": 3955, "method_signature": "void testIteratorRegressionChildlessUncle()", "filename": "MinMaxPriorityQueueTest.testIteratorRegressionChildlessUncle.json"}
{"callee_method_names": ["MinMaxPriorityQueue<Integer>.isEmpty", "MinMaxPriorityQueue<Integer>.pollFirst", "List<Integer>.remove", "MinMaxPriorityQueue<Integer>.add", "List<Integer>.add", "MinMaxPriorityQueue<Integer>.add", "List<Integer>.add", "MinMaxPriorityQueue<Integer>.remove", "List<Integer>.remove", "MinMaxPriorityQueue<Integer>.poll", "List<Integer>.remove", "List<Integer>.add"], "method_name": "MinMaxPriorityQueueTest.testRegression_dataCorruption", "method_implementation": "{\n    int size = 8;\n    List<Integer> expected = createOrderedList(size);\n    MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create(expected);\n    List<Integer> contents = Lists.newArrayList(expected);\n    List<Integer> elements = Lists.newArrayListWithCapacity(size);\n    while (!q.isEmpty()) {\n        assertThat(q).containsExactlyElementsIn(contents);\n        Integer next = q.pollFirst();\n        contents.remove(next);\n        assertThat(q).containsExactlyElementsIn(contents);\n        for (int i = 0; i <= size; i++) {\n            q.add(i);\n            contents.add(i);\n            assertThat(q).containsExactlyElementsIn(contents);\n            q.add(next);\n            contents.add(next);\n            assertThat(q).containsExactlyElementsIn(contents);\n            q.remove(i);\n            assertTrue(contents.remove(Integer.valueOf(i)));\n            assertThat(q).containsExactlyElementsIn(contents);\n            assertEquals(next, q.poll());\n            contents.remove(next);\n            assertThat(q).containsExactlyElementsIn(contents);\n        }\n        elements.add(next);\n    }\n    assertEquals(expected, elements);\n}", "repo_id": "5", "comment": "/**\n * Regression test for b/4124577\n */\n", "repo_name": "guava-master/", "id": 3961, "method_signature": "void testRegression_dataCorruption()", "filename": "MinMaxPriorityQueueTest.testRegression_dataCorruption.json"}
{"callee_method_names": ["MinMaxPriorityQueue<Long>.remove", "MinMaxPriorityQueue<Long>.remove"], "method_name": "MinMaxPriorityQueueTest.testRemoveRegression", "method_implementation": "{\n    MinMaxPriorityQueue<Long> queue = MinMaxPriorityQueue.create(ImmutableList.of(2L, 3L, 0L, 4L, 1L));\n    queue.remove(4L);\n    queue.remove(1L);\n    assertThat(queue).doesNotContain(1L);\n}", "repo_id": "5", "comment": "/**\n * Regression test for https://github.com/google/guava/issues/2658\n */\n", "repo_name": "guava-master/", "id": 3962, "method_signature": "void testRemoveRegression()", "filename": "MinMaxPriorityQueueTest.testRemoveRegression.json"}
{"callee_method_names": ["ExecutorService.submit"], "method_name": "MockExecutor.invokeAny", "method_implementation": "{\n    assertTaskWrapped(tasks);\n    lastMethodCalled = \"invokeAny\";\n    return inline.submit(Iterables.get(tasks, 0)).get();\n}", "repo_id": "5", "comment": "// Define the invokeAny methods to invoke the first task\n", "repo_name": "guava-master/", "id": 3821, "method_signature": "T invokeAny(Collection)", "filename": "MockExecutor.invokeAny.json"}
{"callee_method_names": ["CountDownLatch.await", "ListenableFuture<?>.get", "String.getCause"], "method_name": "MockFutureListener.assertException", "method_implementation": "{\n    // Verify that the listener executed in a reasonable amount of time.\n    Assert.assertTrue(countDownLatch.await(1L, SECONDS));\n    try {\n        future.get();\n        Assert.fail(\"This call was supposed to throw an ExecutionException\");\n    } catch (ExecutionException expected) {\n        Assert.assertSame(expectedCause, expected.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Verify that the listener completes in a reasonable amount of time, and Asserts that the future\n * throws an {@code ExecutableException} and that the cause of the {@code ExecutableException} is\n * {@code expectedCause}.\n */\n", "repo_name": "guava-master/", "id": 4145, "method_signature": "void assertException(Throwable)", "filename": "MockFutureListener.assertException.json"}
{"callee_method_names": ["CountDownLatch.await", "ListenableFuture<?>.get", "UnicodeEscaper.getCause"], "method_name": "MockFutureListener.assertSuccess", "method_implementation": "{\n    // Verify that the listener executed in a reasonable amount of time.\n    Assert.assertTrue(countDownLatch.await(1L, SECONDS));\n    try {\n        Assert.assertEquals(expectedData, future.get());\n    } catch (ExecutionException e) {\n        throw e.getCause();\n    }\n}", "repo_id": "5", "comment": "/**\n * Verify that the listener completes in a reasonable amount of time, and Asserts that the future\n * returns the expected data.\n *\n * @throws Throwable if the listener isn't called or if it resulted in a throwable or if the\n *     result doesn't match the expected value.\n */\n", "repo_name": "guava-master/", "id": 4144, "method_signature": "void assertSuccess(Object)", "filename": "MockFutureListener.assertSuccess.json"}
{"callee_method_names": ["Guard.awaitNanos", "Guard.isSatisfied"], "method_name": "Monitor.awaitNanos", "method_implementation": "{\n    boolean firstTime = true;\n    try {\n        do {\n            if (nanos <= 0L) {\n                return false;\n            }\n            if (firstTime) {\n                if (signalBeforeWaiting) {\n                    signalNextWaiter();\n                }\n                beginWaitingFor(guard);\n                firstTime = false;\n            }\n            nanos = guard.condition.awaitNanos(nanos);\n        } while (!guard.isSatisfied());\n        return true;\n    } finally {\n        if (!firstTime) {\n            endWaitingFor(guard);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Caller should check before calling that guard is not satisfied.\n */\n", "repo_name": "guava-master/", "id": 5454, "method_signature": "boolean awaitNanos(Guard, long, boolean)", "filename": "Monitor.awaitNanos.json"}
{"callee_method_names": [], "method_name": "Monitor.beginWaitingFor", "method_implementation": "{\n    int waiters = guard.waiterCount++;\n    if (waiters == 0) {\n        // push guard onto activeGuards\n        guard.next = activeGuards;\n        activeGuards = guard;\n    }\n}", "repo_id": "5", "comment": "/**\n * Records that the current thread is about to wait on the specified guard.\n */\n", "repo_name": "guava-master/", "id": 5452, "method_signature": "void beginWaitingFor(Guard)", "filename": "Monitor.beginWaitingFor.json"}
{"callee_method_names": [], "method_name": "Monitor.endWaitingFor", "method_implementation": "{\n    int waiters = --guard.waiterCount;\n    if (waiters == 0) {\n        // unlink guard from activeGuards\n        for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next) {\n            if (p == guard) {\n                if (pred == null) {\n                    activeGuards = p.next;\n                } else {\n                    pred.next = p.next;\n                }\n                // help GC\n                p.next = null;\n                break;\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Records that the current thread is no longer waiting on the specified guard.\n */\n", "repo_name": "guava-master/", "id": 5453, "method_signature": "void endWaitingFor(Guard)", "filename": "Monitor.endWaitingFor.json"}
{"callee_method_names": ["ReentrantLock.tryLock", "ReentrantLock.tryLock"], "method_name": "Monitor.enter", "method_implementation": "{\n    final long timeoutNanos = toSafeNanos(time, unit);\n    final ReentrantLock lock = this.lock;\n    if (!fair && lock.tryLock()) {\n        return true;\n    }\n    boolean interrupted = Thread.interrupted();\n    try {\n        final long startTime = System.nanoTime();\n        for (long remainingNanos = timeoutNanos; ; ) {\n            try {\n                return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n            } catch (InterruptedException interrupt) {\n                interrupted = true;\n                remainingNanos = remainingNanos(startTime, timeoutNanos);\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Enters this monitor. Blocks at most the given time.\n *\n * @return whether the monitor was entered\n */\n", "repo_name": "guava-master/", "id": 5431, "method_signature": "boolean enter(long, TimeUnit)", "filename": "Monitor.enter.json"}
{"callee_method_names": ["Guard.isSatisfied", "ReentrantLock.unlock"], "method_name": "Monitor.enterIf", "method_implementation": "{\n    if (guard.monitor != this) {\n        throw new IllegalMonitorStateException();\n    }\n    if (!enter(time, unit)) {\n        return false;\n    }\n    boolean satisfied = false;\n    try {\n        return satisfied = guard.isSatisfied();\n    } finally {\n        if (!satisfied) {\n            lock.unlock();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n * lock, but does not wait for the guard to be satisfied.\n *\n * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n */\n", "repo_name": "guava-master/", "id": 5437, "method_signature": "boolean enterIf(Guard, long, TimeUnit)", "filename": "Monitor.enterIf.json"}
{"callee_method_names": ["ReentrantLock.tryLock", "Guard.isSatisfied", "ReentrantLock.unlock"], "method_name": "Monitor.enterIfInterruptibly", "method_implementation": "{\n    if (guard.monitor != this) {\n        throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    if (!lock.tryLock(time, unit)) {\n        return false;\n    }\n    boolean satisfied = false;\n    try {\n        return satisfied = guard.isSatisfied();\n    } finally {\n        if (!satisfied) {\n            lock.unlock();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n *\n * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n */\n", "repo_name": "guava-master/", "id": 5439, "method_signature": "boolean enterIfInterruptibly(Guard, long, TimeUnit)", "filename": "Monitor.enterIfInterruptibly.json"}
{"callee_method_names": ["ReentrantLock.isHeldByCurrentThread", "ReentrantLock.tryLock", "ReentrantLock.tryLock", "Guard.isSatisfied", "ReentrantLock.unlock"], "method_name": "Monitor.enterWhen", "method_implementation": "{\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (guard.monitor != this) {\n        throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean reentrant = lock.isHeldByCurrentThread();\n    long startTime = 0L;\n    locked: {\n        if (!fair) {\n            // Check interrupt status to get behavior consistent with fair case.\n            if (Thread.interrupted()) {\n                throw new InterruptedException();\n            }\n            if (lock.tryLock()) {\n                break locked;\n            }\n        }\n        startTime = initNanoTime(timeoutNanos);\n        if (!lock.tryLock(time, unit)) {\n            return false;\n        }\n    }\n    boolean satisfied = false;\n    boolean threw = true;\n    try {\n        satisfied = guard.isSatisfied() || awaitNanos(guard, (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos), reentrant);\n        threw = false;\n        return satisfied;\n    } finally {\n        if (!satisfied) {\n            try {\n                // Don't need to signal if timed out, but do if interrupted\n                if (threw && !reentrant) {\n                    signalNextWaiter();\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n * interrupted.\n *\n * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n * @throws InterruptedException if interrupted while waiting\n */\n", "repo_name": "guava-master/", "id": 5433, "method_signature": "boolean enterWhen(Guard, long, TimeUnit)", "filename": "Monitor.enterWhen.json"}
{"callee_method_names": ["ReentrantLock.isHeldByCurrentThread", "ReentrantLock.tryLock", "ReentrantLock.tryLock", "Guard.isSatisfied", "ReentrantLock.unlock"], "method_name": "Monitor.enterWhenUninterruptibly", "method_implementation": "{\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (guard.monitor != this) {\n        throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    long startTime = 0L;\n    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n    boolean interrupted = Thread.interrupted();\n    try {\n        if (fair || !lock.tryLock()) {\n            startTime = initNanoTime(timeoutNanos);\n            for (long remainingNanos = timeoutNanos; ; ) {\n                try {\n                    if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS)) {\n                        break;\n                    } else {\n                        return false;\n                    }\n                } catch (InterruptedException interrupt) {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        boolean satisfied = false;\n        try {\n            while (true) {\n                try {\n                    if (guard.isSatisfied()) {\n                        satisfied = true;\n                    } else {\n                        final long remainingNanos;\n                        if (startTime == 0L) {\n                            startTime = initNanoTime(timeoutNanos);\n                            remainingNanos = timeoutNanos;\n                        } else {\n                            remainingNanos = remainingNanos(startTime, timeoutNanos);\n                        }\n                        satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                    }\n                    return satisfied;\n                } catch (InterruptedException interrupt) {\n                    interrupted = true;\n                    signalBeforeWaiting = false;\n                }\n            }\n        } finally {\n            if (!satisfied) {\n                // No need to signal if timed out\n                lock.unlock();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n * the time to acquire the lock and the time to wait for the guard to be satisfied.\n *\n * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n */\n", "repo_name": "guava-master/", "id": 5435, "method_signature": "boolean enterWhenUninterruptibly(Guard, long, TimeUnit)", "filename": "Monitor.enterWhenUninterruptibly.json"}
{"callee_method_names": ["ReentrantLock.lock", "ReentrantLock.unlock"], "method_name": "Monitor.getWaitQueueLength", "method_implementation": "{\n    if (guard.monitor != this) {\n        throw new IllegalMonitorStateException();\n    }\n    lock.lock();\n    try {\n        return guard.waiterCount;\n    } finally {\n        lock.unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n * the system state, not for synchronization control.\n */\n", "repo_name": "guava-master/", "id": 5446, "method_signature": "int getWaitQueueLength(Guard)", "filename": "Monitor.getWaitQueueLength.json"}
{"callee_method_names": [], "method_name": "Monitor.initNanoTime", "method_implementation": "{\n    if (timeoutNanos <= 0L) {\n        return 0L;\n    } else {\n        long startTime = System.nanoTime();\n        return (startTime == 0L) ? 1L : startTime;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n * timeout has already elapsed.\n */\n", "repo_name": "guava-master/", "id": 5447, "method_signature": "long initNanoTime(long)", "filename": "Monitor.initNanoTime.json"}
{"callee_method_names": ["Guard.isSatisfied"], "method_name": "Monitor.isSatisfied", "method_implementation": "{\n    try {\n        return guard.isSatisfied();\n    } catch (Throwable throwable) {\n        // Any Exception is either a RuntimeException or sneaky checked exception.\n        signalAllWaiters();\n        throw throwable;\n    }\n}", "repo_id": "5", "comment": "/**\n * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n * unlikely) event that isSatisfied() throws.\n */\n", "repo_name": "guava-master/", "id": 5450, "method_signature": "boolean isSatisfied(Guard)", "filename": "Monitor.isSatisfied.json"}
{"callee_method_names": ["ReentrantLock.getHoldCount", "ReentrantLock.unlock"], "method_name": "Monitor.leave", "method_implementation": "{\n    final ReentrantLock lock = this.lock;\n    try {\n        // No need to signal if we will still be holding the lock when we return\n        if (lock.getHoldCount() == 1) {\n            signalNextWaiter();\n        }\n    } finally {\n        // Will throw IllegalMonitorStateException if not held\n        lock.unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Leaves this monitor. May be called only by a thread currently occupying this monitor.\n */\n", "repo_name": "guava-master/", "id": 5445, "method_signature": "void leave()", "filename": "Monitor.leave.json"}
{"callee_method_names": ["BooleanSupplier.getAsBoolean"], "method_name": "Monitor.newGuard", "method_implementation": "{\n    checkNotNull(isSatisfied, \"isSatisfied\");\n    return new Guard(this) {\n\n        @Override\n        public boolean isSatisfied() {\n            return isSatisfied.getAsBoolean();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@linkplain Guard guard} for this monitor.\n *\n * @param isSatisfied the new guard's boolean condition (see {@link Guard#isSatisfied\n *     isSatisfied()})\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 2043, "method_signature": "Guard newGuard(BooleanSupplier)", "filename": "Monitor.newGuard.json"}
{"callee_method_names": [], "method_name": "Monitor.remainingNanos", "method_implementation": "{\n    // assert timeoutNanos == 0L || startTime != 0L;\n    // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n    // if (true) return timeoutNanos;\n    // ONLY 2 TESTS FAIL IF WE DO:\n    // if (true) return 0;\n    return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n}", "repo_id": "5", "comment": "/**\n * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n */\n", "repo_name": "guava-master/", "id": 5448, "method_signature": "long remainingNanos(long, long)", "filename": "Monitor.remainingNanos.json"}
{"callee_method_names": ["Guard.signalAll"], "method_name": "Monitor.signalAllWaiters", "method_implementation": "{\n    for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n        guard.condition.signalAll();\n    }\n}", "repo_id": "5", "comment": "/**\n * Signals all threads waiting on guards.\n */\n", "repo_name": "guava-master/", "id": 5451, "method_signature": "void signalAllWaiters()", "filename": "Monitor.signalAllWaiters.json"}
{"callee_method_names": ["Guard.signal"], "method_name": "Monitor.signalNextWaiter", "method_implementation": "{\n    for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n        if (isSatisfied(guard)) {\n            guard.condition.signal();\n            break;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Signals some other thread waiting on a satisfied guard, if one exists.\n *\n * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n * the current thread is about to relinquish the lock and may have changed the state protected by\n * the monitor, thereby causing some guard to be satisfied.\n *\n * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n * since the concurrency control must manage multiple Conditions. So this method must generally be\n * called when waits are interrupted.\n *\n * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n * satisfied, it does *not* need to call this method before returning to wait. This can only\n * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n * current thread can and returning the guard to the unsatisfied state. In the latter case the\n * other thread (last thread modifying the state protected by the monitor) takes over the\n * responsibility of signalling the next waiter.\n *\n * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n */\n", "repo_name": "guava-master/", "id": 5449, "method_signature": "void signalNextWaiter()", "filename": "Monitor.signalNextWaiter.json"}
{"callee_method_names": ["ReentrantLock.tryLock", "Guard.isSatisfied", "ReentrantLock.unlock"], "method_name": "Monitor.tryEnterIf", "method_implementation": "{\n    if (guard.monitor != this) {\n        throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    if (!lock.tryLock()) {\n        return false;\n    }\n    boolean satisfied = false;\n    try {\n        return satisfied = guard.isSatisfied();\n    } finally {\n        if (!satisfied) {\n            lock.unlock();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n * block acquiring the lock and does not wait for the guard to be satisfied.\n *\n * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n *\n * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n */\n", "repo_name": "guava-master/", "id": 5440, "method_signature": "boolean tryEnterIf(Guard)", "filename": "Monitor.tryEnterIf.json"}
{"callee_method_names": ["ReentrantLock.isHeldByCurrentThread", "Guard.isSatisfied"], "method_name": "Monitor.waitFor", "method_implementation": "{\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (!((guard.monitor == this) && lock.isHeldByCurrentThread())) {\n        throw new IllegalMonitorStateException();\n    }\n    if (guard.isSatisfied()) {\n        return true;\n    }\n    if (Thread.interrupted()) {\n        throw new InterruptedException();\n    }\n    return awaitNanos(guard, timeoutNanos, true);\n}", "repo_id": "5", "comment": "/**\n * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n * be called only by a thread currently occupying this monitor.\n *\n * @return whether the guard is now satisfied\n * @throws InterruptedException if interrupted while waiting\n */\n", "repo_name": "guava-master/", "id": 5442, "method_signature": "boolean waitFor(Guard, long, TimeUnit)", "filename": "Monitor.waitFor.json"}
{"callee_method_names": ["ReentrantLock.isHeldByCurrentThread", "Guard.isSatisfied", "Guard.isSatisfied"], "method_name": "Monitor.waitForUninterruptibly", "method_implementation": "{\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (!((guard.monitor == this) && lock.isHeldByCurrentThread())) {\n        throw new IllegalMonitorStateException();\n    }\n    if (guard.isSatisfied()) {\n        return true;\n    }\n    boolean signalBeforeWaiting = true;\n    final long startTime = initNanoTime(timeoutNanos);\n    boolean interrupted = Thread.interrupted();\n    try {\n        for (long remainingNanos = timeoutNanos; ; ) {\n            try {\n                return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n            } catch (InterruptedException interrupt) {\n                interrupted = true;\n                if (guard.isSatisfied()) {\n                    return true;\n                }\n                signalBeforeWaiting = false;\n                remainingNanos = remainingNanos(startTime, timeoutNanos);\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n * thread currently occupying this monitor.\n *\n * @return whether the guard is now satisfied\n */\n", "repo_name": "guava-master/", "id": 5444, "method_signature": "boolean waitForUninterruptibly(Guard, long, TimeUnit)", "filename": "Monitor.waitForUninterruptibly.json"}
{"callee_method_names": [], "method_name": "MonitorBasedArrayBlockingQueue.add", "method_implementation": "{\n    return super.add(e);\n}", "repo_id": "5", "comment": "/**\n * Inserts the specified element at the tail of this queue if it is possible to do so immediately\n * without exceeding the queue's capacity, returning {@code true} upon success and throwing an\n * {@code IllegalStateException} if this queue is full.\n *\n * @param e the element to add\n * @return {@code true} (as specified by {@link Collection#add})\n * @throws IllegalStateException if this queue is full\n * @throws NullPointerException if the specified element is null\n */\n", "repo_name": "guava-master/", "id": 3494, "method_signature": "boolean add(E)", "filename": "MonitorBasedArrayBlockingQueue.add.json"}
{"callee_method_names": [], "method_name": "MonitorBasedArrayBlockingQueue.checkNext", "method_implementation": "{\n    if (nextIndex == putIndex) {\n        nextIndex = -1;\n        nextItem = null;\n    } else {\n        nextItem = items[nextIndex];\n        if (nextItem == null)\n            nextIndex = -1;\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks whether nextIndex is valid; if so setting nextItem. Stops iterator when either hits\n * putIndex or sees null item.\n */\n", "repo_name": "guava-master/", "id": 3508, "method_signature": "void checkNext()", "filename": "MonitorBasedArrayBlockingQueue.checkNext.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.clear", "method_implementation": "{\n    final E[] items = this.items;\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        int i = takeIndex;\n        int k = count;\n        while (k-- > 0) {\n            items[i] = null;\n            i = inc(i);\n        }\n        count = 0;\n        putIndex = 0;\n        takeIndex = 0;\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically removes all of the elements from this queue. The queue will be empty after this call\n * returns.\n */\n", "repo_name": "guava-master/", "id": 3504, "method_signature": "void clear()", "filename": "MonitorBasedArrayBlockingQueue.clear.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Object.equals", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.contains", "method_implementation": "{\n    if (o == null)\n        return false;\n    final E[] items = this.items;\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        int i = takeIndex;\n        int k = 0;\n        while (k++ < count) {\n            if (o.equals(items[i]))\n                return true;\n            i = inc(i);\n        }\n        return false;\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if this queue contains the specified element. More formally, returns\n * {@code true} if and only if this queue contains at least one element {@code e} such that {@code\n * o.equals(e)}.\n *\n * @param o object to be checked for containment in this queue\n * @return {@code true} if this queue contains the specified element\n */\n", "repo_name": "guava-master/", "id": 3501, "method_signature": "boolean contains(Object)", "filename": "MonitorBasedArrayBlockingQueue.contains.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Collection<? super E>.add", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.drainTo", "method_implementation": "{\n    if (c == null)\n        throw new NullPointerException();\n    if (c == this)\n        throw new IllegalArgumentException();\n    if (maxElements <= 0)\n        return 0;\n    final E[] items = this.items;\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        int i = takeIndex;\n        int n = 0;\n        int max = (maxElements < count) ? maxElements : count;\n        while (n < max) {\n            c.add(items[i]);\n            items[i] = null;\n            i = inc(i);\n            ++n;\n        }\n        if (n > 0) {\n            count -= n;\n            takeIndex = i;\n        }\n        return n;\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * @throws UnsupportedOperationException {@inheritDoc}\n * @throws ClassCastException {@inheritDoc}\n * @throws NullPointerException {@inheritDoc}\n * @throws IllegalArgumentException {@inheritDoc}\n */\n", "repo_name": "guava-master/", "id": 3506, "method_signature": "int drainTo(Collection, int)", "filename": "MonitorBasedArrayBlockingQueue.drainTo.json"}
{"callee_method_names": [], "method_name": "MonitorBasedArrayBlockingQueue.extract", "method_implementation": "{\n    final E[] items = this.items;\n    E x = items[takeIndex];\n    items[takeIndex] = null;\n    takeIndex = inc(takeIndex);\n    --count;\n    return x;\n}", "repo_id": "5", "comment": "/**\n * Extracts element at current take position, advances, and signals. Call only when occupying\n * monitor.\n */\n", "repo_name": "guava-master/", "id": 3492, "method_signature": "E extract()", "filename": "MonitorBasedArrayBlockingQueue.extract.json"}
{"callee_method_names": [], "method_name": "MonitorBasedArrayBlockingQueue.insert", "method_implementation": "{\n    items[putIndex] = x;\n    putIndex = inc(putIndex);\n    ++count;\n}", "repo_id": "5", "comment": "/**\n * Inserts element at current put position, advances, and signals. Call only when occupying\n * monitor.\n */\n", "repo_name": "guava-master/", "id": 3491, "method_signature": "void insert(E)", "filename": "MonitorBasedArrayBlockingQueue.insert.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.iterator", "method_implementation": "{\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        return new Itr();\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an iterator over the elements in this queue in proper sequence. The returned {@code\n * Iterator} is a \"weakly consistent\" iterator that will never throw {@link\n * ConcurrentModificationException}, and guarantees to traverse elements as they existed upon\n * construction of the iterator, and may (but is not guaranteed to) reflect any modifications\n * subsequent to construction.\n *\n * @return an iterator over the elements in this queue in proper sequence\n */\n", "repo_name": "guava-master/", "id": 3507, "method_signature": "Iterator<E> iterator()", "filename": "MonitorBasedArrayBlockingQueue.iterator.json"}
{"callee_method_ids": [5433, 5445], "callee_method_names": ["Monitor.enterWhen", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.offer", "method_implementation": "{\n    if (e == null)\n        throw new NullPointerException();\n    final Monitor monitor = this.monitor;\n    if (monitor.enterWhen(notFull, timeout, unit)) {\n        try {\n            insert(e);\n            return true;\n        } finally {\n            monitor.leave();\n        }\n    } else {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Inserts the specified element at the tail of this queue, waiting up to the specified wait time\n * for space to become available if the queue is full.\n *\n * @throws InterruptedException {@inheritDoc}\n * @throws NullPointerException {@inheritDoc}\n */\n", "repo_name": "guava-master/", "id": 3496, "method_signature": "boolean offer(E, long, TimeUnit)", "filename": "MonitorBasedArrayBlockingQueue.offer.json"}
{"callee_method_ids": [5433, 5445], "callee_method_names": ["Monitor.enterWhen", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.put", "method_implementation": "{\n    if (e == null)\n        throw new NullPointerException();\n    final Monitor monitor = this.monitor;\n    monitor.enterWhen(notFull);\n    try {\n        insert(e);\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Inserts the specified element at the tail of this queue, waiting for space to become available\n * if the queue is full.\n *\n * @throws InterruptedException {@inheritDoc}\n * @throws NullPointerException {@inheritDoc}\n */\n", "repo_name": "guava-master/", "id": 3497, "method_signature": "void put(E)", "filename": "MonitorBasedArrayBlockingQueue.put.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.remainingCapacity", "method_implementation": "{\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        return items.length - count;\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the number of additional elements that this queue can ideally (in the absence of memory\n * or resource constraints) accept without blocking. This is always equal to the initial capacity\n * of this queue less the current {@code size} of this queue.\n *\n * <p>Note that you <em>cannot</em> always tell if an attempt to insert an element will succeed by\n * inspecting {@code remainingCapacity} because it may be the case that another thread is about to\n * insert or remove an element.\n */\n", "repo_name": "guava-master/", "id": 3499, "method_signature": "int remainingCapacity()", "filename": "MonitorBasedArrayBlockingQueue.remainingCapacity.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Object.equals", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.remove", "method_implementation": "{\n    if (o == null)\n        return false;\n    final E[] items = this.items;\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        int i = takeIndex;\n        int k = 0;\n        for (; ; ) {\n            if (k++ >= count)\n                return false;\n            if (o.equals(items[i])) {\n                removeAt(i);\n                return true;\n            }\n            i = inc(i);\n        }\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes a single instance of the specified element from this queue, if it is present. More\n * formally, removes an element {@code e} such that {@code o.equals(e)}, if this queue contains\n * one or more such elements. Returns {@code true} if this queue contained the specified element\n * (or equivalently, if this queue changed as a result of the call).\n *\n * @param o element to be removed from this queue, if present\n * @return {@code true} if this queue changed as a result of the call\n */\n", "repo_name": "guava-master/", "id": 3500, "method_signature": "boolean remove(Object)", "filename": "MonitorBasedArrayBlockingQueue.remove.json"}
{"callee_method_names": [], "method_name": "MonitorBasedArrayBlockingQueue.removeAt", "method_implementation": "{\n    final E[] items = this.items;\n    // if removing front item, just advance\n    if (i == takeIndex) {\n        items[takeIndex] = null;\n        takeIndex = inc(takeIndex);\n    } else {\n        // slide over all others up through putIndex.\n        for (; ; ) {\n            int nexti = inc(i);\n            if (nexti != putIndex) {\n                items[i] = items[nexti];\n                i = nexti;\n            } else {\n                items[i] = null;\n                putIndex = i;\n                break;\n            }\n        }\n    }\n    --count;\n}", "repo_id": "5", "comment": "/**\n * Utility for remove and iterator.remove: Delete item at position i. Call only when occupying\n * monitor.\n */\n", "repo_name": "guava-master/", "id": 3493, "method_signature": "void removeAt(int)", "filename": "MonitorBasedArrayBlockingQueue.removeAt.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.size", "method_implementation": "{\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        return count;\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the number of elements in this queue.\n *\n * @return the number of elements in this queue\n */\n", "repo_name": "guava-master/", "id": 3498, "method_signature": "int size()", "filename": "MonitorBasedArrayBlockingQueue.size.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Monitor.leave"], "method_name": "MonitorBasedArrayBlockingQueue.toArray", "method_implementation": "{\n    final E[] items = this.items;\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        if (a.length < count)\n            a = ObjectArrays.newArray(a, count);\n        int k = 0;\n        int i = takeIndex;\n        while (k < count) {\n            // This cast is not itself safe, but the following statement\n            // will fail if the runtime type of items[i] is not assignable\n            // to the runtime type of a[k++], which is all that the method\n            // contract requires (see @throws ArrayStoreException above).\n            @SuppressWarnings(\"unchecked\")\n            T t = (T) items[i];\n            a[k++] = t;\n            i = inc(i);\n        }\n        if (a.length > count)\n            a[count] = null;\n        return a;\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing all of the elements in this queue, in proper sequence; the runtime\n * type of the returned array is that of the specified array. If the queue fits in the specified\n * array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the\n * specified array and the size of this queue.\n *\n * <p>If this queue fits in the specified array with room to spare (i.e., the array has more\n * elements than this queue), the element in the array immediately following the end of the queue\n * is set to {@code null}.\n *\n * <p>Like the {@link #toArray()} method, this method acts as bridge between array-based and\n * collection-based APIs. Further, this method allows precise control over the runtime type of the\n * output array, and may, under certain circumstances, be used to save allocation costs.\n *\n * <p>Suppose {@code x} is a queue known to contain only strings. The following code can be used\n * to dump the queue into a newly allocated array of {@code String}:\n *\n * <pre>\n *     String[] y = x.toArray(new String[0]);</pre>\n *\n * <p>Note that {@code toArray(new Object[0])} is identical in function to {@code toArray()}.\n *\n * @param a the array into which the elements of the queue are to be stored, if it is big enough;\n *     otherwise, a new array of the same runtime type is allocated for this purpose\n * @return an array containing all of the elements in this queue\n * @throws ArrayStoreException if the runtime type of the specified array is not a supertype of\n *     the runtime type of every element in this queue\n * @throws NullPointerException if the specified array is null\n */\n", "repo_name": "guava-master/", "id": 3503, "method_signature": "T[] toArray(T[])", "filename": "MonitorBasedArrayBlockingQueue.toArray.json"}
{"callee_method_names": [], "method_name": "MonitorBasedPriorityBlockingQueue.add", "method_implementation": "{\n    return offer(e);\n}", "repo_id": "5", "comment": "/**\n * Inserts the specified element into this priority queue.\n *\n * @param e the element to add\n * @return {@code true} (as specified by {@link Collection#add})\n * @throws ClassCastException if the specified element cannot be compared with elements currently\n *     in the priority queue according to the priority queue's ordering\n * @throws NullPointerException if the specified element is null\n */\n", "repo_name": "guava-master/", "id": 3510, "method_signature": "boolean add(E)", "filename": "MonitorBasedPriorityBlockingQueue.add.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "PriorityQueue<E>.clear", "Monitor.leave"], "method_name": "MonitorBasedPriorityBlockingQueue.clear", "method_implementation": "{\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        q.clear();\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Atomically removes all of the elements from this queue. The queue will be empty after this call\n * returns.\n */\n", "repo_name": "guava-master/", "id": 3520, "method_signature": "void clear()", "filename": "MonitorBasedPriorityBlockingQueue.clear.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "PriorityQueue<E>.contains", "Monitor.leave"], "method_name": "MonitorBasedPriorityBlockingQueue.contains", "method_implementation": "{\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        return q.contains(o);\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if this queue contains the specified element. More formally, returns\n * {@code true} if and only if this queue contains at least one element {@code e} such that {@code\n * o.equals(e)}.\n *\n * @param o object to be checked for containment in this queue\n * @return {@code true} if this queue contains the specified element\n */\n", "repo_name": "guava-master/", "id": 3515, "method_signature": "boolean contains(Object)", "filename": "MonitorBasedPriorityBlockingQueue.contains.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "PriorityQueue<E>.poll", "Collection<? super E>.add", "Monitor.leave"], "method_name": "MonitorBasedPriorityBlockingQueue.drainTo", "method_implementation": "{\n    if (c == null)\n        throw new NullPointerException();\n    if (c == this)\n        throw new IllegalArgumentException();\n    if (maxElements <= 0)\n        return 0;\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        int n = 0;\n        E e;\n        while (n < maxElements && (e = q.poll()) != null) {\n            c.add(e);\n            ++n;\n        }\n        return n;\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * @throws UnsupportedOperationException {@inheritDoc}\n * @throws ClassCastException {@inheritDoc}\n * @throws NullPointerException {@inheritDoc}\n * @throws IllegalArgumentException {@inheritDoc}\n */\n", "repo_name": "guava-master/", "id": 3519, "method_signature": "int drainTo(Collection, int)", "filename": "MonitorBasedPriorityBlockingQueue.drainTo.json"}
{"callee_method_names": [], "method_name": "MonitorBasedPriorityBlockingQueue.iterator", "method_implementation": "{\n    return new Itr(toArray());\n}", "repo_id": "5", "comment": "/**\n * Returns an iterator over the elements in this queue. The iterator does not return the elements\n * in any particular order. The returned {@code Iterator} is a \"weakly consistent\" iterator that\n * will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements\n * as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect\n * any modifications subsequent to construction.\n *\n * @return an iterator over the elements in this queue\n */\n", "repo_name": "guava-master/", "id": 3521, "method_signature": "Iterator<E> iterator()", "filename": "MonitorBasedPriorityBlockingQueue.iterator.json"}
{"callee_method_names": [], "method_name": "MonitorBasedPriorityBlockingQueue.offer", "method_implementation": "{\n    checkNotNull(unit);\n    // never need to block\n    return offer(e);\n}", "repo_id": "5", "comment": "/**\n * Inserts the specified element into this priority queue. As the queue is unbounded this method\n * will never block.\n *\n * @param e the element to add\n * @param timeout This parameter is ignored as the method never blocks\n * @param unit This parameter is ignored as the method never blocks\n * @return {@code true}\n * @throws ClassCastException if the specified element cannot be compared with elements currently\n *     in the priority queue according to the priority queue's ordering\n * @throws NullPointerException if the specified element is null\n */\n", "repo_name": "guava-master/", "id": 3512, "method_signature": "boolean offer(E, long, TimeUnit)", "filename": "MonitorBasedPriorityBlockingQueue.offer.json"}
{"callee_method_names": [], "method_name": "MonitorBasedPriorityBlockingQueue.remainingCapacity", "method_implementation": "{\n    return Integer.MAX_VALUE;\n}", "repo_id": "5", "comment": "/**\n * Always returns {@code Integer.MAX_VALUE} because a {@code MonitorBasedPriorityBlockingQueue} is\n * not capacity constrained.\n *\n * @return {@code Integer.MAX_VALUE}\n */\n", "repo_name": "guava-master/", "id": 3513, "method_signature": "int remainingCapacity()", "filename": "MonitorBasedPriorityBlockingQueue.remainingCapacity.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "PriorityQueue<E>.remove", "Monitor.leave"], "method_name": "MonitorBasedPriorityBlockingQueue.remove", "method_implementation": "{\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        return q.remove(o);\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes a single instance of the specified element from this queue, if it is present. More\n * formally, removes an element {@code e} such that {@code o.equals(e)}, if this queue contains\n * one or more such elements. Returns {@code true} if and only if this queue contained the\n * specified element (or equivalently, if this queue changed as a result of the call).\n *\n * @param o element to be removed from this queue, if present\n * @return {@code true} if this queue changed as a result of the call\n */\n", "repo_name": "guava-master/", "id": 3514, "method_signature": "boolean remove(Object)", "filename": "MonitorBasedPriorityBlockingQueue.remove.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "PriorityQueue<E>.toArray", "Monitor.leave"], "method_name": "MonitorBasedPriorityBlockingQueue.toArray", "method_implementation": "{\n    final Monitor monitor = this.monitor;\n    monitor.enter();\n    try {\n        return q.toArray(a);\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing all of the elements in this queue; the runtime type of the returned\n * array is that of the specified array. The returned array elements are in no particular order.\n * If the queue fits in the specified array, it is returned therein. Otherwise, a new array is\n * allocated with the runtime type of the specified array and the size of this queue.\n *\n * <p>If this queue fits in the specified array with room to spare (i.e., the array has more\n * elements than this queue), the element in the array immediately following the end of the queue\n * is set to {@code null}.\n *\n * <p>Like the {@link #toArray()} method, this method acts as bridge between array-based and\n * collection-based APIs. Further, this method allows precise control over the runtime type of the\n * output array, and may, under certain circumstances, be used to save allocation costs.\n *\n * <p>Suppose {@code x} is a queue known to contain only strings. The following code can be used\n * to dump the queue into a newly allocated array of {@code String}:\n *\n * <pre>\n *     String[] y = x.toArray(new String[0]);</pre>\n *\n * <p>Note that {@code toArray(new Object[0])} is identical in function to {@code toArray()}.\n *\n * @param a the array into which the elements of the queue are to be stored, if it is big enough;\n *     otherwise, a new array of the same runtime type is allocated for this purpose\n * @return an array containing all of the elements in this queue\n * @throws ArrayStoreException if the runtime type of the specified array is not a supertype of\n *     the runtime type of every element in this queue\n * @throws NullPointerException if the specified array is null\n */\n", "repo_name": "guava-master/", "id": 3517, "method_signature": "T[] toArray(T[])", "filename": "MonitorBasedPriorityBlockingQueue.toArray.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "java.io.ObjectOutputStream.defaultWriteObject", "Monitor.leave"], "method_name": "MonitorBasedPriorityBlockingQueue.writeObject", "method_implementation": "{\n    monitor.enter();\n    try {\n        s.defaultWriteObject();\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Saves the state to a stream (that is, serializes it). This merely wraps default serialization\n * within the monitor. The serialization strategy for items is left to underlying Queue. Note that\n * locking is not needed on deserialization, so readObject is not defined, just relying on\n * default.\n */\n", "repo_name": "guava-master/", "id": 3522, "method_signature": "void writeObject(java.io.ObjectOutputStream)", "filename": "MonitorBasedPriorityBlockingQueue.writeObject.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.addDelayedShutdownHook", "method_implementation": "{\n    new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n}", "repo_id": "5", "comment": "/**\n * Add a shutdown hook to wait for thread completion in the given {@link ExecutorService service}.\n * This is useful if the given service uses daemon threads, and we want to keep the JVM from\n * exiting immediately on shutdown, instead giving these daemon threads a chance to terminate\n * normally.\n *\n * @param service ExecutorService which uses daemon threads\n * @param terminationTimeout how long to wait for the executor to finish before terminating the\n *     JVM\n * @param timeUnit unit of time for the time parameter\n */\n", "repo_name": "guava-master/", "id": 5258, "method_signature": "void addDelayedShutdownHook(ExecutorService, long, TimeUnit)", "filename": "MoreExecutors.addDelayedShutdownHook.json"}
{"callee_method_names": ["Object.notifyAll"], "method_name": "MoreExecutors.endTask", "method_implementation": "{\n    synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n            lock.notifyAll();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Decrements the running task count.\n */\n", "repo_name": "guava-master/", "id": 5261, "method_signature": "void endTask()", "filename": "MoreExecutors.endTask.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.getExitingExecutorService", "method_implementation": "{\n    return new Application().getExitingExecutorService(executor);\n}", "repo_id": "5", "comment": "/**\n * Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application\n * is complete. It does so by using daemon threads and adding a shutdown hook to wait for their\n * completion.\n *\n * <p>This method waits 120 seconds before continuing with JVM termination, even if the executor\n * has not finished its work.\n *\n * <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}.\n *\n * @param executor the executor to modify to make sure it exits when the application is finished\n * @return an unmodifiable version of the input which will not hang the JVM\n */\n", "repo_name": "guava-master/", "id": 5255, "method_signature": "ExecutorService getExitingExecutorService(ThreadPoolExecutor)", "filename": "MoreExecutors.getExitingExecutorService.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.getExitingScheduledExecutorService", "method_implementation": "{\n    return new Application().getExitingScheduledExecutorService(executor);\n}", "repo_id": "5", "comment": "/**\n * Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when\n * the application is complete. It does so by using daemon threads and adding a shutdown hook to\n * wait for their completion.\n *\n * <p>This method waits 120 seconds before continuing with JVM termination, even if the executor\n * has not finished its work.\n *\n * <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}.\n *\n * @param executor the executor to modify to make sure it exits when the application is finished\n * @return an unmodifiable version of the input which will not hang the JVM\n */\n", "repo_name": "guava-master/", "id": 5257, "method_signature": "ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor)", "filename": "MoreExecutors.getExitingScheduledExecutorService.json"}
{"callee_method_names": ["Collection<? extends Callable<T>>.size", "TimeUnit.toNanos", "Collection<? extends Callable<T>>.iterator", "List<Future<T>>.add", "Iterator<? extends Callable<T>>.next", "BlockingQueue<Future<T>>.poll", "List<Future<T>>.add", "Iterator<? extends Callable<T>>.next", "BlockingQueue<Future<T>>.poll", "BlockingQueue<Future<T>>.take", "Future<T>.get", "Future<T>.cancel"], "method_name": "MoreExecutors.invokeAnyImpl", "method_implementation": "{\n    checkNotNull(executorService);\n    checkNotNull(unit);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n    long timeoutNanos = unit.toNanos(timeout);\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n    try {\n        // Record exceptions so that if we fail to obtain any\n        // result, we can throw the last exception we got.\n        ExecutionException ee = null;\n        long lastTime = timed ? System.nanoTime() : 0;\n        Iterator<? extends Callable<T>> it = tasks.iterator();\n        futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n        --ntasks;\n        int active = 1;\n        while (true) {\n            Future<T> f = futureQueue.poll();\n            if (f == null) {\n                if (ntasks > 0) {\n                    --ntasks;\n                    futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n                    ++active;\n                } else if (active == 0) {\n                    break;\n                } else if (timed) {\n                    f = futureQueue.poll(timeoutNanos, TimeUnit.NANOSECONDS);\n                    if (f == null) {\n                        throw new TimeoutException();\n                    }\n                    long now = System.nanoTime();\n                    timeoutNanos -= now - lastTime;\n                    lastTime = now;\n                } else {\n                    f = futureQueue.take();\n                }\n            }\n            if (f != null) {\n                --active;\n                try {\n                    return f.get();\n                } catch (ExecutionException eex) {\n                    ee = eex;\n                } catch (InterruptedException iex) {\n                    throw iex;\n                } catch (Exception rex) {\n                    // sneaky checked exception\n                    ee = new ExecutionException(rex);\n                }\n            }\n        }\n        if (ee == null) {\n            ee = new ExecutionException(null);\n        }\n        throw ee;\n    } finally {\n        for (Future<T> f : futures) {\n            f.cancel(true);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n * implementations.\n */\n", "repo_name": "guava-master/", "id": 5266, "method_signature": "T invokeAnyImpl(ListeningExecutorService, Collection, boolean, long, TimeUnit)", "filename": "MoreExecutors.invokeAnyImpl.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.listeningDecorator", "method_implementation": "{\n    return (delegate instanceof ListeningScheduledExecutorService) ? (ListeningScheduledExecutorService) delegate : new ScheduledListeningDecorator(delegate);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code invokeAll} methods\n * submit {@link ListenableFutureTask} instances to the given delegate executor. Those methods, as\n * well as {@code execute} and {@code invokeAny}, are implemented in terms of calls to {@code\n * delegate.execute}. All other methods are forwarded unchanged to the delegate. This implies that\n * the returned {@code ListeningScheduledExecutorService} never calls the delegate's {@code\n * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special handling of tasks\n * must be implemented in the delegate's {@code execute} method or by wrapping the returned {@code\n * ListeningScheduledExecutorService}.\n *\n * <p>If the delegate executor was already an instance of {@code\n * ListeningScheduledExecutorService}, it is returned untouched, and the rest of this\n * documentation does not apply.\n *\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5265, "method_signature": "ListeningScheduledExecutorService listeningDecorator(ScheduledExecutorService)", "filename": "MoreExecutors.listeningDecorator.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.newDirectExecutorService", "method_implementation": "{\n    return new DirectExecutorService();\n}", "repo_id": "5", "comment": "/**\n * Creates an executor service that runs each task in the thread that invokes {@code\n * execute/submit}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}. This applies both to\n * individually submitted tasks and to collections of tasks submitted via {@code invokeAll} or\n * {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are\n * run to completion before a {@code Future} is returned to the caller (unless the executor has\n * been shutdown).\n *\n * <p>Although all tasks are immediately executed in the thread that submitted the task, this\n * {@code ExecutorService} imposes a small locking overhead on each task submission in order to\n * implement shutdown and termination behavior.\n *\n * <p>The implementation deviates from the {@code ExecutorService} specification with regards to\n * the {@code shutdownNow} method. First, \"best-effort\" with regards to canceling running tasks is\n * implemented as \"no-effort\". No interrupts or other attempts are made to stop threads executing\n * tasks. Second, the returned list will always be empty, as any submitted task is considered to\n * have started execution. This applies also to tasks given to {@code invokeAll} or {@code\n * invokeAny} which are pending serial execution, even the subset of the tasks that have not yet\n * started execution. It is unclear from the {@code ExecutorService} specification if these should\n * be included, and it's much easier to implement the interpretation that they not be. Finally, a\n * call to {@code shutdown} or {@code shutdownNow} may result in concurrent calls to {@code\n * invokeAll/invokeAny} throwing RejectedExecutionException, although a subset of the tasks may\n * already have been executed.\n *\n * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n */\n", "repo_name": "guava-master/", "id": 5262, "method_signature": "ListeningExecutorService newDirectExecutorService()", "filename": "MoreExecutors.newDirectExecutorService.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.newSequentialExecutor", "method_implementation": "{\n    return new SequentialExecutor(delegate);\n}", "repo_id": "5", "comment": "/**\n * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n * are running concurrently.\n *\n * <p>{@linkplain Executor#execute executed} tasks have a happens-before order as defined in the\n * Java Language Specification. Tasks execute with the same happens-before order that the function\n * calls to {@link Executor#execute `execute()`} that submitted those tasks had.\n *\n * <p>The executor uses {@code delegate} in order to {@link Executor#execute execute} each task in\n * turn, and does not create any threads of its own.\n *\n * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n * polled and executed from a task queue until there are no more tasks. The thread will not be\n * released until there are no more tasks to run.\n *\n * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n * will not be released until that submitted task is also complete.\n *\n * <p>If a task is {@linkplain Thread#interrupt interrupted} while a task is running:\n *\n * <ol>\n *   <li>execution will not stop until the task queue is empty.\n *   <li>tasks will begin execution with the thread marked as not interrupted - any interruption\n *       applies only to the task that was running at the point of interruption.\n *   <li>if the thread was interrupted before the SequentialExecutor's worker begins execution,\n *       the interrupt will be restored to the thread after it completes so that its {@code\n *       delegate} Executor may process the interrupt.\n *   <li>subtasks are run with the thread uninterrupted and interrupts received during execution\n *       of a task are ignored.\n * </ol>\n *\n * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n * time a task is submitted.\n *\n * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n * Executors#newSingleThreadExecutor}).\n *\n * @since 23.3 (since 23.1 as {@code sequentialExecutor})\n */\n", "repo_name": "guava-master/", "id": 5263, "method_signature": "Executor newSequentialExecutor(Executor)", "filename": "MoreExecutors.newSequentialExecutor.json"}
{"callee_method_names": ["Thread.setName"], "method_name": "MoreExecutors.newThread", "method_implementation": "{\n    checkNotNull(name);\n    checkNotNull(runnable);\n    // TODO(b/139726489): Confirm that null is impossible here.\n    Thread result = requireNonNull(platformThreadFactory().newThread(runnable));\n    try {\n        result.setName(name);\n    } catch (SecurityException e) {\n        // OK if we can't set the name in this environment.\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name} unless\n * changing the name is forbidden by the security manager.\n */\n", "repo_name": "guava-master/", "id": 5269, "method_signature": "Thread newThread(String, Runnable)", "filename": "MoreExecutors.newThread.json"}
{"callee_method_names": ["Entry<?, ?>.getCause"], "method_name": "MoreExecutors.platformThreadFactory", "method_implementation": "{\n    if (!isAppEngineWithApiClasses()) {\n        return Executors.defaultThreadFactory();\n    }\n    try {\n        return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\").getMethod(\"currentRequestThreadFactory\").invoke(null);\n        /*\n       * Do not merge the 3 catch blocks below. javac would infer a type of\n       * ReflectiveOperationException, which Animal Sniffer would reject. (Old versions of Android\n       * don't *seem* to mind, but there might be edge cases of which we're unaware.)\n       */\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n        throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n        throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n        throw Throwables.propagate(e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a default thread factory used to create new threads.\n *\n * <p>When running on AppEngine with access to <a\n * href=\"https://cloud.google.com/appengine/docs/standard/java/javadoc/\">AppEngine legacy\n * APIs</a>, this method returns {@code ThreadManager.currentRequestThreadFactory()}. Otherwise,\n * it returns {@link Executors#defaultThreadFactory()}.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 5268, "method_signature": "ThreadFactory platformThreadFactory()", "filename": "MoreExecutors.platformThreadFactory.json"}
{"callee_method_names": ["Executor.execute", "AbstractFuture<?>.setException"], "method_name": "MoreExecutors.rejectionPropagatingExecutor", "method_implementation": "{\n    checkNotNull(delegate);\n    checkNotNull(future);\n    if (delegate == directExecutor()) {\n        // directExecutor() cannot throw RejectedExecutionException\n        return delegate;\n    }\n    return new Executor() {\n\n        @Override\n        public void execute(Runnable command) {\n            try {\n                delegate.execute(command);\n            } catch (RejectedExecutionException e) {\n                future.setException(e);\n            }\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an Executor that will propagate {@link RejectedExecutionException} from the delegate\n * executor to the given {@code future}.\n *\n * <p>Note, the returned executor can only be used once.\n */\n", "repo_name": "guava-master/", "id": 5274, "method_signature": "Executor rejectionPropagatingExecutor(Executor, AbstractFuture)", "filename": "MoreExecutors.rejectionPropagatingExecutor.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.renamingDecorator", "method_implementation": "{\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    return new WrappingScheduledExecutorService(service) {\n\n        @Override\n        protected <T extends @Nullable Object> Callable<T> wrapTask(Callable<T> callable) {\n            return Callables.threadRenaming(callable, nameSupplier);\n        }\n\n        @Override\n        protected Runnable wrapTask(Runnable command) {\n            return Callables.threadRenaming(command, nameSupplier);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n * tasks run in.\n *\n * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n * right before each task is run. The renaming is best effort, if a {@link SecurityManager}\n * prevents the renaming then it will be skipped but the tasks will still execute.\n *\n * @param service The executor to decorate\n * @param nameSupplier The source of names for each task\n */\n", "repo_name": "guava-master/", "id": 5272, "method_signature": "ScheduledExecutorService renamingDecorator(ScheduledExecutorService, Supplier)", "filename": "MoreExecutors.renamingDecorator.json"}
{"callee_method_names": ["TimeUnit.toNanos", "ExecutorService.shutdown", "ExecutorService.awaitTermination", "ExecutorService.shutdownNow", "ExecutorService.awaitTermination", "ExecutorService.shutdownNow", "ExecutorService.isTerminated"], "method_name": "MoreExecutors.shutdownAndAwaitTermination", "method_implementation": "{\n    long halfTimeoutNanos = unit.toNanos(timeout) / 2;\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n        // Wait for half the duration of the timeout for existing tasks to terminate\n        if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n            // Cancel currently executing tasks\n            service.shutdownNow();\n            // Wait the other half of the timeout for tasks to respond to being cancelled\n            service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n        }\n    } catch (InterruptedException ie) {\n        // Preserve interrupt status\n        Thread.currentThread().interrupt();\n        // (Re-)Cancel if current thread also interrupted\n        service.shutdownNow();\n    }\n    return service.isTerminated();\n}", "repo_id": "5", "comment": "/**\n * Shuts down the given executor service gradually, first disabling new submissions and later, if\n * necessary, cancelling remaining tasks.\n *\n * <p>The method takes the following steps:\n *\n * <ol>\n *   <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n *   <li>awaits executor service termination for half of the specified timeout.\n *   <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n *       pending tasks and interrupting running tasks.\n *   <li>awaits executor service termination for the other half of the specified timeout.\n * </ol>\n *\n * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n * ExecutorService#shutdownNow()} and returns.\n *\n * @param service the {@code ExecutorService} to shut down\n * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n * @param unit the time unit of the timeout argument\n * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n *     if the call timed out or was interrupted\n * @since 17.0\n */\n", "repo_name": "guava-master/", "id": 5273, "method_signature": "boolean shutdownAndAwaitTermination(ExecutorService, long, TimeUnit)", "filename": "MoreExecutors.shutdownAndAwaitTermination.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.shutdownNow", "method_implementation": "{\n    shutdown();\n    return Collections.emptyList();\n}", "repo_id": "5", "comment": "// See newDirectExecutorService javadoc for unusual behavior of this method.\n", "repo_name": "guava-master/", "id": 5259, "method_signature": "List<Runnable> shutdownNow()", "filename": "MoreExecutors.shutdownNow.json"}
{"callee_method_names": [], "method_name": "MoreExecutors.startTask", "method_implementation": "{\n    synchronized (lock) {\n        if (shutdown) {\n            throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks if the executor has been shut down and increments the running task count.\n *\n * @throws RejectedExecutionException if the executor has been previously shutdown\n */\n", "repo_name": "guava-master/", "id": 5260, "method_signature": "void startTask()", "filename": "MoreExecutors.startTask.json"}
{"callee_method_names": ["ListeningExecutorService.submit", "ListenableFuture<T>.addListener", "BlockingQueue<Future<T>>.add"], "method_name": "MoreExecutors.submitAndAddQueueListener", "method_implementation": "{\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n\n        @Override\n        public void run() {\n            queue.add(future);\n        }\n    }, directExecutor());\n    return future;\n}", "repo_id": "5", "comment": "/**\n * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n */\n", "repo_name": "guava-master/", "id": 5267, "method_signature": "ListenableFuture<T> submitAndAddQueueListener(ListeningExecutorService, Callable, BlockingQueue)", "filename": "MoreExecutors.submitAndAddQueueListener.json"}
{"callee_method_names": ["Thread.getState"], "method_name": "MoreExecutorsTest.awaitTimedWaiting", "method_implementation": "{\n    while (true) {\n        switch(thread.getState()) {\n            case BLOCKED:\n            case NEW:\n            case RUNNABLE:\n            case WAITING:\n                Thread.yield();\n                break;\n            case TIMED_WAITING:\n                return;\n            case TERMINATED:\n            default:\n                throw new AssertionError();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Wait for the given thread to reach the {@link State#TIMED_WAITING} thread state.\n */\n", "repo_name": "guava-master/", "id": 3866, "method_signature": "void awaitTimedWaiting(Thread)", "filename": "MoreExecutorsTest.awaitTimedWaiting.json"}
{"callee_method_names": ["ExecutorService.awaitTermination", "Thread.start", "ExecutorService.shutdown", "Thread.isAlive", "Thread.interrupt"], "method_name": "MoreExecutorsTest.testDirectExecutorService_awaitTermination_missedSignal", "method_implementation": "{\n    final ExecutorService service = MoreExecutors.newDirectExecutorService();\n    Thread waiter = new Thread() {\n\n        @Override\n        public void run() {\n            try {\n                service.awaitTermination(1, TimeUnit.DAYS);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    };\n    waiter.start();\n    awaitTimedWaiting(waiter);\n    service.shutdown();\n    Uninterruptibles.joinUninterruptibly(waiter, 10, TimeUnit.SECONDS);\n    if (waiter.isAlive()) {\n        waiter.interrupt();\n        fail(\"awaitTermination failed to trigger after shutdown()\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Test for a bug where threads weren't getting signaled when shutdown was called, only when tasks\n * completed.\n */\n", "repo_name": "guava-master/", "id": 3865, "method_signature": "void testDirectExecutorService_awaitTermination_missedSignal()", "filename": "MoreExecutorsTest.testDirectExecutorService_awaitTermination_missedSignal.json"}
{"callee_method_names": ["List<Callable<String>>.add", "List<Callable<String>>.add"], "method_name": "MoreExecutorsTest.testInvokeAnyImpl", "method_implementation": "{\n    ListeningExecutorService e = newDirectExecutorService();\n    try {\n        List<Callable<String>> l = new ArrayList<>();\n        l.add(new StringTask());\n        l.add(new StringTask());\n        String result = invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);\n        assertSame(TEST_STRING, result);\n    } finally {\n        joinPool(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * invokeAny(c) returns result of some task in c if at least one completes\n */\n", "repo_name": "guava-master/", "id": 3871, "method_signature": "void testInvokeAnyImpl()", "filename": "MoreExecutorsTest.testInvokeAnyImpl.json"}
{"callee_method_names": [], "method_name": "MoreExecutorsTest.testInvokeAnyImpl_emptyTasks", "method_implementation": "{\n    ListeningExecutorService e = newDirectExecutorService();\n    try {\n        invokeAnyImpl(e, new ArrayList<Callable<String>>(), false, 0, TimeUnit.NANOSECONDS);\n        fail();\n    } catch (IllegalArgumentException success) {\n    } finally {\n        joinPool(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * invokeAny(empty collection) throws IAE\n */\n", "repo_name": "guava-master/", "id": 3868, "method_signature": "void testInvokeAnyImpl_emptyTasks()", "filename": "MoreExecutorsTest.testInvokeAnyImpl_emptyTasks.json"}
{"callee_method_names": ["List<Callable<String>>.add"], "method_name": "MoreExecutorsTest.testInvokeAnyImpl_noTaskCompletes", "method_implementation": "{\n    ListeningExecutorService e = newDirectExecutorService();\n    List<Callable<String>> l = new ArrayList<>();\n    l.add(new NPETask());\n    try {\n        invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);\n        fail();\n    } catch (ExecutionException success) {\n        assertThat(success).hasCauseThat().isInstanceOf(NullPointerException.class);\n    } finally {\n        joinPool(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * invokeAny(c) throws ExecutionException if no task in c completes\n */\n", "repo_name": "guava-master/", "id": 3870, "method_signature": "void testInvokeAnyImpl_noTaskCompletes()", "filename": "MoreExecutorsTest.testInvokeAnyImpl_noTaskCompletes.json"}
{"callee_method_names": ["List<Callable<Integer>>.add", "List<Callable<Integer>>.add"], "method_name": "MoreExecutorsTest.testInvokeAnyImpl_nullElement", "method_implementation": "{\n    ListeningExecutorService e = newDirectExecutorService();\n    List<Callable<Integer>> l = new ArrayList<>();\n    l.add(new Callable<Integer>() {\n\n        @Override\n        public Integer call() {\n            throw new ArithmeticException(\"/ by zero\");\n        }\n    });\n    l.add(null);\n    try {\n        invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);\n        fail();\n    } catch (NullPointerException success) {\n    } finally {\n        joinPool(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * invokeAny(c) throws NPE if c has null elements\n */\n", "repo_name": "guava-master/", "id": 3869, "method_signature": "void testInvokeAnyImpl_nullElement()", "filename": "MoreExecutorsTest.testInvokeAnyImpl_nullElement.json"}
{"callee_method_names": [], "method_name": "MoreExecutorsTest.testInvokeAnyImpl_nullTasks", "method_implementation": "{\n    ListeningExecutorService e = newDirectExecutorService();\n    try {\n        invokeAnyImpl(e, null, false, 0, TimeUnit.NANOSECONDS);\n        fail();\n    } catch (NullPointerException success) {\n    } finally {\n        joinPool(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * invokeAny(null) throws NPE\n */\n", "repo_name": "guava-master/", "id": 3867, "method_signature": "void testInvokeAnyImpl_nullTasks()", "filename": "MoreExecutorsTest.testInvokeAnyImpl_nullTasks.json"}
{"callee_method_names": ["Collection<IOException>.add"], "method_name": "MoreFiles.addException", "method_implementation": "{\n    if (exceptions == null) {\n        // don't need Set semantics\n        exceptions = new ArrayList<>();\n    }\n    exceptions.add(e);\n    return exceptions;\n}", "repo_id": "5", "comment": "/**\n * Adds the given exception to the given collection, creating the collection if it's null. Returns\n * the collection.\n */\n", "repo_name": "guava-master/", "id": 1395, "method_signature": "Collection<IOException> addException(Collection, IOException)", "filename": "MoreFiles.addException.json"}
{"callee_method_names": ["Path.toString"], "method_name": "MoreFiles.checkAllowsInsecure", "method_implementation": "{\n    if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {\n        throw new InsecureRecursiveDeleteException(path.toString());\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks that the given options allow an insecure delete, throwing an exception if not.\n */\n", "repo_name": "guava-master/", "id": 1394, "method_signature": "void checkAllowsInsecure(Path, RecursiveDeleteOption[])", "filename": "MoreFiles.checkAllowsInsecure.json"}
{"callee_method_names": ["Collection<IOException>.addAll"], "method_name": "MoreFiles.concat", "method_implementation": "{\n    if (exceptions == null) {\n        return other;\n    } else if (other != null) {\n        exceptions.addAll(other);\n    }\n    return exceptions;\n}", "repo_id": "5", "comment": "/**\n * Concatenates the contents of the two given collections of exceptions. If either collection is\n * null, the other collection is returned. Otherwise, the elements of {@code other} are added to\n * {@code exceptions} and {@code exceptions} is returned.\n */\n", "repo_name": "guava-master/", "id": 1396, "method_signature": "Collection<IOException> concat(Collection, Collection)", "filename": "MoreFiles.concat.json"}
{"callee_method_names": ["Path.toAbsolutePath", "Path.getParent"], "method_name": "MoreFiles.createParentDirectories", "method_implementation": "{\n    // Interestingly, unlike File.getCanonicalFile(), Path/Files provides no way of getting the\n    // canonical (absolute, normalized, symlinks resolved, etc.) form of a path to a nonexistent\n    // file. getCanonicalFile() can at least get the canonical form of the part of the path which\n    // actually exists and then append the normalized remainder of the path to that.\n    Path normalizedAbsolutePath = path.toAbsolutePath().normalize();\n    Path parent = normalizedAbsolutePath.getParent();\n    if (parent == null) {\n        // The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n        // mean that the root itself exists -- consider x:\\ on a Windows machine without such a\n        // drive -- or even that the caller can create it, but this method makes no such guarantees\n        // even for non-root files.\n        return;\n    }\n    // Check if the parent is a directory first because createDirectories will fail if the parent\n    // exists and is a symlink to a directory... we'd like for this to succeed in that case.\n    // (I'm kind of surprised that createDirectories would fail in that case; doesn't seem like\n    // what you'd want to happen.)\n    if (!Files.isDirectory(parent)) {\n        Files.createDirectories(parent, attrs);\n        if (!Files.isDirectory(parent)) {\n            throw new IOException(\"Unable to create parent directories of \" + path);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Creates any necessary but nonexistent parent directories of the specified path. Note that if\n * this operation fails, it may have succeeded in creating some (but not all) of the necessary\n * parent directories. The parent directory is created with the given {@code attrs}.\n *\n * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n *     directories of the specified file could not be created.\n */\n", "repo_name": "guava-master/", "id": 1384, "method_signature": "void createParentDirectories(Path, FileAttribute<?>[])", "filename": "MoreFiles.createParentDirectories.json"}
{"callee_method_names": ["Collection<IOException>.add"], "method_name": "MoreFiles.deleteDirectoryContents", "method_implementation": "{\n    // created lazily if needed\n    Collection<IOException> exceptions = null;\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n        if (stream instanceof SecureDirectoryStream) {\n            SecureDirectoryStream<Path> sds = (SecureDirectoryStream<Path>) stream;\n            exceptions = deleteDirectoryContentsSecure(sds);\n        } else {\n            checkAllowsInsecure(path, options);\n            exceptions = deleteDirectoryContentsInsecure(stream);\n        }\n    } catch (IOException e) {\n        if (exceptions == null) {\n            throw e;\n        } else {\n            exceptions.add(e);\n        }\n    }\n    if (exceptions != null) {\n        throwDeleteFailed(path, exceptions);\n    }\n}", "repo_id": "5", "comment": "/**\n * Deletes all files within the directory at the given {@code path} {@linkplain #deleteRecursively\n * recursively}. Does not delete the directory itself. Deletes symbolic links, not their targets\n * (subject to the caveat below). If {@code path} itself is a symbolic link to a directory, that\n * link is followed and the contents of the directory it targets are deleted.\n *\n * <p>If an I/O exception occurs attempting to read, open or delete any file under the given\n * directory, this method skips that file and continues. All such exceptions are collected and,\n * after attempting to delete all files, an {@code IOException} is thrown containing those\n * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.\n *\n * <h2>Warning: Security of recursive deletes</h2>\n *\n * <p>On a file system that supports symbolic links and does <i>not</i> support {@link\n * SecureDirectoryStream}, it is possible for a recursive delete to delete files and directories\n * that are <i>outside</i> the directory being deleted. This can happen if, after checking that a\n * file is a directory (and not a symbolic link), that directory is replaced by a symbolic link to\n * an outside directory before the call that opens the directory to read its entries.\n *\n * <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't\n * guarantee the security of recursive deletes. If you wish to allow the recursive deletes anyway,\n * pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that behavior.\n *\n * @throws NoSuchFileException if {@code path} does not exist <i>(optional specific exception)</i>\n * @throws NotDirectoryException if the file at {@code path} is not a directory <i>(optional\n *     specific exception)</i>\n * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be\n *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not\n *     specified\n * @throws IOException if one or more files can't be deleted for any reason\n */\n", "repo_name": "guava-master/", "id": 1388, "method_signature": "void deleteDirectoryContents(Path, RecursiveDeleteOption[])", "filename": "MoreFiles.deleteDirectoryContents.json"}
{"callee_method_names": [], "method_name": "MoreFiles.deleteDirectoryContentsInsecure", "method_implementation": "{\n    Collection<IOException> exceptions = null;\n    try {\n        for (Path entry : dir) {\n            exceptions = concat(exceptions, deleteRecursivelyInsecure(entry));\n        }\n        return exceptions;\n    } catch (DirectoryIteratorException e) {\n        return addException(exceptions, e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Simple, insecure method for deleting the contents of a directory for file systems that don't\n * support {@code SecureDirectoryStream}. Returns a collection of exceptions that occurred or null\n * if no exceptions were thrown.\n */\n", "repo_name": "guava-master/", "id": 1392, "method_signature": "Collection<IOException> deleteDirectoryContentsInsecure(DirectoryStream)", "filename": "MoreFiles.deleteDirectoryContentsInsecure.json"}
{"callee_method_names": ["Path.getFileName"], "method_name": "MoreFiles.deleteDirectoryContentsSecure", "method_implementation": "{\n    Collection<IOException> exceptions = null;\n    try {\n        for (Path path : dir) {\n            exceptions = concat(exceptions, deleteRecursivelySecure(dir, path.getFileName()));\n        }\n        return exceptions;\n    } catch (DirectoryIteratorException e) {\n        return addException(exceptions, e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Secure method for deleting the contents of a directory using {@code SecureDirectoryStream}.\n * Returns a collection of exceptions that occurred or null if no exceptions were thrown.\n */\n", "repo_name": "guava-master/", "id": 1390, "method_signature": "Collection<IOException> deleteDirectoryContentsSecure(SecureDirectoryStream)", "filename": "MoreFiles.deleteDirectoryContentsSecure.json"}
{"callee_method_names": ["Path.toString", "Path.getFileName", "Collection<IOException>.add"], "method_name": "MoreFiles.deleteRecursively", "method_implementation": "{\n    Path parentPath = getParentPath(path);\n    if (parentPath == null) {\n        throw new FileSystemException(path.toString(), null, \"can't delete recursively\");\n    }\n    // created lazily if needed\n    Collection<IOException> exceptions = null;\n    try {\n        boolean sdsSupported = false;\n        try (DirectoryStream<Path> parent = Files.newDirectoryStream(parentPath)) {\n            if (parent instanceof SecureDirectoryStream) {\n                sdsSupported = true;\n                exceptions = deleteRecursivelySecure((SecureDirectoryStream<Path>) parent, /*\n                   * requireNonNull is safe because paths have file names when they have parents,\n                   * and we checked for a parent at the beginning of the method.\n                   */\n                requireNonNull(path.getFileName()));\n            }\n        }\n        if (!sdsSupported) {\n            checkAllowsInsecure(path, options);\n            exceptions = deleteRecursivelyInsecure(path);\n        }\n    } catch (IOException e) {\n        if (exceptions == null) {\n            throw e;\n        } else {\n            exceptions.add(e);\n        }\n    }\n    if (exceptions != null) {\n        throwDeleteFailed(path, exceptions);\n    }\n}", "repo_id": "5", "comment": "/**\n * Deletes the file or directory at the given {@code path} recursively. Deletes symbolic links,\n * not their targets (subject to the caveat below).\n *\n * <p>If an I/O exception occurs attempting to read, open or delete any file under the given\n * directory, this method skips that file and continues. All such exceptions are collected and,\n * after attempting to delete all files, an {@code IOException} is thrown containing those\n * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.\n *\n * <h2>Warning: Security of recursive deletes</h2>\n *\n * <p>On a file system that supports symbolic links and does <i>not</i> support {@link\n * SecureDirectoryStream}, it is possible for a recursive delete to delete files and directories\n * that are <i>outside</i> the directory being deleted. This can happen if, after checking that a\n * file is a directory (and not a symbolic link), that directory is replaced by a symbolic link to\n * an outside directory before the call that opens the directory to read its entries.\n *\n * <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't\n * guarantee the security of recursive deletes. If you wish to allow the recursive deletes anyway,\n * pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that behavior.\n *\n * @throws NoSuchFileException if {@code path} does not exist <i>(optional specific exception)</i>\n * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be\n *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not\n *     specified\n * @throws IOException if {@code path} or any file in the subtree rooted at it can't be deleted\n *     for any reason\n */\n", "repo_name": "guava-master/", "id": 1387, "method_signature": "void deleteRecursively(Path, RecursiveDeleteOption[])", "filename": "MoreFiles.deleteRecursively.json"}
{"callee_method_names": [], "method_name": "MoreFiles.deleteRecursivelyInsecure", "method_implementation": "{\n    Collection<IOException> exceptions = null;\n    try {\n        if (Files.isDirectory(path, NOFOLLOW_LINKS)) {\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n                exceptions = deleteDirectoryContentsInsecure(stream);\n            }\n        }\n        // If exceptions is not null, something went wrong trying to delete the contents of the\n        // directory, so we shouldn't try to delete the directory as it will probably fail.\n        if (exceptions == null) {\n            Files.delete(path);\n        }\n        return exceptions;\n    } catch (IOException e) {\n        return addException(exceptions, e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Insecure recursive delete for file systems that don't support {@code SecureDirectoryStream}.\n * Returns a collection of exceptions that occurred or null if no exceptions were thrown.\n */\n", "repo_name": "guava-master/", "id": 1391, "method_signature": "Collection<IOException> deleteRecursivelyInsecure(Path)", "filename": "MoreFiles.deleteRecursivelyInsecure.json"}
{"callee_method_names": ["SecureDirectoryStream<Path>.newDirectoryStream", "SecureDirectoryStream<Path>.deleteDirectory", "SecureDirectoryStream<Path>.deleteFile"], "method_name": "MoreFiles.deleteRecursivelySecure", "method_implementation": "{\n    Collection<IOException> exceptions = null;\n    try {\n        if (isDirectory(dir, path, NOFOLLOW_LINKS)) {\n            try (SecureDirectoryStream<Path> childDir = dir.newDirectoryStream(path, NOFOLLOW_LINKS)) {\n                exceptions = deleteDirectoryContentsSecure(childDir);\n            }\n            // If exceptions is not null, something went wrong trying to delete the contents of the\n            // directory, so we shouldn't try to delete the directory as it will probably fail.\n            if (exceptions == null) {\n                dir.deleteDirectory(path);\n            }\n        } else {\n            dir.deleteFile(path);\n        }\n        return exceptions;\n    } catch (IOException e) {\n        return addException(exceptions, e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Secure recursive delete using {@code SecureDirectoryStream}. Returns a collection of exceptions\n * that occurred or null if no exceptions were thrown.\n */\n", "repo_name": "guava-master/", "id": 1389, "method_signature": "Collection<IOException> deleteRecursivelySecure(SecureDirectoryStream, Path)", "filename": "MoreFiles.deleteRecursivelySecure.json"}
{"callee_method_ids": [4767], "callee_method_names": ["ByteSource.sizeIfKnown", "ByteSource.sizeIfKnown", "ByteSource.contentEquals"], "method_name": "MoreFiles.equal", "method_implementation": "{\n    checkNotNull(path1);\n    checkNotNull(path2);\n    if (Files.isSameFile(path1, path2)) {\n        return true;\n    }\n    /*\n     * Some operating systems may return zero as the length for files denoting system-dependent\n     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n     * directly.\n     */\n    ByteSource source1 = asByteSource(path1);\n    ByteSource source2 = asByteSource(path2);\n    long len1 = source1.sizeIfKnown().or(0L);\n    long len2 = source2.sizeIfKnown().or(0L);\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\n        return false;\n    }\n    return source1.contentEquals(source2);\n}", "repo_id": "5", "comment": "/**\n * Returns true if the files located by the given paths exist, are not directories, and contain\n * the same bytes.\n *\n * @throws IOException if an I/O error occurs\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 1382, "method_signature": "boolean equal(Path, Path)", "filename": "MoreFiles.equal.json"}
{"callee_method_names": ["Path.getFileName", "Path.toString", "String.lastIndexOf", "String.substring"], "method_name": "MoreFiles.getFileExtension", "method_implementation": "{\n    Path name = path.getFileName();\n    // null for empty paths and root-only paths\n    if (name == null) {\n        return \"\";\n    }\n    String fileName = name.toString();\n    int dotIndex = fileName.lastIndexOf('.');\n    return dotIndex == -1 ? \"\" : fileName.substring(dotIndex + 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n * the file at the given path, or the empty string if the file has no extension. The result does\n * not include the '{@code .}'.\n *\n * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n * name as determined by {@link Path#getFileName}. It does not account for any filesystem-specific\n * behavior that the {@link Path} API does not already account for. For example, on NTFS it will\n * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n */\n", "repo_name": "guava-master/", "id": 1385, "method_signature": "String getFileExtension(Path)", "filename": "MoreFiles.getFileExtension.json"}
{"callee_method_names": ["Path.getFileName", "Path.toString", "String.lastIndexOf", "String.substring"], "method_name": "MoreFiles.getNameWithoutExtension", "method_implementation": "{\n    Path name = path.getFileName();\n    // null for empty paths and root-only paths\n    if (name == null) {\n        return \"\";\n    }\n    String fileName = name.toString();\n    int dotIndex = fileName.lastIndexOf('.');\n    return dotIndex == -1 ? fileName : fileName.substring(0, dotIndex);\n}", "repo_id": "5", "comment": "/**\n * Returns the file name without its <a\n * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n */\n", "repo_name": "guava-master/", "id": 1386, "method_signature": "String getNameWithoutExtension(Path)", "filename": "MoreFiles.getNameWithoutExtension.json"}
{"callee_method_names": ["Path.getParent", "Path.getNameCount", "Path.getFileSystem"], "method_name": "MoreFiles.getParentPath", "method_implementation": "{\n    Path parent = path.getParent();\n    // Paths that have a parent:\n    if (parent != null) {\n        // \"/foo\" (\"/\")\n        // \"foo/bar\" (\"foo\")\n        // \"C:\\foo\" (\"C:\\\")\n        // \"\\foo\" (\"\\\" - current drive for process on Windows)\n        // \"C:foo\" (\"C:\" - working dir of drive C on Windows)\n        return parent;\n    }\n    // Paths that don't have a parent:\n    if (path.getNameCount() == 0) {\n        // \"/\", \"C:\\\", \"\\\" (no parent)\n        // \"\" (undefined, though typically parent of working dir)\n        // \"C:\" (parent of working dir of drive C on Windows)\n        //\n        // For working dir paths (\"\" and \"C:\"), return null because:\n        //   A) it's not specified that \"\" is the path to the working directory.\n        //   B) if we're getting this path for recursive delete, it's typically not possible to\n        //      delete the working dir with a relative path anyway, so it's ok to fail.\n        //   C) if we're getting it for opening a new SecureDirectoryStream, there's no need to get\n        //      the parent path anyway since we can safely open a DirectoryStream to the path without\n        //      worrying about a symlink.\n        return null;\n    } else {\n        // \"foo\" (working dir)\n        return path.getFileSystem().getPath(\".\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a path to the parent directory of the given path. If the path actually has a parent\n * path, this is simple. Otherwise, we need to do some trickier things. Returns null if the path\n * is a root or is the empty path.\n */\n", "repo_name": "guava-master/", "id": 1393, "method_signature": "Path getParentPath(Path)", "filename": "MoreFiles.getParentPath.json"}
{"callee_method_names": ["SecureDirectoryStream<Path>.getFileAttributeView"], "method_name": "MoreFiles.isDirectory", "method_implementation": "{\n    return dir.getFileAttributeView(name, BasicFileAttributeView.class, options).readAttributes().isDirectory();\n}", "repo_id": "5", "comment": "/**\n * Returns whether or not the file with the given name in the given dir is a directory.\n */\n", "repo_name": "guava-master/", "id": 1380, "method_signature": "boolean isDirectory(SecureDirectoryStream, Path, LinkOption[])", "filename": "MoreFiles.isDirectory.json"}
{"callee_method_names": ["LinkOption.clone"], "method_name": "MoreFiles.isRegularFile", "method_implementation": "{\n    final LinkOption[] optionsCopy = options.clone();\n    return new Predicate<Path>() {\n\n        @Override\n        public boolean apply(Path input) {\n            return Files.isRegularFile(input, optionsCopy);\n        }\n\n        @Override\n        public String toString() {\n            return \"MoreFiles.isRegularFile(\" + Arrays.toString(optionsCopy) + \")\";\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a predicate that returns the result of {@link java.nio.file.Files#isRegularFile(Path,\n * LinkOption...)} on input paths with the given link options.\n */\n", "repo_name": "guava-master/", "id": 1381, "method_signature": "Predicate<Path> isRegularFile(LinkOption[])", "filename": "MoreFiles.isRegularFile.json"}
{"callee_method_names": [], "method_name": "MoreFiles.listFiles", "method_implementation": "{\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n        return ImmutableList.copyOf(stream);\n    } catch (DirectoryIteratorException e) {\n        throw e.getCause();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable list of paths to the files contained in the given directory.\n *\n * @throws NoSuchFileException if the file does not exist <i>(optional specific exception)</i>\n * @throws NotDirectoryException if the file could not be opened because it is not a directory\n *     <i>(optional specific exception)</i>\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 1378, "method_signature": "ImmutableList<Path> listFiles(Path)", "filename": "MoreFiles.listFiles.json"}
{"callee_method_names": ["Path.toString", "FileSystemException.addSuppressed"], "method_name": "MoreFiles.throwDeleteFailed", "method_implementation": "{\n    NoSuchFileException pathNotFound = pathNotFound(path, exceptions);\n    if (pathNotFound != null) {\n        throw pathNotFound;\n    }\n    // TODO(cgdecker): Should there be a custom exception type for this?\n    // Also, should we try to include the Path of each file we may have failed to delete rather\n    // than just the exceptions that occurred?\n    FileSystemException deleteFailed = new FileSystemException(path.toString(), null, \"failed to delete one or more files; see suppressed exceptions for details\");\n    for (IOException e : exceptions) {\n        deleteFailed.addSuppressed(e);\n    }\n    throw deleteFailed;\n}", "repo_id": "5", "comment": "/**\n * Throws an exception indicating that one or more files couldn't be deleted when deleting {@code\n * path} or its contents.\n *\n * <p>If there is only one exception in the collection, and it is a {@link NoSuchFileException}\n * thrown because {@code path} itself didn't exist, then throws that exception. Otherwise, the\n * thrown exception contains all the exceptions in the given collection as suppressed exceptions.\n */\n", "repo_name": "guava-master/", "id": 1397, "method_signature": "void throwDeleteFailed(Path, Collection)", "filename": "MoreFiles.throwDeleteFailed.json"}
{"callee_method_names": [], "method_name": "MoreFiles.touch", "method_implementation": "{\n    checkNotNull(path);\n    try {\n        Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));\n    } catch (NoSuchFileException e) {\n        try {\n            Files.createFile(path);\n        } catch (FileAlreadyExistsException ignore) {\n            // The file didn't exist when we called setLastModifiedTime, but it did when we called\n            // createFile, so something else created the file in between. The end result is\n            // what we wanted: a new file that probably has its last modified time set to approximately\n            // now. Or it could have an arbitrary last modified time set by the creator, but that's no\n            // different than if another process set its last modified time to something else after we\n            // created it here.\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Like the unix command of the same name, creates an empty file or updates the last modified\n * timestamp of the existing file at the given path to the current system time.\n */\n", "repo_name": "guava-master/", "id": 1383, "method_signature": "void touch(Path)", "filename": "MoreFiles.touch.json"}
{"callee_method_names": ["FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath", "FileSystem.getPath"], "method_name": "MoreFilesTest.newTestFileSystem", "method_implementation": "{\n    FileSystem fs = Jimfs.newFileSystem(Configuration.unix().toBuilder().setSupportedFeatures(ObjectArrays.concat(SYMBOLIC_LINKS, supportedFeatures)).build());\n    Files.createDirectories(fs.getPath(\"dir/b/i/j/l\"));\n    Files.createFile(fs.getPath(\"dir/a\"));\n    Files.createFile(fs.getPath(\"dir/c\"));\n    Files.createSymbolicLink(fs.getPath(\"dir/d\"), fs.getPath(\"b/i\"));\n    Files.createDirectory(fs.getPath(\"dir/e\"));\n    Files.createSymbolicLink(fs.getPath(\"dir/f\"), fs.getPath(\"/dontdelete\"));\n    Files.createFile(fs.getPath(\"dir/b/g\"));\n    Files.createSymbolicLink(fs.getPath(\"dir/b/h\"), fs.getPath(\"../a\"));\n    Files.createFile(fs.getPath(\"dir/b/i/j/k\"));\n    Files.createDirectory(fs.getPath(\"/dontdelete\"));\n    Files.createFile(fs.getPath(\"/dontdelete/a\"));\n    Files.createDirectory(fs.getPath(\"/dontdelete/b\"));\n    Files.createFile(fs.getPath(\"/dontdelete/c\"));\n    Files.createSymbolicLink(fs.getPath(\"/symlinktodir\"), fs.getPath(\"work/dir\"));\n    return fs;\n}", "repo_id": "5", "comment": "/**\n * Creates a new file system for testing that supports the given features in addition to\n * supporting symbolic links. The file system is created initially having the following file\n * structure:\n *\n * <pre>\n *   /\n *      work/\n *         dir/\n *            a\n *            b/\n *               g\n *               h -> ../a\n *               i/\n *                  j/\n *                     k\n *                     l/\n *            c\n *            d -> b/i\n *            e/\n *            f -> /dontdelete\n *      dontdelete/\n *         a\n *         b/\n *         c\n *      symlinktodir -> work/dir\n * </pre>\n */\n", "repo_name": "guava-master/", "id": 166, "method_signature": "FileSystem newTestFileSystem(Feature[])", "filename": "MoreFilesTest.newTestFileSystem.json"}
{"callee_method_names": ["ExecutorService.submit"], "method_name": "MoreFilesTest.startDirectorySymlinkSwitching", "method_implementation": "{\n    // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n    @SuppressWarnings(\"unused\")\n    Future<?> possiblyIgnoredError = executor.submit(new Runnable() {\n\n        @Override\n        public void run() {\n            boolean createSymlink = false;\n            while (!Thread.interrupted()) {\n                try {\n                    // trying to switch between a real directory and a symlink (dir -> /a)\n                    if (Files.deleteIfExists(file)) {\n                        if (createSymlink) {\n                            Files.createSymbolicLink(file, target);\n                        } else {\n                            Files.createDirectory(file);\n                        }\n                        createSymlink = !createSymlink;\n                    }\n                } catch (IOException tolerated) {\n                    // it's expected that some of these will fail\n                }\n                Thread.yield();\n            }\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Starts a new task on the given executor that switches (deletes and replaces) a file between\n * being a directory and being a symlink. The given {@code file} is the file that should switch\n * between being a directory and being a symlink, while the given {@code target} is the target the\n * symlink should have.\n */\n", "repo_name": "guava-master/", "id": 168, "method_signature": "void startDirectorySymlinkSwitching(Path, Path, ExecutorService)", "filename": "MoreFilesTest.startDirectorySymlinkSwitching.json"}
{"callee_method_names": ["FileSystem.getPath", "Path.resolve", "FileSystem.getPath", "Path.resolve", "Method.delete", "ExecutorService.shutdownNow"], "method_name": "MoreFilesTest.testDirectoryDeletion_directorySymlinkRace", "method_implementation": "{\n    int iterations = isAndroid() ? 100 : 5000;\n    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n        try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n            Path dirToDelete = fs.getPath(\"dir/b/i\");\n            Path changingFile = dirToDelete.resolve(\"j/l\");\n            Path symlinkTarget = fs.getPath(\"/dontdelete\");\n            ExecutorService executor = Executors.newSingleThreadExecutor();\n            startDirectorySymlinkSwitching(changingFile, symlinkTarget, executor);\n            try {\n                for (int i = 0; i < iterations; i++) {\n                    try {\n                        Files.createDirectories(changingFile);\n                        Files.createFile(dirToDelete.resolve(\"j/k\"));\n                    } catch (FileAlreadyExistsException expected) {\n                        // if a file already exists, that's fine... just continue\n                    }\n                    try {\n                        method.delete(dirToDelete);\n                    } catch (FileSystemException expected) {\n                        // the delete method may or may not throw an exception, but if it does that's fine\n                        // and expected\n                    }\n                    // this test is mainly checking that the contents of /dontdelete aren't deleted under\n                    // any circumstances\n                    assertEquals(3, MoreFiles.listFiles(symlinkTarget).size());\n                    Thread.yield();\n                }\n            } finally {\n                executor.shutdownNow();\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * This test attempts to create a situation in which one thread is constantly changing a file from\n * being a real directory to being a symlink to another directory. It then calls\n * deleteDirectoryContents thousands of times on a directory whose subtree contains the file\n * that's switching between directory and symlink to try to ensure that under no circumstance does\n * deleteDirectoryContents follow the symlink to the other directory and delete that directory's\n * contents.\n *\n * <p>We can only test this with a file system that supports SecureDirectoryStream, because it's\n * not possible to protect against this if the file system doesn't.\n */\n", "repo_name": "guava-master/", "id": 167, "method_signature": "void testDirectoryDeletion_directorySymlinkRace()", "filename": "MoreFilesTest.testDirectoryDeletion_directorySymlinkRace.json"}
{"callee_method_names": [], "method_name": "MoreObjects.firstNonNull", "method_implementation": "{\n    if (first != null) {\n        return first;\n    }\n    if (second != null) {\n        return second;\n    }\n    throw new NullPointerException(\"Both parameters are null\");\n}", "repo_id": "5", "comment": "/**\n * Returns the first of two given parameters that is not {@code null}, if either is, or otherwise\n * throws a {@link NullPointerException}.\n *\n * <p>To find the first non-null element in an iterable, use {@code Iterables.find(iterable,\n * Predicates.notNull())}. For varargs, use {@code Iterables.find(Arrays.asList(a, b, c, ...),\n * Predicates.notNull())}, static importing as necessary.\n *\n * <p><b>Note:</b> if {@code first} is represented as an {@link Optional}, this can be\n * accomplished with {@link Optional#or(Object) first.or(second)}. That approach also allows for\n * lazy evaluation of the fallback instance, using {@link Optional#or(Supplier)\n * first.or(supplier)}.\n *\n * <p><b>Java 9 users:</b> use {@code java.util.Objects.requireNonNullElse(first, second)}\n * instead.\n *\n * @return {@code first} if it is non-null; otherwise {@code second} if it is non-null\n * @throws NullPointerException if both {@code first} and {@code second} are null\n * @since 18.0 (since 3.0 as {@code Objects.firstNonNull()}).\n */\n", "repo_name": "guava-master/", "id": 5162, "method_signature": "T firstNonNull(T, T)", "filename": "MoreObjects.firstNonNull.json"}
{"callee_method_names": [], "method_name": "MoreObjects.omitNullValues", "method_implementation": "{\n    omitNullValues = true;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures the {@link ToStringHelper} so {@link #toString()} will ignore properties with null\n * value. The order of calling this method, relative to the {@code add()}/{@code addValue()}\n * methods, is not significant.\n *\n * @since 18.0 (since 12.0 as {@code Objects.ToStringHelper.omitNullValues()}).\n */\n", "repo_name": "guava-master/", "id": 5163, "method_signature": "ToStringHelper omitNullValues()", "filename": "MoreObjects.omitNullValues.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "Object.getClass", "StringBuilder.append", "String.length", "StringBuilder.append", "StringBuilder.append"], "method_name": "MoreObjects.toString", "method_implementation": "{\n    // create a copy to keep it consistent in case value changes\n    boolean omitNullValuesSnapshot = omitNullValues;\n    boolean omitEmptyValuesSnapshot = omitEmptyValues;\n    String nextSeparator = \"\";\n    StringBuilder builder = new StringBuilder(32).append(className).append('{');\n    for (ValueHolder valueHolder = holderHead.next; valueHolder != null; valueHolder = valueHolder.next) {\n        Object value = valueHolder.value;\n        if (valueHolder instanceof UnconditionalValueHolder || (value == null ? !omitNullValuesSnapshot : (!omitEmptyValuesSnapshot || !isEmpty(value)))) {\n            builder.append(nextSeparator);\n            nextSeparator = \", \";\n            if (valueHolder.name != null) {\n                builder.append(valueHolder.name).append('=');\n            }\n            if (value != null && value.getClass().isArray()) {\n                Object[] objectArray = { value };\n                String arrayString = Arrays.deepToString(objectArray);\n                builder.append(arrayString, 1, arrayString.length() - 1);\n            } else {\n                builder.append(value);\n            }\n        }\n    }\n    return builder.append('}').toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string in the format specified by {@link MoreObjects#toStringHelper(Object)}.\n *\n * <p>After calling this method, you can keep adding more properties to later call toString()\n * again and get a more complete representation of the same object; but properties cannot be\n * removed, so this only allows limited reuse of the helper instance. The helper allows\n * duplication of properties (multiple name/value pairs with the same name can be added).\n */\n", "repo_name": "guava-master/", "id": 5164, "method_signature": "String toString()", "filename": "MoreObjects.toString.json"}
{"callee_method_names": [], "method_name": "MoreObjectsTest.testToString_oneField", "method_implementation": "{\n    String toTest = MoreObjects.toStringHelper(new TestClass()).add(\"field1\", \"Hello\").toString();\n    assertEquals(\"TestClass{field1=Hello}\", toTest);\n}", "repo_id": "5", "comment": "// all remaining test are on an inner class with various fields\n", "repo_name": "guava-master/", "id": 3691, "method_signature": "void testToString_oneField()", "filename": "MoreObjectsTest.testToString_oneField.json"}
{"callee_method_names": ["Stack.remove", "Stack.push"], "method_name": "MultiExceptionListIterator.promoteToNext", "method_implementation": "{\n    if (nextElements.remove(e)) {\n        nextElements.push(e);\n    } else {\n        throw new UnknownElementException(nextElements, e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Moves the given element from its current position in {@link #nextElements} to the top of the\n * stack so that it is returned by the next call to {@link Iterator#next()}. If the element is\n * not in {@link #nextElements}, this method throws an {@link UnknownElementException}.\n *\n * <p>This method is used when testing iterators without a known ordering. We poll the target\n * iterator's next element and pass it to the reference iterator through this method so it can\n * return the same element. This enables the assertion to pass and the reference iterator to\n * properly update its state.\n */\n", "repo_name": "guava-master/", "id": 4159, "method_signature": "void promoteToNext(E)", "filename": "MultiExceptionListIterator.promoteToNext.json"}
{"callee_method_names": ["Iterator<? extends ByteSource>.hasNext", "Iterator<? extends ByteSource>.next"], "method_name": "MultiInputStream.advance", "method_implementation": "{\n    close();\n    if (it.hasNext()) {\n        in = it.next().openStream();\n    }\n}", "repo_id": "5", "comment": "/**\n * Closes the current input stream and opens the next one, if any.\n */\n", "repo_name": "guava-master/", "id": 4737, "method_signature": "void advance()", "filename": "MultiInputStream.advance.json"}
{"callee_method_names": ["Iterator<? extends CharSource>.hasNext", "Iterator<? extends CharSource>.next"], "method_name": "MultiReader.advance", "method_implementation": "{\n    close();\n    if (it.hasNext()) {\n        current = it.next().openStream();\n    }\n}", "repo_id": "5", "comment": "/**\n * Closes the current reader and opens the next one, if any.\n */\n", "repo_name": "guava-master/", "id": 4740, "method_signature": "void advance()", "filename": "MultiReader.advance.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.arrayListValues", "method_implementation": "{\n    checkNonnegative(expectedValuesPerKey, \"expectedValuesPerKey\");\n    return new ListMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> ListMultimap<K, V> build() {\n            return Multimaps.newListMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new ArrayListSupplier<V>(expectedValuesPerKey));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an {@link ArrayList} to store value collections, initialized to expect the specified\n * number of values per key.\n *\n * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}\n */\n", "repo_name": "guava-master/", "id": 5956, "method_signature": "ListMultimapBuilder<K0,Object> arrayListValues(int)", "filename": "MultimapBuilder.arrayListValues.json"}
{"callee_method_names": ["Multimap<K, V>.putAll"], "method_name": "MultimapBuilder.build", "method_implementation": "{\n    Multimap<K, V> result = build();\n    result.putAll(multimap);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Multimap} with the specified implementation, initialized with the entries of\n * {@code multimap}.\n */\n", "repo_name": "guava-master/", "id": 5962, "method_signature": "Multimap<K,V> build(Multimap)", "filename": "MultimapBuilder.build.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.enumKeys", "method_implementation": "{\n    checkNotNull(keyClass);\n    return new MultimapBuilderWithKeys<K0>() {\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        <K extends K0, V extends @Nullable Object> Map<K, Collection<V>> createMap() {\n            // K must actually be K0, since enums are effectively final\n            // (their subclasses are inaccessible)\n            return (Map<K, Collection<V>>) new EnumMap<K0, Collection<V>>(keyClass);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an {@link EnumMap} to map keys to value collections.\n *\n * @since 16.0\n */\n", "repo_name": "guava-master/", "id": 5955, "method_signature": "MultimapBuilderWithKeys<K0> enumKeys(Class)", "filename": "MultimapBuilder.enumKeys.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.enumSetValues", "method_implementation": "{\n    checkNotNull(valueClass, \"valueClass\");\n    return new SetMultimapBuilder<K0, V0>() {\n\n        @Override\n        public <K extends K0, V extends V0> SetMultimap<K, V> build() {\n            // V must actually be V0, since enums are effectively final\n            // (their subclasses are inaccessible)\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n            Supplier<Set<V>> factory = (Supplier) new EnumSetSupplier<V0>(valueClass);\n            return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), factory);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an {@link EnumSet} to store value collections.\n */\n", "repo_name": "guava-master/", "id": 5961, "method_signature": "SetMultimapBuilder<K0,V0> enumSetValues(Class)", "filename": "MultimapBuilder.enumSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.hashKeys", "method_implementation": "{\n    checkNonnegative(expectedKeys, \"expectedKeys\");\n    return new MultimapBuilderWithKeys<@Nullable Object>() {\n\n        @Override\n        <K extends @Nullable Object, V extends @Nullable Object> Map<K, Collection<V>> createMap() {\n            return Platform.newHashMapWithExpectedSize(expectedKeys);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a hash table to map keys to value collections, initialized to expect the specified number\n * of keys.\n *\n * @throws IllegalArgumentException if {@code expectedKeys < 0}\n */\n", "repo_name": "guava-master/", "id": 5952, "method_signature": "MultimapBuilderWithKeys<Object> hashKeys(int)", "filename": "MultimapBuilder.hashKeys.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.hashSetValues", "method_implementation": "{\n    checkNonnegative(expectedValuesPerKey, \"expectedValuesPerKey\");\n    return new SetMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> SetMultimap<K, V> build() {\n            return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new HashSetSupplier<V>(expectedValuesPerKey));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a hash-based {@code Set} to store value collections, initialized to expect the specified\n * number of values per key.\n *\n * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}\n */\n", "repo_name": "guava-master/", "id": 5958, "method_signature": "SetMultimapBuilder<K0,Object> hashSetValues(int)", "filename": "MultimapBuilder.hashSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.linkedHashKeys", "method_implementation": "{\n    checkNonnegative(expectedKeys, \"expectedKeys\");\n    return new MultimapBuilderWithKeys<@Nullable Object>() {\n\n        @Override\n        <K extends @Nullable Object, V extends @Nullable Object> Map<K, Collection<V>> createMap() {\n            return Platform.newLinkedHashMapWithExpectedSize(expectedKeys);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an hash table to map keys to value collections, initialized to expect the specified number\n * of keys.\n *\n * <p>The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link\n * Multimap#asMap()} will iterate through the keys in the order that they were first added to the\n * multimap, save that if all values associated with a key are removed and then the key is added\n * back into the multimap, that key will come last in the key iteration order.\n */\n", "repo_name": "guava-master/", "id": 5953, "method_signature": "MultimapBuilderWithKeys<Object> linkedHashKeys(int)", "filename": "MultimapBuilder.linkedHashKeys.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.linkedHashSetValues", "method_implementation": "{\n    checkNonnegative(expectedValuesPerKey, \"expectedValuesPerKey\");\n    return new SetMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> SetMultimap<K, V> build() {\n            return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new LinkedHashSetSupplier<V>(expectedValuesPerKey));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an insertion-ordered hash-based {@code Set} to store value collections, initialized to\n * expect the specified number of values per key.\n *\n * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}\n */\n", "repo_name": "guava-master/", "id": 5959, "method_signature": "SetMultimapBuilder<K0,Object> linkedHashSetValues(int)", "filename": "MultimapBuilder.linkedHashSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.linkedListValues", "method_implementation": "{\n    return new ListMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> ListMultimap<K, V> build() {\n            return Multimaps.newListMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), LinkedListSupplier.<V>instance());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a {@link LinkedList} to store value collections.\n */\n", "repo_name": "guava-master/", "id": 5957, "method_signature": "ListMultimapBuilder<K0,Object> linkedListValues()", "filename": "MultimapBuilder.linkedListValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.treeKeys", "method_implementation": "{\n    checkNotNull(comparator);\n    return new MultimapBuilderWithKeys<K0>() {\n\n        @Override\n        <K extends K0, V extends @Nullable Object> Map<K, Collection<V>> createMap() {\n            return new TreeMap<>(comparator);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a {@link TreeMap} sorted by the specified comparator to map keys to value collections.\n *\n * <p>The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link\n * Multimap#asMap()} will iterate through the keys in sorted order.\n *\n * <p>For all multimaps generated by the resulting builder, the {@link Multimap#keySet()} can be\n * safely cast to a {@link java.util.SortedSet}, and the {@link Multimap#asMap()} can safely be\n * cast to a {@link java.util.SortedMap}.\n *\n * <p>Multimaps generated by the resulting builder will not be serializable if {@code comparator}\n * is not serializable.\n */\n", "repo_name": "guava-master/", "id": 5954, "method_signature": "MultimapBuilderWithKeys<K0> treeKeys(Comparator)", "filename": "MultimapBuilder.treeKeys.json"}
{"callee_method_names": [], "method_name": "MultimapBuilder.treeSetValues", "method_implementation": "{\n    checkNotNull(comparator, \"comparator\");\n    return new SortedSetMultimapBuilder<K0, V0>() {\n\n        @Override\n        public <K extends K0, V extends V0> SortedSetMultimap<K, V> build() {\n            return Multimaps.newSortedSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new TreeSetSupplier<V>(comparator));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a {@link TreeSet} ordered by the specified comparator to store value collections.\n *\n * <p>Multimaps generated by the resulting builder will not be serializable if {@code\n * comparator} is not serializable.\n */\n", "repo_name": "guava-master/", "id": 5960, "method_signature": "SortedSetMultimapBuilder<K0,V0> treeSetValues(Comparator)", "filename": "MultimapBuilder.treeSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilderWithKeys.arrayListValues", "method_implementation": "{\n    checkNonnegative(expectedValuesPerKey, \"expectedValuesPerKey\");\n    return new ListMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> ListMultimap<K, V> build() {\n            return Multimaps.newListMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new ArrayListSupplier<V>(expectedValuesPerKey));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an {@link ArrayList} to store value collections, initialized to expect the specified\n * number of values per key.\n *\n * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}\n */\n", "repo_name": "guava-master/", "id": 5963, "method_signature": "ListMultimapBuilder<K0,Object> arrayListValues(int)", "filename": "MultimapBuilderWithKeys.arrayListValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilderWithKeys.enumSetValues", "method_implementation": "{\n    checkNotNull(valueClass, \"valueClass\");\n    return new SetMultimapBuilder<K0, V0>() {\n\n        @Override\n        public <K extends K0, V extends V0> SetMultimap<K, V> build() {\n            // V must actually be V0, since enums are effectively final\n            // (their subclasses are inaccessible)\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n            Supplier<Set<V>> factory = (Supplier) new EnumSetSupplier<V0>(valueClass);\n            return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), factory);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an {@link EnumSet} to store value collections.\n */\n", "repo_name": "guava-master/", "id": 5968, "method_signature": "SetMultimapBuilder<K0,V0> enumSetValues(Class)", "filename": "MultimapBuilderWithKeys.enumSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilderWithKeys.hashSetValues", "method_implementation": "{\n    checkNonnegative(expectedValuesPerKey, \"expectedValuesPerKey\");\n    return new SetMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> SetMultimap<K, V> build() {\n            return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new HashSetSupplier<V>(expectedValuesPerKey));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a hash-based {@code Set} to store value collections, initialized to expect the specified\n * number of values per key.\n *\n * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}\n */\n", "repo_name": "guava-master/", "id": 5965, "method_signature": "SetMultimapBuilder<K0,Object> hashSetValues(int)", "filename": "MultimapBuilderWithKeys.hashSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilderWithKeys.linkedHashSetValues", "method_implementation": "{\n    checkNonnegative(expectedValuesPerKey, \"expectedValuesPerKey\");\n    return new SetMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> SetMultimap<K, V> build() {\n            return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new LinkedHashSetSupplier<V>(expectedValuesPerKey));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses an insertion-ordered hash-based {@code Set} to store value collections, initialized to\n * expect the specified number of values per key.\n *\n * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}\n */\n", "repo_name": "guava-master/", "id": 5966, "method_signature": "SetMultimapBuilder<K0,Object> linkedHashSetValues(int)", "filename": "MultimapBuilderWithKeys.linkedHashSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilderWithKeys.linkedListValues", "method_implementation": "{\n    return new ListMultimapBuilder<K0, @Nullable Object>() {\n\n        @Override\n        public <K extends K0, V extends @Nullable Object> ListMultimap<K, V> build() {\n            return Multimaps.newListMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), LinkedListSupplier.<V>instance());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a {@link LinkedList} to store value collections.\n */\n", "repo_name": "guava-master/", "id": 5964, "method_signature": "ListMultimapBuilder<K0,Object> linkedListValues()", "filename": "MultimapBuilderWithKeys.linkedListValues.json"}
{"callee_method_names": [], "method_name": "MultimapBuilderWithKeys.treeSetValues", "method_implementation": "{\n    checkNotNull(comparator, \"comparator\");\n    return new SortedSetMultimapBuilder<K0, V0>() {\n\n        @Override\n        public <K extends K0, V extends V0> SortedSetMultimap<K, V> build() {\n            return Multimaps.newSortedSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), new TreeSetSupplier<V>(comparator));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Uses a {@link TreeSet} ordered by the specified comparator to store value collections.\n *\n * <p>Multimaps generated by the resulting builder will not be serializable if {@code\n * comparator} is not serializable.\n */\n", "repo_name": "guava-master/", "id": 5967, "method_signature": "SortedSetMultimapBuilder<K0,V0> treeSetValues(Comparator)", "filename": "MultimapBuilderWithKeys.treeSetValues.json"}
{"callee_method_names": [], "method_name": "MultimapTestSuiteBuilder.getTesters", "method_implementation": "{\n    return ImmutableList.<Class<? extends AbstractTester>>of(MultimapAsMapGetTester.class, MultimapAsMapTester.class, MultimapSizeTester.class, MultimapClearTester.class, MultimapContainsKeyTester.class, MultimapContainsValueTester.class, MultimapContainsEntryTester.class, MultimapEntriesTester.class, MultimapEqualsTester.class, MultimapGetTester.class, MultimapKeySetTester.class, MultimapKeysTester.class, MultimapPutTester.class, MultimapPutAllMultimapTester.class, MultimapPutIterableTester.class, MultimapReplaceValuesTester.class, MultimapRemoveEntryTester.class, MultimapRemoveAllTester.class, MultimapToStringTester.class, MultimapValuesTester.class);\n}", "repo_id": "5", "comment": "// Class parameters must be raw.\n", "repo_name": "guava-master/", "id": 4181, "method_signature": "List<Class<? extends AbstractTester>> getTesters()", "filename": "MultimapTestSuiteBuilder.getTesters.json"}
{"callee_method_names": ["SortedSetMultimap<K,V>.asMap"], "method_name": "Multimaps.asMap", "method_implementation": "{\n    return (Map<K, SortedSet<V>>) (Map<K, ?>) multimap.asMap();\n}", "repo_id": "5", "comment": "/**\n * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type corrected from {@code\n * Map<K, Collection<V>>} to {@code Map<K, SortedSet<V>>}.\n *\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 6098, "method_signature": "Map<K,SortedSet<V>> asMap(SortedSetMultimap)", "filename": "Multimaps.asMap.json"}
{"callee_method_names": [], "method_name": "Multimaps.filterEntries", "method_implementation": "{\n    checkNotNull(entryPredicate);\n    return (unfiltered instanceof FilteredSetMultimap) ? filterFiltered((FilteredSetMultimap<K, V>) unfiltered, entryPredicate) : new FilteredEntrySetMultimap<K, V>(checkNotNull(unfiltered), entryPredicate);\n}", "repo_id": "5", "comment": "/**\n * Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n * returned multimap is a live view of {@code unfiltered}; changes to one affect the other.\n *\n * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n * other methods are supported by the multimap and its views. When adding a key/value pair that\n * doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code\n * replaceValues()} methods throw an {@link IllegalArgumentException}.\n *\n * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n * underlying multimap.\n *\n * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n * copy.\n *\n * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n * at {@link Predicate#apply}.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6110, "method_signature": "SetMultimap<K,V> filterEntries(SetMultimap, Predicate)", "filename": "Multimaps.filterEntries.json"}
{"callee_method_names": ["FilteredSetMultimap<K,V>.entryPredicate", "FilteredSetMultimap<K,V>.unfiltered"], "method_name": "Multimaps.filterFiltered", "method_implementation": "{\n    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(multimap.entryPredicate(), entryPredicate);\n    return new FilteredEntrySetMultimap<>(multimap.unfiltered(), predicate);\n}", "repo_id": "5", "comment": "/**\n * Support removal operations when filtering a filtered multimap. Since a filtered multimap has\n * iterators that don't support remove, passing one to the FilteredEntryMultimap constructor would\n * lead to a multimap whose removal operations would fail. This method combines the predicates to\n * avoid that problem.\n */\n", "repo_name": "guava-master/", "id": 6112, "method_signature": "SetMultimap<K,V> filterFiltered(FilteredSetMultimap, Predicate)", "filename": "Multimaps.filterFiltered.json"}
{"callee_method_names": ["FilteredKeyListMultimap<K, V>.unfiltered"], "method_name": "Multimaps.filterKeys", "method_implementation": "{\n    if (unfiltered instanceof FilteredKeyListMultimap) {\n        FilteredKeyListMultimap<K, V> prev = (FilteredKeyListMultimap<K, V>) unfiltered;\n        return new FilteredKeyListMultimap<>(prev.unfiltered(), Predicates.<K>and(prev.keyPredicate, keyPredicate));\n    } else {\n        return new FilteredKeyListMultimap<>(unfiltered, keyPredicate);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a\n * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n * the other.\n *\n * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n * other methods are supported by the multimap and its views. When adding a key that doesn't\n * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n * replaceValues()} methods throw an {@link IllegalArgumentException}.\n *\n * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n * underlying multimap.\n *\n * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n * copy.\n *\n * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n * {@link Predicate#apply}. Do not provide a predicate such as {@code\n * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6106, "method_signature": "ListMultimap<K,V> filterKeys(ListMultimap, Predicate)", "filename": "Multimaps.filterKeys.json"}
{"callee_method_names": [], "method_name": "Multimaps.filterValues", "method_implementation": "{\n    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n}", "repo_id": "5", "comment": "/**\n * Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a\n * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n * the other.\n *\n * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n * other methods are supported by the multimap and its views. When adding a value that doesn't\n * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n * replaceValues()} methods throw an {@link IllegalArgumentException}.\n *\n * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n * multimap or its views, only mappings whose value satisfy the filter will be removed from the\n * underlying multimap.\n *\n * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n * copy.\n *\n * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6108, "method_signature": "SetMultimap<K,V> filterValues(SetMultimap, Predicate)", "filename": "Multimaps.filterValues.json"}
{"callee_method_names": [], "method_name": "Multimaps.flatteningToMultimap", "method_implementation": "{\n    return CollectCollectors.<T, K, V, M>flatteningToMultimap(keyFunction, valueFunction, multimapSupplier);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} accumulating entries into a {@code Multimap} generated from the\n * specified supplier. Each input element is mapped to a key and a stream of values, each of which\n * are put into the resulting {@code Multimap}, in the encounter order of the stream and the\n * encounter order of the streams of values.\n *\n * <p>Example:\n *\n * <pre>{@code\n * static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n *         .collect(\n *             flatteningToMultimap(\n *                  str -> str.charAt(0),\n *                  str -> str.substring(1).chars().mapToObj(c -> (char) c),\n *                  MultimapBuilder.linkedHashKeys().arrayListValues()::build));\n *\n * // is equivalent to\n *\n * static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP;\n *\n * static {\n *     FIRST_LETTER_MULTIMAP = MultimapBuilder.linkedHashKeys().arrayListValues().build();\n *     FIRST_LETTER_MULTIMAP.putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'));\n *     FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('p', 'p', 'l', 'e'));\n *     FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'));\n *     FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'));\n *     FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'));\n * }\n * }</pre>\n */\n", "repo_name": "guava-master/", "id": 6079, "method_signature": "Collector<T,?,M> flatteningToMultimap(java.util.function.Function, java.util.function.Function, java.util.function.Supplier)", "filename": "Multimaps.flatteningToMultimap.json"}
{"callee_method_names": ["Iterator<V>.hasNext", "Iterator<V>.next", "ImmutableListMultimap.Builder<K, V>.put", "Function<? super V,K>.apply", "ImmutableListMultimap.Builder<K, V>.build"], "method_name": "Multimaps.index", "method_implementation": "{\n    checkNotNull(keyFunction);\n    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n    while (values.hasNext()) {\n        V value = values.next();\n        checkNotNull(value, values);\n        builder.put(keyFunction.apply(value), value);\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Creates an index {@code ImmutableListMultimap} that contains the results of applying a\n * specified function to each item in an {@code Iterator} of values. Each value will be stored as\n * a value in the resulting multimap, yielding a multimap with the same size as the input\n * iterator. The key used to store that value in the multimap will be the result of calling the\n * function on that value. The resulting multimap is created as an immutable snapshot. In the\n * returned multimap, keys appear in the order they are first encountered, and the values\n * corresponding to each key appear in the same order as they are encountered.\n *\n * <p>For example,\n *\n * <pre>{@code\n * List<String> badGuys =\n *     Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n * Function<String, Integer> stringLengthFunction = ...;\n * Multimap<Integer, String> index =\n *     Multimaps.index(badGuys.iterator(), stringLengthFunction);\n * System.out.println(index);\n * }</pre>\n *\n * <p>prints\n *\n * <pre>{@code\n * {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}\n * }</pre>\n *\n * <p>The returned multimap is serializable if its keys and values are all serializable.\n *\n * @param values the values to use when constructing the {@code ImmutableListMultimap}\n * @param keyFunction the function used to produce the key for each value\n * @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code\n *     keyFunction} on each value in the input collection to that value\n * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code\n *     keyFunction} produces {@code null} for any key\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6103, "method_signature": "ImmutableListMultimap<K,V> index(Iterator, Function)", "filename": "Multimaps.index.json"}
{"callee_method_names": ["Multimap<? extends V,? extends K>.entries", "M.put", "int.getValue", "int.getKey"], "method_name": "Multimaps.invertFrom", "method_implementation": "{\n    checkNotNull(dest);\n    for (Map.Entry<? extends V, ? extends K> entry : source.entries()) {\n        dest.put(entry.getValue(), entry.getKey());\n    }\n    return dest;\n}", "repo_id": "5", "comment": "/**\n * Copies each key-value mapping in {@code source} into {@code dest}, with its key and value\n * reversed.\n *\n * <p>If {@code source} is an {@link ImmutableMultimap}, consider using {@link\n * ImmutableMultimap#inverse} instead.\n *\n * @param source any multimap\n * @param dest the multimap to copy into; usually empty\n * @return {@code dest}\n */\n", "repo_name": "guava-master/", "id": 6087, "method_signature": "M invertFrom(Multimap, M)", "filename": "Multimaps.invertFrom.json"}
{"callee_method_names": [], "method_name": "Multimaps.newListMultimap", "method_implementation": "{\n    return new CustomListMultimap<>(map, factory);\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code ListMultimap} that uses the provided map and factory. It can generate a\n * multimap based on arbitrary {@link Map} and {@link List} classes.\n *\n * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n * toString} methods for the multimap and its returned views. The multimap's {@code get}, {@code\n * removeAll}, and {@code replaceValues} methods return {@code RandomAccess} lists if the factory\n * does. However, the multimap's {@code get} method returns instances of a different class than\n * does {@code factory.get()}.\n *\n * <p>The multimap is serializable if {@code map}, {@code factory}, the lists generated by {@code\n * factory}, and the multimap contents are all serializable.\n *\n * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n * #synchronizedListMultimap}.\n *\n * <p>Call this method only when the simpler methods {@link ArrayListMultimap#create()} and {@link\n * LinkedListMultimap#create()} won't suffice.\n *\n * <p>Note: the multimap assumes complete ownership over of {@code map} and the lists returned by\n * {@code factory}. Those objects should not be manually updated, they should be empty when\n * provided, and they should not use soft, weak, or phantom references.\n *\n * @param map place to store the mapping from each key to its corresponding values\n * @param factory supplier of new, empty lists that will each hold all values for a given key\n * @throws IllegalArgumentException if {@code map} is not empty\n */\n", "repo_name": "guava-master/", "id": 6081, "method_signature": "ListMultimap<K,V> newListMultimap(Map, Supplier)", "filename": "Multimaps.newListMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.newSetMultimap", "method_implementation": "{\n    return new CustomSetMultimap<>(map, factory);\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code SetMultimap} that uses the provided map and factory. It can generate a\n * multimap based on arbitrary {@link Map} and {@link Set} classes.\n *\n * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n * toString} methods for the multimap and its returned views. However, the multimap's {@code get}\n * method returns instances of a different class than {@code factory.get()} does.\n *\n * <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code\n * factory}, and the multimap contents are all serializable.\n *\n * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n * #synchronizedSetMultimap}.\n *\n * <p>Call this method only when the simpler methods {@link HashMultimap#create()}, {@link\n * LinkedHashMultimap#create()}, {@link TreeMultimap#create()}, and {@link\n * TreeMultimap#create(Comparator, Comparator)} won't suffice.\n *\n * <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by\n * {@code factory}. Those objects should not be manually updated and they should not use soft,\n * weak, or phantom references.\n *\n * @param map place to store the mapping from each key to its corresponding values\n * @param factory supplier of new, empty sets that will each hold all values for a given key\n * @throws IllegalArgumentException if {@code map} is not empty\n */\n", "repo_name": "guava-master/", "id": 6083, "method_signature": "SetMultimap<K,V> newSetMultimap(Map, Supplier)", "filename": "Multimaps.newSetMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.newSortedSetMultimap", "method_implementation": "{\n    return new CustomSortedSetMultimap<>(map, factory);\n}", "repo_id": "5", "comment": "/**\n * Creates a new {@code SortedSetMultimap} that uses the provided map and factory. It can generate\n * a multimap based on arbitrary {@link Map} and {@link SortedSet} classes.\n *\n * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n * toString} methods for the multimap and its returned views. However, the multimap's {@code get}\n * method returns instances of a different class than {@code factory.get()} does.\n *\n * <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code\n * factory}, and the multimap contents are all serializable.\n *\n * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n * #synchronizedSortedSetMultimap}.\n *\n * <p>Call this method only when the simpler methods {@link TreeMultimap#create()} and {@link\n * TreeMultimap#create(Comparator, Comparator)} won't suffice.\n *\n * <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by\n * {@code factory}. Those objects should not be manually updated and they should not use soft,\n * weak, or phantom references.\n *\n * @param map place to store the mapping from each key to its corresponding values\n * @param factory supplier of new, empty sorted sets that will each hold all values for a given\n *     key\n * @throws IllegalArgumentException if {@code map} is not empty\n */\n", "repo_name": "guava-master/", "id": 6085, "method_signature": "SortedSetMultimap<K,V> newSortedSetMultimap(Map, Supplier)", "filename": "Multimaps.newSortedSetMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.toMultimap", "method_implementation": "{\n    return CollectCollectors.<T, K, V, M>toMultimap(keyFunction, valueFunction, multimapSupplier);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} accumulating entries into a {@code Multimap} generated from the\n * specified supplier. The keys and values of the entries are the result of applying the provided\n * mapping functions to the input elements, accumulated in the encounter order of the stream.\n *\n * <p>Example:\n *\n * <pre>{@code\n * static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP =\n *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n *         .collect(\n *             toMultimap(\n *                  str -> str.charAt(0),\n *                  str -> str.substring(1),\n *                  MultimapBuilder.treeKeys().arrayListValues()::build));\n *\n * // is equivalent to\n *\n * static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP;\n *\n * static {\n *     FIRST_LETTER_MULTIMAP = MultimapBuilder.treeKeys().arrayListValues().build();\n *     FIRST_LETTER_MULTIMAP.put('b', \"anana\");\n *     FIRST_LETTER_MULTIMAP.put('a', \"pple\");\n *     FIRST_LETTER_MULTIMAP.put('a', \"sparagus\");\n *     FIRST_LETTER_MULTIMAP.put('c', \"arrot\");\n *     FIRST_LETTER_MULTIMAP.put('c', \"herry\");\n * }\n * }</pre>\n *\n * <p>To collect to an {@link ImmutableMultimap}, use either {@link\n * ImmutableSetMultimap#toImmutableSetMultimap} or {@link\n * ImmutableListMultimap#toImmutableListMultimap}.\n */\n", "repo_name": "guava-master/", "id": 6078, "method_signature": "Collector<T,?,M> toMultimap(java.util.function.Function, java.util.function.Function, java.util.function.Supplier)", "filename": "Multimaps.toMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.transformEntries", "method_implementation": "{\n    return new TransformedEntriesListMultimap<>(fromMap, transformer);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of a {@code ListMultimap} whose values are derived from the original multimap's\n * entries. In contrast to {@link #transformValues(ListMultimap, Function)}, this method's\n * entry-transformation logic may depend on the key as well as the value.\n *\n * <p>All other properties of the transformed multimap, such as iteration order, are left intact.\n * For example, the code:\n *\n * <pre>{@code\n * Multimap<String, Integer> multimap =\n *     ImmutableMultimap.of(\"a\", 1, \"a\", 4, \"b\", 6);\n * EntryTransformer<String, Integer, String> transformer =\n *     new EntryTransformer<String, Integer, String>() {\n *       public String transformEntry(String key, Integer value) {\n *         return key + value;\n *       }\n *     };\n * Multimap<String, String> transformed =\n *     Multimaps.transformEntries(multimap, transformer);\n * System.out.println(transformed);\n * }</pre>\n *\n * ... prints {@code {\"a\"=[\"a1\", \"a4\"], \"b\"=[\"b6\"]}}.\n *\n * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n * supports removal operations, and these are reflected in the underlying multimap.\n *\n * <p>It's acceptable for the underlying multimap to contain null keys and null values provided\n * that the transformer is capable of accepting null inputs. The transformed multimap might\n * contain null values if the transformer sometimes gives a null result.\n *\n * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n * is.\n *\n * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n * multimap to be a view, but it means that the transformer will be applied many times for bulk\n * operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform\n * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap\n * doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.\n *\n * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n * transformed multimap.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6102, "method_signature": "ListMultimap<K,V2> transformEntries(ListMultimap, EntryTransformer)", "filename": "Multimaps.transformEntries.json"}
{"callee_method_names": [], "method_name": "Multimaps.transformValues", "method_implementation": "{\n    checkNotNull(function);\n    EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);\n    return transformEntries(fromMultimap, transformer);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of a {@code ListMultimap} where each value is transformed by a function. All\n * other properties of the multimap, such as iteration order, are left intact. For example, the\n * code:\n *\n * <pre>{@code\n * ListMultimap<String, Integer> multimap\n *      = ImmutableListMultimap.of(\"a\", 4, \"a\", 16, \"b\", 9);\n * Function<Integer, Double> sqrt =\n *     new Function<Integer, Double>() {\n *       public Double apply(Integer in) {\n *         return Math.sqrt((int) in);\n *       }\n *     };\n * ListMultimap<String, Double> transformed = Multimaps.transformValues(map,\n *     sqrt);\n * System.out.println(transformed);\n * }</pre>\n *\n * ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.\n *\n * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n * supports removal operations, and these are reflected in the underlying multimap.\n *\n * <p>It's acceptable for the underlying multimap to contain null keys, and even null values\n * provided that the function is capable of accepting null input. The transformed multimap might\n * contain null values, if the function sometimes gives a null result.\n *\n * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n * is.\n *\n * <p>The function is applied lazily, invoked when needed. This is necessary for the returned\n * multimap to be a view, but it means that the function will be applied many times for bulk\n * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned\n * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your\n * choosing.\n *\n * @since 7.0\n */\n", "repo_name": "guava-master/", "id": 6100, "method_signature": "ListMultimap<K,V2> transformValues(ListMultimap, Function)", "filename": "Multimaps.transformValues.json"}
{"callee_method_names": [], "method_name": "Multimaps.unmodifiableEntries", "method_implementation": "{\n    if (entries instanceof Set) {\n        return Maps.unmodifiableEntrySet((Set<Entry<K, V>>) entries);\n    }\n    return new Maps.UnmodifiableEntries<>(Collections.unmodifiableCollection(entries));\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified collection of entries. The {@link Entry#setValue}\n * operation throws an {@link UnsupportedOperationException}. If the specified collection is a\n * {@code Set}, the returned collection is also a {@code Set}.\n *\n * @param entries the entries for which to return an unmodifiable view\n * @return an unmodifiable view of the entries\n */\n", "repo_name": "guava-master/", "id": 6095, "method_signature": "Collection<Entry<K,V>> unmodifiableEntries(Collection)", "filename": "Multimaps.unmodifiableEntries.json"}
{"callee_method_names": [], "method_name": "Multimaps.unmodifiableListMultimap", "method_implementation": "{\n    return checkNotNull(delegate);\n}", "repo_id": "5", "comment": "/**\n * Simply returns its argument.\n *\n * @deprecated no need to use this\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6093, "method_signature": "ListMultimap<K,V> unmodifiableListMultimap(ImmutableListMultimap)", "filename": "Multimaps.unmodifiableListMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.unmodifiableMultimap", "method_implementation": "{\n    if (delegate instanceof UnmodifiableMultimap || delegate instanceof ImmutableMultimap) {\n        return delegate;\n    }\n    return new UnmodifiableMultimap<>(delegate);\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified multimap. Query operations on the returned\n * multimap \"read through\" to the specified multimap, and attempts to modify the returned\n * multimap, either directly or through the multimap's views, result in an {@code\n * UnsupportedOperationException}.\n *\n * <p>The returned multimap will be serializable if the specified multimap is serializable.\n *\n * @param delegate the multimap for which an unmodifiable view is to be returned\n * @return an unmodifiable view of the specified multimap\n */\n", "repo_name": "guava-master/", "id": 6088, "method_signature": "Multimap<K,V> unmodifiableMultimap(Multimap)", "filename": "Multimaps.unmodifiableMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.unmodifiableSetMultimap", "method_implementation": "{\n    return checkNotNull(delegate);\n}", "repo_id": "5", "comment": "/**\n * Simply returns its argument.\n *\n * @deprecated no need to use this\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6090, "method_signature": "SetMultimap<K,V> unmodifiableSetMultimap(ImmutableSetMultimap)", "filename": "Multimaps.unmodifiableSetMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.unmodifiableSortedSetMultimap", "method_implementation": "{\n    if (delegate instanceof UnmodifiableSortedSetMultimap) {\n        return delegate;\n    }\n    return new UnmodifiableSortedSetMultimap<>(delegate);\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified {@code SortedSetMultimap}. Query operations on\n * the returned multimap \"read through\" to the specified multimap, and attempts to modify the\n * returned multimap, either directly or through the multimap's views, result in an {@code\n * UnsupportedOperationException}.\n *\n * <p>The returned multimap will be serializable if the specified multimap is serializable.\n *\n * @param delegate the multimap for which an unmodifiable view is to be returned\n * @return an unmodifiable view of the specified multimap\n */\n", "repo_name": "guava-master/", "id": 6091, "method_signature": "SortedSetMultimap<K,V> unmodifiableSortedSetMultimap(SortedSetMultimap)", "filename": "Multimaps.unmodifiableSortedSetMultimap.json"}
{"callee_method_names": [], "method_name": "Multimaps.unmodifiableValueCollection", "method_implementation": "{\n    if (collection instanceof SortedSet) {\n        return Collections.unmodifiableSortedSet((SortedSet<V>) collection);\n    } else if (collection instanceof Set) {\n        return Collections.unmodifiableSet((Set<V>) collection);\n    } else if (collection instanceof List) {\n        return Collections.unmodifiableList((List<V>) collection);\n    }\n    return Collections.unmodifiableCollection(collection);\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified collection, preserving the interface for\n * instances of {@code SortedSet}, {@code Set}, {@code List} and {@code Collection}, in that order\n * of preference.\n *\n * @param collection the collection for which to return an unmodifiable view\n * @return an unmodifiable view of the collection\n */\n", "repo_name": "guava-master/", "id": 6094, "method_signature": "Collection<V> unmodifiableValueCollection(Collection)", "filename": "Multimaps.unmodifiableValueCollection.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject"], "method_name": "Multimaps.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(factory);\n    stream.writeObject(backingMap());\n}", "repo_id": "5", "comment": "/**\n * @serialData the factory and the backing map\n */\n", "repo_name": "guava-master/", "id": 6086, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "Multimaps.writeObject.json"}
{"callee_method_names": ["Multimap<String, Integer>.keys", "Multimap<String,Integer>.keys", "Multimap<String, Integer>.keySet", "Multimap<String,Integer>.keySet", "Multimap<String, Integer>.entries", "Multimap<String,Integer>.entries", "Multimap<String, Integer>.asMap", "Multimap<String,Integer>.asMap", "Multimap<String,Integer>.toString", "Multimap<String, Integer>.toString", "Multimap<String,Integer>.hashCode", "Multimap<String, Integer>.hashCode", "Multimap<String, Integer>.asMap", "Multimap<String, Integer>.asMap", "Multimap<String, Integer>.entries"], "method_name": "MultimapsTest.checkUnmodifiableMultimap", "method_implementation": "{\n    Multimap<String, Integer> unmodifiable = prepareUnmodifiableTests(multimap, permitsDuplicates, nullKey, nullValue);\n    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(unmodifiable, \"test\", 123);\n    assertUnmodifiableIterableInTandem(unmodifiable.keys(), multimap.keys());\n    assertUnmodifiableIterableInTandem(unmodifiable.keySet(), multimap.keySet());\n    assertUnmodifiableIterableInTandem(unmodifiable.entries(), multimap.entries());\n    assertUnmodifiableIterableInTandem(unmodifiable.asMap().entrySet(), multimap.asMap().entrySet());\n    assertEquals(multimap.toString(), unmodifiable.toString());\n    assertEquals(multimap.hashCode(), unmodifiable.hashCode());\n    assertEquals(multimap, unmodifiable);\n    assertThat(unmodifiable.asMap().get(\"bar\")).containsExactly(5, -1);\n    assertNull(unmodifiable.asMap().get(\"missing\"));\n    assertFalse(unmodifiable.entries() instanceof Serializable);\n}", "repo_id": "5", "comment": "/**\n * The supplied multimap will be mutated and an unmodifiable instance used in its stead. If the\n * multimap does not support null keys or values, alternatives may be specified for tests\n * involving nulls.\n */\n", "repo_name": "guava-master/", "id": 4001, "method_signature": "void checkUnmodifiableMultimap(Multimap, boolean, String, Integer)", "filename": "MultimapsTest.checkUnmodifiableMultimap.json"}
{"callee_method_names": ["Multimap<String,Integer>.clear", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.put", "Multimap<String,Integer>.size", "Multimap<String,Integer>.size"], "method_name": "MultimapsTest.prepareUnmodifiableTests", "method_implementation": "{\n    multimap.clear();\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 2);\n    multimap.put(\"foo\", 3);\n    multimap.put(\"bar\", 5);\n    multimap.put(\"bar\", -1);\n    multimap.put(nullKey, nullValue);\n    multimap.put(\"foo\", nullValue);\n    multimap.put(nullKey, 5);\n    multimap.put(\"foo\", 2);\n    if (permitsDuplicates) {\n        assertEquals(9, multimap.size());\n    } else {\n        assertEquals(8, multimap.size());\n    }\n    Multimap<String, Integer> unmodifiable;\n    if (multimap instanceof SortedSetMultimap) {\n        unmodifiable = Multimaps.unmodifiableSortedSetMultimap((SortedSetMultimap<String, Integer>) multimap);\n    } else if (multimap instanceof SetMultimap) {\n        unmodifiable = Multimaps.unmodifiableSetMultimap((SetMultimap<String, Integer>) multimap);\n    } else if (multimap instanceof ListMultimap) {\n        unmodifiable = Multimaps.unmodifiableListMultimap((ListMultimap<String, Integer>) multimap);\n    } else {\n        unmodifiable = Multimaps.unmodifiableMultimap(multimap);\n    }\n    return unmodifiable;\n}", "repo_id": "5", "comment": "/**\n * Prepares the multimap for unmodifiable tests, returning an unmodifiable view of the map.\n */\n", "repo_name": "guava-master/", "id": 4002, "method_signature": "Multimap<String,Integer> prepareUnmodifiableTests(Multimap, boolean, String, Integer)", "filename": "MultimapsTest.prepareUnmodifiableTests.json"}
{"callee_method_names": ["Entry<K,V1>.getElement", "Entry<K,V1>.getCount", "Consumer<? super E>.accept"], "method_name": "Multiset.forEach", "method_implementation": "{\n    checkNotNull(action);\n    entrySet().forEach(entry -> {\n        E elem = entry.getElement();\n        int count = entry.getCount();\n        for (int i = 0; i < count; i++) {\n            action.accept(elem);\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>Elements that occur multiple times in the multiset will be passed to the {@code Consumer}\n * correspondingly many times, though not necessarily sequentially.\n */\n", "repo_name": "guava-master/", "id": 3262, "method_signature": "void forEach(Consumer)", "filename": "Multiset.forEach.json"}
{"callee_method_names": [], "method_name": "MultisetElementSetTester.getElementSetDuplicateInitializingMethods", "method_implementation": "{\n    return Arrays.asList(Helpers.getMethod(MultisetElementSetTester.class, \"testElementSetRemoveDuplicatePropagatesToMultiset\"));\n}", "repo_id": "5", "comment": "/**\n * Returns {@link Method} instances for the read tests that assume multisets support duplicates so\n * that the test of {@code Multisets.forSet()} can suppress them.\n */\n", "repo_name": "guava-master/", "id": 4169, "method_signature": "List<Method> getElementSetDuplicateInitializingMethods()", "filename": "MultisetElementSetTester.getElementSetDuplicateInitializingMethods.json"}
{"callee_method_names": [], "method_name": "MultisetForEachEntryTester.getForEachEntryDuplicateInitializingMethods", "method_implementation": "{\n    return Arrays.asList(Helpers.getMethod(MultisetForEachEntryTester.class, \"testForEachEntryDuplicates\"));\n}", "repo_id": "5", "comment": "/**\n * Returns {@link Method} instances for the remove tests that assume multisets support duplicates\n * so that the test of {@code Multisets.forSet()} can suppress them.\n */\n", "repo_name": "guava-master/", "id": 704, "method_signature": "List<Method> getForEachEntryDuplicateInitializingMethods()", "filename": "MultisetForEachEntryTester.getForEachEntryDuplicateInitializingMethods.json"}
{"callee_method_names": [], "method_name": "MultisetIteratorTester.getIteratorDuplicateInitializingMethods", "method_implementation": "{\n    return Arrays.asList(Helpers.getMethod(MultisetIteratorTester.class, \"testIteratorKnownOrder\"), Helpers.getMethod(MultisetIteratorTester.class, \"testIteratorUnknownOrder\"), Helpers.getMethod(MultisetIteratorTester.class, \"testRemovingIteratorKnownOrder\"), Helpers.getMethod(MultisetIteratorTester.class, \"testRemovingIteratorUnknownOrder\"));\n}", "repo_id": "5", "comment": "/**\n * Returns {@link Method} instances for the tests that assume multisets support duplicates so that\n * the test of {@code Multisets.forSet()} can suppress them.\n */\n", "repo_name": "guava-master/", "id": 4180, "method_signature": "List<Method> getIteratorDuplicateInitializingMethods()", "filename": "MultisetIteratorTester.getIteratorDuplicateInitializingMethods.json"}
{"callee_method_names": ["List<E>.addAll", "Entry<E>.getCount", "Entry<E>.getElement", "List<E>.addAll", "Entry<E>.getCount", "Entry<E>.getElement", "List<E>.toArray"], "method_name": "MultisetNavigationTester.resetWithHole", "method_implementation": "{\n    List<E> container = new ArrayList<>();\n    container.addAll(Collections.nCopies(a.getCount(), a.getElement()));\n    container.addAll(Collections.nCopies(c.getCount(), c.getElement()));\n    super.resetContainer(getSubjectGenerator().create(container.toArray()));\n    sortedMultiset = (SortedMultiset<E>) getMultiset();\n}", "repo_id": "5", "comment": "/**\n * Resets the contents of sortedMultiset to have entries a, c, for the navigation tests.\n */\n", "repo_name": "guava-master/", "id": 4162, "method_signature": "void resetWithHole()", "filename": "MultisetNavigationTester.resetWithHole.json"}
{"callee_method_names": [], "method_name": "MultisetRemoveTester.getRemoveDuplicateInitializingMethods", "method_implementation": "{\n    return Arrays.asList(Helpers.getMethod(MultisetRemoveTester.class, \"testRemove_some_occurrences_present\"));\n}", "repo_id": "5", "comment": "/**\n * Returns {@link Method} instances for the remove tests that assume multisets support duplicates\n * so that the test of {@code Multisets.forSet()} can suppress them.\n */\n", "repo_name": "guava-master/", "id": 4183, "method_signature": "List<Method> getRemoveDuplicateInitializingMethods()", "filename": "MultisetRemoveTester.getRemoveDuplicateInitializingMethods.json"}
{"callee_method_names": ["AbstractMapBasedMultiset<? extends E>.isEmpty", "AbstractMapBasedMultiset<? extends E>.addTo"], "method_name": "Multisets.addAllImpl", "method_implementation": "{\n    if (elements.isEmpty()) {\n        return false;\n    }\n    elements.addTo(self);\n    return true;\n}", "repo_id": "5", "comment": "/**\n * A specialization of {@code addAllImpl} for when {@code elements} is an\n * AbstractMapBasedMultiset.\n */\n", "repo_name": "guava-master/", "id": 6207, "method_signature": "boolean addAllImpl(Multiset, AbstractMapBasedMultiset)", "filename": "Multisets.addAllImpl.json"}
{"callee_method_names": ["Multiset<?>.entrySet", "Multiset<?>.count", "int.getElement", "int.getCount"], "method_name": "Multisets.containsOccurrences", "method_implementation": "{\n    checkNotNull(superMultiset);\n    checkNotNull(subMultiset);\n    for (Entry<?> entry : subMultiset.entrySet()) {\n        int superCount = superMultiset.count(entry.getElement());\n        if (superCount < entry.getCount()) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code subMultiset.count(o) <= superMultiset.count(o)} for all {@code\n * o}.\n *\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6196, "method_signature": "boolean containsOccurrences(Multiset, Multiset)", "filename": "Multisets.containsOccurrences.json"}
{"callee_method_names": ["Multiset<E>.entrySet"], "method_name": "Multisets.copyHighestCountFirst", "method_implementation": "{\n    Entry<E>[] entries = (Entry<E>[]) multiset.entrySet().toArray(new Entry[0]);\n    Arrays.sort(entries, DecreasingCount.INSTANCE);\n    return ImmutableMultiset.copyFromEntries(Arrays.asList(entries));\n}", "repo_id": "5", "comment": "/**\n * Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order puts\n * the highest count first, with ties broken by the iteration order of the original multiset.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 6214, "method_signature": "ImmutableMultiset<E> copyHighestCountFirst(Multiset)", "filename": "Multisets.copyHighestCountFirst.json"}
{"callee_method_names": ["Multiset<E>.count", "Multiset<?>.count", "Multiset<E>.entrySet", "Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Entry<E>.getElement", "Entry<E>.getCount", "Multiset<?>.count", "Multiset<E>.entrySet", "Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Entry<E>.getElement", "Entry<E>.getCount", "Multiset<?>.count"], "method_name": "Multisets.difference", "method_implementation": "{\n    checkNotNull(multiset1);\n    checkNotNull(multiset2);\n    // TODO(lowasser): consider making the entries live views\n    return new ViewMultiset<E>() {\n\n        @Override\n        public int count(@CheckForNull Object element) {\n            int count1 = multiset1.count(element);\n            return (count1 == 0) ? 0 : Math.max(0, count1 - multiset2.count(element));\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        Iterator<E> elementIterator() {\n            final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n            return new AbstractIterator<E>() {\n\n                @Override\n                @CheckForNull\n                protected E computeNext() {\n                    while (iterator1.hasNext()) {\n                        Entry<E> entry1 = iterator1.next();\n                        E element = entry1.getElement();\n                        if (entry1.getCount() > multiset2.count(element)) {\n                            return element;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        Iterator<Entry<E>> entryIterator() {\n            final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n            return new AbstractIterator<Entry<E>>() {\n\n                @Override\n                @CheckForNull\n                protected Entry<E> computeNext() {\n                    while (iterator1.hasNext()) {\n                        Entry<E> entry1 = iterator1.next();\n                        E element = entry1.getElement();\n                        int count = entry1.getCount() - multiset2.count(element);\n                        if (count > 0) {\n                            return immutableEntry(element, count);\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        int distinctElements() {\n            return Iterators.size(entryIterator());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the\n * count of each element is the result of the <i>zero-truncated subtraction</i> of its count in\n * the second multiset from its count in the first multiset, with elements that would have a count\n * of 0 not included. The iteration order of the returned multiset matches that of the element set\n * of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.\n *\n * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6195, "method_signature": "Multiset<E> difference(Multiset, Multiset)", "filename": "Multisets.difference.json"}
{"callee_method_names": ["Multiset.Entry<?>.getCount", "Multiset.Entry<?>.getElement"], "method_name": "Multisets.equals", "method_implementation": "{\n    if (object instanceof Multiset.Entry) {\n        Multiset.Entry<?> that = (Multiset.Entry<?>) object;\n        return this.getCount() == that.getCount() && Objects.equal(this.getElement(), that.getElement());\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Indicates whether an object equals this entry, following the behavior specified in {@link\n * Multiset.Entry#equals}.\n */\n", "repo_name": "guava-master/", "id": 6201, "method_signature": "boolean equals(Object)", "filename": "Multisets.equals.json"}
{"callee_method_names": ["Multiset<?>.size", "Multiset<?>.size", "Multiset<?>.entrySet", "Multiset<?>.entrySet", "Multiset<?>.entrySet", "Multiset<?>.count", "Entry<?>.getElement", "Entry<?>.getCount"], "method_name": "Multisets.equalsImpl", "method_implementation": "{\n    if (object == multiset) {\n        return true;\n    }\n    if (object instanceof Multiset) {\n        Multiset<?> that = (Multiset<?>) object;\n        /*\n       * We can't simply check whether the entry sets are equal, since that\n       * approach fails when a TreeMultiset has a comparator that returns 0\n       * when passed unequal elements.\n       */\n        if (multiset.size() != that.size() || multiset.entrySet().size() != that.entrySet().size()) {\n            return false;\n        }\n        for (Entry<?> entry : that.entrySet()) {\n            if (multiset.count(entry.getElement()) != entry.getCount()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Multiset#equals}.\n */\n", "repo_name": "guava-master/", "id": 6204, "method_signature": "boolean equalsImpl(Multiset, Object)", "filename": "Multisets.equalsImpl.json"}
{"callee_method_names": [], "method_name": "Multisets.filter", "method_implementation": "{\n    if (unfiltered instanceof FilteredMultiset) {\n        // Support clear(), removeAll(), and retainAll() when filtering a filtered\n        // collection.\n        FilteredMultiset<E> filtered = (FilteredMultiset<E>) unfiltered;\n        Predicate<E> combinedPredicate = Predicates.<E>and(filtered.predicate, predicate);\n        return new FilteredMultiset<E>(filtered.unfiltered, combinedPredicate);\n    }\n    return new FilteredMultiset<E>(unfiltered, predicate);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the elements of {@code unfiltered} that satisfy a predicate. The returned\n * multiset is a live view of {@code unfiltered}; changes to one affect the other.\n *\n * <p>The resulting multiset's iterators, and those of its {@code entrySet()} and {@code\n * elementSet()}, do not support {@code remove()}. However, all other multiset methods supported\n * by {@code unfiltered} are supported by the returned multiset. When given an element that\n * doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw\n * an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code\n * clear()} are called on the filtered multiset, only elements that satisfy the filter will be\n * removed from the underlying multiset.\n *\n * <p>The returned multiset isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered multiset's methods, such as {@code size()}, iterate across every\n * element in the underlying multiset and determine which elements satisfy the filter. When a live\n * view is <i>not</i> needed, it may be faster to copy the returned multiset and use the copy.\n *\n * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n * {@link Predicate#apply}. Do not provide a predicate such as {@code\n * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n * Iterables#filter(Iterable, Class)} for related functionality.)\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6190, "method_signature": "Multiset<E> filter(Multiset, Predicate)", "filename": "Multisets.filter.json"}
{"callee_method_names": ["E.hashCode"], "method_name": "Multisets.hashCode", "method_implementation": "{\n    E e = getElement();\n    return ((e == null) ? 0 : e.hashCode()) ^ getCount();\n}", "repo_id": "5", "comment": "/**\n * Return this entry's hash code, following the behavior specified in {@link\n * Multiset.Entry#hashCode}.\n */\n", "repo_name": "guava-master/", "id": 6202, "method_signature": "int hashCode()", "filename": "Multisets.hashCode.json"}
{"callee_method_names": [], "method_name": "Multisets.inferDistinctElements", "method_implementation": "{\n    if (elements instanceof Multiset) {\n        return ((Multiset<?>) elements).elementSet().size();\n    }\n    // initial capacity will be rounded up to 16\n    return 11;\n}", "repo_id": "5", "comment": "/**\n * Returns the expected number of distinct elements given the specified elements. The number of\n * distinct elements is only computed if {@code elements} is an instance of {@code Multiset};\n * otherwise the default value of 11 is returned.\n */\n", "repo_name": "guava-master/", "id": 6191, "method_signature": "int inferDistinctElements(Iterable)", "filename": "Multisets.inferDistinctElements.json"}
{"callee_method_names": ["Multiset<E>.count", "Multiset<?>.count", "Multiset<E>.elementSet", "Multiset<?>.elementSet", "Multiset<E>.entrySet", "Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Entry<E>.getElement", "Entry<E>.getCount", "Multiset<?>.count"], "method_name": "Multisets.intersection", "method_implementation": "{\n    checkNotNull(multiset1);\n    checkNotNull(multiset2);\n    return new ViewMultiset<E>() {\n\n        @Override\n        public int count(@CheckForNull Object element) {\n            int count1 = multiset1.count(element);\n            return (count1 == 0) ? 0 : Math.min(count1, multiset2.count(element));\n        }\n\n        @Override\n        Set<E> createElementSet() {\n            return Sets.intersection(multiset1.elementSet(), multiset2.elementSet());\n        }\n\n        @Override\n        Iterator<E> elementIterator() {\n            throw new AssertionError(\"should never be called\");\n        }\n\n        @Override\n        Iterator<Entry<E>> entryIterator() {\n            final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n            // TODO(lowasser): consider making the entries live views\n            return new AbstractIterator<Entry<E>>() {\n\n                @Override\n                @CheckForNull\n                protected Entry<E> computeNext() {\n                    while (iterator1.hasNext()) {\n                        Entry<E> entry1 = iterator1.next();\n                        E element = entry1.getElement();\n                        int count = Math.min(entry1.getCount(), multiset2.count(element));\n                        if (count > 0) {\n                            return immutableEntry(element, count);\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,\n * the count of each element is the <i>minimum</i> of its counts in the two backing multisets,\n * with elements that would have a count of 0 not included. The iteration order of the returned\n * multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the\n * same element appearing consecutively.\n *\n * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n *\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 6193, "method_signature": "Multiset<E> intersection(Multiset, Multiset)", "filename": "Multisets.intersection.json"}
{"callee_method_names": ["Multiset<?>.entrySet", "Entry<?>.getCount"], "method_name": "Multisets.linearTimeSizeImpl", "method_implementation": "{\n    long size = 0;\n    for (Entry<?> entry : multiset.entrySet()) {\n        size += entry.getCount();\n    }\n    return Ints.saturatedCast(size);\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Multiset#size}.\n */\n", "repo_name": "guava-master/", "id": 6213, "method_signature": "int linearTimeSizeImpl(Multiset)", "filename": "Multisets.linearTimeSizeImpl.json"}
{"callee_method_names": ["Entry<?>.getElement", "Entry<?>.getCount", "Multiset<@Nullable Object>.setCount"], "method_name": "Multisets.remove", "method_implementation": "{\n    if (object instanceof Multiset.Entry) {\n        Entry<?> entry = (Entry<?>) object;\n        Object element = entry.getElement();\n        int entryCount = entry.getCount();\n        if (entryCount != 0) {\n            // Safe as long as we never add a new entry, which we won't.\n            // (Presumably it can still throw CCE/NPE but only if the underlying Multiset does.)\n            @SuppressWarnings({ \"unchecked\", \"nullness\" })\n            Multiset<@Nullable Object> multiset = (Multiset<@Nullable Object>) multiset();\n            return multiset.setCount(element, entryCount, 0);\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "// GWT compiler warning; see contains().\n", "repo_name": "guava-master/", "id": 6212, "method_signature": "boolean remove(Object)", "filename": "Multisets.remove.json"}
{"callee_method_names": ["Multiset<?>.elementSet"], "method_name": "Multisets.removeAllImpl", "method_implementation": "{\n    Collection<?> collection = (elementsToRemove instanceof Multiset) ? ((Multiset<?>) elementsToRemove).elementSet() : elementsToRemove;\n    return self.elementSet().removeAll(collection);\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Multiset#removeAll}.\n */\n", "repo_name": "guava-master/", "id": 6208, "method_signature": "boolean removeAllImpl(Multiset, Collection)", "filename": "Multisets.removeAllImpl.json"}
{"callee_method_names": ["Multiset<?>.entrySet", "Iterator<? extends Entry<?>>.hasNext", "Iterator<? extends Entry<?>>.next", "Multiset<?>.count", "Entry<?>.getElement", "Entry<?>.getCount", "Iterator<? extends Entry<?>>.remove", "Multiset<?>.remove", "Entry<?>.getElement"], "method_name": "Multisets.removeOccurrences", "method_implementation": "{\n    checkNotNull(multisetToModify);\n    checkNotNull(occurrencesToRemove);\n    boolean changed = false;\n    Iterator<? extends Entry<?>> entryIterator = multisetToModify.entrySet().iterator();\n    while (entryIterator.hasNext()) {\n        Entry<?> entry = entryIterator.next();\n        int removeCount = occurrencesToRemove.count(entry.getElement());\n        if (removeCount >= entry.getCount()) {\n            entryIterator.remove();\n            changed = true;\n        } else if (removeCount > 0) {\n            multisetToModify.remove(entry.getElement(), removeCount);\n            changed = true;\n        }\n    }\n    return changed;\n}", "repo_id": "5", "comment": "/**\n * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n * occurrence of {@code e} in {@code multisetToModify}.\n *\n * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n * occurrencesToRemove.count(e))}.\n *\n * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n * sometimes more efficient than, the following:\n *\n * <pre>{@code\n * for (E e : occurrencesToRemove) {\n *   multisetToModify.remove(e);\n * }\n * }</pre>\n *\n * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n * @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)\n */\n", "repo_name": "guava-master/", "id": 6200, "method_signature": "boolean removeOccurrences(Multiset, Multiset)", "filename": "Multisets.removeOccurrences.json"}
{"callee_method_names": ["Multiset<?>.elementSet"], "method_name": "Multisets.retainAllImpl", "method_implementation": "{\n    checkNotNull(elementsToRetain);\n    Collection<?> collection = (elementsToRetain instanceof Multiset) ? ((Multiset<?>) elementsToRetain).elementSet() : elementsToRetain;\n    return self.elementSet().retainAll(collection);\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Multiset#retainAll}.\n */\n", "repo_name": "guava-master/", "id": 6209, "method_signature": "boolean retainAllImpl(Multiset, Collection)", "filename": "Multisets.retainAllImpl.json"}
{"callee_method_names": [], "method_name": "Multisets.retainOccurrences", "method_implementation": "{\n    return retainOccurrencesImpl(multisetToModify, multisetToRetain);\n}", "repo_id": "5", "comment": "/**\n * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code\n * multisetToRetain.count(e)}.\n *\n * <p>To be precise, {@code multisetToModify.count(e)} is set to {@code\n * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link\n * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},\n * but mutates {@code multisetToModify} instead of returning a view.\n *\n * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of\n * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all\n * other elements.\n *\n * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 6197, "method_signature": "boolean retainOccurrences(Multiset, Multiset)", "filename": "Multisets.retainOccurrences.json"}
{"callee_method_names": ["Multiset<E>.entrySet", "Iterator<Entry<E>>.hasNext", "Iterator<Entry<E>>.next", "Multiset<?>.count", "Entry<E>.getElement", "Iterator<Entry<E>>.remove", "Entry<E>.getCount", "Multiset<E>.setCount", "Entry<E>.getElement"], "method_name": "Multisets.retainOccurrencesImpl", "method_implementation": "{\n    checkNotNull(multisetToModify);\n    checkNotNull(occurrencesToRetain);\n    // Avoiding ConcurrentModificationExceptions is tricky.\n    Iterator<Entry<E>> entryIterator = multisetToModify.entrySet().iterator();\n    boolean changed = false;\n    while (entryIterator.hasNext()) {\n        Entry<E> entry = entryIterator.next();\n        int retainCount = occurrencesToRetain.count(entry.getElement());\n        if (retainCount == 0) {\n            entryIterator.remove();\n            changed = true;\n        } else if (retainCount < entry.getCount()) {\n            multisetToModify.setCount(entry.getElement(), retainCount);\n            changed = true;\n        }\n    }\n    return changed;\n}", "repo_id": "5", "comment": "/**\n * Delegate implementation which cares about the element type.\n */\n", "repo_name": "guava-master/", "id": 6198, "method_signature": "boolean retainOccurrencesImpl(Multiset, Multiset)", "filename": "Multisets.retainOccurrencesImpl.json"}
{"callee_method_names": ["Multiset<E>.count", "Multiset<E>.setCount"], "method_name": "Multisets.setCountImpl", "method_implementation": "{\n    checkNonnegative(oldCount, \"oldCount\");\n    checkNonnegative(newCount, \"newCount\");\n    if (self.count(element) == oldCount) {\n        self.setCount(element, newCount);\n        return true;\n    } else {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * An implementation of {@link Multiset#setCount(Object, int, int)}.\n */\n", "repo_name": "guava-master/", "id": 6211, "method_signature": "boolean setCountImpl(Multiset, E, int, int)", "filename": "Multisets.setCountImpl.json"}
{"callee_method_names": ["Multiset<? extends E>.contains", "Multiset<? extends E>.contains", "Multiset<? extends E>.isEmpty", "Multiset<? extends E>.isEmpty", "Multiset<? extends E>.size", "Multiset<? extends E>.size", "Multiset<? extends E>.count", "Multiset<? extends E>.count", "Multiset<? extends E>.elementSet", "Multiset<? extends E>.elementSet", "Multiset<? extends E>.entrySet", "Multiset<? extends E>.entrySet", "Iterator<? extends Entry<? extends E>>.hasNext", "Iterator<? extends Entry<? extends E>>.next", "Entry<? extends E>.getElement", "Entry<? extends E>.getCount", "Multiset<? extends E>.count", "Iterator<? extends Entry<? extends E>>.hasNext", "Iterator<? extends Entry<? extends E>>.next", "Entry<? extends E>.getElement", "Multiset<? extends E>.contains", "Entry<? extends E>.getCount"], "method_name": "Multisets.sum", "method_implementation": "{\n    checkNotNull(multiset1);\n    checkNotNull(multiset2);\n    // TODO(lowasser): consider making the entries live views\n    return new ViewMultiset<E>() {\n\n        @Override\n        public boolean contains(@CheckForNull Object element) {\n            return multiset1.contains(element) || multiset2.contains(element);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return multiset1.isEmpty() && multiset2.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return IntMath.saturatedAdd(multiset1.size(), multiset2.size());\n        }\n\n        @Override\n        public int count(@CheckForNull Object element) {\n            return multiset1.count(element) + multiset2.count(element);\n        }\n\n        @Override\n        Set<E> createElementSet() {\n            return Sets.union(multiset1.elementSet(), multiset2.elementSet());\n        }\n\n        @Override\n        Iterator<E> elementIterator() {\n            throw new AssertionError(\"should never be called\");\n        }\n\n        @Override\n        Iterator<Entry<E>> entryIterator() {\n            final Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();\n            final Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();\n            return new AbstractIterator<Entry<E>>() {\n\n                @Override\n                @CheckForNull\n                protected Entry<E> computeNext() {\n                    if (iterator1.hasNext()) {\n                        Entry<? extends E> entry1 = iterator1.next();\n                        E element = entry1.getElement();\n                        int count = entry1.getCount() + multiset2.count(element);\n                        return immutableEntry(element, count);\n                    }\n                    while (iterator2.hasNext()) {\n                        Entry<? extends E> entry2 = iterator2.next();\n                        E element = entry2.getElement();\n                        if (!multiset1.contains(element)) {\n                            return immutableEntry(element, entry2.getCount());\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count\n * of each element is the <i>sum</i> of its counts in the two backing multisets. The iteration\n * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n * the members of the element set of {@code multiset2} that are not contained in {@code\n * multiset1}, with repeated occurrences of the same element appearing consecutively.\n *\n * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6194, "method_signature": "Multiset<E> sum(Multiset, Multiset)", "filename": "Multisets.sum.json"}
{"callee_method_names": [], "method_name": "Multisets.toMultiset", "method_implementation": "{\n    return CollectCollectors.toMultiset(elementFunction, countFunction, multisetSupplier);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates elements into a multiset created via the specified\n * {@code Supplier}, whose elements are the result of applying {@code elementFunction} to the\n * inputs, with counts equal to the result of applying {@code countFunction} to the inputs.\n * Elements are added in encounter order.\n *\n * <p>If the mapped elements contain duplicates (according to {@link Object#equals}), the element\n * will be added more than once, with the count summed over all appearances of the element.\n *\n * <p>Note that {@code stream.collect(toMultiset(function, e -> 1, supplier))} is equivalent to\n * {@code stream.map(function).collect(Collectors.toCollection(supplier))}.\n *\n * <p>To collect to an {@link ImmutableMultiset}, use {@link\n * ImmutableMultiset#toImmutableMultiset}.\n */\n", "repo_name": "guava-master/", "id": 6187, "method_signature": "Collector<T,?,M> toMultiset(Function, ToIntFunction, Supplier)", "filename": "Multisets.toMultiset.json"}
{"callee_method_names": [], "method_name": "Multisets.toString", "method_implementation": "{\n    String text = String.valueOf(getElement());\n    int n = getCount();\n    return (n == 1) ? text : (text + \" x \" + n);\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of this multiset entry. The string representation consists of\n * the associated element if the associated count is one, and otherwise the associated element\n * followed by the characters \" x \" (space, x and space) followed by the count. Elements and\n * counts are converted to strings as by {@code String.valueOf}.\n */\n", "repo_name": "guava-master/", "id": 6203, "method_signature": "String toString()", "filename": "Multisets.toString.json"}
{"callee_method_names": ["Multiset<? extends E>.contains", "Multiset<? extends E>.contains", "Multiset<? extends E>.isEmpty", "Multiset<? extends E>.isEmpty", "Multiset<? extends E>.count", "Multiset<? extends E>.count", "Multiset<? extends E>.elementSet", "Multiset<? extends E>.elementSet", "Multiset<? extends E>.entrySet", "Multiset<? extends E>.entrySet", "Iterator<? extends Entry<? extends E>>.hasNext", "Iterator<? extends Entry<? extends E>>.next", "Entry<? extends E>.getElement", "Entry<? extends E>.getCount", "Multiset<? extends E>.count", "Iterator<? extends Entry<? extends E>>.hasNext", "Iterator<? extends Entry<? extends E>>.next", "Entry<? extends E>.getElement", "Multiset<? extends E>.contains", "Entry<? extends E>.getCount"], "method_name": "Multisets.union", "method_implementation": "{\n    checkNotNull(multiset1);\n    checkNotNull(multiset2);\n    return new ViewMultiset<E>() {\n\n        @Override\n        public boolean contains(@CheckForNull Object element) {\n            return multiset1.contains(element) || multiset2.contains(element);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return multiset1.isEmpty() && multiset2.isEmpty();\n        }\n\n        @Override\n        public int count(@CheckForNull Object element) {\n            return Math.max(multiset1.count(element), multiset2.count(element));\n        }\n\n        @Override\n        Set<E> createElementSet() {\n            return Sets.union(multiset1.elementSet(), multiset2.elementSet());\n        }\n\n        @Override\n        Iterator<E> elementIterator() {\n            throw new AssertionError(\"should never be called\");\n        }\n\n        @Override\n        Iterator<Entry<E>> entryIterator() {\n            final Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();\n            final Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();\n            // TODO(lowasser): consider making the entries live views\n            return new AbstractIterator<Entry<E>>() {\n\n                @Override\n                @CheckForNull\n                protected Entry<E> computeNext() {\n                    if (iterator1.hasNext()) {\n                        Entry<? extends E> entry1 = iterator1.next();\n                        E element = entry1.getElement();\n                        int count = Math.max(entry1.getCount(), multiset2.count(element));\n                        return immutableEntry(element, count);\n                    }\n                    while (iterator2.hasNext()) {\n                        Entry<? extends E> entry2 = iterator2.next();\n                        E element = entry2.getElement();\n                        if (!multiset1.contains(element)) {\n                            return immutableEntry(element, entry2.getCount());\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count\n * of each element is the <i>maximum</i> of its counts in the two backing multisets. The iteration\n * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n * the members of the element set of {@code multiset2} that are not contained in {@code\n * multiset1}, with repeated occurrences of the same element appearing consecutively.\n *\n * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6192, "method_signature": "Multiset<E> union(Multiset, Multiset)", "filename": "Multisets.union.json"}
{"callee_method_names": [], "method_name": "Multisets.unmodifiableMultiset", "method_implementation": "{\n    if (multiset instanceof UnmodifiableMultiset || multiset instanceof ImmutableMultiset) {\n        // Since it's unmodifiable, the covariant cast is safe\n        @SuppressWarnings(\"unchecked\")\n        Multiset<E> result = (Multiset<E>) multiset;\n        return result;\n    }\n    return new UnmodifiableMultiset<E>(checkNotNull(multiset));\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified multiset. Query operations on the returned\n * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n * result in an {@link UnsupportedOperationException}.\n *\n * <p>The returned multiset will be serializable if the specified multiset is serializable.\n *\n * @param multiset the multiset for which an unmodifiable view is to be generated\n * @return an unmodifiable view of the multiset\n */\n", "repo_name": "guava-master/", "id": 6188, "method_signature": "Multiset<E> unmodifiableMultiset(Multiset)", "filename": "Multisets.unmodifiableMultiset.json"}
{"callee_method_names": [], "method_name": "Multisets.unmodifiableSortedMultiset", "method_implementation": "{\n    // it's in its own file so it can be emulated for GWT\n    return new UnmodifiableSortedMultiset<E>(checkNotNull(sortedMultiset));\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned\n * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n * result in an {@link UnsupportedOperationException}.\n *\n * <p>The returned multiset will be serializable if the specified multiset is serializable.\n *\n * @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated\n * @return an unmodifiable view of the multiset\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 6189, "method_signature": "SortedMultiset<E> unmodifiableSortedMultiset(SortedMultiset)", "filename": "Multisets.unmodifiableSortedMultiset.json"}
{"callee_method_names": ["ByteBuffer.putLong", "ByteBuffer.array"], "method_name": "Murmur3Hash128Test.toHashCode", "method_implementation": "{\n    ByteBuffer bb = ByteBuffer.wrap(new byte[longs.length * 8]).order(ByteOrder.LITTLE_ENDIAN);\n    for (long x : longs) {\n        bb.putLong(x);\n    }\n    return HashCode.fromBytes(bb.array());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link HashCode} for a sequence of longs, in big-endian order.\n */\n", "repo_name": "guava-master/", "id": 3726, "method_signature": "HashCode toHashCode(long[])", "filename": "Murmur3Hash128Test.toHashCode.json"}
{"callee_method_names": [], "method_name": "Murmur3_32HashFunction.fmix", "method_implementation": "{\n    h1 ^= length;\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n    return HashCode.fromInt(h1);\n}", "repo_id": "5", "comment": "// Finalization mix - force all bits of a hash block to avalanche\n", "repo_name": "guava-master/", "id": 5235, "method_signature": "HashCode fmix(int, int)", "filename": "Murmur3_32HashFunction.fmix.json"}
{"callee_method_names": [], "method_name": "MutableClassToInstanceMap.checkedEntry", "method_implementation": "{\n    return new ForwardingMapEntry<Class<? extends @NonNull B>, B>() {\n\n        @Override\n        protected Entry<Class<? extends @NonNull B>, B> delegate() {\n            return entry;\n        }\n\n        @Override\n        @ParametricNullness\n        public B setValue(@ParametricNullness B value) {\n            cast(getKey(), value);\n            return super.setValue(value);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Wraps the {@code setValue} implementation of an {@code Entry} to enforce the class constraint.\n */\n", "repo_name": "guava-master/", "id": 6489, "method_signature": "Entry<Class<? extends B>,B> checkedEntry(Entry)", "filename": "MutableClassToInstanceMap.checkedEntry.json"}
{"callee_method_names": ["MutableClassToInstanceMap<Impl>.putInstance", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue"], "method_name": "MutableClassToInstanceMapTest.create", "method_implementation": "{\n    MutableClassToInstanceMap<Impl> map = MutableClassToInstanceMap.create();\n    for (Object object : elements) {\n        Entry<Class, Impl> entry = (Entry<Class, Impl>) object;\n        map.putInstance(entry.getKey(), entry.getValue());\n    }\n    return (Map) map;\n}", "repo_id": "5", "comment": "// but here we have to do some serious fudging\n", "repo_name": "guava-master/", "id": 3979, "method_signature": "Map<Class,Impl> create(Object[])", "filename": "MutableClassToInstanceMapTest.create.json"}
{"callee_method_names": [], "method_name": "MutableTypeToInstanceMap.put", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Please use putInstance() instead.\");\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #putInstance} instead.\n *\n * @deprecated unsupported operation\n * @throws UnsupportedOperationException always\n */\n", "repo_name": "guava-master/", "id": 4724, "method_signature": "B put(TypeToken, B)", "filename": "MutableTypeToInstanceMap.put.json"}
{"callee_method_names": [], "method_name": "MutableTypeToInstanceMap.putAll", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Please use putInstance() instead.\");\n}", "repo_id": "5", "comment": "/**\n * Not supported. Use {@link #putInstance} instead.\n *\n * @deprecated unsupported operation\n * @throws UnsupportedOperationException always\n */\n", "repo_name": "guava-master/", "id": 4725, "method_signature": "void putAll(Map)", "filename": "MutableTypeToInstanceMap.putAll.json"}
{"callee_method_names": ["MutableTypeToInstanceMap<Object>.putInstance", "Entry<TypeToken, Object>.getKey", "Entry<TypeToken, Object>.getValue"], "method_name": "MutableTypeToInstanceMapTest.create", "method_implementation": "{\n    MutableTypeToInstanceMap<Object> map = new MutableTypeToInstanceMap<>();\n    for (Object object : elements) {\n        Entry<TypeToken, Object> entry = (Entry<TypeToken, Object>) object;\n        map.putInstance(entry.getKey(), entry.getValue());\n    }\n    return (Map) map;\n}", "repo_id": "5", "comment": "// but here we have to do some serious fudging\n", "repo_name": "guava-master/", "id": 3617, "method_signature": "Map<TypeToken,Object> create(Object[])", "filename": "MutableTypeToInstanceMapTest.create.json"}
{"callee_method_names": [], "method_name": "NavigableMapNavigationTester.resetWithHole", "method_implementation": "{\n    Entry<K, V>[] entries = new Entry[] { a, c };\n    super.resetMap(entries);\n    navigableMap = (NavigableMap<K, V>) getMap();\n}", "repo_id": "5", "comment": "/**\n * Resets the contents of navigableMap to have entries a, c, for the navigation tests.\n */\n", "repo_name": "guava-master/", "id": 4189, "method_signature": "void resetWithHole()", "filename": "NavigableMapNavigationTester.resetWithHole.json"}
{"callee_method_names": ["FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getSubjectGenerator", "List<Feature<?>>.add", "List<Feature<?>>.addAll", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getFeatures", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getName", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getSuppressedTests"], "method_name": "NavigableMapTestSuiteBuilder.createDescendingSuite", "method_implementation": "{\n    TestSortedMapGenerator<K, V> delegate = (TestSortedMapGenerator<K, V>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n    List<Feature<?>> features = new ArrayList<>();\n    features.add(NoRecurse.DESCENDING);\n    features.addAll(parentBuilder.getFeatures());\n    return subSuiteUsing(new DescendingTestMapGenerator<K, V>(delegate)).named(parentBuilder.getName() + \" descending\").withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Create a suite whose maps are descending views of other maps.\n */\n", "repo_name": "guava-master/", "id": 4155, "method_signature": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder)", "filename": "NavigableMapTestSuiteBuilder.createDescendingSuite.json"}
{"callee_method_names": [], "method_name": "NavigableSetNavigationTester.getHoleMethods", "method_implementation": "{\n    return new Method[] { Helpers.getMethod(NavigableSetNavigationTester.class, \"testLowerHole\"), Helpers.getMethod(NavigableSetNavigationTester.class, \"testFloorHole\"), Helpers.getMethod(NavigableSetNavigationTester.class, \"testCeilingHole\"), Helpers.getMethod(NavigableSetNavigationTester.class, \"testHigherHole\") };\n}", "repo_id": "5", "comment": "/*\n   * TODO(cpovirk): or we could make HOLES_FORBIDDEN a feature. Or we could declare that\n   * implementations are permitted to throw IAE if a hole is requested, and we could update\n   * test*Hole to permit IAE. (But might this ignore genuine bugs?) But see the TODO above\n   * testLower, which could make this all unnecessary\n   */\n", "repo_name": "guava-master/", "id": 4192, "method_signature": "Method[] getHoleMethods()", "filename": "NavigableSetNavigationTester.getHoleMethods.json"}
{"callee_method_names": ["NavigableSet<E>.lower", "NavigableSet<E>.lower", "NavigableSet<E>.lower"], "method_name": "NavigableSetNavigationTester.testLower", "method_implementation": "{\n    assertEquals(null, navigableSet.lower(a));\n    assertEquals(a, navigableSet.lower(b));\n    assertEquals(b, navigableSet.lower(c));\n}", "repo_id": "5", "comment": "/*\n   * TODO(cpovirk): make \"too small\" and \"too large\" elements available for better navigation\n   * testing. At that point, we may be able to eliminate the \"hole\" tests, which would mean that\n   * ContiguousSet's tests would no longer need to suppress them.\n   */\n", "repo_name": "guava-master/", "id": 4191, "method_signature": "void testLower()", "filename": "NavigableSetNavigationTester.testLower.json"}
{"callee_method_names": ["FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getSubjectGenerator", "List<Feature<?>>.add", "List<Feature<?>>.addAll", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getFeatures", "TestSetGenerator<E>.samples", "TestSetGenerator<E>.createArray", "TestSetGenerator<E>.order", "List<E>.add", "TestSetGenerator<E>.create", "NavigableSet<E>.descendingSet", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getName", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getSuppressedTests"], "method_name": "NavigableSetTestSuiteBuilder.createDescendingSuite", "method_implementation": "{\n    TestSetGenerator<E> delegate = (TestSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n    List<Feature<?>> features = new ArrayList<>();\n    features.add(DESCENDING_VIEW);\n    features.addAll(parentBuilder.getFeatures());\n    return NavigableSetTestSuiteBuilder.using(new TestSetGenerator<E>() {\n\n        @Override\n        public SampleElements<E> samples() {\n            return delegate.samples();\n        }\n\n        @Override\n        public E[] createArray(int length) {\n            return delegate.createArray(length);\n        }\n\n        @Override\n        public Iterable<E> order(List<E> insertionOrder) {\n            List<E> list = new ArrayList<>();\n            for (E e : delegate.order(insertionOrder)) {\n                list.add(e);\n            }\n            Collections.reverse(list);\n            return list;\n        }\n\n        @Override\n        public Set<E> create(Object... elements) {\n            NavigableSet<E> navigableSet = (NavigableSet<E>) delegate.create(elements);\n            return navigableSet.descendingSet();\n        }\n    }).named(parentBuilder.getName() + \" descending\").withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Create a suite whose maps are descending views of other maps.\n */\n", "repo_name": "guava-master/", "id": 4206, "method_signature": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder)", "filename": "NavigableSetTestSuiteBuilder.createDescendingSuite.json"}
{"callee_method_names": [], "method_name": "NetworkBuilder.allowsParallelEdges", "method_implementation": "{\n    this.allowsParallelEdges = allowsParallelEdges;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies whether the network will allow parallel edges. Attempting to add a parallel edge to a\n * network that does not allow them will throw an {@link UnsupportedOperationException}.\n *\n * <p>The default value is {@code false}.\n */\n", "repo_name": "guava-master/", "id": 6730, "method_signature": "NetworkBuilder<N,E> allowsParallelEdges(boolean)", "filename": "NetworkBuilder.allowsParallelEdges.json"}
{"callee_method_names": [], "method_name": "NetworkBuilder.allowsSelfLoops", "method_implementation": "{\n    this.allowsSelfLoops = allowsSelfLoops;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies whether the network will allow self-loops (edges that connect a node to itself).\n * Attempting to add a self-loop to a network that does not allow them will throw an {@link\n * UnsupportedOperationException}.\n *\n * <p>The default value is {@code false}.\n */\n", "repo_name": "guava-master/", "id": 6731, "method_signature": "NetworkBuilder<N,E> allowsSelfLoops(boolean)", "filename": "NetworkBuilder.allowsSelfLoops.json"}
{"callee_method_names": [], "method_name": "NetworkBuilder.edgeOrder", "method_implementation": "{\n    NetworkBuilder<N, E1> newBuilder = cast();\n    newBuilder.edgeOrder = checkNotNull(edgeOrder);\n    return newBuilder;\n}", "repo_id": "5", "comment": "/**\n * Specifies the order of iteration for the elements of {@link Network#edges()}.\n *\n * <p>The default value is {@link ElementOrder#insertion() insertion order}.\n */\n", "repo_name": "guava-master/", "id": 6735, "method_signature": "NetworkBuilder<N,E1> edgeOrder(ElementOrder)", "filename": "NetworkBuilder.edgeOrder.json"}
{"callee_method_names": [], "method_name": "NetworkBuilder.expectedEdgeCount", "method_implementation": "{\n    this.expectedEdgeCount = Optional.of(checkNonNegative(expectedEdgeCount));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the expected number of edges in the network.\n *\n * @throws IllegalArgumentException if {@code expectedEdgeCount} is negative\n */\n", "repo_name": "guava-master/", "id": 6733, "method_signature": "NetworkBuilder<N,E> expectedEdgeCount(int)", "filename": "NetworkBuilder.expectedEdgeCount.json"}
{"callee_method_names": [], "method_name": "NetworkBuilder.expectedNodeCount", "method_implementation": "{\n    this.expectedNodeCount = Optional.of(checkNonNegative(expectedNodeCount));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the expected number of nodes in the network.\n *\n * @throws IllegalArgumentException if {@code expectedNodeCount} is negative\n */\n", "repo_name": "guava-master/", "id": 6732, "method_signature": "NetworkBuilder<N,E> expectedNodeCount(int)", "filename": "NetworkBuilder.expectedNodeCount.json"}
{"callee_method_names": ["Network<N,E>.isDirected", "Network<N,E>.allowsParallelEdges", "Network<N,E>.allowsSelfLoops", "Network<N,E>.nodeOrder", "Network<N,E>.edgeOrder"], "method_name": "NetworkBuilder.from", "method_implementation": "{\n    return new NetworkBuilder<N, E>(network.isDirected()).allowsParallelEdges(network.allowsParallelEdges()).allowsSelfLoops(network.allowsSelfLoops()).nodeOrder(network.nodeOrder()).edgeOrder(network.edgeOrder());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link NetworkBuilder} initialized with all properties queryable from {@code\n * network}.\n *\n * <p>The \"queryable\" properties are those that are exposed through the {@link Network} interface,\n * such as {@link Network#isDirected()}. Other properties, such as {@link\n * #expectedNodeCount(int)}, are not set in the new builder.\n */\n", "repo_name": "guava-master/", "id": 6729, "method_signature": "NetworkBuilder<N,E> from(Network)", "filename": "NetworkBuilder.from.json"}
{"callee_method_names": [], "method_name": "NetworkBuilder.nodeOrder", "method_implementation": "{\n    NetworkBuilder<N1, E> newBuilder = cast();\n    newBuilder.nodeOrder = checkNotNull(nodeOrder);\n    return newBuilder;\n}", "repo_id": "5", "comment": "/**\n * Specifies the order of iteration for the elements of {@link Network#nodes()}.\n *\n * <p>The default value is {@link ElementOrder#insertion() insertion order}.\n */\n", "repo_name": "guava-master/", "id": 6734, "method_signature": "NetworkBuilder<N1,E> nodeOrder(ElementOrder)", "filename": "NetworkBuilder.nodeOrder.json"}
{"callee_method_names": ["MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge"], "method_name": "NetworkEquivalenceTest.equivalent_connectionsDiffer", "method_implementation": "{\n    network.addEdge(N1, N2, E12);\n    network.addEdge(N1, N3, E13);\n    MutableNetwork<Integer, String> g2 = createNetwork(edgeType);\n    // connect E13 to N1 and N2, and E12 to N1 and N3 => not equivalent\n    g2.addEdge(N1, N2, E13);\n    g2.addEdge(N1, N3, E12);\n    assertThat(network).isNotEqualTo(g2);\n}", "repo_id": "5", "comment": "// Node/edge sets are the same, but node/edge connections differ.\n", "repo_name": "guava-master/", "id": 4059, "method_signature": "void equivalent_connectionsDiffer()", "filename": "NetworkEquivalenceTest.equivalent_connectionsDiffer.json"}
{"callee_method_names": ["MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge"], "method_name": "NetworkEquivalenceTest.equivalent_directedVsUndirected", "method_implementation": "{\n    network.addEdge(N1, N2, E12);\n    MutableNetwork<Integer, String> g2 = createNetwork(oppositeType(edgeType));\n    g2.addEdge(N1, N2, E12);\n    assertThat(network).isNotEqualTo(g2);\n}", "repo_id": "5", "comment": "// Node/edge sets are the same, but node/edge connections differ due to edge type.\n", "repo_name": "guava-master/", "id": 4057, "method_signature": "void equivalent_directedVsUndirected()", "filename": "NetworkEquivalenceTest.equivalent_directedVsUndirected.json"}
{"callee_method_names": ["NetworkBuilder<Integer, String>.build", "NetworkBuilder<Integer, String>.build", "MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge"], "method_name": "NetworkEquivalenceTest.equivalent_edgeAddOrdersDiffer", "method_implementation": "{\n    NetworkBuilder<Integer, String> builder = NetworkBuilder.from(network).allowsParallelEdges(true);\n    MutableNetwork<Integer, String> g1 = builder.build();\n    MutableNetwork<Integer, String> g2 = builder.build();\n    // for ug1, add e12 first, then e12_a\n    g1.addEdge(N1, N2, E12);\n    g1.addEdge(N1, N2, E12_A);\n    // for ug2, add e12_a first, then e12\n    g2.addEdge(N1, N2, E12_A);\n    g2.addEdge(N1, N2, E12);\n    assertThat(g1).isEqualTo(g2);\n}", "repo_id": "5", "comment": "// (In this case the networks are considered equivalent; the edge add orderings are irrelevant.)\n", "repo_name": "guava-master/", "id": 4061, "method_signature": "void equivalent_edgeAddOrdersDiffer()", "filename": "NetworkEquivalenceTest.equivalent_edgeAddOrdersDiffer.json"}
{"callee_method_names": ["MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge"], "method_name": "NetworkEquivalenceTest.equivalent_edgeSetsDiffer", "method_implementation": "{\n    network.addEdge(N1, N2, E12);\n    MutableNetwork<Integer, String> g2 = createNetwork(edgeType);\n    g2.addEdge(N1, N2, E13);\n    assertThat(network).isNotEqualTo(g2);\n}", "repo_id": "5", "comment": "// Node sets are the same, but edge sets differ.\n", "repo_name": "guava-master/", "id": 4056, "method_signature": "void equivalent_edgeSetsDiffer()", "filename": "NetworkEquivalenceTest.equivalent_edgeSetsDiffer.json"}
{"callee_method_names": ["MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.allowsParallelEdges", "MutableNetwork<Integer, String>.allowsSelfLoops", "MutableNetwork<Integer, String>.addEdge"], "method_name": "NetworkEquivalenceTest.equivalent_propertiesDiffer", "method_implementation": "{\n    network.addEdge(N1, N2, E12);\n    MutableNetwork<Integer, String> g2 = NetworkBuilder.from(network).allowsParallelEdges(!network.allowsParallelEdges()).allowsSelfLoops(!network.allowsSelfLoops()).build();\n    g2.addEdge(N1, N2, E12);\n    assertThat(network).isEqualTo(g2);\n}", "repo_id": "5", "comment": "// (In this case the networks are considered equivalent; the property differences are irrelevant.)\n", "repo_name": "guava-master/", "id": 4060, "method_signature": "void equivalent_propertiesDiffer()", "filename": "NetworkEquivalenceTest.equivalent_propertiesDiffer.json"}
{"callee_method_names": ["MutableNetwork<Integer, String>.addEdge", "MutableNetwork<Integer, String>.addEdge"], "method_name": "NetworkEquivalenceTest.equivalent_selfLoop_directedVsUndirected", "method_implementation": "{\n    network.addEdge(N1, N1, E11);\n    MutableNetwork<Integer, String> g2 = createNetwork(oppositeType(edgeType));\n    g2.addEdge(N1, N1, E11);\n    assertThat(network).isNotEqualTo(g2);\n}", "repo_id": "5", "comment": "// Node/edge sets and node/edge connections are the same, but directedness differs.\n", "repo_name": "guava-master/", "id": 4058, "method_signature": "void equivalent_selfLoop_directedVsUndirected()", "filename": "NetworkEquivalenceTest.equivalent_selfLoop_directedVsUndirected.json"}
{"callee_method_names": ["List<Member>.add"], "method_name": "NullPointerTester.ignore", "method_implementation": "{\n    ignoredMembers.add(checkNotNull(constructor));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Ignore {@code constructor} in the tests that follow. Returns this object.\n *\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 4122, "method_signature": "NullPointerTester ignore(Constructor)", "filename": "NullPointerTester.ignore.json"}
{"callee_method_names": ["Method.getName", "Method.getParameterTypes", "Class<?>[].equals"], "method_name": "NullPointerTester.isEquals", "method_implementation": "{\n    if (!(member instanceof Method)) {\n        return false;\n    }\n    Method method = (Method) member;\n    if (!method.getName().contentEquals(\"equals\")) {\n        return false;\n    }\n    Class<?>[] parameters = method.getParameterTypes();\n    if (parameters.length != 1) {\n        return false;\n    }\n    if (!parameters[0].equals(Object.class)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns true if the given member is a method that overrides {@link Object#equals(Object)}.\n *\n * <p>The documentation for {@link Object#equals} says it should accept null, so don't require an\n * explicit {@code @NullableDecl} annotation (see <a\n * href=\"https://github.com/google/guava/issues/1819\">#1819</a>).\n *\n * <p>It is not necessary to consider visibility, return type, or type parameter declarations. The\n * declaration of a method with the same name and formal parameters as {@link Object#equals} that\n * is not public and boolean-returning, or that declares any type parameters, would be rejected at\n * compile-time.\n */\n", "repo_name": "guava-master/", "id": 4129, "method_signature": "boolean isEquals(Member)", "filename": "NullPointerTester.isEquals.json"}
{"callee_method_names": ["ClassToInstanceMap<Object>.putInstance"], "method_name": "NullPointerTester.setDefault", "method_implementation": "{\n    defaults.putInstance(type, checkNotNull(value));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets a default value that can be used for any parameter of type {@code type}. Returns this\n * object.\n */\n", "repo_name": "guava-master/", "id": 4120, "method_signature": "NullPointerTester setDefault(Class, T)", "filename": "NullPointerTester.setDefault.json"}
{"callee_method_names": ["Constructor<?>.getDeclaringClass", "Class<?>.getModifiers", "Class<?>.getEnclosingClass", "Class<?>.getName", "Constructor<?>.getParameterTypes"], "method_name": "NullPointerTester.testConstructor", "method_implementation": "{\n    Class<?> declaringClass = ctor.getDeclaringClass();\n    checkArgument(Modifier.isStatic(declaringClass.getModifiers()) || declaringClass.getEnclosingClass() == null, \"Cannot test constructor of non-static inner class: %s\", declaringClass.getName());\n    Class<?>[] types = ctor.getParameterTypes();\n    for (int nullIndex = 0; nullIndex < types.length; nullIndex++) {\n        testConstructorParameter(ctor, nullIndex);\n    }\n}", "repo_id": "5", "comment": "/**\n * Verifies that {@code ctor} produces a {@link NullPointerException} or {@link\n * UnsupportedOperationException} whenever <i>any</i> of its non-nullable parameters are null.\n */\n", "repo_name": "guava-master/", "id": 4127, "method_signature": "void testConstructor(Constructor)", "filename": "NullPointerTester.testConstructor.json"}
{"callee_method_names": ["Class<?>.getDeclaredConstructors", "Visibility.isVisible"], "method_name": "NullPointerTester.testConstructors", "method_implementation": "{\n    for (Constructor<?> constructor : c.getDeclaredConstructors()) {\n        if (minimalVisibility.isVisible(constructor) && !isIgnored(constructor)) {\n            testConstructor(constructor);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Runs {@link #testConstructor} on every constructor in class {@code c} that has at least {@code\n * minimalVisibility}.\n */\n", "repo_name": "guava-master/", "id": 4123, "method_signature": "void testConstructors(Class, Visibility)", "filename": "NullPointerTester.testConstructors.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "NullPointerTester.testInstanceMethods", "method_implementation": "{\n    for (Method method : getInstanceMethodsToTest(instance.getClass(), minimalVisibility)) {\n        testMethod(instance, method);\n    }\n}", "repo_id": "5", "comment": "/**\n * Runs {@link #testMethod} on every instance method of the class of {@code instance} with at\n * least {@code minimalVisibility}, including those inherited from superclasses of the same\n * package.\n */\n", "repo_name": "guava-master/", "id": 4125, "method_signature": "void testInstanceMethods(Object, Visibility)", "filename": "NullPointerTester.testInstanceMethods.json"}
{"callee_method_names": ["Method.getParameterTypes"], "method_name": "NullPointerTester.testMethod", "method_implementation": "{\n    Class<?>[] types = method.getParameterTypes();\n    for (int nullIndex = 0; nullIndex < types.length; nullIndex++) {\n        testMethodParameter(instance, method, nullIndex);\n    }\n}", "repo_id": "5", "comment": "/**\n * Verifies that {@code method} produces a {@link NullPointerException} or {@link\n * UnsupportedOperationException} whenever <i>any</i> of its non-nullable parameters are null.\n *\n * @param instance the instance to invoke {@code method} on, or null if {@code method} is static\n */\n", "repo_name": "guava-master/", "id": 4126, "method_signature": "void testMethod(Object, Method)", "filename": "NullPointerTester.testMethod.json"}
{"callee_method_names": ["Method.setAccessible", "Method.getDeclaringClass"], "method_name": "NullPointerTester.testMethodParameter", "method_implementation": "{\n    method.setAccessible(true);\n    testParameter(instance, invokable(instance, method), paramIndex, method.getDeclaringClass());\n}", "repo_id": "5", "comment": "/**\n * Verifies that {@code method} produces a {@link NullPointerException} or {@link\n * UnsupportedOperationException} when the parameter in position {@code paramIndex} is null. If\n * this parameter is marked nullable, this method does nothing.\n *\n * @param instance the instance to invoke {@code method} on, or null if {@code method} is static\n */\n", "repo_name": "guava-master/", "id": 665, "method_signature": "void testMethodParameter(Object, Method, int)", "filename": "NullPointerTester.testMethodParameter.json"}
{"callee_method_names": ["Invokable<?,?>.getParameters", "Invokable<Object, ?>.invoke", "UnicodeEscaper.getCause", "ExceptionTypePolicy.isExpectedType", "Invokable<?,?>.getParameters", "AssertionFailedError.initCause"], "method_name": "NullPointerTester.testParameter", "method_implementation": "{\n    /*\n     * com.google.common is starting to rely on type-use annotations, which aren't visible under\n     * Android VMs and in open-source guava-android. So we skip testing there.\n     */\n    if (Reflection.getPackageName(testedClass).startsWith(\"com.google.common\")) {\n        return;\n    }\n    if (isPrimitiveOrNullable(invokable.getParameters().get(paramIndex))) {\n        // there's nothing to test\n        return;\n    }\n    @Nullable\n    Object[] params = buildParamList(invokable, paramIndex);\n    try {\n        // We'll get a runtime exception if the type is wrong.\n        @SuppressWarnings(\"unchecked\")\n        Invokable<Object, ?> unsafe = (Invokable<Object, ?>) invokable;\n        unsafe.invoke(instance, params);\n        Assert.fail(\"No exception thrown for parameter at index \" + paramIndex + \" from \" + invokable + Arrays.toString(params) + \" for \" + testedClass);\n    } catch (InvocationTargetException e) {\n        Throwable cause = e.getCause();\n        if (policy.isExpectedType(cause)) {\n            return;\n        }\n        AssertionFailedError error = new AssertionFailedError(String.format(\"wrong exception thrown from %s when passing null to %s parameter at index %s.%n\" + \"Full parameters: %s%n\" + \"Actual exception message: %s\", invokable, invokable.getParameters().get(paramIndex).getType(), paramIndex, Arrays.toString(params), cause));\n        error.initCause(cause);\n        throw error;\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Verifies that {@code invokable} produces a {@link NullPointerException} or {@link\n * UnsupportedOperationException} when the parameter in position {@code paramIndex} is null. If\n * this parameter is marked nullable, this method does nothing.\n *\n * @param instance the instance to invoke {@code invokable} on, or null if {@code invokable} is\n *     static\n */\n", "repo_name": "guava-master/", "id": 4128, "method_signature": "void testParameter(Object, Invokable, int, Class)", "filename": "NullPointerTester.testParameter.json"}
{"callee_method_names": ["Visibility.getStaticMethods"], "method_name": "NullPointerTester.testStaticMethods", "method_implementation": "{\n    for (Method method : minimalVisibility.getStaticMethods(c)) {\n        if (!isIgnored(method)) {\n            testMethod(null, method);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Runs {@link #testMethod} on every static method of class {@code c} that has at least {@code\n * minimalVisibility}, including those \"inherited\" from superclasses of the same package.\n */\n", "repo_name": "guava-master/", "id": 4124, "method_signature": "void testStaticMethods(Class, Visibility)", "filename": "NullPointerTester.testStaticMethods.json"}
{"callee_method_names": ["Action.act", "Action.act"], "method_name": "NullPointerTesterTest.reactToNullParameters", "method_implementation": "{\n    if (first == null) {\n        actionWhenFirstParamIsNull.act();\n    }\n    if (second == null) {\n        actionWhenSecondParamIsNull.act();\n    }\n}", "repo_id": "5", "comment": "/**\n * Method that decides how to react to parameters.\n */\n", "repo_name": "guava-master/", "id": 786, "method_signature": "void reactToNullParameters(Object, Object)", "filename": "NullPointerTesterTest.reactToNullParameters.json"}
{"callee_method_names": [], "method_name": "NullPointerTesterTest.toString", "method_implementation": "{\n    return rootLocaleFormat(\"Bar(%s, %s)\", actionWhenFirstParamIsNull, actionWhenSecondParamIsNull);\n}", "repo_id": "5", "comment": "/**\n * To provide sanity during debugging.\n */\n", "repo_name": "guava-master/", "id": 787, "method_signature": "String toString()", "filename": "NullPointerTesterTest.toString.json"}
{"callee_method_names": [], "method_name": "NullnessCasts.uncheckedCastNullableTToT", "method_implementation": "{\n    return t;\n}", "repo_id": "5", "comment": "/**\n * Accepts a {@code @Nullable T} and returns a plain {@code T}, without performing any check that\n * that conversion is safe.\n *\n * <p>This method is intended to help with usages of type parameters that have {@linkplain\n * ParametricNullness parametric nullness}. If a type parameter instead ranges over only non-null\n * types (or if the type is a non-variable type, like {@code String}), then code should almost\n * never use this method, preferring instead to call {@code requireNonNull} so as to benefit from\n * its runtime check.\n *\n * <p>An example use case for this method is in implementing an {@code Iterator<T>} whose {@code\n * next} field is lazily initialized. The type of that field would be {@code @Nullable T}, and the\n * code would be responsible for populating a \"real\" {@code T} (which might still be the value\n * {@code null}!) before returning it to callers. Depending on how the code is structured, a\n * nullness analysis might not understand that the field has been populated. To avoid that problem\n * without having to add {@code @SuppressWarnings}, the code can call this method.\n *\n * <p>Why <i>not</i> just add {@code SuppressWarnings}? The problem is that this method is\n * typically useful for {@code return} statements. That leaves the code with two options: Either\n * add the suppression to the whole method (which turns off checking for a large section of code),\n * or extract a variable, and put the suppression on that. However, a local variable typically\n * doesn't work: Because nullness analyses typically infer the nullness of local variables,\n * there's no way to assign a {@code @Nullable T} to a field {@code T foo;} and instruct the\n * analysis that that means \"plain {@code T}\" rather than the inferred type {@code @Nullable T}.\n * (Even if supported added {@code @NonNull}, that would not help, since the problem case\n * addressed by this method is the case in which {@code T} has parametric nullness -- and thus its\n * value may be legitimately {@code null}.)\n */\n", "repo_name": "guava-master/", "id": 6498, "method_signature": "T uncheckedCastNullableTToT(T)", "filename": "NullnessCasts.uncheckedCastNullableTToT.json"}
{"callee_method_names": [], "method_name": "NullnessCasts.uncheckedNull", "method_implementation": "{\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code null} cast to any type.\n *\n * <p>This method is intended to help with usages of type parameters that have {@linkplain\n * ParametricNullness parametric nullness}. Sometimes, code may receive a null {@code T} but store\n * a \"null sentinel\" to take its place. When the time comes to convert it back to a {@code T} to\n * return to a caller, the code needs to a way to return {@code null} from a method that returns\n * \"plain {@code T}.\" This API provides that.\n */\n", "repo_name": "guava-master/", "id": 5466, "method_signature": "T uncheckedNull()", "filename": "NullnessCasts.uncheckedNull.json"}
{"callee_method_names": [], "method_name": "NullnessCasts.unsafeNull", "method_implementation": "{\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code null} as any type, even one that does not include {@code null}.\n */\n", "repo_name": "guava-master/", "id": 6499, "method_signature": "T unsafeNull()", "filename": "NullnessCasts.unsafeNull.json"}
{"callee_method_names": [], "method_name": "ObjectArrays.checkElementNotNull", "method_implementation": "{\n    if (element == null) {\n        throw new NullPointerException(\"at index \" + index);\n    }\n    return element;\n}", "repo_id": "5", "comment": "// creation cost.\n", "repo_name": "guava-master/", "id": 6155, "method_signature": "Object checkElementNotNull(Object, int)", "filename": "ObjectArrays.checkElementNotNull.json"}
{"callee_method_names": [], "method_name": "ObjectArrays.concat", "method_implementation": "{\n    T[] result = Arrays.copyOf(array, array.length + 1);\n    result[array.length] = element;\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a new array that appends {@code element} to {@code array}.\n *\n * @param array the array of elements to prepend\n * @param element the element to append to the end\n * @return an array whose size is one larger than {@code array}, with the same contents as {@code\n *     array}, plus {@code element} occupying the last position.\n */\n", "repo_name": "guava-master/", "id": 6150, "method_signature": "T[] concat(T[], T)", "filename": "ObjectArrays.concat.json"}
{"callee_method_names": [], "method_name": "ObjectArrays.copyAsObjectArray", "method_implementation": "{\n    checkPositionIndexes(offset, offset + length, elements.length);\n    if (length == 0) {\n        return new Object[0];\n    }\n    @Nullable\n    Object[] result = new Object[length];\n    System.arraycopy(elements, offset, result, 0, length);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a copy of the specified subrange of the specified array that is literally an Object[],\n * and not e.g. a {@code String[]}.\n */\n", "repo_name": "guava-master/", "id": 6153, "method_signature": "Object[] copyAsObjectArray(Object[], int, int)", "filename": "ObjectArrays.copyAsObjectArray.json"}
{"callee_method_names": [], "method_name": "ObjectArrays.newArray", "method_implementation": "{\n    return (T[]) Array.newInstance(type, length);\n}", "repo_id": "5", "comment": "/**\n * Returns a new array of the given length with the specified component type.\n *\n * @param type the component type\n * @param length the length of the new array\n */\n", "repo_name": "guava-master/", "id": 6147, "method_signature": "T[] newArray(Class, int)", "filename": "ObjectArrays.newArray.json"}
{"callee_method_names": [], "method_name": "ObjectArrays.swap", "method_implementation": "{\n    Object temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}", "repo_id": "5", "comment": "/**\n * Swaps {@code array[i]} with {@code array[j]}.\n */\n", "repo_name": "guava-master/", "id": 6154, "method_signature": "void swap(Object[], int, int)", "filename": "ObjectArrays.swap.json"}
{"callee_method_names": [], "method_name": "ObjectArrays.toArrayImpl", "method_implementation": "{\n    checkPositionIndexes(offset, offset + len, src.length);\n    if (dst.length < len) {\n        dst = newArray(dst, len);\n    } else if (dst.length > len) {\n        @Nullable\n        Object[] unsoundlyCovariantArray = dst;\n        unsoundlyCovariantArray[len] = null;\n    }\n    System.arraycopy(src, offset, dst, 0, len);\n    return dst;\n}", "repo_id": "5", "comment": "/**\n * Implementation of {@link Collection#toArray(Object[])} for collections backed by an object\n * array. the runtime type of the returned array is that of the specified array. If the collection\n * fits in the specified array, it is returned therein. Otherwise, a new array is allocated with\n * the runtime type of the specified array and the size of the specified collection.\n *\n * <p>If the collection fits in the specified array with room to spare (i.e., the array has more\n * elements than the collection), the element in the array immediately following the end of the\n * collection is set to {@code null}. This is useful in determining the length of the collection\n * <i>only</i> if the caller knows that the collection does not contain any null elements.\n */\n", "repo_name": "guava-master/", "id": 6152, "method_signature": "T[] toArrayImpl(Object[], int, int, T[])", "filename": "ObjectArrays.toArrayImpl.json"}
{"callee_method_names": [], "method_name": "ObjectCountHashMap.insertEntry", "method_implementation": "{\n    this.entries[entryIndex] = ((long) hash << 32) | (NEXT_MASK & UNSET);\n    this.keys[entryIndex] = key;\n    this.values[entryIndex] = value;\n}", "repo_id": "5", "comment": "/**\n * Creates a fresh entry with the specified object at the specified position in the entry array.\n */\n", "repo_name": "guava-master/", "id": 6612, "method_signature": "void insertEntry(int, K, int, int)", "filename": "ObjectCountHashMap.insertEntry.json"}
{"callee_method_names": [], "method_name": "ObjectCountHashMap.moveLastEntry", "method_implementation": "{\n    int srcIndex = size() - 1;\n    if (dstIndex < srcIndex) {\n        // move last entry to deleted spot\n        keys[dstIndex] = keys[srcIndex];\n        values[dstIndex] = values[srcIndex];\n        keys[srcIndex] = null;\n        values[srcIndex] = 0;\n        // move the last entry to the removed spot, just like we moved the element\n        long lastEntry = entries[srcIndex];\n        entries[dstIndex] = lastEntry;\n        entries[srcIndex] = UNSET;\n        // also need to update whoever's \"next\" pointer was pointing to the last entry place\n        // reusing \"tableIndex\" and \"next\"; these variables were no longer needed\n        int tableIndex = getHash(lastEntry) & hashTableMask();\n        int lastNext = table[tableIndex];\n        if (lastNext == srcIndex) {\n            // we need to update the root pointer\n            table[tableIndex] = dstIndex;\n        } else {\n            // we need to update a pointer in an entry\n            int previous;\n            long entry;\n            do {\n                previous = lastNext;\n                lastNext = getNext(entry = entries[lastNext]);\n            } while (lastNext != srcIndex);\n            // here, entries[previous] points to the old entry location; update it\n            entries[previous] = swapNext(entry, dstIndex);\n        }\n    } else {\n        keys[dstIndex] = null;\n        values[dstIndex] = 0;\n        entries[dstIndex] = UNSET;\n    }\n}", "repo_id": "5", "comment": "/**\n * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.\n */\n", "repo_name": "guava-master/", "id": 6615, "method_signature": "void moveLastEntry(int)", "filename": "ObjectCountHashMap.moveLastEntry.json"}
{"callee_method_names": [], "method_name": "ObjectCountHashMap.resizeEntries", "method_implementation": "{\n    this.keys = Arrays.copyOf(keys, newCapacity);\n    this.values = Arrays.copyOf(values, newCapacity);\n    long[] entries = this.entries;\n    int oldCapacity = entries.length;\n    entries = Arrays.copyOf(entries, newCapacity);\n    if (newCapacity > oldCapacity) {\n        Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\n    }\n    this.entries = entries;\n}", "repo_id": "5", "comment": "/**\n * Resizes the internal entries array to the specified capacity, which may be greater or less than\n * the current capacity.\n */\n", "repo_name": "guava-master/", "id": 6614, "method_signature": "void resizeEntries(int)", "filename": "ObjectCountHashMap.resizeEntries.json"}
{"callee_method_names": [], "method_name": "ObjectCountHashMap.resizeMeMaybe", "method_implementation": "{\n    int entriesSize = entries.length;\n    if (newSize > entriesSize) {\n        int newCapacity = entriesSize + Math.max(1, entriesSize >>> 1);\n        if (newCapacity < 0) {\n            newCapacity = Integer.MAX_VALUE;\n        }\n        if (newCapacity != entriesSize) {\n            resizeEntries(newCapacity);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns currentSize + 1, after resizing the entries storage if necessary.\n */\n", "repo_name": "guava-master/", "id": 6613, "method_signature": "void resizeMeMaybe(int)", "filename": "ObjectCountHashMap.resizeMeMaybe.json"}
{"callee_method_names": [], "method_name": "OldAbstractFuture.complete", "method_implementation": "{\n    boolean doCompletion = compareAndSetState(RUNNING, COMPLETING);\n    if (doCompletion) {\n        // If this thread successfully transitioned to COMPLETING, set the value\n        // and exception and then release to the final state.\n        this.value = v;\n        // Don't actually construct a CancellationException until necessary.\n        this.exception = ((finalState & (CANCELLED | INTERRUPTED)) != 0) ? new CancellationException(\"Future.cancel() was called.\") : t;\n        releaseShared(finalState);\n    } else if (getState() == COMPLETING) {\n        // If some other thread is currently completing the future, block until\n        // they are done so we can guarantee completion.\n        acquireShared(-1);\n    }\n    return doCompletion;\n}", "repo_id": "5", "comment": "/**\n * Implementation of completing a task. Either {@code v} or {@code t} will be set but not\n * both. The {@code finalState} is the state to change to from {@link #RUNNING}. If the state\n * is not in the RUNNING state we return {@code false} after waiting for the state to be set\n * to a valid final state ({@link #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}).\n *\n * @param v the value to set as the result of the computation.\n * @param t the exception to set as the result of the computation.\n * @param finalState the state to transition to.\n */\n", "repo_name": "guava-master/", "id": 3912, "method_signature": "boolean complete(V, Throwable, int)", "filename": "OldAbstractFuture.complete.json"}
{"callee_method_names": [], "method_name": "OldAbstractFuture.get", "method_implementation": "{\n    // Acquire the shared lock allowing interruption.\n    acquireSharedInterruptibly(-1);\n    return getValue();\n}", "repo_id": "5", "comment": "/**\n * Blocks until {@link #complete(Object, Throwable, int)} has been successfully called. Throws\n * a {@link CancellationException} if the task was cancelled, or a {@link ExecutionException}\n * if the task completed with an error.\n */\n", "repo_name": "guava-master/", "id": 3910, "method_signature": "V get()", "filename": "OldAbstractFuture.get.json"}
{"callee_method_names": [], "method_name": "OldAbstractFuture.getValue", "method_implementation": "{\n    int state = getState();\n    switch(state) {\n        case COMPLETED:\n            if (exception != null) {\n                throw new ExecutionException(exception);\n            } else {\n                return value;\n            }\n        case CANCELLED:\n        case INTERRUPTED:\n            throw cancellationExceptionWithCause(\"Task was cancelled.\", exception);\n        default:\n            throw new IllegalStateException(\"Error, synchronizer in invalid state: \" + state);\n    }\n}", "repo_id": "5", "comment": "/**\n * Implementation of the actual value retrieval. Will return the value on success, an\n * exception on failure, a cancellation on cancellation, or an illegal state if the\n * synchronizer is in an invalid state.\n */\n", "repo_name": "guava-master/", "id": 3911, "method_signature": "V getValue()", "filename": "OldAbstractFuture.getValue.json"}
{"callee_method_ids": [5456], "callee_method_names": ["Sync.set", "ExecutionList.execute"], "method_name": "OldAbstractFuture.set", "method_implementation": "{\n    boolean result = sync.set(value);\n    if (result) {\n        executionList.execute();\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Subclasses should invoke this method to set the result of the computation to {@code value}.\n * This will set the state of the future to {@link OldAbstractFuture.Sync#COMPLETED} and invoke\n * the listeners if the state was successfully changed.\n *\n * @param value the value that was the result of the task.\n * @return true if the state was successfully changed.\n */\n", "repo_name": "guava-master/", "id": 3905, "method_signature": "boolean set(V)", "filename": "OldAbstractFuture.set.json"}
{"callee_method_ids": [5456], "callee_method_names": ["Sync.setException", "ExecutionList.execute"], "method_name": "OldAbstractFuture.setException", "method_implementation": "{\n    boolean result = sync.setException(checkNotNull(throwable));\n    if (result) {\n        executionList.execute();\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Subclasses should invoke this method to set the result of the computation to an error, {@code\n * throwable}. This will set the state of the future to {@link OldAbstractFuture.Sync#COMPLETED}\n * and invoke the listeners if the state was successfully changed.\n *\n * @param throwable the exception that the task failed with.\n * @return true if the state was successfully changed.\n */\n", "repo_name": "guava-master/", "id": 3906, "method_signature": "boolean setException(Throwable)", "filename": "OldAbstractFuture.setException.json"}
{"callee_method_names": [], "method_name": "OldAbstractFuture.tryAcquireShared", "method_implementation": "{\n    if (isDone()) {\n        return 1;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/*\n       * Acquisition succeeds if the future is done, otherwise it fails.\n       */\n", "repo_name": "guava-master/", "id": 3907, "method_signature": "int tryAcquireShared(int)", "filename": "OldAbstractFuture.tryAcquireShared.json"}
{"callee_method_names": [], "method_name": "OldAbstractFuture.tryReleaseShared", "method_implementation": "{\n    setState(finalState);\n    return true;\n}", "repo_id": "5", "comment": "/*\n       * We always allow a release to go through, this means the state has been\n       * successfully changed and the result is available.\n       */\n", "repo_name": "guava-master/", "id": 3908, "method_signature": "boolean tryReleaseShared(int)", "filename": "OldAbstractFuture.tryReleaseShared.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.putIfAbsent", "ConcurrentMap<E, Integer>.replace"], "method_name": "OldConcurrentHashMultiset.add", "method_implementation": "{\n    if (occurrences == 0) {\n        return count(element);\n    }\n    checkArgument(occurrences > 0, \"Invalid occurrences: %s\", occurrences);\n    while (true) {\n        int current = count(element);\n        if (current == 0) {\n            if (countMap.putIfAbsent(element, occurrences) == null) {\n                return 0;\n            }\n        } else {\n            checkArgument(occurrences <= Integer.MAX_VALUE - current, \"Overflow adding %s occurrences to a count of %s\", occurrences, current);\n            int next = current + occurrences;\n            if (countMap.replace(element, current, next)) {\n                return current;\n            }\n        }\n        // If we're still here, there was a race, so just try again.\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds a number of occurrences of the specified element to this multiset.\n *\n * @param element the element to add\n * @param occurrences the number of occurrences to add\n * @return the previous count of the element before the operation; possibly zero\n * @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting\n *     amount would exceed {@link Integer#MAX_VALUE}\n */\n", "repo_name": "guava-master/", "id": 3536, "method_signature": "int add(E, int)", "filename": "OldConcurrentHashMultiset.add.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.get"], "method_name": "OldConcurrentHashMultiset.count", "method_implementation": "{\n    try {\n        return unbox(countMap.get(element));\n    } catch (NullPointerException | ClassCastException e) {\n        return 0;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the number of occurrences of {@code element} in this multiset.\n *\n * @param element the element to look for\n * @return the nonnegative number of occurrences of the element\n */\n", "repo_name": "guava-master/", "id": 3533, "method_signature": "int count(Object)", "filename": "OldConcurrentHashMultiset.count.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.remove", "ConcurrentMap<E, Integer>.replace"], "method_name": "OldConcurrentHashMultiset.remove", "method_implementation": "{\n    if (occurrences == 0) {\n        return count(element);\n    }\n    checkArgument(occurrences > 0, \"Invalid occurrences: %s\", occurrences);\n    while (true) {\n        int current = count(element);\n        if (current == 0) {\n            return 0;\n        }\n        if (occurrences >= current) {\n            if (countMap.remove(element, current)) {\n                return current;\n            }\n        } else {\n            // We know it's an \"E\" because it already exists in the map.\n            @SuppressWarnings(\"unchecked\")\n            E casted = (E) element;\n            if (countMap.replace(casted, current, current - occurrences)) {\n                return current;\n            }\n        }\n        // If we're still here, there was a race, so just try again.\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes a number of occurrences of the specified element from this multiset. If the multiset\n * contains fewer than this number of occurrences to begin with, all occurrences will be\n * removed.\n *\n * @param element the element whose occurrences should be removed\n * @param occurrences the number of occurrences of the element to remove\n * @return the count of the element before the operation; possibly zero\n * @throws IllegalArgumentException if {@code occurrences} is negative\n */\n", "repo_name": "guava-master/", "id": 3537, "method_signature": "int remove(Object, int)", "filename": "OldConcurrentHashMultiset.remove.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.remove"], "method_name": "OldConcurrentHashMultiset.removeAllOccurrences", "method_implementation": "{\n    try {\n        return unbox(countMap.remove(element));\n    } catch (NullPointerException | ClassCastException e) {\n        return 0;\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes <b>all</b> occurrences of the specified element from this multiset. This method\n * complements {@link Multiset#remove(Object)}, which removes only one occurrence at a time.\n *\n * @param element the element whose occurrences should all be removed\n * @return the number of occurrences successfully removed, possibly zero\n */\n", "repo_name": "guava-master/", "id": 3538, "method_signature": "int removeAllOccurrences(Object)", "filename": "OldConcurrentHashMultiset.removeAllOccurrences.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.remove", "ConcurrentMap<E, Integer>.replace"], "method_name": "OldConcurrentHashMultiset.removeExactly", "method_implementation": "{\n    if (occurrences == 0) {\n        return true;\n    }\n    checkArgument(occurrences > 0, \"Invalid occurrences: %s\", occurrences);\n    while (true) {\n        int current = count(element);\n        if (occurrences > current) {\n            return false;\n        }\n        if (occurrences == current) {\n            if (countMap.remove(element, occurrences)) {\n                return true;\n            }\n        } else {\n            // it's in the map, must be an \"E\"\n            @SuppressWarnings(\"unchecked\")\n            E casted = (E) element;\n            if (countMap.replace(casted, current, current - occurrences)) {\n                return true;\n            }\n        }\n        // If we're still here, there was a race, so just try again.\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes exactly the specified number of occurrences of {@code element}, or makes no change if\n * this is not possible.\n *\n * <p>This method, in contrast to {@link #remove(Object, int)}, has no effect when the element\n * count is smaller than {@code occurrences}.\n *\n * @param element the element to remove\n * @param occurrences the number of occurrences of {@code element} to remove\n * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)\n */\n", "repo_name": "guava-master/", "id": 3539, "method_signature": "boolean removeExactly(Object, int)", "filename": "OldConcurrentHashMultiset.removeExactly.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.containsKey", "ConcurrentMap<E, Integer>.remove", "ConcurrentMap<E, Integer>.putIfAbsent", "ConcurrentMap<E, Integer>.replace"], "method_name": "OldConcurrentHashMultiset.setCount", "method_implementation": "{\n    checkNonnegative(oldCount, \"oldCount\");\n    checkNonnegative(newCount, \"newCount\");\n    if (newCount == 0) {\n        if (oldCount == 0) {\n            // No change to make, but must return true if the element is not present\n            return !countMap.containsKey(element);\n        } else {\n            return countMap.remove(element, oldCount);\n        }\n    }\n    if (oldCount == 0) {\n        return countMap.putIfAbsent(element, newCount) == null;\n    }\n    return countMap.replace(element, oldCount, newCount);\n}", "repo_id": "5", "comment": "/**\n * Sets the number of occurrences of {@code element} to {@code newCount}, but only if the count\n * is currently {@code oldCount}. If {@code element} does not appear in the multiset exactly\n * {@code oldCount} times, no changes will be made.\n *\n * @return {@code true} if the change was successful. This usually indicates that the multiset\n *     has been modified, but not always: in the case that {@code oldCount == newCount}, the\n *     method will return {@code true} if the condition was met.\n * @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is negative\n */\n", "repo_name": "guava-master/", "id": 3541, "method_signature": "boolean setCount(E, int, int)", "filename": "OldConcurrentHashMultiset.setCount.json"}
{"callee_method_names": ["ConcurrentMap<E, Integer>.values"], "method_name": "OldConcurrentHashMultiset.size", "method_implementation": "{\n    long sum = 0L;\n    for (Integer value : countMap.values()) {\n        sum += value;\n    }\n    return Ints.saturatedCast(sum);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>If the data in the multiset is modified by any other threads during this method, it is\n * undefined which (if any) of these modifications will be reflected in the result.\n */\n", "repo_name": "guava-master/", "id": 3534, "method_signature": "int size()", "filename": "OldConcurrentHashMultiset.size.json"}
{"callee_method_names": ["Entry<K,V1>.getElement", "Entry<K,V1>.getCount", "List<E>.add"], "method_name": "OldConcurrentHashMultiset.snapshot", "method_implementation": "{\n    List<E> list = Lists.newArrayListWithExpectedSize(size());\n    for (Multiset.Entry<E> entry : entrySet()) {\n        E element = entry.getElement();\n        for (int i = entry.getCount(); i > 0; i--) {\n            list.add(element);\n        }\n    }\n    return list;\n}", "repo_id": "5", "comment": "/*\n     * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but\n     * either of these would recurse back to us again!\n     */\n", "repo_name": "guava-master/", "id": 3535, "method_signature": "List<E> snapshot()", "filename": "OldConcurrentHashMultiset.snapshot.json"}
{"callee_method_names": ["Iterable<? extends Optional<? extends T>>.iterator", "Iterator<? extends Optional<? extends T>>.hasNext", "Iterator<? extends Optional<? extends T>>.next", "Optional<? extends T>.isPresent", "Optional<? extends T>.get"], "method_name": "Optional.presentInstances", "method_implementation": "{\n    checkNotNull(optionals);\n    return new Iterable<T>() {\n\n        @Override\n        public Iterator<T> iterator() {\n            return new AbstractIterator<T>() {\n\n                private final Iterator<? extends Optional<? extends T>> iterator = checkNotNull(optionals.iterator());\n\n                @Override\n                @CheckForNull\n                protected T computeNext() {\n                    while (iterator.hasNext()) {\n                        Optional<? extends T> optional = iterator.next();\n                        if (optional.isPresent()) {\n                            return optional.get();\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns the value of each present instance from the supplied {@code optionals}, in order,\n * skipping over occurrences of {@link Optional#absent}. Iterators are unmodifiable and are\n * evaluated lazily.\n *\n * <p><b>Comparison to {@code java.util.Optional}:</b> this method has no equivalent in Java 8's\n * {@code Optional} class; use {@code\n * optionals.stream().filter(Optional::isPresent).map(Optional::get)} instead.\n *\n * <p><b>Java 9 users:</b> use {@code optionals.stream().flatMap(Optional::stream)} instead.\n *\n * @since 11.0 (generics widened in 13.0)\n */\n", "repo_name": "guava-master/", "id": 4989, "method_signature": "Iterable<T> presentInstances(Iterable)", "filename": "Optional.presentInstances.json"}
{"callee_method_names": ["List<E>.size", "Comparator<? super E>.compare", "List<E>.get", "List<E>.get"], "method_name": "OrderedPermutationCollection.calculateSize", "method_implementation": "{\n    int permutations = 1;\n    int n = 1;\n    int r = 1;\n    while (n < sortedInputList.size()) {\n        int comparison = comparator.compare(sortedInputList.get(n - 1), sortedInputList.get(n));\n        if (comparison < 0) {\n            // We move to the next non-repeated element.\n            permutations = IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));\n            r = 0;\n            if (permutations == Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n        }\n        n++;\n        r++;\n    }\n    return IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));\n}", "repo_id": "5", "comment": "/**\n * The number of permutations with repeated elements is calculated as follows:\n *\n * <ul>\n *   <li>For an empty list, it is 1 (base case).\n *   <li>When r numbers are added to a list of n-r elements, the number of permutations is\n *       increased by a factor of (n choose r).\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 6611, "method_signature": "int calculateSize(List, Comparator)", "filename": "OrderedPermutationCollection.calculateSize.json"}
{"callee_method_names": [], "method_name": "Ordering.allEqual", "method_implementation": "{\n    return AllEqualOrdering.INSTANCE;\n}", "repo_id": "5", "comment": "/**\n * Returns an ordering which treats all values as equal, indicating \"no ordering.\" Passing this\n * ordering to any <i>stable</i> sort algorithm results in no change to the order of elements.\n * Note especially that {@link #sortedCopy} and {@link #immutableSortedCopy} are stable, and in\n * the returned instance these are implemented by simply copying the source list.\n *\n * <p>Example:\n *\n * <pre>{@code\n * Ordering.allEqual().nullsLast().sortedCopy(\n *     asList(t, null, e, s, null, t, null))\n * }</pre>\n *\n * <p>Assuming {@code t}, {@code e} and {@code s} are non-null, this returns {@code [t, e, s, t,\n * null, null, null]} regardless of the true comparison order of those three values (which might\n * not even implement {@link Comparable} at all).\n *\n * <p><b>Warning:</b> by definition, this comparator is not <i>consistent with equals</i> (as\n * defined {@linkplain Comparator here}). Avoid its use in APIs, such as {@link\n * TreeSet#TreeSet(Comparator)}, where such consistency is expected.\n *\n * <p>The returned comparator is serializable.\n *\n * <p><b>Java 8 users:</b> Use the lambda expression {@code (a, b) -> 0} instead (in certain cases\n * you may need to cast that to {@code Comparator<YourType>}).\n *\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 6315, "method_signature": "Ordering<Object> allEqual()", "filename": "Ordering.allEqual.json"}
{"callee_method_names": [], "method_name": "Ordering.binarySearch", "method_implementation": "{\n    return Collections.binarySearch(sortedList, key, this);\n}", "repo_id": "5", "comment": "/**\n * {@link Collections#binarySearch(List, Object, Comparator) Searches} {@code sortedList} for\n * {@code key} using the binary search algorithm. The list must be sorted using this ordering.\n *\n * @param sortedList the list to be searched\n * @param key the key to be searched for\n * @deprecated Use {@link Collections#binarySearch(List, Object, Comparator)} directly.\n */\n", "repo_name": "guava-master/", "id": 6328, "method_signature": "int binarySearch(List, T)", "filename": "Ordering.binarySearch.json"}
{"callee_method_names": [], "method_name": "Ordering.compound", "method_implementation": "{\n    return new CompoundOrdering<T>(comparators);\n}", "repo_id": "5", "comment": "/**\n * Returns an ordering which tries each given comparator in order until a non-zero result is\n * found, returning that result, and returning zero only if all comparators return zero. The\n * returned ordering is based on the state of the {@code comparators} iterable at the time it was\n * provided to this method.\n *\n * <p>The returned ordering is equivalent to that produced using {@code\n * Ordering.from(comp1).compound(comp2).compound(comp3) . . .}.\n *\n * <p>The returned object is serializable if each of the {@code comparators} is serializable.\n *\n * <p><b>Warning:</b> Supplying an argument with undefined iteration order, such as a {@link\n * HashSet}, will produce non-deterministic results.\n *\n * <p><b>Java 8 users:</b> Use a chain of calls to {@link Comparator#thenComparing(Comparator)},\n * or {@code comparatorCollection.stream().reduce(Comparator::thenComparing).get()} (if the\n * collection might be empty, also provide a default comparator as the {@code identity} parameter\n * to {@code reduce}).\n *\n * @param comparators the comparators to try in order\n */\n", "repo_name": "guava-master/", "id": 6316, "method_signature": "Ordering<T> compound(Iterable)", "filename": "Ordering.compound.json"}
{"callee_method_names": [], "method_name": "Ordering.from", "method_implementation": "{\n    return checkNotNull(ordering);\n}", "repo_id": "5", "comment": "/**\n * Simply returns its argument.\n *\n * @deprecated no need to use this\n */\n", "repo_name": "guava-master/", "id": 6314, "method_signature": "Ordering<T> from(Ordering)", "filename": "Ordering.from.json"}
{"callee_method_names": [], "method_name": "Ordering.greatestOf", "method_implementation": "{\n    // TODO(kevinb): see if delegation is hurting performance noticeably\n    // TODO(kevinb): if we change this implementation, add full unit tests.\n    return this.<E>reverse().leastOf(iterable, k);\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code k} greatest elements of the given iterable according to this ordering, in\n * order from greatest to least. If there are fewer than {@code k} elements present, all will be\n * included.\n *\n * <p>The implementation does not necessarily use a <i>stable</i> sorting algorithm; when multiple\n * elements are equivalent, it is undefined which will come first.\n *\n * <p><b>Java 8 users:</b> Continue to use this method for now. After the next release of Guava,\n * use {@code Streams.stream(iterable).collect(Comparators.greatest(k, thisComparator))} instead.\n *\n * @return an immutable {@code RandomAccess} list of the {@code k} greatest elements in\n *     <i>descending order</i>\n * @throws IllegalArgumentException if {@code k} is negative\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 6324, "method_signature": "List<E> greatestOf(Iterable, int)", "filename": "Ordering.greatestOf.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next"], "method_name": "Ordering.isOrdered", "method_implementation": "{\n    Iterator<? extends T> it = iterable.iterator();\n    if (it.hasNext()) {\n        T prev = it.next();\n        while (it.hasNext()) {\n            T next = it.next();\n            if (compare(prev, next) > 0) {\n                return false;\n            }\n            prev = next;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if each element in {@code iterable} after the first is greater than or\n * equal to the element that preceded it, according to this ordering. Note that this is always\n * true when the iterable has fewer than two elements.\n *\n * <p><b>Java 8 users:</b> Use the equivalent {@link Comparators#isInOrder(Iterable, Comparator)}\n * instead, since the rest of {@code Ordering} is mostly obsolete (as explained in the class\n * documentation).\n */\n", "repo_name": "guava-master/", "id": 6326, "method_signature": "boolean isOrdered(Iterable)", "filename": "Ordering.isOrdered.json"}
{"callee_method_names": ["Iterable<? extends T>.iterator", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next"], "method_name": "Ordering.isStrictlyOrdered", "method_implementation": "{\n    Iterator<? extends T> it = iterable.iterator();\n    if (it.hasNext()) {\n        T prev = it.next();\n        while (it.hasNext()) {\n            T next = it.next();\n            if (compare(prev, next) >= 0) {\n                return false;\n            }\n            prev = next;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if each element in {@code iterable} after the first is <i>strictly</i>\n * greater than the element that preceded it, according to this ordering. Note that this is always\n * true when the iterable has fewer than two elements.\n *\n * <p><b>Java 8 users:</b> Use the equivalent {@link Comparators#isInStrictOrder(Iterable,\n * Comparator)} instead, since the rest of {@code Ordering} is mostly obsolete (as explained in\n * the class documentation).\n */\n", "repo_name": "guava-master/", "id": 6327, "method_signature": "boolean isStrictlyOrdered(Iterable)", "filename": "Ordering.isStrictlyOrdered.json"}
{"callee_method_names": ["Iterator<E>.hasNext", "ArrayList<E>.size", "ArrayList<E>.subList", "ArrayList<E>.size", "ArrayList<E>.trimToSize", "TopKSelector<E>.offerAll", "TopKSelector<E>.topK"], "method_name": "Ordering.leastOf", "method_implementation": "{\n    checkNotNull(iterator);\n    checkNonnegative(k, \"k\");\n    if (k == 0 || !iterator.hasNext()) {\n        return Collections.emptyList();\n    } else if (k >= Integer.MAX_VALUE / 2) {\n        // k is really large; just do a straightforward sorted-copy-and-sublist\n        ArrayList<E> list = Lists.newArrayList(iterator);\n        Collections.sort(list, this);\n        if (list.size() > k) {\n            list.subList(k, list.size()).clear();\n        }\n        list.trimToSize();\n        return Collections.unmodifiableList(list);\n    } else {\n        TopKSelector<E> selector = TopKSelector.least(k, this);\n        selector.offerAll(iterator);\n        return selector.topK();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code k} least elements from the given iterator according to this ordering, in\n * order from least to greatest. If there are fewer than {@code k} elements present, all will be\n * included.\n *\n * <p>The implementation does not necessarily use a <i>stable</i> sorting algorithm; when multiple\n * elements are equivalent, it is undefined which will come first.\n *\n * <p><b>Java 8 users:</b> Use {@code Streams.stream(iterator).collect(Comparators.least(k,\n * thisComparator))} instead.\n *\n * @return an immutable {@code RandomAccess} list of the {@code k} least elements in ascending\n *     order\n * @throws IllegalArgumentException if {@code k} is negative\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6323, "method_signature": "List<E> leastOf(Iterator, int)", "filename": "Ordering.leastOf.json"}
{"callee_method_names": [], "method_name": "Ordering.lexicographical", "method_implementation": "{\n    /*\n     * Note that technically the returned ordering should be capable of\n     * handling not just {@code Iterable<S>} instances, but also any {@code\n     * Iterable<? extends S>}. However, the need for this comes up so rarely\n     * that it doesn't justify making everyone else deal with the very ugly\n     * wildcard.\n     */\n    return new LexicographicalOrdering<S>(this);\n}", "repo_id": "5", "comment": "/**\n * Returns a new ordering which sorts iterables by comparing corresponding elements pairwise until\n * a nonzero result is found; imposes \"dictionary order\". If the end of one iterable is reached,\n * but not the other, the shorter iterable is considered to be less than the longer one. For\n * example, a lexicographical natural ordering over integers considers {@code [] < [1] < [1, 1] <\n * [1, 2] < [2]}.\n *\n * <p>Note that {@code ordering.lexicographical().reverse()} is not equivalent to {@code\n * ordering.reverse().lexicographical()} (consider how each would order {@code [1]} and {@code [1,\n * 1]}).\n *\n * <p><b>Java 8 users:</b> Use {@link Comparators#lexicographical(Comparator)} instead.\n *\n * @since 2.0\n */\n", "repo_name": "guava-master/", "id": 6317, "method_signature": "Ordering<Iterable<S>> lexicographical()", "filename": "Ordering.lexicographical.json"}
{"callee_method_names": [], "method_name": "Ordering.max", "method_implementation": "{\n    E maxSoFar = max(max(a, b), c);\n    for (E r : rest) {\n        maxSoFar = max(maxSoFar, r);\n    }\n    return maxSoFar;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest of the specified values according to this ordering. If there are multiple\n * greatest values, the first of those is returned.\n *\n * <p><b>Java 8 users:</b> Use {@code Collections.max(Arrays.asList(a, b, c...), thisComparator)}\n * instead (but note that it does not guarantee which tied maximum element is returned).\n *\n * @param a value to compare, returned if greater than or equal to the rest.\n * @param b value to compare\n * @param c value to compare\n * @param rest values to compare\n * @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this\n *     ordering.\n */\n", "repo_name": "guava-master/", "id": 6321, "method_signature": "E max(E, E, E, E[])", "filename": "Ordering.max.json"}
{"callee_method_names": [], "method_name": "Ordering.min", "method_implementation": "{\n    E minSoFar = min(min(a, b), c);\n    for (E r : rest) {\n        minSoFar = min(minSoFar, r);\n    }\n    return minSoFar;\n}", "repo_id": "5", "comment": "/**\n * Returns the least of the specified values according to this ordering. If there are multiple\n * least values, the first of those is returned.\n *\n * <p><b>Java 8 users:</b> Use {@code Collections.min(Arrays.asList(a, b, c...), thisComparator)}\n * instead (but note that it does not guarantee which tied minimum element is returned).\n *\n * @param a value to compare, returned if less than or equal to the rest.\n * @param b value to compare\n * @param c value to compare\n * @param rest values to compare\n * @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this\n *     ordering.\n */\n", "repo_name": "guava-master/", "id": 6319, "method_signature": "E min(E, E, E, E[])", "filename": "Ordering.min.json"}
{"callee_method_names": [], "method_name": "Ordering.natural", "method_implementation": "{\n    return (Ordering<C>) NaturalOrdering.INSTANCE;\n}", "repo_id": "5", "comment": "/**\n * Returns a serializable ordering that uses the natural order of the values. The ordering throws\n * a {@link NullPointerException} when passed a null parameter.\n *\n * <p>The type specification is {@code <C extends Comparable>}, instead of the technically correct\n * {@code <C extends Comparable<? super C>>}, to support legacy types from before Java 5.\n *\n * <p><b>Java 8 users:</b> use {@link Comparator#naturalOrder} instead.\n */\n", "repo_name": "guava-master/", "id": 6312, "method_signature": "Ordering<C> natural()", "filename": "Ordering.natural.json"}
{"callee_method_names": [], "method_name": "Ordering.sortedCopy", "method_implementation": "{\n    // does not escape, and contains only E's\n    @SuppressWarnings(\"unchecked\")\n    E[] array = (E[]) Iterables.toArray(elements);\n    Arrays.sort(array, this);\n    return Lists.newArrayList(Arrays.asList(array));\n}", "repo_id": "5", "comment": "// TODO(kevinb): rerun benchmarks including new options\n", "repo_name": "guava-master/", "id": 6325, "method_signature": "List<E> sortedCopy(Iterable)", "filename": "Ordering.sortedCopy.json"}
{"callee_method_names": ["List<Object>.add", "Ordering<Object>.toString"], "method_name": "OrderingTest.testArbitrary_withoutCollisions", "method_implementation": "{\n    List<Object> list = Lists.newArrayList();\n    for (int i = 0; i < 50; i++) {\n        list.add(new Object());\n    }\n    Ordering<Object> arbitrary = Ordering.arbitrary();\n    Collections.sort(list, arbitrary);\n    // Now we don't care what order it's put the list in, only that\n    // comparing any pair of elements gives the answer we expect.\n    Helpers.testComparator(arbitrary, list);\n    assertEquals(\"Ordering.arbitrary()\", arbitrary.toString());\n}", "repo_id": "5", "comment": "// actual public API.\n", "repo_name": "guava-master/", "id": 3985, "method_signature": "void testArbitrary_withoutCollisions()", "filename": "OrderingTest.testArbitrary_withoutCollisions.json"}
{"callee_method_names": ["Ordering<Iterable<Integer>>.sortedCopy"], "method_name": "OrderingTest.testComplicatedOrderingExample", "method_implementation": "{\n    Integer nullInt = (Integer) null;\n    Ordering<Iterable<Integer>> example = Ordering.<Integer>natural().nullsFirst().reverse().lexicographical().reverse().nullsLast();\n    List<Integer> list1 = Lists.newArrayList();\n    List<Integer> list2 = Lists.newArrayList(1);\n    List<Integer> list3 = Lists.newArrayList(1, 1);\n    List<Integer> list4 = Lists.newArrayList(1, 2);\n    List<Integer> list5 = Lists.newArrayList(1, null, 2);\n    List<Integer> list6 = Lists.newArrayList(2);\n    List<Integer> list7 = Lists.newArrayList(nullInt);\n    List<Integer> list8 = Lists.newArrayList(nullInt, nullInt);\n    List<List<Integer>> list = Lists.newArrayList(list1, list2, list3, list4, list5, list6, list7, list8, null);\n    List<List<Integer>> sorted = example.sortedCopy(list);\n    // [[null, null], [null], [1, null, 2], [1, 1], [1, 2], [1], [2], [], null]\n    assertThat(sorted).containsExactly(Lists.newArrayList(nullInt, nullInt), Lists.newArrayList(nullInt), Lists.newArrayList(1, null, 2), Lists.newArrayList(1, 1), Lists.newArrayList(1, 2), Lists.newArrayList(1), Lists.newArrayList(2), Lists.newArrayList(), null).inOrder();\n}", "repo_id": "5", "comment": "// From https://github.com/google/guava/issues/1342\n", "repo_name": "guava-master/", "id": 3984, "method_signature": "void testComplicatedOrderingExample()", "filename": "OrderingTest.testComplicatedOrderingExample.json"}
{"callee_method_names": [], "method_name": "OrderingTest.testExhaustively", "method_implementation": "{\n    checkArgument(strictlyOrderedElements.length >= 3, \"strictlyOrderedElements \" + \"requires at least 3 elements\");\n    List<T> list = Arrays.asList(strictlyOrderedElements);\n    // for use calling Collection.toArray later\n    T[] emptyArray = Platform.newArray(strictlyOrderedElements, 0);\n    // shoot me, but I didn't want to deal with wildcards through the whole test\n    @SuppressWarnings(\"unchecked\")\n    Scenario<T> starter = new Scenario<>((Ordering) ordering, list, emptyArray);\n    verifyScenario(starter, 0);\n}", "repo_id": "5", "comment": "/**\n * Requires at least 3 elements in {@code strictlyOrderedElements} in order to test the varargs\n * version of min/max.\n */\n", "repo_name": "guava-master/", "id": 3986, "method_signature": "void testExhaustively(Ordering, T[])", "filename": "OrderingTest.testExhaustively.json"}
{"callee_method_ids": [6808], "callee_method_names": ["EventBus.register", "AtomicReference<String>.set", "AtomicInteger.incrementAndGet", "EventBus.post", "AtomicInteger.get", "AtomicReference<String>.get"], "method_name": "OutsideEventBusTest.testAnonymous", "method_implementation": "{\n    final AtomicReference<String> holder = new AtomicReference<>();\n    final AtomicInteger deliveries = new AtomicInteger();\n    EventBus bus = new EventBus();\n    bus.register(new Object() {\n\n        @Subscribe\n        public void accept(String str) {\n            holder.set(str);\n            deliveries.incrementAndGet();\n        }\n    });\n    String EVENT = \"Hello!\";\n    bus.post(EVENT);\n    assertEquals(\"Only one event should be delivered.\", 1, deliveries.get());\n    assertEquals(\"Correct string should be delivered.\", EVENT, holder.get());\n}", "repo_id": "5", "comment": "/*\n   * If you do this test from common.eventbus.EventBusTest, it doesn't actually test the behavior.\n   * That is, even if exactly the same method works from inside the common.eventbus package tests,\n   * it can fail here.\n   */\n", "repo_name": "guava-master/", "id": 4074, "method_signature": "void testAnonymous()", "filename": "OutsideEventBusTest.testAnonymous.json"}
{"callee_method_ids": [4601, 4601], "callee_method_names": ["Object.getClass", "Stats.equals", "Stats.equals"], "method_name": "PairedStats.equals", "method_implementation": "{\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        return false;\n    }\n    PairedStats other = (PairedStats) obj;\n    return xStats.equals(other.xStats) && yStats.equals(other.yStats) && doubleToLongBits(sumOfProductsOfDeltas) == doubleToLongBits(other.sumOfProductsOfDeltas);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p><b>Note:</b> This tests exact equality of the calculated statistics, including the floating\n * point values. Two instances are guaranteed to be considered equal if one is copied from the\n * other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both\n * were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without\n * adding any values in between the two calls, or if one is obtained from the other after\n * round-tripping through java serialization. However, floating point rounding errors mean that it\n * may be false for some instances where the statistics are mathematically equal, including\n * instances constructed from the same values in a different order... or (in the general case)\n * even in the same order. (It is guaranteed to return true for instances constructed from the\n * same values in the same order if {@code strictfp} is in effect, or if the system architecture\n * guarantees {@code strictfp}-like semantics.)\n */\n", "repo_name": "guava-master/", "id": 4578, "method_signature": "boolean equals(Object)", "filename": "PairedStats.equals.json"}
{"callee_method_names": ["ByteBuffer.getDouble"], "method_name": "PairedStats.fromByteArray", "method_implementation": "{\n    checkNotNull(byteArray);\n    checkArgument(byteArray.length == BYTES, \"Expected PairedStats.BYTES = %s, got %s\", BYTES, byteArray.length);\n    ByteBuffer buffer = ByteBuffer.wrap(byteArray).order(ByteOrder.LITTLE_ENDIAN);\n    Stats xStats = Stats.readFrom(buffer);\n    Stats yStats = Stats.readFrom(buffer);\n    double sumOfProductsOfDeltas = buffer.getDouble();\n    return new PairedStats(xStats, yStats, sumOfProductsOfDeltas);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link PairedStats} instance from the given byte representation which was obtained by\n * {@link #toByteArray}.\n *\n * <p><b>Note:</b> No guarantees are made regarding stability of the representation between\n * versions.\n */\n", "repo_name": "guava-master/", "id": 4580, "method_signature": "PairedStats fromByteArray(byte[])", "filename": "PairedStats.fromByteArray.json"}
{"callee_method_names": ["Stats.sumOfSquaresOfDeltas", "Stats.sumOfSquaresOfDeltas", "Stats.mean", "Stats.mean", "Stats.mean", "Stats.sumOfSquaresOfDeltas", "Stats.mean"], "method_name": "PairedStats.leastSquaresFit", "method_implementation": "{\n    checkState(count() > 1);\n    if (isNaN(sumOfProductsOfDeltas)) {\n        return LinearTransformation.forNaN();\n    }\n    double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();\n    if (xSumOfSquaresOfDeltas > 0.0) {\n        if (yStats.sumOfSquaresOfDeltas() > 0.0) {\n            return LinearTransformation.mapping(xStats.mean(), yStats.mean()).withSlope(sumOfProductsOfDeltas / xSumOfSquaresOfDeltas);\n        } else {\n            return LinearTransformation.horizontal(yStats.mean());\n        }\n    } else {\n        checkState(yStats.sumOfSquaresOfDeltas() > 0.0);\n        return LinearTransformation.vertical(xStats.mean());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a linear transformation giving the best fit to the data according to <a\n * href=\"http://mathworld.wolfram.com/LeastSquaresFitting.html\">Ordinary Least Squares linear\n * regression</a> of {@code y} as a function of {@code x}. The count must be greater than one, and\n * either the {@code x} or {@code y} data must have a non-zero population variance (i.e. {@code\n * xStats().populationVariance() > 0.0 || yStats().populationVariance() > 0.0}). The result is\n * guaranteed to be horizontal if there is variance in the {@code x} data but not the {@code y}\n * data, and vertical if there is variance in the {@code y} data but not the {@code x} data.\n *\n * <p>This fit minimizes the root-mean-square error in {@code y} as a function of {@code x}. This\n * error is defined as the square root of the mean of the squares of the differences between the\n * actual {@code y} values of the data and the values predicted by the fit for the {@code x}\n * values (i.e. it is the square root of the mean of the squares of the vertical distances between\n * the data points and the best fit line). For this fit, this error is a fraction {@code sqrt(1 -\n * R*R)} of the population standard deviation of {@code y}, where {@code R} is the Pearson's\n * correlation coefficient (as given by {@link #pearsonsCorrelationCoefficient()}).\n *\n * <p>The corresponding root-mean-square error in {@code x} as a function of {@code y} is a\n * fraction {@code sqrt(1/(R*R) - 1)} of the population standard deviation of {@code x}. This fit\n * does not normally minimize that error: to do that, you should swap the roles of {@code x} and\n * {@code y}.\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link\n * LinearTransformation#forNaN()}.\n *\n * @throws IllegalStateException if the dataset is empty or contains a single pair of values, or\n *     both the {@code x} and {@code y} dataset must have zero population variance\n */\n", "repo_name": "guava-master/", "id": 4577, "method_signature": "LinearTransformation leastSquaresFit()", "filename": "PairedStats.leastSquaresFit.json"}
{"callee_method_names": [], "method_name": "PairedStats.pearsonsCorrelationCoefficient", "method_implementation": "{\n    checkState(count() > 1);\n    if (isNaN(sumOfProductsOfDeltas)) {\n        return NaN;\n    }\n    double xSumOfSquaresOfDeltas = xStats().sumOfSquaresOfDeltas();\n    double ySumOfSquaresOfDeltas = yStats().sumOfSquaresOfDeltas();\n    checkState(xSumOfSquaresOfDeltas > 0.0);\n    checkState(ySumOfSquaresOfDeltas > 0.0);\n    // The product of two positive numbers can be zero if the multiplication underflowed. We\n    // force a positive value by effectively rounding up to MIN_VALUE.\n    double productOfSumsOfSquaresOfDeltas = ensurePositive(xSumOfSquaresOfDeltas * ySumOfSquaresOfDeltas);\n    return ensureInUnitRange(sumOfProductsOfDeltas / Math.sqrt(productOfSumsOfSquaresOfDeltas));\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://mathworld.wolfram.com/CorrelationCoefficient.html\">Pearson's or\n * product-moment correlation coefficient</a> of the values. The count must greater than one, and\n * the {@code x} and {@code y} values must both have non-zero population variance (i.e. {@code\n * xStats().populationVariance() > 0.0 && yStats().populationVariance() > 0.0}). The result is not\n * guaranteed to be exactly +/-1 even when the data are perfectly (anti-)correlated, due to\n * numerical errors. However, it is guaranteed to be in the inclusive range [-1, +1].\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n *\n * @throws IllegalStateException if the dataset is empty or contains a single pair of values, or\n *     either the {@code x} and {@code y} dataset has zero population variance\n */\n", "repo_name": "guava-master/", "id": 4576, "method_signature": "double pearsonsCorrelationCoefficient()", "filename": "PairedStats.pearsonsCorrelationCoefficient.json"}
{"callee_method_ids": [4607, 4607], "callee_method_names": ["Stats.writeTo", "Stats.writeTo", "ByteBuffer.putDouble", "ByteBuffer.array"], "method_name": "PairedStats.toByteArray", "method_implementation": "{\n    ByteBuffer buffer = ByteBuffer.allocate(BYTES).order(ByteOrder.LITTLE_ENDIAN);\n    xStats.writeTo(buffer);\n    yStats.writeTo(buffer);\n    buffer.putDouble(sumOfProductsOfDeltas);\n    return buffer.array();\n}", "repo_id": "5", "comment": "/**\n * Gets a byte array representation of this instance.\n *\n * <p><b>Note:</b> No guarantees are made regarding stability of the representation between\n * versions.\n */\n", "repo_name": "guava-master/", "id": 4579, "method_signature": "byte[] toByteArray()", "filename": "PairedStats.toByteArray.json"}
{"callee_method_ids": [4638, 4638], "callee_method_names": ["StatsAccumulator.add", "StatsAccumulator.count", "StatsAccumulator.mean", "StatsAccumulator.mean", "StatsAccumulator.add"], "method_name": "PairedStatsAccumulator.add", "method_implementation": "{\n    // We extend the recursive expression for the one-variable case at Art of Computer Programming\n    // vol. 2, Knuth, 4.2.2, (16) to the two-variable case. We have two value series x_i and y_i.\n    // We define the arithmetic means X_n = 1/n \\sum_{i=1}^n x_i, and Y_n = 1/n \\sum_{i=1}^n y_i.\n    // We also define the sum of the products of the differences from the means\n    //           C_n = \\sum_{i=1}^n x_i y_i - n X_n Y_n\n    // for all n >= 1. Then for all n > 1:\n    //       C_{n-1} = \\sum_{i=1}^{n-1} x_i y_i - (n-1) X_{n-1} Y_{n-1}\n    // C_n - C_{n-1} = x_n y_n - n X_n Y_n + (n-1) X_{n-1} Y_{n-1}\n    //               = x_n y_n - X_n [ y_n + (n-1) Y_{n-1} ] + [ n X_n - x_n ] Y_{n-1}\n    //               = x_n y_n - X_n y_n - x_n Y_{n-1} + X_n Y_{n-1}\n    //               = (x_n - X_n) (y_n - Y_{n-1})\n    xStats.add(x);\n    if (isFinite(x) && isFinite(y)) {\n        if (xStats.count() > 1) {\n            sumOfProductsOfDeltas += (x - xStats.mean()) * (y - yStats.mean());\n        }\n    } else {\n        sumOfProductsOfDeltas = NaN;\n    }\n    yStats.add(y);\n}", "repo_id": "5", "comment": "/**\n * Adds the given pair of values to the dataset.\n */\n", "repo_name": "guava-master/", "id": 4590, "method_signature": "void add(double, double)", "filename": "PairedStatsAccumulator.add.json"}
{"callee_method_ids": [4645, 4645], "callee_method_names": ["PairedStats.count", "StatsAccumulator.addAll", "PairedStats.xStats", "StatsAccumulator.count", "PairedStats.sumOfProductsOfDeltas", "PairedStats.sumOfProductsOfDeltas", "PairedStats.xStats", "StatsAccumulator.mean", "PairedStats.yStats", "StatsAccumulator.mean", "PairedStats.count", "StatsAccumulator.addAll", "PairedStats.yStats"], "method_name": "PairedStatsAccumulator.addAll", "method_implementation": "{\n    if (values.count() == 0) {\n        return;\n    }\n    xStats.addAll(values.xStats());\n    if (yStats.count() == 0) {\n        sumOfProductsOfDeltas = values.sumOfProductsOfDeltas();\n    } else {\n        // This is a generalized version of the calculation in add(double, double) above. Note that\n        // non-finite inputs will have sumOfProductsOfDeltas = NaN, so non-finite values will result\n        // in NaN naturally.\n        sumOfProductsOfDeltas += values.sumOfProductsOfDeltas() + (values.xStats().mean() - xStats.mean()) * (values.yStats().mean() - yStats.mean()) * values.count();\n    }\n    yStats.addAll(values.yStats());\n}", "repo_id": "5", "comment": "/**\n * Adds the given statistics to the dataset, as if the individual values used to compute the\n * statistics had been added directly.\n */\n", "repo_name": "guava-master/", "id": 4591, "method_signature": "void addAll(PairedStats)", "filename": "PairedStatsAccumulator.addAll.json"}
{"callee_method_names": ["StatsAccumulator.sumOfSquaresOfDeltas", "StatsAccumulator.sumOfSquaresOfDeltas", "StatsAccumulator.mean", "StatsAccumulator.mean", "StatsAccumulator.mean", "StatsAccumulator.sumOfSquaresOfDeltas", "StatsAccumulator.mean"], "method_name": "PairedStatsAccumulator.leastSquaresFit", "method_implementation": "{\n    checkState(count() > 1);\n    if (isNaN(sumOfProductsOfDeltas)) {\n        return LinearTransformation.forNaN();\n    }\n    double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();\n    if (xSumOfSquaresOfDeltas > 0.0) {\n        if (yStats.sumOfSquaresOfDeltas() > 0.0) {\n            return LinearTransformation.mapping(xStats.mean(), yStats.mean()).withSlope(sumOfProductsOfDeltas / xSumOfSquaresOfDeltas);\n        } else {\n            return LinearTransformation.horizontal(yStats.mean());\n        }\n    } else {\n        checkState(yStats.sumOfSquaresOfDeltas() > 0.0);\n        return LinearTransformation.vertical(xStats.mean());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a linear transformation giving the best fit to the data according to <a\n * href=\"http://mathworld.wolfram.com/LeastSquaresFitting.html\">Ordinary Least Squares linear\n * regression</a> of {@code y} as a function of {@code x}. The count must be greater than one, and\n * either the {@code x} or {@code y} data must have a non-zero population variance (i.e. {@code\n * xStats().populationVariance() > 0.0 || yStats().populationVariance() > 0.0}). The result is\n * guaranteed to be horizontal if there is variance in the {@code x} data but not the {@code y}\n * data, and vertical if there is variance in the {@code y} data but not the {@code x} data.\n *\n * <p>This fit minimizes the root-mean-square error in {@code y} as a function of {@code x}. This\n * error is defined as the square root of the mean of the squares of the differences between the\n * actual {@code y} values of the data and the values predicted by the fit for the {@code x}\n * values (i.e. it is the square root of the mean of the squares of the vertical distances between\n * the data points and the best fit line). For this fit, this error is a fraction {@code sqrt(1 -\n * R*R)} of the population standard deviation of {@code y}, where {@code R} is the Pearson's\n * correlation coefficient (as given by {@link #pearsonsCorrelationCoefficient()}).\n *\n * <p>The corresponding root-mean-square error in {@code x} as a function of {@code y} is a\n * fraction {@code sqrt(1/(R*R) - 1)} of the population standard deviation of {@code x}. This fit\n * does not normally minimize that error: to do that, you should swap the roles of {@code x} and\n * {@code y}.\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link\n * LinearTransformation#forNaN()}.\n *\n * @throws IllegalStateException if the dataset is empty or contains a single pair of values, or\n *     both the {@code x} and {@code y} dataset have zero population variance\n */\n", "repo_name": "guava-master/", "id": 4593, "method_signature": "LinearTransformation leastSquaresFit()", "filename": "PairedStatsAccumulator.leastSquaresFit.json"}
{"callee_method_names": ["StatsAccumulator.sumOfSquaresOfDeltas", "StatsAccumulator.sumOfSquaresOfDeltas"], "method_name": "PairedStatsAccumulator.pearsonsCorrelationCoefficient", "method_implementation": "{\n    checkState(count() > 1);\n    if (isNaN(sumOfProductsOfDeltas)) {\n        return NaN;\n    }\n    double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();\n    double ySumOfSquaresOfDeltas = yStats.sumOfSquaresOfDeltas();\n    checkState(xSumOfSquaresOfDeltas > 0.0);\n    checkState(ySumOfSquaresOfDeltas > 0.0);\n    // The product of two positive numbers can be zero if the multiplication underflowed. We\n    // force a positive value by effectively rounding up to MIN_VALUE.\n    double productOfSumsOfSquaresOfDeltas = ensurePositive(xSumOfSquaresOfDeltas * ySumOfSquaresOfDeltas);\n    return ensureInUnitRange(sumOfProductsOfDeltas / Math.sqrt(productOfSumsOfSquaresOfDeltas));\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://mathworld.wolfram.com/CorrelationCoefficient.html\">Pearson's or\n * product-moment correlation coefficient</a> of the values. The count must greater than one, and\n * the {@code x} and {@code y} values must both have non-zero population variance (i.e. {@code\n * xStats().populationVariance() > 0.0 && yStats().populationVariance() > 0.0}). The result is not\n * guaranteed to be exactly +/-1 even when the data are perfectly (anti-)correlated, due to\n * numerical errors. However, it is guaranteed to be in the inclusive range [-1, +1].\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n *\n * @throws IllegalStateException if the dataset is empty or contains a single pair of values, or\n *     either the {@code x} and {@code y} dataset has zero population variance\n */\n", "repo_name": "guava-master/", "id": 4592, "method_signature": "double pearsonsCorrelationCoefficient()", "filename": "PairedStatsAccumulator.pearsonsCorrelationCoefficient.json"}
{"callee_method_names": [], "method_name": "Parameter.getDeclaredAnnotation", "method_implementation": "{\n    checkNotNull(annotationType);\n    return FluentIterable.from(annotations).filter(annotationType).first().orNull();\n}", "repo_id": "5", "comment": "/**\n * @since 18.0\n */\n", "repo_name": "guava-master/", "id": 4713, "method_signature": "A getDeclaredAnnotation(Class)", "filename": "Parameter.getDeclaredAnnotation.json"}
{"callee_method_names": [], "method_name": "Parameter.getDeclaredAnnotationsByType", "method_implementation": "{\n    @Nullable\n    A[] result = FluentIterable.from(annotations).filter(annotationType).toArray(annotationType);\n    // safe because the input list contains no nulls\n    @SuppressWarnings(\"nullness\")\n    A[] cast = (A[]) result;\n    return cast;\n}", "repo_id": "5", "comment": "/**\n * @since 18.0\n */\n", "repo_name": "guava-master/", "id": 4714, "method_signature": "A[] getDeclaredAnnotationsByType(Class)", "filename": "Parameter.getDeclaredAnnotationsByType.json"}
{"callee_method_names": [], "method_name": "ParseOverflowDetection.overflowInParse", "method_implementation": "{\n    if (current >= 0) {\n        if (current < maxValueDivs[radix]) {\n            return false;\n        }\n        if (current > maxValueDivs[radix]) {\n            return true;\n        }\n        // current == maxValueDivs[radix]\n        return (digit > maxValueMods[radix]);\n    }\n    // current < 0: high bit is set\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns true if (current * radix) + digit is a number too large to be represented by an\n * unsigned long. This is useful for detecting overflow while parsing a string representation of\n * a number. Does not verify whether supplied radix is valid, passing an invalid radix will give\n * undefined results or an ArrayIndexOutOfBoundsException.\n */\n", "repo_name": "guava-master/", "id": 4298, "method_signature": "boolean overflowInParse(long, int, int)", "filename": "ParseOverflowDetection.overflowInParse.json"}
{"callee_method_names": ["ImmutableList<ClosingFuture<?>>.contains"], "method_name": "Peeker.getDone", "method_implementation": "{\n    checkState(beingCalled);\n    checkArgument(futures.contains(closingFuture));\n    return Futures.getDone(closingFuture.future);\n}", "repo_id": "5", "comment": "/**\n * Returns the value of {@code closingFuture}.\n *\n * @throws ExecutionException if {@code closingFuture} is a failed step\n * @throws CancellationException if the {@code closingFuture}'s future was cancelled\n * @throws IllegalArgumentException if {@code closingFuture} is not one of the futures passed to\n *     {@link #whenAllComplete(Iterable)} or {@link #whenAllComplete(Iterable)}\n * @throws IllegalStateException if called outside of a call to {@link\n *     CombiningCallable#call(DeferredCloser, Peeker)} or {@link\n *     AsyncCombiningCallable#call(DeferredCloser, Peeker)}\n */\n", "repo_name": "guava-master/", "id": 5419, "method_signature": "D getDone(ClosingFuture)", "filename": "Peeker.getDone.json"}
{"callee_method_names": ["Logger.fine", "Set<Feature<?>>.retainAll", "Set<Feature<?>>.removeAll", "Set<Feature<?>>.retainAll", "Logger.fine", "Set<Feature<?>>.isEmpty", "CollectionSize.toString", "Set<Feature<?>>.add", "OneSizeTestSuiteBuilder<T, E>.createTestSuite", "TestSuite.addTest", "TestSuite.addTest"], "method_name": "PerCollectionSizeTestSuiteBuilder.createTestSuite", "method_implementation": "{\n    checkCanCreate();\n    String name = getName();\n    // Copy this set, so we can modify it.\n    Set<Feature<?>> features = Helpers.copyToSet(getFeatures());\n    List<Class<? extends AbstractTester>> testers = getTesters();\n    logger.fine(\" Testing: \" + name);\n    // Split out all the specified sizes.\n    Set<Feature<?>> sizesToTest = Helpers.<Feature<?>>copyToSet(CollectionSize.values());\n    sizesToTest.retainAll(features);\n    features.removeAll(sizesToTest);\n    FeatureUtil.addImpliedFeatures(sizesToTest);\n    sizesToTest.retainAll(Arrays.asList(CollectionSize.ZERO, CollectionSize.ONE, CollectionSize.SEVERAL));\n    logger.fine(\"   Sizes: \" + formatFeatureSet(sizesToTest));\n    if (sizesToTest.isEmpty()) {\n        throw new IllegalStateException(name + \": no CollectionSizes specified (check the argument to \" + \"FeatureSpecificTestSuiteBuilder.withFeatures().)\");\n    }\n    TestSuite suite = new TestSuite(name);\n    for (Feature<?> collectionSize : sizesToTest) {\n        String oneSizeName = Platform.format(\"%s [collection size: %s]\", name, collectionSize.toString().toLowerCase());\n        OneSizeGenerator<T, E> oneSizeGenerator = new OneSizeGenerator<>(getSubjectGenerator(), (CollectionSize) collectionSize);\n        Set<Feature<?>> oneSizeFeatures = Helpers.copyToSet(features);\n        oneSizeFeatures.add(collectionSize);\n        Set<Method> oneSizeSuppressedTests = getSuppressedTests();\n        OneSizeTestSuiteBuilder<T, E> oneSizeBuilder = new OneSizeTestSuiteBuilder<T, E>(testers).named(oneSizeName).usingGenerator(oneSizeGenerator).withFeatures(oneSizeFeatures).withSetUp(getSetUp()).withTearDown(getTearDown()).suppressing(oneSizeSuppressedTests);\n        TestSuite oneSizeSuite = oneSizeBuilder.createTestSuite();\n        suite.addTest(oneSizeSuite);\n        for (TestSuite derivedSuite : createDerivedSuites(oneSizeBuilder)) {\n            oneSizeSuite.addTest(derivedSuite);\n        }\n    }\n    return suite;\n}", "repo_id": "5", "comment": "/**\n * Creates a runnable JUnit test suite based on the criteria already given.\n */\n", "repo_name": "guava-master/", "id": 4222, "method_signature": "TestSuite createTestSuite()", "filename": "PerCollectionSizeTestSuiteBuilder.createTestSuite.json"}
{"callee_method_names": ["Executor.execute", "LazyLogger.get"], "method_name": "PerListenerQueue.dispatch", "method_implementation": "{\n    boolean scheduleEventRunner = false;\n    synchronized (this) {\n        if (!isThreadScheduled) {\n            isThreadScheduled = true;\n            scheduleEventRunner = true;\n        }\n    }\n    if (scheduleEventRunner) {\n        try {\n            executor.execute(this);\n        } catch (Exception e) {\n            // sneaky checked exception\n            // reset state in case of an error so that later dispatch calls will actually do something\n            synchronized (this) {\n                isThreadScheduled = false;\n            }\n            // Log it and keep going.\n            logger.get().log(Level.SEVERE, \"Exception while running callbacks for \" + listener + \" on \" + executor, e);\n            throw e;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Dispatches all listeners {@linkplain #enqueue enqueued} prior to this call, serially and in\n * order.\n */\n", "repo_name": "guava-master/", "id": 5522, "method_signature": "void dispatch()", "filename": "PerListenerQueue.dispatch.json"}
{"callee_method_names": ["String.toCharArray"], "method_name": "PercentEscaper.createSafeOctets", "method_implementation": "{\n    int maxChar = -1;\n    char[] safeCharArray = safeChars.toCharArray();\n    for (char c : safeCharArray) {\n        maxChar = Math.max(c, maxChar);\n    }\n    boolean[] octets = new boolean[maxChar + 1];\n    for (char c : safeCharArray) {\n        octets[c] = true;\n    }\n    return octets;\n}", "repo_id": "5", "comment": "/**\n * Creates a boolean array with entries corresponding to the character values specified in\n * safeChars set to true. The array is as small as is required to hold the given character\n * information.\n */\n", "repo_name": "guava-master/", "id": 6677, "method_signature": "boolean[] createSafeOctets(String)", "filename": "PercentEscaper.createSafeOctets.json"}
{"callee_method_names": [], "method_name": "PercentEscaper.escape", "method_implementation": "{\n    // We should never get negative values here but if we do it will throw an\n    // IndexOutOfBoundsException, so at least it will get spotted.\n    if (cp < safeOctets.length && safeOctets[cp]) {\n        return null;\n    } else if (cp == ' ' && plusForSpace) {\n        return PLUS_SIGN;\n    } else if (cp <= 0x7F) {\n        // Single byte UTF-8 characters\n        // Start with \"%--\" and fill in the blanks\n        char[] dest = new char[3];\n        dest[0] = '%';\n        dest[2] = UPPER_HEX_DIGITS[cp & 0xF];\n        dest[1] = UPPER_HEX_DIGITS[cp >>> 4];\n        return dest;\n    } else if (cp <= 0x7ff) {\n        // Two byte UTF-8 characters [cp >= 0x80 && cp <= 0x7ff]\n        // Start with \"%--%--\" and fill in the blanks\n        char[] dest = new char[6];\n        dest[0] = '%';\n        dest[3] = '%';\n        dest[5] = UPPER_HEX_DIGITS[cp & 0xF];\n        cp >>>= 4;\n        dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n        cp >>>= 2;\n        dest[2] = UPPER_HEX_DIGITS[cp & 0xF];\n        cp >>>= 4;\n        dest[1] = UPPER_HEX_DIGITS[0xC | cp];\n        return dest;\n    } else if (cp <= 0xffff) {\n        // Three byte UTF-8 characters [cp >= 0x800 && cp <= 0xffff]\n        // Start with \"%E-%--%--\" and fill in the blanks\n        char[] dest = new char[9];\n        dest[0] = '%';\n        dest[1] = 'E';\n        dest[3] = '%';\n        dest[6] = '%';\n        dest[8] = UPPER_HEX_DIGITS[cp & 0xF];\n        cp >>>= 4;\n        dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n        cp >>>= 2;\n        dest[5] = UPPER_HEX_DIGITS[cp & 0xF];\n        cp >>>= 4;\n        dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n        cp >>>= 2;\n        dest[2] = UPPER_HEX_DIGITS[cp];\n        return dest;\n    } else if (cp <= 0x10ffff) {\n        char[] dest = new char[12];\n        // Four byte UTF-8 characters [cp >= 0xffff && cp <= 0x10ffff]\n        // Start with \"%F-%--%--%--\" and fill in the blanks\n        dest[0] = '%';\n        dest[1] = 'F';\n        dest[3] = '%';\n        dest[6] = '%';\n        dest[9] = '%';\n        dest[11] = UPPER_HEX_DIGITS[cp & 0xF];\n        cp >>>= 4;\n        dest[10] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n        cp >>>= 2;\n        dest[8] = UPPER_HEX_DIGITS[cp & 0xF];\n        cp >>>= 4;\n        dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n        cp >>>= 2;\n        dest[5] = UPPER_HEX_DIGITS[cp & 0xF];\n        cp >>>= 4;\n        dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n        cp >>>= 2;\n        dest[2] = UPPER_HEX_DIGITS[cp & 0x7];\n        return dest;\n    } else {\n        // If this ever happens it is due to bug in UnicodeEscaper, not bad input.\n        throw new IllegalArgumentException(\"Invalid unicode character value \" + cp);\n    }\n}", "repo_id": "5", "comment": "/**\n * Escapes the given Unicode code point in UTF-8.\n */\n", "repo_name": "guava-master/", "id": 6680, "method_signature": "char[] escape(int)", "filename": "PercentEscaper.escape.json"}
{"callee_method_names": ["CharSequence.charAt"], "method_name": "PercentEscaper.nextEscapeIndex", "method_implementation": "{\n    checkNotNull(csq);\n    for (; index < end; index++) {\n        char c = csq.charAt(index);\n        if (c >= safeOctets.length || !safeOctets[c]) {\n            break;\n        }\n    }\n    return index;\n}", "repo_id": "5", "comment": "/*\n   * Overridden for performance. For unescaped strings this improved the performance of the uri\n   * escaper from ~760ns to ~400ns as measured by {@link CharEscapersBenchmark}.\n   */\n", "repo_name": "guava-master/", "id": 6678, "method_signature": "int nextEscapeIndex(CharSequence, int, int)", "filename": "PercentEscaper.nextEscapeIndex.json"}
{"callee_method_names": ["String.charAt", "String.charAt"], "method_name": "PercentEscaperTest.escapeAscii", "method_implementation": "{\n    Preconditions.checkArgument(c < 128);\n    String hex = \"0123456789ABCDEF\";\n    return \"%\" + hex.charAt((c >> 4) & 0xf) + hex.charAt(c & 0xf);\n}", "repo_id": "5", "comment": "/**\n * Helper to manually escape a 7-bit ascii character\n */\n", "repo_name": "guava-master/", "id": 4040, "method_signature": "String escapeAscii(char)", "filename": "PercentEscaperTest.escapeAscii.json"}
{"callee_method_names": [], "method_name": "PercentEscaperTest.testBadArguments_badchars", "method_implementation": "{\n    String msg = \"Alphanumeric characters are always 'safe' \" + \"and should not be explicitly specified\";\n    try {\n        new PercentEscaper(\"-+#abc.!\", false);\n        fail(msg);\n    } catch (IllegalArgumentException expected) {\n        assertThat(expected).hasMessageThat().isEqualTo(msg);\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests that specifying any alphanumeric characters as 'safe' causes an {@link\n * IllegalArgumentException}.\n */\n", "repo_name": "guava-master/", "id": 4039, "method_signature": "void testBadArguments_badchars()", "filename": "PercentEscaperTest.testBadArguments_badchars.json"}
{"callee_method_names": [], "method_name": "PercentEscaperTest.testBadArguments_null", "method_implementation": "{\n    try {\n        new PercentEscaper(null, false);\n        fail(\"Expected null pointer exception for null parameter\");\n    } catch (NullPointerException expected) {\n        // pass\n    }\n}", "repo_id": "5", "comment": "/**\n * Test that giving a null 'safeChars' string causes a {@link NullPointerException}.\n */\n", "repo_name": "guava-master/", "id": 4038, "method_signature": "void testBadArguments_null()", "filename": "PercentEscaperTest.testBadArguments_null.json"}
{"callee_method_names": [], "method_name": "PercentEscaperTest.testCustomEscaper", "method_implementation": "{\n    UnicodeEscaper e = new PercentEscaper(\"+*/-\", false);\n    for (char c = 0; c < 128; c++) {\n        if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || \"+*/-\".indexOf(c) >= 0) {\n            assertUnescaped(e, c);\n        } else {\n            assertEscaping(e, escapeAscii(c), c);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Tests that if we add extra 'safe' characters they remain unescaped\n */\n", "repo_name": "guava-master/", "id": 4036, "method_signature": "void testCustomEscaper()", "filename": "PercentEscaperTest.testCustomEscaper.json"}
{"callee_method_ids": [4266, 4266], "callee_method_names": ["UnicodeEscaper.escape", "UnicodeEscaper.escape"], "method_name": "PercentEscaperTest.testCustomEscaper_withpercent", "method_implementation": "{\n    UnicodeEscaper e = new PercentEscaper(\"%\", false);\n    assertEquals(\"foo%7Cbar\", e.escape(\"foo|bar\"));\n    // idempotent\n    assertEquals(\"foo%7Cbar\", e.escape(\"foo%7Cbar\"));\n}", "repo_id": "5", "comment": "/**\n * Tests that if specify '%' as safe the result is an idempotent escaper.\n */\n", "repo_name": "guava-master/", "id": 4037, "method_signature": "void testCustomEscaper_withpercent()", "filename": "PercentEscaperTest.testCustomEscaper_withpercent.json"}
{"callee_method_ids": [4266, 4266, 4266], "callee_method_names": ["UnicodeEscaper.escape", "UnicodeEscaper.escape", "UnicodeEscaper.escape"], "method_name": "PercentEscaperTest.testPlusForSpace", "method_implementation": "{\n    UnicodeEscaper basicEscaper = new PercentEscaper(\"\", false);\n    UnicodeEscaper plusForSpaceEscaper = new PercentEscaper(\"\", true);\n    UnicodeEscaper spaceEscaper = new PercentEscaper(\" \", false);\n    assertEquals(\"string%20with%20spaces\", basicEscaper.escape(\"string with spaces\"));\n    assertEquals(\"string+with+spaces\", plusForSpaceEscaper.escape(\"string with spaces\"));\n    assertEquals(\"string with spaces\", spaceEscaper.escape(\"string with spaces\"));\n}", "repo_id": "5", "comment": "/**\n * Tests the various ways that the space character can be handled\n */\n", "repo_name": "guava-master/", "id": 4035, "method_signature": "void testPlusForSpace()", "filename": "PercentEscaperTest.testPlusForSpace.json"}
{"callee_method_ids": [4266, 4266, 4266, 4266], "callee_method_names": ["UnicodeEscaper.escape", "UnicodeEscaper.escape", "UnicodeEscaper.escape", "UnicodeEscaper.escape"], "method_name": "PercentEscaperTest.testSimpleEscaper", "method_implementation": "{\n    UnicodeEscaper e = new PercentEscaper(\"\", false);\n    for (char c = 0; c < 128; c++) {\n        if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            assertUnescaped(e, c);\n        } else {\n            assertEscaping(e, escapeAscii(c), c);\n        }\n    }\n    // Testing multibyte escape sequences\n    // nul\n    assertEscaping(e, \"%00\", '\\u0000');\n    // del\n    assertEscaping(e, \"%7F\", '\\u007f');\n    // xx-00010,x-000000\n    assertEscaping(e, \"%C2%80\", '\\u0080');\n    // xx-11111,x-111111\n    assertEscaping(e, \"%DF%BF\", '\\u07ff');\n    // xxx-0000,x-100000,x-00,0000\n    assertEscaping(e, \"%E0%A0%80\", '\\u0800');\n    // xxx-1111,x-111111,x-11,1111\n    assertEscaping(e, \"%EF%BF%BF\", '\\uffff');\n    assertUnicodeEscaping(e, \"%F0%90%80%80\", '\\uD800', '\\uDC00');\n    assertUnicodeEscaping(e, \"%F4%8F%BF%BF\", '\\uDBFF', '\\uDFFF');\n    // simple string tests\n    assertEquals(\"\", e.escape(\"\"));\n    assertEquals(\"safestring\", e.escape(\"safestring\"));\n    assertEquals(\"embedded%00null\", e.escape(\"embedded\\0null\"));\n    assertEquals(\"max%EF%BF%BFchar\", e.escape(\"max\\uffffchar\"));\n}", "repo_id": "5", "comment": "/**\n * Tests that the simple escaper treats 0-9, a-z and A-Z as safe\n */\n", "repo_name": "guava-master/", "id": 4034, "method_signature": "void testSimpleEscaper()", "filename": "PercentEscaperTest.testSimpleEscaper.json"}
{"callee_method_names": [], "method_name": "Platform.copy", "method_implementation": "{\n    T[] result = newArray(arrayOfType, to - from);\n    System.arraycopy(source, from, result, 0, to - from);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Equivalent to Arrays.copyOfRange(source, from, to, arrayOfType.getClass()).\n */\n", "repo_name": "guava-master/", "id": 6826, "method_signature": "T[] copy(Object[], int, int, T[])", "filename": "Platform.copy.json"}
{"callee_method_names": ["String.length", "String.indexOf", "StringBuilder.append", "String.substring", "StringBuilder.append", "StringBuilder.append", "String.substring", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Platform.format", "method_implementation": "{\n    // start substituting the arguments into the '%s' placeholders\n    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);\n    int templateStart = 0;\n    int i = 0;\n    while (i < args.length) {\n        int placeholderStart = template.indexOf(\"%s\", templateStart);\n        if (placeholderStart == -1) {\n            break;\n        }\n        builder.append(template.substring(templateStart, placeholderStart));\n        builder.append(args[i++]);\n        templateStart = placeholderStart + 2;\n    }\n    builder.append(template.substring(templateStart));\n    // if we run out of placeholders, append the extra args in square braces\n    if (i < args.length) {\n        builder.append(\" [\");\n        builder.append(args[i++]);\n        while (i < args.length) {\n            builder.append(\", \");\n            builder.append(args[i++]);\n        }\n        builder.append(\"]\");\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "// TODO: Consolidate different copies in one single place.\n", "repo_name": "guava-master/", "id": 6815, "method_signature": "String format(String, Object[])", "filename": "Platform.format.json"}
{"callee_method_names": ["ObjectOutputStream.writeObject", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject"], "method_name": "Platform.reserialize", "method_implementation": "{\n    checkNotNull(object);\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n    try {\n        ObjectOutputStream out = new ObjectOutputStream(bytes);\n        out.writeObject(object);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray()));\n        return (T) requireNonNull(in.readObject());\n    } catch (IOException | ClassNotFoundException e) {\n        throw new RuntimeException(e);\n    }\n}", "repo_id": "5", "comment": "/**\n * Serializes and deserializes the specified object.\n */\n", "repo_name": "guava-master/", "id": 4143, "method_signature": "T reserialize(T)", "filename": "Platform.reserialize.json"}
{"callee_method_names": ["CacheBuilderFactory.buildAllPermutations", "CacheBuilder<Object, Object>.recordStats"], "method_name": "PopulatedCachesTest.caches", "method_implementation": "{\n    // lots of different ways to configure a LoadingCache\n    CacheBuilderFactory factory = cacheFactory();\n    return Iterables.transform(factory.buildAllPermutations(), new Function<CacheBuilder<Object, Object>, LoadingCache<Object, Object>>() {\n\n        @Override\n        public LoadingCache<Object, Object> apply(CacheBuilder<Object, Object> builder) {\n            return builder.recordStats().build(identityLoader());\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Most of the tests in this class run against every one of these caches.\n */\n", "repo_name": "guava-master/", "id": 3674, "method_signature": "Iterable<LoadingCache<Object,Object>> caches()", "filename": "PopulatedCachesTest.caches.json"}
{"callee_method_names": ["LoadingCache<Object,Object>.getUnchecked", "List<Entry<Object, Object>>.add"], "method_name": "PopulatedCachesTest.warmUp", "method_implementation": "{\n    List<Entry<Object, Object>> entries = Lists.newArrayList();\n    for (int i = minimum; i < maximum; i++) {\n        Object key = i;\n        Object value = cache.getUnchecked(key);\n        entries.add(entryOf(key, value));\n    }\n    return entries;\n}", "repo_id": "5", "comment": "/**\n * Returns the entries that were added to the map, so they won't fall out of a map with weak or\n * soft references until the caller drops the reference to the returned entries.\n */\n", "repo_name": "guava-master/", "id": 3675, "method_signature": "List<Entry<Object,Object>> warmUp(LoadingCache, int, int)", "filename": "PopulatedCachesTest.warmUp.json"}
{"callee_method_names": ["T.getCause", "StringBuilder.append", "T.getMessage", "StringBuilder.toString"], "method_name": "PotentialDeadlockException.getMessage", "method_implementation": "{\n    // requireNonNull is safe because ExampleStackTrace sets a non-null message.\n    StringBuilder message = new StringBuilder(requireNonNull(super.getMessage()));\n    for (Throwable t = conflictingStackTrace; t != null; t = t.getCause()) {\n        message.append(\", \").append(t.getMessage());\n    }\n    return message.toString();\n}", "repo_id": "5", "comment": "/**\n * Appends the chain of messages from the {@code conflictingStackTrace} to the original {@code\n * message}.\n */\n", "repo_name": "guava-master/", "id": 5480, "method_signature": "String getMessage()", "filename": "PotentialDeadlockException.getMessage.json"}
{"callee_method_names": [], "method_name": "Preconditions.checkArgument", "method_implementation": "{\n    if (!expression) {\n        throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures the truth of an expression involving one or more parameters to the calling method.\n *\n * <p>See {@link #checkArgument(boolean, String, Object...)} for details.\n *\n * @since 20.0 (varargs overload since 2.0)\n */\n", "repo_name": "guava-master/", "id": 5027, "method_signature": "void checkArgument(boolean, String, Object, Object, Object, Object)", "filename": "Preconditions.checkArgument.json"}
{"callee_method_names": [], "method_name": "Preconditions.checkElementIndex", "method_implementation": "{\n    // Carefully optimized for execution by hotspot (explanatory comment above)\n    if (index < 0 || index >= size) {\n        throw new IndexOutOfBoundsException(badElementIndex(index, size, desc));\n    }\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size\n * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.\n *\n * @param index a user-supplied index identifying an element of an array, list or string\n * @param size the size of that array, list or string\n * @param desc the text to use to describe this index in an error message\n * @return the value of {@code index}\n * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}\n * @throws IllegalArgumentException if {@code size} is negative\n */\n", "repo_name": "guava-master/", "id": 5078, "method_signature": "int checkElementIndex(int, int, String)", "filename": "Preconditions.checkElementIndex.json"}
{"callee_method_names": [], "method_name": "Preconditions.checkNotNull", "method_implementation": "{\n    if (reference == null) {\n        throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n    }\n    return reference;\n}", "repo_id": "5", "comment": "/**\n * Ensures that an object reference passed as a parameter to the calling method is not null.\n *\n * <p>See {@link #checkNotNull(Object, String, Object...)} for details.\n *\n * @since 20.0 (varargs overload since 2.0)\n */\n", "repo_name": "guava-master/", "id": 5077, "method_signature": "T checkNotNull(T, String, Object, Object, Object, Object)", "filename": "Preconditions.checkNotNull.json"}
{"callee_method_names": [], "method_name": "Preconditions.checkPositionIndex", "method_implementation": "{\n    // Carefully optimized for execution by hotspot (explanatory comment above)\n    if (index < 0 || index > size) {\n        throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc));\n    }\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of\n * size {@code size}. A position index may range from zero to {@code size}, inclusive.\n *\n * @param index a user-supplied index identifying a position in an array, list or string\n * @param size the size of that array, list or string\n * @param desc the text to use to describe this index in an error message\n * @return the value of {@code index}\n * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}\n * @throws IllegalArgumentException if {@code size} is negative\n */\n", "repo_name": "guava-master/", "id": 5079, "method_signature": "int checkPositionIndex(int, int, String)", "filename": "Preconditions.checkPositionIndex.json"}
{"callee_method_names": [], "method_name": "Preconditions.checkPositionIndexes", "method_implementation": "{\n    // Carefully optimized for execution by hotspot (explanatory comment above)\n    if (start < 0 || end < start || end > size) {\n        throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures that {@code start} and {@code end} specify valid <i>positions</i> in an array, list or\n * string of size {@code size}, and are in order. A position index may range from zero to {@code\n * size}, inclusive.\n *\n * @param start a user-supplied index identifying a starting position in an array, list or string\n * @param end a user-supplied index identifying an ending position in an array, list or string\n * @param size the size of that array, list or string\n * @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},\n *     or if {@code end} is less than {@code start}\n * @throws IllegalArgumentException if {@code size} is negative\n */\n", "repo_name": "guava-master/", "id": 5080, "method_signature": "void checkPositionIndexes(int, int, int)", "filename": "Preconditions.checkPositionIndexes.json"}
{"callee_method_names": [], "method_name": "Preconditions.checkState", "method_implementation": "{\n    if (!expression) {\n        throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures the truth of an expression involving the state of the calling instance, but not\n * involving any parameters to the calling method.\n *\n * <p>See {@link #checkState(boolean, String, Object...)} for details.\n *\n * @since 20.0 (varargs overload since 2.0)\n */\n", "repo_name": "guava-master/", "id": 5052, "method_signature": "void checkState(boolean, String, Object, Object, Object, Object)", "filename": "Preconditions.checkState.json"}
{"callee_method_names": ["ImmutableSet.Builder<ImmutableList<Class<?>>>.add", "ImmutableSet.Builder<ImmutableList<Class<?>>>.add", "List<List<Class<?>>>.add", "ImmutableSet.Builder<ImmutableList<Class<?>>>.add", "ImmutableSet.Builder<ImmutableList<Class<?>>>.build"], "method_name": "PreconditionsTest.allSignatures", "method_implementation": "{\n    ImmutableSet.Builder<ImmutableList<Class<?>>> allOverloads = ImmutableSet.builder();\n    // The first two are for the overloads that don't take formatting args, e.g.\n    // checkArgument(boolean) and checkArgument(boolean, Object)\n    allOverloads.add(ImmutableList.<Class<?>>of(predicateType));\n    allOverloads.add(ImmutableList.<Class<?>>of(predicateType, Object.class));\n    List<List<Class<?>>> typesLists = new ArrayList<>();\n    for (int i = 0; i < 2; i++) {\n        typesLists.add(possibleParamTypes);\n        for (List<Class<?>> curr : Lists.cartesianProduct(typesLists)) {\n            allOverloads.add(ImmutableList.<Class<?>>builder().add(predicateType).add(// the format string\n            String.class).addAll(curr).build());\n        }\n    }\n    return allOverloads.build().asList();\n}", "repo_id": "5", "comment": "/**\n * Returns a list of parameters for invoking an overload of checkState, checkArgument or\n * checkNotNull\n *\n * @param predicateType The first parameter to the method (boolean or Object)\n */\n", "repo_name": "guava-master/", "id": 3707, "method_signature": "ImmutableList<ImmutableList<Class<?>>> allSignatures(Class)", "filename": "PreconditionsTest.allSignatures.json"}
{"callee_method_names": [], "method_name": "PreconditionsTest.assertFailureCause", "method_implementation": "{\n    assertThat(throwable).isInstanceOf(clazz);\n    if (params.length == 1) {\n        assertThat(throwable).hasMessageThat().isNull();\n    } else if (params.length == 2) {\n        assertThat(throwable).hasMessageThat().isEmpty();\n    } else {\n        assertThat(throwable).hasMessageThat().isEqualTo(Strings.lenientFormat(\"\", Arrays.copyOfRange(params, 2, params.length)));\n    }\n}", "repo_id": "5", "comment": "/**\n * Asserts that the given throwable has the given class and then asserts on the message as using\n * the full set of method parameters.\n */\n", "repo_name": "guava-master/", "id": 3705, "method_signature": "void assertFailureCause(Throwable, Class, Object[])", "filename": "PreconditionsTest.assertFailureCause.json"}
{"callee_method_names": ["ImmutableList<Class<?>>.size", "ImmutableList<Class<?>>.get"], "method_name": "PreconditionsTest.getParametersForSignature", "method_implementation": "{\n    Object[] params = new Object[sig.size()];\n    params[0] = firstParam;\n    if (params.length > 1) {\n        params[1] = \"\";\n        if (params.length > 2) {\n            // fill in the rest of the array with arbitrary instances\n            for (int i = 2; i < params.length; i++) {\n                params[i] = ArbitraryInstances.get(sig.get(i));\n            }\n        }\n    }\n    return params;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing parameters for invoking a checkArgument, checkNotNull or checkState\n * method reflectively\n *\n * @param firstParam The first parameter\n * @param sig The method signature\n */\n", "repo_name": "guava-master/", "id": 3706, "method_signature": "Object[] getParametersForSignature(Object, ImmutableList)", "filename": "PreconditionsTest.getParametersForSignature.json"}
{"callee_method_names": ["Boolean.booleanValue", "Boolean.booleanValue"], "method_name": "PreconditionsTest.overloadSelection", "method_implementation": "{\n    Boolean boxedBoolean = null;\n    boolean aBoolean = true;\n    Long boxedLong = null;\n    int anInt = 1;\n    // With a boxed predicate, no overloads can be selected in phase 1\n    // ambiguous without the call to .booleanValue to unbox the Boolean\n    Preconditions.checkState(boxedBoolean.booleanValue(), \"\", 1);\n    // ambiguous without the cast to Object because the boxed predicate prevents any overload from\n    // being selected in phase 1\n    Preconditions.checkState(boxedBoolean, \"\", (Object) boxedLong);\n    // ternaries introduce their own problems. because of the ternary (which requires a boxing\n    // operation) no overload can be selected in phase 1.  and in phase 2 it is ambiguous since it\n    // matches with the second parameter being boxed and without it being boxed.  The cast to Object\n    // avoids this.\n    Preconditions.checkState(aBoolean, \"\", aBoolean ? \"\" : anInt, (Object) anInt);\n    // ambiguous without the .booleanValue() call since the boxing forces us into phase 2 resolution\n    short s = 2;\n    Preconditions.checkState(boxedBoolean.booleanValue(), \"\", s);\n}", "repo_id": "5", "comment": "// how javac selects overloads\n", "repo_name": "guava-master/", "id": 3708, "method_signature": "void overloadSelection()", "filename": "PreconditionsTest.overloadSelection.json"}
{"callee_method_names": [], "method_name": "Predicates.contains", "method_implementation": "{\n    return new ContainsPatternPredicate(new JdkPattern(pattern));\n}", "repo_id": "5", "comment": "/**\n * Returns a predicate that evaluates to {@code true} if the {@code CharSequence} being tested\n * contains any match for the given regular expression pattern. The test used is equivalent to\n * {@code pattern.matcher(arg).find()}\n *\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 4971, "method_signature": "Predicate<CharSequence> contains(Pattern)", "filename": "Predicates.contains.json"}
{"callee_method_names": [], "method_name": "Predicates.containsPattern", "method_implementation": "{\n    return new ContainsPatternFromStringPredicate(pattern);\n}", "repo_id": "5", "comment": "/**\n * Returns a predicate that evaluates to {@code true} if the {@code CharSequence} being tested\n * contains any match for the given regular expression pattern. The test used is equivalent to\n * {@code Pattern.compile(pattern).matcher(arg).find()}\n *\n * @throws IllegalArgumentException if the pattern is invalid\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 4970, "method_signature": "Predicate<CharSequence> containsPattern(String)", "filename": "Predicates.containsPattern.json"}
{"callee_method_names": [], "method_name": "Predicates.equalTo", "method_implementation": "{\n    return (target == null) ? Predicates.<T>isNull() : new IsEqualToPredicate(target).withNarrowedType();\n}", "repo_id": "5", "comment": "/**\n * Returns a predicate that evaluates to {@code true} if the object being tested {@code equals()}\n * the given target or both are null.\n */\n", "repo_name": "guava-master/", "id": 4968, "method_signature": "Predicate<T> equalTo(T)", "filename": "Predicates.equalTo.json"}
{"callee_method_names": [], "method_name": "Predicates.subtypeOf", "method_implementation": "{\n    return new SubtypeOfPredicate(clazz);\n}", "repo_id": "5", "comment": "/**\n * Returns a predicate that evaluates to {@code true} if the class being tested is assignable to\n * (is a subtype of) {@code clazz}. Example:\n *\n * <pre>{@code\n * List<Class<?>> classes = Arrays.asList(\n *     Object.class, String.class, Number.class, Long.class);\n * return Iterables.filter(classes, subtypeOf(Number.class));\n * }</pre>\n *\n * The code above returns an iterable containing {@code Number.class} and {@code Long.class}.\n *\n * @since 20.0 (since 10.0 under the incorrect name {@code assignableFrom})\n */\n", "repo_name": "guava-master/", "id": 4969, "method_signature": "Predicate<Class<?>> subtypeOf(Class)", "filename": "Predicates.subtypeOf.json"}
{"callee_method_names": ["Predicate<CharSequence>.apply", "Predicate<CharSequence>.apply"], "method_name": "PredicatesTest.testContainsPattern_apply", "method_implementation": "{\n    Predicate<CharSequence> isFoobar = Predicates.containsPattern(\"^Fo.*o.*bar$\");\n    assertTrue(isFoobar.apply(\"Foxyzoabcbar\"));\n    assertFalse(isFoobar.apply(\"Foobarx\"));\n}", "repo_id": "5", "comment": "/**\n * Tests for Predicates.contains(Pattern) and .containsPattern(String). We assume the regex level\n * works, so there are only trivial tests of that aspect. TODO: Fix comment style once annotation\n * stripper is fixed.\n */\n", "repo_name": "guava-master/", "id": 3711, "method_signature": "void testContainsPattern_apply()", "filename": "PredicatesTest.testContainsPattern_apply.json"}
{"callee_method_names": [], "method_name": "PredicatesTest.testIn_compilesWithExplicitSupertype", "method_implementation": "{\n    Collection<Number> nums = ImmutableSet.of();\n    Predicate<Number> p1 = Predicates.in(nums);\n    Predicate<Object> p2 = Predicates.<Object>in(nums);\n    // The next two lines are not expected to compile.\n    // Predicate<Integer> p3 = Predicates.in(nums);\n    // Predicate<Integer> p4 = Predicates.<Integer>in(nums);\n}", "repo_id": "5", "comment": "/*\n   * Tests that compilation will work when applying explicit types.\n   */\n", "repo_name": "guava-master/", "id": 3710, "method_signature": "void testIn_compilesWithExplicitSupertype()", "filename": "PredicatesTest.testIn_compilesWithExplicitSupertype.json"}
{"callee_method_names": ["Predicate<Object>.apply", "Predicate<Object>.apply", "Predicate<Object>.apply", "Predicate<Object>.apply"], "method_name": "PredicatesTest.testIsInstanceOf_apply", "method_implementation": "{\n    Predicate<Object> isInteger = Predicates.instanceOf(Integer.class);\n    assertTrue(isInteger.apply(1));\n    assertFalse(isInteger.apply(2.0f));\n    assertFalse(isInteger.apply(\"\"));\n    assertFalse(isInteger.apply(null));\n}", "repo_id": "5", "comment": "/**\n * Tests for Predicates.instanceOf(x). TODO: Fix the comment style after fixing annotation\n * stripper to remove comments properly. Currently, all tests before the comments are removed as\n * well.\n */\n", "repo_name": "guava-master/", "id": 3709, "method_signature": "void testIsInstanceOf_apply()", "filename": "PredicatesTest.testIsInstanceOf_apply.json"}
{"callee_method_names": ["Map<Class<?>, Class<?>>.get"], "method_name": "Primitives.unwrap", "method_implementation": "{\n    checkNotNull(type);\n    // cast is safe: long.class and Long.class are both of type Class<Long>\n    @SuppressWarnings(\"unchecked\")\n    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(type);\n    return (unwrapped == null) ? type : unwrapped;\n}", "repo_id": "5", "comment": "/**\n * Returns the corresponding primitive type of {@code type} if it is a wrapper type; otherwise\n * returns {@code type} itself. Idempotent.\n *\n * <pre>\n *     unwrap(Integer.class) == int.class\n *     unwrap(int.class) == int.class\n *     unwrap(String.class) == String.class\n * </pre>\n */\n", "repo_name": "guava-master/", "id": 4306, "method_signature": "Class<T> unwrap(Class)", "filename": "Primitives.unwrap.json"}
{"callee_method_names": ["Map<Class<?>, Class<?>>.get"], "method_name": "Primitives.wrap", "method_implementation": "{\n    checkNotNull(type);\n    // cast is safe: long.class and Long.class are both of type Class<Long>\n    @SuppressWarnings(\"unchecked\")\n    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(type);\n    return (wrapped == null) ? type : wrapped;\n}", "repo_id": "5", "comment": "/**\n * Returns the corresponding wrapper type of {@code type} if it is a primitive type; otherwise\n * returns {@code type} itself. Idempotent.\n *\n * <pre>\n *     wrap(int.class) == Integer.class\n *     wrap(Integer.class) == Integer.class\n *     wrap(String.class) == String.class\n * </pre>\n */\n", "repo_name": "guava-master/", "id": 4305, "method_signature": "Class<T> wrap(Class)", "filename": "Primitives.wrap.json"}
{"callee_method_names": [], "method_name": "Quantiles.chooseNextSelection", "method_implementation": "{\n    if (requiredFrom == requiredTo) {\n        // only one thing to choose, so choose it\n        return requiredFrom;\n    }\n    // Find the center and round down. The true center is either centerFloor or halfway between\n    // centerFloor and centerFloor + 1.\n    int centerFloor = (from + to) >>> 1;\n    // Do a binary search until we're down to the range of two which encloses centerFloor (unless\n    // all values are lower or higher than centerFloor, in which case we find the two highest or\n    // lowest respectively). If centerFloor is in allRequired, we will definitely find it. If not,\n    // but centerFloor + 1 is, we'll definitely find that. The closest value to the true (unrounded)\n    // center will be at either low or high.\n    int low = requiredFrom;\n    int high = requiredTo;\n    while (high > low + 1) {\n        int mid = (low + high) >>> 1;\n        if (allRequired[mid] > centerFloor) {\n            high = mid;\n        } else if (allRequired[mid] < centerFloor) {\n            low = mid;\n        } else {\n            // allRequired[mid] = centerFloor, so we can't get closer than that\n            return mid;\n        }\n    }\n    // Now pick the closest of the two candidates. Note that there is no rounding here.\n    if (from + to - allRequired[low] - allRequired[high] > 0) {\n        return high;\n    } else {\n        return low;\n    }\n}", "repo_id": "5", "comment": "/**\n * Chooses the next selection to do from the required selections. It is required that the array\n * {@code allRequired} is sorted and that {@code allRequired[i]} are in the range [{@code from},\n * {@code to}] for all {@code i} in the range [{@code requiredFrom}, {@code requiredTo}]. The\n * value returned by this method is the {@code i} in that range such that {@code allRequired[i]}\n * is as close as possible to the center of the range [{@code from}, {@code to}]. Choosing the\n * value closest to the center of the range first is the most efficient strategy because it\n * minimizes the size of the subranges from which the remaining selections must be done.\n */\n", "repo_name": "guava-master/", "id": 4572, "method_signature": "int chooseNextSelection(int[], int, int, int, int)", "filename": "Quantiles.chooseNextSelection.json"}
{"callee_method_names": ["Map<Integer, Double>.put", "Map<Integer, Double>.put", "Map<Integer, Double>.put"], "method_name": "Quantiles.computeInPlace", "method_implementation": "{\n    checkArgument(dataset.length > 0, \"Cannot calculate quantiles of an empty dataset\");\n    if (containsNaN(dataset)) {\n        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n        for (int index : indexes) {\n            nanMap.put(index, NaN);\n        }\n        return unmodifiableMap(nanMap);\n    }\n    // Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n    // index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n    // remainder, we can just select the value whose index in the sorted dataset equals the\n    // quotient; if there is a remainder, we interpolate between that and the next value.\n    int[] quotients = new int[indexes.length];\n    int[] remainders = new int[indexes.length];\n    // The indexes to select. In the worst case, we'll need one each side of each quantile.\n    int[] requiredSelections = new int[indexes.length * 2];\n    int requiredSelectionsCount = 0;\n    for (int i = 0; i < indexes.length; i++) {\n        // Since index and (dataset.length - 1) are non-negative ints, their product can be\n        // expressed as a long, without risk of overflow:\n        long numerator = (long) indexes[i] * (dataset.length - 1);\n        // Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n        // non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n        // get a rounded ratio and a remainder which can be expressed as ints, without risk of\n        // overflow:\n        int quotient = (int) LongMath.divide(numerator, scale, RoundingMode.DOWN);\n        int remainder = (int) (numerator - (long) quotient * scale);\n        quotients[i] = quotient;\n        remainders[i] = remainder;\n        requiredSelections[requiredSelectionsCount] = quotient;\n        requiredSelectionsCount++;\n        if (remainder != 0) {\n            requiredSelections[requiredSelectionsCount] = quotient + 1;\n            requiredSelectionsCount++;\n        }\n    }\n    sort(requiredSelections, 0, requiredSelectionsCount);\n    selectAllInPlace(requiredSelections, 0, requiredSelectionsCount - 1, dataset, 0, dataset.length - 1);\n    Map<Integer, Double> ret = new LinkedHashMap<>();\n    for (int i = 0; i < indexes.length; i++) {\n        int quotient = quotients[i];\n        int remainder = remainders[i];\n        if (remainder == 0) {\n            ret.put(indexes[i], dataset[quotient]);\n        } else {\n            ret.put(indexes[i], interpolate(dataset[quotient], dataset[quotient + 1], remainder, scale));\n        }\n    }\n    return unmodifiableMap(ret);\n}", "repo_id": "5", "comment": "/**\n * Computes the quantile values of the given dataset, performing the computation in-place.\n *\n * @param dataset the dataset to do the calculation on, which must be non-empty, and which will\n *     be arbitrarily reordered by this method call\n * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n *     map are ordered by quantile index in the same order that the indexes were passed to the\n *     {@code indexes} method.\n */\n", "repo_name": "guava-master/", "id": 4565, "method_signature": "Map<Integer,Double> computeInPlace(double[])", "filename": "Quantiles.computeInPlace.json"}
{"callee_method_names": [], "method_name": "Quantiles.containsNaN", "method_implementation": "{\n    for (double value : dataset) {\n        if (Double.isNaN(value)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns whether any of the values in {@code dataset} are {@code NaN}.\n */\n", "repo_name": "guava-master/", "id": 4566, "method_signature": "boolean containsNaN(double[])", "filename": "Quantiles.containsNaN.json"}
{"callee_method_names": [], "method_name": "Quantiles.interpolate", "method_implementation": "{\n    if (lower == NEGATIVE_INFINITY) {\n        if (upper == POSITIVE_INFINITY) {\n            // Return NaN when lower == NEGATIVE_INFINITY and upper == POSITIVE_INFINITY:\n            return NaN;\n        }\n        // Return NEGATIVE_INFINITY when NEGATIVE_INFINITY == lower <= upper < POSITIVE_INFINITY:\n        return NEGATIVE_INFINITY;\n    }\n    if (upper == POSITIVE_INFINITY) {\n        // Return POSITIVE_INFINITY when NEGATIVE_INFINITY < lower <= upper == POSITIVE_INFINITY:\n        return POSITIVE_INFINITY;\n    }\n    return lower + (upper - lower) * remainder / scale;\n}", "repo_id": "5", "comment": "/**\n * Returns a value a fraction {@code (remainder / scale)} of the way between {@code lower} and\n * {@code upper}. Assumes that {@code lower <= upper}. Correctly handles infinities (but not\n * {@code NaN}).\n */\n", "repo_name": "guava-master/", "id": 4567, "method_signature": "double interpolate(double, double, double, double)", "filename": "Quantiles.interpolate.json"}
{"callee_method_names": [], "method_name": "Quantiles.movePivotToStartOfSlice", "method_implementation": "{\n    int mid = (from + to) >>> 1;\n    // We want to make a swap such that either array[to] <= array[from] <= array[mid], or\n    // array[mid] <= array[from] <= array[to]. We know that from < to, so we know mid < to\n    // (although it's possible that mid == from, if to == from + 1). Note that the postcondition\n    // would be impossible to fulfil if mid == to unless we also have array[from] == array[to].\n    boolean toLessThanMid = (array[to] < array[mid]);\n    boolean midLessThanFrom = (array[mid] < array[from]);\n    boolean toLessThanFrom = (array[to] < array[from]);\n    if (toLessThanMid == midLessThanFrom) {\n        // Either array[to] < array[mid] < array[from] or array[from] <= array[mid] <= array[to].\n        swap(array, mid, from);\n    } else if (toLessThanMid != toLessThanFrom) {\n        // Either array[from] <= array[to] < array[mid] or array[mid] <= array[to] < array[from].\n        swap(array, from, to);\n    }\n    // The postcondition now holds. So the median, our chosen pivot, is at from.\n}", "repo_id": "5", "comment": "/**\n * Selects the pivot to use, namely the median of the values at {@code from}, {@code to}, and\n * halfway between the two (rounded down), from {@code array}, and ensure (by swapping elements if\n * necessary) that that pivot value appears at the start of the slice i.e. at {@code from}.\n * Expects that {@code from} is strictly less than {@code to}.\n */\n", "repo_name": "guava-master/", "id": 4570, "method_signature": "void movePivotToStartOfSlice(double[], int, int)", "filename": "Quantiles.movePivotToStartOfSlice.json"}
{"callee_method_names": [], "method_name": "Quantiles.partition", "method_implementation": "{\n    // Select a pivot, and move it to the start of the slice i.e. to index from.\n    movePivotToStartOfSlice(array, from, to);\n    double pivot = array[from];\n    // Move all elements with indexes in (from, to] which are greater than the pivot to the end of\n    // the array. Keep track of where those elements begin.\n    int partitionPoint = to;\n    for (int i = to; i > from; i--) {\n        if (array[i] > pivot) {\n            swap(array, partitionPoint, i);\n            partitionPoint--;\n        }\n    }\n    // We now know that all elements with indexes in (from, partitionPoint] are less than or equal\n    // to the pivot at from, and all elements with indexes in (partitionPoint, to] are greater than\n    // it. We swap the pivot into partitionPoint and we know the array is partitioned around that.\n    swap(array, from, partitionPoint);\n    return partitionPoint;\n}", "repo_id": "5", "comment": "/**\n * Performs a partition operation on the slice of {@code array} with elements in the range [{@code\n * from}, {@code to}]. Uses the median of {@code from}, {@code to}, and the midpoint between them\n * as a pivot. Returns the index which the slice is partitioned around, i.e. if it returns {@code\n * ret} then we know that the values with indexes in [{@code from}, {@code ret}) are less than or\n * equal to the value at {@code ret} and the values with indexes in ({@code ret}, {@code to}] are\n * greater than or equal to that.\n */\n", "repo_name": "guava-master/", "id": 4569, "method_signature": "int partition(double[], int, int)", "filename": "Quantiles.partition.json"}
{"callee_method_names": [], "method_name": "Quantiles.selectAllInPlace", "method_implementation": "{\n    // Choose the first selection to do...\n    int requiredChosen = chooseNextSelection(allRequired, requiredFrom, requiredTo, from, to);\n    int required = allRequired[requiredChosen];\n    // ...do the first selection...\n    selectInPlace(required, array, from, to);\n    // ...then recursively perform the selections in the range below...\n    int requiredBelow = requiredChosen - 1;\n    while (requiredBelow >= requiredFrom && allRequired[requiredBelow] == required) {\n        // skip duplicates of required in the range below\n        requiredBelow--;\n    }\n    if (requiredBelow >= requiredFrom) {\n        selectAllInPlace(allRequired, requiredFrom, requiredBelow, array, from, required - 1);\n    }\n    // ...and then recursively perform the selections in the range above.\n    int requiredAbove = requiredChosen + 1;\n    while (requiredAbove <= requiredTo && allRequired[requiredAbove] == required) {\n        // skip duplicates of required in the range above\n        requiredAbove++;\n    }\n    if (requiredAbove <= requiredTo) {\n        selectAllInPlace(allRequired, requiredAbove, requiredTo, array, required + 1, to);\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs an in-place selection, like {@link #selectInPlace}, to select all the indexes {@code\n * allRequired[i]} for {@code i} in the range [{@code requiredFrom}, {@code requiredTo}]. These\n * indexes must be sorted in the array and must all be in the range [{@code from}, {@code to}].\n */\n", "repo_name": "guava-master/", "id": 4571, "method_signature": "void selectAllInPlace(int[], int, int, double[], int, int)", "filename": "Quantiles.selectAllInPlace.json"}
{"callee_method_names": [], "method_name": "Quantiles.selectInPlace", "method_implementation": "{\n    // If we are looking for the least element in the range, we can just do a linear search for it.\n    // (We will hit this whenever we are doing quantile interpolation: our first selection finds\n    // the lower value, our second one finds the upper value by looking for the next least element.)\n    if (required == from) {\n        int min = from;\n        for (int index = from + 1; index <= to; index++) {\n            if (array[min] > array[index]) {\n                min = index;\n            }\n        }\n        if (min != from) {\n            swap(array, min, from);\n        }\n        return;\n    }\n    // Let's play quickselect! We'll repeatedly partition the range [from, to] containing the\n    // required element, as long as it has more than one element.\n    while (to > from) {\n        int partitionPoint = partition(array, from, to);\n        if (partitionPoint >= required) {\n            to = partitionPoint - 1;\n        }\n        if (partitionPoint <= required) {\n            from = partitionPoint + 1;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs an in-place selection to find the element which would appear at a given index in a\n * dataset if it were sorted. The following preconditions should hold:\n *\n * <ul>\n *   <li>{@code required}, {@code from}, and {@code to} should all be indexes into {@code array};\n *   <li>{@code required} should be in the range [{@code from}, {@code to}];\n *   <li>all the values with indexes in the range [0, {@code from}) should be less than or equal\n *       to all the values with indexes in the range [{@code from}, {@code to}];\n *   <li>all the values with indexes in the range ({@code to}, {@code array.length - 1}] should be\n *       greater than or equal to all the values with indexes in the range [{@code from}, {@code\n *       to}].\n * </ul>\n *\n * This method will reorder the values with indexes in the range [{@code from}, {@code to}] such\n * that all the values with indexes in the range [{@code from}, {@code required}) are less than or\n * equal to the value with index {@code required}, and all the values with indexes in the range\n * ({@code required}, {@code to}] are greater than or equal to that value. Therefore, the value at\n * {@code required} is the value which would appear at that index in the sorted dataset.\n */\n", "repo_name": "guava-master/", "id": 4568, "method_signature": "void selectInPlace(int, double[], int, int)", "filename": "Quantiles.selectInPlace.json"}
{"callee_method_names": [], "method_name": "Quantiles.swap", "method_implementation": "{\n    double temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}", "repo_id": "5", "comment": "/**\n * Swaps the values at {@code i} and {@code j} in {@code array}.\n */\n", "repo_name": "guava-master/", "id": 4573, "method_signature": "void swap(double[], int, int)", "filename": "Quantiles.swap.json"}
{"callee_method_names": ["Iterable<E>.iterator", "Iterator<? extends T>.hasNext", "Iterator<? extends T>.next", "Iterator<? extends T>.remove"], "method_name": "QueueIterator.foundAndRemovedExactReference", "method_implementation": "{\n    for (Iterator<E> it = elements.iterator(); it.hasNext(); ) {\n        E element = it.next();\n        if (element == target) {\n            it.remove();\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns true if an exact reference (==) was found and removed from the supplied iterable.\n */\n", "repo_name": "guava-master/", "id": 6539, "method_signature": "boolean foundAndRemovedExactReference(Iterable, E)", "filename": "QueueIterator.foundAndRemovedExactReference.json"}
{"callee_method_names": [], "method_name": "QueueIterator.nextNotInSkipMe", "method_implementation": "{\n    if (nextCursor < c) {\n        if (skipMe != null) {\n            while (c < size() && foundAndRemovedExactReference(skipMe, elementData(c))) {\n                c++;\n            }\n        }\n        nextCursor = c;\n    }\n}", "repo_id": "5", "comment": "/**\n * Advances nextCursor to the index of the first element after {@code c} that is not in {@code\n * skipMe} and returns {@code size()} if there is no such element.\n */\n", "repo_name": "guava-master/", "id": 6541, "method_signature": "void nextNotInSkipMe(int)", "filename": "QueueIterator.nextNotInSkipMe.json"}
{"callee_method_names": [], "method_name": "QueueIterator.removeExact", "method_implementation": "{\n    for (int i = 0; i < size; i++) {\n        if (queue[i] == target) {\n            removeAt(i);\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Removes only this exact instance, not others that are equals()\n */\n", "repo_name": "guava-master/", "id": 6540, "method_signature": "boolean removeExact(Object)", "filename": "QueueIterator.removeExact.json"}
{"callee_method_names": [], "method_name": "QueueTestSuiteBuilder.skipCollectionTests", "method_implementation": "{\n    runCollectionTests = false;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specify whether to skip the general collection tests. Call this method when testing a\n * collection that's both a queue and a list, to avoid running the common collection tests twice.\n * By default, collection tests do run.\n */\n", "repo_name": "guava-master/", "id": 4187, "method_signature": "QueueTestSuiteBuilder<E> skipCollectionTests()", "filename": "QueueTestSuiteBuilder.skipCollectionTests.json"}
{"callee_method_names": ["ArrayDeque.poll", "Runnable.run", "LazyLogger.get"], "method_name": "QueueWorker.workOnQueue", "method_implementation": "{\n    boolean interruptedDuringTask = false;\n    boolean hasSetRunning = false;\n    try {\n        while (true) {\n            synchronized (queue) {\n                // Choose whether this thread will run or not after acquiring the lock on the first\n                // iteration\n                if (!hasSetRunning) {\n                    if (workerRunningState == RUNNING) {\n                        // Don't want to have two workers pulling from the queue.\n                        return;\n                    } else {\n                        // Increment the run counter to avoid the ABA problem of a submitter marking the\n                        // thread as QUEUED after it already ran and exhausted the queue before returning\n                        // from execute().\n                        workerRunCount++;\n                        workerRunningState = RUNNING;\n                        hasSetRunning = true;\n                    }\n                }\n                task = queue.poll();\n                if (task == null) {\n                    workerRunningState = IDLE;\n                    return;\n                }\n            }\n            // Remove the interrupt bit before each task. The interrupt is for the \"current task\" when\n            // it is sent, so subsequent tasks in the queue should not be caused to be interrupted\n            // by a previous one in the queue being interrupted.\n            interruptedDuringTask |= Thread.interrupted();\n            try {\n                task.run();\n            } catch (Exception e) {\n                // sneaky checked exception\n                log.get().log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n            } finally {\n                task = null;\n            }\n        }\n    } finally {\n        // Ensure that if the thread was interrupted at all while processing the task queue, it\n        // is returned to the delegate Executor interrupted so that it may handle the\n        // interruption if it likes.\n        if (interruptedDuringTask) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Continues executing tasks from {@link #queue} until it is empty.\n *\n * <p>The thread's interrupt bit is cleared before execution of each task.\n *\n * <p>If the Thread in use is interrupted before or during execution of the tasks in {@link\n * #queue}, the Executor will complete its tasks, and then restore the interruption. This means\n * that once the Thread returns to the Executor that this Executor composes, the interruption\n * will still be present. If the composed Executor is an ExecutorService, it can respond to\n * shutdown() by returning tasks queued on that Thread after {@link #worker} drains the queue.\n */\n", "repo_name": "guava-master/", "id": 5525, "method_signature": "void workOnQueue()", "filename": "QueueWorker.workOnQueue.json"}
{"callee_method_names": ["TimeUnit.toNanos", "BlockingQueue<E>.drainTo", "BlockingQueue<E>.poll", "Collection<? super E>.add"], "method_name": "Queues.drain", "method_implementation": "{\n    Preconditions.checkNotNull(buffer);\n    /*\n     * This code performs one System.nanoTime() more than necessary, and in return, the time to\n     * execute Queue#drainTo is not added *on top* of waiting for the timeout (which could make\n     * the timeout arbitrarily inaccurate, given a queue that is slow to drain).\n     */\n    long deadline = System.nanoTime() + unit.toNanos(timeout);\n    int added = 0;\n    while (added < numElements) {\n        // we could rely solely on #poll, but #drainTo might be more efficient when there are multiple\n        // elements already available (e.g. LinkedBlockingQueue#drainTo locks only once)\n        added += q.drainTo(buffer, numElements - added);\n        if (added < numElements) {\n            // not enough elements immediately available; will have to poll\n            E e = q.poll(deadline - System.nanoTime(), TimeUnit.NANOSECONDS);\n            if (e == null) {\n                // we already waited enough, and there are no more elements in sight\n                break;\n            }\n            buffer.add(e);\n            added++;\n        }\n    }\n    return added;\n}", "repo_id": "5", "comment": "/**\n * Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested {@code\n * numElements} elements are not available, it will wait for them up to the specified timeout.\n *\n * @param q the blocking queue to be drained\n * @param buffer where to add the transferred elements\n * @param numElements the number of elements to be waited for\n * @param timeout how long to wait before giving up, in units of {@code unit}\n * @param unit a {@code TimeUnit} determining how to interpret the timeout parameter\n * @return the number of elements transferred\n * @throws InterruptedException if interrupted while waiting\n */\n", "repo_name": "guava-master/", "id": 6131, "method_signature": "int drain(BlockingQueue, Collection, int, long, TimeUnit)", "filename": "Queues.drain.json"}
{"callee_method_names": ["TimeUnit.toNanos", "BlockingQueue<E>.drainTo", "BlockingQueue<E>.poll", "Collection<? super E>.add"], "method_name": "Queues.drainUninterruptibly", "method_implementation": "{\n    Preconditions.checkNotNull(buffer);\n    long deadline = System.nanoTime() + unit.toNanos(timeout);\n    int added = 0;\n    boolean interrupted = false;\n    try {\n        while (added < numElements) {\n            // we could rely solely on #poll, but #drainTo might be more efficient when there are\n            // multiple elements already available (e.g. LinkedBlockingQueue#drainTo locks only once)\n            added += q.drainTo(buffer, numElements - added);\n            if (added < numElements) {\n                // not enough elements immediately available; will have to poll\n                // written exactly once, by a successful (uninterrupted) invocation of #poll\n                E e;\n                while (true) {\n                    try {\n                        e = q.poll(deadline - System.nanoTime(), TimeUnit.NANOSECONDS);\n                        break;\n                    } catch (InterruptedException ex) {\n                        // note interruption and retry\n                        interrupted = true;\n                    }\n                }\n                if (e == null) {\n                    // we already waited enough, and there are no more elements in sight\n                    break;\n                }\n                buffer.add(e);\n                added++;\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    return added;\n}", "repo_id": "5", "comment": "/**\n * Drains the queue as {@linkplain #drain(BlockingQueue, Collection, int, long, TimeUnit)}, but\n * with a different behavior in case it is interrupted while waiting. In that case, the operation\n * will continue as usual, and in the end the thread's interruption status will be set (no {@code\n * InterruptedException} is thrown).\n *\n * @param q the blocking queue to be drained\n * @param buffer where to add the transferred elements\n * @param numElements the number of elements to be waited for\n * @param timeout how long to wait before giving up, in units of {@code unit}\n * @param unit a {@code TimeUnit} determining how to interpret the timeout parameter\n * @return the number of elements transferred\n */\n", "repo_name": "guava-master/", "id": 6132, "method_signature": "int drainUninterruptibly(BlockingQueue, Collection, int, long, TimeUnit)", "filename": "Queues.drainUninterruptibly.json"}
{"callee_method_names": [], "method_name": "Queues.newArrayBlockingQueue", "method_implementation": "{\n    return new ArrayBlockingQueue<E>(capacity);\n}", "repo_id": "5", "comment": "/**\n * Creates an empty {@code ArrayBlockingQueue} with the given (fixed) capacity and nonfair access\n * policy.\n */\n", "repo_name": "guava-master/", "id": 6117, "method_signature": "ArrayBlockingQueue<E> newArrayBlockingQueue(int)", "filename": "Queues.newArrayBlockingQueue.json"}
{"callee_method_names": [], "method_name": "Queues.newArrayDeque", "method_implementation": "{\n    if (elements instanceof Collection) {\n        return new ArrayDeque<E>((Collection<? extends E>) elements);\n    }\n    ArrayDeque<E> deque = new ArrayDeque<E>();\n    Iterables.addAll(deque, elements);\n    return deque;\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code ArrayDeque} containing the elements of the specified iterable, in the order\n * they are returned by the iterable's iterator.\n *\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 6118, "method_signature": "ArrayDeque<E> newArrayDeque(Iterable)", "filename": "Queues.newArrayDeque.json"}
{"callee_method_names": [], "method_name": "Queues.newConcurrentLinkedQueue", "method_implementation": "{\n    if (elements instanceof Collection) {\n        return new ConcurrentLinkedQueue<E>((Collection<? extends E>) elements);\n    }\n    ConcurrentLinkedQueue<E> queue = new ConcurrentLinkedQueue<E>();\n    Iterables.addAll(queue, elements);\n    return queue;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code ConcurrentLinkedQueue} containing the elements of the specified iterable, in\n * the order they are returned by the iterable's iterator.\n */\n", "repo_name": "guava-master/", "id": 6120, "method_signature": "ConcurrentLinkedQueue<E> newConcurrentLinkedQueue(Iterable)", "filename": "Queues.newConcurrentLinkedQueue.json"}
{"callee_method_names": [], "method_name": "Queues.newLinkedBlockingDeque", "method_implementation": "{\n    if (elements instanceof Collection) {\n        return new LinkedBlockingDeque<E>((Collection<? extends E>) elements);\n    }\n    LinkedBlockingDeque<E> deque = new LinkedBlockingDeque<E>();\n    Iterables.addAll(deque, elements);\n    return deque;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code LinkedBlockingDeque} with a capacity of {@link Integer#MAX_VALUE}, containing\n * the elements of the specified iterable, in the order they are returned by the iterable's\n * iterator.\n *\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 6123, "method_signature": "LinkedBlockingDeque<E> newLinkedBlockingDeque(Iterable)", "filename": "Queues.newLinkedBlockingDeque.json"}
{"callee_method_names": [], "method_name": "Queues.newLinkedBlockingQueue", "method_implementation": "{\n    if (elements instanceof Collection) {\n        return new LinkedBlockingQueue<E>((Collection<? extends E>) elements);\n    }\n    LinkedBlockingQueue<E> queue = new LinkedBlockingQueue<E>();\n    Iterables.addAll(queue, elements);\n    return queue;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE}, containing\n * the elements of the specified iterable, in the order they are returned by the iterable's\n * iterator.\n *\n * @param elements the elements that the queue should contain, in order\n * @return a new {@code LinkedBlockingQueue} containing those elements\n */\n", "repo_name": "guava-master/", "id": 6126, "method_signature": "LinkedBlockingQueue<E> newLinkedBlockingQueue(Iterable)", "filename": "Queues.newLinkedBlockingQueue.json"}
{"callee_method_names": [], "method_name": "Queues.newPriorityBlockingQueue", "method_implementation": "{\n    if (elements instanceof Collection) {\n        return new PriorityBlockingQueue<E>((Collection<? extends E>) elements);\n    }\n    PriorityBlockingQueue<E> queue = new PriorityBlockingQueue<E>();\n    Iterables.addAll(queue, elements);\n    return queue;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code PriorityBlockingQueue} containing the given elements.\n *\n * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},\n * this priority queue will be ordered according to the same ordering.\n *\n * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}\n *     in 15.0)\n */\n", "repo_name": "guava-master/", "id": 6128, "method_signature": "PriorityBlockingQueue<E> newPriorityBlockingQueue(Iterable)", "filename": "Queues.newPriorityBlockingQueue.json"}
{"callee_method_names": [], "method_name": "Queues.newPriorityQueue", "method_implementation": "{\n    if (elements instanceof Collection) {\n        return new PriorityQueue<E>((Collection<? extends E>) elements);\n    }\n    PriorityQueue<E> queue = new PriorityQueue<E>();\n    Iterables.addAll(queue, elements);\n    return queue;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code PriorityQueue} containing the given elements.\n *\n * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},\n * this priority queue will be ordered according to the same ordering.\n *\n * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}\n *     in 15.0)\n */\n", "repo_name": "guava-master/", "id": 6129, "method_signature": "PriorityQueue<E> newPriorityQueue(Iterable)", "filename": "Queues.newPriorityQueue.json"}
{"callee_method_names": [], "method_name": "Queues.newSynchronousQueue", "method_implementation": "{\n    return new SynchronousQueue<E>();\n}", "repo_id": "5", "comment": "/**\n * Creates an empty {@code SynchronousQueue} with nonfair access policy.\n */\n", "repo_name": "guava-master/", "id": 6130, "method_signature": "SynchronousQueue<E> newSynchronousQueue()", "filename": "Queues.newSynchronousQueue.json"}
{"callee_method_names": ["BlockingQueue<Object>.peek"], "method_name": "QueuesTest.assertDrained", "method_implementation": "{\n    assertNull(q.peek());\n    assertInterruptibleDrained(q);\n    assertUninterruptibleDrained(q);\n}", "repo_id": "5", "comment": "/**\n * Checks that #drain() invocations behave correctly for a drained (empty) queue.\n */\n", "repo_name": "guava-master/", "id": 4027, "method_signature": "void assertDrained(BlockingQueue)", "filename": "QueuesTest.assertDrained.json"}
{"callee_method_ids": [1784], "callee_method_names": ["ExecutorService.submit", "Stopwatch.elapsed"], "method_name": "QueuesTest.assertUninterruptibleDrained", "method_implementation": "{\n    assertEquals(0, Queues.drainUninterruptibly(q, ImmutableList.of(), 0, 10, MILLISECONDS));\n    // but does the wait actually occurs?\n    // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n    @SuppressWarnings(\"unused\")\n    Future<?> possiblyIgnoredError = threadPool.submit(new Interrupter(currentThread()));\n    Stopwatch timer = Stopwatch.createStarted();\n    Queues.drainUninterruptibly(q, newArrayList(), 1, 10, MILLISECONDS);\n    assertThat(timer.elapsed(MILLISECONDS)).isAtLeast(10L);\n    // wait for interrupted status and clear it\n    while (!Thread.interrupted()) {\n        Thread.yield();\n    }\n}", "repo_id": "5", "comment": "// same as above; uninterruptible version\n", "repo_name": "guava-master/", "id": 4028, "method_signature": "void assertUninterruptibleDrained(BlockingQueue)", "filename": "QueuesTest.assertUninterruptibleDrained.json"}
{"callee_method_names": [], "method_name": "Range.apply", "method_implementation": "{\n    return contains(input);\n}", "repo_id": "5", "comment": "/**\n * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #contains}\n *     instead.\n */\n", "repo_name": "guava-master/", "id": 6482, "method_signature": "boolean apply(C)", "filename": "Range.apply.json"}
{"callee_method_names": ["Cut<C>.canonical", "Cut<C>.canonical"], "method_name": "Range.canonical", "method_implementation": "{\n    checkNotNull(domain);\n    Cut<C> lower = lowerBound.canonical(domain);\n    Cut<C> upper = upperBound.canonical(domain);\n    return (lower == lowerBound && upper == upperBound) ? this : create(lower, upper);\n}", "repo_id": "5", "comment": "/**\n * Returns the canonical form of this range in the given domain. The canonical form has the\n * following properties:\n *\n * <ul>\n *   <li>equivalence: {@code a.canonical().contains(v) == a.contains(v)} for all {@code v} (in\n *       other words, {@code ContiguousSet.create(a.canonical(domain), domain).equals(\n *       ContiguousSet.create(a, domain))}\n *   <li>uniqueness: unless {@code a.isEmpty()}, {@code ContiguousSet.create(a,\n *       domain).equals(ContiguousSet.create(b, domain))} implies {@code\n *       a.canonical(domain).equals(b.canonical(domain))}\n *   <li>idempotence: {@code a.canonical(domain).canonical(domain).equals(a.canonical(domain))}\n * </ul>\n *\n * <p>Furthermore, this method guarantees that the range returned will be one of the following\n * canonical forms:\n *\n * <ul>\n *   <li>[start..end)\n *   <li>[start..+\u221e)\n *   <li>(-\u221e..end) (only if type {@code C} is unbounded below)\n *   <li>(-\u221e..+\u221e) (only if type {@code C} is unbounded below)\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 6487, "method_signature": "Range<C> canonical(DiscreteDomain)", "filename": "Range.canonical.json"}
{"callee_method_names": ["Cut<C>.isLessThan", "Cut<C>.isLessThan"], "method_name": "Range.contains", "method_implementation": "{\n    checkNotNull(value);\n    // let this throw CCE if there is some trickery going on\n    return lowerBound.isLessThan(value) && !upperBound.isLessThan(value);\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code value} is within the bounds of this range. For example, on the\n * range {@code [0..2)}, {@code contains(1)} returns {@code true}, while {@code contains(2)}\n * returns {@code false}.\n */\n", "repo_name": "guava-master/", "id": 6481, "method_signature": "boolean contains(C)", "filename": "Range.contains.json"}
{"callee_method_names": ["SortedSet<? extends C>.comparator", "SortedSet<? extends C>.first", "SortedSet<? extends C>.last"], "method_name": "Range.containsAll", "method_implementation": "{\n    if (Iterables.isEmpty(values)) {\n        return true;\n    }\n    // this optimizes testing equality of two range-backed sets\n    if (values instanceof SortedSet) {\n        SortedSet<? extends C> set = (SortedSet<? extends C>) values;\n        Comparator<?> comparator = set.comparator();\n        if (Ordering.natural().equals(comparator) || comparator == null) {\n            return contains(set.first()) && contains(set.last());\n        }\n    }\n    for (C value : values) {\n        if (!contains(value)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if every element in {@code values} is {@linkplain #contains contained} in\n * this range.\n */\n", "repo_name": "guava-master/", "id": 6483, "method_signature": "boolean containsAll(Iterable)", "filename": "Range.containsAll.json"}
{"callee_method_names": [], "method_name": "Range.downTo", "method_implementation": "{\n    switch(boundType) {\n        case OPEN:\n            return greaterThan(endpoint);\n        case CLOSED:\n            return atLeast(endpoint);\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a range from the given endpoint, which may be either inclusive (closed) or exclusive\n * (open), with no upper bound.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6479, "method_signature": "Range<C> downTo(C, BoundType)", "filename": "Range.downTo.json"}
{"callee_method_names": ["SortedSet<C>.comparator", "SortedSet<C>.first", "SortedSet<C>.last", "Iterable<C>.iterator", "Iterator<C>.next", "Iterator<C>.hasNext", "Iterator<C>.next"], "method_name": "Range.encloseAll", "method_implementation": "{\n    checkNotNull(values);\n    if (values instanceof SortedSet) {\n        SortedSet<C> set = (SortedSet<C>) values;\n        Comparator<?> comparator = set.comparator();\n        if (Ordering.<C>natural().equals(comparator) || comparator == null) {\n            return closed(set.first(), set.last());\n        }\n    }\n    Iterator<C> valueIterator = values.iterator();\n    C min = checkNotNull(valueIterator.next());\n    C max = min;\n    while (valueIterator.hasNext()) {\n        C value = checkNotNull(valueIterator.next());\n        min = Ordering.<C>natural().min(min, value);\n        max = Ordering.<C>natural().max(max, value);\n    }\n    return closed(min, max);\n}", "repo_id": "5", "comment": "/**\n * Returns the minimal range that {@linkplain Range#contains(Comparable) contains} all of the\n * given values. The returned range is {@linkplain BoundType#CLOSED closed} on both ends.\n *\n * @throws ClassCastException if the values are not mutually comparable\n * @throws NoSuchElementException if {@code values} is empty\n * @throws NullPointerException if any of {@code values} is null\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6480, "method_signature": "Range<C> encloseAll(Iterable)", "filename": "Range.encloseAll.json"}
{"callee_method_names": ["Cut<C>.equals", "Cut<C>.equals"], "method_name": "Range.equals", "method_implementation": "{\n    if (object instanceof Range) {\n        Range<?> other = (Range<?>) object;\n        return lowerBound.equals(other.lowerBound) && upperBound.equals(other.upperBound);\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code object} is a range having the same endpoints and bound types as\n * this range. Note that discrete ranges such as {@code (1..4)} and {@code [2..3]} are <b>not</b>\n * equal to one another, despite the fact that they each contain precisely the same set of values.\n * Similarly, empty ranges are not equal unless they have exactly the same representation, so\n * {@code [3..3)}, {@code (3..3]}, {@code (4..4]} are all unequal.\n */\n", "repo_name": "guava-master/", "id": 6488, "method_signature": "boolean equals(Object)", "filename": "Range.equals.json"}
{"callee_method_names": ["Cut<C>.compareTo", "Range<C>.compareTo"], "method_name": "Range.gap", "method_implementation": "{\n    /*\n     * For an explanation of the basic principle behind this check, see\n     * https://stackoverflow.com/a/35754308/28465\n     *\n     * In that explanation's notation, our `overlap` check would be `x1 < y2 && y1 < x2`. We've\n     * flipped one part of the check so that we're using \"less than\" in both cases (rather than a\n     * mix of \"less than\" and \"greater than\"). We've also switched to \"strictly less than\" rather\n     * than \"less than or equal to\" because of *handwave* the difference between \"endpoints of\n     * inclusive ranges\" and \"Cuts.\"\n     */\n    if (lowerBound.compareTo(otherRange.upperBound) < 0 && otherRange.lowerBound.compareTo(upperBound) < 0) {\n        throw new IllegalArgumentException(\"Ranges have a nonempty intersection: \" + this + \", \" + otherRange);\n    }\n    boolean isThisFirst = this.lowerBound.compareTo(otherRange.lowerBound) < 0;\n    Range<C> firstRange = isThisFirst ? this : otherRange;\n    Range<C> secondRange = isThisFirst ? otherRange : this;\n    return create(firstRange.upperBound, secondRange.lowerBound);\n}", "repo_id": "5", "comment": "/**\n * Returns the maximal range lying between this range and {@code otherRange}, if such a range\n * exists. The resulting range may be empty if the two ranges are adjacent but non-overlapping.\n *\n * <p>For example, the gap of {@code [1..5]} and {@code (7..10)} is {@code (5..7]}. The resulting\n * range may be empty; for example, the gap between {@code [1..5)} {@code [5..7)} yields the empty\n * range {@code [5..5)}.\n *\n * <p>The gap exists if and only if the two ranges are either disconnected or immediately adjacent\n * (any intersection must be an empty range).\n *\n * <p>The gap operation is commutative.\n *\n * @throws IllegalArgumentException if this range and {@code otherRange} have a nonempty\n *     intersection\n * @since 27.0\n */\n", "repo_name": "guava-master/", "id": 6485, "method_signature": "Range<C> gap(Range)", "filename": "Range.gap.json"}
{"callee_method_names": ["Cut<C>.compareTo", "Cut<C>.compareTo", "Cut<C>.compareTo"], "method_name": "Range.intersection", "method_implementation": "{\n    int lowerCmp = lowerBound.compareTo(connectedRange.lowerBound);\n    int upperCmp = upperBound.compareTo(connectedRange.upperBound);\n    if (lowerCmp >= 0 && upperCmp <= 0) {\n        return this;\n    } else if (lowerCmp <= 0 && upperCmp >= 0) {\n        return connectedRange;\n    } else {\n        Cut<C> newLower = (lowerCmp >= 0) ? lowerBound : connectedRange.lowerBound;\n        Cut<C> newUpper = (upperCmp <= 0) ? upperBound : connectedRange.upperBound;\n        // create() would catch this, but give a confusing error message\n        checkArgument(newLower.compareTo(newUpper) <= 0, \"intersection is undefined for disconnected ranges %s and %s\", this, connectedRange);\n        // TODO(kevinb): all the precondition checks in the constructor are redundant...\n        return create(newLower, newUpper);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the maximal range {@linkplain #encloses enclosed} by both this range and {@code\n * connectedRange}, if such a range exists.\n *\n * <p>For example, the intersection of {@code [1..5]} and {@code (3..7)} is {@code (3..5]}. The\n * resulting range may be empty; for example, {@code [1..5)} intersected with {@code [5..7)}\n * yields the empty range {@code [5..5)}.\n *\n * <p>The intersection exists if and only if the two ranges are {@linkplain #isConnected\n * connected}.\n *\n * <p>The intersection operation is commutative, associative and idempotent, and its identity\n * element is {@link Range#all}).\n *\n * @throws IllegalArgumentException if {@code isConnected(connectedRange)} is {@code false}\n */\n", "repo_name": "guava-master/", "id": 6484, "method_signature": "Range<C> intersection(Range)", "filename": "Range.intersection.json"}
{"callee_method_names": [], "method_name": "Range.range", "method_implementation": "{\n    checkNotNull(lowerType);\n    checkNotNull(upperType);\n    Cut<C> lowerBound = (lowerType == BoundType.OPEN) ? Cut.aboveValue(lower) : Cut.belowValue(lower);\n    Cut<C> upperBound = (upperType == BoundType.OPEN) ? Cut.belowValue(upper) : Cut.aboveValue(upper);\n    return create(lowerBound, upperBound);\n}", "repo_id": "5", "comment": "/**\n * Returns a range that contains any value from {@code lower} to {@code upper}, where each\n * endpoint may be either inclusive (closed) or exclusive (open).\n *\n * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}\n * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6477, "method_signature": "Range<C> range(C, BoundType, C, BoundType)", "filename": "Range.range.json"}
{"callee_method_names": ["Cut<C>.compareTo", "Cut<C>.compareTo"], "method_name": "Range.span", "method_implementation": "{\n    int lowerCmp = lowerBound.compareTo(other.lowerBound);\n    int upperCmp = upperBound.compareTo(other.upperBound);\n    if (lowerCmp <= 0 && upperCmp >= 0) {\n        return this;\n    } else if (lowerCmp >= 0 && upperCmp <= 0) {\n        return other;\n    } else {\n        Cut<C> newLower = (lowerCmp <= 0) ? lowerBound : other.lowerBound;\n        Cut<C> newUpper = (upperCmp >= 0) ? upperBound : other.upperBound;\n        return create(newLower, newUpper);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the minimal range that {@linkplain #encloses encloses} both this range and {@code\n * other}. For example, the span of {@code [1..3]} and {@code (5..7)} is {@code [1..7)}.\n *\n * <p><i>If</i> the input ranges are {@linkplain #isConnected connected}, the returned range can\n * also be called their <i>union</i>. If they are not, note that the span might contain values\n * that are not contained in either input range.\n *\n * <p>Like {@link #intersection(Range) intersection}, this operation is commutative, associative\n * and idempotent. Unlike it, it is always well-defined for any two input ranges.\n */\n", "repo_name": "guava-master/", "id": 6486, "method_signature": "Range<C> span(Range)", "filename": "Range.span.json"}
{"callee_method_names": [], "method_name": "Range.upTo", "method_implementation": "{\n    switch(boundType) {\n        case OPEN:\n            return lessThan(endpoint);\n        case CLOSED:\n            return atMost(endpoint);\n        default:\n            throw new AssertionError();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a range with no lower bound up to the given endpoint, which may be either inclusive\n * (closed) or exclusive (open).\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 6478, "method_signature": "Range<C> upTo(C, BoundType)", "filename": "Range.upTo.json"}
{"callee_method_names": [], "method_name": "RangeSet.addAll", "method_implementation": "{\n    for (Range<C> range : ranges) {\n        add(range);\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds all of the specified ranges to this range set (optional operation). After this operation,\n * this range set is the minimal range set that {@linkplain #enclosesAll(RangeSet) encloses} both\n * the original range set and each range in {@code other}.\n *\n * <p>This is equivalent to calling {@link #add} on each of the ranges in {@code other} in turn.\n *\n * @throws UnsupportedOperationException if this range set does not support the {@code addAll}\n *     operation\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 3267, "method_signature": "void addAll(Iterable)", "filename": "RangeSet.addAll.json"}
{"callee_method_names": [], "method_name": "RangeSet.enclosesAll", "method_implementation": "{\n    for (Range<C> range : other) {\n        if (!encloses(range)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if for each range in {@code other} there exists a member range in this\n * range set which {@linkplain Range#encloses encloses} it. Returns {@code true} if {@code other}\n * is empty.\n *\n * <p>This is equivalent to checking if this range set {@link #encloses} each range in {@code\n * other}.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 3266, "method_signature": "boolean enclosesAll(Iterable)", "filename": "RangeSet.enclosesAll.json"}
{"callee_method_names": [], "method_name": "RangeSet.removeAll", "method_implementation": "{\n    for (Range<C> range : ranges) {\n        remove(range);\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes all of the specified ranges from this range set (optional operation).\n *\n * <p>This is equivalent to calling {@link #remove} on each of the ranges in {@code other} in\n * turn.\n *\n * @throws UnsupportedOperationException if this range set does not support the {@code removeAll}\n *     operation\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 3268, "method_signature": "void removeAll(Iterable)", "filename": "RangeSet.removeAll.json"}
{"callee_method_names": ["Stopwatch.sleepMicrosUninterruptibly"], "method_name": "RateLimiter.acquire", "method_implementation": "{\n    long microsToWait = reserve(permits);\n    stopwatch.sleepMicrosUninterruptibly(microsToWait);\n    return 1.0 * microsToWait / SECONDS.toMicros(1L);\n}", "repo_id": "5", "comment": "/**\n * Acquires the given number of permits from this {@code RateLimiter}, blocking until the request\n * can be granted. Tells the amount of time slept, if any.\n *\n * @param permits the number of permits to acquire\n * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited\n * @throws IllegalArgumentException if the requested number of permits is negative or zero\n * @since 16.0 (present in 13.0 with {@code void} return type})\n */\n", "repo_name": "guava-master/", "id": 5282, "method_signature": "double acquire(int)", "filename": "RateLimiter.acquire.json"}
{"callee_method_names": [], "method_name": "RateLimiter.create", "method_implementation": "{\n    checkArgument(warmupPeriod >= 0, \"warmupPeriod must not be negative: %s\", warmupPeriod);\n    return create(permitsPerSecond, warmupPeriod, unit, 3.0, SleepingStopwatch.createFromSystemTimer());\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code RateLimiter} with the specified stable throughput, given as \"permits per\n * second\" (commonly referred to as <i>QPS</i>, queries per second), and a <i>warmup period</i>,\n * during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches its maximum\n * rate at the end of the period (as long as there are enough requests to saturate it). Similarly,\n * if the {@code RateLimiter} is left <i>unused</i> for a duration of {@code warmupPeriod}, it\n * will gradually return to its \"cold\" state, i.e. it will go through the same warming up process\n * as when it was first created.\n *\n * <p>The returned {@code RateLimiter} is intended for cases where the resource that actually\n * fulfills the requests (e.g., a remote server) needs \"warmup\" time, rather than being\n * immediately accessed at the stable (maximum) rate.\n *\n * <p>The returned {@code RateLimiter} starts in a \"cold\" state (i.e. the warmup period will\n * follow), and if it is left unused for long enough, it will return to that state.\n *\n * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many\n *     permits become available per second\n * @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its rate,\n *     before reaching its stable (maximum) rate\n * @param unit the time unit of the warmupPeriod argument\n * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or {@code\n *     warmupPeriod} is negative\n */\n", "repo_name": "guava-master/", "id": 5279, "method_signature": "RateLimiter create(double, long, TimeUnit)", "filename": "RateLimiter.create.json"}
{"callee_method_names": [], "method_name": "RateLimiter.getRate", "method_implementation": "{\n    synchronized (mutex()) {\n        return doGetRate();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the stable rate (as {@code permits per seconds}) with which this {@code RateLimiter} is\n * configured with. The initial value of this is the same as the {@code permitsPerSecond} argument\n * passed in the factory method that produced this {@code RateLimiter}, and it is only updated\n * after invocations to {@linkplain #setRate}.\n */\n", "repo_name": "guava-master/", "id": 5281, "method_signature": "double getRate()", "filename": "RateLimiter.getRate.json"}
{"callee_method_names": ["Stopwatch.readMicros"], "method_name": "RateLimiter.reserve", "method_implementation": "{\n    checkPermits(permits);\n    synchronized (mutex()) {\n        return reserveAndGetWaitLength(permits, stopwatch.readMicros());\n    }\n}", "repo_id": "5", "comment": "/**\n * Reserves the given number of permits from this {@code RateLimiter} for future use, returning\n * the number of microseconds until the reservation can be consumed.\n *\n * @return time in microseconds to wait until the resource can be acquired, never negative\n */\n", "repo_name": "guava-master/", "id": 5283, "method_signature": "long reserve(int)", "filename": "RateLimiter.reserve.json"}
{"callee_method_names": ["Stopwatch.readMicros"], "method_name": "RateLimiter.setRate", "method_implementation": "{\n    checkArgument(permitsPerSecond > 0.0 && !Double.isNaN(permitsPerSecond), \"rate must be positive\");\n    synchronized (mutex()) {\n        doSetRate(permitsPerSecond, stopwatch.readMicros());\n    }\n}", "repo_id": "5", "comment": "/**\n * Updates the stable rate of this {@code RateLimiter}, that is, the {@code permitsPerSecond}\n * argument provided in the factory method that constructed the {@code RateLimiter}. Currently\n * throttled threads will <b>not</b> be awakened as a result of this invocation, thus they do not\n * observe the new rate; only subsequent requests will.\n *\n * <p>Note though that, since each request repays (by waiting, if necessary) the cost of the\n * <i>previous</i> request, this means that the very next request after an invocation to {@code\n * setRate} will not be affected by the new rate; it will pay the cost of the previous request,\n * which is in terms of the previous rate.\n *\n * <p>The behavior of the {@code RateLimiter} is not modified in any other way, e.g. if the {@code\n * RateLimiter} was configured with a warmup period of 20 seconds, it still has a warmup period of\n * 20 seconds after this method invocation.\n *\n * @param permitsPerSecond the new stable rate of this {@code RateLimiter}\n * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero\n */\n", "repo_name": "guava-master/", "id": 5280, "method_signature": "void setRate(double)", "filename": "RateLimiter.setRate.json"}
{"callee_method_names": ["TimeUnit.toMicros", "Stopwatch.readMicros", "Stopwatch.sleepMicrosUninterruptibly"], "method_name": "RateLimiter.tryAcquire", "method_implementation": "{\n    long timeoutMicros = max(unit.toMicros(timeout), 0);\n    checkPermits(permits);\n    long microsToWait;\n    synchronized (mutex()) {\n        long nowMicros = stopwatch.readMicros();\n        if (!canAcquire(nowMicros, timeoutMicros)) {\n            return false;\n        } else {\n            microsToWait = reserveAndGetWaitLength(permits, nowMicros);\n        }\n    }\n    stopwatch.sleepMicrosUninterruptibly(microsToWait);\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained\n * without exceeding the specified {@code timeout}, or returns {@code false} immediately (without\n * waiting) if the permits would not have been granted before the timeout expired.\n *\n * @param permits the number of permits to acquire\n * @param timeout the maximum time to wait for the permits. Negative values are treated as zero.\n * @param unit the time unit of the timeout argument\n * @return {@code true} if the permits were acquired, {@code false} otherwise\n * @throws IllegalArgumentException if the requested number of permits is negative or zero\n */\n", "repo_name": "guava-master/", "id": 5284, "method_signature": "boolean tryAcquire(int, long, TimeUnit)", "filename": "RateLimiter.tryAcquire.json"}
{"callee_method_ids": [5280, 5282], "callee_method_names": ["RateLimiter.setRate", "RateLimiter.acquire"], "method_name": "RateLimiterTest.testInfinity_BustyTimeElapsed", "method_implementation": "{\n    RateLimiter limiter = RateLimiter.create(Double.POSITIVE_INFINITY, stopwatch);\n    stopwatch.instant += 1000000;\n    limiter.setRate(2.0);\n    for (int i = 0; i < 5; i++) {\n        limiter.acquire();\n    }\n    assertEvents(// First comes the saved-up burst, which defaults to a 1-second burst (2 requests).\n    \"R0.00\", // Now comes the free request.\n    \"R0.00\", // Now comes the free request.\n    \"R0.00\", // Now it's 0.5 seconds per request.\n    \"R0.50\", \"R0.50\");\n}", "repo_id": "5", "comment": "/**\n * https://code.google.com/p/guava-libraries/issues/detail?id=1791\n */\n", "repo_name": "guava-master/", "id": 3792, "method_signature": "void testInfinity_BustyTimeElapsed()", "filename": "RateLimiterTest.testInfinity_BustyTimeElapsed.json"}
{"callee_method_names": [], "method_name": "RateLimiterTest.testTimeToWarmUpIsHonouredEvenWithWeights", "method_implementation": "{\n    Random random = new Random();\n    int warmupPermits = 10;\n    double[] coldFactorsToTest = { 2.0, 3.0, 10.0 };\n    double[] qpsToTest = { 4.0, 2.0, 1.0, 0.5, 0.1 };\n    for (int trial = 0; trial < 100; trial++) {\n        for (double coldFactor : coldFactorsToTest) {\n            for (double qps : qpsToTest) {\n                // If warmupPermits = maxPermits - thresholdPermits then\n                // warmupPeriod = (1 + coldFactor) * warmupPermits * stableInterval / 2\n                long warmupMillis = (long) ((1 + coldFactor) * warmupPermits / (2.0 * qps) * 1000.0);\n                RateLimiter rateLimiter = RateLimiter.create(qps, warmupMillis, MILLISECONDS, coldFactor, stopwatch);\n                assertEquals(warmupMillis, measureTotalTimeMillis(rateLimiter, warmupPermits, random));\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * This neat test shows that no matter what weights we use in our requests, if we push X amount of\n * permits in a cool state, where X = rate * timeToCoolDown, and we have specified a\n * timeToWarmUp() period, it will cost as the prescribed amount of time. E.g., calling\n * [acquire(5), acquire(1)] takes exactly the same time as [acquire(2), acquire(3), acquire(1)].\n */\n", "repo_name": "guava-master/", "id": 3794, "method_signature": "void testTimeToWarmUpIsHonouredEvenWithWeights()", "filename": "RateLimiterTest.testTimeToWarmUpIsHonouredEvenWithWeights.json"}
{"callee_method_ids": [5280], "callee_method_names": ["FakeStopwatch.sleepMillis", "RateLimiter.setRate"], "method_name": "RateLimiterTest.testWeNeverGetABurstMoreThanOneSec", "method_implementation": "{\n    RateLimiter limiter = RateLimiter.create(1.0, stopwatch);\n    int[] rates = { 1000, 1, 10, 1000000, 10, 1 };\n    for (int rate : rates) {\n        int oneSecWorthOfWork = rate;\n        stopwatch.sleepMillis(rate * 1000);\n        limiter.setRate(rate);\n        long burst = measureTotalTimeMillis(limiter, oneSecWorthOfWork, new Random());\n        // we allow one second worth of work to go in a burst (i.e. take less than a second)\n        assertTrue(burst <= 1000);\n        long afterBurst = measureTotalTimeMillis(limiter, oneSecWorthOfWork, new Random());\n        // but work beyond that must take at least one second\n        assertTrue(afterBurst >= 1000);\n    }\n}", "repo_id": "5", "comment": "/**\n * Make sure that bursts can never go above 1-second-worth-of-work for the current rate, even when\n * we change the rate.\n */\n", "repo_name": "guava-master/", "id": 3793, "method_signature": "void testWeNeverGetABurstMoreThanOneSec()", "filename": "RateLimiterTest.testWeNeverGetABurstMoreThanOneSec.json"}
{"callee_method_names": ["ByteBuffer.remaining", "ByteBuffer.get"], "method_name": "ReaderInputStream.drain", "method_implementation": "{\n    int remaining = Math.min(len, byteBuffer.remaining());\n    byteBuffer.get(b, off, remaining);\n    return remaining;\n}", "repo_id": "5", "comment": "/**\n * Copy as much of the byte buffer into the output array as possible, returning the (positive)\n * number of characters copied.\n */\n", "repo_name": "guava-master/", "id": 4829, "method_signature": "int drain(byte[], int, int)", "filename": "ReaderInputStream.drain.json"}
{"callee_method_names": ["CharBuffer.array", "CharBuffer.capacity", "CharBuffer.position", "CharBuffer.limit"], "method_name": "ReaderInputStream.grow", "method_implementation": "{\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n    CharBuffer bigger = CharBuffer.wrap(copy);\n    Java8Compatibility.position(bigger, buf.position());\n    Java8Compatibility.limit(bigger, buf.limit());\n    return bigger;\n}", "repo_id": "5", "comment": "/**\n * Returns a new CharBuffer identical to buf, except twice the capacity.\n */\n", "repo_name": "guava-master/", "id": 4826, "method_signature": "CharBuffer grow(CharBuffer)", "filename": "ReaderInputStream.grow.json"}
{"callee_method_names": ["CharsetEncoder.flush", "CharsetEncoder.encode", "CoderResult.isOverflow", "CoderResult.isUnderflow", "CoderResult.isError", "CoderResult.throwException"], "method_name": "ReaderInputStream.read", "method_implementation": "{\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n        return 0;\n    }\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n    DRAINING: while (true) {\n        // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n        // back to encoding/flushing.\n        if (draining) {\n            totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n            if (totalBytesRead == len || doneFlushing) {\n                return (totalBytesRead > 0) ? totalBytesRead : -1;\n            }\n            draining = false;\n            Java8Compatibility.clear(byteBuffer);\n        }\n        while (true) {\n            // We call encode until there is no more input. The last call to encode will have endOfInput\n            // == true. Then there is a final call to flush.\n            CoderResult result;\n            if (doneFlushing) {\n                result = CoderResult.UNDERFLOW;\n            } else if (doneEncoding) {\n                result = encoder.flush(byteBuffer);\n            } else {\n                result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n            }\n            if (result.isOverflow()) {\n                // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n                startDraining(true);\n                continue DRAINING;\n            } else if (result.isUnderflow()) {\n                // If encoder underflows, it means either:\n                // a) the final flush() succeeded; next drain (then done)\n                // b) we encoded all of the input; next flush\n                // c) we ran of out input to encode; next read more input\n                if (doneEncoding) {\n                    // (a)\n                    doneFlushing = true;\n                    startDraining(false);\n                    continue DRAINING;\n                } else if (endOfInput) {\n                    // (b)\n                    doneEncoding = true;\n                } else {\n                    // (c)\n                    readMoreChars();\n                }\n            } else if (result.isError()) {\n                // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n                result.throwException();\n                // Not called.\n                return 0;\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "// buffer when possible.\n", "repo_name": "guava-master/", "id": 4825, "method_signature": "int read(byte[], int, int)", "filename": "ReaderInputStream.read.json"}
{"callee_method_names": ["CharBuffer.position", "CharBuffer.compact", "CharBuffer.limit", "Reader.read", "CharBuffer.array"], "method_name": "ReaderInputStream.readMoreChars", "method_implementation": "{\n    // Possibilities:\n    // 1) array has space available on right-hand side (between limit and capacity)\n    // 2) array has space available on left-hand side (before position)\n    // 3) array has no space available\n    //\n    // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n    // array, then they both become case 1.\n    if (availableCapacity(charBuffer) == 0) {\n        if (charBuffer.position() > 0) {\n            // (2) There is room in the buffer. Move existing bytes to the beginning.\n            Java8Compatibility.flip(charBuffer.compact());\n        } else {\n            // (3) Entire buffer is full, need bigger buffer.\n            charBuffer = grow(charBuffer);\n        }\n    }\n    // (1) Read more characters into free space at end of array.\n    int limit = charBuffer.limit();\n    int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n    if (numChars == -1) {\n        endOfInput = true;\n    } else {\n        Java8Compatibility.limit(charBuffer, limit + numChars);\n    }\n}", "repo_id": "5", "comment": "/**\n * Handle the case of underflow caused by needing more input characters.\n */\n", "repo_name": "guava-master/", "id": 4827, "method_signature": "void readMoreChars()", "filename": "ReaderInputStream.readMoreChars.json"}
{"callee_method_names": ["ByteBuffer.remaining", "ByteBuffer.capacity"], "method_name": "ReaderInputStream.startDraining", "method_implementation": "{\n    Java8Compatibility.flip(byteBuffer);\n    if (overflow && byteBuffer.remaining() == 0) {\n        byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n    } else {\n        draining = true;\n    }\n}", "repo_id": "5", "comment": "/**\n * Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\n * drain because there was overflow, and there aren't actually any characters to drain, then the\n * overflow must be due to a small output buffer.\n */\n", "repo_name": "guava-master/", "id": 4828, "method_signature": "void startDraining(boolean)", "filename": "ReaderInputStream.startDraining.json"}
{"callee_method_names": ["CountDownLatch.getCount", "CountDownLatch.countDown"], "method_name": "RecordingRunnable.run", "method_implementation": "{\n    checkState(wasRun.getCount() > 0);\n    wasRun.countDown();\n}", "repo_id": "5", "comment": "// synchronized so that checkState works as expected.\n", "repo_name": "guava-master/", "id": 3920, "method_signature": "void run()", "filename": "RecordingRunnable.run.json"}
{"callee_method_names": ["Class<?>.getName", "Class<?>.getClassLoader"], "method_name": "Reflection.initialize", "method_implementation": "{\n    for (Class<?> clazz : classes) {\n        try {\n            Class.forName(clazz.getName(), true, clazz.getClassLoader());\n        } catch (ClassNotFoundException e) {\n            throw new AssertionError(e);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures that the given classes are initialized, as described in <a\n * href=\"http://java.sun.com/docs/books/jls/third_edition/html/execution.html#12.4.2\">JLS Section\n * 12.4.2</a>.\n *\n * <p>WARNING: Normally it's a smell if a class needs to be explicitly initialized, because static\n * state hurts system maintainability and testability. In cases when you have no choice while\n * interoperating with a legacy framework, this method helps to keep the code less ugly.\n *\n * @throws ExceptionInInitializerError if an exception is thrown during initialization of a class\n */\n", "repo_name": "guava-master/", "id": 4734, "method_signature": "void initialize(Class<?>[])", "filename": "Reflection.initialize.json"}
{"callee_method_names": ["Class<T>.isInterface", "Class<T>.getClassLoader", "Class<T>.cast"], "method_name": "Reflection.newProxy", "method_implementation": "{\n    checkNotNull(handler);\n    checkArgument(interfaceType.isInterface(), \"%s is not an interface\", interfaceType);\n    Object object = Proxy.newProxyInstance(interfaceType.getClassLoader(), new Class<?>[] { interfaceType }, handler);\n    return interfaceType.cast(object);\n}", "repo_id": "5", "comment": "/**\n * Returns a proxy instance that implements {@code interfaceType} by dispatching method\n * invocations to {@code handler}. The class loader of {@code interfaceType} will be used to\n * define the proxy class. To implement multiple interfaces or specify a class loader, use {@link\n * Proxy#newProxyInstance}.\n *\n * @throws IllegalArgumentException if {@code interfaceType} does not specify the type of a Java\n *     interface\n */\n", "repo_name": "guava-master/", "id": 4735, "method_signature": "T newProxy(Class, InvocationHandler)", "filename": "Reflection.newProxy.json"}
{"callee_method_names": [], "method_name": "RegularContiguousSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6376, "method_signature": "Object writeReplace()", "filename": "RegularContiguousSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularEntrySet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5539, "method_signature": "Object writeReplace()", "filename": "RegularEntrySet.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableAsList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6497, "method_signature": "Object writeReplace()", "filename": "RegularImmutableAsList.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableAsListTest.testDoesntCheckForNull", "method_implementation": "{\n    ImmutableSet<Integer> set = ImmutableSet.of(1, 2, 3);\n    ImmutableList<Integer> unused = new RegularImmutableAsList<Integer>(set, new Object[] { null, null, null });\n    // shouldn't throw!\n}", "repo_id": "5", "comment": "/**\n * RegularImmutableAsList should assume its input is null-free without checking, because it only\n * gets invoked from other immutable collections.\n */\n", "repo_name": "guava-master/", "id": 3978, "method_signature": "void testDoesntCheckForNull()", "filename": "RegularImmutableAsListTest.testDoesntCheckForNull.json"}
{"callee_method_names": ["ImmutableMapEntry<?,?>.getNextInValueBucket", "Object.equals", "ImmutableMapEntry<?,?>.getValue"], "method_name": "RegularImmutableBiMap.checkNoConflictInValueBucket", "method_implementation": "{\n    int bucketSize = 0;\n    for (; valueBucketHead != null; valueBucketHead = valueBucketHead.getNextInValueBucket()) {\n        checkNoConflict(!value.equals(valueBucketHead.getValue()), \"value\", entry, valueBucketHead);\n        if (++bucketSize > MAX_HASH_BUCKET_LENGTH) {\n            throw new BucketOverflowException();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * @throws IllegalArgumentException if another entry in the bucket has the same key\n * @throws BucketOverflowException if this bucket has too many entries, which may indicate a hash\n *     flooding attack\n */\n", "repo_name": "guava-master/", "id": 2692, "method_signature": "void checkNoConflictInValueBucket(Object, Entry, ImmutableMapEntry)", "filename": "RegularImmutableBiMap.checkNoConflictInValueBucket.json"}
{"callee_method_names": [], "method_name": "RegularImmutableBiMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6059, "method_signature": "Object writeReplace()", "filename": "RegularImmutableBiMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableList.get", "method_implementation": "{\n    checkElementIndex(index, size);\n    // requireNonNull is safe because we guarantee that the first `size` elements are non-null.\n    return (E) requireNonNull(array[index]);\n}", "repo_id": "5", "comment": "// The fake cast to E is safe because the creation methods only allow E's\n", "repo_name": "guava-master/", "id": 5644, "method_signature": "E get(int)", "filename": "RegularImmutableList.get.json"}
{"callee_method_names": [], "method_name": "RegularImmutableList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5645, "method_signature": "Object writeReplace()", "filename": "RegularImmutableList.writeReplace.json"}
{"callee_method_names": ["ImmutableMapEntry<K,V>.getNextInKeyBucket", "ImmutableMapEntry<K,V>.getKey"], "method_name": "RegularImmutableMap.checkNoConflictInKeyBucket", "method_implementation": "{\n    int bucketSize = 0;\n    for (; keyBucketHead != null; keyBucketHead = keyBucketHead.getNextInKeyBucket()) {\n        if (keyBucketHead.getKey().equals(key)) {\n            if (throwIfDuplicateKeys) {\n                checkNoConflict(/* safe= */\n                false, \"key\", keyBucketHead, key + \"=\" + newValue);\n            } else {\n                return keyBucketHead;\n            }\n        }\n        if (++bucketSize > MAX_HASH_BUCKET_LENGTH) {\n            throw new BucketOverflowException();\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Checks if the given key already appears in the hash chain starting at {@code keyBucketHead}. If\n * it does not, then null is returned. If it does, then if {@code throwIfDuplicateKeys} is true an\n * {@code IllegalArgumentException} is thrown, and otherwise the existing {@link Entry} is\n * returned.\n *\n * @throws IllegalArgumentException if another entry in the bucket has the same key and {@code\n *     throwIfDuplicateKeys} is true\n * @throws BucketOverflowException if this bucket has too many entries, which may indicate a hash\n *     flooding attack\n */\n", "repo_name": "guava-master/", "id": 2551, "method_signature": "ImmutableMapEntry<K,V> checkNoConflictInKeyBucket(Object, Object, ImmutableMapEntry, boolean)", "filename": "RegularImmutableMap.checkNoConflictInKeyBucket.json"}
{"callee_method_names": ["Builder.DuplicateKey.exception"], "method_name": "RegularImmutableMap.create", "method_implementation": "{\n    if (n == 0) {\n        @SuppressWarnings(\"unchecked\")\n        RegularImmutableMap<K, V> empty = (RegularImmutableMap<K, V>) EMPTY;\n        return empty;\n    } else if (n == 1) {\n        // requireNonNull is safe because the first `2*n` elements have been filled in.\n        checkEntryNotNull(requireNonNull(alternatingKeysAndValues[0]), requireNonNull(alternatingKeysAndValues[1]));\n        return new RegularImmutableMap<K, V>(null, alternatingKeysAndValues, 1);\n    }\n    checkPositionIndex(n, alternatingKeysAndValues.length >> 1);\n    int tableSize = ImmutableSet.chooseTableSize(n);\n    // If there are no duplicate keys, hashTablePlus is the final hashTable value. If there *are*\n    // duplicate keys, hashTablePlus consists of 3 elements: [0] the hashTable; [1] the number of\n    // entries in alternatingKeysAndValues that are still valid after rewriting to remove\n    // duplicates; [2] a Builder.DuplicateKey that records the first duplicate key we encountered\n    // for possible later use in exceptions, perhaps straight away.\n    Object hashTablePlus = createHashTable(alternatingKeysAndValues, n, tableSize, 0);\n    Object hashTable;\n    if (hashTablePlus instanceof Object[]) {\n        Object[] hashTableAndSizeAndDuplicate = (Object[]) hashTablePlus;\n        Builder.DuplicateKey duplicateKey = (Builder.DuplicateKey) hashTableAndSizeAndDuplicate[2];\n        if (builder == null) {\n            throw duplicateKey.exception();\n        }\n        builder.duplicateKey = duplicateKey;\n        hashTable = hashTableAndSizeAndDuplicate[0];\n        n = (Integer) hashTableAndSizeAndDuplicate[1];\n        alternatingKeysAndValues = Arrays.copyOf(alternatingKeysAndValues, n * 2);\n    } else {\n        hashTable = hashTablePlus;\n    }\n    return new RegularImmutableMap<K, V>(hashTable, alternatingKeysAndValues, n);\n}", "repo_id": "5", "comment": "// stored in the builder, which may use it to throw an exception later.\n", "repo_name": "guava-master/", "id": 5921, "method_signature": "RegularImmutableMap<K,V> create(int, Object[], Builder)", "filename": "RegularImmutableMap.create.json"}
{"callee_method_names": ["Object.hashCode", "Object.equals", "Object.hashCode", "Object.equals", "Object.hashCode", "Object.equals"], "method_name": "RegularImmutableMap.createHashTable", "method_implementation": "{\n    if (n == 1) {\n        // for n=1 we don't create a hash table, but we need to do the checkEntryNotNull check!\n        // requireNonNull is safe because the first `2*n` elements have been filled in.\n        checkEntryNotNull(requireNonNull(alternatingKeysAndValues[keyOffset]), requireNonNull(alternatingKeysAndValues[keyOffset ^ 1]));\n        return null;\n    }\n    int mask = tableSize - 1;\n    Builder.DuplicateKey duplicateKey = null;\n    if (tableSize <= BYTE_MAX_SIZE) {\n        /*\n       * Use 8 bits per entry. The value is unsigned to allow use up to a size of 2^8.\n       *\n       * The absent indicator of -1 signed becomes 2^8 - 1 unsigned, which reduces the actual max\n       * size to 2^8 - 1. However, due to a load factor < 1 the limit is never approached.\n       */\n        byte[] hashTable = new byte[tableSize];\n        Arrays.fill(hashTable, ABSENT);\n        int outI = 0;\n        entries: for (int i = 0; i < n; i++) {\n            int keyIndex = 2 * i + keyOffset;\n            int outKeyIndex = 2 * outI + keyOffset;\n            // requireNonNull is safe because the first `2*n` elements have been filled in.\n            Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n            Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n            checkEntryNotNull(key, value);\n            for (int h = Hashing.smear(key.hashCode()); ; h++) {\n                h &= mask;\n                // unsigned read\n                int previousKeyIndex = hashTable[h] & BYTE_MASK;\n                if (previousKeyIndex == BYTE_MASK) {\n                    // -1 signed becomes 255 unsigned\n                    hashTable[h] = (byte) outKeyIndex;\n                    break;\n                } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n                    duplicateKey = new Builder.DuplicateKey(key, value, requireNonNull(alternatingKeysAndValues[previousKeyIndex ^ 1]));\n                    alternatingKeysAndValues[previousKeyIndex ^ 1] = value;\n                    continue entries;\n                }\n            }\n            if (outI < i) {\n                // if outI == i don't bother writing the values back where they came from\n                alternatingKeysAndValues[outKeyIndex] = key;\n                alternatingKeysAndValues[outKeyIndex ^ 1] = value;\n            }\n            outI++;\n        }\n        return outI == n ? hashTable : new Object[] { hashTable, outI, duplicateKey };\n    } else if (tableSize <= SHORT_MAX_SIZE) {\n        /*\n       * Use 16 bits per entry. The value is unsigned to allow use up to a size of 2^16.\n       *\n       * The absent indicator of -1 signed becomes 2^16 - 1 unsigned, which reduces the actual max\n       * size to 2^16 - 1. However, due to a load factor < 1 the limit is never approached.\n       */\n        short[] hashTable = new short[tableSize];\n        Arrays.fill(hashTable, ABSENT);\n        int outI = 0;\n        entries: for (int i = 0; i < n; i++) {\n            int keyIndex = 2 * i + keyOffset;\n            int outKeyIndex = 2 * outI + keyOffset;\n            // requireNonNull is safe because the first `2*n` elements have been filled in.\n            Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n            Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n            checkEntryNotNull(key, value);\n            for (int h = Hashing.smear(key.hashCode()); ; h++) {\n                h &= mask;\n                // unsigned read\n                int previousKeyIndex = hashTable[h] & SHORT_MASK;\n                if (previousKeyIndex == SHORT_MASK) {\n                    // -1 signed becomes 65_535 unsigned\n                    hashTable[h] = (short) outKeyIndex;\n                    break;\n                } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n                    duplicateKey = new Builder.DuplicateKey(key, value, requireNonNull(alternatingKeysAndValues[previousKeyIndex ^ 1]));\n                    alternatingKeysAndValues[previousKeyIndex ^ 1] = value;\n                    continue entries;\n                }\n            }\n            if (outI < i) {\n                // if outI == i don't bother writing the values back where they came from\n                alternatingKeysAndValues[outKeyIndex] = key;\n                alternatingKeysAndValues[outKeyIndex ^ 1] = value;\n            }\n            outI++;\n        }\n        return outI == n ? hashTable : new Object[] { hashTable, outI, duplicateKey };\n    } else {\n        /*\n       * Use 32 bits per entry.\n       */\n        int[] hashTable = new int[tableSize];\n        Arrays.fill(hashTable, ABSENT);\n        int outI = 0;\n        entries: for (int i = 0; i < n; i++) {\n            int keyIndex = 2 * i + keyOffset;\n            int outKeyIndex = 2 * outI + keyOffset;\n            // requireNonNull is safe because the first `2*n` elements have been filled in.\n            Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n            Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n            checkEntryNotNull(key, value);\n            for (int h = Hashing.smear(key.hashCode()); ; h++) {\n                h &= mask;\n                int previousKeyIndex = hashTable[h];\n                if (previousKeyIndex == ABSENT) {\n                    hashTable[h] = outKeyIndex;\n                    break;\n                } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n                    duplicateKey = new Builder.DuplicateKey(key, value, requireNonNull(alternatingKeysAndValues[previousKeyIndex ^ 1]));\n                    alternatingKeysAndValues[previousKeyIndex ^ 1] = value;\n                    continue entries;\n                }\n            }\n            if (outI < i) {\n                // if outI == i don't bother writing the values back where they came from\n                alternatingKeysAndValues[outKeyIndex] = key;\n                alternatingKeysAndValues[outKeyIndex ^ 1] = value;\n            }\n            outI++;\n        }\n        return outI == n ? hashTable : new Object[] { hashTable, outI, duplicateKey };\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a hash table for the specified keys and values, and ensures that neither keys nor\n * values are null. This method may update {@code alternatingKeysAndValues} if there are duplicate\n * keys. If so, the return value will indicate how many entries are still valid, and will also\n * include a {@link Builder.DuplicateKey} in case duplicate keys are not allowed now or will not\n * be allowed on a later {@link Builder#buildOrThrow()} call.\n *\n * @param keyOffset 1 if this is the reverse direction of a BiMap, 0 otherwise.\n * @return an {@code Object} that is a {@code byte[]}, {@code short[]}, or {@code int[]}, the\n *     smallest possible to fit {@code tableSize}; or an {@code Object[]} where [0] is one of\n *     these; [1] indicates how many element pairs in {@code alternatingKeysAndValues} are valid;\n *     and [2] is a {@link Builder.DuplicateKey} for the first duplicate key encountered.\n */\n", "repo_name": "guava-master/", "id": 5922, "method_signature": "Object createHashTable(Object[], int, int, int)", "filename": "RegularImmutableMap.createHashTable.json"}
{"callee_method_names": [], "method_name": "RegularImmutableMap.fromEntryArray", "method_implementation": "{\n    checkPositionIndex(n, entryArray.length);\n    if (n == 0) {\n        // it has no entries so the type variables don't matter\n        @SuppressWarnings(\"unchecked\")\n        ImmutableMap<K, V> empty = (ImmutableMap<K, V>) EMPTY;\n        return empty;\n    }\n    try {\n        return fromEntryArrayCheckingBucketOverflow(n, entryArray, throwIfDuplicateKeys);\n    } catch (BucketOverflowException e) {\n        // probable hash flooding attack, fall back to j.u.HM based implementation and use its\n        // implementation of hash flooding protection\n        return JdkBackedImmutableMap.create(n, entryArray, throwIfDuplicateKeys);\n    }\n}", "repo_id": "5", "comment": "/**\n * Creates an ImmutableMap from the first n entries in entryArray. This implementation may replace\n * the entries in entryArray with its own entry objects (though they will have the same key/value\n * contents), and may take ownership of entryArray.\n */\n", "repo_name": "guava-master/", "id": 2548, "method_signature": "ImmutableMap<K,V> fromEntryArray(int, Entry<K,V>[], boolean)", "filename": "RegularImmutableMap.fromEntryArray.json"}
{"callee_method_names": [], "method_name": "RegularImmutableMap.makeImmutable", "method_implementation": "{\n    boolean reusable = entry instanceof ImmutableMapEntry && ((ImmutableMapEntry<K, V>) entry).isReusable();\n    return reusable ? (ImmutableMapEntry<K, V>) entry : new ImmutableMapEntry<K, V>(key, value);\n}", "repo_id": "5", "comment": "/**\n * Makes an entry usable internally by a new ImmutableMap without rereading its contents.\n */\n", "repo_name": "guava-master/", "id": 2550, "method_signature": "ImmutableMapEntry<K,V> makeImmutable(Entry, K, V)", "filename": "RegularImmutableMap.makeImmutable.json"}
{"callee_method_names": ["IdentityHashMap<Entry<K,V>,Boolean>.get", "IdentityHashMap<Entry<K,V>,Boolean>.put"], "method_name": "RegularImmutableMap.removeDuplicates", "method_implementation": "{\n    Entry<K, V>[] newEntries = createEntryArray(newN);\n    for (int in = 0, out = 0; in < n; in++) {\n        Entry<K, V> entry = entries[in];\n        Boolean status = duplicates.get(entry);\n        // null=>not dup'd; true=>dup'd, first; false=>dup'd, not first\n        if (status != null) {\n            if (status) {\n                duplicates.put(entry, false);\n            } else {\n                // delete this entry; we already copied an earlier one for the same key\n                continue;\n            }\n        }\n        newEntries[out++] = entry;\n    }\n    return newEntries;\n}", "repo_id": "5", "comment": "/**\n * Constructs a new entry array where each duplicated key from the original appears only once, at\n * its first position but with its final value. The {@code duplicates} map is modified.\n *\n * @param entries the original array of entries including duplicates\n * @param n the number of valid entries in {@code entries}\n * @param newN the expected number of entries once duplicates are removed\n * @param duplicates a map of canonical {@link Entry} objects for each duplicate key. This map\n *     will be updated by the method, setting each value to false as soon as the {@link Entry} has\n *     been included in the new entry array.\n * @return an array of {@code newN} entries where no key appears more than once.\n */\n", "repo_name": "guava-master/", "id": 2549, "method_signature": "Entry<K,V>[] removeDuplicates(Entry<K,V>[], int, int, IdentityHashMap)", "filename": "RegularImmutableMap.removeDuplicates.json"}
{"callee_method_names": [], "method_name": "RegularImmutableMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5927, "method_signature": "Object writeReplace()", "filename": "RegularImmutableMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableMultiset.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5932, "method_signature": "Object writeReplace()", "filename": "RegularImmutableMultiset.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6287, "method_signature": "Object writeReplace()", "filename": "RegularImmutableSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableSortedMultiset.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5606, "method_signature": "Object writeReplace()", "filename": "RegularImmutableSortedMultiset.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableSortedSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5747, "method_signature": "Object writeReplace()", "filename": "RegularImmutableSortedSet.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularImmutableTable.checkNoDuplicate", "method_implementation": "{\n    checkArgument(existingValue == null, \"Duplicate key: (row=%s, column=%s), values: [%s, %s].\", rowKey, columnKey, newValue, existingValue);\n}", "repo_id": "5", "comment": "/*\n   * We could have declared this method 'static' but the additional compile-time checks achieved by\n   * referencing the type variables seem worthwhile.\n   */\n", "repo_name": "guava-master/", "id": 6073, "method_signature": "void checkNoDuplicate(R, C, V, V)", "filename": "RegularImmutableTable.checkNoDuplicate.json"}
{"callee_method_names": ["ImmutableList<Cell<R,C,V>>.size", "ImmutableSet<R>.size", "ImmutableSet<C>.size"], "method_name": "RegularImmutableTable.forOrderedComponents", "method_implementation": "{\n    // use a dense table if more than half of the cells have values\n    // TODO(gak): tune this condition based on empirical evidence\n    return (cellList.size() > (((long) rowSpace.size() * columnSpace.size()) / 2)) ? new DenseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace) : new SparseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace);\n}", "repo_id": "5", "comment": "/**\n * A factory that chooses the most space-efficient representation of the table.\n */\n", "repo_name": "guava-master/", "id": 6072, "method_signature": "RegularImmutableTable<R,C,V> forOrderedComponents(ImmutableList, ImmutableSet, ImmutableSet)", "filename": "RegularImmutableTable.forOrderedComponents.json"}
{"callee_method_names": [], "method_name": "RegularImmutableTable.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6071, "method_signature": "Object writeReplace()", "filename": "RegularImmutableTable.writeReplace.json"}
{"callee_method_names": [], "method_name": "RegularSetBuilderImpl.hashFloodingDetected", "method_implementation": "{\n    int maxRunBeforeFallback = maxRunBeforeFallback(hashTable.length);\n    int mask = hashTable.length - 1;\n    // Invariant: all elements at indices in [knownRunStart, knownRunEnd) are nonnull.\n    // If knownRunStart == knownRunEnd, this is vacuously true.\n    // When knownRunEnd exceeds hashTable.length, it \"wraps\", detecting runs around the end\n    // of the table.\n    int knownRunStart = 0;\n    int knownRunEnd = 0;\n    outerLoop: while (knownRunStart < hashTable.length) {\n        if (knownRunStart == knownRunEnd && hashTable[knownRunStart] == null) {\n            if (hashTable[(knownRunStart + maxRunBeforeFallback - 1) & mask] == null) {\n                // There are only maxRunBeforeFallback - 1 elements between here and there,\n                // so even if they were all nonnull, we wouldn't detect a hash flood.  Therefore,\n                // we can skip them all.\n                knownRunStart += maxRunBeforeFallback;\n            } else {\n                // the only case in which maxRunEnd doesn't increase by mRBF\n                knownRunStart++;\n                // happens about f * (1-f) for f = DESIRED_LOAD_FACTOR, so around 21% of the time\n            }\n            knownRunEnd = knownRunStart;\n        } else {\n            for (int j = knownRunStart + maxRunBeforeFallback - 1; j >= knownRunEnd; j--) {\n                if (hashTable[j & mask] == null) {\n                    knownRunEnd = knownRunStart + maxRunBeforeFallback;\n                    knownRunStart = j + 1;\n                    continue outerLoop;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Checks the whole hash table for poor hash distribution. Takes O(n) in the worst case, O(n /\n * log n) on average.\n *\n * <p>The online hash flooding detecting in RegularSetBuilderImpl.add can detect e.g. many\n * exactly matching hash codes, which would cause construction to take O(n^2), but can't detect\n * e.g. hash codes adversarially designed to go into ascending table locations, which keeps\n * construction O(n) (as desired) but then can have O(n) queries later.\n *\n * <p>If this returns false, then no query can take more than O(log n).\n *\n * <p>Note that for a RegularImmutableSet with elements with truly random hash codes, contains\n * operations take expected O(1) time but with high probability take O(log n) for at least some\n * element. (https://en.wikipedia.org/wiki/Linear_probing#Analysis)\n *\n * <p>This method may return {@code true} even on truly random input, but {@code\n * ImmutableSetTest} tests that the probability of that is low.\n */\n", "repo_name": "guava-master/", "id": 3098, "method_signature": "boolean hashFloodingDetected(Object[])", "filename": "RegularSetBuilderImpl.hashFloodingDetected.json"}
{"callee_method_names": ["Object.hashCode"], "method_name": "RegularSetBuilderImpl.rebuildHashTable", "method_implementation": "{\n    @Nullable\n    Object[] hashTable = new @Nullable Object[newTableSize];\n    int mask = hashTable.length - 1;\n    for (int i = 0; i < n; i++) {\n        // requireNonNull is safe because we ensure that the first n elements have been populated.\n        Object e = requireNonNull(elements[i]);\n        int j0 = Hashing.smear(e.hashCode());\n        for (int j = j0; ; j++) {\n            int index = j & mask;\n            if (hashTable[index] == null) {\n                hashTable[index] = e;\n                break;\n            }\n        }\n    }\n    return hashTable;\n}", "repo_id": "5", "comment": "/**\n * Builds a new open-addressed hash table from the first n objects in elements.\n */\n", "repo_name": "guava-master/", "id": 3097, "method_signature": "Object[] rebuildHashTable(int, Object[], int)", "filename": "RegularSetBuilderImpl.rebuildHashTable.json"}
{"callee_method_names": ["List<ImmutableList<T>>.add"], "method_name": "RelationshipTester.addRelatedGroup", "method_implementation": "{\n    groups.add(ImmutableList.copyOf(group));\n    return this;\n}", "repo_id": "5", "comment": "// TODO(cpovirk): should we reject null items, since the tests already check null automatically?\n", "repo_name": "guava-master/", "id": 4139, "method_signature": "RelationshipTester<T> addRelatedGroup(Iterable)", "filename": "RelationshipTester.addRelatedGroup.json"}
{"callee_method_names": ["Executor.execute", "RemovalListener<K,V>.onRemoval"], "method_name": "RemovalListeners.asynchronous", "method_implementation": "{\n    checkNotNull(listener);\n    checkNotNull(executor);\n    return (RemovalNotification<K, V> notification) -> executor.execute(() -> listener.onRemoval(notification));\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code RemovalListener} which processes all eviction notifications using {@code\n * executor}.\n *\n * @param listener the backing listener\n * @param executor the executor with which removal notifications are asynchronously executed\n */\n", "repo_name": "guava-master/", "id": 4867, "method_signature": "RemovalListener<K,V> asynchronous(RemovalListener, Executor)", "filename": "RemovalListeners.asynchronous.json"}
{"callee_method_ids": [5321, 5321], "callee_method_names": ["AbstractService.notifyFailed", "ReentrantLock.lock", "ReentrantLock.unlock", "AbstractService.notifyFailed"], "method_name": "ReschedulableCallable.reschedule", "method_implementation": "{\n    // invoke the callback outside the lock, prevents some shenanigans.\n    Schedule schedule;\n    try {\n        schedule = CustomScheduler.this.getNextSchedule();\n    } catch (Throwable t) {\n        restoreInterruptIfIsInterruptedException(t);\n        service.notifyFailed(t);\n        return new FutureAsCancellable(immediateCancelledFuture());\n    }\n    // We reschedule ourselves with a lock held for two reasons. 1. we want to make sure that\n    // cancel calls cancel on the correct future. 2. we want to make sure that the assignment\n    // to currentFuture doesn't race with itself so that currentFuture is assigned in the\n    // correct order.\n    Throwable scheduleFailure = null;\n    Cancellable toReturn;\n    lock.lock();\n    try {\n        toReturn = initializeOrUpdateCancellationDelegate(schedule);\n    } catch (Throwable e) {\n        // Any Exception is either a RuntimeException or sneaky checked exception.\n        //\n        // If an exception is thrown by the subclass then we need to make sure that the service\n        // notices and transitions to the FAILED state. We do it by calling notifyFailed directly\n        // because the service does not monitor the state of the future so if the exception is not\n        // caught and forwarded to the service the task would stop executing but the service would\n        // have no idea.\n        // TODO(lukes): consider building everything in terms of ListenableScheduledFuture then\n        // the AbstractService could monitor the future directly. Rescheduling is still hard...\n        // but it would help with some of these lock ordering issues.\n        scheduleFailure = e;\n        toReturn = new FutureAsCancellable(immediateCancelledFuture());\n    } finally {\n        lock.unlock();\n    }\n    // Call notifyFailed outside the lock to avoid lock ordering issues.\n    if (scheduleFailure != null) {\n        service.notifyFailed(scheduleFailure);\n    }\n    return toReturn;\n}", "repo_id": "5", "comment": "/**\n * Atomically reschedules this task and assigns the new future to {@link\n * #cancellationDelegate}.\n */\n", "repo_name": "guava-master/", "id": 5342, "method_signature": "Cancellable reschedule()", "filename": "ReschedulableCallable.reschedule.json"}
{"callee_method_names": ["ClassLoader.getResource"], "method_name": "ResourceInfo.url", "method_implementation": "{\n    URL url = loader.getResource(resourceName);\n    if (url == null) {\n        throw new NoSuchElementException(resourceName);\n    }\n    return url;\n}", "repo_id": "5", "comment": "/**\n * Returns the url identifying the resource.\n *\n * <p>See {@link ClassLoader#getResource}\n *\n * @throws NoSuchElementException if the resource cannot be loaded through the class loader,\n *     despite physically existing in the class path.\n */\n", "repo_name": "guava-master/", "id": 4708, "method_signature": "URL url()", "filename": "ResourceInfo.url.json"}
{"callee_method_names": ["Class<?>.getResource", "Class<?>.getName"], "method_name": "Resources.getResource", "method_implementation": "{\n    URL url = contextClass.getResource(resourceName);\n    checkArgument(url != null, \"resource %s relative to %s not found.\", resourceName, contextClass.getName());\n    return url;\n}", "repo_id": "5", "comment": "/**\n * Given a {@code resourceName} that is relative to {@code contextClass}, returns a {@code URL}\n * pointing to the named resource.\n *\n * @throws IllegalArgumentException if the resource is not found\n */\n", "repo_name": "guava-master/", "id": 4748, "method_signature": "URL getResource(Class, String)", "filename": "Resources.getResource.json"}
{"callee_method_names": ["List<String>.add"], "method_name": "Resources.readLines", "method_implementation": "{\n    // don't use asCharSource(url, charset).readLines() because that returns\n    // an immutable list, which would change the behavior of this method\n    return readLines(url, charset, new LineProcessor<List<String>>() {\n\n        final List<String> result = Lists.newArrayList();\n\n        @Override\n        public boolean processLine(String line) {\n            result.add(line);\n            return true;\n        }\n\n        @Override\n        public List<String> getResult() {\n            return result;\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Reads all of the lines from a URL. The lines do not include line-termination characters, but do\n * include other leading and trailing whitespace.\n *\n * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n * Resources.asCharSource(url, charset).readLines()}.\n *\n * @param url the URL to read from\n * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful\n *     predefined constants\n * @return a mutable {@link List} containing all the lines\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "guava-master/", "id": 4746, "method_signature": "List<String> readLines(URL, Charset)", "filename": "Resources.readLines.json"}
{"callee_method_names": [], "method_name": "ReverseImmutableList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5741, "method_signature": "Object writeReplace()", "filename": "ReverseImmutableList.writeReplace.json"}
{"callee_method_names": ["Map<C, V>.isEmpty", "Map<R, Map<C, V>>.remove"], "method_name": "Row.maintainEmptyInvariant", "method_implementation": "{\n    updateBackingRowMapField();\n    if (backingRowMap != null && backingRowMap.isEmpty()) {\n        backingMap.remove(rowKey);\n        backingRowMap = null;\n    }\n}", "repo_id": "5", "comment": "// Call this every time we perform a removal.\n", "repo_name": "guava-master/", "id": 6414, "method_signature": "void maintainEmptyInvariant()", "filename": "Row.maintainEmptyInvariant.json"}
{"callee_method_names": [], "method_name": "Row.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5552, "method_signature": "Object writeReplace()", "filename": "Row.writeReplace.json"}
{"callee_method_names": [], "method_name": "RowMap.get", "method_implementation": "{\n    // requireNonNull is safe because of the containsRow check.\n    return containsRow(key) ? row((R) requireNonNull(key)) : null;\n}", "repo_id": "5", "comment": "// performing cast only when key is in backing map and has the correct type\n", "repo_name": "guava-master/", "id": 6416, "method_signature": "Map<C,V> get(Object)", "filename": "RowMap.get.json"}
{"callee_method_names": [], "method_name": "RowMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5554, "method_signature": "Object writeReplace()", "filename": "RowMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "ScaleAndIndex.computeInPlace", "method_implementation": "{\n    checkArgument(dataset.length > 0, \"Cannot calculate quantiles of an empty dataset\");\n    if (containsNaN(dataset)) {\n        return NaN;\n    }\n    // Calculate the quotient and remainder in the integer division x = k * (N-1) / q, i.e.\n    // index * (dataset.length - 1) / scale. If there is no remainder, we can just find the value\n    // whose index in the sorted dataset equals the quotient; if there is a remainder, we\n    // interpolate between that and the next value.\n    // Since index and (dataset.length - 1) are non-negative ints, their product can be expressed\n    // as a long, without risk of overflow:\n    long numerator = (long) index * (dataset.length - 1);\n    // Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n    // non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to get\n    // a rounded ratio and a remainder which can be expressed as ints, without risk of overflow:\n    int quotient = (int) LongMath.divide(numerator, scale, RoundingMode.DOWN);\n    int remainder = (int) (numerator - (long) quotient * scale);\n    selectInPlace(quotient, dataset, 0, dataset.length - 1);\n    if (remainder == 0) {\n        return dataset[quotient];\n    } else {\n        selectInPlace(quotient + 1, dataset, quotient + 1, dataset.length - 1);\n        return interpolate(dataset[quotient], dataset[quotient + 1], remainder, scale);\n    }\n}", "repo_id": "5", "comment": "/**\n * Computes the quantile value of the given dataset, performing the computation in-place.\n *\n * @param dataset the dataset to do the calculation on, which must be non-empty, and which will\n *     be arbitrarily reordered by this method call\n * @return the quantile value\n */\n", "repo_name": "guava-master/", "id": 4574, "method_signature": "double computeInPlace(double[])", "filename": "ScaleAndIndex.computeInPlace.json"}
{"callee_method_names": ["Map<Integer, Double>.put", "Map<Integer, Double>.put", "Map<Integer, Double>.put"], "method_name": "ScaleAndIndexes.computeInPlace", "method_implementation": "{\n    checkArgument(dataset.length > 0, \"Cannot calculate quantiles of an empty dataset\");\n    if (containsNaN(dataset)) {\n        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n        for (int index : indexes) {\n            nanMap.put(index, NaN);\n        }\n        return unmodifiableMap(nanMap);\n    }\n    // Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n    // index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n    // remainder, we can just select the value whose index in the sorted dataset equals the\n    // quotient; if there is a remainder, we interpolate between that and the next value.\n    int[] quotients = new int[indexes.length];\n    int[] remainders = new int[indexes.length];\n    // The indexes to select. In the worst case, we'll need one each side of each quantile.\n    int[] requiredSelections = new int[indexes.length * 2];\n    int requiredSelectionsCount = 0;\n    for (int i = 0; i < indexes.length; i++) {\n        // Since index and (dataset.length - 1) are non-negative ints, their product can be\n        // expressed as a long, without risk of overflow:\n        long numerator = (long) indexes[i] * (dataset.length - 1);\n        // Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n        // non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n        // get a rounded ratio and a remainder which can be expressed as ints, without risk of\n        // overflow:\n        int quotient = (int) LongMath.divide(numerator, scale, RoundingMode.DOWN);\n        int remainder = (int) (numerator - (long) quotient * scale);\n        quotients[i] = quotient;\n        remainders[i] = remainder;\n        requiredSelections[requiredSelectionsCount] = quotient;\n        requiredSelectionsCount++;\n        if (remainder != 0) {\n            requiredSelections[requiredSelectionsCount] = quotient + 1;\n            requiredSelectionsCount++;\n        }\n    }\n    sort(requiredSelections, 0, requiredSelectionsCount);\n    selectAllInPlace(requiredSelections, 0, requiredSelectionsCount - 1, dataset, 0, dataset.length - 1);\n    Map<Integer, Double> ret = new LinkedHashMap<>();\n    for (int i = 0; i < indexes.length; i++) {\n        int quotient = quotients[i];\n        int remainder = remainders[i];\n        if (remainder == 0) {\n            ret.put(indexes[i], dataset[quotient]);\n        } else {\n            ret.put(indexes[i], interpolate(dataset[quotient], dataset[quotient + 1], remainder, scale));\n        }\n    }\n    return unmodifiableMap(ret);\n}", "repo_id": "5", "comment": "/**\n * Computes the quantile values of the given dataset, performing the computation in-place.\n *\n * @param dataset the dataset to do the calculation on, which must be non-empty, and which will\n *     be arbitrarily reordered by this method call\n * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n *     map are ordered by quantile index in the same order that the indexes were passed to the\n *     {@code indexes} method.\n */\n", "repo_name": "guava-master/", "id": 4575, "method_signature": "Map<Integer,Double> computeInPlace(double[])", "filename": "ScaleAndIndexes.computeInPlace.json"}
{"callee_method_names": ["ScheduledExecutorService.scheduleWithFixedDelay"], "method_name": "Scheduler.newFixedDelaySchedule", "method_implementation": "{\n    checkNotNull(unit);\n    checkArgument(delay > 0, \"delay must be > 0, found %s\", delay);\n    return new Scheduler() {\n\n        @Override\n        public Cancellable schedule(AbstractService service, ScheduledExecutorService executor, Runnable task) {\n            return new FutureAsCancellable(executor.scheduleWithFixedDelay(task, initialDelay, delay, unit));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Scheduler} that schedules the task using the {@link\n * ScheduledExecutorService#scheduleWithFixedDelay} method.\n *\n * @param initialDelay the time to delay first execution\n * @param delay the delay between the termination of one execution and the commencement of the\n *     next\n * @param unit the time unit of the initialDelay and delay parameters\n */\n", "repo_name": "guava-master/", "id": 5339, "method_signature": "Scheduler newFixedDelaySchedule(long, long, TimeUnit)", "filename": "Scheduler.newFixedDelaySchedule.json"}
{"callee_method_names": ["ScheduledExecutorService.scheduleAtFixedRate"], "method_name": "Scheduler.newFixedRateSchedule", "method_implementation": "{\n    checkNotNull(unit);\n    checkArgument(period > 0, \"period must be > 0, found %s\", period);\n    return new Scheduler() {\n\n        @Override\n        public Cancellable schedule(AbstractService service, ScheduledExecutorService executor, Runnable task) {\n            return new FutureAsCancellable(executor.scheduleAtFixedRate(task, initialDelay, period, unit));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Scheduler} that schedules the task using the {@link\n * ScheduledExecutorService#scheduleAtFixedRate} method.\n *\n * @param initialDelay the time to delay first execution\n * @param period the period between successive executions of the task\n * @param unit the time unit of the initialDelay and period parameters\n */\n", "repo_name": "guava-master/", "id": 5340, "method_signature": "Scheduler newFixedRateSchedule(long, long, TimeUnit)", "filename": "Scheduler.newFixedRateSchedule.json"}
{"callee_method_names": ["LocalCache<K, V>.usesKeyReferences", "LocalCache<K, V>.usesValueReferences"], "method_name": "Segment.clearReferenceQueues", "method_implementation": "{\n    if (map.usesKeyReferences()) {\n        clearKeyReferenceQueue();\n    }\n    if (map.usesValueReferences()) {\n        clearValueReferenceQueue();\n    }\n}", "repo_id": "5", "comment": "/**\n * Clears all entries from the key and value reference queues.\n */\n", "repo_name": "guava-master/", "id": 4946, "method_signature": "void clearReferenceQueues()", "filename": "Segment.clearReferenceQueues.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "E.getKey", "E.getHash", "MapMakerInternalMap<K, V, E, S>.equivalent", "AtomicReferenceArray<E>.set"], "method_name": "Segment.clearValueForTesting", "method_implementation": "{\n    lock();\n    try {\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n            K entryKey = e.getKey();\n            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key, entryKey)) {\n                WeakValueReference<K, V, E> v = ((WeakValueEntry<K, V, E>) e).getValueReference();\n                if (v == valueReference) {\n                    E newFirst = removeFromChain(first, e);\n                    table.set(index, newFirst);\n                    return true;\n                }\n                return false;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Clears a value that has not yet been set, and thus does not require count to be modified.\n */\n", "repo_name": "guava-master/", "id": 6279, "method_signature": "boolean clearValueForTesting(K, int, WeakValueReference)", "filename": "Segment.clearValueForTesting.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "MapMakerInternalMap<K, V, E, S>.valueEquivalence"], "method_name": "Segment.containsValue", "method_implementation": "{\n    try {\n        if (count != 0) {\n            // read-volatile\n            AtomicReferenceArray<E> table = this.table;\n            int length = table.length();\n            for (int i = 0; i < length; ++i) {\n                for (E e = table.get(i); e != null; e = e.getNext()) {\n                    V entryValue = getLiveValue(e);\n                    if (entryValue == null) {\n                        continue;\n                    }\n                    if (map.valueEquivalence().equivalent(value, entryValue)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    } finally {\n        postReadCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * This method is a convenience for testing. Code should call {@link\n * MapMakerInternalMap#containsValue} directly.\n */\n", "repo_name": "guava-master/", "id": 6274, "method_signature": "boolean containsValue(Object)", "filename": "Segment.containsValue.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.getKey", "ReferenceEntry<K,V>.getValueReference", "ValueReference<K, V>.get", "ValueReference<K, V>.isActive", "LocalCache<K, V>.copyEntry", "ReferenceEntry<K, V>.setValueReference", "ValueReference<K, V>.copyFor"], "method_name": "Segment.copyEntry", "method_implementation": "{\n    K key = original.getKey();\n    if (key == null) {\n        // key collected\n        return null;\n    }\n    ValueReference<K, V> valueReference = original.getValueReference();\n    V value = valueReference.get();\n    if ((value == null) && valueReference.isActive()) {\n        // value collected\n        return null;\n    }\n    ReferenceEntry<K, V> newEntry = map.entryFactory.copyEntry(this, original, newNext, key);\n    newEntry.setValueReference(valueReference.copyFor(this.valueReferenceQueue, value, newEntry));\n    return newEntry;\n}", "repo_id": "5", "comment": "/**\n * Copies {@code original} into a new entry chained to {@code newNext}. Returns the new entry,\n * or {@code null} if {@code original} was already garbage collected.\n */\n", "repo_name": "guava-master/", "id": 4939, "method_signature": "ReferenceEntry<K,V> copyEntry(ReferenceEntry, ReferenceEntry)", "filename": "Segment.copyEntry.json"}
{"callee_method_names": ["Queue<ReferenceEntry<K, V>>.poll", "Queue<ReferenceEntry<K, V>>.contains", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "Segment.drainRecencyQueue", "method_implementation": "{\n    ReferenceEntry<K, V> e;\n    while ((e = recencyQueue.poll()) != null) {\n        // An entry may be in the recency queue despite it being removed from\n        // the map . This can occur when the entry was concurrently read while a\n        // writer is removing it from the segment or after a clear has removed\n        // all the segment's entries.\n        if (accessQueue.contains(e)) {\n            accessQueue.add(e);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Drains the recency queue, updating eviction metadata that the entries therein were read in\n * the specified relative order. This currently amounts to adding them to relevant eviction\n * lists (accounting for the fact that they could have been removed from the map since being\n * added to the recency queue).\n */\n", "repo_name": "guava-master/", "id": 4950, "method_signature": "void drainRecencyQueue()", "filename": "Segment.drainRecencyQueue.json"}
{"callee_method_names": ["LocalCache<K, V>.usesKeyReferences", "LocalCache<K, V>.usesValueReferences"], "method_name": "Segment.drainReferenceQueues", "method_implementation": "{\n    if (map.usesKeyReferences()) {\n        drainKeyReferenceQueue();\n    }\n    if (map.usesValueReferences()) {\n        drainValueReferenceQueue();\n    }\n}", "repo_id": "5", "comment": "/**\n * Drain the key and value reference queues, cleaning up internal entries containing garbage\n * collected keys or values.\n */\n", "repo_name": "guava-master/", "id": 4945, "method_signature": "void drainReferenceQueues()", "filename": "Segment.drainReferenceQueues.json"}
{"callee_method_names": ["LocalCache<K, V>.evictsBySize", "ReferenceEntry<K,V>.getValueReference", "ReferenceEntry<K,V>.getHash", "ReferenceEntry<K, V>.getHash"], "method_name": "Segment.evictEntries", "method_implementation": "{\n    if (!map.evictsBySize()) {\n        return;\n    }\n    drainRecencyQueue();\n    // If the newest entry by itself is too heavy for the segment, don't bother evicting\n    // anything else, just that\n    if (newest.getValueReference().getWeight() > maxSegmentWeight) {\n        if (!removeEntry(newest, newest.getHash(), RemovalCause.SIZE)) {\n            throw new AssertionError();\n        }\n    }\n    while (totalWeight > maxSegmentWeight) {\n        ReferenceEntry<K, V> e = getNextEvictable();\n        if (!removeEntry(e, e.getHash(), RemovalCause.SIZE)) {\n            throw new AssertionError();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs eviction if the segment is over capacity. Avoids flushing the entire cache if the\n * newest entry exceeds the maximum weight all on its own.\n *\n * @param newest the most recently added entry\n */\n", "repo_name": "guava-master/", "id": 4952, "method_signature": "void evictEntries(ReferenceEntry)", "filename": "Segment.evictEntries.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "E.getHash", "AtomicReferenceArray<E>.set", "E.getNext", "E.getHash", "AtomicReferenceArray<E>.set", "E.getNext", "E.getHash", "AtomicReferenceArray<E>.get", "AtomicReferenceArray<E>.set"], "method_name": "Segment.expand", "method_implementation": "{\n    AtomicReferenceArray<E> oldTable = table;\n    int oldCapacity = oldTable.length();\n    if (oldCapacity >= MAXIMUM_CAPACITY) {\n        return;\n    }\n    /*\n       * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the\n       * elements from each bin must either stay at same index, or move with a power of two offset.\n       * We eliminate unnecessary node creation by catching cases where old nodes can be reused\n       * because their next fields won't change. Statistically, at the default threshold, only\n       * about one-sixth of them need cloning when a table doubles. The nodes they replace will be\n       * garbage collectable as soon as they are no longer referenced by any reader thread that may\n       * be in the midst of traversing table right now.\n       */\n    int newCount = count;\n    AtomicReferenceArray<E> newTable = newEntryArray(oldCapacity << 1);\n    threshold = newTable.length() * 3 / 4;\n    int newMask = newTable.length() - 1;\n    for (int oldIndex = 0; oldIndex < oldCapacity; ++oldIndex) {\n        // We need to guarantee that any existing reads of old Map can\n        // proceed. So we cannot yet null out each bin.\n        E head = oldTable.get(oldIndex);\n        if (head != null) {\n            E next = head.getNext();\n            int headIndex = head.getHash() & newMask;\n            // Single node on list\n            if (next == null) {\n                newTable.set(headIndex, head);\n            } else {\n                // Reuse the consecutive sequence of nodes with the same target\n                // index from the end of the list. tail points to the first\n                // entry in the reusable list.\n                E tail = head;\n                int tailIndex = headIndex;\n                for (E e = next; e != null; e = e.getNext()) {\n                    int newIndex = e.getHash() & newMask;\n                    if (newIndex != tailIndex) {\n                        // The index changed. We'll need to copy the previous entry.\n                        tailIndex = newIndex;\n                        tail = e;\n                    }\n                }\n                newTable.set(tailIndex, tail);\n                // Clone nodes leading up to the tail.\n                for (E e = head; e != tail; e = e.getNext()) {\n                    int newIndex = e.getHash() & newMask;\n                    E newNext = newTable.get(newIndex);\n                    E newFirst = copyEntry(e, newNext);\n                    if (newFirst != null) {\n                        newTable.set(newIndex, newFirst);\n                    } else {\n                        newCount--;\n                    }\n                }\n            }\n        }\n    }\n    table = newTable;\n    this.count = newCount;\n}", "repo_id": "5", "comment": "/**\n * Expands the table if possible.\n */\n", "repo_name": "guava-master/", "id": 6275, "method_signature": "void expand()", "filename": "Segment.expand.json"}
{"callee_method_names": ["StatsCounter.recordLoadSuccess", "LoadingValueReference<K,V>.elapsedNanos", "StatsCounter.recordLoadException", "LoadingValueReference<K,V>.elapsedNanos"], "method_name": "Segment.getAndRecordStats", "method_implementation": "{\n    V value = null;\n    try {\n        value = getUninterruptibly(newValue);\n        if (value == null) {\n            throw new InvalidCacheLoadException(\"CacheLoader returned null for key \" + key + \".\");\n        }\n        statsCounter.recordLoadSuccess(loadingValueReference.elapsedNanos());\n        storeLoadedValue(key, hash, loadingValueReference, value);\n        return value;\n    } finally {\n        if (value == null) {\n            statsCounter.recordLoadException(loadingValueReference.elapsedNanos());\n            removeLoadingValue(key, hash, loadingValueReference);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Waits uninterruptibly for {@code newValue} to be loaded, and then records loading stats.\n */\n", "repo_name": "guava-master/", "id": 4941, "method_signature": "V getAndRecordStats(K, int, LoadingValueReference, ListenableFuture)", "filename": "Segment.getAndRecordStats.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.get", "AtomicReferenceArray<E>.length"], "method_name": "Segment.getFirst", "method_implementation": "{\n    // read this volatile field only once\n    AtomicReferenceArray<E> table = this.table;\n    return table.get(hash & (table.length() - 1));\n}", "repo_id": "5", "comment": "/**\n * Returns first entry of bin for given hash.\n */\n", "repo_name": "guava-master/", "id": 6273, "method_signature": "E getFirst(int)", "filename": "Segment.getFirst.json"}
{"callee_method_names": ["E.getKey", "E.getValue"], "method_name": "Segment.getLiveValue", "method_implementation": "{\n    if (entry.getKey() == null) {\n        tryDrainReferenceQueues();\n        return null;\n    }\n    V value = entry.getValue();\n    if (value == null) {\n        tryDrainReferenceQueues();\n        return null;\n    }\n    return value;\n}", "repo_id": "5", "comment": "/**\n * Gets the value from an entry. Returns {@code null} if the entry is invalid or\n * partially-collected.\n */\n", "repo_name": "guava-master/", "id": 6280, "method_signature": "V getLiveValue(E)", "filename": "Segment.getLiveValue.json"}
{"callee_method_names": ["ReferenceEntry<K, V>.getValueReference"], "method_name": "Segment.getNextEvictable", "method_implementation": "{\n    for (ReferenceEntry<K, V> e : accessQueue) {\n        int weight = e.getValueReference().getWeight();\n        if (weight > 0) {\n            return e;\n        }\n    }\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "// TODO(fry): instead implement this with an eviction head\n", "repo_name": "guava-master/", "id": 4953, "method_signature": "ReferenceEntry<K,V> getNextEvictable()", "filename": "Segment.getNextEvictable.json"}
{"callee_method_names": ["LocalCache<K, V>.read", "AtomicReferenceArray<ReferenceEntry<K, V>>.length", "AtomicReferenceArray<ReferenceEntry<K, V>>.get", "ReferenceEntry<K, V>.getNext", "ReferenceEntry<K, V>.getKey", "ReferenceEntry<K, V>.getHash", "LocalCache<K, V>.equivalent", "ReferenceEntry<K, V>.getValueReference", "ValueReference<K, V>.isLoading", "ReferenceEntry<K, V>.getWriteTime", "ReferenceEntry<K, V>.setValueReference", "ReferenceEntry<K, V>.setValueReference", "AtomicReferenceArray<ReferenceEntry<K, V>>.set"], "method_name": "Segment.insertLoadingValueReference", "method_implementation": "{\n    ReferenceEntry<K, V> e = null;\n    lock();\n    try {\n        long now = map.ticker.read();\n        preWriteCleanup(now);\n        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n        int index = hash & (table.length() - 1);\n        ReferenceEntry<K, V> first = table.get(index);\n        // Look for an existing entry.\n        for (e = first; e != null; e = e.getNext()) {\n            K entryKey = e.getKey();\n            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key, entryKey)) {\n                // We found an existing entry.\n                ValueReference<K, V> valueReference = e.getValueReference();\n                if (valueReference.isLoading() || (checkTime && (now - e.getWriteTime() < map.refreshNanos))) {\n                    // refresh is a no-op if loading is pending\n                    // if checkTime, we want to check *after* acquiring the lock if refresh still needs\n                    // to be scheduled\n                    return null;\n                }\n                // continue returning old value while loading\n                ++modCount;\n                LoadingValueReference<K, V> loadingValueReference = new LoadingValueReference<>(valueReference);\n                e.setValueReference(loadingValueReference);\n                return loadingValueReference;\n            }\n        }\n        ++modCount;\n        LoadingValueReference<K, V> loadingValueReference = new LoadingValueReference<>();\n        e = newEntry(key, hash, first);\n        e.setValueReference(loadingValueReference);\n        table.set(index, e);\n        return loadingValueReference;\n    } finally {\n        unlock();\n        postWriteCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a newly inserted {@code LoadingValueReference}, or null if the live value reference\n * is already loading.\n */\n", "repo_name": "guava-master/", "id": 4943, "method_signature": "LoadingValueReference<K,V> insertLoadingValueReference(K, int, boolean)", "filename": "Segment.insertLoadingValueReference.json"}
{"callee_method_names": ["AtomicInteger.incrementAndGet"], "method_name": "Segment.postReadCleanup", "method_implementation": "{\n    if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {\n        runCleanup();\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs routine cleanup following a read. Normally cleanup happens during writes, or from\n * the cleanupExecutor. If cleanup is not observed after a sufficient number of reads, try\n * cleaning up from the read thread.\n */\n", "repo_name": "guava-master/", "id": 6281, "method_signature": "void postReadCleanup()", "filename": "Segment.postReadCleanup.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "AtomicReferenceArray<E>.set"], "method_name": "Segment.reclaimKey", "method_implementation": "{\n    lock();\n    try {\n        int newCount = count - 1;\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n            if (e == entry) {\n                ++modCount;\n                E newFirst = removeFromChain(first, e);\n                newCount = this.count - 1;\n                table.set(index, newFirst);\n                // write-volatile\n                this.count = newCount;\n                return true;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes an entry whose key has been garbage collected.\n */\n", "repo_name": "guava-master/", "id": 6277, "method_signature": "boolean reclaimKey(E, int)", "filename": "Segment.reclaimKey.json"}
{"callee_method_names": ["AtomicReferenceArray<E>.length", "AtomicReferenceArray<E>.get", "E.getNext", "E.getKey", "E.getHash", "MapMakerInternalMap<K, V, E, S>.equivalent", "AtomicReferenceArray<E>.set"], "method_name": "Segment.reclaimValue", "method_implementation": "{\n    lock();\n    try {\n        int newCount = this.count - 1;\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n            K entryKey = e.getKey();\n            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key, entryKey)) {\n                WeakValueReference<K, V, E> v = ((WeakValueEntry<K, V, E>) e).getValueReference();\n                if (v == valueReference) {\n                    ++modCount;\n                    E newFirst = removeFromChain(first, e);\n                    newCount = this.count - 1;\n                    table.set(index, newFirst);\n                    // write-volatile\n                    this.count = newCount;\n                    return true;\n                }\n                return false;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n    }\n}", "repo_id": "5", "comment": "/**\n * Removes an entry whose value has been garbage collected.\n */\n", "repo_name": "guava-master/", "id": 6278, "method_signature": "boolean reclaimValue(K, int, WeakValueReference)", "filename": "Segment.reclaimValue.json"}
{"callee_method_names": ["LocalCache<K, V>.recordsAccess", "ReferenceEntry<K,V>.setAccessTime", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "Segment.recordLockedRead", "method_implementation": "{\n    if (map.recordsAccess()) {\n        entry.setAccessTime(now);\n    }\n    accessQueue.add(entry);\n}", "repo_id": "5", "comment": "/**\n * Updates the eviction metadata that {@code entry} was just read. This currently amounts to\n * adding {@code entry} to relevant eviction lists.\n *\n * <p>Note: this method should only be called under lock, as it directly manipulates the\n * eviction queues. Unlocked reads should use {@link #recordRead}.\n */\n", "repo_name": "guava-master/", "id": 4948, "method_signature": "void recordLockedRead(ReferenceEntry, long)", "filename": "Segment.recordLockedRead.json"}
{"callee_method_names": ["LocalCache<K, V>.recordsAccess", "ReferenceEntry<K,V>.setAccessTime", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "Segment.recordRead", "method_implementation": "{\n    if (map.recordsAccess()) {\n        entry.setAccessTime(now);\n    }\n    recencyQueue.add(entry);\n}", "repo_id": "5", "comment": "/**\n * Records the relative order in which this read was performed by adding {@code entry} to the\n * recency queue. At write-time, or when the queue is full past the threshold, the queue will be\n * drained and the entries therein processed.\n *\n * <p>Note: locked reads should use {@link #recordLockedRead}.\n */\n", "repo_name": "guava-master/", "id": 4947, "method_signature": "void recordRead(ReferenceEntry, long)", "filename": "Segment.recordRead.json"}
{"callee_method_names": ["LocalCache<K, V>.recordsAccess", "ReferenceEntry<K,V>.setAccessTime", "LocalCache<K, V>.recordsWrite", "ReferenceEntry<K,V>.setWriteTime", "Queue<ReferenceEntry<K, V>>.add", "Queue<ReferenceEntry<K, V>>.add"], "method_name": "Segment.recordWrite", "method_implementation": "{\n    // we are already under lock, so drain the recency queue immediately\n    drainRecencyQueue();\n    totalWeight += weight;\n    if (map.recordsAccess()) {\n        entry.setAccessTime(now);\n    }\n    if (map.recordsWrite()) {\n        entry.setWriteTime(now);\n    }\n    accessQueue.add(entry);\n    writeQueue.add(entry);\n}", "repo_id": "5", "comment": "/**\n * Updates eviction metadata that {@code entry} was just written. This currently amounts to\n * adding {@code entry} to relevant eviction lists.\n */\n", "repo_name": "guava-master/", "id": 4949, "method_signature": "void recordWrite(ReferenceEntry, int, long)", "filename": "Segment.recordWrite.json"}
{"callee_method_names": ["ListenableFuture<V>.isDone"], "method_name": "Segment.refresh", "method_implementation": "{\n    final LoadingValueReference<K, V> loadingValueReference = insertLoadingValueReference(key, hash, checkTime);\n    if (loadingValueReference == null) {\n        return null;\n    }\n    ListenableFuture<V> result = loadAsync(key, hash, loadingValueReference, loader);\n    if (result.isDone()) {\n        try {\n            return Uninterruptibles.getUninterruptibly(result);\n        } catch (Throwable t) {\n            // don't let refresh exceptions propagate; error was already logged\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Refreshes the value associated with {@code key}, unless another thread is already doing so.\n * Returns the newly refreshed value associated with {@code key} if it was refreshed inline, or\n * {@code null} if another thread is performing the refresh or if an error occurs during\n * refresh.\n */\n", "repo_name": "guava-master/", "id": 4942, "method_signature": "V refresh(K, int, CacheLoader, boolean)", "filename": "Segment.refresh.json"}
{"callee_method_names": ["E.getNext", "E.getNext"], "method_name": "Segment.removeFromChain", "method_implementation": "{\n    int newCount = count;\n    E newFirst = entry.getNext();\n    for (E e = first; e != entry; e = e.getNext()) {\n        E next = copyEntry(e, newFirst);\n        if (next != null) {\n            newFirst = next;\n        } else {\n            newCount--;\n        }\n    }\n    this.count = newCount;\n    return newFirst;\n}", "repo_id": "5", "comment": "/**\n * Removes an entry from within a table. All entries following the removed node can stay, but\n * all preceding ones need to be cloned.\n *\n * <p>This method does not decrement count for the removed entry, but does decrement count for\n * all partially collected entries which are skipped. As such callers which are modifying count\n * must re-read it after calling removeFromChain.\n *\n * @param first the first entry of the table\n * @param entry the entry being removed from the table\n * @return the new first entry for the table\n */\n", "repo_name": "guava-master/", "id": 6276, "method_signature": "E removeFromChain(E, E)", "filename": "Segment.removeFromChain.json"}
{"callee_method_names": ["ReferenceEntry<K,V>.getValueReference", "LocalCache<K, V>.weigh", "LocalCache<K, V>.referenceValue", "ReferenceEntry<K,V>.setValueReference", "ValueReference<K, V>.notifyNewValue"], "method_name": "Segment.setValue", "method_implementation": "{\n    ValueReference<K, V> previous = entry.getValueReference();\n    int weight = map.weigher.weigh(key, value);\n    checkState(weight >= 0, \"Weights must be non-negative\");\n    ValueReference<K, V> valueReference = map.valueStrength.referenceValue(this, entry, value, weight);\n    entry.setValueReference(valueReference);\n    recordWrite(entry, weight, now);\n    previous.notifyNewValue(value);\n}", "repo_id": "5", "comment": "/**\n * Sets a new value of an entry. Adds newly created entries at the end of the access queue.\n */\n", "repo_name": "guava-master/", "id": 4940, "method_signature": "void setValue(ReferenceEntry, K, V, long)", "filename": "Segment.setValue.json"}
{"callee_method_names": [], "method_name": "Segment.setWeakValueReferenceForTesting", "method_implementation": "{\n    throw new AssertionError();\n}", "repo_id": "5", "comment": "/**\n * Unsafely sets the weak value reference inside the given {@code entry} to be the given {@code\n * valueReference}\n */\n", "repo_name": "guava-master/", "id": 6271, "method_signature": "void setWeakValueReferenceForTesting(InternalEntry, WeakValueReference)", "filename": "Segment.setWeakValueReferenceForTesting.json"}
{"callee_method_names": [], "method_name": "Segment.tryDrainReferenceQueues", "method_implementation": "{\n    if (tryLock()) {\n        try {\n            maybeDrainReferenceQueues();\n        } finally {\n            unlock();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Cleanup collected entries when the lock is available.\n */\n", "repo_name": "guava-master/", "id": 6272, "method_signature": "void tryDrainReferenceQueues()", "filename": "Segment.tryDrainReferenceQueues.json"}
{"callee_method_names": [], "method_name": "Segment.tryExpireEntries", "method_implementation": "{\n    if (tryLock()) {\n        try {\n            expireEntries(now);\n        } finally {\n            unlock();\n            // don't call postWriteCleanup as we're in a read\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Cleanup expired entries when the lock is available.\n */\n", "repo_name": "guava-master/", "id": 4951, "method_signature": "void tryExpireEntries(long)", "filename": "Segment.tryExpireEntries.json"}
{"callee_method_names": ["ArrayDeque.add", "Runnable.run", "Runnable.toString", "ArrayDeque.add", "Executor.execute", "ArrayDeque.removeLastOccurrence"], "method_name": "SequentialExecutor.execute", "method_implementation": "{\n    checkNotNull(task);\n    Runnable submittedTask;\n    long oldRunCount;\n    synchronized (queue) {\n        // If the worker is already running (or execute() on the delegate returned successfully, and\n        // the worker has yet to start) then we don't need to start the worker.\n        if (workerRunningState == RUNNING || workerRunningState == QUEUED) {\n            queue.add(task);\n            return;\n        }\n        oldRunCount = workerRunCount;\n        // If the worker is not yet running, the delegate Executor might reject our attempt to start\n        // it. To preserve FIFO order and failure atomicity of rejected execution when the same\n        // Runnable is executed more than once, allocate a wrapper that we know is safe to remove by\n        // object identity.\n        // A data structure that returned a removal handle from add() would allow eliminating this\n        // allocation.\n        submittedTask = new Runnable() {\n\n            @Override\n            public void run() {\n                task.run();\n            }\n\n            @Override\n            public String toString() {\n                return task.toString();\n            }\n        };\n        queue.add(submittedTask);\n        workerRunningState = QUEUING;\n    }\n    try {\n        executor.execute(worker);\n    } catch (Throwable t) {\n        // Any Exception is either a RuntimeException or sneaky checked exception.\n        synchronized (queue) {\n            boolean removed = (workerRunningState == IDLE || workerRunningState == QUEUING) && queue.removeLastOccurrence(submittedTask);\n            // If the delegate is directExecutor(), the submitted runnable could have thrown a REE. But\n            // that's handled by the log check that catches RuntimeExceptions in the queue worker.\n            if (!(t instanceof RejectedExecutionException) || removed) {\n                throw t;\n            }\n        }\n        return;\n    }\n    /*\n     * This is an unsynchronized read! After the read, the function returns immediately or acquires\n     * the lock to check again. Since an IDLE state was observed inside the preceding synchronized\n     * block, and reference field assignment is atomic, this may save reacquiring the lock when\n     * another thread or the worker task has cleared the count and set the state.\n     *\n     * <p>When {@link #executor} is a directExecutor(), the value written to\n     * {@code workerRunningState} will be available synchronously, and behaviour will be\n     * deterministic.\n     */\n    @SuppressWarnings(\"GuardedBy\")\n    boolean alreadyMarkedQueued = workerRunningState != QUEUING;\n    if (alreadyMarkedQueued) {\n        return;\n    }\n    synchronized (queue) {\n        if (workerRunCount == oldRunCount && workerRunningState == QUEUING) {\n            workerRunningState = QUEUED;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds a task to the queue and makes sure a worker thread is running.\n *\n * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n * execution of tasks will stop until a call to this method is made.\n */\n", "repo_name": "guava-master/", "id": 5523, "method_signature": "void execute(Runnable)", "filename": "SequentialExecutor.execute.json"}
{"callee_method_names": ["ArrayDeque.poll", "Runnable.run", "LazyLogger.get"], "method_name": "SequentialExecutor.workOnQueue", "method_implementation": "{\n    boolean interruptedDuringTask = false;\n    boolean hasSetRunning = false;\n    try {\n        while (true) {\n            synchronized (queue) {\n                // Choose whether this thread will run or not after acquiring the lock on the first\n                // iteration\n                if (!hasSetRunning) {\n                    if (workerRunningState == RUNNING) {\n                        // Don't want to have two workers pulling from the queue.\n                        return;\n                    } else {\n                        // Increment the run counter to avoid the ABA problem of a submitter marking the\n                        // thread as QUEUED after it already ran and exhausted the queue before returning\n                        // from execute().\n                        workerRunCount++;\n                        workerRunningState = RUNNING;\n                        hasSetRunning = true;\n                    }\n                }\n                task = queue.poll();\n                if (task == null) {\n                    workerRunningState = IDLE;\n                    return;\n                }\n            }\n            // Remove the interrupt bit before each task. The interrupt is for the \"current task\" when\n            // it is sent, so subsequent tasks in the queue should not be caused to be interrupted\n            // by a previous one in the queue being interrupted.\n            interruptedDuringTask |= Thread.interrupted();\n            try {\n                task.run();\n            } catch (Exception e) {\n                // sneaky checked exception\n                log.get().log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n            } finally {\n                task = null;\n            }\n        }\n    } finally {\n        // Ensure that if the thread was interrupted at all while processing the task queue, it\n        // is returned to the delegate Executor interrupted so that it may handle the\n        // interruption if it likes.\n        if (interruptedDuringTask) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Continues executing tasks from {@link #queue} until it is empty.\n *\n * <p>The thread's interrupt bit is cleared before execution of each task.\n *\n * <p>If the Thread in use is interrupted before or during execution of the tasks in {@link\n * #queue}, the Executor will complete its tasks, and then restore the interruption. This means\n * that once the Thread returns to the Executor that this Executor composes, the interruption\n * will still be present. If the composed Executor is an ExecutorService, it can respond to\n * shutdown() by returning tasks queued on that Thread after {@link #worker} drains the queue.\n */\n", "repo_name": "guava-master/", "id": 5524, "method_signature": "void workOnQueue()", "filename": "SequentialExecutor.workOnQueue.json"}
{"callee_method_ids": [5523, 5523], "callee_method_names": ["CyclicBarrier.await", "SequentialExecutor.execute", "ExecutorService.execute", "CyclicBarrier.await", "SequentialExecutor.execute", "CyclicBarrier.await", "ExecutorService.shutdown"], "method_name": "SequentialExecutorTest.testTaskThrowsError", "method_implementation": "{\n    class MyError extends Error {\n    }\n    final CyclicBarrier barrier = new CyclicBarrier(2);\n    // we need to make sure the error gets thrown on a different thread.\n    ExecutorService service = Executors.newSingleThreadExecutor();\n    try {\n        final SequentialExecutor executor = new SequentialExecutor(service);\n        Runnable errorTask = new Runnable() {\n\n            @Override\n            public void run() {\n                throw new MyError();\n            }\n        };\n        Runnable barrierTask = new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    barrier.await();\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n        executor.execute(errorTask);\n        // submit directly to the service\n        service.execute(barrierTask);\n        // the barrier task runs after the error task so we know that the error has been observed by\n        // SequentialExecutor by the time the barrier is satisfied\n        barrier.await(1, TimeUnit.SECONDS);\n        executor.execute(barrierTask);\n        // timeout means the second task wasn't even tried\n        barrier.await(1, TimeUnit.SECONDS);\n    } finally {\n        service.shutdown();\n    }\n}", "repo_id": "5", "comment": "/*\n   * Under Android, MyError propagates up and fails the test?\n   *\n   * TODO(b/218700094): Does this matter to prod users, or is it just a feature of our testing\n   * environment? If the latter, maybe write a custom Executor that avoids failing the test when it\n   * sees an Error?\n   */\n", "repo_name": "guava-master/", "id": 3875, "method_signature": "void testTaskThrowsError()", "filename": "SequentialExecutorTest.testTaskThrowsError.json"}
{"callee_method_names": ["T.getClass", "T.getClass"], "method_name": "SerializableTester.reserializeAndAssert", "method_implementation": "{\n    T copy = reserialize(object);\n    new EqualsTester().addEqualityGroup(object, copy).testEquals();\n    Assert.assertEquals(object.getClass(), copy.getClass());\n    return copy;\n}", "repo_id": "5", "comment": "/**\n * Serializes and deserializes the specified object and verifies that the re-serialized object is\n * equal to the provided object, that the hashcodes are identical, and that the class of the\n * re-serialized object is identical to that of the original.\n *\n * <p><b>GWT warning:</b> Under GWT, this method simply returns its input, as proper GWT\n * serialization tests require more setup. This no-op behavior allows test authors to intersperse\n * {@code SerializableTester} calls with other, GWT-compatible tests.\n *\n * <p>Note that the specified object may not be known by the compiler to be a {@link\n * java.io.Serializable} instance, and is thus declared an {@code Object}. For example, it might\n * be declared as a {@code List}.\n *\n * <p>Note also that serialization is not in general required to return an object that is\n * {@linkplain Object#equals equal} to the original, nor is it required to return even an object\n * of the same class. For example, if sublists of {@code MyList} instances were serializable,\n * those sublists might implement a private {@code MySubList} type but serialize as a plain {@code\n * MyList} to save space. So long as {@code MyList} has all the public supertypes of {@code\n * MySubList}, this is safe. For these cases, for which {@code reserializeAndAssert} is too\n * strict, use {@link #reserialize}.\n *\n * @return the re-serialized object\n * @throws RuntimeException if the specified object was not successfully serialized or\n *     deserialized\n * @throws AssertionFailedError if the re-serialized object is not equal to the original object,\n *     or if the hashcodes are different.\n */\n", "repo_name": "guava-master/", "id": 4086, "method_signature": "T reserializeAndAssert(T)", "filename": "SerializableTester.reserializeAndAssert.json"}
{"callee_method_names": ["Class<T>.getDeclaredField"], "method_name": "Serialization.getFieldSetter", "method_implementation": "{\n    try {\n        Field field = clazz.getDeclaredField(fieldName);\n        return new FieldSetter<>(field);\n    } catch (NoSuchFieldException e) {\n        // programmer error\n        throw new AssertionError(e);\n    }\n}", "repo_id": "5", "comment": "// Secret sauce for setting final fields; don't make it public.\n", "repo_name": "guava-master/", "id": 5537, "method_signature": "FieldSetter<T> getFieldSetter(Class, String)", "filename": "Serialization.getFieldSetter.json"}
{"callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "Map<K,V>.put"], "method_name": "Serialization.populateMap", "method_implementation": "{\n    for (int i = 0; i < size; i++) {\n        // reading data stored by writeMap\n        @SuppressWarnings(\"unchecked\")\n        K key = (K) stream.readObject();\n        // reading data stored by writeMap\n        @SuppressWarnings(\"unchecked\")\n        V value = (V) stream.readObject();\n        map.put(key, value);\n    }\n}", "repo_id": "5", "comment": "/**\n * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}\n * for the data format. The size is determined by a prior call to {@link #readCount}.\n */\n", "repo_name": "guava-master/", "id": 5530, "method_signature": "void populateMap(Map, ObjectInputStream, int)", "filename": "Serialization.populateMap.json"}
{"callee_method_names": ["ObjectInputStream.readObject", "Multimap<K,V>.get", "ObjectInputStream.readInt", "ObjectInputStream.readObject", "Collection<V>.add"], "method_name": "Serialization.populateMultimap", "method_implementation": "{\n    for (int i = 0; i < distinctKeys; i++) {\n        // reading data stored by writeMultimap\n        @SuppressWarnings(\"unchecked\")\n        K key = (K) stream.readObject();\n        Collection<V> values = multimap.get(key);\n        int valueCount = stream.readInt();\n        for (int j = 0; j < valueCount; j++) {\n            // reading data stored by writeMultimap\n            @SuppressWarnings(\"unchecked\")\n            V value = (V) stream.readObject();\n            values.add(value);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Populates a multimap by reading an input stream, as part of deserialization. See {@link\n * #writeMultimap} for the data format. The number of distinct keys is determined by a prior call\n * to {@link #readCount}.\n */\n", "repo_name": "guava-master/", "id": 5536, "method_signature": "void populateMultimap(Multimap, ObjectInputStream, int)", "filename": "Serialization.populateMultimap.json"}
{"callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readInt", "Multiset<E>.add"], "method_name": "Serialization.populateMultiset", "method_implementation": "{\n    for (int i = 0; i < distinctElements; i++) {\n        // reading data stored by writeMultiset\n        @SuppressWarnings(\"unchecked\")\n        E element = (E) stream.readObject();\n        int count = stream.readInt();\n        multiset.add(element, count);\n    }\n}", "repo_id": "5", "comment": "/**\n * Populates a multiset by reading an input stream, as part of deserialization. See {@link\n * #writeMultiset} for the data format. The number of distinct elements is determined by a prior\n * call to {@link #readCount}.\n */\n", "repo_name": "guava-master/", "id": 5533, "method_signature": "void populateMultiset(Multiset, ObjectInputStream, int)", "filename": "Serialization.populateMultiset.json"}
{"callee_method_names": ["ObjectOutputStream.writeInt", "Map<K,V>.size", "Map<K,V>.entrySet", "ObjectOutputStream.writeObject", "Entry<K, AtomicLong>.getKey", "ObjectOutputStream.writeObject", "Entry<K, AtomicLong>.getValue"], "method_name": "Serialization.writeMap", "method_implementation": "{\n    stream.writeInt(map.size());\n    for (Map.Entry<K, V> entry : map.entrySet()) {\n        stream.writeObject(entry.getKey());\n        stream.writeObject(entry.getValue());\n    }\n}", "repo_id": "5", "comment": "/**\n * Stores the contents of a map in an output stream, as part of serialization. It does not support\n * concurrent maps whose content may change while the method is running.\n *\n * <p>The serialized output consists of the number of entries, first key, first value, second key,\n * second value, and so on.\n */\n", "repo_name": "guava-master/", "id": 5528, "method_signature": "void writeMap(Map, ObjectOutputStream)", "filename": "Serialization.writeMap.json"}
{"callee_method_names": ["ObjectOutputStream.writeInt", "Multimap<K,V>.asMap", "Multimap<K,V>.asMap", "ObjectOutputStream.writeObject", "Entry<K, AtomicLong>.getKey", "ObjectOutputStream.writeInt", "Entry<K, AtomicLong>.getValue", "Entry<K, AtomicLong>.getValue", "ObjectOutputStream.writeObject"], "method_name": "Serialization.writeMultimap", "method_implementation": "{\n    stream.writeInt(multimap.asMap().size());\n    for (Map.Entry<K, Collection<V>> entry : multimap.asMap().entrySet()) {\n        stream.writeObject(entry.getKey());\n        stream.writeInt(entry.getValue().size());\n        for (V value : entry.getValue()) {\n            stream.writeObject(value);\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Stores the contents of a multimap in an output stream, as part of serialization. It does not\n * support concurrent multimaps whose content may change while the method is running. The {@link\n * Multimap#asMap} view determines the ordering in which data is written to the stream.\n *\n * <p>The serialized output consists of the number of distinct keys, and then for each distinct\n * key: the key, the number of values for that key, and the key's values.\n */\n", "repo_name": "guava-master/", "id": 5534, "method_signature": "void writeMultimap(Multimap, ObjectOutputStream)", "filename": "Serialization.writeMultimap.json"}
{"callee_method_names": ["Multiset<E>.entrySet", "ObjectOutputStream.writeInt", "Multiset<E>.entrySet", "ObjectOutputStream.writeObject", "Entry<K, AtomicLong>.getElement", "ObjectOutputStream.writeInt", "Entry<K, AtomicLong>.getCount"], "method_name": "Serialization.writeMultiset", "method_implementation": "{\n    int entryCount = multiset.entrySet().size();\n    stream.writeInt(entryCount);\n    for (Multiset.Entry<E> entry : multiset.entrySet()) {\n        stream.writeObject(entry.getElement());\n        stream.writeInt(entry.getCount());\n    }\n}", "repo_id": "5", "comment": "/**\n * Stores the contents of a multiset in an output stream, as part of serialization. It does not\n * support concurrent multisets whose content may change while the method is running.\n *\n * <p>The serialized output consists of the number of distinct elements, the first element, its\n * count, the second element, its count, and so on.\n */\n", "repo_name": "guava-master/", "id": 5531, "method_signature": "void writeMultiset(Multiset, ObjectOutputStream)", "filename": "Serialization.writeMultiset.json"}
{"callee_method_ids": [5521], "callee_method_names": ["Monitor.isOccupiedByCurrentThread", "ListenerCallQueue.dispatch"], "method_name": "ServiceManager.dispatchListenerEvents", "method_implementation": "{\n    checkState(!monitor.isOccupiedByCurrentThread(), \"It is incorrect to execute listeners with the monitor held.\");\n    listeners.dispatch();\n}", "repo_id": "5", "comment": "/**\n * Attempts to execute all the listeners in {@link #listeners}.\n */\n", "repo_name": "guava-master/", "id": 5349, "method_signature": "void dispatchListenerEvents()", "filename": "ServiceManager.dispatchListenerEvents.json"}
{"callee_method_names": ["Service.isRunning"], "method_name": "ServiceManager.isHealthy", "method_implementation": "{\n    for (Service service : services) {\n        if (!service.isRunning()) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n *\n * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n * get detailed information about which services are not running.\n */\n", "repo_name": "guava-master/", "id": 5345, "method_signature": "boolean isHealthy()", "filename": "ServiceManager.isHealthy.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Service.state", "List<Service>.add", "Monitor.leave"], "method_name": "ServiceManager.markReady", "method_implementation": "{\n    monitor.enter();\n    try {\n        if (!transitioned) {\n            // nothing has transitioned since construction, good.\n            ready = true;\n        } else {\n            // This should be an extremely rare race condition.\n            List<Service> servicesInBadStates = Lists.newArrayList();\n            for (Service service : servicesByState().values()) {\n                if (service.state() != NEW) {\n                    servicesInBadStates.add(service);\n                }\n            }\n            throw new IllegalArgumentException(\"Services started transitioning asynchronously before \" + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n * been observed yet.\n */\n", "repo_name": "guava-master/", "id": 5347, "method_signature": "void markReady()", "filename": "ServiceManager.markReady.json"}
{"callee_method_names": ["Service.state", "WeakReference<ServiceManagerState>.tryStartTiming", "Service.startAsync", "LazyLogger.get"], "method_name": "ServiceManager.startAsync", "method_implementation": "{\n    for (Service service : services) {\n        checkState(service.state() == NEW, \"Not all services are NEW, cannot start %s\", this);\n    }\n    for (Service service : services) {\n        try {\n            state.tryStartTiming(service);\n            service.startAsync();\n        } catch (IllegalStateException e) {\n            // This can happen if the service has already been started or stopped (e.g. by another\n            // service or listener). Our contract says it is safe to call this method if\n            // all services were NEW when it was called, and this has already been verified above, so we\n            // don't propagate the exception.\n            logger.get().log(Level.WARNING, \"Unable to start Service \" + service, e);\n        }\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Initiates service {@linkplain Service#startAsync startup} on all the services being managed. It\n * is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n *\n * @return this\n * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n *     method is called.\n */\n", "repo_name": "guava-master/", "id": 5343, "method_signature": "ServiceManager startAsync()", "filename": "ServiceManager.startAsync.json"}
{"callee_method_names": [], "method_name": "ServiceManager.startupDurations", "method_implementation": "{\n    return ImmutableMap.copyOf(Maps.<Service, Long, Duration>transformValues(startupTimes(), Duration::ofMillis));\n}", "repo_id": "5", "comment": "/**\n * Returns the service load times. This value will only return startup times for services that\n * have finished starting.\n *\n * @return Map of services and their corresponding startup time, the map entries will be ordered\n *     by startup time.\n * @since 31.0\n */\n", "repo_name": "guava-master/", "id": 1940, "method_signature": "ImmutableMap<Service,Duration> startupDurations()", "filename": "ServiceManager.startupDurations.json"}
{"callee_method_names": ["Service.stopAsync"], "method_name": "ServiceManager.stopAsync", "method_implementation": "{\n    for (Service service : services) {\n        service.stopAsync();\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n * being managed.\n *\n * @return this\n */\n", "repo_name": "guava-master/", "id": 5344, "method_signature": "ServiceManager stopAsync()", "filename": "ServiceManager.stopAsync.json"}
{"callee_method_ids": [5431, 5188, 5445], "callee_method_names": ["Monitor.enter", "SetMultimap<State, Service>.remove", "SetMultimap<State, Service>.put", "Map<Service, Stopwatch>.get", "Map<Service, Stopwatch>.put", "State.compareTo", "Stopwatch.isRunning", "Stopwatch.stop", "LazyLogger.get", "Multiset<State>.count", "Multiset<State>.count", "Multiset<State>.count", "Monitor.leave"], "method_name": "ServiceManager.transitionService", "method_implementation": "{\n    checkNotNull(service);\n    checkArgument(from != to);\n    monitor.enter();\n    try {\n        transitioned = true;\n        if (!ready) {\n            return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service), \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service), \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n            // This means the service was started by some means other than ServiceManager.startAsync\n            stopwatch = Stopwatch.createStarted();\n            startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n            // N.B. if we miss the STARTING event then we may never record a startup time.\n            stopwatch.stop();\n            if (!(service instanceof NoOpService)) {\n                logger.get().log(Level.FINE, \"Started {0} in {1}.\", new Object[] { service, stopwatch });\n            }\n        }\n        // Queue our listeners\n        // Did a service fail?\n        if (to == FAILED) {\n            enqueueFailedEvent(service);\n        }\n        if (states.count(RUNNING) == numberOfServices) {\n            // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n            // they are not guaranteed to get 'true', because any service could fail right now.\n            enqueueHealthyEvent();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n            enqueueStoppedEvent();\n        }\n    } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        dispatchListenerEvents();\n    }\n}", "repo_id": "5", "comment": "/**\n * Updates the state with the given service transition.\n *\n * <p>This method performs the main logic of ServiceManager in the following steps.\n *\n * <ol>\n *   <li>Update the {@link #servicesByState()}\n *   <li>Update the {@link #startupTimers}\n *   <li>Based on the new state queue listeners to run\n *   <li>Run the listeners (outside of the lock)\n * </ol>\n */\n", "repo_name": "guava-master/", "id": 5348, "method_signature": "void transitionService(Service, State, State)", "filename": "ServiceManager.transitionService.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Map<Service, Stopwatch>.get", "Map<Service, Stopwatch>.put", "Monitor.leave"], "method_name": "ServiceManager.tryStartTiming", "method_implementation": "{\n    monitor.enter();\n    try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n            startupTimers.put(service, Stopwatch.createStarted());\n        }\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Attempts to start the timer immediately prior to the service being started via {@link\n * Service#startAsync()}.\n */\n", "repo_name": "guava-master/", "id": 5346, "method_signature": "void tryStartTiming(Service)", "filename": "ServiceManager.tryStartTiming.json"}
{"callee_method_ids": [5521], "callee_method_names": ["Monitor.isOccupiedByCurrentThread", "ListenerCallQueue.dispatch"], "method_name": "ServiceManagerState.dispatchListenerEvents", "method_implementation": "{\n    checkState(!monitor.isOccupiedByCurrentThread(), \"It is incorrect to execute listeners with the monitor held.\");\n    listeners.dispatch();\n}", "repo_id": "5", "comment": "/**\n * Attempts to execute all the listeners in {@link #listeners}.\n */\n", "repo_name": "guava-master/", "id": 5353, "method_signature": "void dispatchListenerEvents()", "filename": "ServiceManagerState.dispatchListenerEvents.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Service.state", "List<Service>.add", "Monitor.leave"], "method_name": "ServiceManagerState.markReady", "method_implementation": "{\n    monitor.enter();\n    try {\n        if (!transitioned) {\n            // nothing has transitioned since construction, good.\n            ready = true;\n        } else {\n            // This should be an extremely rare race condition.\n            List<Service> servicesInBadStates = Lists.newArrayList();\n            for (Service service : servicesByState().values()) {\n                if (service.state() != NEW) {\n                    servicesInBadStates.add(service);\n                }\n            }\n            throw new IllegalArgumentException(\"Services started transitioning asynchronously before \" + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n * been observed yet.\n */\n", "repo_name": "guava-master/", "id": 5351, "method_signature": "void markReady()", "filename": "ServiceManagerState.markReady.json"}
{"callee_method_ids": [5431, 5188, 5445], "callee_method_names": ["Monitor.enter", "SetMultimap<State, Service>.remove", "SetMultimap<State, Service>.put", "Map<Service, Stopwatch>.get", "Map<Service, Stopwatch>.put", "State.compareTo", "Stopwatch.isRunning", "Stopwatch.stop", "LazyLogger.get", "Multiset<State>.count", "Multiset<State>.count", "Multiset<State>.count", "Monitor.leave"], "method_name": "ServiceManagerState.transitionService", "method_implementation": "{\n    checkNotNull(service);\n    checkArgument(from != to);\n    monitor.enter();\n    try {\n        transitioned = true;\n        if (!ready) {\n            return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service), \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service), \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n            // This means the service was started by some means other than ServiceManager.startAsync\n            stopwatch = Stopwatch.createStarted();\n            startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n            // N.B. if we miss the STARTING event then we may never record a startup time.\n            stopwatch.stop();\n            if (!(service instanceof NoOpService)) {\n                logger.get().log(Level.FINE, \"Started {0} in {1}.\", new Object[] { service, stopwatch });\n            }\n        }\n        // Queue our listeners\n        // Did a service fail?\n        if (to == FAILED) {\n            enqueueFailedEvent(service);\n        }\n        if (states.count(RUNNING) == numberOfServices) {\n            // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n            // they are not guaranteed to get 'true', because any service could fail right now.\n            enqueueHealthyEvent();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n            enqueueStoppedEvent();\n        }\n    } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        dispatchListenerEvents();\n    }\n}", "repo_id": "5", "comment": "/**\n * Updates the state with the given service transition.\n *\n * <p>This method performs the main logic of ServiceManager in the following steps.\n *\n * <ol>\n *   <li>Update the {@link #servicesByState()}\n *   <li>Update the {@link #startupTimers}\n *   <li>Based on the new state queue listeners to run\n *   <li>Run the listeners (outside of the lock)\n * </ol>\n */\n", "repo_name": "guava-master/", "id": 5352, "method_signature": "void transitionService(Service, State, State)", "filename": "ServiceManagerState.transitionService.json"}
{"callee_method_ids": [5431, 5445], "callee_method_names": ["Monitor.enter", "Map<Service, Stopwatch>.get", "Map<Service, Stopwatch>.put", "Monitor.leave"], "method_name": "ServiceManagerState.tryStartTiming", "method_implementation": "{\n    monitor.enter();\n    try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n            startupTimers.put(service, Stopwatch.createStarted());\n        }\n    } finally {\n        monitor.leave();\n    }\n}", "repo_id": "5", "comment": "/**\n * Attempts to start the timer immediately prior to the service being started via {@link\n * Service#startAsync()}.\n */\n", "repo_name": "guava-master/", "id": 5350, "method_signature": "void tryStartTiming(Service)", "filename": "ServiceManagerState.tryStartTiming.json"}
{"callee_method_ids": [5343, 5345, 5344, 5345], "callee_method_names": ["Logger.setLevel", "Logger.addHandler", "ServiceManager.addListener", "ServiceManager.startAsync", "ServiceManager.isHealthy", "RecordingListener.isEmpty", "ServiceManager.stopAsync", "ServiceManager.isHealthy", "RecordingListener.isEmpty", "ServiceManager.toString", "ServiceManager.servicesByState", "ServiceManager.startupTimes", "TestLogHandler.getStoredLogRecords", "Formatter.format"], "method_name": "ServiceManagerTest.testEmptyServiceManager", "method_implementation": "{\n    Logger logger = Logger.getLogger(ServiceManager.class.getName());\n    logger.setLevel(Level.FINEST);\n    TestLogHandler logHandler = new TestLogHandler();\n    logger.addHandler(logHandler);\n    ServiceManager manager = new ServiceManager(Arrays.<Service>asList());\n    RecordingListener listener = new RecordingListener();\n    manager.addListener(listener, directExecutor());\n    manager.startAsync().awaitHealthy();\n    assertTrue(manager.isHealthy());\n    assertTrue(listener.healthyCalled);\n    assertFalse(listener.stoppedCalled);\n    assertTrue(listener.failedServices.isEmpty());\n    manager.stopAsync().awaitStopped();\n    assertFalse(manager.isHealthy());\n    assertTrue(listener.stoppedCalled);\n    assertTrue(listener.failedServices.isEmpty());\n    // check that our NoOpService is not directly observable via any of the inspection methods or\n    // via logging.\n    assertEquals(\"ServiceManager{services=[]}\", manager.toString());\n    assertTrue(manager.servicesByState().isEmpty());\n    assertTrue(manager.startupTimes().isEmpty());\n    Formatter logFormatter = new Formatter() {\n\n        @Override\n        public String format(LogRecord record) {\n            return formatMessage(record);\n        }\n    };\n    for (LogRecord record : logHandler.getStoredLogRecords()) {\n        assertThat(logFormatter.format(record)).doesNotContain(\"NoOpService\");\n    }\n}", "repo_id": "5", "comment": "/**\n * This is for covering a case where the ServiceManager would behave strangely if constructed with\n * no service under management. Listeners would never fire because the ServiceManager was healthy\n * and stopped at the same time. This test ensures that listeners fire and isHealthy makes sense.\n */\n", "repo_name": "guava-master/", "id": 3886, "method_signature": "void testEmptyServiceManager()", "filename": "ServiceManagerTest.testEmptyServiceManager.json"}
{"callee_method_ids": [5343], "callee_method_names": ["ServiceManager.addListener", "ServiceManager.startAsync"], "method_name": "ServiceManagerTest.testFailStart_singleServiceCallsHealthy", "method_implementation": "{\n    Service a = new FailStartService();\n    ServiceManager manager = new ServiceManager(asList(a));\n    RecordingListener listener = new RecordingListener();\n    manager.addListener(listener, directExecutor());\n    assertThrows(IllegalStateException.class, () -> manager.startAsync().awaitHealthy());\n    assertFalse(listener.healthyCalled);\n}", "repo_id": "5", "comment": "/**\n * This covers a bug where listener.healthy would get called when a single service failed during\n * startup (it occurred in more complicated cases also).\n */\n", "repo_name": "guava-master/", "id": 3884, "method_signature": "void testFailStart_singleServiceCallsHealthy()", "filename": "ServiceManagerTest.testFailStart_singleServiceCallsHealthy.json"}
{"callee_method_ids": [5344, 5343], "callee_method_names": ["ServiceManager.addListener", "ServiceManager.stopAsync", "ServiceManager.startAsync", "ServiceManager.awaitStopped"], "method_name": "ServiceManagerTest.testFailStart_stopOthers", "method_implementation": "{\n    Service a = new FailStartService();\n    Service b = new NoOpService();\n    final ServiceManager manager = new ServiceManager(asList(a, b));\n    manager.addListener(new Listener() {\n\n        @Override\n        public void failure(Service service) {\n            manager.stopAsync();\n        }\n    }, directExecutor());\n    manager.startAsync();\n    manager.awaitStopped(10, TimeUnit.MILLISECONDS);\n}", "repo_id": "5", "comment": "/**\n * This covers a bug where if a listener was installed that would stop the manager if any service\n * fails and something failed during startup before service.start was called on all the services,\n * then awaitStopped would deadlock due to an IllegalStateException that was thrown when trying to\n * stop the timer(!).\n */\n", "repo_name": "guava-master/", "id": 3885, "method_signature": "void testFailStart_stopOthers()", "filename": "ServiceManagerTest.testFailStart_stopOthers.json"}
{"callee_method_ids": [5343, 5345, 5344], "callee_method_names": ["ServiceManager.addListener", "CountDownLatch.countDown", "ServiceManager.startAsync", "CountDownLatch.countDown", "CountDownLatch.await", "ServiceManager.isHealthy", "ServiceManager.stopAsync", "Thread.start", "Thread.join", "Thread.isAlive", "CountDownLatch.countDown"], "method_name": "ServiceManagerTest.testListenerDeadlock", "method_implementation": "{\n    final CountDownLatch failEnter = new CountDownLatch(1);\n    final CountDownLatch failLeave = new CountDownLatch(1);\n    final CountDownLatch afterStarted = new CountDownLatch(1);\n    Service failRunService = new AbstractService() {\n\n        @Override\n        protected void doStart() {\n            new Thread() {\n\n                @Override\n                public void run() {\n                    notifyStarted();\n                    // We need to wait for the main thread to leave the ServiceManager.startAsync call\n                    // to\n                    // ensure that the thread running the failure callbacks is not the main thread.\n                    Uninterruptibles.awaitUninterruptibly(afterStarted);\n                    notifyFailed(new Exception(\"boom\"));\n                }\n            }.start();\n        }\n\n        @Override\n        protected void doStop() {\n            notifyStopped();\n        }\n    };\n    final ServiceManager manager = new ServiceManager(Arrays.asList(failRunService, new NoOpService()));\n    manager.addListener(new ServiceManager.Listener() {\n\n        @Override\n        public void failure(Service service) {\n            failEnter.countDown();\n            // block until after the service manager is shutdown\n            Uninterruptibles.awaitUninterruptibly(failLeave);\n        }\n    }, directExecutor());\n    manager.startAsync();\n    afterStarted.countDown();\n    // We do not call awaitHealthy because, due to races, that method may throw an exception.  But\n    // we really just want to wait for the thread to be in the failure callback so we wait for that\n    // explicitly instead.\n    failEnter.await();\n    assertFalse(\"State should be updated before calling listeners\", manager.isHealthy());\n    // now we want to stop the services.\n    Thread stoppingThread = new Thread() {\n\n        @Override\n        public void run() {\n            manager.stopAsync().awaitStopped();\n        }\n    };\n    stoppingThread.start();\n    // this should be super fast since the only non-stopped service is a NoOpService\n    stoppingThread.join(1000);\n    assertFalse(\"stopAsync has deadlocked!.\", stoppingThread.isAlive());\n    // release the background thread\n    failLeave.countDown();\n}", "repo_id": "5", "comment": "/**\n * Tests that a ServiceManager can be fully shut down if one of its failure listeners is slow or\n * even permanently blocked.\n */\n", "repo_name": "guava-master/", "id": 3887, "method_signature": "void testListenerDeadlock()", "filename": "ServiceManagerTest.testListenerDeadlock.json"}
{"callee_method_names": ["Logger.setLevel", "Logger.addHandler", "NoOpService.startAsync", "NoOpService.stopAsync", "TestLogHandler.getStoredLogRecords"], "method_name": "ServiceManagerTest.testPartiallyConstructedManager", "method_implementation": "{\n    Logger logger = Logger.getLogger(\"global\");\n    logger.setLevel(Level.FINEST);\n    TestLogHandler logHandler = new TestLogHandler();\n    logger.addHandler(logHandler);\n    NoOpService service = new NoOpService();\n    service.startAsync();\n    assertThrows(IllegalArgumentException.class, () -> new ServiceManager(Arrays.asList(service)));\n    service.stopAsync();\n    // Nothing was logged!\n    assertEquals(0, logHandler.getStoredLogRecords().size());\n}", "repo_id": "5", "comment": "/**\n * Catches a bug where when constructing a service manager failed, later interactions with the\n * service could cause IllegalStateExceptions inside the partially constructed ServiceManager.\n * This ISE wouldn't actually bubble up but would get logged by ExecutionQueue. This obfuscated\n * the original error (which was not constructing ServiceManager correctly).\n */\n", "repo_name": "guava-master/", "id": 3888, "method_signature": "void testPartiallyConstructedManager()", "filename": "ServiceManagerTest.testPartiallyConstructedManager.json"}
{"callee_method_ids": [5343], "callee_method_names": ["ServiceManager.addListener", "ServiceManager.startAsync"], "method_name": "ServiceManagerTest.testSingleFailedServiceCallsStopped", "method_implementation": "{\n    Service a = new FailStartService();\n    ServiceManager manager = new ServiceManager(asList(a));\n    RecordingListener listener = new RecordingListener();\n    manager.addListener(listener, directExecutor());\n    assertThrows(IllegalStateException.class, () -> manager.startAsync().awaitHealthy());\n    assertTrue(listener.stoppedCalled);\n}", "repo_id": "5", "comment": "/**\n * This covers a case where if the last service to stop failed then the stopped callback would\n * never be called.\n */\n", "repo_name": "guava-master/", "id": 3883, "method_signature": "void testSingleFailedServiceCallsStopped()", "filename": "ServiceManagerTest.testSingleFailedServiceCallsStopped.json"}
{"callee_method_ids": [5343, 5344], "callee_method_names": ["List<Service>.add", "ServiceManager.startAsync", "ServiceManager.stopAsync"], "method_name": "ServiceManagerTest.testTransitionRace", "method_implementation": "{\n    for (int k = 0; k < 1000; k++) {\n        List<Service> services = Lists.newArrayList();\n        for (int i = 0; i < 5; i++) {\n            services.add(new SnappyShutdownService(i));\n        }\n        ServiceManager manager = new ServiceManager(services);\n        manager.startAsync().awaitHealthy();\n        manager.stopAsync().awaitStopped(10, TimeUnit.SECONDS);\n    }\n}", "repo_id": "5", "comment": "/**\n * This test is for a case where two Service.Listener callbacks for the same service would call\n * transitionService in the wrong order due to a race. Due to the fact that it is a race this test\n * isn't guaranteed to expose the issue, but it is at least likely to become flaky if the race\n * sneaks back in, and in this case flaky means something is definitely wrong.\n *\n * <p>Before the bug was fixed this test would fail at least 30% of the time.\n */\n", "repo_name": "guava-master/", "id": 3889, "method_signature": "void testTransitionRace()", "filename": "ServiceManagerTest.testTransitionRace.json"}
{"callee_method_names": [], "method_name": "ServiceTest.testStateOrdering", "method_implementation": "{\n    // List every valid (direct) state transition.\n    assertLessThan(NEW, STARTING);\n    assertLessThan(NEW, TERMINATED);\n    assertLessThan(STARTING, RUNNING);\n    assertLessThan(STARTING, STOPPING);\n    assertLessThan(STARTING, FAILED);\n    assertLessThan(RUNNING, STOPPING);\n    assertLessThan(RUNNING, FAILED);\n    assertLessThan(STOPPING, FAILED);\n    assertLessThan(STOPPING, TERMINATED);\n}", "repo_id": "5", "comment": "/**\n * Assert on the comparison ordering of the State enum since we guarantee it.\n */\n", "repo_name": "guava-master/", "id": 3795, "method_signature": "void testStateOrdering()", "filename": "ServiceTest.testStateOrdering.json"}
{"callee_method_names": ["SetBuilderImpl<E>.add"], "method_name": "SetBuilderImpl.combine", "method_implementation": "{\n    SetBuilderImpl<E> result = this;\n    for (int i = 0; i < other.distinct; i++) {\n        /*\n         * requireNonNull is safe because we ensure that the first `distinct` elements have been\n         * populated.\n         */\n        result = result.add(requireNonNull(other.dedupedElements[i]));\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Adds all the elements from the specified SetBuilderImpl to this SetBuilderImpl.\n */\n", "repo_name": "guava-master/", "id": 3096, "method_signature": "SetBuilderImpl<E> combine(SetBuilderImpl)", "filename": "SetBuilderImpl.combine.json"}
{"callee_method_names": [], "method_name": "SetBuilderImpl.ensureCapacity", "method_implementation": "{\n    if (minCapacity > dedupedElements.length) {\n        int newCapacity = ImmutableCollection.Builder.expandedCapacity(dedupedElements.length, minCapacity);\n        dedupedElements = Arrays.copyOf(dedupedElements, newCapacity);\n    }\n}", "repo_id": "5", "comment": "/**\n * Resizes internal data structures if necessary to store the specified number of distinct\n * elements.\n */\n", "repo_name": "guava-master/", "id": 3095, "method_signature": "void ensureCapacity(int)", "filename": "SetBuilderImpl.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "SetGenerators.create", "method_implementation": "{\n    return (ImmutableSet<String>) ImmutableSet.of(elements[0], elements[0]);\n}", "repo_id": "5", "comment": "// is pointless\n", "repo_name": "guava-master/", "id": 4171, "method_signature": "Set<String> create(String[])", "filename": "SetGenerators.create.json"}
{"callee_method_names": ["SortedSet<E>.add"], "method_name": "SetGenerators.nullCheckedTreeSet", "method_implementation": "{\n    SortedSet<E> set = newTreeSet();\n    for (E element : elements) {\n        // Explicit null check because TreeSet wrongly accepts add(null) when empty.\n        set.add(checkNotNull(element));\n    }\n    return set;\n}", "repo_id": "5", "comment": "// SetCreationTester has some tests that pass in duplicates. Dedup them.\n", "repo_name": "guava-master/", "id": 4172, "method_signature": "SortedSet<E> nullCheckedTreeSet(E[])", "filename": "SetGenerators.nullCheckedTreeSet.json"}
{"callee_method_names": [], "method_name": "SetGenerators.order", "method_implementation": "{\n    Collections.sort(insertionOrder, Ordering.natural().reverse());\n    return insertionOrder;\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements in reverse natural order.\n */\n", "repo_name": "guava-master/", "id": 4173, "method_signature": "List<Integer> order(List)", "filename": "SetGenerators.order.json"}
{"callee_method_names": [], "method_name": "SetHashCodeTester.getHashCodeMethods", "method_implementation": "{\n    return new Method[] { Helpers.getMethod(SetHashCodeTester.class, \"testHashCode\"), Helpers.getMethod(SetHashCodeTester.class, \"testHashCode_containingNull\") };\n}", "repo_id": "5", "comment": "/**\n * Returns the {@link Method} instances for the test methods in this class which call {@code\n * hashCode()} on the set values so that set tests on unhashable objects can suppress it with\n * {@code FeatureSpecificTestSuiteBuilder.suppressing()}.\n */\n", "repo_name": "guava-master/", "id": 4193, "method_signature": "Method[] getHashCodeMethods()", "filename": "SetHashCodeTester.getHashCodeMethods.json"}
{"callee_method_names": [], "method_name": "SetView.add", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5599, "method_signature": "boolean add(E)", "filename": "SetView.add.json"}
{"callee_method_names": [], "method_name": "SetView.addAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5601, "method_signature": "boolean addAll(Collection)", "filename": "SetView.addAll.json"}
{"callee_method_names": [], "method_name": "SetView.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5604, "method_signature": "void clear()", "filename": "SetView.clear.json"}
{"callee_method_names": ["S.addAll"], "method_name": "SetView.copyInto", "method_implementation": "{\n    set.addAll(this);\n    return set;\n}", "repo_id": "5", "comment": "// some javac bug or some weirdness in the spec, not sure which.\n", "repo_name": "guava-master/", "id": 5598, "method_signature": "S copyInto(S)", "filename": "SetView.copyInto.json"}
{"callee_method_names": [], "method_name": "SetView.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5600, "method_signature": "boolean remove(Object)", "filename": "SetView.remove.json"}
{"callee_method_names": [], "method_name": "SetView.removeAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5602, "method_signature": "boolean removeAll(Collection)", "filename": "SetView.removeAll.json"}
{"callee_method_names": [], "method_name": "SetView.removeIf", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2226, "method_signature": "boolean removeIf(java.util.function.Predicate)", "filename": "SetView.removeIf.json"}
{"callee_method_names": [], "method_name": "SetView.retainAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5603, "method_signature": "boolean retainAll(Collection)", "filename": "SetView.retainAll.json"}
{"callee_method_names": [], "method_name": "Sets.add", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5577, "method_signature": "boolean add(E)", "filename": "Sets.add.json"}
{"callee_method_names": [], "method_name": "Sets.addAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5579, "method_signature": "boolean addAll(Collection)", "filename": "Sets.addAll.json"}
{"callee_method_names": [], "method_name": "Sets.clear", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5582, "method_signature": "void clear()", "filename": "Sets.clear.json"}
{"callee_method_names": ["ImmutableMap<E, Integer>.size", "ImmutableMap<E, Integer>.size", "ImmutableMap<E, Integer>.size", "ImmutableMap<E, Integer>.keySet", "Set<?>.size", "ImmutableMap<E, Integer>.keySet", "ImmutableMap<E, Integer>.size", "BitSet.isEmpty", "BitSet.set", "BitSet.nextSetBit", "BitSet.nextClearBit", "ImmutableMap<E, Integer>.size", "BitSet.set", "BitSet.clear", "BitSet.set", "BitSet.clone", "ImmutableMap<E, Integer>.get", "BitSet.get", "BitSet.nextSetBit", "ImmutableMap<E, Integer>.keySet", "ImmutableMap<E, Integer>.size", "ImmutableMap<E, Integer>.keySet"], "method_name": "Sets.combinations", "method_implementation": "{\n    final ImmutableMap<E, Integer> index = Maps.indexMap(set);\n    checkNonnegative(size, \"size\");\n    checkArgument(size <= index.size(), \"size (%s) must be <= set.size() (%s)\", size, index.size());\n    if (size == 0) {\n        return ImmutableSet.<Set<E>>of(ImmutableSet.<E>of());\n    } else if (size == index.size()) {\n        return ImmutableSet.<Set<E>>of(index.keySet());\n    }\n    return new AbstractSet<Set<E>>() {\n\n        @Override\n        public boolean contains(@CheckForNull Object o) {\n            if (o instanceof Set) {\n                Set<?> s = (Set<?>) o;\n                return s.size() == size && index.keySet().containsAll(s);\n            }\n            return false;\n        }\n\n        @Override\n        public Iterator<Set<E>> iterator() {\n            return new AbstractIterator<Set<E>>() {\n\n                final BitSet bits = new BitSet(index.size());\n\n                @Override\n                @CheckForNull\n                protected Set<E> computeNext() {\n                    if (bits.isEmpty()) {\n                        bits.set(0, size);\n                    } else {\n                        int firstSetBit = bits.nextSetBit(0);\n                        int bitToFlip = bits.nextClearBit(firstSetBit);\n                        if (bitToFlip == index.size()) {\n                            return endOfData();\n                        }\n                        /*\n               * The current set in sorted order looks like\n               * {firstSetBit, firstSetBit + 1, ..., bitToFlip - 1, ...}\n               * where it does *not* contain bitToFlip.\n               *\n               * The next combination is\n               *\n               * {0, 1, ..., bitToFlip - firstSetBit - 2, bitToFlip, ...}\n               *\n               * This is lexicographically next if you look at the combinations in descending order\n               * e.g. {2, 1, 0}, {3, 1, 0}, {3, 2, 0}, {3, 2, 1}, {4, 1, 0}...\n               */\n                        bits.set(0, bitToFlip - firstSetBit - 1);\n                        bits.clear(bitToFlip - firstSetBit - 1, bitToFlip);\n                        bits.set(bitToFlip);\n                    }\n                    final BitSet copy = (BitSet) bits.clone();\n                    return new AbstractSet<E>() {\n\n                        @Override\n                        public boolean contains(@CheckForNull Object o) {\n                            Integer i = index.get(o);\n                            return i != null && copy.get(i);\n                        }\n\n                        @Override\n                        public Iterator<E> iterator() {\n                            return new AbstractIterator<E>() {\n\n                                int i = -1;\n\n                                @Override\n                                @CheckForNull\n                                protected E computeNext() {\n                                    i = copy.nextSetBit(i + 1);\n                                    if (i == -1) {\n                                        return endOfData();\n                                    }\n                                    return index.keySet().asList().get(i);\n                                }\n                            };\n                        }\n\n                        @Override\n                        public int size() {\n                            return size;\n                        }\n                    };\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            return IntMath.binomial(index.size(), size);\n        }\n\n        @Override\n        public String toString() {\n            return \"Sets.combinations(\" + index.keySet() + \", \" + size + \")\";\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns the set of all subsets of {@code set} of size {@code size}. For example, {@code\n * combinations(ImmutableSet.of(1, 2, 3), 2)} returns the set {@code {{1, 2}, {1, 3}, {2, 3}}}.\n *\n * <p>Elements appear in these subsets in the same iteration order as they appeared in the input\n * set. The order in which these subsets appear in the outer set is undefined.\n *\n * <p>The returned set and its constituent sets use {@code equals} to decide whether two elements\n * are identical, even if the input set uses a different concept of equivalence.\n *\n * <p><i>Performance notes:</i> the memory usage of the returned set is only {@code O(n)}. When\n * the result set is constructed, the input set is merely copied. Only as the result set is\n * iterated are the individual subsets created. Each of these subsets occupies an additional O(n)\n * memory but only for as long as the user retains a reference to it. That is, the set returned by\n * {@code combinations} does not retain the individual subsets.\n *\n * @param set the set of elements to take combinations of\n * @param size the number of elements per combination\n * @return the set of all combinations of {@code size} elements from {@code set}\n * @throws IllegalArgumentException if {@code size} is not between 0 and {@code set.size()}\n *     inclusive\n * @throws NullPointerException if {@code set} is or contains {@code null}\n * @since 23.0\n */\n", "repo_name": "guava-master/", "id": 5591, "method_signature": "Set<Set<E>> combinations(Set, int)", "filename": "Sets.combinations.json"}
{"callee_method_names": [], "method_name": "Sets.complementOf", "method_implementation": "{\n    checkNotNull(collection);\n    return (collection instanceof EnumSet) ? EnumSet.complementOf((EnumSet<E>) collection) : makeComplementByHand(collection, type);\n}", "repo_id": "5", "comment": "/**\n * Creates an {@code EnumSet} consisting of all enum values that are not in the specified\n * collection. This is equivalent to {@link EnumSet#complementOf}, but can act on any input\n * collection, as long as the elements are of enum type.\n *\n * @param collection the collection whose complement should be stored in the {@code EnumSet}\n * @param type the type of the elements in the set\n * @return a new, modifiable {@code EnumSet} initially containing all the values of the enum not\n *     present in the given collection\n */\n", "repo_name": "guava-master/", "id": 5574, "method_signature": "EnumSet<E> complementOf(Collection, Class)", "filename": "Sets.complementOf.json"}
{"callee_method_names": ["S.addAll"], "method_name": "Sets.copyInto", "method_implementation": "{\n    set.addAll(this);\n    return set;\n}", "repo_id": "5", "comment": "// some javac bug or some weirdness in the spec, not sure which.\n", "repo_name": "guava-master/", "id": 5576, "method_signature": "S copyInto(S)", "filename": "Sets.copyInto.json"}
{"callee_method_names": ["Set<E>.iterator", "Iterator<E>.hasNext", "Iterator<E>.next", "Set<?>.contains", "Set<?>.contains", "Set<?>.containsAll", "Set<E>.contains", "Set<?>.contains"], "method_name": "Sets.difference", "method_implementation": "{\n    checkNotNull(set1, \"set1\");\n    checkNotNull(set2, \"set2\");\n    return new SetView<E>() {\n\n        @Override\n        public UnmodifiableIterator<E> iterator() {\n            return new AbstractIterator<E>() {\n\n                final Iterator<E> itr = set1.iterator();\n\n                @Override\n                @CheckForNull\n                protected E computeNext() {\n                    while (itr.hasNext()) {\n                        E e = itr.next();\n                        if (!set2.contains(e)) {\n                            return e;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            int size = 0;\n            for (E e : set1) {\n                if (!set2.contains(e)) {\n                    size++;\n                }\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return set2.containsAll(set1);\n        }\n\n        @Override\n        public boolean contains(@CheckForNull Object element) {\n            return set1.contains(element) && !set2.contains(element);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable <b>view</b> of the difference of two sets. The returned set contains\n * all elements that are contained by {@code set1} and not contained by {@code set2}. {@code set2}\n * may also contain elements not present in {@code set1}; these are simply ignored. The iteration\n * order of the returned set matches that of {@code set1}.\n *\n * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a\n * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.\n */\n", "repo_name": "guava-master/", "id": 5585, "method_signature": "SetView<E> difference(Set, Set)", "filename": "Sets.difference.json"}
{"callee_method_names": ["Set<?>.size", "Set<?>.size", "Set<?>.containsAll"], "method_name": "Sets.equalsImpl", "method_implementation": "{\n    if (s == object) {\n        return true;\n    }\n    if (object instanceof Set) {\n        Set<?> o = (Set<?>) object;\n        try {\n            return s.size() == o.size() && s.containsAll(o);\n        } catch (NullPointerException | ClassCastException ignored) {\n            return false;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * An implementation for {@link Set#equals(Object)}.\n */\n", "repo_name": "guava-master/", "id": 5593, "method_signature": "boolean equalsImpl(Set, Object)", "filename": "Sets.equalsImpl.json"}
{"callee_method_names": [], "method_name": "Sets.filter", "method_implementation": "{\n    if (unfiltered instanceof FilteredSet) {\n        // Support clear(), removeAll(), and retainAll() when filtering a filtered\n        // collection.\n        FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n        Predicate<E> combinedPredicate = Predicates.<E>and(filtered.predicate, predicate);\n        return new FilteredNavigableSet<E>((NavigableSet<E>) filtered.unfiltered, combinedPredicate);\n    }\n    return new FilteredNavigableSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n}", "repo_id": "5", "comment": "/**\n * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that satisfy a predicate.\n * The returned set is a live view of {@code unfiltered}; changes to one affect the other.\n *\n * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n * that satisfy the filter will be removed from the underlying set.\n *\n * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n *\n * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n * the underlying set and determine which elements satisfy the filter. When a live view is\n * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n * use the copy.\n *\n * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n * {@link Predicate#apply}. Do not provide a predicate such as {@code\n * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n * Iterables#filter(Iterable, Class)} for related functionality.)\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 5589, "method_signature": "NavigableSet<E> filter(NavigableSet, Predicate)", "filename": "Sets.filter.json"}
{"callee_method_names": ["Object.hashCode"], "method_name": "Sets.hashCodeImpl", "method_implementation": "{\n    int hashCode = 0;\n    for (Object o : s) {\n        hashCode += o != null ? o.hashCode() : 0;\n        hashCode = ~~hashCode;\n        // Needed to deal with unusual integer overflow in GWT.\n    }\n    return hashCode;\n}", "repo_id": "5", "comment": "/**\n * An implementation for {@link Set#hashCode()}.\n */\n", "repo_name": "guava-master/", "id": 5592, "method_signature": "int hashCodeImpl(Set)", "filename": "Sets.hashCodeImpl.json"}
{"callee_method_names": ["Collection<E>.isEmpty", "Iterable<E>.iterator", "Iterator<E>.hasNext", "Iterator<E>.next"], "method_name": "Sets.immutableEnumSet", "method_implementation": "{\n    if (elements instanceof ImmutableEnumSet) {\n        return (ImmutableEnumSet<E>) elements;\n    } else if (elements instanceof Collection) {\n        Collection<E> collection = (Collection<E>) elements;\n        if (collection.isEmpty()) {\n            return ImmutableSet.of();\n        } else {\n            return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));\n        }\n    } else {\n        Iterator<E> itr = elements.iterator();\n        if (itr.hasNext()) {\n            EnumSet<E> enumSet = EnumSet.of(itr.next());\n            Iterators.addAll(enumSet, itr);\n            return ImmutableEnumSet.asImmutable(enumSet);\n        } else {\n            return ImmutableSet.of();\n        }\n    }\n}", "repo_id": "5", "comment": "// http://code.google.com/p/google-web-toolkit/issues/detail?id=3028\n", "repo_name": "guava-master/", "id": 5562, "method_signature": "ImmutableSet<E> immutableEnumSet(Iterable)", "filename": "Sets.immutableEnumSet.json"}
{"callee_method_names": ["Set<E>.iterator", "Iterator<E>.hasNext", "Iterator<E>.next", "Set<?>.contains", "Set<?>.contains", "Set<E>.contains", "Set<?>.contains", "Set<E>.containsAll", "Set<?>.containsAll"], "method_name": "Sets.intersection", "method_implementation": "{\n    checkNotNull(set1, \"set1\");\n    checkNotNull(set2, \"set2\");\n    return new SetView<E>() {\n\n        @Override\n        public UnmodifiableIterator<E> iterator() {\n            return new AbstractIterator<E>() {\n\n                final Iterator<E> itr = set1.iterator();\n\n                @Override\n                @CheckForNull\n                protected E computeNext() {\n                    while (itr.hasNext()) {\n                        E e = itr.next();\n                        if (set2.contains(e)) {\n                            return e;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            int size = 0;\n            for (E e : set1) {\n                if (set2.contains(e)) {\n                    size++;\n                }\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return Collections.disjoint(set2, set1);\n        }\n\n        @Override\n        public boolean contains(@CheckForNull Object object) {\n            return set1.contains(object) && set2.contains(object);\n        }\n\n        @Override\n        public boolean containsAll(Collection<?> collection) {\n            return set1.containsAll(collection) && set2.containsAll(collection);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable <b>view</b> of the intersection of two sets. The returned set contains\n * all elements that are contained by both backing sets. The iteration order of the returned set\n * matches that of {@code set1}.\n *\n * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a\n * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.\n *\n * <p><b>Note:</b> The returned view performs slightly better when {@code set1} is the smaller of\n * the two sets. If you have reason to believe one of your sets will generally be smaller than the\n * other, pass it first. Unfortunately, since this method sets the generic type of the returned\n * set based on the type of the first set passed, this could in rare cases force you to make a\n * cast, for example:\n *\n * <pre>{@code\n * Set<Object> aFewBadObjects = ...\n * Set<String> manyBadStrings = ...\n *\n * // impossible for a non-String to be in the intersection\n * SuppressWarnings(\"unchecked\")\n * Set<String> badStrings = (Set) Sets.intersection(\n *     aFewBadObjects, manyBadStrings);\n * }</pre>\n *\n * <p>This is unfortunate, but should come up only very rarely.\n */\n", "repo_name": "guava-master/", "id": 5584, "method_signature": "SetView<E> intersection(Set, Set)", "filename": "Sets.intersection.json"}
{"callee_method_names": [], "method_name": "Sets.newConcurrentHashSet", "method_implementation": "{\n    Set<E> set = newConcurrentHashSet();\n    Iterables.addAll(set, elements);\n    return set;\n}", "repo_id": "5", "comment": "/**\n * Creates a thread-safe set backed by a hash map and containing the given elements. The set is\n * backed by a {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n * guarantees.\n *\n * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The\n * set is serializable.\n *\n * @param elements the elements that the set should contain\n * @return a new thread-safe set containing those elements (minus duplicates)\n * @throws NullPointerException if {@code elements} or any of its contents is null\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5568, "method_signature": "Set<E> newConcurrentHashSet(Iterable)", "filename": "Sets.newConcurrentHashSet.json"}
{"callee_method_names": [], "method_name": "Sets.newCopyOnWriteArraySet", "method_implementation": "{\n    // We copy elements to an ArrayList first, rather than incurring the\n    // quadratic cost of adding them to the COWAS directly.\n    Collection<? extends E> elementsCollection = (elements instanceof Collection) ? (Collection<? extends E>) elements : Lists.newArrayList(elements);\n    return new CopyOnWriteArraySet<E>(elementsCollection);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code CopyOnWriteArraySet} instance containing the given elements.\n *\n * @param elements the elements that the set should contain, in order\n * @return a new {@code CopyOnWriteArraySet} containing those elements\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5572, "method_signature": "CopyOnWriteArraySet<E> newCopyOnWriteArraySet(Iterable)", "filename": "Sets.newCopyOnWriteArraySet.json"}
{"callee_method_names": [], "method_name": "Sets.newEnumSet", "method_implementation": "{\n    EnumSet<E> set = EnumSet.noneOf(elementType);\n    Iterables.addAll(set, iterable);\n    return set;\n}", "repo_id": "5", "comment": "/**\n * Returns a new, <i>mutable</i> {@code EnumSet} instance containing the given elements in their\n * natural order. This method behaves identically to {@link EnumSet#copyOf(Collection)}, but also\n * accepts non-{@code Collection} iterables and empty iterables.\n */\n", "repo_name": "guava-master/", "id": 5564, "method_signature": "EnumSet<E> newEnumSet(Iterable, Class)", "filename": "Sets.newEnumSet.json"}
{"callee_method_names": [], "method_name": "Sets.newHashSet", "method_implementation": "{\n    HashSet<E> set = newHashSet();\n    Iterators.addAll(set, elements);\n    return set;\n}", "repo_id": "5", "comment": "/**\n * Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin\n * convenience for creating an empty set and then calling {@link Iterators#addAll}.\n *\n * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n * ImmutableSet#copyOf(Iterator)} instead.\n *\n * <p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an {@link EnumSet}\n * instead.\n *\n * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n */\n", "repo_name": "guava-master/", "id": 5567, "method_signature": "HashSet<E> newHashSet(Iterator)", "filename": "Sets.newHashSet.json"}
{"callee_method_names": [], "method_name": "Sets.newLinkedHashSet", "method_implementation": "{\n    if (elements instanceof Collection) {\n        return new LinkedHashSet<E>((Collection<? extends E>) elements);\n    }\n    LinkedHashSet<E> set = newLinkedHashSet();\n    Iterables.addAll(set, elements);\n    return set;\n}", "repo_id": "5", "comment": "/**\n * Creates a <i>mutable</i> {@code LinkedHashSet} instance containing the given elements in order.\n *\n * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n * ImmutableSet#copyOf(Iterable)} instead.\n *\n * <p><b>Note:</b> if {@code elements} is a {@link Collection}, you don't need this method.\n * Instead, use the {@code LinkedHashSet} constructor directly, taking advantage of <a\n * href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n *\n * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n *\n * @param elements the elements that the set should contain, in order\n * @return a new {@code LinkedHashSet} containing those elements (minus duplicates)\n */\n", "repo_name": "guava-master/", "id": 5569, "method_signature": "LinkedHashSet<E> newLinkedHashSet(Iterable)", "filename": "Sets.newLinkedHashSet.json"}
{"callee_method_names": [], "method_name": "Sets.newSetFromMap", "method_implementation": "{\n    return Collections.newSetFromMap(map);\n}", "repo_id": "5", "comment": "/**\n * Returns a set backed by the specified map. The resulting set displays the same ordering,\n * concurrency, and performance characteristics as the backing map. In essence, this factory\n * method provides a {@link Set} implementation corresponding to any {@link Map} implementation.\n * There is no need to use this method on a {@link Map} implementation that already has a\n * corresponding {@link Set} implementation (such as {@link java.util.HashMap} or {@link\n * java.util.TreeMap}).\n *\n * <p>Each method invocation on the set returned by this method results in exactly one method\n * invocation on the backing map or its {@code keySet} view, with one exception. The {@code\n * addAll} method is implemented as a sequence of {@code put} invocations on the backing map.\n *\n * <p>The specified map must be empty at the time this method is invoked, and should not be\n * accessed directly after this method returns. These conditions are ensured if the map is created\n * empty, passed directly to this method, and no reference to the map is retained, as illustrated\n * in the following code fragment:\n *\n * <pre>{@code\n * Set<Object> identityHashSet = Sets.newSetFromMap(\n *     new IdentityHashMap<Object, Boolean>());\n * }</pre>\n *\n * <p>The returned set is serializable if the backing map is.\n *\n * @param map the backing map\n * @return the set backed by the map\n * @throws IllegalArgumentException if {@code map} is not empty\n * @deprecated Use {@link Collections#newSetFromMap} instead.\n */\n", "repo_name": "guava-master/", "id": 5575, "method_signature": "Set<E> newSetFromMap(Map)", "filename": "Sets.newSetFromMap.json"}
{"callee_method_names": [], "method_name": "Sets.newTreeSet", "method_implementation": "{\n    TreeSet<E> set = newTreeSet();\n    Iterables.addAll(set, elements);\n    return set;\n}", "repo_id": "5", "comment": "/**\n * Creates a <i>mutable</i> {@code TreeSet} instance containing the given elements sorted by their\n * natural ordering.\n *\n * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedSet#copyOf(Iterable)}\n * instead.\n *\n * <p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit comparator, this\n * method has different behavior than {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code\n * TreeSet} with that comparator.\n *\n * <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,\n * use the {@code TreeSet} constructor directly, taking advantage of <a\n * href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n *\n * <p>This method is just a small convenience for creating an empty set and then calling {@link\n * Iterables#addAll}. This method is not very useful and will likely be deprecated in the future.\n *\n * @param elements the elements that the set should contain\n * @return a new {@code TreeSet} containing those elements (minus duplicates)\n */\n", "repo_name": "guava-master/", "id": 5570, "method_signature": "TreeSet<E> newTreeSet(Iterable)", "filename": "Sets.newTreeSet.json"}
{"callee_method_names": [], "method_name": "Sets.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5578, "method_signature": "boolean remove(Object)", "filename": "Sets.remove.json"}
{"callee_method_names": [], "method_name": "Sets.removeAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5580, "method_signature": "boolean removeAll(Collection)", "filename": "Sets.removeAll.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Set<?>.remove", "Iterator<?>.next"], "method_name": "Sets.removeAllImpl", "method_implementation": "{\n    boolean changed = false;\n    while (iterator.hasNext()) {\n        changed |= set.remove(iterator.next());\n    }\n    return changed;\n}", "repo_id": "5", "comment": "/**\n * Remove each element in an iterable from a set.\n */\n", "repo_name": "guava-master/", "id": 5596, "method_signature": "boolean removeAllImpl(Set, Iterator)", "filename": "Sets.removeAllImpl.json"}
{"callee_method_names": [], "method_name": "Sets.removeIf", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 2203, "method_signature": "boolean removeIf(java.util.function.Predicate)", "filename": "Sets.removeIf.json"}
{"callee_method_names": [], "method_name": "Sets.retainAll", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the collection unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5581, "method_signature": "boolean retainAll(Collection)", "filename": "Sets.retainAll.json"}
{"callee_method_names": ["NavigableSet<K>.comparator", "NavigableSet<K>.comparator", "Range<K>.hasLowerBound", "Range<K>.hasUpperBound", "NavigableSet<K>.comparator", "Range<K>.lowerEndpoint", "Range<K>.upperEndpoint", "Range<K>.hasLowerBound", "Range<K>.hasUpperBound", "NavigableSet<K>.subSet", "Range<K>.lowerEndpoint", "Range<K>.lowerBoundType", "Range<K>.upperEndpoint", "Range<K>.upperBoundType", "Range<K>.hasLowerBound", "NavigableSet<K>.tailSet", "Range<K>.lowerEndpoint", "Range<K>.lowerBoundType", "Range<K>.hasUpperBound", "NavigableSet<K>.headSet", "Range<K>.upperEndpoint", "Range<K>.upperBoundType"], "method_name": "Sets.subSet", "method_implementation": "{\n    if (set.comparator() != null && set.comparator() != Ordering.natural() && range.hasLowerBound() && range.hasUpperBound()) {\n        checkArgument(set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) <= 0, \"set is using a custom comparator which is inconsistent with the natural ordering.\");\n    }\n    if (range.hasLowerBound() && range.hasUpperBound()) {\n        return set.subSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED, range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);\n    } else if (range.hasLowerBound()) {\n        return set.tailSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);\n    } else if (range.hasUpperBound()) {\n        return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);\n    }\n    return checkNotNull(set);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of the portion of {@code set} whose elements are contained by {@code range}.\n *\n * <p>This method delegates to the appropriate methods of {@link NavigableSet} (namely {@link\n * NavigableSet#subSet(Object, boolean, Object, boolean) subSet()}, {@link\n * NavigableSet#tailSet(Object, boolean) tailSet()}, and {@link NavigableSet#headSet(Object,\n * boolean) headSet()}) to actually construct the view. Consult these methods for a full\n * description of the returned view's behavior.\n *\n * <p><b>Warning:</b> {@code Range}s always represent a range of values using the values' natural\n * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a {@link\n * Comparator}, which can violate the natural ordering. Using this method (or in general using\n * {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined behavior.\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 5597, "method_signature": "NavigableSet<K> subSet(NavigableSet, Range)", "filename": "Sets.subSet.json"}
{"callee_method_names": ["Set<? extends E>.iterator", "Set<? extends E>.iterator", "Iterator<? extends E>.hasNext", "Iterator<? extends E>.next", "Set<? extends E>.contains", "Iterator<? extends E>.hasNext", "Iterator<? extends E>.next", "Set<? extends E>.contains", "Set<? extends E>.contains", "Set<? extends E>.contains", "Set<? extends E>.equals", "Set<? extends E>.contains", "Set<? extends E>.contains"], "method_name": "Sets.symmetricDifference", "method_implementation": "{\n    checkNotNull(set1, \"set1\");\n    checkNotNull(set2, \"set2\");\n    return new SetView<E>() {\n\n        @Override\n        public UnmodifiableIterator<E> iterator() {\n            final Iterator<? extends E> itr1 = set1.iterator();\n            final Iterator<? extends E> itr2 = set2.iterator();\n            return new AbstractIterator<E>() {\n\n                @Override\n                @CheckForNull\n                public E computeNext() {\n                    while (itr1.hasNext()) {\n                        E elem1 = itr1.next();\n                        if (!set2.contains(elem1)) {\n                            return elem1;\n                        }\n                    }\n                    while (itr2.hasNext()) {\n                        E elem2 = itr2.next();\n                        if (!set1.contains(elem2)) {\n                            return elem2;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            int size = 0;\n            for (E e : set1) {\n                if (!set2.contains(e)) {\n                    size++;\n                }\n            }\n            for (E e : set2) {\n                if (!set1.contains(e)) {\n                    size++;\n                }\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return set1.equals(set2);\n        }\n\n        @Override\n        public boolean contains(@CheckForNull Object element) {\n            return set1.contains(element) ^ set2.contains(element);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable <b>view</b> of the symmetric difference of two sets. The returned set\n * contains all elements that are contained in either {@code set1} or {@code set2} but not in\n * both. The iteration order of the returned set is undefined.\n *\n * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a\n * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.\n *\n * @since 3.0\n */\n", "repo_name": "guava-master/", "id": 5586, "method_signature": "SetView<E> symmetricDifference(Set, Set)", "filename": "Sets.symmetricDifference.json"}
{"callee_method_names": [], "method_name": "Sets.synchronizedNavigableSet", "method_implementation": "{\n    return Synchronized.navigableSet(navigableSet);\n}", "repo_id": "5", "comment": "/**\n * Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In\n * order to guarantee serial access, it is critical that <b>all</b> access to the backing\n * navigable set is accomplished through the returned navigable set (or its views).\n *\n * <p>It is imperative that the user manually synchronize on the returned sorted set when\n * iterating over it or any of its {@code descendingSet}, {@code subSet}, {@code headSet}, or\n * {@code tailSet} views.\n *\n * <pre>{@code\n * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n *  ...\n * synchronized (set) {\n *   // Must be in the synchronized block\n *   Iterator<E> it = set.iterator();\n *   while (it.hasNext()) {\n *     foo(it.next());\n *   }\n * }\n * }</pre>\n *\n * <p>or:\n *\n * <pre>{@code\n * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n * NavigableSet<E> set2 = set.descendingSet().headSet(foo);\n *  ...\n * synchronized (set) { // Note: set, not set2!!!\n *   // Must be in the synchronized block\n *   Iterator<E> it = set2.descendingIterator();\n *   while (it.hasNext())\n *     foo(it.next());\n *   }\n * }\n * }</pre>\n *\n * <p>Failure to follow this advice may result in non-deterministic behavior.\n *\n * <p>The returned navigable set will be serializable if the specified navigable set is\n * serializable.\n *\n * <p><b>Java 8 users and later:</b> Prefer {@link Collections#synchronizedNavigableSet}.\n *\n * @param navigableSet the navigable set to be \"wrapped\" in a synchronized navigable set.\n * @return a synchronized view of the specified navigable set.\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 5595, "method_signature": "NavigableSet<E> synchronizedNavigableSet(NavigableSet)", "filename": "Sets.synchronizedNavigableSet.json"}
{"callee_method_names": [], "method_name": "Sets.toImmutableEnumSet", "method_implementation": "{\n    return CollectCollectors.toImmutableEnumSet();\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code Collector} that accumulates the input elements into a new {@code ImmutableSet}\n * with an implementation specialized for enums. Unlike {@link ImmutableSet#toImmutableSet}, the\n * resulting set will iterate over elements in their enum definition order, not encounter order.\n */\n", "repo_name": "guava-master/", "id": 5563, "method_signature": "Collector<E,?,ImmutableSet<E>> toImmutableEnumSet()", "filename": "Sets.toImmutableEnumSet.json"}
{"callee_method_names": ["Set<? extends E>.size", "Set<? extends E>.contains", "Set<? extends E>.isEmpty", "Set<? extends E>.isEmpty", "Set<? extends E>.iterator", "Set<? extends E>.iterator", "Iterator<? extends E>.hasNext", "Iterator<? extends E>.next", "Iterator<? extends E>.hasNext", "Iterator<? extends E>.next", "Set<? extends E>.contains", "Set<? extends E>.contains", "Set<? extends E>.contains", "S.addAll", "S.addAll", "ImmutableSet.Builder<@NonNull E>.build"], "method_name": "Sets.union", "method_implementation": "{\n    checkNotNull(set1, \"set1\");\n    checkNotNull(set2, \"set2\");\n    return new SetView<E>() {\n\n        @Override\n        public int size() {\n            int size = set1.size();\n            for (E e : set2) {\n                if (!set1.contains(e)) {\n                    size++;\n                }\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return set1.isEmpty() && set2.isEmpty();\n        }\n\n        @Override\n        public UnmodifiableIterator<E> iterator() {\n            return new AbstractIterator<E>() {\n\n                final Iterator<? extends E> itr1 = set1.iterator();\n\n                final Iterator<? extends E> itr2 = set2.iterator();\n\n                @Override\n                @CheckForNull\n                protected E computeNext() {\n                    if (itr1.hasNext()) {\n                        return itr1.next();\n                    }\n                    while (itr2.hasNext()) {\n                        E e = itr2.next();\n                        if (!set1.contains(e)) {\n                            return e;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        public boolean contains(@CheckForNull Object object) {\n            return set1.contains(object) || set2.contains(object);\n        }\n\n        @Override\n        public <S extends Set<E>> S copyInto(S set) {\n            set.addAll(set1);\n            set.addAll(set2);\n            return set;\n        }\n\n        @Override\n        // see supertype\n        @SuppressWarnings({ \"nullness\", \"unchecked\" })\n        public ImmutableSet<@NonNull E> immutableCopy() {\n            ImmutableSet.Builder<@NonNull E> builder = new ImmutableSet.Builder<@NonNull E>().addAll((Iterable<@NonNull E>) set1).addAll((Iterable<@NonNull E>) set2);\n            return (ImmutableSet<@NonNull E>) builder.build();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable <b>view</b> of the union of two sets. The returned set contains all\n * elements that are contained in either backing set. Iterating over the returned set iterates\n * first over all the elements of {@code set1}, then over each element of {@code set2}, in order,\n * that is not contained in {@code set1}.\n *\n * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a\n * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.\n */\n", "repo_name": "guava-master/", "id": 5583, "method_signature": "SetView<E> union(Set, Set)", "filename": "Sets.union.json"}
{"callee_method_names": [], "method_name": "Sets.unmodifiableNavigableSet", "method_implementation": "{\n    if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet) {\n        return set;\n    }\n    return new UnmodifiableNavigableSet<E>(set);\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified navigable set. This method allows modules to\n * provide users with \"read-only\" access to internal navigable sets. Query operations on the\n * returned set \"read through\" to the specified set, and attempts to modify the returned set,\n * whether direct or via its collection views, result in an {@code UnsupportedOperationException}.\n *\n * <p>The returned navigable set will be serializable if the specified navigable set is\n * serializable.\n *\n * <p><b>Java 8 users and later:</b> Prefer {@link Collections#unmodifiableNavigableSet}.\n *\n * @param set the navigable set for which an unmodifiable view is to be returned\n * @return an unmodifiable view of the specified navigable set\n * @since 12.0\n */\n", "repo_name": "guava-master/", "id": 5594, "method_signature": "NavigableSet<E> unmodifiableNavigableSet(NavigableSet)", "filename": "Sets.unmodifiableNavigableSet.json"}
{"callee_method_names": [], "method_name": "Sets.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5590, "method_signature": "Object writeReplace()", "filename": "Sets.writeReplace.json"}
{"callee_method_names": [], "method_name": "SetsTest.testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero", "method_implementation": "{\n    Set<Object> sumToEighthMaxIntElements = newHashSet(objectWithHashCode(1 << 29), objectWithHashCode(0));\n    assertPowerSetHashCode(1 << 30, sumToEighthMaxIntElements);\n    Set<Object> sumToQuarterMaxIntElements = newHashSet(objectWithHashCode(1 << 30), objectWithHashCode(0));\n    assertPowerSetHashCode(1 << 31, sumToQuarterMaxIntElements);\n}", "repo_id": "5", "comment": "/**\n * Test that a hash code miscomputed by \"input.hashCode() * tooFarValue / 2\" is correct under our\n * {@code hashCode} implementation.\n */\n", "repo_name": "guava-master/", "id": 3974, "method_signature": "void testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero()", "filename": "SetsTest.testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero.json"}
{"callee_method_names": [], "method_name": "SetsTest.verifyLinkedHashSetContents", "method_implementation": "{\n    assertEquals(\"LinkedHashSet should have preserved order for iteration\", new ArrayList<E>(set), new ArrayList<E>(contents));\n    verifySetContents(set, contents);\n}", "repo_id": "5", "comment": "/**\n * Utility method to verify that the given LinkedHashSet is equal to and hashes identically to a\n * set constructed with the elements in the given collection. Also verifies that the ordering in\n * the set is the same as the ordering of the given contents.\n */\n", "repo_name": "guava-master/", "id": 3975, "method_signature": "void verifyLinkedHashSetContents(LinkedHashSet, Collection)", "filename": "SetsTest.verifyLinkedHashSetContents.json"}
{"callee_method_names": ["Set<E>.add"], "method_name": "SetsTest.verifySetContents", "method_implementation": "{\n    Set<E> expected = null;\n    if (contents instanceof Set) {\n        expected = (Set<E>) contents;\n    } else {\n        expected = new HashSet<E>();\n        for (E element : contents) {\n            expected.add(element);\n        }\n    }\n    assertEquals(expected, set);\n}", "repo_id": "5", "comment": "/**\n * Utility method that verifies that the given set is equal to and hashes identically to a set\n * constructed with the elements in the given iterable.\n */\n", "repo_name": "guava-master/", "id": 3977, "method_signature": "void verifySetContents(Set, Iterable)", "filename": "SetsTest.verifySetContents.json"}
{"callee_method_names": ["SortedSet<E>.comparator"], "method_name": "SetsTest.verifySortedSetContents", "method_implementation": "{\n    assertSame(comparator, set.comparator());\n    verifySetContents(set, iterable);\n}", "repo_id": "5", "comment": "/**\n * Utility method to verify that the given SortedSet is equal to and hashes identically to a set\n * constructed with the elements in the given iterable. Also verifies that the comparator is the\n * same as the given comparator.\n */\n", "repo_name": "guava-master/", "id": 3976, "method_signature": "void verifySortedSetContents(SortedSet, Iterable, Comparator)", "filename": "SetsTest.verifySortedSetContents.json"}
{"callee_method_names": ["SettableFuture<Integer>.isDone", "SettableFuture<Integer>.isCancelled"], "method_name": "SettableFutureTest.testCreate", "method_implementation": "{\n    SettableFuture<Integer> future = SettableFuture.create();\n    assertFalse(future.isDone());\n    assertFalse(future.isCancelled());\n}", "repo_id": "5", "comment": "/**\n * Tests the initial state of the future.\n */\n", "repo_name": "guava-master/", "id": 3815, "method_signature": "void testCreate()", "filename": "SettableFutureTest.testCreate.json"}
{"callee_method_names": [], "method_name": "Shorts.asList", "method_implementation": "{\n    if (backingArray.length == 0) {\n        return Collections.emptyList();\n    }\n    return new ShortArrayAsList(backingArray);\n}", "repo_id": "5", "comment": "/**\n * Returns a fixed-size list backed by the specified array, similar to {@link\n * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to\n * set a value to {@code null} will result in a {@link NullPointerException}.\n *\n * <p>The returned list maintains the values, but not the identities, of {@code Short} objects\n * written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for\n * the returned list is unspecified.\n *\n * <p>The returned list is serializable.\n *\n * @param backingArray the array to back the list\n * @return a list view of the array\n */\n", "repo_name": "guava-master/", "id": 4367, "method_signature": "List<Short> asList(short[])", "filename": "Shorts.asList.json"}
{"callee_method_names": [], "method_name": "Shorts.checkedCast", "method_implementation": "{\n    short result = (short) value;\n    checkArgument(result == value, \"Out of range: %s\", value);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code short} value that is equal to {@code value}, if possible.\n *\n * @param value any value in the range of the {@code short} type\n * @return the {@code short} value that equals {@code value}\n * @throws IllegalArgumentException if {@code value} is greater than {@link Short#MAX_VALUE} or\n *     less than {@link Short#MIN_VALUE}\n */\n", "repo_name": "guava-master/", "id": 4351, "method_signature": "short checkedCast(long)", "filename": "Shorts.checkedCast.json"}
{"callee_method_names": [], "method_name": "Shorts.concat", "method_implementation": "{\n    int length = 0;\n    for (short[] array : arrays) {\n        length += array.length;\n    }\n    short[] result = new short[length];\n    int pos = 0;\n    for (short[] array : arrays) {\n        System.arraycopy(array, 0, result, pos, array.length);\n        pos += array.length;\n    }\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the values from each provided array combined into a single array. For example, {@code\n * concat(new short[] {a, b}, new short[] {}, new short[] {c}} returns the array {@code {a, b,\n * c}}.\n *\n * @param arrays zero or more {@code short} arrays\n * @return a single array containing all the values from the source arrays, in order\n */\n", "repo_name": "guava-master/", "id": 4359, "method_signature": "short[] concat(short[][])", "filename": "Shorts.concat.json"}
{"callee_method_names": [], "method_name": "Shorts.contains", "method_implementation": "{\n    for (short value : array) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.\n *\n * @param array an array of {@code short} values, possibly empty\n * @param target a primitive {@code short} value\n * @return {@code true} if {@code array[i] == target} for some value of {@code i}\n */\n", "repo_name": "guava-master/", "id": 4353, "method_signature": "boolean contains(short[], short)", "filename": "Shorts.contains.json"}
{"callee_method_names": [], "method_name": "Shorts.ensureCapacity", "method_implementation": "{\n    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing the same values as {@code array}, but guaranteed to be of a\n * specified minimum length. If {@code array} already has a length of at least {@code minLength},\n * it is returned directly. Otherwise, a new array of size {@code minLength + padding} is\n * returned, containing the values of {@code array}, and zeroes in the remaining places.\n *\n * @param array the source array\n * @param minLength the minimum length the returned array must guarantee\n * @param padding an extra amount to \"grow\" the array by if growth is necessary\n * @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative\n * @return an array containing the values of {@code array}, with guaranteed minimum length {@code\n *     minLength}\n */\n", "repo_name": "guava-master/", "id": 4361, "method_signature": "short[] ensureCapacity(short[], int, int)", "filename": "Shorts.ensureCapacity.json"}
{"callee_method_names": [], "method_name": "Shorts.fromByteArray", "method_implementation": "{\n    checkArgument(bytes.length >= BYTES, \"array too small: %s < %s\", bytes.length, BYTES);\n    return fromBytes(bytes[0], bytes[1]);\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code short} value whose big-endian representation is stored in the first 2 bytes\n * of {@code bytes}; equivalent to {@code ByteBuffer.wrap(bytes).getShort()}. For example, the\n * input byte array {@code {0x54, 0x32}} would yield the {@code short} value {@code 0x5432}.\n *\n * <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that library exposes much more\n * flexibility at little cost in readability.\n *\n * @throws IllegalArgumentException if {@code bytes} has fewer than 2 elements\n */\n", "repo_name": "guava-master/", "id": 4360, "method_signature": "short fromByteArray(byte[])", "filename": "Shorts.fromByteArray.json"}
{"callee_method_names": [], "method_name": "Shorts.indexOf", "method_implementation": "{\n    checkNotNull(array, \"array\");\n    checkNotNull(target, \"target\");\n    if (target.length == 0) {\n        return 0;\n    }\n    outer: for (int i = 0; i < array.length - target.length + 1; i++) {\n        for (int j = 0; j < target.length; j++) {\n            if (array[i + j] != target[j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/**\n * Returns the start position of the first occurrence of the specified {@code target} within\n * {@code array}, or {@code -1} if there is no such occurrence.\n *\n * <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,\n * i, i + target.length)} contains exactly the same elements as {@code target}.\n *\n * @param array the array to search for the sequence {@code target}\n * @param target the array to search for as a sub-sequence of {@code array}\n */\n", "repo_name": "guava-master/", "id": 4355, "method_signature": "int indexOf(short[], short[])", "filename": "Shorts.indexOf.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Shorts.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 6);\n    builder.append(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code short} values separated by {@code separator}.\n * For example, {@code join(\"-\", (short) 1, (short) 2, (short) 3)} returns the string {@code\n * \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code short} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4362, "method_signature": "String join(String, short[])", "filename": "Shorts.join.json"}
{"callee_method_names": [], "method_name": "Shorts.lastIndexOf", "method_implementation": "{\n    for (int i = end - 1; i >= start; i--) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "5", "comment": "// TODO(kevinb): consider making this public\n", "repo_name": "guava-master/", "id": 4356, "method_signature": "int lastIndexOf(short[], short, int, int)", "filename": "Shorts.lastIndexOf.json"}
{"callee_method_names": [], "method_name": "Shorts.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    short max = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code short} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4358, "method_signature": "short max(short[])", "filename": "Shorts.max.json"}
{"callee_method_names": [], "method_name": "Shorts.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    short min = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] < min) {\n            min = array[i];\n        }\n    }\n    return min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code short} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4357, "method_signature": "short min(short[])", "filename": "Shorts.min.json"}
{"callee_method_names": [], "method_name": "Shorts.reverse", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n        short tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}", "repo_id": "5", "comment": "/**\n * Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive. This is equivalent to {@code\n * Collections.reverse(Shorts.asList(array).subList(fromIndex, toIndex))}, but is likely to be\n * more efficient.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4364, "method_signature": "void reverse(short[], int, int)", "filename": "Shorts.reverse.json"}
{"callee_method_names": [], "method_name": "Shorts.rotate", "method_implementation": "{\n    // See Ints.rotate for more details about possible algorithms here.\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    if (array.length <= 1) {\n        return;\n    }\n    int length = toIndex - fromIndex;\n    // Obtain m = (-distance mod length), a non-negative value less than \"length\". This is how many\n    // places left to rotate.\n    int m = -distance % length;\n    m = (m < 0) ? m + length : m;\n    // The current index of what will become the first element of the rotated section.\n    int newFirstIndex = m + fromIndex;\n    if (newFirstIndex == fromIndex) {\n        return;\n    }\n    reverse(array, fromIndex, newFirstIndex);\n    reverse(array, newFirstIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code\n * toIndex} exclusive. This is equivalent to {@code\n * Collections.rotate(Shorts.asList(array).subList(fromIndex, toIndex), distance)}, but is\n * considerably faster and avoids allocations and garbage collection.\n *\n * <p>The provided \"distance\" may be negative, which will rotate left.\n *\n * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or\n *     {@code toIndex > fromIndex}\n * @since 32.0.0\n */\n", "repo_name": "guava-master/", "id": 4365, "method_signature": "void rotate(short[], int, int, int)", "filename": "Shorts.rotate.json"}
{"callee_method_names": [], "method_name": "Shorts.saturatedCast", "method_implementation": "{\n    if (value > Short.MAX_VALUE) {\n        return Short.MAX_VALUE;\n    }\n    if (value < Short.MIN_VALUE) {\n        return Short.MIN_VALUE;\n    }\n    return (short) value;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code short} nearest in value to {@code value}.\n *\n * @param value any {@code long} value\n * @return the same value cast to {@code short} if it is in the range of the {@code short} type,\n *     {@link Short#MAX_VALUE} if it is too large, or {@link Short#MIN_VALUE} if it is too small\n */\n", "repo_name": "guava-master/", "id": 4352, "method_signature": "short saturatedCast(long)", "filename": "Shorts.saturatedCast.json"}
{"callee_method_names": [], "method_name": "Shorts.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    Arrays.sort(array, fromIndex, toIndex);\n    reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4363, "method_signature": "void sortDescending(short[], int, int)", "filename": "Shorts.sortDescending.json"}
{"callee_method_names": ["Collection<? extends Number>.toArray"], "method_name": "Shorts.toArray", "method_implementation": "{\n    if (collection instanceof ShortArrayAsList) {\n        return ((ShortArrayAsList) collection).toShortArray();\n    }\n    Object[] boxedArray = collection.toArray();\n    int len = boxedArray.length;\n    short[] array = new short[len];\n    for (int i = 0; i < len; i++) {\n        // checkNotNull for GWT (do not optimize)\n        array[i] = ((Number) checkNotNull(boxedArray[i])).shortValue();\n    }\n    return array;\n}", "repo_id": "5", "comment": "/**\n * Returns an array containing each value of {@code collection}, converted to a {@code short}\n * value in the manner of {@link Number#shortValue}.\n *\n * <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.\n * Calling this method is as thread-safe as calling that method.\n *\n * @param collection a collection of {@code Number} instances\n * @return an array containing the same values as {@code collection}, in the same order, converted\n *     to primitives\n * @throws NullPointerException if {@code collection} or any of its elements is null\n * @since 1.0 (parameter was {@code Collection<Short>} before 12.0)\n */\n", "repo_name": "guava-master/", "id": 4366, "method_signature": "short[] toArray(Collection)", "filename": "Shorts.toArray.json"}
{"callee_method_names": ["List<Short>.subList", "List<Short>.subList"], "method_name": "ShortsTest.testAsList_subList_toArray_roundTrip", "method_implementation": "{\n    short[] array = { (short) 0, (short) 1, (short) 2, (short) 3 };\n    List<Short> list = Shorts.asList(array);\n    assertThat(Shorts.toArray(list.subList(1, 3))).isEqualTo(new short[] { (short) 1, (short) 2 });\n    assertThat(Shorts.toArray(list.subList(2, 2))).isEqualTo(new short[] {});\n}", "repo_id": "5", "comment": "// This test stems from a real bug found by andrewk\n", "repo_name": "guava-master/", "id": 3547, "method_signature": "void testAsList_subList_toArray_roundTrip()", "filename": "ShortsTest.testAsList_subList_toArray_roundTrip.json"}
{"callee_method_names": [], "method_name": "SignedBytes.checkedCast", "method_implementation": "{\n    byte result = (byte) value;\n    checkArgument(result == value, \"Out of range: %s\", value);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code byte} value that is equal to {@code value}, if possible.\n *\n * @param value any value in the range of the {@code byte} type\n * @return the {@code byte} value that equals {@code value}\n * @throws IllegalArgumentException if {@code value} is greater than {@link Byte#MAX_VALUE} or\n *     less than {@link Byte#MIN_VALUE}\n */\n", "repo_name": "guava-master/", "id": 4299, "method_signature": "byte checkedCast(long)", "filename": "SignedBytes.checkedCast.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "SignedBytes.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 5);\n    builder.append(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(array[i]);\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code byte} values separated by {@code separator}.\n * For example, {@code join(\":\", 0x01, 0x02, -0x01)} returns the string {@code \"1:2:-1\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code byte} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4303, "method_signature": "String join(String, byte[])", "filename": "SignedBytes.join.json"}
{"callee_method_names": [], "method_name": "SignedBytes.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    byte max = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code byte} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4302, "method_signature": "byte max(byte[])", "filename": "SignedBytes.max.json"}
{"callee_method_names": [], "method_name": "SignedBytes.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    byte min = array[0];\n    for (int i = 1; i < array.length; i++) {\n        if (array[i] < min) {\n            min = array[i];\n        }\n    }\n    return min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}.\n *\n * @param array a <i>nonempty</i> array of {@code byte} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4301, "method_signature": "byte min(byte[])", "filename": "SignedBytes.min.json"}
{"callee_method_names": [], "method_name": "SignedBytes.saturatedCast", "method_implementation": "{\n    if (value > Byte.MAX_VALUE) {\n        return Byte.MAX_VALUE;\n    }\n    if (value < Byte.MIN_VALUE) {\n        return Byte.MIN_VALUE;\n    }\n    return (byte) value;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code byte} nearest in value to {@code value}.\n *\n * @param value any {@code long} value\n * @return the same value cast to {@code byte} if it is in the range of the {@code byte} type,\n *     {@link Byte#MAX_VALUE} if it is too large, or {@link Byte#MIN_VALUE} if it is too small\n */\n", "repo_name": "guava-master/", "id": 4300, "method_signature": "byte saturatedCast(long)", "filename": "SignedBytes.saturatedCast.json"}
{"callee_method_names": [], "method_name": "SignedBytes.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    Arrays.sort(array, fromIndex, toIndex);\n    Bytes.reverse(array, fromIndex, toIndex);\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4304, "method_signature": "void sortDescending(byte[], int, int)", "filename": "SignedBytes.sortDescending.json"}
{"callee_method_names": ["StatsCounter.snapshot", "LongAddable.add", "CacheStats.hitCount", "LongAddable.add", "CacheStats.missCount", "LongAddable.add", "CacheStats.loadSuccessCount", "LongAddable.add", "CacheStats.loadExceptionCount", "LongAddable.add", "CacheStats.totalLoadTime", "LongAddable.add", "CacheStats.evictionCount"], "method_name": "SimpleStatsCounter.incrementBy", "method_implementation": "{\n    CacheStats otherStats = other.snapshot();\n    hitCount.add(otherStats.hitCount());\n    missCount.add(otherStats.missCount());\n    loadSuccessCount.add(otherStats.loadSuccessCount());\n    loadExceptionCount.add(otherStats.loadExceptionCount());\n    totalLoadTime.add(otherStats.totalLoadTime());\n    evictionCount.add(otherStats.evictionCount());\n}", "repo_id": "5", "comment": "/**\n * Increments all counters by the values in {@code other}.\n */\n", "repo_name": "guava-master/", "id": 4900, "method_signature": "void incrementBy(StatsCounter)", "filename": "SimpleStatsCounter.incrementBy.json"}
{"callee_method_names": ["Class<T>.getClassLoader", "Class<T>.cast"], "method_name": "SimpleTimeLimiter.newProxy", "method_implementation": "{\n    Object object = Proxy.newProxyInstance(interfaceType.getClassLoader(), new Class<?>[] { interfaceType }, handler);\n    return interfaceType.cast(object);\n}", "repo_id": "5", "comment": "// TODO: replace with version in common.reflect if and when it's open-sourced\n", "repo_name": "guava-master/", "id": 5483, "method_signature": "T newProxy(Class, InvocationHandler)", "filename": "SimpleTimeLimiter.newProxy.json"}
{"callee_method_names": [], "method_name": "SingletonImmutableBiMap.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2150, "method_signature": "Object writeReplace()", "filename": "SingletonImmutableBiMap.writeReplace.json"}
{"callee_method_names": [], "method_name": "SingletonImmutableList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 2776, "method_signature": "Object writeReplace()", "filename": "SingletonImmutableList.writeReplace.json"}
{"callee_method_names": [], "method_name": "SingletonImmutableSet.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6060, "method_signature": "Object writeReplace()", "filename": "SingletonImmutableSet.writeReplace.json"}
{"callee_method_names": ["ByteArrayOutputStream.toByteArray"], "method_name": "Sink.assertInvariants", "method_implementation": "{\n    // we should have seen as many bytes as the next multiple of chunk after expectedBytes - 1\n    assertEquals(out.toByteArray().length, ceilToMultiple(expectedBytes, chunkSize));\n    assertEquals(expectedBytes / chunkSize, processCalled);\n    assertEquals(expectedBytes % chunkSize != 0, remainingCalled);\n}", "repo_id": "5", "comment": "// ensures that the number of invocations looks sane\n", "repo_name": "guava-master/", "id": 3745, "method_signature": "void assertInvariants(int)", "filename": "Sink.assertInvariants.json"}
{"callee_method_names": [], "method_name": "SipHashFunctionTest.test15ByteStringFromSipHashPaper", "method_implementation": "{\n    byte[] message = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e };\n    long k0 = 0x0706050403020100L;\n    long k1 = 0x0f0e0d0c0b0a0908L;\n    assertEquals(0xa129ca6149be45e5L, Hashing.sipHash24(k0, k1).hashBytes(message).asLong());\n}", "repo_id": "5", "comment": "// It can be downloaded here: https://131002.net/siphash/siphash.pdf\n", "repo_name": "guava-master/", "id": 3738, "method_signature": "void test15ByteStringFromSipHashPaper()", "filename": "SipHashFunctionTest.test15ByteStringFromSipHashPaper.json"}
{"callee_method_names": ["HashFunction.hashBytes", "HashFunction.hashBytes", "HashFunction.hashBytes", "ImmutableSet<HashCode>.size"], "method_name": "SipHashFunctionTest.testCollisionsDueToIncorrectSignExtension", "method_implementation": "{\n    byte[] col1 = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, (byte) 0x80 };\n    byte[] col2 = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, (byte) 0x81 };\n    byte[] col3 = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, (byte) 0xff };\n    ImmutableSet<HashCode> hashCodes = ImmutableSet.of(SIP_WITH_KEY.hashBytes(col1), SIP_WITH_KEY.hashBytes(col2), SIP_WITH_KEY.hashBytes(col3));\n    assertEquals(3, hashCodes.size());\n}", "repo_id": "5", "comment": "// A fault implementation will generate collisions for these inputs.\n", "repo_name": "guava-master/", "id": 3740, "method_signature": "void testCollisionsDueToIncorrectSignExtension()", "filename": "SipHashFunctionTest.testCollisionsDueToIncorrectSignExtension.json"}
{"callee_method_names": [], "method_name": "SipHashFunctionTest.testKnownValues", "method_implementation": "{\n    assertSip(new byte[] {}, 0x726fdb47dd0e0e31L);\n    assertSip(new byte[] { 0x61 }, 0x2ba3e8e9a71148caL);\n    assertSip(new byte[1000000], 0x28205108397aa742L);\n    assertSip(\"12345678\", 0x02130609caea37ebL);\n    assertSip(\"abcdef\", 0x2a6e77e733c7c05dL);\n    assertSip(\"SipHash\", 0x8325093242a96f60L);\n}", "repo_id": "5", "comment": "// From https://github.com/BrandonHaynes/siphash-csharp/blob/master/tests/Tests.cs\n", "repo_name": "guava-master/", "id": 3739, "method_signature": "void testKnownValues()", "filename": "SipHashFunctionTest.testKnownValues.json"}
{"callee_method_names": [], "method_name": "SmallCharMatcher.chooseTableSize", "method_implementation": "{\n    if (setSize == 1) {\n        return 2;\n    }\n    // Correct the size for open addressing to match desired load factor.\n    // Round up to the next highest power of 2.\n    int tableSize = Integer.highestOneBit(setSize - 1) << 1;\n    while (tableSize * DESIRED_LOAD_FACTOR < setSize) {\n        tableSize <<= 1;\n    }\n    return tableSize;\n}", "repo_id": "5", "comment": "/**\n * Returns an array size suitable for the backing array of a hash table that uses open addressing\n * with linear probing in its implementation. The returned size is the smallest power of two that\n * can hold setSize elements with the desired load factor.\n */\n", "repo_name": "guava-master/", "id": 5126, "method_signature": "int chooseTableSize(int)", "filename": "SmallCharMatcher.chooseTableSize.json"}
{"callee_method_names": ["ReferenceQueue.poll", "AtomicReferenceArray<@Nullable ArrayReference<? extends L>>.compareAndSet"], "method_name": "SmallLazyStriped.drainQueue", "method_implementation": "{\n    Reference<? extends L> ref;\n    while ((ref = queue.poll()) != null) {\n        // We only ever register ArrayReferences with the queue so this is always safe.\n        ArrayReference<? extends L> arrayRef = (ArrayReference<? extends L>) ref;\n        // Try to clear out the array slot, n.b. if we fail that is fine, in either case the\n        // arrayRef will be out of the array after this step.\n        locks.compareAndSet(arrayRef.index, arrayRef, null);\n    }\n}", "repo_id": "5", "comment": "// objects indefinitely.\n", "repo_name": "guava-master/", "id": 5390, "method_signature": "void drainQueue()", "filename": "SmallLazyStriped.drainQueue.json"}
{"callee_method_names": [], "method_name": "SmoothRateLimiter.resync", "method_implementation": "{\n    // if nextFreeTicket is in the past, resync to now\n    if (nowMicros > nextFreeTicketMicros) {\n        double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();\n        storedPermits = min(maxPermits, storedPermits + newPermits);\n        nextFreeTicketMicros = nowMicros;\n    }\n}", "repo_id": "5", "comment": "/**\n * Updates {@code storedPermits} and {@code nextFreeTicketMicros} based on the current time.\n */\n", "repo_name": "guava-master/", "id": 5516, "method_signature": "void resync(long)", "filename": "SmoothRateLimiter.resync.json"}
{"callee_method_names": [], "method_name": "SortedAsMap.keySet", "method_implementation": "{\n    SortedSet<K> result = sortedKeySet;\n    return (result == null) ? sortedKeySet = createKeySet() : result;\n}", "repo_id": "5", "comment": "// satisfy the SortedMap.keySet() interface\n", "repo_name": "guava-master/", "id": 5950, "method_signature": "SortedSet<K> keySet()", "filename": "SortedAsMap.keySet.json"}
{"callee_method_names": ["Comparator<?>.equals"], "method_name": "SortedIterables.hasSameComparator", "method_implementation": "{\n    checkNotNull(comparator);\n    checkNotNull(elements);\n    Comparator<?> comparator2;\n    if (elements instanceof SortedSet) {\n        comparator2 = comparator((SortedSet<?>) elements);\n    } else if (elements instanceof SortedIterable) {\n        comparator2 = ((SortedIterable<?>) elements).comparator();\n    } else {\n        return false;\n    }\n    return comparator.equals(comparator2);\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@code elements} is a sorted collection using an ordering equivalent to\n * {@code comparator}.\n */\n", "repo_name": "guava-master/", "id": 6373, "method_signature": "boolean hasSameComparator(Comparator, Iterable)", "filename": "SortedIterables.hasSameComparator.json"}
{"callee_method_names": ["List<? extends E>.size", "Comparator<? super E>.compare", "List<? extends E>.get", "KeyPresentBehavior.resultIndex", "List<? extends E>.subList", "KeyAbsentBehavior.resultIndex"], "method_name": "SortedLists.binarySearch", "method_implementation": "{\n    checkNotNull(comparator);\n    checkNotNull(list);\n    checkNotNull(presentBehavior);\n    checkNotNull(absentBehavior);\n    if (!(list instanceof RandomAccess)) {\n        list = Lists.newArrayList(list);\n    }\n    // TODO(lowasser): benchmark when it's best to do a linear search\n    int lower = 0;\n    int upper = list.size() - 1;\n    while (lower <= upper) {\n        int middle = (lower + upper) >>> 1;\n        int c = comparator.compare(key, list.get(middle));\n        if (c < 0) {\n            upper = middle - 1;\n        } else if (c > 0) {\n            lower = middle + 1;\n        } else {\n            return lower + presentBehavior.resultIndex(comparator, key, list.subList(lower, upper + 1), middle - lower);\n        }\n    }\n    return absentBehavior.resultIndex(lower);\n}", "repo_id": "5", "comment": "/**\n * Searches the specified list for the specified object using the binary search algorithm. The\n * list must be sorted into ascending order according to the specified comparator (as by the\n * {@link Collections#sort(List, Comparator) Collections.sort(List, Comparator)} method), prior to\n * making this call. If it is not sorted, the results are undefined.\n *\n * <p>If there are elements in the list which compare as equal to the key, the choice of {@link\n * KeyPresentBehavior} decides which index is returned. If no elements compare as equal to the\n * key, the choice of {@link KeyAbsentBehavior} decides which index is returned.\n *\n * <p>This method runs in log(n) time on random-access lists, which offer near-constant-time\n * access to each list element.\n *\n * @param list the list to be searched.\n * @param key the value to be searched for.\n * @param comparator the comparator by which the list is ordered.\n * @param presentBehavior the specification for what to do if at least one element of the list\n *     compares as equal to the key.\n * @param absentBehavior the specification for what to do if no elements of the list compare as\n *     equal to the key.\n * @return the index determined by the {@code KeyPresentBehavior}, if the key is in the list;\n *     otherwise the index determined by the {@code KeyAbsentBehavior}.\n */\n", "repo_name": "guava-master/", "id": 5840, "method_signature": "int binarySearch(List, E, Comparator, KeyPresentBehavior, KeyAbsentBehavior)", "filename": "SortedLists.binarySearch.json"}
{"callee_method_names": ["SortedMap<K,V>.headMap", "SortedMap<K,V>.tailMap", "SortedMap<K,V>.subMap"], "method_name": "SortedMapSubmapTestMapGenerator.createSubMap", "method_implementation": "{\n    if (from == Bound.NO_BOUND && to == Bound.EXCLUSIVE) {\n        return map.headMap(lastExclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.NO_BOUND) {\n        return map.tailMap(firstInclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.EXCLUSIVE) {\n        return map.subMap(firstInclusive, lastExclusive);\n    } else {\n        throw new IllegalArgumentException();\n    }\n}", "repo_id": "5", "comment": "/**\n * Calls the smallest subMap overload that filters out the extreme values. This method is\n * overridden in NavigableMapTestSuiteBuilder.\n */\n", "repo_name": "guava-master/", "id": 4153, "method_signature": "SortedMap<K,V> createSubMap(SortedMap, K, K)", "filename": "SortedMapSubmapTestMapGenerator.createSubMap.json"}
{"callee_method_names": ["FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getSubjectGenerator", "List<Feature<?>>.add", "List<Feature<?>>.addAll", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getFeatures", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getName", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getSuppressedTests", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getSetUp", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>>.getTearDown"], "method_name": "SortedMapTestSuiteBuilder.createSubmapSuite", "method_implementation": "{\n    TestSortedMapGenerator<K, V> delegate = (TestSortedMapGenerator<K, V>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n    List<Feature<?>> features = new ArrayList<>();\n    features.add(NoRecurse.SUBMAP);\n    features.addAll(parentBuilder.getFeatures());\n    return newBuilderUsing(delegate, to, from).named(parentBuilder.getName() + \" subMap \" + from + \"-\" + to).withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).withSetUp(parentBuilder.getSetUp()).withTearDown(parentBuilder.getTearDown()).createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Creates a suite whose map has some elements filtered out of view.\n *\n * <p>Because the map may be ascending or descending, this test must derive the relative order of\n * these extreme values rather than relying on their regular sort ordering.\n */\n", "repo_name": "guava-master/", "id": 4154, "method_signature": "TestSuite createSubmapSuite(FeatureSpecificTestSuiteBuilder, Bound, Bound)", "filename": "SortedMapTestSuiteBuilder.createSubmapSuite.json"}
{"callee_method_names": ["List<String>.add", "List<String>.add", "List<String>.add", "List<String>.add"], "method_name": "SortedMultisetTestSuiteBuilder.getExtremeValues", "method_implementation": "{\n    List<String> result = new ArrayList<>();\n    result.add(\"!! a\");\n    result.add(\"!! b\");\n    result.add(\"~~ y\");\n    result.add(\"~~ z\");\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns an array of four bogus elements that will always be too high or too low for the\n * display. This includes two values for each extreme.\n *\n * <p>This method (dangerously) assume that the strings {@code \"!! a\"} and {@code \"~~ z\"} will\n * work for this purpose, which may cause problems for navigable maps with non-string or unicode\n * generators.\n */\n", "repo_name": "guava-master/", "id": 4168, "method_signature": "List<String> getExtremeValues()", "filename": "SortedMultisetTestSuiteBuilder.getExtremeValues.json"}
{"callee_method_names": ["SortedSet<E>.headSet", "SortedSet<E>.tailSet", "SortedSet<E>.subSet"], "method_name": "SortedSetSubsetTestSetGenerator.createSubSet", "method_implementation": "{\n    if (from == Bound.NO_BOUND && to == Bound.EXCLUSIVE) {\n        return set.headSet(lastExclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.NO_BOUND) {\n        return set.tailSet(firstInclusive);\n    } else if (from == Bound.INCLUSIVE && to == Bound.EXCLUSIVE) {\n        return set.subSet(firstInclusive, lastExclusive);\n    } else {\n        throw new IllegalArgumentException();\n    }\n}", "repo_id": "5", "comment": "/**\n * Calls the smallest subSet overload that filters out the extreme values.\n */\n", "repo_name": "guava-master/", "id": 4152, "method_signature": "SortedSet<E> createSubSet(SortedSet, E, E)", "filename": "SortedSetSubsetTestSetGenerator.createSubSet.json"}
{"callee_method_names": ["FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getSubjectGenerator", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getFeatures", "List<Feature<?>>.remove", "List<Feature<?>>.add", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getName", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getSuppressedTests", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getSetUp", "FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Collection<E>,E>>.getTearDown"], "method_name": "SortedSetTestSuiteBuilder.createSubsetSuite", "method_implementation": "{\n    TestSortedSetGenerator<E> delegate = (TestSortedSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n    List<Feature<?>> features = new ArrayList<>(parentBuilder.getFeatures());\n    features.remove(CollectionFeature.ALLOWS_NULL_VALUES);\n    features.add(CollectionFeature.SUBSET_VIEW);\n    return newBuilderUsing(delegate, to, from).named(parentBuilder.getName() + \" subSet \" + from + \"-\" + to).withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).withSetUp(parentBuilder.getSetUp()).withTearDown(parentBuilder.getTearDown()).createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Creates a suite whose set has some elements filtered out of view.\n *\n * <p>Because the set may be ascending or descending, this test must derive the relative order of\n * these extreme values rather than relying on their regular sort ordering.\n */\n", "repo_name": "guava-master/", "id": 4235, "method_signature": "TestSuite createSubsetSuite(FeatureSpecificTestSuiteBuilder, Bound, Bound)", "filename": "SortedSetTestSuiteBuilder.createSubsetSuite.json"}
{"callee_method_names": ["Supplier<Spliterator.OfDouble>.get", "Supplier<Spliterator.OfDouble>.get"], "method_name": "SpliteratorTester.ofDouble", "method_implementation": "{\n    return new SpliteratorTester<>(ImmutableSet.of(() -> new GeneralSpliteratorOfObject<>(spliteratorSupplier.get()), () -> new GeneralSpliteratorOfPrimitive<>(spliteratorSupplier.get(), c -> c::accept)));\n}", "repo_id": "5", "comment": "/**\n * @since 28.1\n */\n", "repo_name": "guava-master/", "id": 745, "method_signature": "SpliteratorTester<Double> ofDouble(Supplier)", "filename": "SpliteratorTester.ofDouble.json"}
{"callee_method_names": ["Supplier<Spliterator.OfInt>.get", "Supplier<Spliterator.OfInt>.get"], "method_name": "SpliteratorTester.ofInt", "method_implementation": "{\n    return new SpliteratorTester<>(ImmutableSet.of(() -> new GeneralSpliteratorOfObject<>(spliteratorSupplier.get()), () -> new GeneralSpliteratorOfPrimitive<>(spliteratorSupplier.get(), c -> c::accept)));\n}", "repo_id": "5", "comment": "/**\n * @since 28.1\n */\n", "repo_name": "guava-master/", "id": 743, "method_signature": "SpliteratorTester<Integer> ofInt(Supplier)", "filename": "SpliteratorTester.ofInt.json"}
{"callee_method_names": ["Supplier<Spliterator.OfLong>.get", "Supplier<Spliterator.OfLong>.get"], "method_name": "SpliteratorTester.ofLong", "method_implementation": "{\n    return new SpliteratorTester<>(ImmutableSet.of(() -> new GeneralSpliteratorOfObject<>(spliteratorSupplier.get()), () -> new GeneralSpliteratorOfPrimitive<>(spliteratorSupplier.get(), c -> c::accept)));\n}", "repo_id": "5", "comment": "/**\n * @since 28.1\n */\n", "repo_name": "guava-master/", "id": 744, "method_signature": "SpliteratorTester<Long> ofLong(Supplier)", "filename": "SpliteratorTester.ofLong.json"}
{"callee_method_names": ["CharSequence.length"], "method_name": "Splitter.fixedLength", "method_implementation": "{\n    checkArgument(length > 0, \"The length may not be less than 1\");\n    return new Splitter(new Strategy() {\n\n        @Override\n        public SplittingIterator iterator(final Splitter splitter, CharSequence toSplit) {\n            return new SplittingIterator(splitter, toSplit) {\n\n                @Override\n                public int separatorStart(int start) {\n                    int nextChunkStart = start + length;\n                    return (nextChunkStart < toSplit.length() ? nextChunkStart : -1);\n                }\n\n                @Override\n                public int separatorEnd(int separatorPosition) {\n                    return separatorPosition;\n                }\n            };\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Returns a splitter that divides strings into pieces of the given length. For example, {@code\n * Splitter.fixedLength(2).split(\"abcde\")} returns an iterable containing {@code [\"ab\", \"cd\",\n * \"e\"]}. The last piece can be smaller than {@code length} but will never be empty.\n *\n * <p><b>Note:</b> if {@link #fixedLength} is used in conjunction with {@link #limit}, the final\n * split piece <i>may be longer than the specified fixed length</i>. This is because the splitter\n * will <i>stop splitting when the limit is reached</i>, and just return the final piece as-is.\n *\n * <p><b>Exception:</b> for consistency with separator-based splitters, {@code split(\"\")} does not\n * yield an empty iterable, but an iterable containing {@code \"\"}. This is the only case in which\n * {@code Iterables.size(split(input))} does not equal {@code IntMath.divide(input.length(),\n * length, CEILING)}. To avoid this behavior, use {@code omitEmptyStrings}.\n *\n * @param length the desired length of pieces after splitting, a positive integer\n * @return a splitter, with default settings, that can split into fixed sized pieces\n * @throws IllegalArgumentException if {@code length} is zero or negative\n */\n", "repo_name": "guava-master/", "id": 4998, "method_signature": "Splitter fixedLength(int)", "filename": "Splitter.fixedLength.json"}
{"callee_method_names": [], "method_name": "Splitter.on", "method_implementation": "{\n    return onPatternInternal(new JdkPattern(separatorPattern));\n}", "repo_id": "5", "comment": "/**\n * Returns a splitter that considers any subsequence matching {@code pattern} to be a separator.\n * For example, {@code Splitter.on(Pattern.compile(\"\\r?\\n\")).split(entireFile)} splits a string\n * into lines whether it uses DOS-style or UNIX-style line terminators.\n *\n * @param separatorPattern the pattern that determines whether a subsequence is a separator. This\n *     pattern may not match the empty string.\n * @return a splitter, with default settings, that uses this pattern\n * @throws IllegalArgumentException if {@code separatorPattern} matches the empty string\n */\n", "repo_name": "guava-master/", "id": 4995, "method_signature": "Splitter on(Pattern)", "filename": "Splitter.on.json"}
{"callee_method_names": [], "method_name": "Splitter.onPattern", "method_implementation": "{\n    return onPatternInternal(Platform.compilePattern(separatorPattern));\n}", "repo_id": "5", "comment": "/**\n * Returns a splitter that considers any subsequence matching a given pattern (regular expression)\n * to be a separator. For example, {@code Splitter.onPattern(\"\\r?\\n\").split(entireFile)} splits a\n * string into lines whether it uses DOS-style or UNIX-style line terminators. This is equivalent\n * to {@code Splitter.on(Pattern.compile(pattern))}.\n *\n * @param separatorPattern the pattern that determines whether a subsequence is a separator. This\n *     pattern may not match the empty string.\n * @return a splitter, with default settings, that uses this pattern\n * @throws IllegalArgumentException if {@code separatorPattern} matches the empty string or is a\n *     malformed expression\n */\n", "repo_name": "guava-master/", "id": 4997, "method_signature": "Splitter onPattern(String)", "filename": "Splitter.onPattern.json"}
{"callee_method_names": ["CommonPattern.matcher", "CommonPattern.matcher", "CommonMatcher.find", "CommonMatcher.start", "CommonMatcher.end"], "method_name": "Splitter.onPatternInternal", "method_implementation": "{\n    checkArgument(!separatorPattern.matcher(\"\").matches(), \"The pattern may not match the empty string: %s\", separatorPattern);\n    return new Splitter(new Strategy() {\n\n        @Override\n        public SplittingIterator iterator(final Splitter splitter, CharSequence toSplit) {\n            final CommonMatcher matcher = separatorPattern.matcher(toSplit);\n            return new SplittingIterator(splitter, toSplit) {\n\n                @Override\n                public int separatorStart(int start) {\n                    return matcher.find(start) ? matcher.start() : -1;\n                }\n\n                @Override\n                public int separatorEnd(int separatorPosition) {\n                    return matcher.end();\n                }\n            };\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Internal utility; see {@link #on(Pattern)} instead.\n */\n", "repo_name": "guava-master/", "id": 4996, "method_signature": "Splitter onPatternInternal(CommonPattern)", "filename": "Splitter.onPatternInternal.json"}
{"callee_method_ids": [5001], "callee_method_names": ["Splitter.split", "Splitter.splittingIterator", "Iterator<String>.hasNext", "Iterator<String>.next", "Map<String, String>.containsKey", "Iterator<String>.hasNext", "Iterator<String>.next", "Map<String, String>.put", "Iterator<String>.hasNext"], "method_name": "Splitter.split", "method_implementation": "{\n    Map<String, String> map = new LinkedHashMap<>();\n    for (String entry : outerSplitter.split(sequence)) {\n        Iterator<String> entryFields = entrySplitter.splittingIterator(entry);\n        checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n        String key = entryFields.next();\n        checkArgument(!map.containsKey(key), \"Duplicate key [%s] found.\", key);\n        checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n        String value = entryFields.next();\n        map.put(key, value);\n        checkArgument(!entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n    }\n    return Collections.unmodifiableMap(map);\n}", "repo_id": "5", "comment": "/**\n * Splits {@code sequence} into substrings, splits each substring into an entry, and returns an\n * unmodifiable map with each of the entries. For example, {@code\n * Splitter.on(';').trimResults().withKeyValueSeparator(\"=>\").split(\"a=>b ; c=>b\")} will return\n * a mapping from {@code \"a\"} to {@code \"b\"} and {@code \"c\"} to {@code \"b\"}.\n *\n * <p>The returned map preserves the order of the entries from {@code sequence}.\n *\n * @throws IllegalArgumentException if the specified sequence does not split into valid map\n *     entries, or if there are duplicate keys\n */\n", "repo_name": "guava-master/", "id": 5001, "method_signature": "Map<String,String> split(CharSequence)", "filename": "Splitter.split.json"}
{"callee_method_names": ["Iterator<String>.hasNext", "List<String>.add", "Iterator<String>.next"], "method_name": "Splitter.splitToList", "method_implementation": "{\n    checkNotNull(sequence);\n    Iterator<String> iterator = splittingIterator(sequence);\n    List<String> result = new ArrayList<>();\n    while (iterator.hasNext()) {\n        result.add(iterator.next());\n    }\n    return Collections.unmodifiableList(result);\n}", "repo_id": "5", "comment": "/**\n * Splits {@code sequence} into string components and returns them as an immutable list. If you\n * want an {@link Iterable} which may be lazily evaluated, use {@link #split(CharSequence)}.\n *\n * @param sequence the sequence of characters to split\n * @return an immutable list of the segments split from the parameter\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 5000, "method_signature": "List<String> splitToList(CharSequence)", "filename": "Splitter.splitToList.json"}
{"callee_method_ids": [5001], "callee_method_names": ["Splitter.split", "StringBuilder.append", "Iterator<String>.next", "StringBuilder.append", "Iterator<String>.next", "StringBuilder.append", "Iterator<String>.next", "Iterator<String>.hasNext"], "method_name": "SplitterTest.assertSplitterIterableIsLazy", "method_implementation": "{\n    StringBuilder builder = new StringBuilder();\n    Iterator<String> iterator = splitter.split(builder).iterator();\n    builder.append(\"A,\");\n    assertEquals(\"A\", iterator.next());\n    builder.append(\"B,\");\n    assertEquals(\"B\", iterator.next());\n    builder.append(\"C\");\n    assertEquals(\"C\", iterator.next());\n    assertFalse(iterator.hasNext());\n}", "repo_id": "5", "comment": "/**\n * This test really pushes the boundaries of what we support. In general the splitter's behaviour\n * is not well defined if the char sequence it's splitting is mutated during iteration.\n */\n", "repo_name": "guava-master/", "id": 3695, "method_signature": "void assertSplitterIterableIsLazy(Splitter)", "filename": "SplitterTest.assertSplitterIterableIsLazy.json"}
{"callee_method_ids": [5000], "callee_method_names": ["Splitter.splitToList"], "method_name": "SplitterTest.testCharacterSimpleSplitToList", "method_implementation": "{\n    String simple = \"a,b,c\";\n    List<String> letters = COMMA_SPLITTER.splitToList(simple);\n    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n}", "repo_id": "5", "comment": "/**\n * All of the infrastructure of split and splitToString is identical, so we do one test of\n * splitToString. All other cases should be covered by testing of split.\n *\n * <p>TODO(user): It would be good to make all the relevant tests run on both split and\n * splitToString automatically.\n */\n", "repo_name": "guava-master/", "id": 3693, "method_signature": "void testCharacterSimpleSplitToList()", "filename": "SplitterTest.testCharacterSimpleSplitToList.json"}
{"callee_method_names": ["Splitter.withKeyValueSeparator"], "method_name": "SplitterTest.testMapSplitter_extraValueDelimiter", "method_implementation": "{\n    try {\n        COMMA_SPLITTER.withKeyValueSeparator(\"=\").split(\"a=1,c=2=\");\n        fail();\n    } catch (IllegalArgumentException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Testing the behavior in https://github.com/google/guava/issues/1900 - this behavior may want to\n * be changed?\n */\n", "repo_name": "guava-master/", "id": 3696, "method_signature": "void testMapSplitter_extraValueDelimiter()", "filename": "SplitterTest.testMapSplitter_extraValueDelimiter.json"}
{"callee_method_names": [], "method_name": "SplitterTest.testPatternSplitWithMultipleLetters", "method_implementation": "{\n    Iterable<String> testPatterningMotto = Splitter.onPattern(\"-\").split(\"Testing-rocks-Debugging-sucks\");\n    assertThat(testPatterningMotto).containsExactly(\"Testing\", \"rocks\", \"Debugging\", \"sucks\").inOrder();\n}", "repo_id": "5", "comment": "// intends to be testing?\n", "repo_name": "guava-master/", "id": 3694, "method_signature": "void testPatternSplitWithMultipleLetters()", "filename": "SplitterTest.testPatternSplitWithMultipleLetters.json"}
{"callee_method_names": ["GraphBuilder<String>.immutable", "GraphBuilder<String>.allowsSelfLoops", "ImmutableGraph.Builder<String>.build", "ImmutableGraph<String>.isDirected", "ImmutableGraph<String>.allowsSelfLoops", "ImmutableGraph<String>.nodeOrder"], "method_name": "StandardImmutableGraphAdditionalTest.immutableGraphBuilder_copiesGraphBuilder", "method_implementation": "{\n    GraphBuilder<String> graphBuilder = GraphBuilder.directed().allowsSelfLoops(true).<String>nodeOrder(ElementOrder.<String>natural());\n    ImmutableGraph.Builder<String> immutableGraphBuilder = graphBuilder.immutable();\n    // Update GraphBuilder, but this shouldn't impact immutableGraphBuilder\n    graphBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());\n    ImmutableGraph<String> emptyGraph = immutableGraphBuilder.build();\n    assertThat(emptyGraph.isDirected()).isTrue();\n    assertThat(emptyGraph.allowsSelfLoops()).isTrue();\n    assertThat(emptyGraph.nodeOrder()).isEqualTo(ElementOrder.<String>natural());\n}", "repo_id": "5", "comment": "/**\n * Tests that the ImmutableGraph.Builder doesn't change when the creating GraphBuilder changes.\n */\n", "repo_name": "guava-master/", "id": 4062, "method_signature": "void immutableGraphBuilder_copiesGraphBuilder()", "filename": "StandardImmutableGraphAdditionalTest.immutableGraphBuilder_copiesGraphBuilder.json"}
{"callee_method_names": ["MapIteratorCache<N, NetworkConnections<N, E>>.put"], "method_name": "StandardMutableNetwork.addNodeInternal", "method_implementation": "{\n    NetworkConnections<N, E> connections = newConnections();\n    checkState(nodeConnections.put(node, connections) == null);\n    return connections;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code node} to the graph and returns the associated {@link NetworkConnections}.\n *\n * @throws IllegalStateException if {@code node} is already present\n */\n", "repo_name": "guava-master/", "id": 6744, "method_signature": "NetworkConnections<N,E> addNodeInternal(N)", "filename": "StandardMutableNetwork.addNodeInternal.json"}
{"callee_method_names": ["MapIteratorCache<N, NetworkConnections<N, E>>.put"], "method_name": "StandardMutableValueGraph.addNodeInternal", "method_implementation": "{\n    GraphConnections<N, V> connections = newConnections();\n    checkState(nodeConnections.put(node, connections) == null);\n    return connections;\n}", "repo_id": "5", "comment": "/**\n * Adds {@code node} to the graph and returns the associated {@link GraphConnections}.\n *\n * @throws IllegalStateException if {@code node} is already present\n */\n", "repo_name": "guava-master/", "id": 6757, "method_signature": "GraphConnections<N,V> addNodeInternal(N)", "filename": "StandardMutableValueGraph.addNodeInternal.json"}
{"callee_method_names": [], "method_name": "StandardTable.columnKeySet", "method_implementation": "{\n    Set<C> result = columnKeySet;\n    return (result == null) ? columnKeySet = new ColumnKeySet() : result;\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p>The returned set has an iterator that does not support {@code remove()}.\n *\n * <p>The set's iterator traverses the columns of the first row, the columns of the second row,\n * etc., skipping any columns that have appeared previously.\n */\n", "repo_name": "guava-master/", "id": 6411, "method_signature": "Set<C> columnKeySet()", "filename": "StandardTable.columnKeySet.json"}
{"callee_method_names": [], "method_name": "StandardTable.get", "method_implementation": "{\n    // requireNonNull is safe because of the containsColumn check.\n    return containsColumn(key) ? column((C) requireNonNull(key)) : null;\n}", "repo_id": "5", "comment": "// has the correct type.\n", "repo_name": "guava-master/", "id": 6413, "method_signature": "Map<R,V> get(Object)", "filename": "StandardTable.get.json"}
{"callee_method_names": ["Map<C, V>.isEmpty", "Map<R, Map<C, V>>.remove"], "method_name": "StandardTable.maintainEmptyInvariant", "method_implementation": "{\n    updateBackingRowMapField();\n    if (backingRowMap != null && backingRowMap.isEmpty()) {\n        backingMap.remove(rowKey);\n        backingRowMap = null;\n    }\n}", "repo_id": "5", "comment": "// Call this every time we perform a removal.\n", "repo_name": "guava-master/", "id": 6409, "method_signature": "void maintainEmptyInvariant()", "filename": "StandardTable.maintainEmptyInvariant.json"}
{"callee_method_names": ["Map<R, Map<C, V>>.entrySet", "Iterator<Entry<R, Map<C, V>>>.hasNext", "Iterator<Entry<R, Map<C, V>>>.next", "Entry<R, Map<C, V>>.getValue", "Map<C, V>.get", "Predicate<? super Entry<R,V>>.apply", "Entry<R, Map<C, V>>.getKey", "Map<C, V>.remove", "Map<C, V>.isEmpty", "Iterator<Entry<R, Map<C, V>>>.remove"], "method_name": "StandardTable.removeFromColumnIf", "method_implementation": "{\n    boolean changed = false;\n    Iterator<Entry<R, Map<C, V>>> iterator = backingMap.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Entry<R, Map<C, V>> entry = iterator.next();\n        Map<C, V> map = entry.getValue();\n        V value = map.get(columnKey);\n        if (value != null && predicate.apply(Maps.immutableEntry(entry.getKey(), value))) {\n            map.remove(columnKey);\n            changed = true;\n            if (map.isEmpty()) {\n                iterator.remove();\n            }\n        }\n    }\n    return changed;\n}", "repo_id": "5", "comment": "/**\n * Removes all {@code Column} mappings whose row key and value satisfy the given predicate.\n */\n", "repo_name": "guava-master/", "id": 6410, "method_signature": "boolean removeFromColumnIf(Predicate)", "filename": "StandardTable.removeFromColumnIf.json"}
{"callee_method_names": [], "method_name": "StandardTable.removeMapping", "method_implementation": "{\n    if (containsMapping(rowKey, columnKey, value)) {\n        remove(rowKey, columnKey);\n        return true;\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Remove a row key / column key / value mapping, if present.\n */\n", "repo_name": "guava-master/", "id": 6408, "method_signature": "boolean removeMapping(Object, Object, Object)", "filename": "StandardTable.removeMapping.json"}
{"callee_method_names": [], "method_name": "StateSnapshot.externalState", "method_implementation": "{\n    if (shutdownWhenStartupFinishes && state == STARTING) {\n        return STOPPING;\n    } else {\n        return state;\n    }\n}", "repo_id": "5", "comment": "/**\n * @see Service#state()\n */\n", "repo_name": "guava-master/", "id": 5325, "method_signature": "State externalState()", "filename": "StateSnapshot.externalState.json"}
{"callee_method_names": [], "method_name": "StateSnapshot.failureCause", "method_implementation": "{\n    checkState(state == FAILED, \"failureCause() is only valid if the service has failed, service is %s\", state);\n    // requireNonNull is safe because the constructor requires a non-null cause with state=FAILED.\n    return requireNonNull(failure);\n}", "repo_id": "5", "comment": "/**\n * @see Service#failureCause()\n */\n", "repo_name": "guava-master/", "id": 5326, "method_signature": "Throwable failureCause()", "filename": "StateSnapshot.failureCause.json"}
{"callee_method_names": ["Object.getClass"], "method_name": "Stats.equals", "method_implementation": "{\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        return false;\n    }\n    Stats other = (Stats) obj;\n    return count == other.count && doubleToLongBits(mean) == doubleToLongBits(other.mean) && doubleToLongBits(sumOfSquaresOfDeltas) == doubleToLongBits(other.sumOfSquaresOfDeltas) && doubleToLongBits(min) == doubleToLongBits(other.min) && doubleToLongBits(max) == doubleToLongBits(other.max);\n}", "repo_id": "5", "comment": "/**\n * {@inheritDoc}\n *\n * <p><b>Note:</b> This tests exact equality of the calculated statistics, including the floating\n * point values. Two instances are guaranteed to be considered equal if one is copied from the\n * other using {@code second = new StatsAccumulator().addAll(first).snapshot()}, if both were\n * obtained by calling {@code snapshot()} on the same {@link StatsAccumulator} without adding any\n * values in between the two calls, or if one is obtained from the other after round-tripping\n * through java serialization. However, floating point rounding errors mean that it may be false\n * for some instances where the statistics are mathematically equal, including instances\n * constructed from the same values in a different order... or (in the general case) even in the\n * same order. (It is guaranteed to return true for instances constructed from the same values in\n * the same order if {@code strictfp} is in effect, or if the system architecture guarantees\n * {@code strictfp}-like semantics.)\n */\n", "repo_name": "guava-master/", "id": 4601, "method_signature": "boolean equals(Object)", "filename": "Stats.equals.json"}
{"callee_method_names": [], "method_name": "Stats.fromByteArray", "method_implementation": "{\n    checkNotNull(byteArray);\n    checkArgument(byteArray.length == BYTES, \"Expected Stats.BYTES = %s remaining , got %s\", BYTES, byteArray.length);\n    return readFrom(ByteBuffer.wrap(byteArray).order(ByteOrder.LITTLE_ENDIAN));\n}", "repo_id": "5", "comment": "/**\n * Creates a Stats instance from the given byte representation which was obtained by {@link\n * #toByteArray}.\n *\n * <p><b>Note:</b> No guarantees are made regarding stability of the representation between\n * versions.\n */\n", "repo_name": "guava-master/", "id": 4608, "method_signature": "Stats fromByteArray(byte[])", "filename": "Stats.fromByteArray.json"}
{"callee_method_names": [], "method_name": "Stats.meanOf", "method_implementation": "{\n    checkArgument(values.length > 0);\n    double mean = values[0];\n    for (int index = 1; index < values.length; index++) {\n        double value = values[index];\n        if (isFinite(value) && isFinite(mean)) {\n            // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)\n            mean += (value - mean) / (index + 1);\n        } else {\n            mean = calculateNewMeanNonFinite(mean, value);\n        }\n    }\n    return mean;\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of the\n * values. The count must be non-zero.\n *\n * <p>The definition of the mean is the same as {@link Stats#mean}.\n *\n * @param values a series of values, which will be converted to {@code double} values (this may\n *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n * @throws IllegalArgumentException if the dataset is empty\n */\n", "repo_name": "guava-master/", "id": 4605, "method_signature": "double meanOf(long[])", "filename": "Stats.meanOf.json"}
{"callee_method_ids": [4645], "callee_method_names": ["StatsAccumulator.addAll", "StatsAccumulator.snapshot"], "method_name": "Stats.of", "method_implementation": "{\n    StatsAccumulator accumulator = new StatsAccumulator();\n    accumulator.addAll(values);\n    return accumulator.snapshot();\n}", "repo_id": "5", "comment": "/**\n * Returns statistics over a dataset containing the given values.\n *\n * @param values a series of values, which will be converted to {@code double} values (this may\n *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n */\n", "repo_name": "guava-master/", "id": 4598, "method_signature": "Stats of(long[])", "filename": "Stats.of.json"}
{"callee_method_names": [], "method_name": "Stats.populationVariance", "method_implementation": "{\n    checkState(count > 0);\n    if (isNaN(sumOfSquaresOfDeltas)) {\n        return NaN;\n    }\n    if (count == 1) {\n        return 0.0;\n    }\n    return ensureNonNegative(sumOfSquaresOfDeltas) / count();\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Population_variance\">population\n * variance</a> of the values. The count must be non-zero.\n *\n * <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It\n * is not guaranteed to return zero when the dataset consists of the same value multiple times,\n * due to numerical errors. However, it is guaranteed never to return a negative result.\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n *\n * @throws IllegalStateException if the dataset is empty\n */\n", "repo_name": "guava-master/", "id": 4599, "method_signature": "double populationVariance()", "filename": "Stats.populationVariance.json"}
{"callee_method_names": ["ByteBuffer.remaining", "ByteBuffer.remaining", "ByteBuffer.getLong", "ByteBuffer.getDouble", "ByteBuffer.getDouble", "ByteBuffer.getDouble", "ByteBuffer.getDouble"], "method_name": "Stats.readFrom", "method_implementation": "{\n    checkNotNull(buffer);\n    checkArgument(buffer.remaining() >= BYTES, \"Expected at least Stats.BYTES = %s remaining , got %s\", BYTES, buffer.remaining());\n    return new Stats(buffer.getLong(), buffer.getDouble(), buffer.getDouble(), buffer.getDouble(), buffer.getDouble());\n}", "repo_id": "5", "comment": "/**\n * Creates a Stats instance from the byte representation read from the given {@link ByteBuffer}.\n *\n * <p><b>Note:</b> No guarantees are made regarding stability of the representation between\n * versions.\n *\n * @param buffer A {@link ByteBuffer} with at least BYTES {@link ByteBuffer#remaining}, ordered as\n *     {@link ByteOrder#LITTLE_ENDIAN}, from which a BYTES-long byte representation of this\n *     instance is read. In the process increases the position of {@link ByteBuffer} by BYTES.\n */\n", "repo_name": "guava-master/", "id": 4609, "method_signature": "Stats readFrom(ByteBuffer)", "filename": "Stats.readFrom.json"}
{"callee_method_names": [], "method_name": "Stats.sampleVariance", "method_implementation": "{\n    checkState(count > 1);\n    if (isNaN(sumOfSquaresOfDeltas)) {\n        return NaN;\n    }\n    return ensureNonNegative(sumOfSquaresOfDeltas) / (count - 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Sample_variance\">unbiased sample\n * variance</a> of the values. If this dataset is a sample drawn from a population, this is an\n * unbiased estimator of the population variance of the population. The count must be greater than\n * one.\n *\n * <p>This is not guaranteed to return zero when the dataset consists of the same value multiple\n * times, due to numerical errors. However, it is guaranteed never to return a negative result.\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n *\n * @throws IllegalStateException if the dataset is empty or contains a single value\n */\n", "repo_name": "guava-master/", "id": 4600, "method_signature": "double sampleVariance()", "filename": "Stats.sampleVariance.json"}
{"callee_method_names": ["ByteBuffer.array"], "method_name": "Stats.toByteArray", "method_implementation": "{\n    ByteBuffer buff = ByteBuffer.allocate(BYTES).order(ByteOrder.LITTLE_ENDIAN);\n    writeTo(buff);\n    return buff.array();\n}", "repo_id": "5", "comment": "/**\n * Gets a byte array representation of this instance.\n *\n * <p><b>Note:</b> No guarantees are made regarding stability of the representation between\n * versions.\n */\n", "repo_name": "guava-master/", "id": 4606, "method_signature": "byte[] toByteArray()", "filename": "Stats.toByteArray.json"}
{"callee_method_names": ["double.add", "double.doubleValue"], "method_name": "Stats.toStats", "method_implementation": "{\n    return Collector.of(StatsAccumulator::new, (a, x) -> a.add(x.doubleValue()), (l, r) -> {\n        l.addAll(r);\n        return l;\n    }, StatsAccumulator::snapshot, Collector.Characteristics.UNORDERED);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} which accumulates statistics from a {@link java.util.stream.Stream}\n * of any type of boxed {@link Number} into a {@link Stats}. Use by calling {@code\n * boxedNumericStream.collect(toStats())}. The numbers will be converted to {@code double} values\n * (which may cause loss of precision).\n *\n * <p>If you have any of the primitive streams {@code DoubleStream}, {@code IntStream}, or {@code\n * LongStream}, you should use the factory method {@link #of} instead.\n *\n * @since 28.2\n */\n", "repo_name": "guava-master/", "id": 1166, "method_signature": "Collector<Number,StatsAccumulator,Stats> toStats()", "filename": "Stats.toStats.json"}
{"callee_method_names": ["ByteBuffer.remaining", "ByteBuffer.remaining", "ByteBuffer.putLong"], "method_name": "Stats.writeTo", "method_implementation": "{\n    checkNotNull(buffer);\n    checkArgument(buffer.remaining() >= BYTES, \"Expected at least Stats.BYTES = %s remaining , got %s\", BYTES, buffer.remaining());\n    buffer.putLong(count).putDouble(mean).putDouble(sumOfSquaresOfDeltas).putDouble(min).putDouble(max);\n}", "repo_id": "5", "comment": "/**\n * Writes to the given {@link ByteBuffer} a byte representation of this instance.\n *\n * <p><b>Note:</b> No guarantees are made regarding stability of the representation between\n * versions.\n *\n * @param buffer A {@link ByteBuffer} with at least BYTES {@link ByteBuffer#remaining}, ordered as\n *     {@link ByteOrder#LITTLE_ENDIAN}, to which a BYTES-long byte representation of this instance\n *     is written. In the process increases the position of {@link ByteBuffer} by BYTES.\n */\n", "repo_name": "guava-master/", "id": 4607, "method_signature": "void writeTo(ByteBuffer)", "filename": "Stats.writeTo.json"}
{"callee_method_names": [], "method_name": "StatsAccumulator.add", "method_implementation": "{\n    if (count == 0) {\n        count = 1;\n        mean = value;\n        min = value;\n        max = value;\n        if (!isFinite(value)) {\n            sumOfSquaresOfDeltas = NaN;\n        }\n    } else {\n        count++;\n        if (isFinite(value) && isFinite(mean)) {\n            // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15) and (16)\n            double delta = value - mean;\n            mean += delta / count;\n            sumOfSquaresOfDeltas += delta * (value - mean);\n        } else {\n            mean = calculateNewMeanNonFinite(mean, value);\n            sumOfSquaresOfDeltas = NaN;\n        }\n        min = Math.min(min, value);\n        max = Math.max(max, value);\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds the given value to the dataset.\n */\n", "repo_name": "guava-master/", "id": 4638, "method_signature": "void add(double)", "filename": "StatsAccumulator.add.json"}
{"callee_method_names": ["StatsAccumulator.count", "StatsAccumulator.count", "StatsAccumulator.mean", "StatsAccumulator.sumOfSquaresOfDeltas", "StatsAccumulator.min", "StatsAccumulator.max"], "method_name": "StatsAccumulator.addAll", "method_implementation": "{\n    if (values.count() == 0) {\n        return;\n    }\n    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());\n}", "repo_id": "5", "comment": "/**\n * Adds the given statistics to the dataset, as if the individual values used to compute the\n * statistics had been added directly.\n *\n * @since 28.2\n */\n", "repo_name": "guava-master/", "id": 4645, "method_signature": "void addAll(StatsAccumulator)", "filename": "StatsAccumulator.addAll.json"}
{"callee_method_names": [], "method_name": "StatsAccumulator.calculateNewMeanNonFinite", "method_implementation": "{\n    /*\n     * Desired behaviour is to match the results of applying the naive mean formula. In particular,\n     * the update formula can subtract infinities in cases where the naive formula would add them.\n     *\n     * Consequently:\n     * 1. If the previous mean is finite and the new value is non-finite then the new mean is that\n     *    value (whether it is NaN or infinity).\n     * 2. If the new value is finite and the previous mean is non-finite then the mean is unchanged\n     *    (whether it is NaN or infinity).\n     * 3. If both the previous mean and the new value are non-finite and...\n     * 3a. ...either or both is NaN (so mean != value) then the new mean is NaN.\n     * 3b. ...they are both the same infinities (so mean == value) then the mean is unchanged.\n     * 3c. ...they are different infinities (so mean != value) then the new mean is NaN.\n     */\n    if (isFinite(previousMean)) {\n        // This is case 1.\n        return value;\n    } else if (isFinite(value) || previousMean == value) {\n        // This is case 2. or 3b.\n        return previousMean;\n    } else {\n        // This is case 3a. or 3c.\n        return NaN;\n    }\n}", "repo_id": "5", "comment": "/**\n * Calculates the new value for the accumulated mean when a value is added, in the case where at\n * least one of the previous mean and the value is non-finite.\n */\n", "repo_name": "guava-master/", "id": 4648, "method_signature": "double calculateNewMeanNonFinite(double, double)", "filename": "StatsAccumulator.calculateNewMeanNonFinite.json"}
{"callee_method_names": [], "method_name": "StatsAccumulator.populationVariance", "method_implementation": "{\n    checkState(count != 0);\n    if (isNaN(sumOfSquaresOfDeltas)) {\n        return NaN;\n    }\n    if (count == 1) {\n        return 0.0;\n    }\n    return ensureNonNegative(sumOfSquaresOfDeltas) / count;\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Population_variance\">population\n * variance</a> of the values. The count must be non-zero.\n *\n * <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It\n * is not guaranteed to return zero when the dataset consists of the same value multiple times,\n * due to numerical errors. However, it is guaranteed never to return a negative result.\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n *\n * @throws IllegalStateException if the dataset is empty\n */\n", "repo_name": "guava-master/", "id": 4646, "method_signature": "double populationVariance()", "filename": "StatsAccumulator.populationVariance.json"}
{"callee_method_names": [], "method_name": "StatsAccumulator.sampleVariance", "method_implementation": "{\n    checkState(count > 1);\n    if (isNaN(sumOfSquaresOfDeltas)) {\n        return NaN;\n    }\n    return ensureNonNegative(sumOfSquaresOfDeltas) / (count - 1);\n}", "repo_id": "5", "comment": "/**\n * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Sample_variance\">unbiased sample\n * variance</a> of the values. If this dataset is a sample drawn from a population, this is an\n * unbiased estimator of the population variance of the population. The count must be greater than\n * one.\n *\n * <p>This is not guaranteed to return zero when the dataset consists of the same value multiple\n * times, due to numerical errors. However, it is guaranteed never to return a negative result.\n *\n * <h3>Non-finite values</h3>\n *\n * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n *\n * @throws IllegalStateException if the dataset is empty or contains a single value\n */\n", "repo_name": "guava-master/", "id": 4647, "method_signature": "double sampleVariance()", "filename": "StatsAccumulator.sampleVariance.json"}
{"callee_method_names": ["LinearTransformation.isHorizontal", "LinearTransformation.isVertical", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.transform", "LinearTransformation.transform", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.slope", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.inverse"], "method_name": "StatsTesting.assertDiagonalLinearTransformation", "method_implementation": "{\n    checkArgument(xDelta != 0.0);\n    checkArgument(yDelta != 0.0);\n    assertThat(transformation.isHorizontal()).isFalse();\n    assertThat(transformation.isVertical()).isFalse();\n    assertThat(transformation.inverse().isHorizontal()).isFalse();\n    assertThat(transformation.inverse().isVertical()).isFalse();\n    assertThat(transformation.transform(x1)).isWithin(ALLOWED_ERROR).of(y1);\n    assertThat(transformation.transform(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);\n    assertThat(transformation.inverse().transform(y1)).isWithin(ALLOWED_ERROR).of(x1);\n    assertThat(transformation.inverse().transform(y1 + yDelta)).isWithin(ALLOWED_ERROR).of(x1 + xDelta);\n    assertThat(transformation.slope()).isWithin(ALLOWED_ERROR).of(yDelta / xDelta);\n    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(xDelta / yDelta);\n    assertThat(transformation.inverse()).isSameInstanceAs(transformation.inverse());\n    assertThat(transformation.inverse().inverse()).isSameInstanceAs(transformation);\n}", "repo_id": "5", "comment": "/**\n * Asserts that {@code transformation} is diagonal (i.e. neither horizontal nor vertical) and\n * passes through both {@code (x1, y1)} and {@code (x1 + xDelta, y1 + yDelta)}. Includes\n * assertions about all the public instance methods of {@link LinearTransformation} (on both\n * {@code transformation} and its inverse). Since the transformation is expected to be diagonal,\n * neither {@code xDelta} nor {@code yDelta} may be zero.\n */\n", "repo_name": "guava-master/", "id": 3567, "method_signature": "void assertDiagonalLinearTransformation(LinearTransformation, double, double, double, double)", "filename": "StatsTesting.assertDiagonalLinearTransformation.json"}
{"callee_method_names": ["LinearTransformation.isHorizontal", "LinearTransformation.isVertical", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.transform", "LinearTransformation.transform", "LinearTransformation.inverse", "LinearTransformation.slope", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.inverse"], "method_name": "StatsTesting.assertHorizontalLinearTransformation", "method_implementation": "{\n    assertThat(transformation.isHorizontal()).isTrue();\n    assertThat(transformation.isVertical()).isFalse();\n    assertThat(transformation.inverse().isHorizontal()).isFalse();\n    assertThat(transformation.inverse().isVertical()).isTrue();\n    assertThat(transformation.transform(-1.0)).isWithin(ALLOWED_ERROR).of(y);\n    assertThat(transformation.transform(1.0)).isWithin(ALLOWED_ERROR).of(y);\n    try {\n        transformation.inverse().transform(0.0);\n        fail(\"Expected IllegalStateException\");\n    } catch (IllegalStateException expected) {\n    }\n    assertThat(transformation.slope()).isWithin(ALLOWED_ERROR).of(0.0);\n    try {\n        transformation.inverse().slope();\n        fail(\"Expected IllegalStateException\");\n    } catch (IllegalStateException expected) {\n    }\n    assertThat(transformation.inverse()).isSameInstanceAs(transformation.inverse());\n    assertThat(transformation.inverse().inverse()).isSameInstanceAs(transformation);\n}", "repo_id": "5", "comment": "/**\n * Asserts that {@code transformation} is horizontal with the given value of {@code y}. Includes\n * assertions about all the public instance methods of {@link LinearTransformation}, including an\n * assertion that {@link LinearTransformation#transform} and {@link LinearTransformation#slope} on\n * its inverse throws as expected.\n */\n", "repo_name": "guava-master/", "id": 3568, "method_signature": "void assertHorizontalLinearTransformation(LinearTransformation, double)", "filename": "StatsTesting.assertHorizontalLinearTransformation.json"}
{"callee_method_names": ["LinearTransformation.isHorizontal", "LinearTransformation.isVertical", "LinearTransformation.slope", "LinearTransformation.transform", "LinearTransformation.inverse"], "method_name": "StatsTesting.assertLinearTransformationNaN", "method_implementation": "{\n    assertThat(transformation.isHorizontal()).isFalse();\n    assertThat(transformation.isVertical()).isFalse();\n    assertThat(transformation.slope()).isNaN();\n    assertThat(transformation.transform(0.0)).isNaN();\n    assertThat(transformation.inverse()).isSameInstanceAs(transformation);\n}", "repo_id": "5", "comment": "/**\n * Asserts that {@code transformation} behaves as expected for {@link\n * LinearTransformation#forNaN}.\n */\n", "repo_name": "guava-master/", "id": 3570, "method_signature": "void assertLinearTransformationNaN(LinearTransformation)", "filename": "StatsTesting.assertLinearTransformationNaN.json"}
{"callee_method_names": ["LinearTransformation.isHorizontal", "LinearTransformation.isVertical", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.transform", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.slope", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.inverse", "LinearTransformation.inverse"], "method_name": "StatsTesting.assertVerticalLinearTransformation", "method_implementation": "{\n    assertThat(transformation.isHorizontal()).isFalse();\n    assertThat(transformation.isVertical()).isTrue();\n    assertThat(transformation.inverse().isHorizontal()).isTrue();\n    assertThat(transformation.inverse().isVertical()).isFalse();\n    try {\n        transformation.transform(0.0);\n        fail(\"Expected IllegalStateException\");\n    } catch (IllegalStateException expected) {\n    }\n    assertThat(transformation.inverse().transform(-1.0)).isWithin(ALLOWED_ERROR).of(x);\n    assertThat(transformation.inverse().transform(1.0)).isWithin(ALLOWED_ERROR).of(x);\n    try {\n        transformation.slope();\n        fail(\"Expected IllegalStateException\");\n    } catch (IllegalStateException expected) {\n    }\n    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(0.0);\n    assertThat(transformation.inverse()).isSameInstanceAs(transformation.inverse());\n    assertThat(transformation.inverse().inverse()).isSameInstanceAs(transformation);\n}", "repo_id": "5", "comment": "/**\n * Asserts that {@code transformation} is vertical with the given value of {@code x}. Includes\n * assertions about all the public instance methods of {@link LinearTransformation}, including\n * assertions that {@link LinearTransformation#slope} and {@link LinearTransformation#transform}\n * throw as expected.\n */\n", "repo_name": "guava-master/", "id": 3569, "method_signature": "void assertVerticalLinearTransformation(LinearTransformation, double)", "filename": "StatsTesting.assertVerticalLinearTransformation.json"}
{"callee_method_ids": [4590], "callee_method_names": ["List<Double>.size", "List<Double>.size", "List<Double>.size", "PairedStatsAccumulator.add", "List<Double>.get", "List<Double>.get"], "method_name": "StatsTesting.createFilledPairedStatsAccumulator", "method_implementation": "{\n    checkArgument(xValues.size() == yValues.size());\n    PairedStatsAccumulator accumulator = new PairedStatsAccumulator();\n    for (int index = 0; index < xValues.size(); index++) {\n        accumulator.add(xValues.get(index), yValues.get(index));\n    }\n    return accumulator;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link PairedStatsAccumulator} filled with the given lists of {@code x} and {@code y}\n * values, which must be of the same size.\n */\n", "repo_name": "guava-master/", "id": 3571, "method_signature": "PairedStatsAccumulator createFilledPairedStatsAccumulator(List, List)", "filename": "StatsTesting.createFilledPairedStatsAccumulator.json"}
{"callee_method_ids": [4591], "callee_method_names": ["List<Double>.size", "List<Double>.size", "List<List<Double>>.size", "PairedStatsAccumulator.addAll", "List<List<Double>>.get", "List<List<Double>>.get"], "method_name": "StatsTesting.createPartitionedFilledPairedStatsAccumulator", "method_implementation": "{\n    checkArgument(xValues.size() == yValues.size());\n    checkArgument(partitionSize > 0);\n    PairedStatsAccumulator accumulator = new PairedStatsAccumulator();\n    List<List<Double>> xPartitions = Lists.partition(xValues, partitionSize);\n    List<List<Double>> yPartitions = Lists.partition(yValues, partitionSize);\n    for (int index = 0; index < xPartitions.size(); index++) {\n        accumulator.addAll(createPairedStatsOf(xPartitions.get(index), yPartitions.get(index)));\n    }\n    return accumulator;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link PairedStatsAccumulator} filled with the given lists of {@code x} and {@code y}\n * values, which must be of the same size, added in groups of {@code partitionSize} using {@link\n * PairedStatsAccumulator#addAll(PairedStats)}.\n */\n", "repo_name": "guava-master/", "id": 3572, "method_signature": "PairedStatsAccumulator createPartitionedFilledPairedStatsAccumulator(List, List, int)", "filename": "StatsTesting.createPartitionedFilledPairedStatsAccumulator.json"}
{"callee_method_names": [], "method_name": "Stopwatch.elapsed", "method_implementation": "{\n    return Duration.ofNanos(elapsedNanos());\n}", "repo_id": "5", "comment": "/**\n * Returns the current elapsed time shown on this stopwatch as a {@link Duration}. Unlike {@link\n * #elapsed(TimeUnit)}, this method does not lose any precision due to rounding.\n *\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 1784, "method_signature": "Duration elapsed()", "filename": "Stopwatch.elapsed.json"}
{"callee_method_names": [], "method_name": "Stopwatch.reset", "method_implementation": "{\n    elapsedNanos = 0;\n    isRunning = false;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the elapsed time for this stopwatch to zero, and places it in a stopped state.\n *\n * @return this {@code Stopwatch} instance\n */\n", "repo_name": "guava-master/", "id": 5189, "method_signature": "Stopwatch reset()", "filename": "Stopwatch.reset.json"}
{"callee_method_names": ["Ticker.read"], "method_name": "Stopwatch.start", "method_implementation": "{\n    checkState(!isRunning, \"This stopwatch is already running.\");\n    isRunning = true;\n    startTick = ticker.read();\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Starts the stopwatch.\n *\n * @return this {@code Stopwatch} instance\n * @throws IllegalStateException if the stopwatch is already running.\n */\n", "repo_name": "guava-master/", "id": 5187, "method_signature": "Stopwatch start()", "filename": "Stopwatch.start.json"}
{"callee_method_names": ["Ticker.read"], "method_name": "Stopwatch.stop", "method_implementation": "{\n    long tick = ticker.read();\n    checkState(isRunning, \"This stopwatch is already stopped.\");\n    isRunning = false;\n    elapsedNanos += tick - startTick;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Stops the stopwatch. Future reads will return the fixed duration that had elapsed up to this\n * point.\n *\n * @return this {@code Stopwatch} instance\n * @throws IllegalStateException if the stopwatch is already stopped.\n */\n", "repo_name": "guava-master/", "id": 5188, "method_signature": "Stopwatch stop()", "filename": "Stopwatch.stop.json"}
{"callee_method_names": [], "method_name": "Stopwatch.toString", "method_implementation": "{\n    long nanos = elapsedNanos();\n    TimeUnit unit = chooseUnit(nanos);\n    double value = (double) nanos / NANOSECONDS.convert(1, unit);\n    // Too bad this functionality is not exposed as a regular method call\n    return Platform.formatCompact4Digits(value) + \" \" + abbreviate(unit);\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of the current elapsed time.\n */\n", "repo_name": "guava-master/", "id": 5190, "method_signature": "String toString()", "filename": "Stopwatch.toString.json"}
{"callee_method_names": ["ObjectOutputStream.isParallel", "ObjectOutputStream.spliterator", "ImmutableList.Builder<Spliterator.OfDouble>.add", "Spliterator.OfDouble.characteristics", "Spliterator.OfDouble.estimateSize", "ImmutableList.Builder<Spliterator.OfDouble>.build"], "method_name": "Streams.concat", "method_implementation": "{\n    boolean isParallel = false;\n    int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL;\n    long estimatedSize = 0L;\n    ImmutableList.Builder<Spliterator.OfDouble> splitrsBuilder = new ImmutableList.Builder<>(streams.length);\n    for (DoubleStream stream : streams) {\n        isParallel |= stream.isParallel();\n        Spliterator.OfDouble splitr = stream.spliterator();\n        splitrsBuilder.add(splitr);\n        characteristics &= splitr.characteristics();\n        estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());\n    }\n    return StreamSupport.doubleStream(CollectSpliterators.flatMapToDouble(splitrsBuilder.build().spliterator(), splitr -> splitr, characteristics, estimatedSize), isParallel).onClose(() -> closeAll(streams));\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link DoubleStream} containing the elements of the first stream, followed by the\n * elements of the second stream, and so on.\n *\n * <p>This is equivalent to {@code Stream.of(streams).flatMapToDouble(stream -> stream)}, but the\n * returned stream may perform better.\n *\n * @see DoubleStream#concat(DoubleStream, DoubleStream)\n */\n", "repo_name": "guava-master/", "id": 3133, "method_signature": "DoubleStream concat(DoubleStream[])", "filename": "Streams.concat.json"}
{"callee_method_names": ["DoubleStream.boxed", "java.util.Optional<Double>.map"], "method_name": "Streams.findLast", "method_implementation": "{\n    // findLast(Stream) does some allocation, so we might as well box some more\n    java.util.Optional<Double> boxedLast = findLast(stream.boxed());\n    return boxedLast.map(OptionalDouble::of).orElse(OptionalDouble.empty());\n}", "repo_id": "5", "comment": "/**\n * Returns the last element of the specified stream, or {@link OptionalDouble#empty} if the stream\n * is empty.\n *\n * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n * method's runtime will be between O(log n) and O(n), performing better on <a\n * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n * streams.\n *\n * @see DoubleStream#findFirst()\n * @throws NullPointerException if the last element of the stream is null\n */\n", "repo_name": "guava-master/", "id": 3143, "method_signature": "OptionalDouble findLast(DoubleStream)", "filename": "Streams.findLast.json"}
{"callee_method_names": ["Stream<A>.isParallel", "Stream<B>.isParallel", "BiConsumer<? super A,? super B>.accept", "Stream<A>.iterator", "Stream<B>.iterator", "Iterator<A>.hasNext", "Iterator<B>.hasNext", "BiConsumer<? super A,? super B>.accept", "Iterator<A>.next", "Iterator<B>.next"], "method_name": "Streams.forEachPair", "method_implementation": "{\n    checkNotNull(consumer);\n    if (streamA.isParallel() || streamB.isParallel()) {\n        zip(streamA, streamB, TemporaryPair::new).forEach(pair -> consumer.accept(pair.a, pair.b));\n    } else {\n        Iterator<A> iterA = streamA.iterator();\n        Iterator<B> iterB = streamB.iterator();\n        while (iterA.hasNext() && iterB.hasNext()) {\n            consumer.accept(iterA.next(), iterB.next());\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code consumer} once for each pair of <i>corresponding</i> elements in {@code streamA}\n * and {@code streamB}. If one stream is longer than the other, the extra elements are silently\n * ignored. Elements passed to the consumer are guaranteed to come from the same position in their\n * respective source streams. For example:\n *\n * <pre>{@code\n * Streams.forEachPair(\n *   Stream.of(\"foo1\", \"foo2\", \"foo3\"),\n *   Stream.of(\"bar1\", \"bar2\"),\n *   (arg1, arg2) -> System.out.println(arg1 + \":\" + arg2)\n * }</pre>\n *\n * <p>will print:\n *\n * <pre>{@code\n * foo1:bar1\n * foo2:bar2\n * }</pre>\n *\n * <p><b>Warning:</b> If either supplied stream is a parallel stream, the same correspondence\n * between elements will be made, but the order in which those pairs of elements are passed to the\n * consumer is <i>not</i> defined.\n *\n * <p>Note that many usages of this method can be replaced with simpler calls to {@link #zip}.\n * This method behaves equivalently to {@linkplain #zip zipping} the stream elements into\n * temporary pair objects and then using {@link Stream#forEach} on that stream.\n *\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 3135, "method_signature": "void forEachPair(Stream, Stream, BiConsumer)", "filename": "Streams.forEachPair.json"}
{"callee_method_names": ["DoubleStream.isParallel", "DoubleStream.spliterator", "Spliterator.OfDouble.hasCharacteristics", "Spliterator.OfDouble.estimateSize", "Spliterator.OfDouble.characteristics", "PrimitiveIterator.OfDouble.hasNext", "Consumer<? super String>.accept", "DoubleFunctionWithIndex<R>.apply", "PrimitiveIterator.OfDouble.nextDouble", "Spliterator.OfDouble.tryAdvance", "Consumer<? super String>.accept", "DoubleFunctionWithIndex<R>.apply"], "method_name": "Streams.mapWithIndex", "method_implementation": "{\n    checkNotNull(stream);\n    checkNotNull(function);\n    boolean isParallel = stream.isParallel();\n    Spliterator.OfDouble fromSpliterator = stream.spliterator();\n    if (!fromSpliterator.hasCharacteristics(Spliterator.SUBSIZED)) {\n        PrimitiveIterator.OfDouble fromIterator = Spliterators.iterator(fromSpliterator);\n        return StreamSupport.stream(new AbstractSpliterator<R>(fromSpliterator.estimateSize(), fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {\n\n            long index = 0;\n\n            @Override\n            public boolean tryAdvance(Consumer<? super R> action) {\n                if (fromIterator.hasNext()) {\n                    action.accept(function.apply(fromIterator.nextDouble(), index++));\n                    return true;\n                }\n                return false;\n            }\n        }, isParallel).onClose(stream::close);\n    }\n    class Splitr extends MapWithIndexSpliterator<Spliterator.OfDouble, R, Splitr> implements DoubleConsumer, Spliterator<R> {\n\n        double holder;\n\n        Splitr(Spliterator.OfDouble splitr, long index) {\n            super(splitr, index);\n        }\n\n        @Override\n        public void accept(double t) {\n            this.holder = t;\n        }\n\n        @Override\n        public boolean tryAdvance(Consumer<? super R> action) {\n            if (fromSpliterator.tryAdvance(this)) {\n                action.accept(function.apply(holder, index++));\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        Splitr createSplit(Spliterator.OfDouble from, long i) {\n            return new Splitr(from, i);\n        }\n    }\n    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel).onClose(stream::close);\n}", "repo_id": "5", "comment": "/**\n * Returns a stream consisting of the results of applying the given function to the elements of\n * {@code stream} and their indexes in the stream. For example,\n *\n * <pre>{@code\n * mapWithIndex(\n *     DoubleStream.of(0.0, 1.0, 2.0)\n *     (e, index) -> index + \":\" + e)\n * }</pre>\n *\n * <p>...would return {@code Stream.of(\"0:0.0\", \"1:1.0\", \"2:2.0\")}.\n *\n * <p>The resulting stream is <a\n * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n * if and only if {@code stream} was efficiently splittable and its underlying spliterator\n * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream\n * comes from a data structure supporting efficient indexed random access, typically an array or\n * list.\n *\n * <p>The order of the resulting stream is defined if and only if the order of the original stream\n * was defined.\n */\n", "repo_name": "guava-master/", "id": 3139, "method_signature": "Stream<R> mapWithIndex(DoubleStream, DoubleFunctionWithIndex)", "filename": "Streams.mapWithIndex.json"}
{"callee_method_names": [], "method_name": "Streams.sneakyThrow", "method_implementation": "{\n    class SneakyThrower<T extends Throwable> {\n\n        // not really safe, but that's the point\n        @SuppressWarnings(\"unchecked\")\n        void throwIt(Throwable t) throws T {\n            throw (T) t;\n        }\n    }\n    new SneakyThrower<Error>().throwIt(t);\n}", "repo_id": "5", "comment": "/**\n * Throws an undeclared checked exception.\n */\n", "repo_name": "guava-master/", "id": 3129, "method_signature": "void sneakyThrow(Throwable)", "filename": "Streams.sneakyThrow.json"}
{"callee_method_names": ["OptionalDouble.isPresent", "OptionalDouble.getAsDouble"], "method_name": "Streams.stream", "method_implementation": "{\n    return optional.isPresent() ? DoubleStream.of(optional.getAsDouble()) : DoubleStream.empty();\n}", "repo_id": "5", "comment": "/**\n * If a value is present in {@code optional}, returns a stream containing only that element,\n * otherwise returns an empty stream.\n *\n * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n */\n", "repo_name": "guava-master/", "id": 3128, "method_signature": "DoubleStream stream(OptionalDouble)", "filename": "Streams.stream.json"}
{"callee_method_names": ["Stream<A>.isParallel", "Stream<B>.isParallel", "Stream<A>.spliterator", "Stream<B>.spliterator", "Spliterator<A>.characteristics", "Spliterator<B>.characteristics", "Spliterator<A>.estimateSize", "Spliterator<B>.estimateSize", "Iterator<A>.hasNext", "Iterator<B>.hasNext", "Consumer<? super String>.accept", "BiFunction<? super A,? super B,R>.apply", "Iterator<A>.next", "Iterator<B>.next"], "method_name": "Streams.zip", "method_implementation": "{\n    checkNotNull(streamA);\n    checkNotNull(streamB);\n    checkNotNull(function);\n    // same as Stream.concat\n    boolean isParallel = streamA.isParallel() || streamB.isParallel();\n    Spliterator<A> splitrA = streamA.spliterator();\n    Spliterator<B> splitrB = streamB.spliterator();\n    int characteristics = splitrA.characteristics() & splitrB.characteristics() & (Spliterator.SIZED | Spliterator.ORDERED);\n    Iterator<A> itrA = Spliterators.iterator(splitrA);\n    Iterator<B> itrB = Spliterators.iterator(splitrB);\n    return StreamSupport.stream(new AbstractSpliterator<R>(min(splitrA.estimateSize(), splitrB.estimateSize()), characteristics) {\n\n        @Override\n        public boolean tryAdvance(Consumer<? super R> action) {\n            if (itrA.hasNext() && itrB.hasNext()) {\n                action.accept(function.apply(itrA.next(), itrB.next()));\n                return true;\n            }\n            return false;\n        }\n    }, isParallel).onClose(streamA::close).onClose(streamB::close);\n}", "repo_id": "5", "comment": "/**\n * Returns a stream in which each element is the result of passing the corresponding element of\n * each of {@code streamA} and {@code streamB} to {@code function}.\n *\n * <p>For example:\n *\n * <pre>{@code\n * Streams.zip(\n *   Stream.of(\"foo1\", \"foo2\", \"foo3\"),\n *   Stream.of(\"bar1\", \"bar2\"),\n *   (arg1, arg2) -> arg1 + \":\" + arg2)\n * }</pre>\n *\n * <p>will return {@code Stream.of(\"foo1:bar1\", \"foo2:bar2\")}.\n *\n * <p>The resulting stream will only be as long as the shorter of the two input streams; if one\n * stream is longer, its extra elements will be ignored.\n *\n * <p>Note that if you are calling {@link Stream#forEach} on the resulting stream, you might want\n * to consider using {@link #forEachPair} instead of this method.\n *\n * <p><b>Performance note:</b> The resulting stream is not <a\n * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>.\n * This may harm parallel performance.\n */\n", "repo_name": "guava-master/", "id": 3134, "method_signature": "Stream<R> zip(Stream, Stream, BiFunction)", "filename": "Streams.zip.json"}
{"callee_method_names": [], "method_name": "StreamsTest.testStream_nonCollection", "method_implementation": "{\n    assertThat(stream(FluentIterable.of())).isEmpty();\n    assertThat(stream(FluentIterable.of(\"a\"))).containsExactly(\"a\");\n    assertThat(stream(FluentIterable.of(1, 2, 3)).filter(n -> n > 1)).containsExactly(2, 3);\n}", "repo_id": "5", "comment": "/*\n   * Full and proper black-box testing of a Stream-returning method is extremely involved, and is\n   * overkill when nearly all Streams are produced using well-tested JDK calls. So, we cheat and\n   * just test that the toArray() contents are as expected.\n   */\n", "repo_name": "guava-master/", "id": 512, "method_signature": "void testStream_nonCollection()", "filename": "StreamsTest.testStream_nonCollection.json"}
{"callee_method_names": [], "method_name": "StringAsImmutableList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6306, "method_signature": "Object writeReplace()", "filename": "StringAsImmutableList.writeReplace.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.charAt", "CharSequence.charAt", "CharSequence.subSequence"], "method_name": "Strings.commonPrefix", "method_implementation": "{\n    checkNotNull(a);\n    checkNotNull(b);\n    int maxPrefixLength = Math.min(a.length(), b.length());\n    int p = 0;\n    while (p < maxPrefixLength && a.charAt(p) == b.charAt(p)) {\n        p++;\n    }\n    if (validSurrogatePairAt(a, p - 1) || validSurrogatePairAt(b, p - 1)) {\n        p--;\n    }\n    return a.subSequence(0, p).toString();\n}", "repo_id": "5", "comment": "/**\n * Returns the longest string {@code prefix} such that {@code a.toString().startsWith(prefix) &&\n * b.toString().startsWith(prefix)}, taking care not to split surrogate pairs. If {@code a} and\n * {@code b} have no common prefix, returns the empty string.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 5171, "method_signature": "String commonPrefix(CharSequence, CharSequence)", "filename": "Strings.commonPrefix.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.charAt", "CharSequence.length", "CharSequence.charAt", "CharSequence.length", "CharSequence.length", "CharSequence.length", "CharSequence.subSequence", "CharSequence.length", "CharSequence.length"], "method_name": "Strings.commonSuffix", "method_implementation": "{\n    checkNotNull(a);\n    checkNotNull(b);\n    int maxSuffixLength = Math.min(a.length(), b.length());\n    int s = 0;\n    while (s < maxSuffixLength && a.charAt(a.length() - s - 1) == b.charAt(b.length() - s - 1)) {\n        s++;\n    }\n    if (validSurrogatePairAt(a, a.length() - s - 1) || validSurrogatePairAt(b, b.length() - s - 1)) {\n        s--;\n    }\n    return a.subSequence(a.length() - s, a.length()).toString();\n}", "repo_id": "5", "comment": "/**\n * Returns the longest string {@code suffix} such that {@code a.toString().endsWith(suffix) &&\n * b.toString().endsWith(suffix)}, taking care not to split surrogate pairs. If {@code a} and\n * {@code b} have no common suffix, returns the empty string.\n *\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 5172, "method_signature": "String commonSuffix(CharSequence, CharSequence)", "filename": "Strings.commonSuffix.json"}
{"callee_method_names": ["String.length", "String.indexOf", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Strings.lenientFormat", "method_implementation": "{\n    // null -> \"null\"\n    template = String.valueOf(template);\n    if (args == null) {\n        args = new Object[] { \"(Object[])null\" };\n    } else {\n        for (int i = 0; i < args.length; i++) {\n            args[i] = lenientToString(args[i]);\n        }\n    }\n    // start substituting the arguments into the '%s' placeholders\n    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);\n    int templateStart = 0;\n    int i = 0;\n    while (i < args.length) {\n        int placeholderStart = template.indexOf(\"%s\", templateStart);\n        if (placeholderStart == -1) {\n            break;\n        }\n        builder.append(template, templateStart, placeholderStart);\n        builder.append(args[i++]);\n        templateStart = placeholderStart + 2;\n    }\n    builder.append(template, templateStart, template.length());\n    // if we run out of placeholders, append the extra args in square braces\n    if (i < args.length) {\n        builder.append(\" [\");\n        builder.append(args[i++]);\n        while (i < args.length) {\n            builder.append(\", \");\n            builder.append(args[i++]);\n        }\n        builder.append(']');\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "// TODO(diamondm) consider using Arrays.toString() for array parameters\n", "repo_name": "guava-master/", "id": 5174, "method_signature": "String lenientFormat(String, Object[])", "filename": "Strings.lenientFormat.json"}
{"callee_method_names": ["String.length", "StringBuilder.append", "String.length", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Strings.padEnd", "method_implementation": "{\n    // eager for GWT.\n    checkNotNull(string);\n    if (string.length() >= minLength) {\n        return string;\n    }\n    StringBuilder sb = new StringBuilder(minLength);\n    sb.append(string);\n    for (int i = string.length(); i < minLength; i++) {\n        sb.append(padChar);\n    }\n    return sb.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string, of length at least {@code minLength}, consisting of {@code string} appended\n * with as many copies of {@code padChar} as are necessary to reach that length. For example,\n *\n * <ul>\n *   <li>{@code padEnd(\"4.\", 5, '0')} returns {@code \"4.000\"}\n *   <li>{@code padEnd(\"2010\", 3, '!')} returns {@code \"2010\"}\n * </ul>\n *\n * <p>See {@link java.util.Formatter} for a richer set of formatting capabilities.\n *\n * @param string the string which should appear at the beginning of the result\n * @param minLength the minimum length the resulting string must have. Can be zero or negative, in\n *     which case the input string is always returned.\n * @param padChar the character to append to the end of the result until the minimum length is\n *     reached\n * @return the padded string\n */\n", "repo_name": "guava-master/", "id": 5169, "method_signature": "String padEnd(String, int, char)", "filename": "Strings.padEnd.json"}
{"callee_method_names": ["String.length", "String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Strings.padStart", "method_implementation": "{\n    // eager for GWT.\n    checkNotNull(string);\n    if (string.length() >= minLength) {\n        return string;\n    }\n    StringBuilder sb = new StringBuilder(minLength);\n    for (int i = string.length(); i < minLength; i++) {\n        sb.append(padChar);\n    }\n    sb.append(string);\n    return sb.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string, of length at least {@code minLength}, consisting of {@code string} prepended\n * with as many copies of {@code padChar} as are necessary to reach that length. For example,\n *\n * <ul>\n *   <li>{@code padStart(\"7\", 3, '0')} returns {@code \"007\"}\n *   <li>{@code padStart(\"2010\", 3, '0')} returns {@code \"2010\"}\n * </ul>\n *\n * <p>See {@link java.util.Formatter} for a richer set of formatting capabilities.\n *\n * @param string the string which should appear at the end of the result\n * @param minLength the minimum length the resulting string must have. Can be zero or negative, in\n *     which case the input string is always returned.\n * @param padChar the character to insert at the beginning of the result until the minimum length\n *     is reached\n * @return the padded string\n */\n", "repo_name": "guava-master/", "id": 5168, "method_signature": "String padStart(String, int, char)", "filename": "Strings.padStart.json"}
{"callee_method_names": ["String.length", "String.getChars"], "method_name": "Strings.repeat", "method_implementation": "{\n    // eager for GWT.\n    checkNotNull(string);\n    if (count <= 1) {\n        checkArgument(count >= 0, \"invalid count: %s\", count);\n        return (count == 0) ? \"\" : string;\n    }\n    // IF YOU MODIFY THE CODE HERE, you must update StringsRepeatBenchmark\n    final int len = string.length();\n    final long longSize = (long) len * (long) count;\n    final int size = (int) longSize;\n    if (size != longSize) {\n        throw new ArrayIndexOutOfBoundsException(\"Required array size too large: \" + longSize);\n    }\n    final char[] array = new char[size];\n    string.getChars(0, len, array, 0);\n    int n;\n    for (n = len; n < size - n; n <<= 1) {\n        System.arraycopy(array, 0, array, n, n);\n    }\n    System.arraycopy(array, 0, array, n, size - n);\n    return new String(array);\n}", "repo_id": "5", "comment": "/**\n * Returns a string consisting of a specific number of concatenated copies of an input string. For\n * example, {@code repeat(\"hey\", 3)} returns the string {@code \"heyheyhey\"}.\n *\n * @param string any non-null string\n * @param count the number of times to repeat it; a nonnegative integer\n * @return a string containing {@code string} repeated {@code count} times (the empty string if\n *     {@code count} is zero)\n * @throws IllegalArgumentException if {@code count} is negative\n */\n", "repo_name": "guava-master/", "id": 5170, "method_signature": "String repeat(String, int)", "filename": "Strings.repeat.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "Strings.validSurrogatePairAt", "method_implementation": "{\n    return index >= 0 && index <= (string.length() - 2) && Character.isHighSurrogate(string.charAt(index)) && Character.isLowSurrogate(string.charAt(index + 1));\n}", "repo_id": "5", "comment": "/**\n * True when a valid surrogate pair starts at the given {@code index} in the given {@code string}.\n * Out-of-range indexes return false.\n */\n", "repo_name": "guava-master/", "id": 5173, "method_signature": "boolean validSurrogatePairAt(CharSequence, int)", "filename": "Strings.validSurrogatePairAt.json"}
{"callee_method_names": [], "method_name": "StringsTest.testPadEnd_null", "method_implementation": "{\n    try {\n        Strings.padEnd(null, 5, '0');\n        fail();\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "// TODO: could remove if we got NPT working in GWT somehow\n", "repo_name": "guava-master/", "id": 3703, "method_signature": "void testPadEnd_null()", "filename": "StringsTest.testPadEnd_null.json"}
{"callee_method_names": [], "method_name": "StringsTest.testPadStart_null", "method_implementation": "{\n    try {\n        Strings.padStart(null, 5, '0');\n        fail();\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "// TODO: could remove if we got NPT working in GWT somehow\n", "repo_name": "guava-master/", "id": 3702, "method_signature": "void testPadStart_null()", "filename": "StringsTest.testPadStart_null.json"}
{"callee_method_names": [], "method_name": "StringsTest.testRepeat_null", "method_implementation": "{\n    try {\n        Strings.repeat(null, 5);\n        fail();\n    } catch (NullPointerException expected) {\n    }\n}", "repo_id": "5", "comment": "// TODO: could remove if we got NPT working in GWT somehow\n", "repo_name": "guava-master/", "id": 3704, "method_signature": "void testRepeat_null()", "filename": "StringsTest.testRepeat_null.json"}
{"callee_method_names": ["List<Object>.isEmpty", "List<Object>.size", "List<Object>.size", "List<Object>.get", "List<Object>.set", "List<Object>.size", "List<Object>.set", "List<Object>.get", "List<Object>.set"], "method_name": "Striped.bulkGet", "method_implementation": "{\n    // Initially using the list to store the keys, then reusing it to store the respective L's\n    List<Object> result = newArrayList(keys);\n    if (result.isEmpty()) {\n        return ImmutableList.of();\n    }\n    int[] stripes = new int[result.size()];\n    for (int i = 0; i < result.size(); i++) {\n        stripes[i] = indexFor(result.get(i));\n    }\n    Arrays.sort(stripes);\n    // optimize for runs of identical stripes\n    int previousStripe = stripes[0];\n    result.set(0, getAt(previousStripe));\n    for (int i = 1; i < result.size(); i++) {\n        int currentStripe = stripes[i];\n        if (currentStripe == previousStripe) {\n            result.set(i, result.get(i - 1));\n        } else {\n            result.set(i, getAt(currentStripe));\n            previousStripe = currentStripe;\n        }\n    }\n    /*\n     * Note that the returned Iterable holds references to the returned stripes, to avoid\n     * error-prone code like:\n     *\n     * Striped<Lock> stripedLock = Striped.lazyWeakXXX(...)'\n     * Iterable<Lock> locks = stripedLock.bulkGet(keys);\n     * for (Lock lock : locks) {\n     *   lock.lock();\n     * }\n     * operation();\n     * for (Lock lock : locks) {\n     *   lock.unlock();\n     * }\n     *\n     * If we only held the int[] stripes, translating it on the fly to L's, the original locks might\n     * be garbage collected after locking them, ending up in a huge mess.\n     */\n    // we carefully replaced all keys with their respective L's\n    @SuppressWarnings(\"unchecked\")\n    List<L> asStripes = (List<L>) result;\n    return Collections.unmodifiableList(asStripes);\n}", "repo_id": "5", "comment": "/**\n * Returns the stripes that correspond to the passed objects, in ascending (as per {@link\n * #getAt(int)}) order. Thus, threads that use the stripes in the order returned by this method\n * are guaranteed to not deadlock each other.\n *\n * <p>It should be noted that using a {@code Striped<L>} with relatively few stripes, and {@code\n * bulkGet(keys)} with a relative large number of keys can cause an excessive number of shared\n * stripes (much like the birthday paradox, where much fewer than anticipated birthdays are needed\n * for a pair of them to match). Please consider carefully the implications of the number of\n * stripes, the intended concurrency level, and the typical number of keys used in a {@code\n * bulkGet(keys)} operation. See <a href=\"http://www.mathpages.com/home/kmath199.htm\">Balls in\n * Bins model</a> for mathematical formulas that can be used to estimate the probability of\n * collisions.\n *\n * @param keys arbitrary non-null keys\n * @return the stripes corresponding to the objects (one per each object, derived by delegating to\n *     {@link #get(Object)}; may contain duplicates), in an increasing index order.\n */\n", "repo_name": "guava-master/", "id": 5388, "method_signature": "Iterable<L> bulkGet(Iterable)", "filename": "Striped.bulkGet.json"}
{"callee_method_names": ["ReferenceQueue.poll", "ConcurrentMap<Integer, L>.compareAndSet"], "method_name": "Striped.drainQueue", "method_implementation": "{\n    Reference<? extends L> ref;\n    while ((ref = queue.poll()) != null) {\n        // We only ever register ArrayReferences with the queue so this is always safe.\n        ArrayReference<? extends L> arrayRef = (ArrayReference<? extends L>) ref;\n        // Try to clear out the array slot, n.b. if we fail that is fine, in either case the\n        // arrayRef will be out of the array after this step.\n        locks.compareAndSet(arrayRef.index, arrayRef, null);\n    }\n}", "repo_id": "5", "comment": "// objects indefinitely.\n", "repo_name": "guava-master/", "id": 5389, "method_signature": "void drainQueue()", "filename": "Striped.drainQueue.json"}
{"callee_method_names": ["Class<sun.misc.Unsafe>.getDeclaredFields", "Function<A, ? extends B>.setAccessible", "Function<A, ? extends B>.get", "Class<sun.misc.Unsafe>.isInstance", "Class<sun.misc.Unsafe>.cast", "Entry<?, ?>.getCause"], "method_name": "Striped64.getUnsafe", "method_implementation": "{\n    try {\n        return sun.misc.Unsafe.getUnsafe();\n    } catch (SecurityException tryReflectionInstead) {\n    }\n    try {\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n\n            @Override\n            public sun.misc.Unsafe run() throws Exception {\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n                    f.setAccessible(true);\n                    Object x = f.get(null);\n                    if (k.isInstance(x))\n                        return k.cast(x);\n                }\n                throw new NoSuchFieldError(\"the Unsafe\");\n            }\n        });\n    } catch (java.security.PrivilegedActionException e) {\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple call\n * to Unsafe.getUnsafe when integrating into a jdk.\n *\n * @return a sun.misc.Unsafe\n */\n", "repo_name": "guava-master/", "id": 5193, "method_signature": "sun.misc.Unsafe getUnsafe()", "filename": "Striped64.getUnsafe.json"}
{"callee_method_names": [], "method_name": "Striped64.internalReset", "method_implementation": "{\n    Cell[] as = cells;\n    base = initialValue;\n    if (as != null) {\n        int n = as.length;\n        for (int i = 0; i < n; ++i) {\n            Cell a = as[i];\n            if (a != null)\n                a.value = initialValue;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Sets base and all cells to the given value.\n */\n", "repo_name": "guava-master/", "id": 5192, "method_signature": "void internalReset(long)", "filename": "Striped64.internalReset.json"}
{"callee_method_names": ["ThreadLocal.set", "Random.nextInt", "Cell.cas"], "method_name": "Striped64.retryUpdate", "method_implementation": "{\n    int h;\n    if (hc == null) {\n        // Initialize randomly\n        threadHashCode.set(hc = new int[1]);\n        // Avoid zero to allow xorShift rehash\n        int r = rng.nextInt();\n        h = hc[0] = (r == 0) ? 1 : r;\n    } else\n        h = hc[0];\n    // True if last slot nonempty\n    boolean collide = false;\n    for (; ; ) {\n        Cell[] as;\n        Cell a;\n        int n;\n        long v;\n        if ((as = cells) != null && (n = as.length) > 0) {\n            if ((a = as[(n - 1) & h]) == null) {\n                if (busy == 0) {\n                    // Try to attach new Cell\n                    // Optimistically create\n                    Cell r = new Cell(x);\n                    if (busy == 0 && casBusy()) {\n                        boolean created = false;\n                        try {\n                            // Recheck under lock\n                            Cell[] rs;\n                            int m, j;\n                            if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {\n                                rs[j] = r;\n                                created = true;\n                            }\n                        } finally {\n                            busy = 0;\n                        }\n                        if (created)\n                            break;\n                        // Slot is now non-empty\n                        continue;\n                    }\n                }\n                collide = false;\n            } else if (// CAS already known to fail\n            !wasUncontended)\n                // Continue after rehash\n                wasUncontended = true;\n            else if (a.cas(v = a.value, fn(v, x)))\n                break;\n            else if (// At max size or stale\n            n >= NCPU || cells != as)\n                // At max size or stale\n                collide = false;\n            else if (!collide)\n                collide = true;\n            else if (busy == 0 && casBusy()) {\n                try {\n                    if (cells == as) {\n                        // Expand table unless stale\n                        Cell[] rs = new Cell[n << 1];\n                        for (int i = 0; i < n; ++i) rs[i] = as[i];\n                        cells = rs;\n                    }\n                } finally {\n                    busy = 0;\n                }\n                collide = false;\n                // Retry with expanded table\n                continue;\n            }\n            // Rehash\n            h ^= h << 13;\n            h ^= h >>> 17;\n            h ^= h << 5;\n            // Record index for next time\n            hc[0] = h;\n        } else if (busy == 0 && cells == as && casBusy()) {\n            boolean init = false;\n            try {\n                // Initialize table\n                if (cells == as) {\n                    Cell[] rs = new Cell[2];\n                    rs[h & 1] = new Cell(x);\n                    cells = rs;\n                    init = true;\n                }\n            } finally {\n                busy = 0;\n            }\n            if (init)\n                break;\n        } else // Fall back on using base\n        if (casBase(v = base, fn(v, x)))\n            break;\n    }\n}", "repo_id": "5", "comment": "/**\n * Handles cases of updates involving initialization, resizing, creating new Cells, and/or\n * contention. See above for explanation. This method suffers the usual non-modularity problems of\n * optimistic retry code, relying on rechecked sets of reads.\n *\n * @param x the value\n * @param hc the hash code holder\n * @param wasUncontended false if CAS failed before call\n */\n", "repo_name": "guava-master/", "id": 5191, "method_signature": "void retryUpdate(long, int[], boolean)", "filename": "Striped64.retryUpdate.json"}
{"callee_method_names": [], "method_name": "StripedTest.testBasicInvariants", "method_implementation": "{\n    for (Striped<?> striped : allImplementations()) {\n        assertBasicInvariants(striped);\n    }\n}", "repo_id": "5", "comment": "/**\n * Checks idempotency, and that we observe the promised number of stripes.\n */\n", "repo_name": "guava-master/", "id": 3921, "method_signature": "void testBasicInvariants()", "filename": "StripedTest.testBasicInvariants.json"}
{"callee_method_names": [], "method_name": "SubList.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 5740, "method_signature": "Object writeReplace()", "filename": "SubList.writeReplace.json"}
{"callee_method_names": [], "method_name": "Subscriber.create", "method_implementation": "{\n    return isDeclaredThreadSafe(method) ? new Subscriber(bus, listener, method) : new SynchronizedSubscriber(bus, listener, method);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code Subscriber} for {@code method} on {@code listener}.\n */\n", "repo_name": "guava-master/", "id": 6809, "method_signature": "Subscriber create(EventBus, Object, Method)", "filename": "Subscriber.create.json"}
{"callee_method_ids": [6807], "callee_method_names": ["Executor.execute", "EventBus.handleSubscriberException", "Throwable.getCause"], "method_name": "Subscriber.dispatchEvent", "method_implementation": "{\n    executor.execute(() -> {\n        try {\n            invokeSubscriberMethod(event);\n        } catch (InvocationTargetException e) {\n            bus.handleSubscriberException(e.getCause(), context(event));\n        }\n    });\n}", "repo_id": "5", "comment": "/**\n * Dispatches {@code event} to this subscriber using the proper executor.\n */\n", "repo_name": "guava-master/", "id": 6810, "method_signature": "void dispatchEvent(Object)", "filename": "Subscriber.dispatchEvent.json"}
{"callee_method_names": ["Method.invoke", "Throwable.getCause", "Throwable.getCause"], "method_name": "Subscriber.invokeSubscriberMethod", "method_implementation": "{\n    try {\n        method.invoke(target, checkNotNull(event));\n    } catch (IllegalArgumentException e) {\n        throw new Error(\"Method rejected target/argument: \" + event, e);\n    } catch (IllegalAccessException e) {\n        throw new Error(\"Method became inaccessible: \" + event, e);\n    } catch (InvocationTargetException e) {\n        if (e.getCause() instanceof Error) {\n            throw (Error) e.getCause();\n        }\n        throw e;\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes the subscriber method. This method can be overridden to make the invocation\n * synchronized.\n */\n", "repo_name": "guava-master/", "id": 6811, "method_signature": "void invokeSubscriberMethod(Object)", "filename": "Subscriber.invokeSubscriberMethod.json"}
{"callee_method_names": ["Object.getClass", "Multimap<Class<?>, Subscriber>.put"], "method_name": "SubscriberRegistry.findAllSubscribers", "method_implementation": "{\n    Multimap<Class<?>, Subscriber> methodsInListener = HashMultimap.create();\n    Class<?> clazz = listener.getClass();\n    for (Method method : getAnnotatedMethods(clazz)) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        Class<?> eventType = parameterTypes[0];\n        methodsInListener.put(eventType, Subscriber.create(bus, listener, method));\n    }\n    return methodsInListener;\n}", "repo_id": "5", "comment": "/**\n * Returns all subscribers for the given listener grouped by the type of event they subscribe to.\n */\n", "repo_name": "guava-master/", "id": 6804, "method_signature": "Multimap<Class<?>,Subscriber> findAllSubscribers(Object)", "filename": "SubscriberRegistry.findAllSubscribers.json"}
{"callee_method_names": ["LoadingCache<Class<?>, ImmutableSet<Class<?>>>.getUnchecked", "E.getCause"], "method_name": "SubscriberRegistry.flattenHierarchy", "method_implementation": "{\n    try {\n        return flattenHierarchyCache.getUnchecked(concreteClass);\n    } catch (UncheckedExecutionException e) {\n        throw Throwables.propagate(e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Flattens a class's type hierarchy into a set of {@code Class} objects including all\n * superclasses (transitively) and all interfaces implemented by these superclasses.\n */\n", "repo_name": "guava-master/", "id": 6806, "method_signature": "ImmutableSet<Class<?>> flattenHierarchy(Class)", "filename": "SubscriberRegistry.flattenHierarchy.json"}
{"callee_method_names": ["Object.getClass", "ImmutableSet<Class<?>>.size", "ConcurrentMap<Class<?>, CopyOnWriteArraySet<Subscriber>>.get", "List<Iterator<Subscriber>>.add", "CopyOnWriteArraySet<Subscriber>.iterator", "List<Iterator<Subscriber>>.iterator"], "method_name": "SubscriberRegistry.getSubscribers", "method_implementation": "{\n    ImmutableSet<Class<?>> eventTypes = flattenHierarchy(event.getClass());\n    List<Iterator<Subscriber>> subscriberIterators = Lists.newArrayListWithCapacity(eventTypes.size());\n    for (Class<?> eventType : eventTypes) {\n        CopyOnWriteArraySet<Subscriber> eventSubscribers = subscribers.get(eventType);\n        if (eventSubscribers != null) {\n            // eager no-copy snapshot\n            subscriberIterators.add(eventSubscribers.iterator());\n        }\n    }\n    return Iterators.concat(subscriberIterators.iterator());\n}", "repo_id": "5", "comment": "/**\n * Gets an iterator representing an immutable snapshot of all subscribers to the given event at\n * the time this method is called.\n */\n", "repo_name": "guava-master/", "id": 6803, "method_signature": "Iterator<Subscriber> getSubscribers(Object)", "filename": "SubscriberRegistry.getSubscribers.json"}
{"callee_method_names": [], "method_name": "SubscriberRegistry.load", "method_implementation": "{\n    return ImmutableSet.<Class<?>>copyOf(TypeToken.of(concreteClass).getTypes().rawTypes());\n}", "repo_id": "5", "comment": "// <Class<?>> is actually needed to compile\n", "repo_name": "guava-master/", "id": 6805, "method_signature": "ImmutableSet<Class<?>> load(Class)", "filename": "SubscriberRegistry.load.json"}
{"callee_method_names": ["Multimap<Class<?>, Subscriber>.asMap", "long.getKey", "long.getValue", "ConcurrentMap<Class<?>, CopyOnWriteArraySet<Subscriber>>.get", "ConcurrentMap<Class<?>, CopyOnWriteArraySet<Subscriber>>.putIfAbsent", "CopyOnWriteArraySet<Subscriber>.addAll"], "method_name": "SubscriberRegistry.register", "method_implementation": "{\n    Multimap<Class<?>, Subscriber> listenerMethods = findAllSubscribers(listener);\n    for (Entry<Class<?>, Collection<Subscriber>> entry : listenerMethods.asMap().entrySet()) {\n        Class<?> eventType = entry.getKey();\n        Collection<Subscriber> eventMethodsInListener = entry.getValue();\n        CopyOnWriteArraySet<Subscriber> eventSubscribers = subscribers.get(eventType);\n        if (eventSubscribers == null) {\n            CopyOnWriteArraySet<Subscriber> newSet = new CopyOnWriteArraySet<>();\n            eventSubscribers = MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);\n        }\n        eventSubscribers.addAll(eventMethodsInListener);\n    }\n}", "repo_id": "5", "comment": "/**\n * Registers all subscriber methods on the given listener object.\n */\n", "repo_name": "guava-master/", "id": 6801, "method_signature": "void register(Object)", "filename": "SubscriberRegistry.register.json"}
{"callee_method_names": ["Multimap<Class<?>, Subscriber>.asMap", "long.getKey", "long.getValue", "ConcurrentMap<Class<?>, CopyOnWriteArraySet<Subscriber>>.get", "CopyOnWriteArraySet<Subscriber>.removeAll"], "method_name": "SubscriberRegistry.unregister", "method_implementation": "{\n    Multimap<Class<?>, Subscriber> listenerMethods = findAllSubscribers(listener);\n    for (Entry<Class<?>, Collection<Subscriber>> entry : listenerMethods.asMap().entrySet()) {\n        Class<?> eventType = entry.getKey();\n        Collection<Subscriber> listenerMethodsForType = entry.getValue();\n        CopyOnWriteArraySet<Subscriber> currentSubscribers = subscribers.get(eventType);\n        if (currentSubscribers == null || !currentSubscribers.removeAll(listenerMethodsForType)) {\n            // if removeAll returns true, all we really know is that at least one subscriber was\n            // removed... however, barring something very strange we can assume that if at least one\n            // subscriber was removed, all subscribers on listener for that event type were... after\n            // all, the definition of subscribers on a particular class is totally static\n            throw new IllegalArgumentException(\"missing event subscriber for an annotated method. Is \" + listener + \" registered?\");\n        }\n        // don't try to remove the set if it's empty; that can't be done safely without a lock\n        // anyway, if the set is empty it'll just be wrapping an array of length 0\n    }\n}", "repo_id": "5", "comment": "/**\n * Unregisters all subscribers on the given listener object.\n */\n", "repo_name": "guava-master/", "id": 6802, "method_signature": "void unregister(Object)", "filename": "SubscriberRegistry.unregister.json"}
{"callee_method_names": [], "method_name": "SubscriberTest.recordingMethod", "method_implementation": "{\n    assertFalse(methodCalled);\n    methodCalled = true;\n    methodArgument = arg;\n}", "repo_id": "5", "comment": "/**\n * Records the provided object in {@link #methodArgument} and sets {@link #methodCalled}. This\n * method is called reflectively by Subscriber during tests, and must remain public.\n *\n * @param arg argument to record.\n */\n", "repo_name": "guava-master/", "id": 4075, "method_signature": "void recordingMethod(Object)", "filename": "SubscriberTest.recordingMethod.json"}
{"callee_method_names": ["Method.getGenericReturnType", "Method.getAnnotation", "TestSubtype.suppressGetSubtype", "TestSubtype.suppressGetSupertype"], "method_name": "SubtypeTester.isSubtype", "method_implementation": "{\n    Type returnType = method.getGenericReturnType();\n    Type paramType = getOnlyParameterType();\n    TestSubtype spec = method.getAnnotation(TestSubtype.class);\n    assertWithMessage(\"%s is subtype of %s\", paramType, returnType).that(TypeToken.of(paramType).isSubtypeOf(returnType)).isTrue();\n    assertWithMessage(\"%s is supertype of %s\", returnType, paramType).that(TypeToken.of(returnType).isSupertypeOf(paramType)).isTrue();\n    if (!spec.suppressGetSubtype()) {\n        assertThat(getSubtype(returnType, TypeToken.of(paramType).getRawType())).isEqualTo(paramType);\n    }\n    if (!spec.suppressGetSupertype()) {\n        assertThat(getSupertype(paramType, TypeToken.of(returnType).getRawType())).isEqualTo(returnType);\n    }\n    return sub;\n}", "repo_id": "5", "comment": "/**\n * Call this in a {@link TestSubtype} public method asserting subtype relationship.\n */\n", "repo_name": "guava-master/", "id": 3615, "method_signature": "T isSubtype(T)", "filename": "SubtypeTester.isSubtype.json"}
{"callee_method_names": ["Method.getGenericReturnType", "Method.getAnnotation", "TestSubtype.suppressGetSubtype", "TestSubtype.suppressGetSupertype"], "method_name": "SubtypeTester.notSubtype", "method_implementation": "{\n    Type returnType = method.getGenericReturnType();\n    Type paramType = getOnlyParameterType();\n    TestSubtype spec = method.getAnnotation(TestSubtype.class);\n    assertWithMessage(\"%s is subtype of %s\", paramType, returnType).that(TypeToken.of(paramType).isSubtypeOf(returnType)).isFalse();\n    assertWithMessage(\"%s is supertype of %s\", returnType, paramType).that(TypeToken.of(returnType).isSupertypeOf(paramType)).isFalse();\n    if (!spec.suppressGetSubtype()) {\n        try {\n            assertThat(getSubtype(returnType, TypeToken.of(paramType).getRawType())).isNotEqualTo(paramType);\n        } catch (IllegalArgumentException notSubtype1) {\n            // The raw class isn't even a subclass.\n        }\n    }\n    if (!spec.suppressGetSupertype()) {\n        try {\n            assertThat(getSupertype(paramType, TypeToken.of(returnType).getRawType())).isNotEqualTo(returnType);\n        } catch (IllegalArgumentException notSubtype2) {\n            // The raw class isn't even a subclass.\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Call this in a {@link TestSubtype} public method asserting that subtype relationship does not\n * hold.\n */\n", "repo_name": "guava-master/", "id": 3616, "method_signature": "X notSubtype(Object)", "filename": "SubtypeTester.notSubtype.json"}
{"callee_method_names": ["Supplier<Object>.get"], "method_name": "Suppliers.apply", "method_implementation": "{\n    return input.get();\n}", "repo_id": "5", "comment": "// Note: This makes T a \"pass-through type\"\n", "repo_name": "guava-master/", "id": 5186, "method_signature": "Object apply(Supplier)", "filename": "Suppliers.apply.json"}
{"callee_method_names": [], "method_name": "Suppliers.memoize", "method_implementation": "{\n    if (delegate instanceof NonSerializableMemoizingSupplier || delegate instanceof MemoizingSupplier) {\n        return delegate;\n    }\n    return delegate instanceof Serializable ? new MemoizingSupplier<T>(delegate) : new NonSerializableMemoizingSupplier<T>(delegate);\n}", "repo_id": "5", "comment": "/**\n * Returns a supplier which caches the instance retrieved during the first call to {@code get()}\n * and returns that value on subsequent calls to {@code get()}. See: <a\n * href=\"http://en.wikipedia.org/wiki/Memoization\">memoization</a>\n *\n * <p>The returned supplier is thread-safe. The delegate's {@code get()} method will be invoked at\n * most once unless the underlying {@code get()} throws an exception. The supplier's serialized\n * form does not contain the cached value, which will be recalculated when {@code get()} is called\n * on the deserialized instance.\n *\n * <p>When the underlying delegate throws an exception then this memoizing supplier will keep\n * delegating calls until it returns valid data.\n *\n * <p>If {@code delegate} is an instance created by an earlier call to {@code memoize}, it is\n * returned directly.\n */\n", "repo_name": "guava-master/", "id": 5182, "method_signature": "Supplier<T> memoize(Supplier)", "filename": "Suppliers.memoize.json"}
{"callee_method_names": ["Duration.isNegative", "Duration.isZero"], "method_name": "Suppliers.memoizeWithExpiration", "method_implementation": "{\n    checkNotNull(delegate);\n    // The alternative of `duration.compareTo(Duration.ZERO) > 0` causes J2ObjC trouble.\n    checkArgument(!duration.isNegative() && !duration.isZero(), \"duration (%s) must be > 0\", duration);\n    return new ExpiringMemoizingSupplier<T>(delegate, toNanosSaturated(duration));\n}", "repo_id": "5", "comment": "/**\n * Returns a supplier that caches the instance supplied by the delegate and removes the cached\n * value after the specified time has passed. Subsequent calls to {@code get()} return the cached\n * value if the expiration time has not passed. After the expiration time, a new value is\n * retrieved, cached, and returned. See: <a\n * href=\"http://en.wikipedia.org/wiki/Memoization\">memoization</a>\n *\n * <p>The returned supplier is thread-safe. The supplier's serialized form does not contain the\n * cached value, which will be recalculated when {@code get()} is called on the reserialized\n * instance. The actual memoization does not happen when the underlying delegate throws an\n * exception.\n *\n * <p>When the underlying delegate throws an exception then this memoizing supplier will keep\n * delegating calls until it returns valid data.\n *\n * @param duration the length of time after a value is created that it should stop being returned\n *     by subsequent {@code get()} calls\n * @throws IllegalArgumentException if {@code duration} is not positive\n * @since NEXT\n */\n", "repo_name": "guava-master/", "id": 5184, "method_signature": "Supplier<T> memoizeWithExpiration(Supplier, Duration)", "filename": "Suppliers.memoizeWithExpiration.json"}
{"callee_method_names": [], "method_name": "Suppliers.supplierFunction", "method_implementation": "{\n    // implementation is \"fully variant\"\n    @SuppressWarnings(\"unchecked\")\n    SupplierFunction<T> sf = (SupplierFunction<T>) SupplierFunctionImpl.INSTANCE;\n    return sf;\n}", "repo_id": "5", "comment": "/**\n * Returns a function that accepts a supplier and returns the result of invoking {@link\n * Supplier#get} on that supplier.\n *\n * <p><b>Java 8 users:</b> use the method reference {@code Supplier::get} instead.\n *\n * @since 8.0\n */\n", "repo_name": "guava-master/", "id": 5185, "method_signature": "Function<Supplier<T>,T> supplierFunction()", "filename": "Suppliers.supplierFunction.json"}
{"callee_method_names": [], "method_name": "Sync.complete", "method_implementation": "{\n    boolean doCompletion = compareAndSetState(RUNNING, COMPLETING);\n    if (doCompletion) {\n        // If this thread successfully transitioned to COMPLETING, set the value\n        // and exception and then release to the final state.\n        this.value = v;\n        // Don't actually construct a CancellationException until necessary.\n        this.exception = ((finalState & (CANCELLED | INTERRUPTED)) != 0) ? new CancellationException(\"Future.cancel() was called.\") : t;\n        releaseShared(finalState);\n    } else if (getState() == COMPLETING) {\n        // If some other thread is currently completing the future, block until\n        // they are done so we can guarantee completion.\n        acquireShared(-1);\n    }\n    return doCompletion;\n}", "repo_id": "5", "comment": "/**\n * Implementation of completing a task. Either {@code v} or {@code t} will be set but not\n * both. The {@code finalState} is the state to change to from {@link #RUNNING}. If the state\n * is not in the RUNNING state we return {@code false} after waiting for the state to be set\n * to a valid final state ({@link #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}).\n *\n * @param v the value to set as the result of the computation.\n * @param t the exception to set as the result of the computation.\n * @param finalState the state to transition to.\n */\n", "repo_name": "guava-master/", "id": 3918, "method_signature": "boolean complete(V, Throwable, int)", "filename": "Sync.complete.json"}
{"callee_method_names": [], "method_name": "Sync.get", "method_implementation": "{\n    // Acquire the shared lock allowing interruption.\n    acquireSharedInterruptibly(-1);\n    return getValue();\n}", "repo_id": "5", "comment": "/**\n * Blocks until {@link #complete(Object, Throwable, int)} has been successfully called. Throws\n * a {@link CancellationException} if the task was cancelled, or a {@link ExecutionException}\n * if the task completed with an error.\n */\n", "repo_name": "guava-master/", "id": 3916, "method_signature": "V get()", "filename": "Sync.get.json"}
{"callee_method_names": [], "method_name": "Sync.getValue", "method_implementation": "{\n    int state = getState();\n    switch(state) {\n        case COMPLETED:\n            if (exception != null) {\n                throw new ExecutionException(exception);\n            } else {\n                return value;\n            }\n        case CANCELLED:\n        case INTERRUPTED:\n            throw cancellationExceptionWithCause(\"Task was cancelled.\", exception);\n        default:\n            throw new IllegalStateException(\"Error, synchronizer in invalid state: \" + state);\n    }\n}", "repo_id": "5", "comment": "/**\n * Implementation of the actual value retrieval. Will return the value on success, an\n * exception on failure, a cancellation on cancellation, or an illegal state if the\n * synchronizer is in an invalid state.\n */\n", "repo_name": "guava-master/", "id": 3917, "method_signature": "V getValue()", "filename": "Sync.getValue.json"}
{"callee_method_names": [], "method_name": "Sync.tryAcquireShared", "method_implementation": "{\n    if (isDone()) {\n        return 1;\n    }\n    return -1;\n}", "repo_id": "5", "comment": "/*\n       * Acquisition succeeds if the future is done, otherwise it fails.\n       */\n", "repo_name": "guava-master/", "id": 3913, "method_signature": "int tryAcquireShared(int)", "filename": "Sync.tryAcquireShared.json"}
{"callee_method_names": [], "method_name": "Sync.tryReleaseShared", "method_implementation": "{\n    setState(finalState);\n    return true;\n}", "repo_id": "5", "comment": "/*\n       * We always allow a release to go through, this means the state has been\n       * successfully changed and the result is available.\n       */\n", "repo_name": "guava-master/", "id": 3914, "method_signature": "boolean tryReleaseShared(int)", "filename": "Sync.tryReleaseShared.json"}
{"callee_method_names": [], "method_name": "Synchronized.computeIfPresent", "method_implementation": "{\n    synchronized (mutex) {\n        return delegate().computeIfPresent(key, remappingFunction);\n    }\n}", "repo_id": "5", "comment": "/*\n     * TODO(cpovirk): Uncomment the @NonNull annotations below once our JDK stubs and J2KT\n     * emulations include them.\n     */\n", "repo_name": "guava-master/", "id": 2475, "method_signature": "V computeIfPresent(K, BiFunction)", "filename": "Synchronized.computeIfPresent.json"}
{"callee_method_names": [], "method_name": "SynchronizedHelper.gasListeners", "method_implementation": "{\n    synchronized (future) {\n        Listener old = future.listeners;\n        if (old != update) {\n            future.listeners = update;\n        }\n        return old;\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs a GAS operation on the {@link #listeners} field.\n */\n", "repo_name": "guava-master/", "id": 5314, "method_signature": "Listener gasListeners(AbstractFuture, Listener)", "filename": "SynchronizedHelper.gasListeners.json"}
{"callee_method_names": [], "method_name": "SynchronizedHelper.gasWaiters", "method_implementation": "{\n    synchronized (future) {\n        Waiter old = future.waiters;\n        if (old != update) {\n            future.waiters = update;\n        }\n        return old;\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs a GAS operation on the {@link #waiters} field.\n */\n", "repo_name": "guava-master/", "id": 5315, "method_signature": "Waiter gasWaiters(AbstractFuture, Waiter)", "filename": "SynchronizedHelper.gasWaiters.json"}
{"callee_method_names": [], "method_name": "SynchronizedMap.computeIfPresent", "method_implementation": "{\n    synchronized (mutex) {\n        return delegate().computeIfPresent(key, remappingFunction);\n    }\n}", "repo_id": "5", "comment": "/*\n     * TODO(cpovirk): Uncomment the @NonNull annotations below once our JDK stubs and J2KT\n     * emulations include them.\n     */\n", "repo_name": "guava-master/", "id": 2476, "method_signature": "V computeIfPresent(K, BiFunction)", "filename": "SynchronizedMap.computeIfPresent.json"}
{"callee_method_names": [], "method_name": "SynchronizedSetTest.suite", "method_implementation": "{\n    return SetTestSuiteBuilder.using(new TestStringSetGenerator() {\n\n        @Override\n        protected Set<String> create(String[] elements) {\n            TestSet<String> inner = new TestSet<>(new HashSet<String>(), MUTEX);\n            Set<String> outer = Synchronized.set(inner, inner.mutex);\n            Collections.addAll(outer, elements);\n            return outer;\n        }\n    }).named(\"Synchronized.set\").withFeatures(CollectionFeature.GENERAL_PURPOSE, CollectionFeature.ALLOWS_NULL_VALUES, CollectionSize.ANY, CollectionFeature.SERIALIZABLE).createTestSuite();\n}", "repo_id": "5", "comment": "// - The backport continued to use MUTEX.\n", "repo_name": "guava-master/", "id": 4030, "method_signature": "Test suite()", "filename": "SynchronizedSetTest.suite.json"}
{"callee_method_names": ["Map<String, Map<Integer, Character>>.keySet", "Map<String, Map<Integer, Character>>.size", "Map<String, Map<Integer, Character>>.get", "Map<String, Map<Integer, Character>>.remove", "Map<String, Map<Integer, Character>>.containsKey", "Map<String, Map<Integer, Character>>.size", "Map<String, Map<Integer, Character>>.remove"], "method_name": "TableCollectionTest.testRemove", "method_implementation": "{\n    final Map<String, Map<Integer, Character>> map;\n    final String keyToRemove;\n    try {\n        map = makePopulatedMap();\n    } catch (UnsupportedOperationException e) {\n        return;\n    }\n    keyToRemove = map.keySet().iterator().next();\n    if (supportsRemove) {\n        int initialSize = map.size();\n        map.get(keyToRemove);\n        map.remove(keyToRemove);\n        // This line doesn't hold - see the Javadoc comments above.\n        // assertEquals(expectedValue, oldValue);\n        assertFalse(map.containsKey(keyToRemove));\n        assertEquals(initialSize - 1, map.size());\n    } else {\n        try {\n            map.remove(keyToRemove);\n            fail(\"Expected UnsupportedOperationException.\");\n        } catch (UnsupportedOperationException expected) {\n        }\n    }\n    assertInvariants(map);\n}", "repo_id": "5", "comment": "/**\n * The version of this test supplied by {@link MapInterfaceTest} fails for this particular map\n * implementation, because {@code map.get()} returns a view collection that changes in the\n * course of a call to {@code remove()}. Thus, the expectation doesn't hold that {@code\n * map.remove(x)} returns the same value which {@code map.get(x)} did immediately beforehand.\n */\n", "repo_name": "guava-master/", "id": 3969, "method_signature": "void testRemove()", "filename": "TableCollectionTest.testRemove.json"}
{"callee_method_names": [], "method_name": "Tables.immutableCell", "method_implementation": "{\n    return new ImmutableCell<>(rowKey, columnKey, value);\n}", "repo_id": "5", "comment": "/**\n * Returns an immutable cell with the specified row key, column key, and value.\n *\n * <p>The returned cell is serializable.\n *\n * @param rowKey the row key to be associated with the returned cell\n * @param columnKey the column key to be associated with the returned cell\n * @param value the value to be associated with the returned cell\n */\n", "repo_name": "guava-master/", "id": 5843, "method_signature": "Cell<R,C,V> immutableCell(R, C, V)", "filename": "Tables.immutableCell.json"}
{"callee_method_names": ["Map<R,Map<C,V>>.isEmpty"], "method_name": "Tables.newCustomTable", "method_implementation": "{\n    checkArgument(backingMap.isEmpty());\n    checkNotNull(factory);\n    // TODO(jlevy): Wrap factory to validate that the supplied maps are empty?\n    return new StandardTable<>(backingMap, factory);\n}", "repo_id": "5", "comment": "/**\n * Creates a table that uses the specified backing map and factory. It can generate a table based\n * on arbitrary {@link Map} classes.\n *\n * <p>The {@code factory}-generated and {@code backingMap} classes determine the table iteration\n * order. However, the table's {@code row()} method returns instances of a different class than\n * {@code factory.get()} does.\n *\n * <p>Call this method only when the simpler factory methods in classes like {@link\n * HashBasedTable} and {@link TreeBasedTable} won't suffice.\n *\n * <p>The views returned by the {@code Table} methods {@link Table#column}, {@link\n * Table#columnKeySet}, and {@link Table#columnMap} have iterators that don't support {@code\n * remove()}. Otherwise, all optional operations are supported. Null row keys, columns keys, and\n * values are not supported.\n *\n * <p>Lookups by row key are often faster than lookups by column key, because the data is stored\n * in a {@code Map<R, Map<C, V>>}. A method call like {@code column(columnKey).get(rowKey)} still\n * runs quickly, since the row key is provided. However, {@code column(columnKey).size()} takes\n * longer, since an iteration across all row keys occurs.\n *\n * <p>Note that this implementation is not synchronized. If multiple threads access this table\n * concurrently and one of the threads modifies the table, it must be synchronized externally.\n *\n * <p>The table is serializable if {@code backingMap}, {@code factory}, the maps generated by\n * {@code factory}, and the table contents are all serializable.\n *\n * <p>Note: the table assumes complete ownership over of {@code backingMap} and the maps returned\n * by {@code factory}. Those objects should not be manually updated and they should not use soft,\n * weak, or phantom references.\n *\n * @param backingMap place to store the mapping from each row key to its corresponding column key\n *     / value map\n * @param factory supplier of new, empty maps that will each hold all column key / value mappings\n *     for a given row key\n * @throws IllegalArgumentException if {@code backingMap} is not empty\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5845, "method_signature": "Table<R,C,V> newCustomTable(Map, Supplier)", "filename": "Tables.newCustomTable.json"}
{"callee_method_names": [], "method_name": "Tables.toTable", "method_implementation": "{\n    return TableCollectors.<T, R, C, V, I>toTable(rowFunction, columnFunction, valueFunction, mergeFunction, tableSupplier);\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link Collector} that accumulates elements into a {@code Table} created using the\n * specified supplier, whose cells are generated by applying the provided mapping functions to the\n * input elements. Cells are inserted into the generated {@code Table} in encounter order.\n *\n * <p>If multiple input elements map to the same row and column, the specified merging function is\n * used to combine the values. Like {@link\n * java.util.stream.Collectors#toMap(java.util.function.Function, java.util.function.Function,\n * BinaryOperator, java.util.function.Supplier)}, this Collector throws a {@code\n * NullPointerException} on null values returned from {@code valueFunction}, and treats nulls\n * returned from {@code mergeFunction} as removals of that row/column pair.\n */\n", "repo_name": "guava-master/", "id": 5842, "method_signature": "Collector<T,?,I> toTable(java.util.function.Function, java.util.function.Function, java.util.function.Function, BinaryOperator, java.util.function.Supplier)", "filename": "Tables.toTable.json"}
{"callee_method_names": [], "method_name": "Tables.transformValues", "method_implementation": "{\n    return new TransformedTable<>(fromTable, function);\n}", "repo_id": "5", "comment": "/**\n * Returns a view of a table where each value is transformed by a function. All other properties\n * of the table, such as iteration order, are left intact.\n *\n * <p>Changes in the underlying table are reflected in this view. Conversely, this view supports\n * removal operations, and these are reflected in the underlying table.\n *\n * <p>It's acceptable for the underlying table to contain null keys, and even null values provided\n * that the function is capable of accepting null input. The transformed table might contain null\n * values, if the function sometimes gives a null result.\n *\n * <p>The returned table is not thread-safe or serializable, even if the underlying table is.\n *\n * <p>The function is applied lazily, invoked when needed. This is necessary for the returned\n * table to be a view, but it means that the function will be applied many times for bulk\n * operations like {@link Table#containsValue} and {@code Table.toString()}. For this to perform\n * well, {@code function} should be fast. To avoid lazy evaluation when the returned table doesn't\n * need to be a view, copy the returned table into a new table of your choosing.\n *\n * @since 10.0\n */\n", "repo_name": "guava-master/", "id": 5846, "method_signature": "Table<R,C,V2> transformValues(Table, Function)", "filename": "Tables.transformValues.json"}
{"callee_method_names": [], "method_name": "Tables.transpose", "method_implementation": "{\n    return (table instanceof TransposeTable) ? ((TransposeTable<R, C, V>) table).original : new TransposeTable<C, R, V>(table);\n}", "repo_id": "5", "comment": "/**\n * Creates a transposed view of a given table that flips its row and column keys. In other words,\n * calling {@code get(columnKey, rowKey)} on the generated table always returns the same value as\n * calling {@code get(rowKey, columnKey)} on the original table. Updating the original table\n * changes the contents of the transposed table and vice versa.\n *\n * <p>The returned table supports update operations as long as the input table supports the\n * analogous operation with swapped rows and columns. For example, in a {@link HashBasedTable}\n * instance, {@code rowKeySet().iterator()} supports {@code remove()} but {@code\n * columnKeySet().iterator()} doesn't. With a transposed {@link HashBasedTable}, it's the other\n * way around.\n */\n", "repo_name": "guava-master/", "id": 5844, "method_signature": "Table<C,R,V> transpose(Table)", "filename": "Tables.transpose.json"}
{"callee_method_names": [], "method_name": "Tables.unmodifiableRowSortedTable", "method_implementation": "{\n    /*\n     * It's not ? extends R, because it's technically not covariant in R. Specifically,\n     * table.rowMap().comparator() could return a comparator that only works for the ? extends R.\n     * Collections.unmodifiableSortedMap makes the same distinction.\n     */\n    return new UnmodifiableRowSortedMap<>(table);\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable view of the specified row-sorted table. This method allows modules to\n * provide users with \"read-only\" access to internal tables. Query operations on the returned\n * table \"read through\" to the specified table, and attempts to modify the returned table, whether\n * direct or via its collection views, result in an {@code UnsupportedOperationException}.\n *\n * <p>The returned table will be serializable if the specified table is serializable.\n *\n * @param table the row-sorted table for which an unmodifiable view is to be returned\n * @return an unmodifiable view of the specified table\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 5847, "method_signature": "RowSortedTable<R,C,V> unmodifiableRowSortedTable(RowSortedTable)", "filename": "Tables.unmodifiableRowSortedTable.json"}
{"callee_method_names": ["Table<String, Integer, Character>.put"], "method_name": "TablesTransformValuesTest.testPut", "method_implementation": "{\n    try {\n        table.put(\"foo\", 1, 'a');\n        fail(\"Expected UnsupportedOperationException\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertSize(0);\n}", "repo_id": "5", "comment": "// put() and putAll() aren't supported.\n", "repo_name": "guava-master/", "id": 3967, "method_signature": "void testPut()", "filename": "TablesTransformValuesTest.testPut.json"}
{"callee_method_names": ["LinkedList.clear", "Logger.log", "List<Throwable>.add", "List<Throwable>.size"], "method_name": "TearDownStack.runTearDown", "method_implementation": "{\n    List<Throwable> exceptions = new ArrayList<>();\n    List<TearDown> stackCopy;\n    synchronized (stack) {\n        stackCopy = Lists.newArrayList(stack);\n        stack.clear();\n    }\n    for (TearDown tearDown : stackCopy) {\n        try {\n            tearDown.tearDown();\n        } catch (Throwable t) {\n            if (suppressThrows) {\n                logger.log(Level.INFO, \"exception thrown during tearDown\", t);\n            } else {\n                exceptions.add(t);\n            }\n        }\n    }\n    if (!suppressThrows && (exceptions.size() > 0)) {\n        throw ClusterException.create(exceptions);\n    }\n}", "repo_id": "5", "comment": "/**\n * Causes teardown to execute.\n */\n", "repo_name": "guava-master/", "id": 4106, "method_signature": "void runTearDown()", "filename": "TearDownStack.runTearDown.json"}
{"callee_method_names": ["TearDownStack.addTearDown", "TearDownStack.size"], "method_name": "TearDownStackTest.buildTearDownStack", "method_implementation": "{\n    final TearDownStack result = new TearDownStack();\n    tearDownStack.addTearDown(new TearDown() {\n\n        @Override\n        public void tearDown() throws Exception {\n            synchronized (result.stack) {\n                assertEquals(\"The test should have cleared the stack (say, by virtue of running runTearDown)\", 0, result.stack.size());\n            }\n        }\n    });\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Builds a {@link TearDownStack} that makes sure it's clear by the end of this test.\n */\n", "repo_name": "guava-master/", "id": 4239, "method_signature": "TearDownStack buildTearDownStack()", "filename": "TearDownStackTest.buildTearDownStack.json"}
{"callee_method_names": [], "method_name": "TempFileCreator.testMakingUserPermissionsFromScratch", "method_implementation": "{\n    // All we're testing is whether it throws.\n    FileAttribute<?> unused = JavaNioCreator.userPermissions().get();\n}", "repo_id": "5", "comment": "/**\n * Creates the permissions normally used for Windows filesystems, looking up the user afresh, even\n * if previous calls have initialized the {@code PermissionSupplier} fields.\n *\n * <p>This lets us test the effects of different values of the {@code user.name} system property\n * without needing a separate VM or classloader.\n */\n", "repo_name": "guava-master/", "id": 4857, "method_signature": "void testMakingUserPermissionsFromScratch()", "filename": "TempFileCreator.testMakingUserPermissionsFromScratch.json"}
{"callee_method_names": [], "method_name": "TestEnumMultisetGenerator.order", "method_implementation": "{\n    Collections.sort(insertionOrder);\n    return insertionOrder;\n}", "repo_id": "5", "comment": "/**\n * Sorts the enums according to their natural ordering.\n */\n", "repo_name": "guava-master/", "id": 4170, "method_signature": "List<AnEnum> order(List)", "filename": "TestEnumMultisetGenerator.order.json"}
{"callee_method_names": [], "method_name": "TestEnumSetGenerator.order", "method_implementation": "{\n    Collections.sort(insertionOrder);\n    return insertionOrder;\n}", "repo_id": "5", "comment": "/**\n * Sorts the enums according to their natural ordering.\n */\n", "repo_name": "guava-master/", "id": 4160, "method_signature": "List<AnEnum> order(List)", "filename": "TestEnumSetGenerator.order.json"}
{"callee_method_names": [], "method_name": "TestIntegerSortedSetGenerator.order", "method_implementation": "{\n    Collections.sort(insertionOrder);\n    return insertionOrder;\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements by their natural ordering.\n */\n", "repo_name": "guava-master/", "id": 4196, "method_signature": "List<Integer> order(List)", "filename": "TestIntegerSortedSetGenerator.order.json"}
{"callee_method_names": ["ArrayList.add"], "method_name": "TestLogHandler.publish", "method_implementation": "{\n    if (record != null) {\n        list.add(record);\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds the most recently logged record to our list.\n */\n", "repo_name": "guava-master/", "id": 4140, "method_signature": "void publish(LogRecord)", "filename": "TestLogHandler.publish.json"}
{"callee_method_names": ["Future<V>.isDone", "Exception.getMessage", "AssertionFailedError.initCause"], "method_name": "TestPlatform.getDoneFromTimeoutOverload", "method_implementation": "{\n    checkState(future.isDone(), \"Future was expected to be done: %s\", future);\n    try {\n        return getUninterruptibly(future, 0, SECONDS);\n    } catch (TimeoutException e) {\n        AssertionFailedError error = new AssertionFailedError(e.getMessage());\n        error.initCause(e);\n        throw error;\n    }\n}", "repo_id": "5", "comment": "/**\n * Retrieves the result of a {@code Future} known to be done but uses the {@code get(long,\n * TimeUnit)} overload in order to test that method.\n */\n", "repo_name": "guava-master/", "id": 3864, "method_signature": "V getDoneFromTimeoutOverload(Future)", "filename": "TestPlatform.getDoneFromTimeoutOverload.json"}
{"callee_method_names": [], "method_name": "TestStringSortedSetGenerator.order", "method_implementation": "{\n    Collections.sort(insertionOrder);\n    return insertionOrder;\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements by their natural ordering.\n */\n", "repo_name": "guava-master/", "id": 4216, "method_signature": "List<String> order(List)", "filename": "TestStringSortedSetGenerator.order.json"}
{"callee_method_names": ["SynchronousQueue.poll"], "method_name": "TestThread.callAndAssertBlocks", "method_implementation": "{\n    checkNotNull(methodName);\n    checkNotNull(arguments);\n    assertEquals(false, invokeMethod(\"hasQueuedThread\", this));\n    sendRequest(methodName, arguments);\n    Thread.sleep(DUE_DILIGENCE_MILLIS);\n    assertEquals(true, invokeMethod(\"hasQueuedThread\", this));\n    assertNull(responseQueue.poll());\n}", "repo_id": "5", "comment": "/**\n * Causes this thread to call the named method, and asserts that this thread becomes blocked on\n * the lock-like object. The lock-like object must have a method equivalent to {@link\n * java.util.concurrent.locks.ReentrantLock#hasQueuedThread(Thread)}.\n */\n", "repo_name": "guava-master/", "id": 3827, "method_signature": "void callAndAssertBlocks(String, Object[])", "filename": "TestThread.callAndAssertBlocks.json"}
{"callee_method_names": [], "method_name": "TestThread.callAndAssertReturns", "method_implementation": "{\n    checkNotNull(methodName);\n    checkNotNull(arguments);\n    sendRequest(methodName, arguments);\n    assertEquals(expected, getResponse(methodName).getResult());\n}", "repo_id": "5", "comment": "/**\n * Causes this thread to call the named method, and asserts that the call returns the expected int\n * value.\n */\n", "repo_name": "guava-master/", "id": 3825, "method_signature": "void callAndAssertReturns(int, String, Object[])", "filename": "TestThread.callAndAssertReturns.json"}
{"callee_method_names": [], "method_name": "TestThread.callAndAssertThrows", "method_implementation": "{\n    checkNotNull(expected);\n    checkNotNull(methodName);\n    checkNotNull(arguments);\n    sendRequest(methodName, arguments);\n    assertEquals(expected, getResponse(methodName).getThrowable().getClass());\n}", "repo_id": "5", "comment": "/**\n * Causes this thread to call the named method, and asserts that the call throws the expected type\n * of throwable.\n */\n", "repo_name": "guava-master/", "id": 3826, "method_signature": "void callAndAssertThrows(Class, String, Object[])", "filename": "TestThread.callAndAssertThrows.json"}
{"callee_method_names": ["SynchronousQueue.poll"], "method_name": "TestThread.callAndAssertWaits", "method_implementation": "{\n    checkNotNull(methodName);\n    checkNotNull(conditionLikeObject);\n    // TODO: Restore the following line when Monitor.hasWaiters() no longer acquires the lock.\n    // assertEquals(false, invokeMethod(\"hasWaiters\", conditionLikeObject));\n    sendRequest(methodName, conditionLikeObject);\n    Thread.sleep(DUE_DILIGENCE_MILLIS);\n    assertEquals(true, invokeMethod(\"hasWaiters\", conditionLikeObject));\n    assertNull(responseQueue.poll());\n}", "repo_id": "5", "comment": "/**\n * Causes this thread to call the named method, and asserts that this thread thereby waits on the\n * given condition-like object. The lock-like object must have a method equivalent to {@link\n * java.util.concurrent.locks.ReentrantLock#hasWaiters(java.util.concurrent.locks.Condition)},\n * except that the method parameter must accept whatever condition-like object is passed into this\n * method.\n */\n", "repo_name": "guava-master/", "id": 3828, "method_signature": "void callAndAssertWaits(String, Object)", "filename": "TestThread.callAndAssertWaits.json"}
{"callee_method_names": ["SynchronousQueue.poll"], "method_name": "TestThread.getResponse", "method_implementation": "{\n    Response response = responseQueue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n    if (response == null) {\n        throw new TimeoutException();\n    }\n    assertEquals(methodName, response.methodName);\n    return response;\n}", "repo_id": "5", "comment": "/**\n * Receives a response from this thread.\n *\n * @throws TimeoutException if this thread does not offer a response within a reasonable amount of\n *     time\n * @throws AssertionFailedError if the given method name does not match the name of the method\n *     this thread has called most recently\n */\n", "repo_name": "guava-master/", "id": 3830, "method_signature": "Response getResponse(String)", "filename": "TestThread.getResponse.json"}
{"callee_method_names": ["SynchronousQueue.offer"], "method_name": "TestThread.sendRequest", "method_implementation": "{\n    if (!requestQueue.offer(new Request(methodName, arguments), TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n        throw new TimeoutException();\n    }\n}", "repo_id": "5", "comment": "/**\n * Sends the given method call to this thread.\n *\n * @throws TimeoutException if this thread does not accept the request within a reasonable amount\n *     of time\n */\n", "repo_name": "guava-master/", "id": 3829, "method_signature": "void sendRequest(String, Object[])", "filename": "TestThread.sendRequest.json"}
{"callee_method_names": [], "method_name": "TestThread.tearDown", "method_implementation": "{\n    stop();\n    join();\n    if (uncaughtThrowable != null) {\n        throw (AssertionFailedError) new AssertionFailedError(\"Uncaught throwable in \" + getName()).initCause(uncaughtThrowable);\n    }\n}", "repo_id": "5", "comment": "// clean up these threads.\n", "repo_name": "guava-master/", "id": 3822, "method_signature": "void tearDown()", "filename": "TestThread.tearDown.json"}
{"callee_method_names": ["Set<T>.iterator"], "method_name": "TestUtil.sanityCheckSet", "method_implementation": "{\n    assertThat(set).hasSize(Iterators.size(set.iterator()));\n    for (Object element : set) {\n        assertThat(set).contains(element);\n    }\n    assertThat(set).doesNotContain(new Object());\n    assertThat(set).isEqualTo(ImmutableSet.copyOf(set));\n    return set;\n}", "repo_id": "5", "comment": "/**\n * In some cases our graph implementations return custom sets that define their own size() and\n * contains(). Verify that these sets are consistent with the elements of their iterator.\n */\n", "repo_name": "guava-master/", "id": 4071, "method_signature": "Set<T> sanityCheckSet(Set)", "filename": "TestUtil.sanityCheckSet.json"}
{"callee_method_names": ["CacheLoader<K,V>.load", "Map<K, V>.put"], "method_name": "TestingCacheLoaders.bulkLoader", "method_implementation": "{\n    checkNotNull(loader);\n    return new CacheLoader<K, V>() {\n\n        @Override\n        public V load(K key) throws Exception {\n            return loader.load(key);\n        }\n\n        @Override\n        public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n            // allow nulls\n            Map<K, V> result = Maps.newHashMap();\n            for (K key : keys) {\n                result.put(key, load(key));\n            }\n            return result;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link CacheLoader} that implements a naive {@link CacheLoader#loadAll}, delegating\n * {@link CacheLoader#load} calls to {@code loader}.\n */\n", "repo_name": "guava-master/", "id": 3659, "method_signature": "CacheLoader<K,V> bulkLoader(CacheLoader)", "filename": "TestingCacheLoaders.bulkLoader.json"}
{"callee_method_names": [], "method_name": "TestingCacheLoaders.errorLoader", "method_implementation": "{\n    checkNotNull(e);\n    return new CacheLoader<K, V>() {\n\n        @Override\n        public V load(K key) {\n            throw e;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link CacheLoader} that throws the given error for every request.\n */\n", "repo_name": "guava-master/", "id": 3660, "method_signature": "CacheLoader<K,V> errorLoader(Error)", "filename": "TestingCacheLoaders.errorLoader.json"}
{"callee_method_names": [], "method_name": "TestingCacheLoaders.exceptionLoader", "method_implementation": "{\n    checkNotNull(e);\n    return new CacheLoader<K, V>() {\n\n        @Override\n        public V load(K key) throws Exception {\n            throw e;\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link CacheLoader} that throws the given exception for every request.\n */\n", "repo_name": "guava-master/", "id": 3661, "method_signature": "CacheLoader<K,V> exceptionLoader(Exception)", "filename": "TestingCacheLoaders.exceptionLoader.json"}
{"callee_method_names": ["M.put", "Entry<Class, Impl>.getKey", "Entry<Class, Impl>.getValue"], "method_name": "TestsForMapsInJavaUtil.populate", "method_implementation": "{\n    for (Entry<T, String> entry : entries) {\n        map.put(entry.getKey(), entry.getValue());\n    }\n    return map;\n}", "repo_id": "5", "comment": "// populate() on an empty map\n", "repo_name": "guava-master/", "id": 4205, "method_signature": "M populate(M, Entry<T,String>[])", "filename": "TestsForMapsInJavaUtil.populate.json"}
{"callee_method_names": [], "method_name": "TestsForMapsInJavaUtil.testsForSynchronizedNavigableMap", "method_implementation": "{\n    return NavigableMapTestSuiteBuilder.using(new TestStringSortedMapGenerator() {\n\n        @Override\n        protected SortedMap<String, String> create(Entry<String, String>[] entries) {\n            NavigableMap<String, String> delegate = populate(new TreeMap<>(), entries);\n            return Collections.synchronizedNavigableMap(delegate);\n        }\n    }).named(\"synchronizedNavigableMap/TreeMap, natural\").withFeatures(MapFeature.GENERAL_PURPOSE, MapFeature.ALLOWS_NULL_VALUES, MapFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION, CollectionFeature.SUPPORTS_ITERATOR_REMOVE, CollectionFeature.KNOWN_ORDER, CollectionFeature.SERIALIZABLE, CollectionSize.ANY).suppressing(suppressForSynchronizedNavigableMap()).createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Tests regular NavigableMap behavior of synchronizedNavigableMap(treeMap); does not test the\n * fact that it's synchronized.\n */\n", "repo_name": "guava-master/", "id": 752, "method_signature": "Test testsForSynchronizedNavigableMap()", "filename": "TestsForMapsInJavaUtil.testsForSynchronizedNavigableMap.json"}
{"callee_method_names": [], "method_name": "TestsForSetsInJavaUtil.testsForSynchronizedNavigableSet", "method_implementation": "{\n    return NavigableSetTestSuiteBuilder.using(new TestStringSortedSetGenerator() {\n\n        @Override\n        public SortedSet<String> create(String[] elements) {\n            NavigableSet<String> delegate = new TreeSet<>(MinimalCollection.of(elements));\n            return Collections.synchronizedNavigableSet(delegate);\n        }\n    }).named(\"synchronizedNavigableSet/TreeSet, natural\").withFeatures(SetFeature.GENERAL_PURPOSE, CollectionFeature.SERIALIZABLE, CollectionFeature.KNOWN_ORDER, CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION, CollectionSize.ANY).suppressing(suppressForSynchronizedNavigableSet()).createTestSuite();\n}", "repo_id": "5", "comment": "/**\n * Tests regular NavigableSet behavior of synchronizedNavigableSet(treeSet); does not test the\n * fact that it's synchronized.\n */\n", "repo_name": "guava-master/", "id": 746, "method_signature": "Test testsForSynchronizedNavigableSet()", "filename": "TestsForSetsInJavaUtil.testsForSynchronizedNavigableSet.json"}
{"callee_method_names": ["ThreadFactory.newThread", "Thread.setName", "Thread.setDaemon", "Thread.setPriority", "Thread.setUncaughtExceptionHandler"], "method_name": "ThreadFactoryBuilder.doBuild", "method_implementation": "{\n    String nameFormat = builder.nameFormat;\n    Boolean daemon = builder.daemon;\n    Integer priority = builder.priority;\n    UncaughtExceptionHandler uncaughtExceptionHandler = builder.uncaughtExceptionHandler;\n    ThreadFactory backingThreadFactory = (builder.backingThreadFactory != null) ? builder.backingThreadFactory : Executors.defaultThreadFactory();\n    AtomicLong count = (nameFormat != null) ? new AtomicLong(0) : null;\n    return new ThreadFactory() {\n\n        @Override\n        public Thread newThread(Runnable runnable) {\n            Thread thread = backingThreadFactory.newThread(runnable);\n            // TODO(b/139735208): Figure out what to do when the factory returns null.\n            requireNonNull(thread);\n            if (nameFormat != null) {\n                // requireNonNull is safe because we create `count` if (and only if) we have a nameFormat.\n                thread.setName(format(nameFormat, requireNonNull(count).getAndIncrement()));\n            }\n            if (daemon != null) {\n                thread.setDaemon(daemon);\n            }\n            if (priority != null) {\n                thread.setPriority(priority);\n            }\n            if (uncaughtExceptionHandler != null) {\n                thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);\n            }\n            return thread;\n        }\n    };\n}", "repo_id": "5", "comment": "// At least, I assume that's why. TODO(cpovirk): Check, and maybe add a test for this.\n", "repo_name": "guava-master/", "id": 5366, "method_signature": "ThreadFactory doBuild(ThreadFactoryBuilder)", "filename": "ThreadFactoryBuilder.doBuild.json"}
{"callee_method_names": [], "method_name": "ThreadFactoryBuilder.setDaemon", "method_implementation": "{\n    this.daemon = daemon;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets daemon or not for new threads created with this ThreadFactory.\n *\n * @param daemon whether or not new Threads created with this ThreadFactory will be daemon threads\n * @return this for the builder pattern\n */\n", "repo_name": "guava-master/", "id": 5362, "method_signature": "ThreadFactoryBuilder setDaemon(boolean)", "filename": "ThreadFactoryBuilder.setDaemon.json"}
{"callee_method_names": [], "method_name": "ThreadFactoryBuilder.setNameFormat", "method_implementation": "{\n    // fail fast if the format is bad or null\n    String unused = format(nameFormat, 0);\n    this.nameFormat = nameFormat;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the naming format to use when naming threads ({@link Thread#setName}) which are created\n * with this ThreadFactory.\n *\n * @param nameFormat a {@link String#format(String, Object...)}-compatible format String, to which\n *     a unique integer (0, 1, etc.) will be supplied as the single parameter. This integer will\n *     be unique to the built instance of the ThreadFactory and will be assigned sequentially. For\n *     example, {@code \"rpc-pool-%d\"} will generate thread names like {@code \"rpc-pool-0\"}, {@code\n *     \"rpc-pool-1\"}, {@code \"rpc-pool-2\"}, etc.\n * @return this for the builder pattern\n */\n", "repo_name": "guava-master/", "id": 5361, "method_signature": "ThreadFactoryBuilder setNameFormat(String)", "filename": "ThreadFactoryBuilder.setNameFormat.json"}
{"callee_method_names": [], "method_name": "ThreadFactoryBuilder.setPriority", "method_implementation": "{\n    // Thread#setPriority() already checks for validity. These error messages\n    // are nicer though and will fail-fast.\n    checkArgument(priority >= Thread.MIN_PRIORITY, \"Thread priority (%s) must be >= %s\", priority, Thread.MIN_PRIORITY);\n    checkArgument(priority <= Thread.MAX_PRIORITY, \"Thread priority (%s) must be <= %s\", priority, Thread.MAX_PRIORITY);\n    this.priority = priority;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the priority for new threads created with this ThreadFactory.\n *\n * <p><b>Warning:</b> relying on the thread scheduler is <a\n * href=\"http://errorprone.info/bugpattern/ThreadPriorityCheck\">discouraged</a>.\n *\n * @param priority the priority for new Threads created with this ThreadFactory\n * @return this for the builder pattern\n */\n", "repo_name": "guava-master/", "id": 5363, "method_signature": "ThreadFactoryBuilder setPriority(int)", "filename": "ThreadFactoryBuilder.setPriority.json"}
{"callee_method_names": [], "method_name": "ThreadFactoryBuilder.setThreadFactory", "method_implementation": "{\n    this.backingThreadFactory = checkNotNull(backingThreadFactory);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the backing {@link ThreadFactory} for new threads created with this ThreadFactory. Threads\n * will be created by invoking #newThread(Runnable) on this backing {@link ThreadFactory}.\n *\n * @param backingThreadFactory the backing {@link ThreadFactory} which will be delegated to during\n *     thread creation.\n * @return this for the builder pattern\n * @see MoreExecutors\n */\n", "repo_name": "guava-master/", "id": 5365, "method_signature": "ThreadFactoryBuilder setThreadFactory(ThreadFactory)", "filename": "ThreadFactoryBuilder.setThreadFactory.json"}
{"callee_method_names": [], "method_name": "ThreadFactoryBuilder.setUncaughtExceptionHandler", "method_implementation": "{\n    this.uncaughtExceptionHandler = checkNotNull(uncaughtExceptionHandler);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Sets the {@link UncaughtExceptionHandler} for new threads created with this ThreadFactory.\n *\n * @param uncaughtExceptionHandler the uncaught exception handler for new Threads created with\n *     this ThreadFactory\n * @return this for the builder pattern\n */\n", "repo_name": "guava-master/", "id": 5364, "method_signature": "ThreadFactoryBuilder setUncaughtExceptionHandler(UncaughtExceptionHandler)", "filename": "ThreadFactoryBuilder.setUncaughtExceptionHandler.json"}
{"callee_method_names": ["CountDownLatch.await"], "method_name": "ThreadedService.awaitRunChecks", "method_implementation": "{\n    assertTrue(\"Service thread hasn't finished its checks. \" + \"Exception status (possibly stale): \" + thrownByExecutionThread, hasConfirmedIsRunning.await(10, SECONDS));\n}", "repo_id": "5", "comment": "/*\n     * The main test thread tries to stop() the service shortly after\n     * confirming that it is running. Meanwhile, the service itself is trying\n     * to confirm that it is running. If the main thread's stop() call happens\n     * before it has the chance, the test will fail. To avoid this, the main\n     * thread calls this method, which waits until the service has performed\n     * its own \"running\" check.\n     */\n", "repo_name": "guava-master/", "id": 3818, "method_signature": "void awaitRunChecks()", "filename": "ThreadedService.awaitRunChecks.json"}
{"callee_method_names": [], "method_name": "Throwables.get", "method_implementation": "{\n    return (StackTraceElement) invokeAccessibleNonThrowingMethod(requireNonNull(getStackTraceElementMethod), requireNonNull(jla), t, n);\n}", "repo_id": "5", "comment": "/*\n       * The following requireNonNull calls are safe because we use jlaStackTrace() only if\n       * lazyStackTraceIsLazy() returns true.\n       */\n", "repo_name": "guava-master/", "id": 5120, "method_signature": "StackTraceElement get(int)", "filename": "Throwables.get.json"}
{"callee_method_names": ["List<Throwable>.add", "Throwable.getCause", "List<Throwable>.add", "Throwable.getCause"], "method_name": "Throwables.getCausalChain", "method_implementation": "{\n    checkNotNull(throwable);\n    List<Throwable> causes = new ArrayList<>(4);\n    causes.add(throwable);\n    // Keep a second pointer that slowly walks the causal chain. If the fast pointer ever catches\n    // the slower pointer, then there's a loop.\n    Throwable slowPointer = throwable;\n    boolean advanceSlowPointer = false;\n    Throwable cause;\n    while ((cause = throwable.getCause()) != null) {\n        throwable = cause;\n        causes.add(throwable);\n        if (throwable == slowPointer) {\n            throw new IllegalArgumentException(\"Loop in causal chain detected.\", throwable);\n        }\n        if (advanceSlowPointer) {\n            slowPointer = slowPointer.getCause();\n        }\n        // only advance every other iteration\n        advanceSlowPointer = !advanceSlowPointer;\n    }\n    return Collections.unmodifiableList(causes);\n}", "repo_id": "5", "comment": "/**\n * Gets a {@code Throwable} cause chain as a list. The first entry in the list will be {@code\n * throwable} followed by its cause hierarchy. Note that this is a snapshot of the cause chain and\n * will not reflect any subsequent changes to the cause chain.\n *\n * <p>Here's an example of how it can be used to find specific types of exceptions in the cause\n * chain:\n *\n * <pre>\n * Iterables.filter(Throwables.getCausalChain(e), IOException.class));\n * </pre>\n *\n * @param throwable the non-null {@code Throwable} to extract causes from\n * @return an unmodifiable list containing the cause chain starting with {@code throwable}\n * @throws IllegalArgumentException if there is a loop in the causal chain\n */\n", "repo_name": "guava-master/", "id": 5115, "method_signature": "List<Throwable> getCausalChain(Throwable)", "filename": "Throwables.getCausalChain.json"}
{"callee_method_names": ["Class<X>.cast", "Throwable.getCause", "Entry<?, ?>.initCause"], "method_name": "Throwables.getCauseAs", "method_implementation": "{\n    try {\n        return expectedCauseType.cast(throwable.getCause());\n    } catch (ClassCastException e) {\n        e.initCause(throwable);\n        throw e;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns {@code throwable}'s cause, cast to {@code expectedCauseType}.\n *\n * <p>Prefer this method instead of manually casting an exception's cause. For example, {@code\n * (IOException) e.getCause()} throws a {@link ClassCastException} that discards the original\n * exception {@code e} if the cause is not an {@link IOException}, but {@code\n * Throwables.getCauseAs(e, IOException.class)} keeps {@code e} as the {@link\n * ClassCastException}'s cause.\n *\n * @throws ClassCastException if the cause cannot be cast to the expected type. The {@code\n *     ClassCastException}'s cause is {@code throwable}.\n * @since 22.0\n */\n", "repo_name": "guava-master/", "id": 5116, "method_signature": "X getCauseAs(Throwable, Class)", "filename": "Throwables.getCauseAs.json"}
{"callee_method_names": [], "method_name": "Throwables.getGetMethod", "method_implementation": "{\n    return getJlaMethod(\"getStackTraceElement\", Throwable.class, int.class);\n}", "repo_id": "5", "comment": "/**\n * Returns the Method that can be used to resolve an individual StackTraceElement, or null if that\n * method cannot be found (it is only to be found in fairly recent JDKs).\n */\n", "repo_name": "guava-master/", "id": 5122, "method_signature": "Method getGetMethod()", "filename": "Throwables.getGetMethod.json"}
{"callee_method_names": ["Class<?>.getMethod", "Method.invoke"], "method_name": "Throwables.getJLA", "method_implementation": "{\n    try {\n        /*\n       * We load sun.misc.* classes using reflection since Android doesn't support these classes and\n       * would result in compilation failure if we directly refer to these classes.\n       */\n        Class<?> sharedSecrets = Class.forName(SHARED_SECRETS_CLASSNAME, false, null);\n        Method langAccess = sharedSecrets.getMethod(\"getJavaLangAccess\");\n        return langAccess.invoke(null);\n    } catch (ThreadDeath death) {\n        throw death;\n    } catch (Throwable t) {\n        /*\n       * This is not one of AppEngine's allowed classes, so even in Sun JDKs, this can fail with\n       * a NoClassDefFoundError. Other apps might deny access to sun.misc packages.\n       */\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not allowed in\n * AppEngine, and not present in non-Sun JDKs.\n */\n", "repo_name": "guava-master/", "id": 5121, "method_signature": "Object getJLA()", "filename": "Throwables.getJLA.json"}
{"callee_method_names": ["Throwable.getCause", "Throwable.getCause"], "method_name": "Throwables.getRootCause", "method_implementation": "{\n    // Keep a second pointer that slowly walks the causal chain. If the fast pointer ever catches\n    // the slower pointer, then there's a loop.\n    Throwable slowPointer = throwable;\n    boolean advanceSlowPointer = false;\n    Throwable cause;\n    while ((cause = throwable.getCause()) != null) {\n        throwable = cause;\n        if (throwable == slowPointer) {\n            throw new IllegalArgumentException(\"Loop in causal chain detected.\", throwable);\n        }\n        if (advanceSlowPointer) {\n            slowPointer = slowPointer.getCause();\n        }\n        // only advance every other iteration\n        advanceSlowPointer = !advanceSlowPointer;\n    }\n    return throwable;\n}", "repo_id": "5", "comment": "/**\n * Returns the innermost cause of {@code throwable}. The first throwable in a chain provides\n * context from when the error or exception was initially detected. Example usage:\n *\n * <pre>\n * assertEquals(\"Unable to assign a customer id\", Throwables.getRootCause(e).getMessage());\n * </pre>\n *\n * @throws IllegalArgumentException if there is a loop in the causal chain\n */\n", "repo_name": "guava-master/", "id": 5114, "method_signature": "Throwable getRootCause(Throwable)", "filename": "Throwables.getRootCause.json"}
{"callee_method_names": ["Method.invoke"], "method_name": "Throwables.getSizeMethod", "method_implementation": "{\n    try {\n        Method getStackTraceDepth = getJlaMethod(\"getStackTraceDepth\", Throwable.class);\n        if (getStackTraceDepth == null) {\n            return null;\n        }\n        getStackTraceDepth.invoke(jla, new Throwable());\n        return getStackTraceDepth;\n    } catch (UnsupportedOperationException | IllegalAccessException | InvocationTargetException e) {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the Method that can be used to return the size of a stack, or null if that method\n * cannot be found (it is only to be found in fairly recent JDKs). Tries to test method {@link\n * sun.misc.JavaLangAccess#getStackTraceDepth(Throwable) getStackTraceDepth} prior to return it\n * (might fail some JDKs).\n *\n * <p>See <a href=\"https://github.com/google/guava/issues/2887\">Throwables#lazyStackTrace throws\n * UnsupportedOperationException</a>.\n */\n", "repo_name": "guava-master/", "id": 5123, "method_signature": "Method getSizeMethod(Object)", "filename": "Throwables.getSizeMethod.json"}
{"callee_method_names": ["Throwable.printStackTrace", "StringWriter.toString"], "method_name": "Throwables.getStackTraceAsString", "method_implementation": "{\n    StringWriter stringWriter = new StringWriter();\n    throwable.printStackTrace(new PrintWriter(stringWriter));\n    return stringWriter.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the result of {@link Throwable#toString() toString()}, followed by\n * the full, recursive stack trace of {@code throwable}. Note that you probably should not be\n * parsing the resulting string; if you need programmatic access to the stack frames, you can call\n * {@link Throwable#getStackTrace()}.\n */\n", "repo_name": "guava-master/", "id": 5117, "method_signature": "String getStackTraceAsString(Throwable)", "filename": "Throwables.getStackTraceAsString.json"}
{"callee_method_names": ["Throwable.getStackTrace"], "method_name": "Throwables.lazyStackTrace", "method_implementation": "{\n    return lazyStackTraceIsLazy() ? jlaStackTrace(throwable) : unmodifiableList(asList(throwable.getStackTrace()));\n}", "repo_id": "5", "comment": "/**\n * Returns the stack trace of {@code throwable}, possibly providing slower iteration over the full\n * trace but faster iteration over parts of the trace. Here, \"slower\" and \"faster\" are defined in\n * comparison to the normal way to access the stack trace, {@link Throwable#getStackTrace()\n * throwable.getStackTrace()}. Note, however, that this method's special implementation is not\n * available for all platforms and configurations. If that implementation is unavailable, this\n * method falls back to {@code getStackTrace}. Callers that require the special implementation can\n * check its availability with {@link #lazyStackTraceIsLazy()}.\n *\n * <p>The expected (but not guaranteed) performance of the special implementation differs from\n * {@code getStackTrace} in one main way: The {@code lazyStackTrace} call itself returns quickly\n * by delaying the per-stack-frame work until each element is accessed. Roughly speaking:\n *\n * <ul>\n *   <li>{@code getStackTrace} takes {@code stackSize} time to return but then negligible time to\n *       retrieve each element of the returned list.\n *   <li>{@code lazyStackTrace} takes negligible time to return but then {@code 1/stackSize} time\n *       to retrieve each element of the returned list (probably slightly more than {@code\n *       1/stackSize}).\n * </ul>\n *\n * <p>Note: The special implementation does not respect calls to {@link Throwable#setStackTrace\n * throwable.setStackTrace}. Instead, it always reflects the original stack trace from the\n * exception's creation.\n *\n * @since 19.0\n * @deprecated This method is equivalent to {@link Throwable#getStackTrace()} on JDK versions past\n *     JDK 8 and on all Android versions. Use {@link Throwable#getStackTrace()} directly, or where\n *     possible use the {@code java.lang.StackWalker.walk} method introduced in JDK 9.\n */\n", "repo_name": "guava-master/", "id": 5118, "method_signature": "List<StackTraceElement> lazyStackTrace(Throwable)", "filename": "Throwables.lazyStackTrace.json"}
{"callee_method_names": [], "method_name": "Throwables.lazyStackTraceIsLazy", "method_implementation": "{\n    return getStackTraceElementMethod != null && getStackTraceDepthMethod != null;\n}", "repo_id": "5", "comment": "/**\n * Returns whether {@link #lazyStackTrace} will use the special implementation described in its\n * documentation.\n *\n * @since 19.0\n * @deprecated This method always returns false on JDK versions past JDK 8 and on all Android\n *     versions.\n */\n", "repo_name": "guava-master/", "id": 5119, "method_signature": "boolean lazyStackTraceIsLazy()", "filename": "Throwables.lazyStackTraceIsLazy.json"}
{"callee_method_names": [], "method_name": "Throwables.propagate", "method_implementation": "{\n    throwIfUnchecked(throwable);\n    throw new RuntimeException(throwable);\n}", "repo_id": "5", "comment": "/**\n * Propagates {@code throwable} as-is if it is an instance of {@link RuntimeException} or {@link\n * Error}, or else as a last resort, wraps it in a {@code RuntimeException} and then propagates.\n *\n * <p>This method always throws an exception. The {@code RuntimeException} return type allows\n * client code to signal to the compiler that statements after the call are unreachable. Example\n * usage:\n *\n * <pre>\n * T doSomething() {\n *   try {\n *     return someMethodThatCouldThrowAnything();\n *   } catch (IKnowWhatToDoWithThisException e) {\n *     return handle(e);\n *   } catch (Throwable t) {\n *     throw Throwables.propagate(t);\n *   }\n * }\n * </pre>\n *\n * @param throwable the Throwable to propagate\n * @return nothing will ever be returned; this return type is only for your convenience, as\n *     illustrated in the example above\n * @deprecated To preserve behavior, use {@code throw e} or {@code throw new RuntimeException(e)}\n *     directly, or use a combination of {@link #throwIfUnchecked} and {@code throw new\n *     RuntimeException(e)}. But consider whether users would be better off if your API threw a\n *     different type of exception. For background on the deprecation, read <a\n *     href=\"https://goo.gl/Ivn2kc\">Why we deprecated {@code Throwables.propagate}</a>.\n */\n", "repo_name": "guava-master/", "id": 5113, "method_signature": "RuntimeException propagate(Throwable)", "filename": "Throwables.propagate.json"}
{"callee_method_names": [], "method_name": "Throwables.propagateIfInstanceOf", "method_implementation": "{\n    if (throwable != null) {\n        throwIfInstanceOf(throwable, declaredType);\n    }\n}", "repo_id": "5", "comment": "/**\n * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@code\n * declaredType}. Example usage:\n *\n * <pre>\n * try {\n *   someMethodThatCouldThrowAnything();\n * } catch (IKnowWhatToDoWithThisException e) {\n *   handle(e);\n * } catch (Throwable t) {\n *   Throwables.propagateIfInstanceOf(t, IOException.class);\n *   Throwables.propagateIfInstanceOf(t, SQLException.class);\n *   throw Throwables.propagate(t);\n * }\n * </pre>\n *\n * @deprecated Use {@link #throwIfInstanceOf}, which has the same behavior but rejects {@code\n *     null}.\n */\n", "repo_name": "guava-master/", "id": 5108, "method_signature": "void propagateIfInstanceOf(Throwable, Class)", "filename": "Throwables.propagateIfInstanceOf.json"}
{"callee_method_names": [], "method_name": "Throwables.propagateIfPossible", "method_implementation": "{\n    checkNotNull(declaredType2);\n    propagateIfInstanceOf(throwable, declaredType1);\n    propagateIfPossible(throwable, declaredType2);\n}", "repo_id": "5", "comment": "/**\n * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link\n * RuntimeException}, {@link Error}, {@code declaredType1}, or {@code declaredType2}.\n *\n * <p><b>Discouraged</b> in favor of calling {@link #throwIfInstanceOf} and {@link\n * #throwIfUnchecked}.\n *\n * @param throwable the Throwable to possibly propagate\n * @param declaredType1 any checked exception type declared by the calling method\n * @param declaredType2 any other checked exception type declared by the calling method\n */\n", "repo_name": "guava-master/", "id": 5112, "method_signature": "void propagateIfPossible(Throwable, Class, Class)", "filename": "Throwables.propagateIfPossible.json"}
{"callee_method_names": ["Class<X>.isInstance", "Class<X>.cast"], "method_name": "Throwables.throwIfInstanceOf", "method_implementation": "{\n    checkNotNull(throwable);\n    if (declaredType.isInstance(throwable)) {\n        throw declaredType.cast(throwable);\n    }\n}", "repo_id": "5", "comment": "/**\n * Throws {@code throwable} if it is an instance of {@code declaredType}. Example usage:\n *\n * <pre>\n * for (Foo foo : foos) {\n *   try {\n *     foo.bar();\n *   } catch (BarException | RuntimeException | Error t) {\n *     failure = t;\n *   }\n * }\n * if (failure != null) {\n *   throwIfInstanceOf(failure, BarException.class);\n *   throwIfUnchecked(failure);\n *   throw new AssertionError(failure);\n * }\n * </pre>\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 5107, "method_signature": "void throwIfInstanceOf(Throwable, Class)", "filename": "Throwables.throwIfInstanceOf.json"}
{"callee_method_names": [], "method_name": "Throwables.throwIfUnchecked", "method_implementation": "{\n    checkNotNull(throwable);\n    if (throwable instanceof RuntimeException) {\n        throw (RuntimeException) throwable;\n    }\n    if (throwable instanceof Error) {\n        throw (Error) throwable;\n    }\n}", "repo_id": "5", "comment": "/**\n * Throws {@code throwable} if it is a {@link RuntimeException} or {@link Error}. Example usage:\n *\n * <pre>\n * for (Foo foo : foos) {\n *   try {\n *     foo.bar();\n *   } catch (RuntimeException | Error t) {\n *     failure = t;\n *   }\n * }\n * if (failure != null) {\n *   throwIfUnchecked(failure);\n *   throw new AssertionError(failure);\n * }\n * </pre>\n *\n * @since 20.0\n */\n", "repo_name": "guava-master/", "id": 5109, "method_signature": "void throwIfUnchecked(Throwable)", "filename": "Throwables.throwIfUnchecked.json"}
{"callee_method_names": [], "method_name": "TimeLimiter.callUninterruptiblyWithTimeout", "method_implementation": "{\n    return callUninterruptiblyWithTimeout(callable, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);\n}", "repo_id": "5", "comment": "/**\n * Invokes a specified Callable, timing out after the specified time limit. If the target method\n * call finishes before the limit is reached, the return value or a wrapped exception is\n * propagated. If, on the other hand, the time limit is reached, we attempt to abort the call to\n * the target, and throw a {@link TimeoutException} to the caller.\n *\n * <p>The difference with {@link #callWithTimeout(Callable, Duration)} is that this method will\n * ignore interrupts on the current thread.\n *\n * @param callable the Callable to execute\n * @param timeout the maximum length of time to wait\n * @return the result returned by the Callable\n * @throws TimeoutException if the time limit is reached\n * @throws ExecutionException if {@code callable} throws a checked exception\n * @throws UncheckedExecutionException if {@code callable} throws a {@code RuntimeException}\n * @throws ExecutionError if {@code callable} throws an {@code Error}\n * @since 28.0\n */\n", "repo_name": "guava-master/", "id": 2072, "method_signature": "T callUninterruptiblyWithTimeout(Callable, Duration)", "filename": "TimeLimiter.callUninterruptiblyWithTimeout.json"}
{"callee_method_names": [], "method_name": "TimeLimiter.callWithTimeout", "method_implementation": "{\n    return callWithTimeout(callable, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);\n}", "repo_id": "5", "comment": "/**\n * Invokes a specified Callable, timing out after the specified time limit. If the target method\n * call finishes before the limit is reached, the return value or a wrapped exception is\n * propagated. If, on the other hand, the time limit is reached, we attempt to abort the call to\n * the target, and throw a {@link TimeoutException} to the caller.\n *\n * @param callable the Callable to execute\n * @param timeout the maximum length of time to wait\n * @return the result returned by the Callable\n * @throws TimeoutException if the time limit is reached\n * @throws InterruptedException if the current thread was interrupted during execution\n * @throws ExecutionException if {@code callable} throws a checked exception\n * @throws UncheckedExecutionException if {@code callable} throws a {@code RuntimeException}\n * @throws ExecutionError if {@code callable} throws an {@code Error}\n * @since 28.0\n */\n", "repo_name": "guava-master/", "id": 2071, "method_signature": "T callWithTimeout(Callable, Duration)", "filename": "TimeLimiter.callWithTimeout.json"}
{"callee_method_names": ["Completion.assertCompletionExpected", "BlockingQueue<String>.peek"], "method_name": "TimedPutQueue.putSuccessfully", "method_implementation": "{\n    putUninterruptibly(queue, \"\");\n    completed.assertCompletionExpected();\n    assertEquals(\"\", queue.peek());\n}", "repo_id": "5", "comment": "/**\n * Perform a {@code put} and assert that operation completed in the expected timeframe.\n */\n", "repo_name": "guava-master/", "id": 3935, "method_signature": "void putSuccessfully()", "filename": "TimedPutQueue.putSuccessfully.json"}
{"callee_method_names": ["Completion.assertCompletionExpected", "BlockingQueue<String>.isEmpty"], "method_name": "TimedTakeQueue.takeSuccessfully", "method_implementation": "{\n    assertEquals(EXPECTED_TAKE, takeUninterruptibly(queue));\n    completed.assertCompletionExpected();\n    assertTrue(queue.isEmpty());\n}", "repo_id": "5", "comment": "/**\n * Perform a {@code take} and assert that operation completed in the expected timeframe.\n */\n", "repo_name": "guava-master/", "id": 3936, "method_signature": "void takeSuccessfully()", "filename": "TimedTakeQueue.takeSuccessfully.json"}
{"callee_method_names": ["X.compareTo", "X.compareTo"], "method_name": "ToDoubleRounder.roundToDouble", "method_implementation": "{\n    checkNotNull(x, \"x\");\n    checkNotNull(mode, \"mode\");\n    double roundArbitrarily = roundToDoubleArbitrarily(x);\n    if (Double.isInfinite(roundArbitrarily)) {\n        switch(mode) {\n            case DOWN:\n            case HALF_EVEN:\n            case HALF_DOWN:\n            case HALF_UP:\n                return Double.MAX_VALUE * sign(x);\n            case FLOOR:\n                return (roundArbitrarily == Double.POSITIVE_INFINITY) ? Double.MAX_VALUE : Double.NEGATIVE_INFINITY;\n            case CEILING:\n                return (roundArbitrarily == Double.POSITIVE_INFINITY) ? Double.POSITIVE_INFINITY : -Double.MAX_VALUE;\n            case UP:\n                return roundArbitrarily;\n            case UNNECESSARY:\n                throw new ArithmeticException(x + \" cannot be represented precisely as a double\");\n        }\n    }\n    X roundArbitrarilyAsX = toX(roundArbitrarily, RoundingMode.UNNECESSARY);\n    int cmpXToRoundArbitrarily = x.compareTo(roundArbitrarilyAsX);\n    switch(mode) {\n        case UNNECESSARY:\n            checkRoundingUnnecessary(cmpXToRoundArbitrarily == 0);\n            return roundArbitrarily;\n        case FLOOR:\n            return (cmpXToRoundArbitrarily >= 0) ? roundArbitrarily : DoubleUtils.nextDown(roundArbitrarily);\n        case CEILING:\n            return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n        case DOWN:\n            if (sign(x) >= 0) {\n                return (cmpXToRoundArbitrarily >= 0) ? roundArbitrarily : DoubleUtils.nextDown(roundArbitrarily);\n            } else {\n                return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n            }\n        case UP:\n            if (sign(x) >= 0) {\n                return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n            } else {\n                return (cmpXToRoundArbitrarily >= 0) ? roundArbitrarily : DoubleUtils.nextDown(roundArbitrarily);\n            }\n        case HALF_DOWN:\n        case HALF_UP:\n        case HALF_EVEN:\n            {\n                X roundFloor;\n                double roundFloorAsDouble;\n                X roundCeiling;\n                double roundCeilingAsDouble;\n                if (cmpXToRoundArbitrarily >= 0) {\n                    roundFloorAsDouble = roundArbitrarily;\n                    roundFloor = roundArbitrarilyAsX;\n                    roundCeilingAsDouble = Math.nextUp(roundArbitrarily);\n                    if (roundCeilingAsDouble == Double.POSITIVE_INFINITY) {\n                        return roundFloorAsDouble;\n                    }\n                    roundCeiling = toX(roundCeilingAsDouble, RoundingMode.CEILING);\n                } else {\n                    roundCeilingAsDouble = roundArbitrarily;\n                    roundCeiling = roundArbitrarilyAsX;\n                    roundFloorAsDouble = DoubleUtils.nextDown(roundArbitrarily);\n                    if (roundFloorAsDouble == Double.NEGATIVE_INFINITY) {\n                        return roundCeilingAsDouble;\n                    }\n                    roundFloor = toX(roundFloorAsDouble, RoundingMode.FLOOR);\n                }\n                X deltaToFloor = minus(x, roundFloor);\n                X deltaToCeiling = minus(roundCeiling, x);\n                int diff = deltaToFloor.compareTo(deltaToCeiling);\n                if (diff < 0) {\n                    // closer to floor\n                    return roundFloorAsDouble;\n                } else if (diff > 0) {\n                    // closer to ceiling\n                    return roundCeilingAsDouble;\n                }\n                // halfway between the representable values; do the half-whatever logic\n                switch(mode) {\n                    case HALF_EVEN:\n                        // roundFloorAsDouble and roundCeilingAsDouble are neighbors, so precisely\n                        // one of them should have an even long representation\n                        return ((Double.doubleToRawLongBits(roundFloorAsDouble) & 1L) == 0) ? roundFloorAsDouble : roundCeilingAsDouble;\n                    case HALF_DOWN:\n                        return (sign(x) >= 0) ? roundFloorAsDouble : roundCeilingAsDouble;\n                    case HALF_UP:\n                        return (sign(x) >= 0) ? roundCeilingAsDouble : roundFloorAsDouble;\n                    default:\n                        throw new AssertionError(\"impossible\");\n                }\n            }\n    }\n    throw new AssertionError(\"impossible\");\n}", "repo_id": "5", "comment": "/**\n * Rounds {@code x} to a {@code double}.\n */\n", "repo_name": "guava-master/", "id": 4589, "method_signature": "double roundToDouble(X, RoundingMode)", "filename": "ToDoubleRounder.roundToDouble.json"}
{"callee_method_names": [], "method_name": "ToStringHelper.omitNullValues", "method_implementation": "{\n    omitNullValues = true;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Configures the {@link ToStringHelper} so {@link #toString()} will ignore properties with null\n * value. The order of calling this method, relative to the {@code add()}/{@code addValue()}\n * methods, is not significant.\n *\n * @since 18.0 (since 12.0 as {@code Objects.ToStringHelper.omitNullValues()}).\n */\n", "repo_name": "guava-master/", "id": 5165, "method_signature": "ToStringHelper omitNullValues()", "filename": "ToStringHelper.omitNullValues.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "Object.getClass", "StringBuilder.append", "String.length", "StringBuilder.append", "StringBuilder.append"], "method_name": "ToStringHelper.toString", "method_implementation": "{\n    // create a copy to keep it consistent in case value changes\n    boolean omitNullValuesSnapshot = omitNullValues;\n    boolean omitEmptyValuesSnapshot = omitEmptyValues;\n    String nextSeparator = \"\";\n    StringBuilder builder = new StringBuilder(32).append(className).append('{');\n    for (ValueHolder valueHolder = holderHead.next; valueHolder != null; valueHolder = valueHolder.next) {\n        Object value = valueHolder.value;\n        if (valueHolder instanceof UnconditionalValueHolder || (value == null ? !omitNullValuesSnapshot : (!omitEmptyValuesSnapshot || !isEmpty(value)))) {\n            builder.append(nextSeparator);\n            nextSeparator = \", \";\n            if (valueHolder.name != null) {\n                builder.append(valueHolder.name).append('=');\n            }\n            if (value != null && value.getClass().isArray()) {\n                Object[] objectArray = { value };\n                String arrayString = Arrays.deepToString(objectArray);\n                builder.append(arrayString, 1, arrayString.length() - 1);\n            } else {\n                builder.append(value);\n            }\n        }\n    }\n    return builder.append('}').toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string in the format specified by {@link MoreObjects#toStringHelper(Object)}.\n *\n * <p>After calling this method, you can keep adding more properties to later call toString()\n * again and get a more complete representation of the same object; but properties cannot be\n * removed, so this only allows limited reuse of the helper instance. The helper allows\n * duplication of properties (multiple name/value pairs with the same name can be added).\n */\n", "repo_name": "guava-master/", "id": 5166, "method_signature": "String toString()", "filename": "ToStringHelper.toString.json"}
{"callee_method_names": [], "method_name": "ToStringHelperTest.testToString_oneField", "method_implementation": "{\n    String toTest = MoreObjects.toStringHelper(new TestClass()).add(\"field1\", \"Hello\").toString();\n    assertEquals(\"TestClass{field1=Hello}\", toTest);\n}", "repo_id": "5", "comment": "// all remaining test are on an inner class with various fields\n", "repo_name": "guava-master/", "id": 3692, "method_signature": "void testToString_oneField()", "filename": "ToStringHelperTest.testToString_oneField.json"}
{"callee_method_names": ["Comparator<? super T>.compare", "Comparator<? super T>.compare"], "method_name": "TopKSelector.offer", "method_implementation": "{\n    if (k == 0) {\n        return;\n    } else if (bufferSize == 0) {\n        buffer[0] = elem;\n        threshold = elem;\n        bufferSize = 1;\n    } else if (bufferSize < k) {\n        buffer[bufferSize++] = elem;\n        // uncheckedCastNullableTToT is safe because bufferSize > 0.\n        if (comparator.compare(elem, uncheckedCastNullableTToT(threshold)) > 0) {\n            threshold = elem;\n        }\n        // uncheckedCastNullableTToT is safe because bufferSize > 0.\n    } else if (comparator.compare(elem, uncheckedCastNullableTToT(threshold)) < 0) {\n        // Otherwise, we can ignore elem; we've seen k better elements.\n        buffer[bufferSize++] = elem;\n        if (bufferSize == 2 * k) {\n            trim();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds {@code elem} as a candidate for the top {@code k} elements. This operation takes amortized\n * O(1) time.\n */\n", "repo_name": "guava-master/", "id": 6133, "method_signature": "void offer(T)", "filename": "TopKSelector.offer.json"}
{"callee_method_names": ["Iterator<? extends T>.hasNext", "Iterator<? extends T>.next"], "method_name": "TopKSelector.offerAll", "method_implementation": "{\n    while (elements.hasNext()) {\n        offer(elements.next());\n    }\n}", "repo_id": "5", "comment": "/**\n * Adds each member of {@code elements} as a candidate for the top {@code k} elements. This\n * operation takes amortized linear time in the length of {@code elements}. The iterator is\n * consumed after this operation completes.\n *\n * <p>If all input data to this {@code TopKSelector} is in a single {@code Iterator}, prefer\n * {@link Ordering#leastOf(Iterator, int)}, which provides a simpler API for that use case.\n */\n", "repo_name": "guava-master/", "id": 6136, "method_signature": "void offerAll(Iterator)", "filename": "TopKSelector.offerAll.json"}
{"callee_method_names": ["Comparator<? super T>.compare"], "method_name": "TopKSelector.partition", "method_implementation": "{\n    T pivotValue = uncheckedCastNullableTToT(buffer[pivotIndex]);\n    buffer[pivotIndex] = buffer[right];\n    int pivotNewIndex = left;\n    for (int i = left; i < right; i++) {\n        if (comparator.compare(uncheckedCastNullableTToT(buffer[i]), pivotValue) < 0) {\n            swap(pivotNewIndex, i);\n            pivotNewIndex++;\n        }\n    }\n    buffer[right] = buffer[pivotNewIndex];\n    buffer[pivotNewIndex] = pivotValue;\n    return pivotNewIndex;\n}", "repo_id": "5", "comment": "/**\n * Partitions the contents of buffer in the range [left, right] around the pivot element\n * previously stored in buffer[pivotValue]. Returns the new index of the pivot element,\n * pivotNewIndex, so that everything in [left, pivotNewIndex] is \u2264 pivotValue and everything in\n * (pivotNewIndex, right] is greater than pivotValue.\n */\n", "repo_name": "guava-master/", "id": 6135, "method_signature": "int partition(int, int, int)", "filename": "TopKSelector.partition.json"}
{"callee_method_names": [], "method_name": "TopKSelector.topK", "method_implementation": "{\n    // safe because we pass sort() a range that contains real Ts\n    @SuppressWarnings(\"nullness\")\n    T[] castBuffer = (T[]) buffer;\n    Arrays.sort(castBuffer, 0, bufferSize, comparator);\n    if (bufferSize > k) {\n        Arrays.fill(buffer, k, buffer.length, null);\n        bufferSize = k;\n        threshold = buffer[k - 1];\n    }\n    // Up to bufferSize, all elements of buffer are real Ts (not null unless T includes null)\n    T[] topK = Arrays.copyOf(castBuffer, bufferSize);\n    // we have to support null elements, so no ImmutableList for us\n    return Collections.unmodifiableList(Arrays.asList(topK));\n}", "repo_id": "5", "comment": "/**\n * Returns the top {@code k} elements offered to this {@code TopKSelector}, or all elements if\n * fewer than {@code k} have been offered, in the order specified by the factory used to create\n * this {@code TopKSelector}.\n *\n * <p>The returned list is an unmodifiable copy and will not be affected by further changes to\n * this {@code TopKSelector}. This method returns in O(k log k) time.\n */\n", "repo_name": "guava-master/", "id": 6137, "method_signature": "List<T> topK()", "filename": "TopKSelector.topK.json"}
{"callee_method_names": ["Comparator<? super T>.compare"], "method_name": "TopKSelector.trim", "method_implementation": "{\n    int left = 0;\n    int right = 2 * k - 1;\n    int minThresholdPosition = 0;\n    // The leftmost position at which the greatest of the k lower elements\n    // -- the new value of threshold -- might be found.\n    int iterations = 0;\n    int maxIterations = IntMath.log2(right - left, RoundingMode.CEILING) * 3;\n    while (left < right) {\n        int pivotIndex = (left + right + 1) >>> 1;\n        int pivotNewIndex = partition(left, right, pivotIndex);\n        if (pivotNewIndex > k) {\n            right = pivotNewIndex - 1;\n        } else if (pivotNewIndex < k) {\n            left = Math.max(pivotNewIndex, left + 1);\n            minThresholdPosition = pivotNewIndex;\n        } else {\n            break;\n        }\n        iterations++;\n        if (iterations >= maxIterations) {\n            // safe because we pass sort() a range that contains real Ts\n            @SuppressWarnings(\"nullness\")\n            T[] castBuffer = (T[]) buffer;\n            // We've already taken O(k log k), let's make sure we don't take longer than O(k log k).\n            Arrays.sort(castBuffer, left, right + 1, comparator);\n            break;\n        }\n    }\n    bufferSize = k;\n    threshold = uncheckedCastNullableTToT(buffer[minThresholdPosition]);\n    for (int i = minThresholdPosition + 1; i < k; i++) {\n        if (comparator.compare(uncheckedCastNullableTToT(buffer[i]), uncheckedCastNullableTToT(threshold)) > 0) {\n            threshold = buffer[i];\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Quickselects the top k elements from the 2k elements in the buffer. O(k) expected time, O(k log\n * k) worst case.\n */\n", "repo_name": "guava-master/", "id": 6134, "method_signature": "void trim()", "filename": "TopKSelector.trim.json"}
{"callee_method_names": ["Map<K, V1>.get", "Map<K, V1>.containsKey", "EntryTransformer<? super K, ? super V1, V2>.transformEntry"], "method_name": "TransformedEntriesMap.get", "method_implementation": "{\n    V1 value = fromMap.get(key);\n    if (value != null || fromMap.containsKey(key)) {\n        // The cast is safe because of the containsKey check.\n        return transformer.transformEntry((K) key, uncheckedCastNullableTToT(value));\n    }\n    return null;\n}", "repo_id": "5", "comment": "// safe as long as the user followed the <b>Warning</b> in the javadoc\n", "repo_name": "guava-master/", "id": 6597, "method_signature": "V2 get(Object)", "filename": "TransformedEntriesMap.get.json"}
{"callee_method_names": ["Map<K, V1>.get", "Map<K, V1>.containsKey", "EntryTransformer<? super K, ? super V1, V2>.transformEntry"], "method_name": "TransformedEntriesMap.getOrDefault", "method_implementation": "{\n    V1 value = fromMap.get(key);\n    if (value != null || fromMap.containsKey(key)) {\n        // The cast is safe because of the containsKey check.\n        return transformer.transformEntry((K) key, uncheckedCastNullableTToT(value));\n    }\n    return defaultValue;\n}", "repo_id": "5", "comment": "// safe as long as the user followed the <b>Warning</b> in the javadoc\n", "repo_name": "guava-master/", "id": 3258, "method_signature": "V2 getOrDefault(Object, V2)", "filename": "TransformedEntriesMap.getOrDefault.json"}
{"callee_method_names": ["Map<K, V1>.containsKey", "EntryTransformer<? super K, ? super V1, V2>.transformEntry", "Map<K, V1>.remove"], "method_name": "TransformedEntriesMap.remove", "method_implementation": "{\n    return fromMap.containsKey(key) ? // The cast is safe because of the containsKey check.\n    transformer.transformEntry((K) key, uncheckedCastNullableTToT(fromMap.remove(key))) : null;\n}", "repo_id": "5", "comment": "// safe as long as the user followed the <b>Warning</b> in the javadoc\n", "repo_name": "guava-master/", "id": 6598, "method_signature": "V2 remove(Object)", "filename": "TransformedEntriesMap.remove.json"}
{"callee_method_names": ["Deque<Iterator<? extends N>>.add", "SuccessorsFunction<N>.successors", "Iterator<? extends N>.hasNext", "InsertionOrder.insertInto", "Deque<Iterator<? extends N>>.isEmpty"], "method_name": "Traversal.topDown", "method_implementation": "{\n    Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n    horizon.add(startNodes);\n    return new AbstractIterator<N>() {\n\n        @Override\n        @CheckForNull\n        protected N computeNext() {\n            do {\n                N next = visitNext(horizon);\n                if (next != null) {\n                    Iterator<? extends N> successors = successorFunction.successors(next).iterator();\n                    if (successors.hasNext()) {\n                        // BFS: horizon.addLast(successors)\n                        // Pre-order: horizon.addFirst(successors)\n                        order.insertInto(horizon, successors);\n                    }\n                    return next;\n                }\n            } while (!horizon.isEmpty());\n            return endOfData();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * In top-down traversal, an ancestor node is always traversed before any of its descendant\n * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are\n * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before\n * aunts for pre-order; while in BFS they are placed at the BACK after aunts.\n */\n", "repo_name": "guava-master/", "id": 6798, "method_signature": "Iterator<N> topDown(Iterator, InsertionOrder)", "filename": "Traversal.topDown.json"}
{"callee_method_names": ["ImmutableSet<N>.iterator"], "method_name": "Traverser.breadthFirst", "method_implementation": "{\n    ImmutableSet<N> validated = validate(startNodes);\n    return new Iterable<N>() {\n\n        @Override\n        public Iterator<N> iterator() {\n            return newTraversal().breadthFirst(validated.iterator());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n * startNodes}, in the order of a breadth-first traversal. This is equivalent to a breadth-first\n * traversal of a graph with an additional root node whose successors are the listed {@code\n * startNodes}.\n *\n * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n * @see #breadthFirst(Object)\n * @since 24.1\n */\n", "repo_name": "guava-master/", "id": 6794, "method_signature": "Iterable<N> breadthFirst(Iterable)", "filename": "Traverser.breadthFirst.json"}
{"callee_method_names": ["ImmutableSet<N>.iterator"], "method_name": "Traverser.depthFirstPostOrder", "method_implementation": "{\n    ImmutableSet<N> validated = validate(startNodes);\n    return new Iterable<N>() {\n\n        @Override\n        public Iterator<N> iterator() {\n            return newTraversal().postOrder(validated.iterator());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n * startNodes}, in the order of a depth-first post-order traversal. This is equivalent to a\n * depth-first post-order traversal of a graph with an additional root node whose successors are\n * the listed {@code startNodes}.\n *\n * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n * @see #depthFirstPostOrder(Object)\n * @since 24.1\n */\n", "repo_name": "guava-master/", "id": 6796, "method_signature": "Iterable<N> depthFirstPostOrder(Iterable)", "filename": "Traverser.depthFirstPostOrder.json"}
{"callee_method_names": ["ImmutableSet<N>.iterator"], "method_name": "Traverser.depthFirstPreOrder", "method_implementation": "{\n    ImmutableSet<N> validated = validate(startNodes);\n    return new Iterable<N>() {\n\n        @Override\n        public Iterator<N> iterator() {\n            return newTraversal().preOrder(validated.iterator());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n * startNodes}, in the order of a depth-first pre-order traversal. This is equivalent to a\n * depth-first pre-order traversal of a graph with an additional root node whose successors are\n * the listed {@code startNodes}.\n *\n * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n * @see #depthFirstPreOrder(Object)\n * @since 24.1\n */\n", "repo_name": "guava-master/", "id": 6795, "method_signature": "Iterable<N> depthFirstPreOrder(Iterable)", "filename": "Traverser.depthFirstPreOrder.json"}
{"callee_method_names": [], "method_name": "Traverser.forGraph", "method_implementation": "{\n    return new Traverser<N>(graph) {\n\n        @Override\n        Traversal<N> newTraversal() {\n            return Traversal.inGraph(graph);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Creates a new traverser for the given general {@code graph}.\n *\n * <p>Traversers created using this method are guaranteed to visit each node reachable from the\n * start node(s) at most once.\n *\n * <p>If you know that no node in {@code graph} is reachable by more than one path from the start\n * node(s), consider using {@link #forTree(SuccessorsFunction)} instead.\n *\n * <p><b>Performance notes</b>\n *\n * <ul>\n *   <li>Traversals require <i>O(n)</i> time (where <i>n</i> is the number of nodes reachable from\n *       the start node), assuming that the node objects have <i>O(1)</i> {@code equals()} and\n *       {@code hashCode()} implementations. (See the <a\n *       href=\"https://github.com/google/guava/wiki/GraphsExplained#elements-must-be-useable-as-map-keys\">\n *       notes on element objects</a> for more information.)\n *   <li>While traversing, the traverser will use <i>O(n)</i> space (where <i>n</i> is the number\n *       of nodes that have thus far been visited), plus <i>O(H)</i> space (where <i>H</i> is the\n *       number of nodes that have been seen but not yet visited, that is, the \"horizon\").\n * </ul>\n *\n * @param graph {@link SuccessorsFunction} representing a general graph that may have cycles.\n */\n", "repo_name": "guava-master/", "id": 6792, "method_signature": "Traverser<N> forGraph(SuccessorsFunction)", "filename": "Traverser.forGraph.json"}
{"callee_method_names": [], "method_name": "Traverser.forTree", "method_implementation": "{\n    if (tree instanceof BaseGraph) {\n        checkArgument(((BaseGraph<?>) tree).isDirected(), \"Undirected graphs can never be trees.\");\n    }\n    if (tree instanceof Network) {\n        checkArgument(((Network<?, ?>) tree).isDirected(), \"Undirected networks can never be trees.\");\n    }\n    return new Traverser<N>(tree) {\n\n        @Override\n        Traversal<N> newTraversal() {\n            return Traversal.inTree(tree);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Creates a new traverser for a directed acyclic graph that has at most one path from the start\n * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n * any other start node, such as a tree or forest.\n *\n * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n * structure being traversed is, in addition to being a tree/forest, also defined <a\n * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n * both time and space versus traversing the same graph using {@code forGraph()}.\n *\n * <p>Providing a graph to be traversed for which there is more than one path from the start\n * node(s) to any node may lead to:\n *\n * <ul>\n *   <li>Traversal not terminating (if the graph has cycles)\n *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n *       node reachable from any start node)\n * </ul>\n *\n * <p><b>Performance notes</b>\n *\n * <ul>\n *   <li>Traversals require <i>O(n)</i> time (where <i>n</i> is the number of nodes reachable from\n *       the start node).\n *   <li>While traversing, the traverser will use <i>O(H)</i> space (where <i>H</i> is the number\n *       of nodes that have been seen but not yet visited, that is, the \"horizon\").\n * </ul>\n *\n * <p><b>Examples</b> (all edges are directed facing downwards)\n *\n * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n * {@code h}.\n *\n * <pre>{@code\n *    a     b      c\n *   / \\   / \\     |\n *  /   \\ /   \\    |\n * d     e     f   g\n *       |\n *       |\n *       h\n * }</pre>\n *\n * <p>.\n *\n * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n * b} were a start node, there would be multiple paths to {@code f}.\n *\n * <pre>{@code\n *    a     b\n *   / \\   / \\\n *  /   \\ /   \\\n * c     d     e\n *        \\   /\n *         \\ /\n *          f\n * }</pre>\n *\n * <p><b>Note on binary trees</b>\n *\n * <p>This method can be used to traverse over a binary tree. Given methods {@code\n * leftChild(node)} and {@code rightChild(node)}, this method can be called as\n *\n * <pre>{@code\n * Traverser.forTree(node -> ImmutableList.of(leftChild(node), rightChild(node)));\n * }</pre>\n *\n * @param tree {@link SuccessorsFunction} representing a directed acyclic graph that has at most\n *     one path between any two nodes\n */\n", "repo_name": "guava-master/", "id": 6793, "method_signature": "Traverser<N> forTree(SuccessorsFunction)", "filename": "Traverser.forTree.json"}
{"callee_method_names": ["Deque<Iterator<? extends N>>.add", "SuccessorsFunction<N>.successors", "Iterator<? extends N>.hasNext", "InsertionOrder.insertInto", "Deque<Iterator<? extends N>>.isEmpty"], "method_name": "Traverser.topDown", "method_implementation": "{\n    Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n    horizon.add(startNodes);\n    return new AbstractIterator<N>() {\n\n        @Override\n        @CheckForNull\n        protected N computeNext() {\n            do {\n                N next = visitNext(horizon);\n                if (next != null) {\n                    Iterator<? extends N> successors = successorFunction.successors(next).iterator();\n                    if (successors.hasNext()) {\n                        // BFS: horizon.addLast(successors)\n                        // Pre-order: horizon.addFirst(successors)\n                        order.insertInto(horizon, successors);\n                    }\n                    return next;\n                }\n            } while (!horizon.isEmpty());\n            return endOfData();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * In top-down traversal, an ancestor node is always traversed before any of its descendant\n * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are\n * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before\n * aunts for pre-order; while in BFS they are placed at the BACK after aunts.\n */\n", "repo_name": "guava-master/", "id": 6797, "method_signature": "Iterator<N> topDown(Iterator, InsertionOrder)", "filename": "Traverser.topDown.json"}
{"callee_method_names": ["ImmutableMultimap.Builder<Character, Character>.put", "ImmutableMultimap.Builder<Character, Character>.put", "ImmutableMultimap.Builder<Character, Character>.build", "ImmutableMultimap<Character, Character>.containsKey", "ImmutableMultimap<Character, Character>.containsValue", "ImmutableMultimap<Character, Character>.get"], "method_name": "TraverserTest.createGraph", "method_implementation": "{\n    ImmutableMultimap.Builder<Character, Character> graphMapBuilder = ImmutableMultimap.builder();\n    for (String edge : edges) {\n        checkArgument(edge.length() == 2, \"Expecting each edge to consist of 2 characters but got %s\", edge);\n        char node1 = edge.charAt(0);\n        char node2 = edge.charAt(1);\n        graphMapBuilder.put(node1, node2);\n        if (!directed) {\n            graphMapBuilder.put(node2, node1);\n        }\n    }\n    final ImmutableMultimap<Character, Character> graphMap = graphMapBuilder.build();\n    return new SuccessorsFunction<Character>() {\n\n        @Override\n        public Iterable<? extends Character> successors(Character node) {\n            checkArgument(graphMap.containsKey(node) || graphMap.containsValue(node), \"Node %s is not an element of this graph\", node);\n            return Ordering.natural().immutableSortedCopy(graphMap.get(node));\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Creates a graph from a list of node pairs (encoded as strings, e.g. \"ab\" means that this graph\n * has an edge between 'a' and 'b').\n *\n * <p>The {@code successors} are always returned in alphabetical order.\n */\n", "repo_name": "guava-master/", "id": 4069, "method_signature": "SuccessorsFunction<Character> createGraph(boolean, String[])", "filename": "TraverserTest.createGraph.json"}
{"callee_method_names": [], "method_name": "TraverserTest.forGraph_breadthFirstIterable_emptyGraph", "method_implementation": "{\n    assertEqualCharNodes(Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"\")), \"\");\n    assertThrows(IllegalArgumentException.class, () -> Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"a\")));\n}", "repo_id": "5", "comment": "/**\n * Checks that the elements of the iterable are calculated on the fly. Concretely, that means that\n * {@link SuccessorsFunction#successors(Object)} can only be called for a subset of all nodes.\n */\n", "repo_name": "guava-master/", "id": 4067, "method_signature": "void forGraph_breadthFirstIterable_emptyGraph()", "filename": "TraverserTest.forGraph_breadthFirstIterable_emptyGraph.json"}
{"callee_method_names": [], "method_name": "TraverserTest.forGraph_breadthFirst_iterableIsLazy", "method_implementation": "{\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('a');\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b');\n    // Iterate again to see if calculation is done again\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');\n}", "repo_id": "5", "comment": "/**\n * Checks that the elements of the iterable are calculated on the fly. Concretely, that means that\n * {@link SuccessorsFunction#successors(Object)} can only be called for a subset of all nodes.\n */\n", "repo_name": "guava-master/", "id": 4068, "method_signature": "void forGraph_breadthFirst_iterableIsLazy()", "filename": "TraverserTest.forGraph_breadthFirst_iterableIsLazy.json"}
{"callee_method_names": ["TreeBasedTable<R,C,? extends V>.rowComparator", "TreeBasedTable<R,C,? extends V>.columnComparator", "TreeBasedTable<R, C, V>.putAll"], "method_name": "TreeBasedTable.create", "method_implementation": "{\n    TreeBasedTable<R, C, V> result = new TreeBasedTable<>(table.rowComparator(), table.columnComparator());\n    result.putAll(table);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Creates a {@code TreeBasedTable} with the same mappings and sort order as the specified {@code\n * TreeBasedTable}.\n */\n", "repo_name": "guava-master/", "id": 5914, "method_signature": "TreeBasedTable<R,C,V> create(TreeBasedTable)", "filename": "TreeBasedTable.create.json"}
{"callee_method_names": ["Map<R,Map<C,V>>.values", "Future<I>.keySet", "Iterator<C>.hasNext", "Iterator<C>.next", "Comparator<? super C>.compare"], "method_name": "TreeBasedTable.createColumnKeyIterator", "method_implementation": "{\n    Comparator<? super C> comparator = columnComparator();\n    Iterator<C> merged = Iterators.mergeSorted(Iterables.transform(backingMap.values(), (Map<C, V> input) -> input.keySet().iterator()), comparator);\n    return new AbstractIterator<C>() {\n\n        @CheckForNull\n        C lastValue;\n\n        @Override\n        @CheckForNull\n        protected C computeNext() {\n            while (merged.hasNext()) {\n                C next = merged.next();\n                boolean duplicate = lastValue != null && comparator.compare(next, lastValue) == 0;\n                // Keep looping till we find a non-duplicate value.\n                if (!duplicate) {\n                    lastValue = next;\n                    return lastValue;\n                }\n            }\n            // clear reference to unused data\n            lastValue = null;\n            return endOfData();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Overridden column iterator to return columns values in globally sorted order.\n */\n", "repo_name": "guava-master/", "id": 5917, "method_signature": "Iterator<C> createColumnKeyIterator()", "filename": "TreeBasedTable.createColumnKeyIterator.json"}
{"callee_method_names": [], "method_name": "TreeBasedTable.rowComparator", "method_implementation": "{\n    /*\n     * requireNonNull is safe because the factories require non-null Comparators, which they pass on\n     * to the backing collections.\n     */\n    return requireNonNull(rowKeySet().comparator());\n}", "repo_id": "5", "comment": "/**\n * Returns the comparator that orders the rows. With natural ordering, {@link Ordering#natural()}\n * is returned.\n *\n * @deprecated Use {@code table.rowKeySet().comparator()} instead.\n */\n", "repo_name": "guava-master/", "id": 5915, "method_signature": "Comparator<? super R> rowComparator()", "filename": "TreeBasedTable.rowComparator.json"}
{"callee_method_names": ["SortedMap<C, V>.isEmpty", "Map<R,Map<C,V>>.containsKey", "Map<R,Map<C,V>>.get"], "method_name": "TreeBasedTable.updateWholeRowField", "method_implementation": "{\n    if (wholeRow == null || (wholeRow.isEmpty() && backingMap.containsKey(rowKey))) {\n        wholeRow = (SortedMap<C, V>) backingMap.get(rowKey);\n    }\n}", "repo_id": "5", "comment": "// If the row was previously empty, we check if there's a new row here every time we're queried.\n", "repo_name": "guava-master/", "id": 5916, "method_signature": "void updateWholeRowField()", "filename": "TreeBasedTable.updateWholeRowField.json"}
{"callee_method_names": [], "method_name": "TreeMultimap.get", "method_implementation": "{\n    return (NavigableSet<V>) super.get(key);\n}", "repo_id": "5", "comment": "/**\n * @since 14.0 (present with return type {@code SortedSet} since 2.0)\n */\n", "repo_name": "guava-master/", "id": 6310, "method_signature": "NavigableSet<V> get(K)", "filename": "TreeMultimap.get.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject", "ObjectOutputStream.writeObject"], "method_name": "TreeMultimap.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(keyComparator());\n    stream.writeObject(valueComparator());\n    Serialization.writeMultimap(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData key comparator, value comparator, number of distinct keys, and then for each\n *     distinct key: the key, number of values for that key, and key values\n */\n", "repo_name": "guava-master/", "id": 6311, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "TreeMultimap.writeObject.json"}
{"callee_method_names": ["TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put"], "method_name": "TreeMultimapExplicitTest.createPopulate", "method_implementation": "{\n    TreeMultimap<String, Integer> multimap = TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n    multimap.put(\"google\", 2);\n    multimap.put(\"google\", 6);\n    multimap.put(null, 3);\n    multimap.put(null, 1);\n    multimap.put(null, 7);\n    multimap.put(\"tree\", 0);\n    multimap.put(\"tree\", null);\n    return multimap;\n}", "repo_id": "5", "comment": "/**\n * Create and populate a {@code TreeMultimap} with explicit comparators.\n */\n", "repo_name": "guava-master/", "id": 3964, "method_signature": "TreeMultimap<String,Integer> createPopulate()", "filename": "TreeMultimapExplicitTest.createPopulate.json"}
{"callee_method_names": ["TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.keySet", "TreeMultimap<String, Integer>.get", "TreeMultimap<String, Integer>.keySet", "TreeMultimap<String, Integer>.get", "TreeMultimap<String, Integer>.keyComparator", "TreeMultimap<String, Integer>.valueComparator", "TreeMultimap<String, Integer>.get"], "method_name": "TreeMultimapExplicitTest.testMultimapCreateFromTreeMultimap", "method_implementation": "{\n    TreeMultimap<String, Integer> tree = TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n    tree.put(\"google\", 2);\n    tree.put(\"google\", 6);\n    tree.put(\"tree\", 0);\n    tree.put(\"tree\", 3);\n    assertThat(tree.keySet()).containsExactly(\"tree\", \"google\").inOrder();\n    assertThat(tree.get(\"google\")).containsExactly(6, 2).inOrder();\n    TreeMultimap<String, Integer> copy = TreeMultimap.create(tree);\n    assertEquals(tree, copy);\n    assertThat(copy.keySet()).containsExactly(\"google\", \"tree\").inOrder();\n    assertThat(copy.get(\"google\")).containsExactly(2, 6).inOrder();\n    assertEquals(Ordering.natural(), copy.keyComparator());\n    assertEquals(Ordering.natural(), copy.valueComparator());\n    assertEquals(Ordering.natural(), copy.get(\"google\").comparator());\n}", "repo_id": "5", "comment": "/**\n * Test that a TreeMultimap created from another uses the natural ordering.\n */\n", "repo_name": "guava-master/", "id": 3965, "method_signature": "void testMultimapCreateFromTreeMultimap()", "filename": "TreeMultimapExplicitTest.testMultimapCreateFromTreeMultimap.json"}
{"callee_method_names": ["TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put", "TreeMultimap<String, Integer>.put"], "method_name": "TreeMultimapNaturalTest.createPopulate", "method_implementation": "{\n    TreeMultimap<String, Integer> multimap = TreeMultimap.create();\n    multimap.put(\"google\", 2);\n    multimap.put(\"google\", 6);\n    multimap.put(\"foo\", 3);\n    multimap.put(\"foo\", 1);\n    multimap.put(\"foo\", 7);\n    multimap.put(\"tree\", 4);\n    multimap.put(\"tree\", 0);\n    return multimap;\n}", "repo_id": "5", "comment": "/**\n * Create and populate a {@code TreeMultimap} with the natural ordering of keys and values.\n */\n", "repo_name": "guava-master/", "id": 3945, "method_signature": "TreeMultimap<String,Integer> createPopulate()", "filename": "TreeMultimapNaturalTest.createPopulate.json"}
{"callee_method_names": ["Multimap<Double, Double>.put", "Multimap<Double, Double>.put", "Multimap<Double, Double>.put", "Multimap<Double, Double>.put", "TreeMultimap<Double, Double>.keyComparator", "TreeMultimap<Double, Double>.valueComparator"], "method_name": "TreeMultimapNaturalTest.testCreateFromHashMultimap", "method_implementation": "{\n    Multimap<Double, Double> hash = HashMultimap.create();\n    hash.put(1.0, 2.0);\n    hash.put(2.0, 3.0);\n    hash.put(3.0, 4.0);\n    hash.put(4.0, 5.0);\n    TreeMultimap<Double, Double> copyFromHash = TreeMultimap.create(hash);\n    assertEquals(hash, copyFromHash);\n    assertEquals(Ordering.natural(), copyFromHash.keyComparator());\n    assertEquals(Ordering.natural(), copyFromHash.valueComparator());\n}", "repo_id": "5", "comment": "/**\n * Test that creating one TreeMultimap from a non-TreeMultimap results in natural ordering.\n */\n", "repo_name": "guava-master/", "id": 3947, "method_signature": "void testCreateFromHashMultimap()", "filename": "TreeMultimapNaturalTest.testCreateFromHashMultimap.json"}
{"callee_method_names": ["SortedSetMultimap<Double, Double>.put", "SortedSetMultimap<Double, Double>.put", "SortedSetMultimap<Double, Double>.put", "SortedSetMultimap<Double, Double>.put", "TreeMultimap<Double, Double>.keyComparator", "TreeMultimap<Double, Double>.valueComparator", "TreeMultimap<Double, Double>.get"], "method_name": "TreeMultimapNaturalTest.testCreateFromSortedSetMultimap", "method_implementation": "{\n    SortedSetMultimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\n    tree.put(1.0, 2.0);\n    tree.put(2.0, 3.0);\n    tree.put(3.0, 4.0);\n    tree.put(4.0, 5.0);\n    SortedSetMultimap<Double, Double> sorted = Multimaps.unmodifiableSortedSetMultimap(tree);\n    TreeMultimap<Double, Double> copyFromSorted = TreeMultimap.create(sorted);\n    assertEquals(tree, copyFromSorted);\n    assertSame(Ordering.natural(), copyFromSorted.keyComparator());\n    assertSame(Ordering.natural(), copyFromSorted.valueComparator());\n    assertSame(Ordering.natural(), copyFromSorted.get(1.0).comparator());\n}", "repo_id": "5", "comment": "/**\n * Test that creating one TreeMultimap from a SortedSetMultimap uses natural ordering.\n */\n", "repo_name": "guava-master/", "id": 3948, "method_signature": "void testCreateFromSortedSetMultimap()", "filename": "TreeMultimapNaturalTest.testCreateFromSortedSetMultimap.json"}
{"callee_method_names": ["Multimap<Double, Double>.put", "Multimap<Double, Double>.put", "Multimap<Double, Double>.put", "Multimap<Double, Double>.put", "TreeMultimap<Double, Double>.keyComparator", "TreeMultimap<Double, Double>.valueComparator", "TreeMultimap<Double, Double>.get"], "method_name": "TreeMultimapNaturalTest.testCreateFromTreeMultimap", "method_implementation": "{\n    Multimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\n    tree.put(1.0, 2.0);\n    tree.put(2.0, 3.0);\n    tree.put(3.0, 4.0);\n    tree.put(4.0, 5.0);\n    TreeMultimap<Double, Double> copyFromTree = TreeMultimap.create(tree);\n    assertEquals(tree, copyFromTree);\n    assertSame(Ordering.natural(), copyFromTree.keyComparator());\n    assertSame(Ordering.natural(), copyFromTree.valueComparator());\n    assertSame(Ordering.natural(), copyFromTree.get(1.0).comparator());\n}", "repo_id": "5", "comment": "/**\n * Test that creating one TreeMultimap from another does not copy the comparators from the source\n * TreeMultimap.\n */\n", "repo_name": "guava-master/", "id": 3946, "method_signature": "void testCreateFromTreeMultimap()", "filename": "TreeMultimapNaturalTest.testCreateFromTreeMultimap.json"}
{"callee_method_names": [], "method_name": "TreeMultiset.create", "method_implementation": "{\n    TreeMultiset<E> multiset = create();\n    Iterables.addAll(multiset, elements);\n    return multiset;\n}", "repo_id": "5", "comment": "/**\n * Creates an empty multiset containing the given initial elements, sorted according to the\n * elements' natural order.\n *\n * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.\n *\n * <p>The type specification is {@code <E extends Comparable>}, instead of the more specific\n * {@code <E extends Comparable<? super E>>}, to support classes defined without generics.\n */\n", "repo_name": "guava-master/", "id": 6239, "method_signature": "TreeMultiset<E> create(Iterable)", "filename": "TreeMultiset.create.json"}
{"callee_method_names": ["Reference<AvlNode<E>>.get", "GeneralRange<E>.hasLowerBound", "GeneralRange<E>.getLowerEndpoint", "AvlNode<E>.ceiling", "GeneralRange<E>.getLowerBoundType", "AvlNode<E>.getElement", "AvlNode<E>.succ", "AvlNode<E>.succ", "GeneralRange<E>.contains", "AvlNode<E>.getElement"], "method_name": "TreeMultiset.firstNode", "method_implementation": "{\n    AvlNode<E> root = rootReference.get();\n    if (root == null) {\n        return null;\n    }\n    AvlNode<E> node;\n    if (range.hasLowerBound()) {\n        // The cast is safe because of the hasLowerBound check.\n        E endpoint = uncheckedCastNullableTToT(range.getLowerEndpoint());\n        node = root.ceiling(comparator(), endpoint);\n        if (node == null) {\n            return null;\n        }\n        if (range.getLowerBoundType() == BoundType.OPEN && comparator().compare(endpoint, node.getElement()) == 0) {\n            node = node.succ();\n        }\n    } else {\n        node = header.succ();\n    }\n    return (node == header || !range.contains(node.getElement())) ? null : node;\n}", "repo_id": "5", "comment": "/**\n * Returns the first node in the tree that is in range.\n */\n", "repo_name": "guava-master/", "id": 6240, "method_signature": "AvlNode<E> firstNode()", "filename": "TreeMultiset.firstNode.json"}
{"callee_method_names": ["AvlNode<E>.removeMax"], "method_name": "TreeMultiset.removeMax", "method_implementation": "{\n    if (right == null) {\n        return left;\n    } else {\n        right = right.removeMax(node);\n        distinctElements--;\n        totalCount -= node.elemCount;\n        return rebalance();\n    }\n}", "repo_id": "5", "comment": "// Removes the maximum node from this subtree to be reused elsewhere\n", "repo_name": "guava-master/", "id": 6242, "method_signature": "AvlNode<E> removeMax(AvlNode)", "filename": "TreeMultiset.removeMax.json"}
{"callee_method_names": ["AvlNode<E>.removeMin"], "method_name": "TreeMultiset.removeMin", "method_implementation": "{\n    if (left == null) {\n        return right;\n    } else {\n        left = left.removeMin(node);\n        distinctElements--;\n        totalCount -= node.elemCount;\n        return rebalance();\n    }\n}", "repo_id": "5", "comment": "// Removes the minimum node from this subtree to be reused elsewhere\n", "repo_name": "guava-master/", "id": 6241, "method_signature": "AvlNode<E> removeMin(AvlNode)", "filename": "TreeMultiset.removeMin.json"}
{"callee_method_names": ["ObjectOutputStream.defaultWriteObject", "ObjectOutputStream.writeObject"], "method_name": "TreeMultiset.writeObject", "method_implementation": "{\n    stream.defaultWriteObject();\n    stream.writeObject(elementSet().comparator());\n    Serialization.writeMultiset(this, stream);\n}", "repo_id": "5", "comment": "/**\n * @serialData the comparator, the number of distinct elements, the first element, its count, the\n *     second element, its count, and so on\n */\n", "repo_name": "guava-master/", "id": 6243, "method_signature": "void writeObject(ObjectOutputStream)", "filename": "TreeMultiset.writeObject.json"}
{"callee_method_names": ["TreeMultiset<String>.add", "TreeMultiset<String>.add", "TreeMultiset<String>.add", "TreeMultiset<String>.add", "TreeMultiset<String>.add", "TreeMultiset<String>.count", "TreeMultiset<String>.count", "Multiset<String>.add", "Multiset<String>.add", "TreeMultiset<String>.elementSet", "SortedSet<String>.first", "SortedSet<String>.last", "SortedSet<String>.comparator"], "method_name": "TreeMultisetTest.testDegenerateComparator", "method_implementation": "{\n    TreeMultiset<String> ms = TreeMultiset.create(DEGENERATE_COMPARATOR);\n    ms.add(\"foo\");\n    ms.add(\"a\");\n    ms.add(\"bar\");\n    ms.add(\"b\");\n    ms.add(\"c\");\n    assertEquals(2, ms.count(\"bar\"));\n    assertEquals(3, ms.count(\"b\"));\n    Multiset<String> ms2 = TreeMultiset.create(DEGENERATE_COMPARATOR);\n    ms2.add(\"cat\", 2);\n    ms2.add(\"x\", 3);\n    assertEquals(ms, ms2);\n    assertEquals(ms2, ms);\n    SortedSet<String> elementSet = ms.elementSet();\n    assertEquals(\"a\", elementSet.first());\n    assertEquals(\"foo\", elementSet.last());\n    assertEquals(DEGENERATE_COMPARATOR, elementSet.comparator());\n}", "repo_id": "5", "comment": "/**\n * Test a TreeMultiset with a comparator that can return 0 when comparing unequal values.\n */\n", "repo_name": "guava-master/", "id": 3966, "method_signature": "void testDegenerateComparator()", "filename": "TreeMultisetTest.testDegenerateComparator.json"}
{"callee_method_names": ["Entry<Cut<K>,RangeMapEntry<K,V>>.getValue", "Entry<Cut<K>,RangeMapEntry<K,V>>.getValue", "Range<K>.span", "Entry<Cut<K>,RangeMapEntry<K,V>>.getValue"], "method_name": "TreeRangeMap.coalesce", "method_implementation": "{\n    if (entry != null && entry.getValue().getKey().isConnected(range) && entry.getValue().getValue().equals(value)) {\n        return range.span(entry.getValue().getKey());\n    }\n    return range;\n}", "repo_id": "5", "comment": "/**\n * Returns the range that spans the given range and entry, if the entry can be coalesced.\n */\n", "repo_name": "guava-master/", "id": 6049, "method_signature": "Range<K> coalesce(Range, V, Entry)", "filename": "TreeRangeMap.coalesce.json"}
{"callee_method_names": ["NavigableMap<Cut<K>, RangeMapEntry<K, V>>.lowerEntry", "NavigableMap<Cut<K>, RangeMapEntry<K, V>>.floorEntry"], "method_name": "TreeRangeMap.coalescedRange", "method_implementation": "{\n    Range<K> coalescedRange = range;\n    Entry<Cut<K>, RangeMapEntry<K, V>> lowerEntry = entriesByLowerBound.lowerEntry(range.lowerBound);\n    coalescedRange = coalesce(coalescedRange, value, lowerEntry);\n    Entry<Cut<K>, RangeMapEntry<K, V>> higherEntry = entriesByLowerBound.floorEntry(range.upperBound);\n    coalescedRange = coalesce(coalescedRange, value, higherEntry);\n    return coalescedRange;\n}", "repo_id": "5", "comment": "/**\n * Computes the coalesced range for the given range+value - does not mutate the map.\n */\n", "repo_name": "guava-master/", "id": 6048, "method_signature": "Range<K> coalescedRange(Range, V)", "filename": "TreeRangeMap.coalescedRange.json"}
{"callee_method_names": ["RangeMap<Integer, Integer>.putCoalescing", "RangeMap<Integer, Integer>.putCoalescing", "RangeMap<Integer, Integer>.remove"], "method_name": "TreeRangeMapTest.testPutCoalescingTwoAndRemove", "method_implementation": "{\n    for (Range<Integer> rangeToPut1 : RANGES) {\n        for (Range<Integer> rangeToPut2 : RANGES) {\n            for (Range<Integer> rangeToRemove : RANGES) {\n                Map<Integer, Integer> model = Maps.newHashMap();\n                putModel(model, rangeToPut1, 1);\n                putModel(model, rangeToPut2, 2);\n                removeModel(model, rangeToRemove);\n                RangeMap<Integer, Integer> test = TreeRangeMap.create();\n                test.putCoalescing(rangeToPut1, 1);\n                test.putCoalescing(rangeToPut2, 2);\n                test.remove(rangeToRemove);\n                verify(model, test);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "// verifies that putCoalescing() doesn't cause any mappings to change relative to put()\n", "repo_name": "guava-master/", "id": 4024, "method_signature": "void testPutCoalescingTwoAndRemove()", "filename": "TreeRangeMapTest.testPutCoalescingTwoAndRemove.json"}
{"callee_method_names": ["TreeRangeSet<C>.addAll"], "method_name": "TreeRangeSet.create", "method_implementation": "{\n    TreeRangeSet<C> result = create();\n    result.addAll(ranges);\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code TreeRangeSet} representing the union of the specified ranges.\n *\n * <p>This is the smallest {@code RangeSet} which encloses each of the specified ranges. An\n * element will be contained in this {@code RangeSet} if and only if it is contained in at least\n * one {@code Range} in {@code ranges}.\n *\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 6077, "method_signature": "TreeRangeSet<C> create(Iterable)", "filename": "TreeRangeSet.create.json"}
{"callee_method_names": ["SortedMap<C, V>.isEmpty", "Map<R,Map<C,V>>.containsKey", "Map<R,Map<C,V>>.get"], "method_name": "TreeRow.updateWholeRowField", "method_implementation": "{\n    if (wholeRow == null || (wholeRow.isEmpty() && backingMap.containsKey(rowKey))) {\n        wholeRow = (SortedMap<C, V>) backingMap.get(rowKey);\n    }\n}", "repo_id": "5", "comment": "// If the row was previously empty, we check if there's a new row here every time we're queried.\n", "repo_name": "guava-master/", "id": 5918, "method_signature": "void updateWholeRowField()", "filename": "TreeRow.updateWholeRowField.json"}
{"callee_method_names": [], "method_name": "TreeTraverser.breadthFirstTraversal", "method_implementation": "{\n    checkNotNull(root);\n    return new FluentIterable<T>() {\n\n        @Override\n        public UnmodifiableIterator<T> iterator() {\n            return new BreadthFirstIterator(root);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable iterable over the nodes in a tree structure, using breadth-first\n * traversal. That is, all the nodes of depth 0 are returned, then depth 1, then 2, and so on.\n *\n * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n * is in progress or when the iterators generated by {@link #children} are advanced.\n *\n * @deprecated Use {@link com.google.common.graph.Traverser#breadthFirst} instead, which has the\n *     same behavior.\n */\n", "repo_name": "guava-master/", "id": 5545, "method_signature": "FluentIterable<T> breadthFirstTraversal(T)", "filename": "TreeTraverser.breadthFirstTraversal.json"}
{"callee_method_names": [], "method_name": "TreeTraverser.postOrderTraversal", "method_implementation": "{\n    checkNotNull(root);\n    return new FluentIterable<T>() {\n\n        @Override\n        public UnmodifiableIterator<T> iterator() {\n            return postOrderIterator(root);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable iterable over the nodes in a tree structure, using post-order\n * traversal. That is, each node's subtrees are traversed before the node itself is returned.\n *\n * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n * is in progress or when the iterators generated by {@link #children} are advanced.\n *\n * @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPostOrder} instead, which\n *     has the same behavior.\n */\n", "repo_name": "guava-master/", "id": 5544, "method_signature": "FluentIterable<T> postOrderTraversal(T)", "filename": "TreeTraverser.postOrderTraversal.json"}
{"callee_method_names": [], "method_name": "TreeTraverser.preOrderTraversal", "method_implementation": "{\n    checkNotNull(root);\n    return new FluentIterable<T>() {\n\n        @Override\n        public UnmodifiableIterator<T> iterator() {\n            return preOrderIterator(root);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order traversal.\n * That is, each node's subtrees are traversed after the node itself is returned.\n *\n * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n * is in progress or when the iterators generated by {@link #children} are advanced.\n *\n * @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPreOrder} instead, which has\n *     the same behavior.\n */\n", "repo_name": "guava-master/", "id": 5543, "method_signature": "FluentIterable<T> preOrderTraversal(T)", "filename": "TreeTraverser.preOrderTraversal.json"}
{"callee_method_names": ["Function<T,? extends Iterable<T>>.apply"], "method_name": "TreeTraverser.using", "method_implementation": "{\n    checkNotNull(nodeToChildrenFunction);\n    return new TreeTraverser<T>() {\n\n        @Override\n        public Iterable<T> children(T root) {\n            return nodeToChildrenFunction.apply(root);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns a tree traverser that uses the given function to navigate from a node to its children.\n * This is useful if the function instance already exists, or so that you can supply a lambda\n * expressions. If those circumstances don't apply, you probably don't need to use this; subclass\n * {@code TreeTraverser} and implement its {@link #children} method directly.\n *\n * @since 20.0\n * @deprecated Use {@link com.google.common.graph.Traverser#forTree} instead. If you are using a\n *     lambda, these methods have exactly the same signature.\n */\n", "repo_name": "guava-master/", "id": 5542, "method_signature": "TreeTraverser<T> using(Function)", "filename": "TreeTraverser.using.json"}
{"callee_method_ids": [4980], "callee_method_names": ["CharSequence.length", "CharSequence.charAt", "Deque<CharSequence>.push", "CharSequence.subSequence", "Joiner.join", "String.length", "ImmutableMap.Builder<String,PublicSuffixType>.put", "CharSequence.charAt", "CharSequence.charAt", "Deque<CharSequence>.pop"], "method_name": "TrieParser.doParseTrieToBuilder", "method_implementation": "{\n    int encodedLen = encoded.length();\n    int idx = start;\n    char c = '\\0';\n    // Read all the characters for this node.\n    for (; idx < encodedLen; idx++) {\n        c = encoded.charAt(idx);\n        if (c == '&' || c == '?' || c == '!' || c == ':' || c == ',') {\n            break;\n        }\n    }\n    stack.push(reverse(encoded.subSequence(start, idx)));\n    if (c == '!' || c == '?' || c == ':' || c == ',') {\n        // '!' represents an interior node that represents a REGISTRY entry in the map.\n        // '?' represents a leaf node, which represents a REGISTRY entry in map.\n        // ':' represents an interior node that represents a private entry in the map\n        // ',' represents a leaf node, which represents a private entry in the map.\n        String domain = DIRECT_JOINER.join(stack);\n        if (domain.length() > 0) {\n            builder.put(domain, PublicSuffixType.fromCode(c));\n        }\n    }\n    idx++;\n    if (c != '?' && c != ',') {\n        while (idx < encodedLen) {\n            // Read all the children\n            idx += doParseTrieToBuilder(stack, encoded, idx, builder);\n            if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {\n                // An extra '?' or ',' after a child node indicates the end of all children of this node.\n                idx++;\n                break;\n            }\n        }\n    }\n    stack.pop();\n    return idx - start;\n}", "repo_id": "5", "comment": "/**\n * Parses a trie node and returns the number of characters consumed.\n *\n * @param stack The prefixes that precede the characters represented by this node. Each entry of\n *     the stack is in reverse order.\n * @param encoded The serialized trie.\n * @param start An index in the encoded serialized trie to begin reading characters from.\n * @param builder A map builder to which all entries will be added.\n * @return The number of characters consumed from {@code encoded}.\n */\n", "repo_name": "guava-master/", "id": 4257, "method_signature": "int doParseTrieToBuilder(Deque, CharSequence, int, ImmutableMap.Builder)", "filename": "TrieParser.doParseTrieToBuilder.json"}
{"callee_method_names": ["Action.act", "Action.act"], "method_name": "TwoArg.reactToNullParameters", "method_implementation": "{\n    if (first == null) {\n        actionWhenFirstParamIsNull.act();\n    }\n    if (second == null) {\n        actionWhenSecondParamIsNull.act();\n    }\n}", "repo_id": "5", "comment": "/**\n * Method that decides how to react to parameters.\n */\n", "repo_name": "guava-master/", "id": 788, "method_signature": "void reactToNullParameters(Object, Object)", "filename": "TwoArg.reactToNullParameters.json"}
{"callee_method_names": [], "method_name": "TwoArg.toString", "method_implementation": "{\n    return rootLocaleFormat(\"Bar(%s, %s)\", actionWhenFirstParamIsNull, actionWhenSecondParamIsNull);\n}", "repo_id": "5", "comment": "/**\n * To provide sanity during debugging.\n */\n", "repo_name": "guava-master/", "id": 789, "method_signature": "String toString()", "filename": "TwoArg.toString.json"}
{"callee_method_names": [], "method_name": "TypeCapture.capture", "method_implementation": "{\n    Type superclass = getClass().getGenericSuperclass();\n    checkArgument(superclass instanceof ParameterizedType, \"%s isn't parameterized\", superclass);\n    return ((ParameterizedType) superclass).getActualTypeArguments()[0];\n}", "repo_id": "5", "comment": "/**\n * Returns the captured type.\n */\n", "repo_name": "guava-master/", "id": 4736, "method_signature": "Type capture()", "filename": "TypeCapture.capture.json"}
{"callee_method_names": ["ImmutableList.Builder<K>.add", "ImmutableList.Builder<K>.build"], "method_name": "TypeCollector.classesOnly", "method_implementation": "{\n    return new ForwardingTypeCollector<K>(this) {\n\n        @Override\n        Iterable<? extends K> getInterfaces(K type) {\n            return ImmutableSet.of();\n        }\n\n        @Override\n        ImmutableList<K> collectTypes(Iterable<? extends K> types) {\n            ImmutableList.Builder<K> builder = ImmutableList.builder();\n            for (K type : types) {\n                if (!getRawType(type).isInterface()) {\n                    builder.add(type);\n                }\n            }\n            return super.collectTypes(builder.build());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * For just classes, we don't have to traverse interfaces.\n */\n", "repo_name": "guava-master/", "id": 4693, "method_signature": "TypeCollector<K> classesOnly()", "filename": "TypeCollector.classesOnly.json"}
{"callee_method_names": ["Map<? super K,Integer>.get", "Map<? super K,Integer>.put"], "method_name": "TypeCollector.collectTypes", "method_implementation": "{\n    Integer existing = map.get(type);\n    if (existing != null) {\n        // short circuit: if set contains type it already contains its supertypes\n        return existing;\n    }\n    // Interfaces should be listed before Object.\n    int aboveMe = getRawType(type).isInterface() ? 1 : 0;\n    for (K interfaceType : getInterfaces(type)) {\n        aboveMe = Math.max(aboveMe, collectTypes(interfaceType, map));\n    }\n    K superclass = getSuperclass(type);\n    if (superclass != null) {\n        aboveMe = Math.max(aboveMe, collectTypes(superclass, map));\n    }\n    /*\n       * TODO(benyu): should we include Object for interface? Also, CharSequence[] and Object[] for\n       * String[]?\n       *\n       */\n    map.put(type, aboveMe + 1);\n    return aboveMe + 1;\n}", "repo_id": "5", "comment": "/**\n * Collects all types to map, and returns the total depth from T up to Object.\n */\n", "repo_name": "guava-master/", "id": 4694, "method_signature": "int collectTypes(K, Map)", "filename": "TypeCollector.collectTypes.json"}
{"callee_method_names": ["TypeMappingIntrospector.visit"], "method_name": "TypeMappingIntrospector.getTypeMappings", "method_implementation": "{\n    checkNotNull(contextType);\n    TypeMappingIntrospector introspector = new TypeMappingIntrospector();\n    introspector.visit(contextType);\n    return ImmutableMap.copyOf(introspector.mappings);\n}", "repo_id": "5", "comment": "/**\n * Returns type mappings using type parameters and type arguments found in the generic\n * superclass and the super interfaces of {@code contextClass}.\n */\n", "repo_name": "guava-master/", "id": 4663, "method_signature": "ImmutableMap<TypeVariableKey,Type> getTypeMappings(Type)", "filename": "TypeMappingIntrospector.getTypeMappings.json"}
{"callee_method_names": [], "method_name": "TypeResolver.equalsType", "method_implementation": "{\n    if (type instanceof TypeVariable) {\n        return equalsTypeVariable((TypeVariable<?>) type);\n    } else {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by the\n * same {@code GenericDeclaration}.\n */\n", "repo_name": "guava-master/", "id": 4660, "method_signature": "boolean equalsType(Type)", "filename": "TypeResolver.equalsType.json"}
{"callee_method_names": [], "method_name": "TypeResolver.forLookup", "method_implementation": "{\n    if (t instanceof TypeVariable) {\n        return new TypeVariableKey((TypeVariable<?>) t);\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Wraps {@code t} in a {@code TypeVariableKey} if it's a type variable.\n */\n", "repo_name": "guava-master/", "id": 4659, "method_signature": "TypeVariableKey forLookup(Type)", "filename": "TypeResolver.forLookup.json"}
{"callee_method_names": ["TypeMappingIntrospector.visit"], "method_name": "TypeResolver.getTypeMappings", "method_implementation": "{\n    checkNotNull(contextType);\n    TypeMappingIntrospector introspector = new TypeMappingIntrospector();\n    introspector.visit(contextType);\n    return ImmutableMap.copyOf(introspector.mappings);\n}", "repo_id": "5", "comment": "/**\n * Returns type mappings using type parameters and type arguments found in the generic\n * superclass and the super interfaces of {@code contextClass}.\n */\n", "repo_name": "guava-master/", "id": 4658, "method_signature": "ImmutableMap<TypeVariableKey,Type> getTypeMappings(Type)", "filename": "TypeResolver.getTypeMappings.json"}
{"callee_method_names": ["ImmutableMap<TypeVariableKey, Type>.get", "TypeVariable<?>.getBounds", "TypeVariable<?>.getGenericDeclaration", "TypeVariable<?>.getName"], "method_name": "TypeResolver.resolveInternal", "method_implementation": "{\n    Type type = map.get(new TypeVariableKey(var));\n    if (type == null) {\n        Type[] bounds = var.getBounds();\n        if (bounds.length == 0) {\n            return var;\n        }\n        Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n        /*\n         * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't\n         * recognize instances of our TypeVariable implementation. This is a problem because users\n         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To\n         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable\n         * implementation in each of the three possible cases:\n         *\n         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.\n         * Therefore, we can always create our own TypeVariable.\n         *\n         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate\n         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n         *\n         * 2a. If the resolved types are identical to the original types, then we can return the\n         * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely.\n         *\n         * 2b. If the resolved types are different from the original types, things are trickier. The\n         * only way to get a TypeVariable instance for the resolved types is to create our own. The\n         * created TypeVariable will not interoperate with any JDK TypeVariable. But this is OK: We\n         * don't _want_ our new TypeVariable to be equal to the JDK TypeVariable because it has\n         * _different bounds_ than the JDK TypeVariable. And it wouldn't make sense for our new\n         * TypeVariable to be equal to any _other_ JDK TypeVariable, either, because any other JDK\n         * TypeVariable must have a different declaration or name. The only TypeVariable that our\n         * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created\n         * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n         * TypeVariable implementation at all.\n         */\n        if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY && Arrays.equals(bounds, resolvedBounds)) {\n            return var;\n        }\n        return Types.newArtificialTypeVariable(var.getGenericDeclaration(), var.getName(), resolvedBounds);\n    }\n    // in case the type is yet another type variable.\n    return new TypeResolver(forDependants).resolveType(type);\n}", "repo_id": "5", "comment": "/**\n * Resolves {@code var} using the encapsulated type mapping. If it maps to yet another\n * non-reified type or has bounds, {@code forDependants} is used to do further resolution, which\n * doesn't try to resolve any type variable on generic declarations that are already being\n * resolved.\n *\n * <p>Should only be called and overridden by {@link #resolve(TypeVariable)}.\n */\n", "repo_name": "guava-master/", "id": 4657, "method_signature": "Type resolveInternal(TypeVariable, TypeTable)", "filename": "TypeResolver.resolveInternal.json"}
{"callee_method_names": ["TypeTable.resolve"], "method_name": "TypeResolver.resolveType", "method_implementation": "{\n    checkNotNull(type);\n    if (type instanceof TypeVariable) {\n        return typeTable.resolve((TypeVariable<?>) type);\n    } else if (type instanceof ParameterizedType) {\n        return resolveParameterizedType((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n        return resolveGenericArrayType((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n        return resolveWildcardType((WildcardType) type);\n    } else {\n        // if Class<?>, no resolution needed, we are done.\n        return type;\n    }\n}", "repo_id": "5", "comment": "/**\n * Resolves all type variables in {@code type} and all downstream types and returns a\n * corresponding type with type variables resolved.\n */\n", "repo_name": "guava-master/", "id": 4655, "method_signature": "Type resolveType(Type)", "filename": "TypeResolver.resolveType.json"}
{"callee_method_ids": [4665], "callee_method_names": ["ImmutableMap.Builder<TypeVariableKey, Type>.putAll", "Map<TypeVariableKey,? extends Type>.entrySet", "TypeVariableKey.equalsType", "ImmutableMap.Builder<TypeVariableKey, Type>.put", "ImmutableMap.Builder<TypeVariableKey, Type>.buildOrThrow"], "method_name": "TypeResolver.where", "method_implementation": "{\n    ImmutableMap.Builder<TypeVariableKey, Type> builder = ImmutableMap.builder();\n    builder.putAll(map);\n    for (Entry<TypeVariableKey, ? extends Type> mapping : mappings.entrySet()) {\n        TypeVariableKey variable = mapping.getKey();\n        Type type = mapping.getValue();\n        checkArgument(!variable.equalsType(type), \"Type variable %s bound to itself\", variable);\n        builder.put(variable, type);\n    }\n    return new TypeTable(builder.buildOrThrow());\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}.\n */\n", "repo_name": "guava-master/", "id": 4656, "method_signature": "TypeTable where(Map)", "filename": "TypeResolver.where.json"}
{"callee_method_names": [], "method_name": "TypeSet.rawTypes", "method_implementation": "{\n    // Java has no way to express ? super T when we parameterize TypeToken vs. Class.\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    ImmutableList<Class<? super T>> collectedTypes = (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n    return ImmutableSet.copyOf(collectedTypes);\n}", "repo_id": "5", "comment": "/**\n * Returns the raw types of the types in this set, in the same order.\n */\n", "repo_name": "guava-master/", "id": 4692, "method_signature": "Set<Class<? super T>> rawTypes()", "filename": "TypeSet.rawTypes.json"}
{"callee_method_names": ["ImmutableMap<TypeVariableKey, Type>.get", "TypeVariable<?>.getBounds", "TypeVariable<?>.getGenericDeclaration", "TypeVariable<?>.getName"], "method_name": "TypeTable.resolveInternal", "method_implementation": "{\n    Type type = map.get(new TypeVariableKey(var));\n    if (type == null) {\n        Type[] bounds = var.getBounds();\n        if (bounds.length == 0) {\n            return var;\n        }\n        Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n        /*\n         * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't\n         * recognize instances of our TypeVariable implementation. This is a problem because users\n         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To\n         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable\n         * implementation in each of the three possible cases:\n         *\n         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.\n         * Therefore, we can always create our own TypeVariable.\n         *\n         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate\n         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n         *\n         * 2a. If the resolved types are identical to the original types, then we can return the\n         * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely.\n         *\n         * 2b. If the resolved types are different from the original types, things are trickier. The\n         * only way to get a TypeVariable instance for the resolved types is to create our own. The\n         * created TypeVariable will not interoperate with any JDK TypeVariable. But this is OK: We\n         * don't _want_ our new TypeVariable to be equal to the JDK TypeVariable because it has\n         * _different bounds_ than the JDK TypeVariable. And it wouldn't make sense for our new\n         * TypeVariable to be equal to any _other_ JDK TypeVariable, either, because any other JDK\n         * TypeVariable must have a different declaration or name. The only TypeVariable that our\n         * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created\n         * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n         * TypeVariable implementation at all.\n         */\n        if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY && Arrays.equals(bounds, resolvedBounds)) {\n            return var;\n        }\n        return Types.newArtificialTypeVariable(var.getGenericDeclaration(), var.getName(), resolvedBounds);\n    }\n    // in case the type is yet another type variable.\n    return new TypeResolver(forDependants).resolveType(type);\n}", "repo_id": "5", "comment": "/**\n * Resolves {@code var} using the encapsulated type mapping. If it maps to yet another\n * non-reified type or has bounds, {@code forDependants} is used to do further resolution, which\n * doesn't try to resolve any type variable on generic declarations that are already being\n * resolved.\n *\n * <p>Should only be called and overridden by {@link #resolve(TypeVariable)}.\n */\n", "repo_name": "guava-master/", "id": 4662, "method_signature": "Type resolveInternal(TypeVariable, TypeTable)", "filename": "TypeTable.resolveInternal.json"}
{"callee_method_ids": [4665], "callee_method_names": ["ImmutableMap.Builder<TypeVariableKey, Type>.putAll", "Map<TypeVariableKey,? extends Type>.entrySet", "TypeVariableKey.equalsType", "ImmutableMap.Builder<TypeVariableKey, Type>.put", "ImmutableMap.Builder<TypeVariableKey, Type>.buildOrThrow"], "method_name": "TypeTable.where", "method_implementation": "{\n    ImmutableMap.Builder<TypeVariableKey, Type> builder = ImmutableMap.builder();\n    builder.putAll(map);\n    for (Entry<TypeVariableKey, ? extends Type> mapping : mappings.entrySet()) {\n        TypeVariableKey variable = mapping.getKey();\n        Type type = mapping.getValue();\n        checkArgument(!variable.equalsType(type), \"Type variable %s bound to itself\", variable);\n        builder.put(variable, type);\n    }\n    return new TypeTable(builder.buildOrThrow());\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}.\n */\n", "repo_name": "guava-master/", "id": 4661, "method_signature": "TypeTable where(Map)", "filename": "TypeTable.where.json"}
{"callee_method_names": [], "method_name": "TypeToken.canonicalizeTypeArg", "method_implementation": "{\n    return typeArg instanceof WildcardType ? canonicalizeWildcardType(declaration, ((WildcardType) typeArg)) : canonicalizeWildcardsInType(typeArg);\n}", "repo_id": "5", "comment": "/**\n * In reflection, {@code Foo<?>.getUpperBounds()[0]} is always {@code Object.class}, even when Foo\n * is defined as {@code Foo<T extends String>}. Thus directly calling {@code <?>.is(String.class)}\n * will return false. To mitigate, we canonicalize wildcards by enforcing the following\n * invariants:\n *\n * <ol>\n *   <li>{@code canonicalize(t)} always produces the equal result for equivalent types. For\n *       example both {@code Enum<?>} and {@code Enum<? extends Enum<?>>} canonicalize to {@code\n *       Enum<? extends Enum<E>}.\n *   <li>{@code canonicalize(t)} produces a \"literal\" supertype of t. For example: {@code Enum<?\n *       extends Enum<?>>} canonicalizes to {@code Enum<?>}, which is a supertype (if we disregard\n *       the upper bound is implicitly an Enum too).\n *   <li>If {@code canonicalize(A) == canonicalize(B)}, then {@code Foo<A>.isSubtypeOf(Foo<B>)}\n *       and vice versa. i.e. {@code A.is(B)} and {@code B.is(A)}.\n *   <li>{@code canonicalize(canonicalize(A)) == canonicalize(A)}.\n * </ol>\n */\n", "repo_name": "guava-master/", "id": 4686, "method_signature": "Type canonicalizeTypeArg(TypeVariable, Type)", "filename": "TypeToken.canonicalizeTypeArg.json"}
{"callee_method_names": ["TypeVariable<?>.getBounds", "WildcardType.getUpperBounds", "List<Type>.add", "WildcardType.getLowerBounds", "List<Type>.toArray"], "method_name": "TypeToken.canonicalizeWildcardType", "method_implementation": "{\n    Type[] declared = declaration.getBounds();\n    List<Type> upperBounds = new ArrayList<>();\n    for (Type bound : type.getUpperBounds()) {\n        if (!any(declared).isSubtypeOf(bound)) {\n            upperBounds.add(canonicalizeWildcardsInType(bound));\n        }\n    }\n    return new Types.WildcardTypeImpl(type.getLowerBounds(), upperBounds.toArray(new Type[0]));\n}", "repo_id": "5", "comment": "// Just don't ever let the user access it.\n", "repo_name": "guava-master/", "id": 4687, "method_signature": "WildcardType canonicalizeWildcardType(TypeVariable, WildcardType)", "filename": "TypeToken.canonicalizeWildcardType.json"}
{"callee_method_names": ["ImmutableList.Builder<K>.add", "ImmutableList.Builder<K>.build"], "method_name": "TypeToken.classesOnly", "method_implementation": "{\n    return new ForwardingTypeCollector<K>(this) {\n\n        @Override\n        Iterable<? extends K> getInterfaces(K type) {\n            return ImmutableSet.of();\n        }\n\n        @Override\n        ImmutableList<K> collectTypes(Iterable<? extends K> types) {\n            ImmutableList.Builder<K> builder = ImmutableList.builder();\n            for (K type : types) {\n                if (!getRawType(type).isInterface()) {\n                    builder.add(type);\n                }\n            }\n            return super.collectTypes(builder.build());\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * For just classes, we don't have to traverse interfaces.\n */\n", "repo_name": "guava-master/", "id": 4690, "method_signature": "TypeCollector<K> classesOnly()", "filename": "TypeToken.classesOnly.json"}
{"callee_method_names": ["Map<? super K,Integer>.get", "Map<? super K,Integer>.put"], "method_name": "TypeToken.collectTypes", "method_implementation": "{\n    Integer existing = map.get(type);\n    if (existing != null) {\n        // short circuit: if set contains type it already contains its supertypes\n        return existing;\n    }\n    // Interfaces should be listed before Object.\n    int aboveMe = getRawType(type).isInterface() ? 1 : 0;\n    for (K interfaceType : getInterfaces(type)) {\n        aboveMe = Math.max(aboveMe, collectTypes(interfaceType, map));\n    }\n    K superclass = getSuperclass(type);\n    if (superclass != null) {\n        aboveMe = Math.max(aboveMe, collectTypes(superclass, map));\n    }\n    /*\n       * TODO(benyu): should we include Object for interface? Also, CharSequence[] and Object[] for\n       * String[]?\n       *\n       */\n    map.put(type, aboveMe + 1);\n    return aboveMe + 1;\n}", "repo_id": "5", "comment": "/**\n * Collects all types to map, and returns the total depth from T up to Object.\n */\n", "repo_name": "guava-master/", "id": 4691, "method_signature": "int collectTypes(K, Map)", "filename": "TypeToken.collectTypes.json"}
{"callee_method_names": ["Constructor<?>.getDeclaringClass"], "method_name": "TypeToken.constructor", "method_implementation": "{\n    checkArgument(constructor.getDeclaringClass() == getRawType(), \"%s not declared by %s\", constructor, getRawType());\n    return new Invokable.ConstructorInvokable<T>(constructor) {\n\n        @Override\n        Type getGenericReturnType() {\n            return getCovariantTypeResolver().resolveType(super.getGenericReturnType());\n        }\n\n        @Override\n        Type[] getGenericParameterTypes() {\n            return getInvariantTypeResolver().resolveTypesInPlace(super.getGenericParameterTypes());\n        }\n\n        @Override\n        Type[] getGenericExceptionTypes() {\n            return getCovariantTypeResolver().resolveTypesInPlace(super.getGenericExceptionTypes());\n        }\n\n        @Override\n        public TypeToken<T> getOwnerType() {\n            return TypeToken.this;\n        }\n\n        @Override\n        public String toString() {\n            return getOwnerType() + \"(\" + Joiner.on(\", \").join(getGenericParameterTypes()) + \")\";\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns the {@link Invokable} for {@code constructor}, which must be a member of {@code T}.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4680, "method_signature": "Invokable<T,T> constructor(Constructor)", "filename": "TypeToken.constructor.json"}
{"callee_method_names": ["Type.equals"], "method_name": "TypeToken.equals", "method_implementation": "{\n    if (o instanceof TypeToken) {\n        TypeToken<?> that = (TypeToken<?>) o;\n        return runtimeType.equals(that.runtimeType);\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns true if {@code o} is another {@code TypeToken} that represents the same {@link Type}.\n */\n", "repo_name": "guava-master/", "id": 4682, "method_signature": "boolean equals(Object)", "filename": "TypeToken.equals.json"}
{"callee_method_names": [], "method_name": "TypeToken.getComponentType", "method_implementation": "{\n    Type componentType = Types.getComponentType(runtimeType);\n    if (componentType == null) {\n        return null;\n    }\n    return of(componentType);\n}", "repo_id": "5", "comment": "/**\n * Returns the array component type if this type represents an array ({@code int[]}, {@code T[]},\n * {@code <? extends Map<String, Integer>[]>} etc.), or else {@code null} is returned.\n */\n", "repo_name": "guava-master/", "id": 4678, "method_signature": "TypeToken<?> getComponentType()", "filename": "TypeToken.getComponentType.json"}
{"callee_method_names": ["ImmutableList.Builder<TypeToken<? super T>>.add", "ImmutableList.Builder<TypeToken<? super T>>.build"], "method_name": "TypeToken.getGenericInterfaces", "method_implementation": "{\n    if (runtimeType instanceof TypeVariable) {\n        return boundsAsInterfaces(((TypeVariable<?>) runtimeType).getBounds());\n    }\n    if (runtimeType instanceof WildcardType) {\n        return boundsAsInterfaces(((WildcardType) runtimeType).getUpperBounds());\n    }\n    ImmutableList.Builder<TypeToken<? super T>> builder = ImmutableList.builder();\n    for (Type interfaceType : getRawType().getGenericInterfaces()) {\n        // interface of T\n        @SuppressWarnings(\"unchecked\")\n        TypeToken<? super T> resolvedInterface = (TypeToken<? super T>) resolveSupertype(interfaceType);\n        builder.add(resolvedInterface);\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Returns the generic interfaces that this type directly {@code implements}. This method is\n * similar but different from {@link Class#getGenericInterfaces()}. For example, {@code new\n * TypeToken<List<String>>() {}.getGenericInterfaces()} will return a list that contains {@code\n * new TypeToken<Iterable<String>>() {}}; while {@code List.class.getGenericInterfaces()} will\n * return an array that contains {@code Iterable<T>}, where the {@code T} is the type variable\n * declared by interface {@code Iterable}.\n *\n * <p>If this type is a type variable or wildcard, its upper bounds are examined and those that\n * are either an interface or upper-bounded only by interfaces are returned. This means that the\n * returned types could include type variables too.\n */\n", "repo_name": "guava-master/", "id": 4672, "method_signature": "ImmutableList<TypeToken<? super T>> getGenericInterfaces()", "filename": "TypeToken.getGenericInterfaces.json"}
{"callee_method_names": [], "method_name": "TypeToken.getGenericSuperclass", "method_implementation": "{\n    if (runtimeType instanceof TypeVariable) {\n        // First bound is always the super class, if one exists.\n        return boundAsSuperclass(((TypeVariable<?>) runtimeType).getBounds()[0]);\n    }\n    if (runtimeType instanceof WildcardType) {\n        // wildcard has one and only one upper bound.\n        return boundAsSuperclass(((WildcardType) runtimeType).getUpperBounds()[0]);\n    }\n    Type superclass = getRawType().getGenericSuperclass();\n    if (superclass == null) {\n        return null;\n    }\n    // super class of T\n    @SuppressWarnings(\"unchecked\")\n    TypeToken<? super T> superToken = (TypeToken<? super T>) resolveSupertype(superclass);\n    return superToken;\n}", "repo_id": "5", "comment": "/**\n * Returns the generic superclass of this type or {@code null} if the type represents {@link\n * Object} or an interface. This method is similar but different from {@link\n * Class#getGenericSuperclass}. For example, {@code new TypeToken<StringArrayList>()\n * {}.getGenericSuperclass()} will return {@code new TypeToken<ArrayList<String>>() {}}; while\n * {@code StringArrayList.class.getGenericSuperclass()} will return {@code ArrayList<E>}, where\n * {@code E} is the type variable declared by class {@code ArrayList}.\n *\n * <p>If this type is a type variable or wildcard, its first upper bound is examined and returned\n * if the bound is a class or extends from a class. This means that the returned type could be a\n * type variable too.\n */\n", "repo_name": "guava-master/", "id": 4671, "method_signature": "TypeToken<? super T> getGenericSuperclass()", "filename": "TypeToken.getGenericSuperclass.json"}
{"callee_method_names": [], "method_name": "TypeToken.getOwnerTypeIfPresent", "method_implementation": "{\n    if (runtimeType instanceof ParameterizedType) {\n        return ((ParameterizedType) runtimeType).getOwnerType();\n    } else if (runtimeType instanceof Class<?>) {\n        return ((Class<?>) runtimeType).getEnclosingClass();\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the owner type of a {@link ParameterizedType} or enclosing class of a {@link Class}, or\n * null otherwise.\n */\n", "repo_name": "guava-master/", "id": 4688, "method_signature": "Type getOwnerTypeIfPresent()", "filename": "TypeToken.getOwnerTypeIfPresent.json"}
{"callee_method_names": [], "method_name": "TypeToken.getRawType", "method_implementation": "{\n    // For wildcard or type variable, the first bound determines the runtime type.\n    Class<?> rawType = getRawTypes().iterator().next();\n    // raw type is |T|\n    @SuppressWarnings(\"unchecked\")\n    Class<? super T> result = (Class<? super T>) rawType;\n    return result;\n}", "repo_id": "5", "comment": "/**\n * Returns the raw type of {@code T}. Formally speaking, if {@code T} is returned by {@link\n * java.lang.reflect.Method#getGenericReturnType}, the raw type is what's returned by {@link\n * java.lang.reflect.Method#getReturnType} of the same method object. Specifically:\n *\n * <ul>\n *   <li>If {@code T} is a {@code Class} itself, {@code T} itself is returned.\n *   <li>If {@code T} is a {@link ParameterizedType}, the raw type of the parameterized type is\n *       returned.\n *   <li>If {@code T} is a {@link GenericArrayType}, the returned type is the corresponding array\n *       class. For example: {@code List<Integer>[] => List[]}.\n *   <li>If {@code T} is a type variable or a wildcard type, the raw type of the first upper bound\n *       is returned. For example: {@code <X extends Foo> => Foo}.\n * </ul>\n */\n", "repo_name": "guava-master/", "id": 4668, "method_signature": "Class<? super T> getRawType()", "filename": "TypeToken.getRawType.json"}
{"callee_method_names": ["TypeToken<? extends T>.isSubtypeOf"], "method_name": "TypeToken.getSubtype", "method_implementation": "{\n    checkArgument(!(runtimeType instanceof TypeVariable), \"Cannot get subtype of type variable <%s>\", this);\n    if (runtimeType instanceof WildcardType) {\n        return getSubtypeFromLowerBounds(subclass, ((WildcardType) runtimeType).getLowerBounds());\n    }\n    // unwrap array type if necessary\n    if (isArray()) {\n        return getArraySubtype(subclass);\n    }\n    // At this point, it's either a raw class or parameterized type.\n    checkArgument(getRawType().isAssignableFrom(subclass), \"%s isn't a subclass of %s\", subclass, this);\n    Type resolvedTypeArgs = resolveTypeArgsForSubclass(subclass);\n    // guarded by the isAssignableFrom() statement above\n    @SuppressWarnings(\"unchecked\")\n    TypeToken<? extends T> subtype = (TypeToken<? extends T>) of(resolvedTypeArgs);\n    checkArgument(subtype.isSubtypeOf(this), \"%s does not appear to be a subtype of %s\", subtype, this);\n    return subtype;\n}", "repo_id": "5", "comment": "/**\n * Returns subtype of {@code this} with {@code subclass} as the raw class. For example, if this is\n * {@code Iterable<String>} and {@code subclass} is {@code List}, {@code List<String>} is\n * returned.\n */\n", "repo_name": "guava-master/", "id": 4674, "method_signature": "TypeToken<? extends T> getSubtype(Class)", "filename": "TypeToken.getSubtype.json"}
{"callee_method_names": ["Class<? super T>.isArray"], "method_name": "TypeToken.getSupertype", "method_implementation": "{\n    checkArgument(this.someRawTypeIsSubclassOf(superclass), \"%s is not a super class of %s\", superclass, this);\n    if (runtimeType instanceof TypeVariable) {\n        return getSupertypeFromUpperBounds(superclass, ((TypeVariable<?>) runtimeType).getBounds());\n    }\n    if (runtimeType instanceof WildcardType) {\n        return getSupertypeFromUpperBounds(superclass, ((WildcardType) runtimeType).getUpperBounds());\n    }\n    if (superclass.isArray()) {\n        return getArraySupertype(superclass);\n    }\n    // resolved supertype\n    @SuppressWarnings(\"unchecked\")\n    TypeToken<? super T> supertype = (TypeToken<? super T>) resolveSupertype(toGenericType(superclass).runtimeType);\n    return supertype;\n}", "repo_id": "5", "comment": "/**\n * Returns the generic form of {@code superclass}. For example, if this is {@code\n * ArrayList<String>}, {@code Iterable<String>} is returned given the input {@code\n * Iterable.class}.\n */\n", "repo_name": "guava-master/", "id": 4673, "method_signature": "TypeToken<? super T> getSupertype(Class)", "filename": "TypeToken.getSupertype.json"}
{"callee_method_names": ["Type.equals", "WildcardType.getUpperBounds", "WildcardType.getLowerBounds"], "method_name": "TypeToken.is", "method_implementation": "{\n    if (runtimeType.equals(formalType)) {\n        return true;\n    }\n    if (formalType instanceof WildcardType) {\n        WildcardType your = canonicalizeWildcardType(declaration, (WildcardType) formalType);\n        // if \"formalType\" is <? extends Foo>, \"this\" can be:\n        // Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or\n        // <T extends SubFoo>.\n        // if \"formalType\" is <? super Foo>, \"this\" can be:\n        // Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.\n        return every(your.getUpperBounds()).isSupertypeOf(runtimeType) && every(your.getLowerBounds()).isSubtypeOf(runtimeType);\n    }\n    return canonicalizeWildcardsInType(runtimeType).equals(canonicalizeWildcardsInType(formalType));\n}", "repo_id": "5", "comment": "/**\n * {@code A.is(B)} is defined as {@code Foo<A>.isSubtypeOf(Foo<B>)}.\n *\n * <p>Specifically, returns true if any of the following conditions is met:\n *\n * <ol>\n *   <li>'this' and {@code formalType} are equal.\n *   <li>'this' and {@code formalType} have equal canonical form.\n *   <li>{@code formalType} is {@code <? extends Foo>} and 'this' is a subtype of {@code Foo}.\n *   <li>{@code formalType} is {@code <? super Foo>} and 'this' is a supertype of {@code Foo}.\n * </ol>\n *\n * Note that condition 2 isn't technically accurate under the context of a recursively bounded\n * type variables. For example, {@code Enum<? extends Enum<E>>} canonicalizes to {@code Enum<?>}\n * where {@code E} is the type variable declared on the {@code Enum} class declaration. It's\n * technically <em>not</em> true that {@code Foo<Enum<? extends Enum<E>>>} is a subtype of {@code\n * Foo<Enum<?>>} according to JLS. See testRecursiveWildcardSubtypeBug() for a real example.\n *\n * <p>It appears that properly handling recursive type bounds in the presence of implicit type\n * bounds is not easy. For now we punt, hoping that this defect should rarely cause issues in real\n * code.\n *\n * @param formalType is {@code Foo<formalType>} a supertype of {@code Foo<T>}?\n * @param declaration The type variable in the context of a parameterized type. Used to infer type\n *     bound when {@code formalType} is a wildcard with implicit upper bound.\n */\n", "repo_name": "guava-master/", "id": 4685, "method_signature": "boolean is(Type, TypeVariable)", "filename": "TypeToken.is.json"}
{"callee_method_names": ["Type.equals"], "method_name": "TypeToken.isSubtypeOf", "method_implementation": "{\n    checkNotNull(supertype);\n    if (supertype instanceof WildcardType) {\n        // if 'supertype' is <? super Foo>, 'this' can be:\n        // Foo, SubFoo, <? extends Foo>.\n        // if 'supertype' is <? extends Foo>, nothing is a subtype.\n        return any(((WildcardType) supertype).getLowerBounds()).isSupertypeOf(runtimeType);\n    }\n    // if 'this' is wildcard, it's a suptype of to 'supertype' if any of its \"extends\"\n    // bounds is a subtype of 'supertype'.\n    if (runtimeType instanceof WildcardType) {\n        // <? super Base> is of no use in checking 'from' being a subtype of 'to'.\n        return any(((WildcardType) runtimeType).getUpperBounds()).isSubtypeOf(supertype);\n    }\n    // if 'this' is type variable, it's a subtype if any of its \"extends\"\n    // bounds is a subtype of 'supertype'.\n    if (runtimeType instanceof TypeVariable) {\n        return runtimeType.equals(supertype) || any(((TypeVariable<?>) runtimeType).getBounds()).isSubtypeOf(supertype);\n    }\n    if (runtimeType instanceof GenericArrayType) {\n        return of(supertype).isSupertypeOfArray((GenericArrayType) runtimeType);\n    }\n    // Proceed to regular Type subtype check\n    if (supertype instanceof Class) {\n        return this.someRawTypeIsSubclassOf((Class<?>) supertype);\n    } else if (supertype instanceof ParameterizedType) {\n        return this.isSubtypeOfParameterizedType((ParameterizedType) supertype);\n    } else if (supertype instanceof GenericArrayType) {\n        return this.isSubtypeOfArrayType((GenericArrayType) supertype);\n    } else {\n        // to instanceof TypeVariable\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns true if this type is a subtype of the given {@code type}. \"Subtype\" is defined\n * according to <a\n * href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for type\n * arguments</a> introduced with Java generics.\n *\n * @since 19.0\n */\n", "repo_name": "guava-master/", "id": 4675, "method_signature": "boolean isSubtypeOf(Type)", "filename": "TypeToken.isSubtypeOf.json"}
{"callee_method_names": ["Method.getDeclaringClass"], "method_name": "TypeToken.method", "method_implementation": "{\n    checkArgument(this.someRawTypeIsSubclassOf(method.getDeclaringClass()), \"%s not declared by %s\", method, this);\n    return new Invokable.MethodInvokable<T>(method) {\n\n        @Override\n        Type getGenericReturnType() {\n            return getCovariantTypeResolver().resolveType(super.getGenericReturnType());\n        }\n\n        @Override\n        Type[] getGenericParameterTypes() {\n            return getInvariantTypeResolver().resolveTypesInPlace(super.getGenericParameterTypes());\n        }\n\n        @Override\n        Type[] getGenericExceptionTypes() {\n            return getCovariantTypeResolver().resolveTypesInPlace(super.getGenericExceptionTypes());\n        }\n\n        @Override\n        public TypeToken<T> getOwnerType() {\n            return TypeToken.this;\n        }\n\n        @Override\n        public String toString() {\n            return getOwnerType() + \".\" + super.toString();\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Returns the {@link Invokable} for {@code method}, which must be a member of {@code T}.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4679, "method_signature": "Invokable<T,Object> method(Method)", "filename": "TypeToken.method.json"}
{"callee_method_names": [], "method_name": "TypeToken.rawTypes", "method_implementation": "{\n    // Java has no way to express ? super T when we parameterize TypeToken vs. Class.\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    ImmutableList<Class<? super T>> collectedTypes = (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n    return ImmutableSet.copyOf(collectedTypes);\n}", "repo_id": "5", "comment": "/**\n * Returns the raw types of the types in this set, in the same order.\n */\n", "repo_name": "guava-master/", "id": 4681, "method_signature": "Set<Class<? super T>> rawTypes()", "filename": "TypeToken.rawTypes.json"}
{"callee_method_names": ["Class<T>.getLowerBounds", "Class<T>.getUpperBounds", "Class<T>.getActualTypeArguments", "Class<T>.getOwnerType", "Class<T>.getGenericComponentType"], "method_name": "TypeToken.rejectTypeVariables", "method_implementation": "{\n    new TypeVisitor() {\n\n        @Override\n        void visitTypeVariable(TypeVariable<?> type) {\n            throw new IllegalArgumentException(runtimeType + \"contains a type variable and is not safe for the operation\");\n        }\n\n        @Override\n        void visitWildcardType(WildcardType type) {\n            visit(type.getLowerBounds());\n            visit(type.getUpperBounds());\n        }\n\n        @Override\n        void visitParameterizedType(ParameterizedType type) {\n            visit(type.getActualTypeArguments());\n            visit(type.getOwnerType());\n        }\n\n        @Override\n        void visitGenericArrayType(GenericArrayType type) {\n            visit(type.getGenericComponentType());\n        }\n    }.visit(runtimeType);\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Ensures that this type token doesn't contain type variables, which can cause unchecked type\n * errors for callers like {@link TypeToInstanceMap}.\n */\n", "repo_name": "guava-master/", "id": 4684, "method_signature": "TypeToken<T> rejectTypeVariables()", "filename": "TypeToken.rejectTypeVariables.json"}
{"callee_method_names": [], "method_name": "TypeToken.resolveType", "method_implementation": "{\n    checkNotNull(type);\n    // Being conservative here because the user could use resolveType() to resolve a type in an\n    // invariant context.\n    return of(getInvariantTypeResolver().resolveType(type));\n}", "repo_id": "5", "comment": "/**\n * Resolves the given {@code type} against the type context represented by this type. For example:\n *\n * <pre>{@code\n * new TypeToken<List<String>>() {}.resolveType(\n *     List.class.getMethod(\"get\", int.class).getGenericReturnType())\n * => String.class\n * }</pre>\n */\n", "repo_name": "guava-master/", "id": 4670, "method_signature": "TypeToken<?> resolveType(Type)", "filename": "TypeToken.resolveType.json"}
{"callee_method_names": ["Class<T>.isArray", "Class<T>.getComponentType", "Class<T>.getTypeParameters", "Class<T>.isMemberClass", "Class<T>.getModifiers", "Class<T>.getEnclosingClass", "Class<T>.getEnclosingClass"], "method_name": "TypeToken.toGenericType", "method_implementation": "{\n    if (cls.isArray()) {\n        Type arrayOfGenericType = Types.newArrayType(// If we are passed with int[].class, don't turn it to GenericArrayType\n        toGenericType(cls.getComponentType()).runtimeType);\n        // array is covariant\n        @SuppressWarnings(\"unchecked\")\n        TypeToken<? extends T> result = (TypeToken<? extends T>) of(arrayOfGenericType);\n        return result;\n    }\n    TypeVariable<Class<T>>[] typeParams = cls.getTypeParameters();\n    Type ownerType = cls.isMemberClass() && !Modifier.isStatic(cls.getModifiers()) ? toGenericType(cls.getEnclosingClass()).runtimeType : null;\n    if ((typeParams.length > 0) || ((ownerType != null) && ownerType != cls.getEnclosingClass())) {\n        // Like, it's Iterable<T> for Iterable.class\n        @SuppressWarnings(\"unchecked\")\n        TypeToken<? extends T> type = (TypeToken<? extends T>) of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams));\n        return type;\n    } else {\n        return of(cls);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the type token representing the generic type declaration of {@code cls}. For example:\n * {@code TypeToken.getGenericType(Iterable.class)} returns {@code Iterable<T>}.\n *\n * <p>If {@code cls} isn't parameterized and isn't a generic array, the type token of the class is\n * returned.\n */\n", "repo_name": "guava-master/", "id": 4689, "method_signature": "TypeToken<? extends T> toGenericType(Class)", "filename": "TypeToken.toGenericType.json"}
{"callee_method_names": [], "method_name": "TypeToken.unwrap", "method_implementation": "{\n    if (isWrapper()) {\n        // this is a wrapper class\n        @SuppressWarnings(\"unchecked\")\n        Class<T> type = (Class<T>) runtimeType;\n        return of(Primitives.unwrap(type));\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Returns the corresponding primitive type if this is a wrapper type; otherwise returns {@code\n * this} itself. Idempotent.\n *\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 4677, "method_signature": "TypeToken<T> unwrap()", "filename": "TypeToken.unwrap.json"}
{"callee_method_ids": [4655], "callee_method_names": ["TypeResolver.resolveType"], "method_name": "TypeToken.where", "method_implementation": "{\n    TypeResolver resolver = new TypeResolver().where(ImmutableMap.of(new TypeResolver.TypeVariableKey(typeParam.typeVariable), typeArg.runtimeType));\n    // If there's any type error, we'd report now rather than later.\n    return new SimpleTypeToken<>(resolver.resolveType(runtimeType));\n}", "repo_id": "5", "comment": "/*\n   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters\n   * that have nullable bounds? Unfortunately, if we change the parameter to TypeParameter<? extends\n   * @Nullable X>, then users might pass a TypeParameter<Y>, where Y is a subtype of X, while still\n   * passing a TypeToken<X>. This would be invalid. Maybe we could accept a TypeParameter<@PolyNull\n   * X> if we support such a thing? It would be weird or misleading for users to be able to pass\n   * `new TypeParameter<@Nullable T>() {}` and have it act as a plain `TypeParameter<T>`, but\n   * hopefully no one would do that, anyway. See also the comment on TypeParameter itself.\n   *\n   * TODO(cpovirk): Elaborate on this / merge with other comment?\n   */\n", "repo_name": "guava-master/", "id": 4669, "method_signature": "TypeToken<T> where(TypeParameter, TypeToken)", "filename": "TypeToken.where.json"}
{"callee_method_names": [], "method_name": "TypeToken.wrap", "method_implementation": "{\n    if (isPrimitive()) {\n        // this is a primitive class\n        @SuppressWarnings(\"unchecked\")\n        Class<T> type = (Class<T>) runtimeType;\n        return of(Primitives.wrap(type));\n    }\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Returns the corresponding wrapper type if this is a primitive type; otherwise returns {@code\n * this} itself. Idempotent.\n *\n * @since 15.0\n */\n", "repo_name": "guava-master/", "id": 4676, "method_signature": "TypeToken<T> wrap()", "filename": "TypeToken.wrap.json"}
{"callee_method_names": [], "method_name": "TypeToken.writeReplace", "method_implementation": "{\n    // TypeResolver just transforms the type to our own impls that are Serializable\n    // except TypeVariable.\n    return of(new TypeResolver().resolveType(runtimeType));\n}", "repo_id": "5", "comment": "/**\n * Implemented to support serialization of subclasses.\n */\n", "repo_name": "guava-master/", "id": 4683, "method_signature": "Object writeReplace()", "filename": "TypeToken.writeReplace.json"}
{"callee_method_names": [], "method_name": "TypeTokenSubtypeTest.explicitTypeBoundIsSubtypeOfImplicitTypeBound", "method_implementation": "{\n    return isSubtype(obj);\n}", "repo_id": "5", "comment": "// Foo<?> and Foo<? extends Bar> equal for class Foo<T extends Bar>\n", "repo_name": "guava-master/", "id": 3620, "method_signature": "UseIterable<?> explicitTypeBoundIsSubtypeOfImplicitTypeBound(UseIterable)", "filename": "TypeTokenSubtypeTest.explicitTypeBoundIsSubtypeOfImplicitTypeBound.json"}
{"callee_method_names": [], "method_name": "TypeTokenSubtypeTest.implicitTypeBoundIsSubtypeOfExplicitTypeBound", "method_implementation": "{\n    return isSubtype(obj);\n}", "repo_id": "5", "comment": "// Foo<?> and Foo<? extends Bar> equal for class Foo<T extends Bar>\n", "repo_name": "guava-master/", "id": 3621, "method_signature": "UseIterable<? extends Iterable<?>> implicitTypeBoundIsSubtypeOfExplicitTypeBound(UseIterable)", "filename": "TypeTokenSubtypeTest.implicitTypeBoundIsSubtypeOfExplicitTypeBound.json"}
{"callee_method_names": [], "method_name": "TypeTokenSubtypeTest.omittedTypeBoundIsSubtypeOfExplicitTypeBound", "method_implementation": "{\n    return isSubtype(obj);\n}", "repo_id": "5", "comment": "// Foo<?> and Foo<? extends Bar> equal for class Foo<T extends Bar>\n", "repo_name": "guava-master/", "id": 3622, "method_signature": "UseIterable<? extends Iterable<?>> omittedTypeBoundIsSubtypeOfExplicitTypeBound(UseIterable)", "filename": "TypeTokenSubtypeTest.omittedTypeBoundIsSubtypeOfExplicitTypeBound.json"}
{"callee_method_names": [], "method_name": "TypeTokenSubtypeTest.testRecursiveWildcardSubtypeBug", "method_implementation": "{\n    Exception e = assertThrows(Exception.class, () -> new RecursiveTypeBoundBugExample<>().testAllDeclarations());\n    assertThat(e).hasCauseThat().isInstanceOf(AssertionError.class);\n}", "repo_id": "5", "comment": "/**\n * This test reproduces the bug in canonicalizeWildcardType() when the type variable is\n * recursively bounded.\n */\n", "repo_name": "guava-master/", "id": 3619, "method_signature": "void testRecursiveWildcardSubtypeBug()", "filename": "TypeTokenSubtypeTest.testRecursiveWildcardSubtypeBug.json"}
{"callee_method_names": [], "method_name": "TypeTokenTest.testDespiteGenericSignatureFormatError", "method_implementation": "{\n    ImmutableSet<?> unused = ImmutableSet.copyOf(TypeToken.of(ToReproduceGenericSignatureFormatError.SubOuter.SubInner.class).getTypes().rawTypes());\n}", "repo_id": "5", "comment": "// For Guava bug http://code.google.com/p/guava-libraries/issues/detail?id=1025\n", "repo_name": "guava-master/", "id": 3608, "method_signature": "void testDespiteGenericSignatureFormatError()", "filename": "TypeTokenTest.testDespiteGenericSignatureFormatError.json"}
{"callee_method_names": [], "method_name": "TypeTokenTest.testEquals", "method_implementation": "{\n    new EqualsTester().addEqualityGroup(TypeToken.of(String.class), TypeToken.of(String.class), new Entry<String, Integer>() {\n    }.keyType(), new Entry<Integer, String>() {\n    }.valueType(), new TypeToken<String>() {\n    }, new TypeToken<String>() {\n    }).addEqualityGroup(TypeToken.of(Integer.class), new TypeToken<Integer>() {\n    }, new Entry<Integer, String>() {\n    }.keyType(), new Entry<String, Integer>() {\n    }.valueType()).addEqualityGroup(new TypeToken<List<String>>() {\n    }, new TypeToken<List<String>>() {\n    }).addEqualityGroup(new TypeToken<List<?>>() {\n    }, new TypeToken<List<?>>() {\n    }).addEqualityGroup(new TypeToken<Map<A, ?>>() {\n    }, new TypeToken<Map<A, ?>>() {\n    }).addEqualityGroup(new TypeToken<Map<B, ?>>() {\n    }).addEqualityGroup(TypeToken.of(new TypeCapture<A>() {\n    }.capture()), TypeToken.of(new TypeCapture<A>() {\n    }.capture())).addEqualityGroup(TypeToken.of(new TypeCapture<B>() {\n    }.capture())).testEquals();\n}", "repo_id": "5", "comment": "// The A and B type parameters are used inside the test to test type variable\n", "repo_name": "guava-master/", "id": 3609, "method_signature": "void testEquals()", "filename": "TypeTokenTest.testEquals.json"}
{"callee_method_names": [], "method_name": "TypeTokenTest.testToString", "method_implementation": "{\n    assertEquals(String.class.getName(), new TypeToken<String>() {\n    }.toString());\n    assertEquals(\"T\", TypeToken.of(new TypeCapture<T>() {\n    }.capture()).toString());\n    assertEquals(\"java.lang.String\", new Entry<String, Integer>() {\n    }.keyType().toString());\n}", "repo_id": "5", "comment": "// T is used inside to test type variable\n", "repo_name": "guava-master/", "id": 3610, "method_signature": "void testToString()", "filename": "TypeTokenTest.testToString.json"}
{"callee_method_names": [], "method_name": "TypeVariableKey.equalsType", "method_implementation": "{\n    if (type instanceof TypeVariable) {\n        return equalsTypeVariable((TypeVariable<?>) type);\n    } else {\n        return false;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by the\n * same {@code GenericDeclaration}.\n */\n", "repo_name": "guava-master/", "id": 4665, "method_signature": "boolean equalsType(Type)", "filename": "TypeVariableKey.equalsType.json"}
{"callee_method_names": [], "method_name": "TypeVariableKey.forLookup", "method_implementation": "{\n    if (t instanceof TypeVariable) {\n        return new TypeVariableKey((TypeVariable<?>) t);\n    } else {\n        return null;\n    }\n}", "repo_id": "5", "comment": "/**\n * Wraps {@code t} in a {@code TypeVariableKey} if it's a type variable.\n */\n", "repo_name": "guava-master/", "id": 4664, "method_signature": "TypeVariableKey forLookup(Type)", "filename": "TypeVariableKey.forLookup.json"}
{"callee_method_names": ["Set<Type>.add", "Set<Type>.remove"], "method_name": "TypeVisitor.visit", "method_implementation": "{\n    for (Type type : types) {\n        if (type == null || !visited.add(type)) {\n            // null owner type, or already visited;\n            continue;\n        }\n        boolean succeeded = false;\n        try {\n            if (type instanceof TypeVariable) {\n                visitTypeVariable((TypeVariable<?>) type);\n            } else if (type instanceof WildcardType) {\n                visitWildcardType((WildcardType) type);\n            } else if (type instanceof ParameterizedType) {\n                visitParameterizedType((ParameterizedType) type);\n            } else if (type instanceof Class) {\n                visitClass((Class<?>) type);\n            } else if (type instanceof GenericArrayType) {\n                visitGenericArrayType((GenericArrayType) type);\n            } else {\n                throw new AssertionError(\"Unknown type: \" + type);\n            }\n            succeeded = true;\n        } finally {\n            if (!succeeded) {\n                // When the visitation failed, we don't want to ignore the second.\n                visited.remove(type);\n            }\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Visits the given types. Null types are ignored. This allows subclasses to call {@code\n * visit(parameterizedType.getOwnerType())} safely without having to check nulls.\n */\n", "repo_name": "guava-master/", "id": 4666, "method_signature": "void visit(Type[])", "filename": "TypeVisitor.visit.json"}
{"callee_method_names": [], "method_name": "Types.getArrayClass", "method_implementation": "{\n    // TODO(user): This is not the most efficient way to handle generic\n    // arrays, but is there another way to extract the array class in a\n    // non-hacky way (i.e. using String value class names- \"[L...\")?\n    return Array.newInstance(componentType, 0).getClass();\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code Class} object of arrays with {@code componentType}.\n */\n", "repo_name": "guava-master/", "id": 4653, "method_signature": "Class<?> getArrayClass(Class)", "filename": "Types.getArrayClass.json"}
{"callee_method_names": ["WildcardType.getLowerBounds", "WildcardType.getUpperBounds"], "method_name": "Types.newArrayType", "method_implementation": "{\n    if (componentType instanceof WildcardType) {\n        WildcardType wildcard = (WildcardType) componentType;\n        Type[] lowerBounds = wildcard.getLowerBounds();\n        checkArgument(lowerBounds.length <= 1, \"Wildcard cannot have more than one lower bounds.\");\n        if (lowerBounds.length == 1) {\n            return supertypeOf(newArrayType(lowerBounds[0]));\n        } else {\n            Type[] upperBounds = wildcard.getUpperBounds();\n            checkArgument(upperBounds.length == 1, \"Wildcard should have only one upper bound.\");\n            return subtypeOf(newArrayType(upperBounds[0]));\n        }\n    }\n    return JavaVersion.CURRENT.newArrayType(componentType);\n}", "repo_id": "5", "comment": "/**\n * Returns the array type of {@code componentType}.\n */\n", "repo_name": "guava-master/", "id": 4649, "method_signature": "Type newArrayType(Type)", "filename": "Types.newArrayType.json"}
{"callee_method_names": [], "method_name": "Types.newArtificialTypeVariable", "method_implementation": "{\n    return newTypeVariableImpl(declaration, name, (bounds.length == 0) ? new Type[] { Object.class } : bounds);\n}", "repo_id": "5", "comment": "/**\n * Returns a new {@link TypeVariable} that belongs to {@code declaration} with {@code name} and\n * {@code bounds}.\n */\n", "repo_name": "guava-master/", "id": 4651, "method_signature": "TypeVariable<D> newArtificialTypeVariable(D, String, Type[])", "filename": "Types.newArtificialTypeVariable.json"}
{"callee_method_names": ["Class<?>.getEnclosingClass"], "method_name": "Types.newParameterizedTypeWithOwner", "method_implementation": "{\n    if (ownerType == null) {\n        return newParameterizedType(rawType, arguments);\n    }\n    // ParameterizedTypeImpl constructor already checks, but we want to throw NPE before IAE\n    checkNotNull(arguments);\n    checkArgument(rawType.getEnclosingClass() != null, \"Owner type for unenclosed %s\", rawType);\n    return new ParameterizedTypeImpl(ownerType, rawType, arguments);\n}", "repo_id": "5", "comment": "/**\n * Returns a type where {@code rawType} is parameterized by {@code arguments} and is owned by\n * {@code ownerType}.\n */\n", "repo_name": "guava-master/", "id": 4650, "method_signature": "ParameterizedType newParameterizedTypeWithOwner(Type, Class, Type[])", "filename": "Types.newParameterizedTypeWithOwner.json"}
{"callee_method_names": ["Class<?>.isPrimitive"], "method_name": "Types.subtypeOfComponentType", "method_implementation": "{\n    for (Type bound : bounds) {\n        Type componentType = getComponentType(bound);\n        if (componentType != null) {\n            // Only the first bound can be a class or array.\n            // Bounds after the first can only be interfaces.\n            if (componentType instanceof Class) {\n                Class<?> componentClass = (Class<?>) componentType;\n                if (componentClass.isPrimitive()) {\n                    return componentClass;\n                }\n            }\n            return subtypeOf(componentType);\n        }\n    }\n    return null;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code ? extends X} if any of {@code bounds} is a subtype of {@code X[]}; or null\n * otherwise.\n */\n", "repo_name": "guava-master/", "id": 4652, "method_signature": "Type subtypeOfComponentType(Type[])", "filename": "Types.subtypeOfComponentType.json"}
{"callee_method_names": ["ParameterizedType.getActualTypeArguments", "ParameterizedType.getActualTypeArguments", "ParameterizedType.getActualTypeArguments"], "method_name": "TypesTest.testNewParameterizedTypeImmutability", "method_implementation": "{\n    Type[] typesIn = { String.class, Integer.class };\n    ParameterizedType parameterizedType = Types.newParameterizedType(Map.class, typesIn);\n    typesIn[0] = null;\n    typesIn[1] = null;\n    Type[] typesOut = parameterizedType.getActualTypeArguments();\n    typesOut[0] = null;\n    typesOut[1] = null;\n    assertEquals(String.class, parameterizedType.getActualTypeArguments()[0]);\n    assertEquals(Integer.class, parameterizedType.getActualTypeArguments()[1]);\n}", "repo_id": "5", "comment": "/**\n * Working with arrays requires defensive code. Verify that we clone the type array for both input\n * and output.\n */\n", "repo_name": "guava-master/", "id": 3611, "method_signature": "void testNewParameterizedTypeImmutability()", "filename": "TypesTest.testNewParameterizedTypeImmutability.json"}
{"callee_method_names": ["CharSequence.charAt", "CharSequence.charAt"], "method_name": "UnicodeEscaper.codePointAt", "method_implementation": "{\n    checkNotNull(seq);\n    if (index < end) {\n        char c1 = seq.charAt(index++);\n        if (c1 < Character.MIN_HIGH_SURROGATE || c1 > Character.MAX_LOW_SURROGATE) {\n            // Fast path (first test is probably all we need to do)\n            return c1;\n        } else if (c1 <= Character.MAX_HIGH_SURROGATE) {\n            // If the high surrogate was the last character, return its inverse\n            if (index == end) {\n                return -c1;\n            }\n            // Otherwise look for the low surrogate following it\n            char c2 = seq.charAt(index);\n            if (Character.isLowSurrogate(c2)) {\n                return Character.toCodePoint(c1, c2);\n            }\n            throw new IllegalArgumentException(\"Expected low surrogate but got char '\" + c2 + \"' with value \" + (int) c2 + \" at index \" + index + \" in '\" + seq + \"'\");\n        } else {\n            throw new IllegalArgumentException(\"Unexpected low surrogate character '\" + c1 + \"' with value \" + (int) c1 + \" at index \" + (index - 1) + \" in '\" + seq + \"'\");\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Index exceeds specified range\");\n}", "repo_id": "5", "comment": "/**\n * Returns the Unicode code point of the character at the given index.\n *\n * <p>Unlike {@link Character#codePointAt(CharSequence, int)} or {@link String#codePointAt(int)}\n * this method will never fail silently when encountering an invalid surrogate pair.\n *\n * <p>The behaviour of this method is as follows:\n *\n * <ol>\n *   <li>If {@code index >= end}, {@link IndexOutOfBoundsException} is thrown.\n *   <li><b>If the character at the specified index is not a surrogate, it is returned.</b>\n *   <li>If the first character was a high surrogate value, then an attempt is made to read the\n *       next character.\n *       <ol>\n *         <li><b>If the end of the sequence was reached, the negated value of the trailing high\n *             surrogate is returned.</b>\n *         <li><b>If the next character was a valid low surrogate, the code point value of the\n *             high/low surrogate pair is returned.</b>\n *         <li>If the next character was not a low surrogate value, then {@link\n *             IllegalArgumentException} is thrown.\n *       </ol>\n *   <li>If the first character was a low surrogate value, {@link IllegalArgumentException} is\n *       thrown.\n * </ol>\n *\n * @param seq the sequence of characters from which to decode the code point\n * @param index the index of the first character to decode\n * @param end the index beyond the last valid character to decode\n * @return the Unicode code point for the given index or the negated value of the trailing high\n *     surrogate character at the end of the sequence\n */\n", "repo_name": "guava-master/", "id": 4269, "method_signature": "int codePointAt(CharSequence, int, int)", "filename": "UnicodeEscaper.codePointAt.json"}
{"callee_method_names": ["String.length"], "method_name": "UnicodeEscaper.escape", "method_implementation": "{\n    checkNotNull(string);\n    int end = string.length();\n    int index = nextEscapeIndex(string, 0, end);\n    return index == end ? string : escapeSlow(string, index);\n}", "repo_id": "5", "comment": "/**\n * Returns the escaped form of a given literal string.\n *\n * <p>If you are escaping input in arbitrary successive chunks, then it is not generally safe to\n * use this method. If an input string ends with an unmatched high surrogate character, then this\n * method will throw {@link IllegalArgumentException}. You should ensure your input is valid <a\n * href=\"http://en.wikipedia.org/wiki/UTF-16\">UTF-16</a> before calling this method.\n *\n * <p><b>Note:</b> When implementing an escaper it is a good idea to override this method for\n * efficiency by inlining the implementation of {@link #nextEscapeIndex(CharSequence, int, int)}\n * directly. Doing this for {@link com.google.common.net.PercentEscaper} more than doubled the\n * performance for unescaped strings (as measured by {@code CharEscapersBenchmark}).\n *\n * @param string the literal string to be escaped\n * @return the escaped form of {@code string}\n * @throws NullPointerException if {@code string} is null\n * @throws IllegalArgumentException if invalid surrogate characters are encountered\n */\n", "repo_name": "guava-master/", "id": 4266, "method_signature": "String escape(String)", "filename": "UnicodeEscaper.escape.json"}
{"callee_method_names": ["String.length", "String.getChars", "String.getChars"], "method_name": "UnicodeEscaper.escapeSlow", "method_implementation": "{\n    int end = s.length();\n    // Get a destination buffer and setup some loop variables.\n    char[] dest = Platform.charBufferFromThreadLocal();\n    int destIndex = 0;\n    int unescapedChunkStart = 0;\n    while (index < end) {\n        int cp = codePointAt(s, index, end);\n        if (cp < 0) {\n            throw new IllegalArgumentException(\"Trailing high surrogate at end of input\");\n        }\n        // It is possible for this to return null because nextEscapeIndex() may\n        // (for performance reasons) yield some false positives but it must never\n        // give false negatives.\n        char[] escaped = escape(cp);\n        int nextIndex = index + (Character.isSupplementaryCodePoint(cp) ? 2 : 1);\n        if (escaped != null) {\n            int charsSkipped = index - unescapedChunkStart;\n            // This is the size needed to add the replacement, not the full\n            // size needed by the string. We only regrow when we absolutely must.\n            int sizeNeeded = destIndex + charsSkipped + escaped.length;\n            if (dest.length < sizeNeeded) {\n                int destLength = sizeNeeded + (end - index) + DEST_PAD;\n                dest = growBuffer(dest, destIndex, destLength);\n            }\n            // If we have skipped any characters, we need to copy them now.\n            if (charsSkipped > 0) {\n                s.getChars(unescapedChunkStart, index, dest, destIndex);\n                destIndex += charsSkipped;\n            }\n            if (escaped.length > 0) {\n                System.arraycopy(escaped, 0, dest, destIndex, escaped.length);\n                destIndex += escaped.length;\n            }\n            // If we dealt with an escaped character, reset the unescaped range.\n            unescapedChunkStart = nextIndex;\n        }\n        index = nextEscapeIndex(s, nextIndex, end);\n    }\n    // Process trailing unescaped characters - no need to account for escaped\n    // length or padding the allocation.\n    int charsSkipped = end - unescapedChunkStart;\n    if (charsSkipped > 0) {\n        int endIndex = destIndex + charsSkipped;\n        if (dest.length < endIndex) {\n            dest = growBuffer(dest, destIndex, endIndex);\n        }\n        s.getChars(unescapedChunkStart, end, dest, destIndex);\n        destIndex = endIndex;\n    }\n    return new String(dest, 0, destIndex);\n}", "repo_id": "5", "comment": "/**\n * Returns the escaped form of a given literal string, starting at the given index. This method is\n * called by the {@link #escape(String)} method when it discovers that escaping is required. It is\n * protected to allow subclasses to override the fastpath escaping function to inline their\n * escaping test. See {@link CharEscaperBuilder} for an example usage.\n *\n * <p>This method is not reentrant and may only be invoked by the top level {@link\n * #escape(String)} method.\n *\n * @param s the literal string to be escaped\n * @param index the index to start escaping from\n * @return the escaped form of {@code string}\n * @throws NullPointerException if {@code string} is null\n * @throws IllegalArgumentException if invalid surrogate characters are encountered\n */\n", "repo_name": "guava-master/", "id": 4268, "method_signature": "String escapeSlow(String, int)", "filename": "UnicodeEscaper.escapeSlow.json"}
{"callee_method_names": [], "method_name": "UnicodeEscaper.growBuffer", "method_implementation": "{\n    if (size < 0) {\n        // overflow - should be OutOfMemoryError but GWT/j2cl don't support it\n        throw new AssertionError(\"Cannot increase internal buffer any further\");\n    }\n    char[] copy = new char[size];\n    if (index > 0) {\n        System.arraycopy(dest, 0, copy, 0, index);\n    }\n    return copy;\n}", "repo_id": "5", "comment": "/**\n * Helper method to grow the character buffer as needed, this only happens once in a while so it's\n * ok if it's in a method call. If the index passed in is 0 then no copying will be done.\n */\n", "repo_name": "guava-master/", "id": 4270, "method_signature": "char[] growBuffer(char[], int, int)", "filename": "UnicodeEscaper.growBuffer.json"}
{"callee_method_names": [], "method_name": "UnicodeEscaper.nextEscapeIndex", "method_implementation": "{\n    int index = start;\n    while (index < end) {\n        int cp = codePointAt(csq, index, end);\n        if (cp < 0 || escape(cp) != null) {\n            break;\n        }\n        index += Character.isSupplementaryCodePoint(cp) ? 2 : 1;\n    }\n    return index;\n}", "repo_id": "5", "comment": "/**\n * Scans a sub-sequence of characters from a given {@link CharSequence}, returning the index of\n * the next character that requires escaping.\n *\n * <p><b>Note:</b> When implementing an escaper, it is a good idea to override this method for\n * efficiency. The base class implementation determines successive Unicode code points and invokes\n * {@link #escape(int)} for each of them. If the semantics of your escaper are such that code\n * points in the supplementary range are either all escaped or all unescaped, this method can be\n * implemented more efficiently using {@link CharSequence#charAt(int)}.\n *\n * <p>Note however that if your escaper does not escape characters in the supplementary range, you\n * should either continue to validate the correctness of any surrogate characters encountered or\n * provide a clear warning to users that your escaper does not validate its input.\n *\n * <p>See {@link com.google.common.net.PercentEscaper} for an example.\n *\n * @param csq a sequence of characters\n * @param start the index of the first character to be scanned\n * @param end the index immediately after the last character to be scanned\n * @throws IllegalArgumentException if the scanned sub-sequence of {@code csq} contains invalid\n *     surrogate pairs\n */\n", "repo_name": "guava-master/", "id": 4267, "method_signature": "int nextEscapeIndex(CharSequence, int, int)", "filename": "UnicodeEscaper.nextEscapeIndex.json"}
{"callee_method_names": ["CharSequence.charAt"], "method_name": "UnicodeEscaperTest.nextEscapeIndex", "method_implementation": "{\n    while (index < end && !Character.isLetter(csq.charAt(index))) {\n        index++;\n    }\n    return index;\n}", "repo_id": "5", "comment": "// Inefficient implementation that defines all letters as escapable.\n", "repo_name": "guava-master/", "id": 3546, "method_signature": "int nextEscapeIndex(CharSequence, int, int)", "filename": "UnicodeEscaperTest.nextEscapeIndex.json"}
{"callee_method_names": ["Thread.start", "Thread.interrupt", "FutureTask<Boolean>.get", "ExecutionException.getCause", "ExecutionException.getCause"], "method_name": "UninterruptibleFutureTest.testMakeUninterruptible_plainFutureSanityCheck", "method_implementation": "{\n    SettableFuture<String> future = SettableFuture.create();\n    FutureTask<Boolean> wasInterrupted = untimedInterruptReporter(future, true);\n    Thread waitingThread = new Thread(wasInterrupted);\n    waitingThread.start();\n    waitingThread.interrupt();\n    ExecutionException expected = assertThrows(ExecutionException.class, () -> wasInterrupted.get());\n    assertTrue(expected.getCause().toString(), expected.getCause() instanceof InterruptedException);\n}", "repo_id": "5", "comment": "/**\n * Confirms that the test code triggers {@link InterruptedException} in a standard {@link Future}.\n */\n", "repo_name": "guava-master/", "id": 3874, "method_signature": "void testMakeUninterruptible_plainFutureSanityCheck()", "filename": "UninterruptibleFutureTest.testMakeUninterruptible_plainFutureSanityCheck.json"}
{"callee_method_names": ["Future<Boolean>.get", "Future<Boolean>.get"], "method_name": "UninterruptibleFutureTest.testRegularFutureInterrupted", "method_implementation": "{\n    /*\n     * Here's the order of events that we want.\n     *\n     * 1. The client thread begins to block on a get() call to a future.\n     * 2. The client thread is interrupted sometime before the result would be\n     *   available.\n     * 3. We expect the client's get() to throw an InterruptedException.\n     * 4. We expect the client thread's interrupt state to be false.\n     * 5. The client thread again makes a blocking call to get().\n     * 6. Now the result becomes available.\n     * 7. We expect get() to return this result.\n     * 8. We expect the test thread's interrupt state to be false.\n     */\n    InterruptionUtil.requestInterruptIn(200, TimeUnit.MILLISECONDS);\n    assertFalse(Thread.interrupted());\n    try {\n        delayedFuture.get(20000, TimeUnit.MILLISECONDS);\n        fail(\"expected to be interrupted\");\n    } catch (InterruptedException expected) {\n    } catch (TimeoutException e) {\n        throw new RuntimeException(e);\n    }\n    // we were interrupted, but it's been cleared now\n    assertFalse(Thread.interrupted());\n    assertFalse(sleeper.completed);\n    try {\n        assertTrue(delayedFuture.get());\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n    assertTrue(sleeper.completed);\n}", "repo_id": "5", "comment": "/**\n * This first test doesn't test anything in Uninterruptibles, just demonstrates some normal\n * behavior of futures so that you can contrast the next test with it.\n */\n", "repo_name": "guava-master/", "id": 3873, "method_signature": "void testRegularFutureInterrupted()", "filename": "UninterruptibleFutureTest.testRegularFutureInterrupted.json"}
{"callee_method_names": ["TimeUnit.toNanos", "ExecutorService.awaitTermination"], "method_name": "Uninterruptibles.awaitTerminationUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(timeout);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                return executor.awaitTermination(remainingNanos, NANOSECONDS);\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)\n * awaitTermination(long, TimeUnit)} uninterruptibly.\n *\n * @since 30.0\n */\n", "repo_name": "guava-master/", "id": 5381, "method_signature": "boolean awaitTerminationUninterruptibly(ExecutorService, long, TimeUnit)", "filename": "Uninterruptibles.awaitTerminationUninterruptibly.json"}
{"callee_method_names": ["TimeUnit.toNanos", "Condition.await"], "method_name": "Uninterruptibles.awaitUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(timeout);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                return condition.await(remainingNanos, NANOSECONDS);\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}\n * uninterruptibly.\n *\n * @since 23.6\n */\n", "repo_name": "guava-master/", "id": 5369, "method_signature": "boolean awaitUninterruptibly(Condition, long, TimeUnit)", "filename": "Uninterruptibles.awaitUninterruptibly.json"}
{"callee_method_names": ["TimeUnit.toNanos", "Future<V>.get"], "method_name": "Uninterruptibles.getUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(timeout);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                // Future treats negative timeouts just like zero.\n                return future.get(remainingNanos, NANOSECONDS);\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code future.}{@link Future#get(long, TimeUnit) get(timeout, unit)} uninterruptibly.\n *\n * <p>Similar methods:\n *\n * <ul>\n *   <li>To retrieve a result from a {@code Future} that is already done, use {@link\n *       Futures#getDone Futures.getDone}.\n *   <li>To treat {@link InterruptedException} uniformly with other exceptions, use {@link\n *       Futures#getChecked(Future, Class, long, TimeUnit) Futures.getChecked}.\n *   <li>To get uninterruptibility and remove checked exceptions, use {@link\n *       Futures#getUnchecked}.\n * </ul>\n *\n * @throws ExecutionException if the computation threw an exception\n * @throws CancellationException if the computation was cancelled\n * @throws TimeoutException if the wait timed out\n */\n", "repo_name": "guava-master/", "id": 5373, "method_signature": "V getUninterruptibly(Future, long, TimeUnit)", "filename": "Uninterruptibles.getUninterruptibly.json"}
{"callee_method_names": ["TimeUnit.toNanos"], "method_name": "Uninterruptibles.joinUninterruptibly", "method_implementation": "{\n    Preconditions.checkNotNull(toJoin);\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(timeout);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                // TimeUnit.timedJoin() treats negative timeouts just like zero.\n                NANOSECONDS.timedJoin(toJoin, remainingNanos);\n                return;\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code unit.}{@link TimeUnit#timedJoin(Thread, long) timedJoin(toJoin, timeout)}\n * uninterruptibly.\n */\n", "repo_name": "guava-master/", "id": 5371, "method_signature": "void joinUninterruptibly(Thread, long, TimeUnit)", "filename": "Uninterruptibles.joinUninterruptibly.json"}
{"callee_method_names": ["BlockingQueue<E>.put"], "method_name": "Uninterruptibles.putUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        while (true) {\n            try {\n                queue.put(element);\n                return;\n            } catch (InterruptedException e) {\n                interrupted = true;\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code queue.}{@link BlockingQueue#put(Object) put(element)} uninterruptibly.\n *\n * @throws ClassCastException if the class of the specified element prevents it from being added\n *     to the given queue\n * @throws IllegalArgumentException if some property of the specified element prevents it from\n *     being added to the given queue\n */\n", "repo_name": "guava-master/", "id": 5375, "method_signature": "void putUninterruptibly(BlockingQueue, E)", "filename": "Uninterruptibles.putUninterruptibly.json"}
{"callee_method_names": ["TimeUnit.toNanos"], "method_name": "Uninterruptibles.sleepUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(sleepFor);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                // TimeUnit.sleep() treats negative timeouts just like zero.\n                NANOSECONDS.sleep(remainingNanos);\n                return;\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)} uninterruptibly.\n */\n", "repo_name": "guava-master/", "id": 5376, "method_signature": "void sleepUninterruptibly(long, TimeUnit)", "filename": "Uninterruptibles.sleepUninterruptibly.json"}
{"callee_method_names": ["BlockingQueue<E>.take"], "method_name": "Uninterruptibles.takeUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        while (true) {\n            try {\n                return queue.take();\n            } catch (InterruptedException e) {\n                interrupted = true;\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code queue.}{@link BlockingQueue#take() take()} uninterruptibly.\n */\n", "repo_name": "guava-master/", "id": 5374, "method_signature": "E takeUninterruptibly(BlockingQueue)", "filename": "Uninterruptibles.takeUninterruptibly.json"}
{"callee_method_names": ["TimeUnit.toNanos", "Semaphore.tryAcquire"], "method_name": "Uninterruptibles.tryAcquireUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(timeout);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                // Semaphore treats negative timeouts just like zero.\n                return semaphore.tryAcquire(permits, remainingNanos, NANOSECONDS);\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code semaphore.}{@link Semaphore#tryAcquire(int, long, TimeUnit) tryAcquire(permits,\n * timeout, unit)} uninterruptibly.\n *\n * @since 18.0\n */\n", "repo_name": "guava-master/", "id": 5378, "method_signature": "boolean tryAcquireUninterruptibly(Semaphore, int, long, TimeUnit)", "filename": "Uninterruptibles.tryAcquireUninterruptibly.json"}
{"callee_method_names": ["TimeUnit.toNanos", "Lock.tryLock"], "method_name": "Uninterruptibles.tryLockUninterruptibly", "method_implementation": "{\n    boolean interrupted = false;\n    try {\n        long remainingNanos = unit.toNanos(timeout);\n        long end = System.nanoTime() + remainingNanos;\n        while (true) {\n            try {\n                return lock.tryLock(remainingNanos, NANOSECONDS);\n            } catch (InterruptedException e) {\n                interrupted = true;\n                remainingNanos = end - System.nanoTime();\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Invokes {@code lock.}{@link Lock#tryLock(long, TimeUnit) tryLock(timeout, unit)}\n * uninterruptibly.\n *\n * @since 30.0\n */\n", "repo_name": "guava-master/", "id": 5379, "method_signature": "boolean tryLockUninterruptibly(Lock, long, TimeUnit)", "filename": "Uninterruptibles.tryLockUninterruptibly.json"}
{"callee_method_names": [], "method_name": "UninterruptiblesTest.assertCompletionNotExpected", "method_implementation": "{\n    Preconditions.checkArgument(timeout < expectedCompletionWaitMillis);\n    assertAtLeastTimePassed(stopwatch, timeout);\n    assertTimeNotPassed(stopwatch, expectedCompletionWaitMillis);\n}", "repo_id": "5", "comment": "/**\n * Asserts that at least {@code timeout} has passed but the expected completion time has not.\n */\n", "repo_name": "guava-master/", "id": 3930, "method_signature": "void assertCompletionNotExpected(long)", "filename": "UninterruptiblesTest.assertCompletionNotExpected.json"}
{"callee_method_names": [], "method_name": "UninterruptiblesTest.assertInterrupted", "method_implementation": "{\n    try {\n        /*\n       * The sleep() will end immediately if we've already been interrupted or\n       * wait patiently for the interrupt if not.\n       */\n        Thread.sleep(LONG_DELAY_MS);\n        fail(\"Dude, where's my interrupt?\");\n    } catch (InterruptedException expected) {\n    }\n}", "repo_id": "5", "comment": "/**\n * Await an interrupt, then clear the interrupt status. Similar to {@code\n * assertTrue(Thread.interrupted())} except that this version tolerates late interrupts.\n */\n", "repo_name": "guava-master/", "id": 3933, "method_signature": "void assertInterrupted()", "filename": "UninterruptiblesTest.assertInterrupted.json"}
{"callee_method_names": ["Completion.assertCompletionExpected", "BlockingQueue<String>.peek"], "method_name": "UninterruptiblesTest.putSuccessfully", "method_implementation": "{\n    putUninterruptibly(queue, \"\");\n    completed.assertCompletionExpected();\n    assertEquals(\"\", queue.peek());\n}", "repo_id": "5", "comment": "/**\n * Perform a {@code put} and assert that operation completed in the expected timeframe.\n */\n", "repo_name": "guava-master/", "id": 3931, "method_signature": "void putSuccessfully()", "filename": "UninterruptiblesTest.putSuccessfully.json"}
{"callee_method_names": ["TearDownStack.addTearDown"], "method_name": "UninterruptiblesTest.setUp", "method_implementation": "{\n    // Clear any previous interrupt before running the test.\n    if (Thread.currentThread().isInterrupted()) {\n        throw new AssertionError(\"Thread interrupted on test entry. \" + \"Some test probably didn't clear the interrupt state\");\n    }\n    tearDownStack.addTearDown(new TearDown() {\n\n        @Override\n        public void tearDown() {\n            Thread.interrupted();\n        }\n    });\n}", "repo_id": "5", "comment": "// NOTE: All durations in these tests are expressed in milliseconds\n", "repo_name": "guava-master/", "id": 3922, "method_signature": "void setUp()", "filename": "UninterruptiblesTest.setUp.json"}
{"callee_method_names": ["Completion.assertCompletionExpected", "BlockingQueue<String>.isEmpty"], "method_name": "UninterruptiblesTest.takeSuccessfully", "method_implementation": "{\n    assertEquals(EXPECTED_TAKE, takeUninterruptibly(queue));\n    completed.assertCompletionExpected();\n    assertTrue(queue.isEmpty());\n}", "repo_id": "5", "comment": "/**\n * Perform a {@code take} and assert that operation completed in the expected timeframe.\n */\n", "repo_name": "guava-master/", "id": 3932, "method_signature": "void takeSuccessfully()", "filename": "UninterruptiblesTest.takeSuccessfully.json"}
{"callee_method_names": [], "method_name": "UninterruptiblesTest.testConditionAwaitTimeoutExceeded", "method_implementation": "{\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    Condition condition = TestCondition.create();\n    boolean signaledBeforeTimeout = awaitUninterruptibly(condition, 500, MILLISECONDS);\n    assertFalse(signaledBeforeTimeout);\n    assertAtLeastTimePassed(stopwatch, 500);\n    assertNotInterrupted();\n}", "repo_id": "5", "comment": "// Condition.await() tests\n", "repo_name": "guava-master/", "id": 3923, "method_signature": "void testConditionAwaitTimeoutExceeded()", "filename": "UninterruptiblesTest.testConditionAwaitTimeoutExceeded.json"}
{"callee_method_names": ["Thread.start", "Thread.join", "Thread.isAlive"], "method_name": "UninterruptiblesTest.testJoinWithNoWait", "method_implementation": "{\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    Thread thread = new Thread(new JoinTarget(15));\n    thread.start();\n    thread.join();\n    assertFalse(thread.isAlive());\n    joinUninterruptibly(thread);\n    joinUninterruptibly(thread, 0, MILLISECONDS);\n    joinUninterruptibly(thread, -42, MILLISECONDS);\n    joinUninterruptibly(thread, LONG_DELAY_MS, MILLISECONDS);\n    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);\n}", "repo_id": "5", "comment": "// join() tests\n", "repo_name": "guava-master/", "id": 3927, "method_signature": "void testJoinWithNoWait()", "filename": "UninterruptiblesTest.testJoinWithNoWait.json"}
{"callee_method_names": ["BlockingQueue<String>.peek"], "method_name": "UninterruptiblesTest.testPutWithNoWait", "method_implementation": "{\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    BlockingQueue<String> queue = new ArrayBlockingQueue<>(999);\n    putUninterruptibly(queue, \"\");\n    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);\n    assertEquals(\"\", queue.peek());\n}", "repo_id": "5", "comment": "// BlockingQueue.put() tests\n", "repo_name": "guava-master/", "id": 3925, "method_signature": "void testPutWithNoWait()", "filename": "UninterruptiblesTest.testPutWithNoWait.json"}
{"callee_method_names": ["BlockingQueue<String>.offer"], "method_name": "UninterruptiblesTest.testTakeWithNoWait", "method_implementation": "{\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    BlockingQueue<String> queue = new ArrayBlockingQueue<>(1);\n    assertTrue(queue.offer(\"\"));\n    assertEquals(\"\", takeUninterruptibly(queue));\n    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);\n}", "repo_id": "5", "comment": "// BlockingQueue.take() tests\n", "repo_name": "guava-master/", "id": 3926, "method_signature": "void testTakeWithNoWait()", "filename": "UninterruptiblesTest.testTakeWithNoWait.json"}
{"callee_method_names": [], "method_name": "UninterruptiblesTest.testTryAcquireWithNoWait", "method_implementation": "{\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    Semaphore semaphore = new Semaphore(99);\n    assertTrue(tryAcquireUninterruptibly(semaphore, 0, MILLISECONDS));\n    assertTrue(tryAcquireUninterruptibly(semaphore, -42, MILLISECONDS));\n    assertTrue(tryAcquireUninterruptibly(semaphore, LONG_DELAY_MS, MILLISECONDS));\n    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);\n}", "repo_id": "5", "comment": "// Semaphore.tryAcquire() tests\n", "repo_name": "guava-master/", "id": 3928, "method_signature": "void testTryAcquireWithNoWait()", "filename": "UninterruptiblesTest.testTryAcquireWithNoWait.json"}
{"callee_method_names": ["ExecutorService.execute", "ExecutorService.shutdown", "ExecutorService.isTerminated"], "method_name": "UninterruptiblesTest.testTryAwaitTerminationUninterruptiblyDuration_success", "method_implementation": "{\n    ExecutorService executor = newFixedThreadPool(1);\n    requestInterruptIn(500);\n    executor.execute(new SleepTask(1000));\n    executor.shutdown();\n    assertTrue(awaitTerminationUninterruptibly(executor, Duration.ofMillis(LONG_DELAY_MS)));\n    assertTrue(executor.isTerminated());\n    assertInterrupted();\n}", "repo_id": "5", "comment": "// executor.awaitTermination Testcases\n", "repo_name": "guava-master/", "id": 474, "method_signature": "void testTryAwaitTerminationUninterruptiblyDuration_success()", "filename": "UninterruptiblesTest.testTryAwaitTerminationUninterruptiblyDuration_success.json"}
{"callee_method_names": ["ExecutorService.execute", "ExecutorService.shutdown", "ExecutorService.isTerminated"], "method_name": "UninterruptiblesTest.testTryAwaitTerminationUninterruptiblyLongTimeUnit_success", "method_implementation": "{\n    ExecutorService executor = newFixedThreadPool(1);\n    requestInterruptIn(500);\n    executor.execute(new SleepTask(1000));\n    executor.shutdown();\n    assertTrue(awaitTerminationUninterruptibly(executor, LONG_DELAY_MS, MILLISECONDS));\n    assertTrue(executor.isTerminated());\n    assertInterrupted();\n}", "repo_id": "5", "comment": "// executor.awaitTermination Testcases\n", "repo_name": "guava-master/", "id": 3929, "method_signature": "void testTryAwaitTerminationUninterruptiblyLongTimeUnit_success()", "filename": "UninterruptiblesTest.testTryAwaitTerminationUninterruptiblyLongTimeUnit_success.json"}
{"callee_method_names": ["Thread.interrupt"], "method_name": "UninterruptiblesTest.testTryLockTimeoutExceeded", "method_implementation": "{\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    Lock lock = new ReentrantLock();\n    Thread lockThread = acquireFor(lock, 5, SECONDS);\n    boolean lockAcquired = tryLockUninterruptibly(lock, 500, MILLISECONDS);\n    assertFalse(lockAcquired);\n    assertAtLeastTimePassed(stopwatch, 500);\n    assertNotInterrupted();\n    // finish locking thread\n    lockThread.interrupt();\n}", "repo_id": "5", "comment": "// Lock.tryLock() tests\n", "repo_name": "guava-master/", "id": 3924, "method_signature": "void testTryLockTimeoutExceeded()", "filename": "UninterruptiblesTest.testTryLockTimeoutExceeded.json"}
{"callee_method_names": [], "method_name": "UnmodifiableBiMap.computeIfPresent", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/*\n     * TODO(cpovirk): Uncomment the @NonNull annotations below once our JDK stubs and J2KT\n     * emulations include them.\n     */\n", "repo_name": "guava-master/", "id": 3257, "method_signature": "V computeIfPresent(K, BiFunction)", "filename": "UnmodifiableBiMap.computeIfPresent.json"}
{"callee_method_names": ["Collection<E>.add", "Collection<E>.iterator", "Collection<E>.add", "Collection<E>.addAll", "Collection<E>.clear", "Collection<E>.iterator", "Collection<E>.remove", "Collection<E>.removeAll", "Collection<E>.retainAll"], "method_name": "UnmodifiableCollectionTests.assertCollectionIsUnmodifiable", "method_implementation": "{\n    Collection<E> siblingCollection = new ArrayList<>();\n    siblingCollection.add(sampleElement);\n    Collection<E> copy = new ArrayList<>();\n    // Avoid copy.addAll(collection), which runs afoul of an Android bug in older versions:\n    // http://b.android.com/72073 http://r.android.com/98929\n    Iterators.addAll(copy, collection.iterator());\n    try {\n        collection.add(sampleElement);\n        fail(\"add succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(copy, collection);\n    try {\n        collection.addAll(siblingCollection);\n        fail(\"addAll succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(copy, collection);\n    try {\n        collection.clear();\n        fail(\"clear succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(copy, collection);\n    assertIteratorIsUnmodifiable(collection.iterator());\n    assertCollectionsAreEquivalent(copy, collection);\n    try {\n        collection.remove(sampleElement);\n        fail(\"remove succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(copy, collection);\n    try {\n        collection.removeAll(siblingCollection);\n        fail(\"removeAll succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(copy, collection);\n    try {\n        collection.retainAll(siblingCollection);\n        fail(\"retainAll succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(copy, collection);\n}", "repo_id": "5", "comment": "/**\n * Verifies that a collection is immutable.\n *\n * <p>A collection is considered immutable if:\n *\n * <ol>\n *   <li>All its mutation methods result in UnsupportedOperationException, and do not change the\n *       underlying contents.\n *   <li>All methods that return objects that can indirectly mutate the collection throw\n *       UnsupportedOperationException when those mutators are called.\n * </ol>\n *\n * @param collection the presumed-immutable collection\n * @param sampleElement an element of the same type as that contained by {@code collection}.\n *     {@code collection} may or may not have {@code sampleElement} as a member.\n */\n", "repo_name": "guava-master/", "id": 4165, "method_signature": "void assertCollectionIsUnmodifiable(Collection, E)", "filename": "UnmodifiableCollectionTests.assertCollectionIsUnmodifiable.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.remove"], "method_name": "UnmodifiableCollectionTests.assertIteratorIsUnmodifiable", "method_implementation": "{\n    while (iterator.hasNext()) {\n        iterator.next();\n        try {\n            iterator.remove();\n            fail(\"Remove on unmodifiable iterator succeeded\");\n        } catch (UnsupportedOperationException expected) {\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Verifies that an Iterator is unmodifiable.\n *\n * <p>This test only works with iterators that iterate over a finite set.\n */\n", "repo_name": "guava-master/", "id": 4163, "method_signature": "void assertIteratorIsUnmodifiable(Iterator)", "filename": "UnmodifiableCollectionTests.assertIteratorIsUnmodifiable.json"}
{"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.hasNext", "Iterator<?>.next", "Iterator<?>.hasNext", "Iterator<?>.next"], "method_name": "UnmodifiableCollectionTests.assertIteratorsInOrder", "method_implementation": "{\n    int i = 0;\n    while (expectedIterator.hasNext()) {\n        Object expected = expectedIterator.next();\n        assertTrue(\"index \" + i + \" expected <\" + expected + \"., actual is exhausted\", actualIterator.hasNext());\n        Object actual = actualIterator.next();\n        assertEquals(\"index \" + i, expected, actual);\n        i++;\n    }\n    if (actualIterator.hasNext()) {\n        fail(\"index \" + i + \", expected is exhausted, actual <\" + actualIterator.next() + \">\");\n    }\n}", "repo_id": "5", "comment": "/**\n * Asserts that two iterators contain elements in tandem.\n *\n * <p>This test only works with iterators that iterate over a finite set.\n */\n", "repo_name": "guava-master/", "id": 4164, "method_signature": "void assertIteratorsInOrder(Iterator, Iterator)", "filename": "UnmodifiableCollectionTests.assertIteratorsInOrder.json"}
{"callee_method_names": ["Multimap<K,V>.entries", "Multimap<K,V>.clear", "Multimap<K,V>.asMap", "Multimap<K,V>.isEmpty", "Multimap<K,V>.asMap", "Multimap<K,V>.entries", "Multimap<K,V>.entries", "Multimap<K,V>.keys", "Multimap<K,V>.keySet", "Multimap<K,V>.isEmpty", "Multimap<K,V>.keySet", "Multimap<K,V>.get", "Multimap<K,V>.put", "Multimap<K,V>.putAll", "Multimap<K, V>.put", "Multimap<K,V>.putAll", "Multimap<K,V>.remove", "Multimap<K,V>.removeAll", "Multimap<K,V>.replaceValues", "Multimap<K,V>.asMap", "Multimap<K,V>.isEmpty", "Multimap<K,V>.keySet", "Multimap<K,V>.asMap", "Multimap<K,V>.asMap", "Multimap<K,V>.asMap", "Multimap<K,V>.values"], "method_name": "UnmodifiableCollectionTests.assertMultimapIsUnmodifiable", "method_implementation": "{\n    List<Entry<K, V>> originalEntries = Collections.unmodifiableList(Lists.newArrayList(multimap.entries()));\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    Collection<V> sampleValueAsCollection = Collections.singleton(sampleValue);\n    // Test #clear()\n    try {\n        multimap.clear();\n        fail(\"clear succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test asMap().entrySet()\n    assertSetIsUnmodifiable(multimap.asMap().entrySet(), Maps.immutableEntry(sampleKey, sampleValueAsCollection));\n    // Test #values()\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    if (!multimap.isEmpty()) {\n        Collection<V> values = multimap.asMap().entrySet().iterator().next().getValue();\n        assertCollectionIsUnmodifiable(values, sampleValue);\n    }\n    // Test #entries()\n    assertCollectionIsUnmodifiable(multimap.entries(), Maps.immutableEntry(sampleKey, sampleValue));\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Iterate over every element in the entry set\n    for (Entry<K, V> entry : multimap.entries()) {\n        assertMapEntryIsUnmodifiable(entry);\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #keys()\n    assertMultisetIsUnmodifiable(multimap.keys(), sampleKey);\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #keySet()\n    assertSetIsUnmodifiable(multimap.keySet(), sampleKey);\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #get()\n    if (!multimap.isEmpty()) {\n        K key = multimap.keySet().iterator().next();\n        assertCollectionIsUnmodifiable(multimap.get(key), sampleValue);\n        assertMultimapRemainsUnmodified(multimap, originalEntries);\n    }\n    // Test #put()\n    try {\n        multimap.put(sampleKey, sampleValue);\n        fail(\"put succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #putAll(K, Collection<V>)\n    try {\n        multimap.putAll(sampleKey, sampleValueAsCollection);\n        fail(\"putAll(K, Iterable) succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #putAll(Multimap<K, V>)\n    Multimap<K, V> multimap2 = ArrayListMultimap.create();\n    multimap2.put(sampleKey, sampleValue);\n    try {\n        multimap.putAll(multimap2);\n        fail(\"putAll(Multimap<K, V>) succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #remove()\n    try {\n        multimap.remove(sampleKey, sampleValue);\n        fail(\"remove succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #removeAll()\n    try {\n        multimap.removeAll(sampleKey);\n        fail(\"removeAll succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #replaceValues()\n    try {\n        multimap.replaceValues(sampleKey, sampleValueAsCollection);\n        fail(\"replaceValues succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    // Test #asMap()\n    try {\n        multimap.asMap().remove(sampleKey);\n        fail(\"asMap().remove() succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n    if (!multimap.isEmpty()) {\n        K presentKey = multimap.keySet().iterator().next();\n        try {\n            multimap.asMap().get(presentKey).remove(sampleValue);\n            fail(\"asMap().get().remove() succeeded on unmodifiable multimap\");\n        } catch (UnsupportedOperationException expected) {\n        }\n        assertMultimapRemainsUnmodified(multimap, originalEntries);\n        try {\n            multimap.asMap().values().iterator().next().remove(sampleValue);\n            fail(\"asMap().values().iterator().next().remove() succeeded on unmodifiable multimap\");\n        } catch (UnsupportedOperationException expected) {\n        }\n        try {\n            ((Collection<?>) multimap.asMap().values().toArray()[0]).clear();\n            fail(\"asMap().values().toArray()[0].clear() succeeded on unmodifiable multimap\");\n        } catch (UnsupportedOperationException expected) {\n        }\n    }\n    assertCollectionIsUnmodifiable(multimap.values(), sampleValue);\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n}", "repo_id": "5", "comment": "/**\n * Verifies that a multimap is immutable.\n *\n * <p>A multimap is considered immutable if:\n *\n * <ol>\n *   <li>All its mutation methods result in UnsupportedOperationException, and do not change the\n *       underlying contents.\n *   <li>All methods that return objects that can indirectly mutate the multimap throw\n *       UnsupportedOperationException when those mutators\n * </ol>\n *\n * @param multimap the presumed-immutable multimap\n * @param sampleKey a key of the same type as that contained by {@code multimap}. {@code multimap}\n *     may or may not have {@code sampleKey} as a key.\n * @param sampleValue a key of the same type as that contained by {@code multimap}. {@code\n *     multimap} may or may not have {@code sampleValue} as a key.\n */\n", "repo_name": "guava-master/", "id": 4167, "method_signature": "void assertMultimapIsUnmodifiable(Multimap, K, V)", "filename": "UnmodifiableCollectionTests.assertMultimapIsUnmodifiable.json"}
{"callee_method_names": ["Multiset<E>.add", "Multiset<E>.remove", "Multiset<E>.elementSet", "Multiset<E>.entrySet"], "method_name": "UnmodifiableCollectionTests.assertMultisetIsUnmodifiable", "method_implementation": "{\n    Multiset<E> copy = LinkedHashMultiset.create(multiset);\n    assertCollectionsAreEquivalent(multiset, copy);\n    // Multiset is a collection, so we can use all those tests.\n    assertCollectionIsUnmodifiable(multiset, sampleElement);\n    assertCollectionsAreEquivalent(multiset, copy);\n    try {\n        multiset.add(sampleElement, 2);\n        fail(\"add(Object, int) succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(multiset, copy);\n    try {\n        multiset.remove(sampleElement, 2);\n        fail(\"remove(Object, int) succeeded on unmodifiable collection\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertCollectionsAreEquivalent(multiset, copy);\n    assertCollectionsAreEquivalent(multiset, copy);\n    assertSetIsUnmodifiable(multiset.elementSet(), sampleElement);\n    assertCollectionsAreEquivalent(multiset, copy);\n    assertSetIsUnmodifiable(multiset.entrySet(), new Multiset.Entry<E>() {\n\n        @Override\n        public int getCount() {\n            return 1;\n        }\n\n        @Override\n        public E getElement() {\n            return sampleElement;\n        }\n    });\n    assertCollectionsAreEquivalent(multiset, copy);\n}", "repo_id": "5", "comment": "/**\n * Verifies that a multiset is immutable.\n *\n * <p>A multiset is considered immutable if:\n *\n * <ol>\n *   <li>All its mutation methods result in UnsupportedOperationException, and do not change the\n *       underlying contents.\n *   <li>All methods that return objects that can indirectly mutate the multiset throw\n *       UnsupportedOperationException when those mutators are called.\n * </ol>\n *\n * @param multiset the presumed-immutable multiset\n * @param sampleElement an element of the same type as that contained by {@code multiset}. {@code\n *     multiset} may or may not have {@code sampleElement} as a member.\n */\n", "repo_name": "guava-master/", "id": 4166, "method_signature": "void assertMultisetIsUnmodifiable(Multiset, E)", "filename": "UnmodifiableCollectionTests.assertMultisetIsUnmodifiable.json"}
{"callee_method_names": [], "method_name": "UnmodifiableIterator.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the underlying data unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 5836, "method_signature": "void remove()", "filename": "UnmodifiableIterator.remove.json"}
{"callee_method_names": [], "method_name": "UnmodifiableListIterator.add", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the underlying data unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6500, "method_signature": "void add(E)", "filename": "UnmodifiableListIterator.add.json"}
{"callee_method_names": [], "method_name": "UnmodifiableListIterator.set", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/**\n * Guaranteed to throw an exception and leave the underlying data unmodified.\n *\n * @throws UnsupportedOperationException always\n * @deprecated Unsupported operation.\n */\n", "repo_name": "guava-master/", "id": 6501, "method_signature": "void set(E)", "filename": "UnmodifiableListIterator.set.json"}
{"callee_method_names": [], "method_name": "UnmodifiableNavigableMap.computeIfPresent", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "5", "comment": "/*\n     * TODO(cpovirk): Uncomment the @NonNull annotations below once our JDK stubs and J2KT\n     * emulations include them.\n     */\n", "repo_name": "guava-master/", "id": 3261, "method_signature": "V computeIfPresent(K, BiFunction)", "filename": "UnmodifiableNavigableMap.computeIfPresent.json"}
{"callee_method_names": ["sun.misc.Unsafe.compareAndSwapObject"], "method_name": "UnsafeAtomicHelper.casWaiters", "method_implementation": "{\n    return UNSAFE.compareAndSwapObject(future, WAITERS_OFFSET, expect, update);\n}", "repo_id": "5", "comment": "/**\n * Performs a CAS operation on the {@link #waiters} field.\n */\n", "repo_name": "guava-master/", "id": 5311, "method_signature": "boolean casWaiters(AbstractFuture, Waiter, Waiter)", "filename": "UnsafeAtomicHelper.casWaiters.json"}
{"callee_method_names": [], "method_name": "UnsafeAtomicHelper.gasListeners", "method_implementation": "{\n    while (true) {\n        Listener listener = future.listeners;\n        if (update == listener) {\n            return listener;\n        }\n        if (casListeners(future, listener, update)) {\n            return listener;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs a GAS operation on the {@link #listeners} field.\n */\n", "repo_name": "guava-master/", "id": 5312, "method_signature": "Listener gasListeners(AbstractFuture, Listener)", "filename": "UnsafeAtomicHelper.gasListeners.json"}
{"callee_method_names": [], "method_name": "UnsafeAtomicHelper.gasWaiters", "method_implementation": "{\n    while (true) {\n        Waiter waiter = future.waiters;\n        if (update == waiter) {\n            return waiter;\n        }\n        if (casWaiters(future, waiter, update)) {\n            return waiter;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * Performs a GAS operation on the {@link #waiters} field.\n */\n", "repo_name": "guava-master/", "id": 5313, "method_signature": "Waiter gasWaiters(AbstractFuture, Waiter)", "filename": "UnsafeAtomicHelper.gasWaiters.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.checkedCast", "method_implementation": "{\n    checkArgument(value >> Byte.SIZE == 0, \"out of range: %s\", value);\n    return (byte) value;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code byte} value that, when treated as unsigned, is equal to {@code value}, if\n * possible.\n *\n * @param value a value between 0 and 255 inclusive\n * @return the {@code byte} value that, when treated as unsigned, equals {@code value}\n * @throws IllegalArgumentException if {@code value} is negative or greater than 255\n */\n", "repo_name": "guava-master/", "id": 4307, "method_signature": "byte checkedCast(long)", "filename": "UnsignedBytes.checkedCast.json"}
{"callee_method_names": ["Class<?>.getEnumConstants"], "method_name": "UnsignedBytes.getBestComparator", "method_implementation": "{\n    try {\n        Class<?> theClass = Class.forName(UNSAFE_COMPARATOR_NAME);\n        // requireNonNull is safe because the class is an enum.\n        Object[] constants = requireNonNull(theClass.getEnumConstants());\n        // yes, UnsafeComparator does implement Comparator<byte[]>\n        @SuppressWarnings(\"unchecked\")\n        Comparator<byte[]> comparator = (Comparator<byte[]>) constants[0];\n        return comparator;\n    } catch (Throwable t) {\n        // ensure we really catch *everything*\n        return lexicographicalComparatorJavaImpl();\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the Unsafe-using Comparator, or falls back to the pure-Java implementation if unable\n * to do so.\n */\n", "repo_name": "guava-master/", "id": 4315, "method_signature": "Comparator<byte[]> getBestComparator()", "filename": "UnsignedBytes.getBestComparator.json"}
{"callee_method_names": ["Class<sun.misc.Unsafe>.getDeclaredFields", "Class<sun.misc.Unsafe>.isInstance", "Class<sun.misc.Unsafe>.cast", "Entry<K, V>.getCause"], "method_name": "UnsignedBytes.getUnsafe", "method_implementation": "{\n    try {\n        return sun.misc.Unsafe.getUnsafe();\n    } catch (SecurityException e) {\n        // that's okay; try reflection instead\n    }\n    try {\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n\n            @Override\n            public sun.misc.Unsafe run() throws Exception {\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n                    f.setAccessible(true);\n                    Object x = f.get(null);\n                    if (k.isInstance(x)) {\n                        return k.cast(x);\n                    }\n                }\n                throw new NoSuchFieldError(\"the Unsafe\");\n            }\n        });\n    } catch (java.security.PrivilegedActionException e) {\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple\n * call to Unsafe.getUnsafe when integrating into a jdk.\n *\n * @return a sun.misc.Unsafe\n */\n", "repo_name": "guava-master/", "id": 4314, "method_signature": "sun.misc.Unsafe getUnsafe()", "filename": "UnsignedBytes.getUnsafe.json"}
{"callee_method_names": ["String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "UnsignedBytes.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * (3 + separator.length()));\n    builder.append(toInt(array[0]));\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(toString(array[i]));\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied {@code byte} values separated by {@code separator}.\n * For example, {@code join(\":\", (byte) 1, (byte) 2, (byte) 255)} returns the string {@code\n * \"1:2:255\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of {@code byte} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4313, "method_signature": "String join(String, byte[])", "filename": "UnsignedBytes.join.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    int max = toInt(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        int next = toInt(array[i]);\n        if (next > max) {\n            max = next;\n        }\n    }\n    return (byte) max;\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}, treating values as unsigned.\n *\n * @param array a <i>nonempty</i> array of {@code byte} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array according to {@link #compare}\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4310, "method_signature": "byte max(byte[])", "filename": "UnsignedBytes.max.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    int min = toInt(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        int next = toInt(array[i]);\n        if (next < min) {\n            min = next;\n        }\n    }\n    return (byte) min;\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}, treating values as unsigned.\n *\n * @param array a <i>nonempty</i> array of {@code byte} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array according to {@link #compare}\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4309, "method_signature": "byte min(byte[])", "filename": "UnsignedBytes.min.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.parseUnsignedByte", "method_implementation": "{\n    int parse = Integer.parseInt(checkNotNull(string), radix);\n    // We need to throw a NumberFormatException, so we have to duplicate checkedCast. =(\n    if (parse >> Byte.SIZE == 0) {\n        return (byte) parse;\n    } else {\n        throw new NumberFormatException(\"out of range: \" + parse);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the unsigned {@code byte} value represented by a string with the given radix.\n *\n * @param string the string containing the unsigned {@code byte} representation to be parsed.\n * @param radix the radix to use while parsing {@code string}\n * @throws NumberFormatException if the string does not contain a valid unsigned {@code byte} with\n *     the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX} and {@link\n *     Character#MAX_RADIX}.\n * @throws NullPointerException if {@code string} is null (in contrast to {@link\n *     Byte#parseByte(String)})\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 4312, "method_signature": "byte parseUnsignedByte(String, int)", "filename": "UnsignedBytes.parseUnsignedByte.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.saturatedCast", "method_implementation": "{\n    if (value > toInt(MAX_VALUE)) {\n        // -1\n        return MAX_VALUE;\n    }\n    if (value < 0) {\n        return (byte) 0;\n    }\n    return (byte) value;\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code byte} value that, when treated as unsigned, is nearest in value to {@code\n * value}.\n *\n * @param value any {@code long} value\n * @return {@code (byte) 255} if {@code value >= 255}, {@code (byte) 0} if {@code value <= 0}, and\n *     {@code value} cast to {@code byte} otherwise\n */\n", "repo_name": "guava-master/", "id": 4308, "method_signature": "byte saturatedCast(long)", "filename": "UnsignedBytes.saturatedCast.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.sort", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] = flip(array[i]);\n    }\n    Arrays.sort(array, fromIndex, toIndex);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] = flip(array[i]);\n    }\n}", "repo_id": "5", "comment": "/**\n * Sorts the array between {@code fromIndex} inclusive and {@code toIndex} exclusive, treating its\n * elements as unsigned bytes.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4316, "method_signature": "void sort(byte[], int, int)", "filename": "UnsignedBytes.sort.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] ^= Byte.MAX_VALUE;\n    }\n    Arrays.sort(array, fromIndex, toIndex);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] ^= Byte.MAX_VALUE;\n    }\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order, interpreting them as unsigned 8-bit integers.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4317, "method_signature": "void sortDescending(byte[], int, int)", "filename": "UnsignedBytes.sortDescending.json"}
{"callee_method_names": [], "method_name": "UnsignedBytes.toString", "method_implementation": "{\n    checkArgument(radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX, \"radix (%s) must be between Character.MIN_RADIX and Character.MAX_RADIX\", radix);\n    // Benchmarks indicate this is probably not worth optimizing.\n    return Integer.toString(toInt(x), radix);\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of {@code x} for the given radix, where {@code x} is treated as\n * unsigned.\n *\n * @param x the value to convert to a string.\n * @param radix the radix to use while working with {@code x}\n * @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}\n *     and {@link Character#MAX_RADIX}.\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 4311, "method_signature": "String toString(byte, int)", "filename": "UnsignedBytes.toString.json"}
{"callee_method_names": [], "method_name": "UnsignedInteger.compareTo", "method_implementation": "{\n    checkNotNull(other);\n    return compare(value, other.value);\n}", "repo_id": "5", "comment": "/**\n * Compares this unsigned integer to another unsigned integer. Returns {@code 0} if they are\n * equal, a negative number if {@code this < other}, and a positive number if {@code this >\n * other}.\n */\n", "repo_name": "guava-master/", "id": 4454, "method_signature": "int compareTo(UnsignedInteger)", "filename": "UnsignedInteger.compareTo.json"}
{"callee_method_names": [], "method_name": "UnsignedInteger.times", "method_implementation": "{\n    // TODO(lowasser): make this GWT-compatible\n    return fromIntBits(value * checkNotNull(val).value);\n}", "repo_id": "5", "comment": "/**\n * Returns the result of multiplying this and {@code val}. If the result would have more than 32\n * bits, returns the low 32 bits of the result.\n *\n * @since 14.0\n */\n", "repo_name": "guava-master/", "id": 4453, "method_signature": "UnsignedInteger times(UnsignedInteger)", "filename": "UnsignedInteger.times.json"}
{"callee_method_names": ["BigInteger.signum", "BigInteger.bitLength", "BigInteger.intValue"], "method_name": "UnsignedInteger.valueOf", "method_implementation": "{\n    checkNotNull(value);\n    checkArgument(value.signum() >= 0 && value.bitLength() <= Integer.SIZE, \"value (%s) is outside the range for an unsigned integer value\", value);\n    return fromIntBits(value.intValue());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code UnsignedInteger} representing the same value as the specified {@link\n * BigInteger}. This is the inverse operation of {@link #bigIntegerValue()}.\n *\n * @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^32}\n */\n", "repo_name": "guava-master/", "id": 4452, "method_signature": "UnsignedInteger valueOf(BigInteger)", "filename": "UnsignedInteger.valueOf.json"}
{"callee_method_names": ["NumberFormatException.initCause"], "method_name": "UnsignedInts.decode", "method_implementation": "{\n    ParseRequest request = ParseRequest.fromString(stringValue);\n    try {\n        return parseUnsignedInt(request.rawValue, request.radix);\n    } catch (NumberFormatException e) {\n        NumberFormatException decodeException = new NumberFormatException(\"Error parsing value: \" + stringValue);\n        decodeException.initCause(e);\n        throw decodeException;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the unsigned {@code int} value represented by the given string.\n *\n * <p>Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix:\n *\n * <ul>\n *   <li>{@code 0x}<i>HexDigits</i>\n *   <li>{@code 0X}<i>HexDigits</i>\n *   <li>{@code #}<i>HexDigits</i>\n *   <li>{@code 0}<i>OctalDigits</i>\n * </ul>\n *\n * @throws NumberFormatException if the string does not contain a valid unsigned {@code int} value\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 4326, "method_signature": "int decode(String)", "filename": "UnsignedInts.decode.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "UnsignedInts.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 5);\n    builder.append(toString(array[0]));\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(toString(array[i]));\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied unsigned {@code int} values separated by {@code\n * separator}. For example, {@code join(\"-\", 1, 2, 3)} returns the string {@code \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of unsigned {@code int} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4323, "method_signature": "String join(String, int[])", "filename": "UnsignedInts.join.json"}
{"callee_method_names": [], "method_name": "UnsignedInts.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    int max = flip(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        int next = flip(array[i]);\n        if (next > max) {\n            max = next;\n        }\n    }\n    return flip(max);\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}, treating values as unsigned.\n *\n * @param array a <i>nonempty</i> array of unsigned {@code int} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array according to {@link #compare}\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4322, "method_signature": "int max(int[])", "filename": "UnsignedInts.max.json"}
{"callee_method_names": [], "method_name": "UnsignedInts.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    int min = flip(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        int next = flip(array[i]);\n        if (next < min) {\n            min = next;\n        }\n    }\n    return flip(min);\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}, treating values as unsigned.\n *\n * @param array a <i>nonempty</i> array of unsigned {@code int} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array according to {@link #compare}\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4321, "method_signature": "int min(int[])", "filename": "UnsignedInts.min.json"}
{"callee_method_names": [], "method_name": "UnsignedInts.parseUnsignedInt", "method_implementation": "{\n    checkNotNull(string);\n    long result = Long.parseLong(string, radix);\n    if ((result & INT_MASK) != result) {\n        throw new NumberFormatException(\"Input \" + string + \" in base \" + radix + \" is not in the range of an unsigned integer\");\n    }\n    return (int) result;\n}", "repo_id": "5", "comment": "/**\n * Returns the unsigned {@code int} value represented by a string with the given radix.\n *\n * <p><b>Java 8 users:</b> use {@link Integer#parseUnsignedInt(String, int)} instead.\n *\n * @param string the string containing the unsigned integer representation to be parsed.\n * @param radix the radix to use while parsing {@code s}; must be between {@link\n *     Character#MIN_RADIX} and {@link Character#MAX_RADIX}.\n * @throws NumberFormatException if the string does not contain a valid unsigned {@code int}, or\n *     if supplied radix is invalid.\n * @throws NullPointerException if {@code s} is null (in contrast to {@link\n *     Integer#parseInt(String)})\n */\n", "repo_name": "guava-master/", "id": 4327, "method_signature": "int parseUnsignedInt(String, int)", "filename": "UnsignedInts.parseUnsignedInt.json"}
{"callee_method_names": [], "method_name": "UnsignedInts.saturatedCast", "method_implementation": "{\n    if (value <= 0) {\n        return 0;\n    } else if (value >= (1L << 32)) {\n        return -1;\n    } else {\n        return (int) value;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the {@code int} value that, when treated as unsigned, is nearest in value to {@code\n * value}.\n *\n * @param value any {@code long} value\n * @return {@code 2^32 - 1} if {@code value >= 2^32}, {@code 0} if {@code value <= 0}, and {@code\n *     value} cast to {@code int} otherwise\n * @since 21.0\n */\n", "repo_name": "guava-master/", "id": 4320, "method_signature": "int saturatedCast(long)", "filename": "UnsignedInts.saturatedCast.json"}
{"callee_method_names": [], "method_name": "UnsignedInts.sort", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] = flip(array[i]);\n    }\n    Arrays.sort(array, fromIndex, toIndex);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] = flip(array[i]);\n    }\n}", "repo_id": "5", "comment": "/**\n * Sorts the array between {@code fromIndex} inclusive and {@code toIndex} exclusive, treating its\n * elements as unsigned 32-bit integers.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4324, "method_signature": "void sort(int[], int, int)", "filename": "UnsignedInts.sort.json"}
{"callee_method_names": [], "method_name": "UnsignedInts.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] ^= Integer.MAX_VALUE;\n    }\n    Arrays.sort(array, fromIndex, toIndex);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] ^= Integer.MAX_VALUE;\n    }\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order, interpreting them as unsigned 32-bit integers.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4325, "method_signature": "void sortDescending(int[], int, int)", "filename": "UnsignedInts.sortDescending.json"}
{"callee_method_names": ["BigInteger.setBit"], "method_name": "UnsignedLong.bigIntegerValue", "method_implementation": "{\n    BigInteger bigInt = BigInteger.valueOf(value & UNSIGNED_MASK);\n    if (value < 0) {\n        bigInt = bigInt.setBit(Long.SIZE - 1);\n    }\n    return bigInt;\n}", "repo_id": "5", "comment": "/**\n * Returns the value of this {@code UnsignedLong} as a {@link BigInteger}.\n */\n", "repo_name": "guava-master/", "id": 4332, "method_signature": "BigInteger bigIntegerValue()", "filename": "UnsignedLong.bigIntegerValue.json"}
{"callee_method_names": [], "method_name": "UnsignedLong.doubleValue", "method_implementation": "{\n    if (value >= 0) {\n        return (double) value;\n    }\n    // The top bit is set, which means that the double value is going to come from the top 53 bits.\n    // So we can ignore the bottom 11, except for rounding. We can unsigned-shift right 1, aka\n    // unsigned-divide by 2, and convert that. Then we'll get exactly half of the desired double\n    // value. But in the specific case where the bottom two bits of the original number are 01, we\n    // want to replace that with 1 in the shifted value for correct rounding.\n    return (double) ((value >>> 1) | (value & 1)) * 2.0;\n}", "repo_id": "5", "comment": "/**\n * Returns the value of this {@code UnsignedLong} as a {@code double}, analogous to a widening\n * primitive conversion from {@code long} to {@code double}, and correctly rounded.\n */\n", "repo_name": "guava-master/", "id": 4331, "method_signature": "double doubleValue()", "filename": "UnsignedLong.doubleValue.json"}
{"callee_method_names": [], "method_name": "UnsignedLong.floatValue", "method_implementation": "{\n    if (value >= 0) {\n        return (float) value;\n    }\n    // The top bit is set, which means that the float value is going to come from the top 24 bits.\n    // So we can ignore the bottom 8, except for rounding. See doubleValue() for more.\n    return (float) ((value >>> 1) | (value & 1)) * 2f;\n}", "repo_id": "5", "comment": "/**\n * Returns the value of this {@code UnsignedLong} as a {@code float}, analogous to a widening\n * primitive conversion from {@code long} to {@code float}, and correctly rounded.\n */\n", "repo_name": "guava-master/", "id": 4330, "method_signature": "float floatValue()", "filename": "UnsignedLong.floatValue.json"}
{"callee_method_names": ["BigInteger.signum", "BigInteger.bitLength", "BigInteger.longValue"], "method_name": "UnsignedLong.valueOf", "method_implementation": "{\n    checkNotNull(value);\n    checkArgument(value.signum() >= 0 && value.bitLength() <= Long.SIZE, \"value (%s) is outside the range for an unsigned long value\", value);\n    return fromLongBits(value.longValue());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@code UnsignedLong} representing the same value as the specified {@code BigInteger}.\n * This is the inverse operation of {@link #bigIntegerValue()}.\n *\n * @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^64}\n */\n", "repo_name": "guava-master/", "id": 4329, "method_signature": "UnsignedLong valueOf(BigInteger)", "filename": "UnsignedLong.valueOf.json"}
{"callee_method_names": ["NumberFormatException.initCause"], "method_name": "UnsignedLongs.decode", "method_implementation": "{\n    ParseRequest request = ParseRequest.fromString(stringValue);\n    try {\n        return parseUnsignedLong(request.rawValue, request.radix);\n    } catch (NumberFormatException e) {\n        NumberFormatException decodeException = new NumberFormatException(\"Error parsing value: \" + stringValue);\n        decodeException.initCause(e);\n        throw decodeException;\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns the unsigned {@code long} value represented by the given string.\n *\n * <p>Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix:\n *\n * <ul>\n *   <li>{@code 0x}<i>HexDigits</i>\n *   <li>{@code 0X}<i>HexDigits</i>\n *   <li>{@code #}<i>HexDigits</i>\n *   <li>{@code 0}<i>OctalDigits</i>\n * </ul>\n *\n * @throws NumberFormatException if the string does not contain a valid unsigned {@code long}\n *     value\n * @since 13.0\n */\n", "repo_name": "guava-master/", "id": 4295, "method_signature": "long decode(String)", "filename": "UnsignedLongs.decode.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.divide", "method_implementation": "{\n    if (divisor < 0) {\n        // i.e., divisor >= 2^63:\n        if (compare(dividend, divisor) < 0) {\n            // dividend < divisor\n            return 0;\n        } else {\n            // dividend >= divisor\n            return 1;\n        }\n    }\n    // Optimization - use signed division if dividend < 2^63\n    if (dividend >= 0) {\n        return dividend / divisor;\n    }\n    /*\n     * Otherwise, approximate the quotient, check, and correct if necessary. Our approximation is\n     * guaranteed to be either exact or one less than the correct value. This follows from fact that\n     * floor(floor(x)/i) == floor(x/i) for any real x and integer i != 0. The proof is not quite\n     * trivial.\n     */\n    long quotient = ((dividend >>> 1) / divisor) << 1;\n    long rem = dividend - quotient * divisor;\n    return quotient + (compare(rem, divisor) >= 0 ? 1 : 0);\n}", "repo_id": "5", "comment": "/**\n * Returns dividend / divisor, where the dividend and divisor are treated as unsigned 64-bit\n * quantities.\n *\n * <p><b>Java 8 users:</b> use {@link Long#divideUnsigned(long, long)} instead.\n *\n * @param dividend the dividend (numerator)\n * @param divisor the divisor (denominator)\n * @throws ArithmeticException if divisor is 0\n */\n", "repo_name": "guava-master/", "id": 4292, "method_signature": "long divide(long, long)", "filename": "UnsignedLongs.divide.json"}
{"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "UnsignedLongs.join", "method_implementation": "{\n    checkNotNull(separator);\n    if (array.length == 0) {\n        return \"\";\n    }\n    // For pre-sizing a builder, just get the right order of magnitude\n    StringBuilder builder = new StringBuilder(array.length * 5);\n    builder.append(toString(array[0]));\n    for (int i = 1; i < array.length; i++) {\n        builder.append(separator).append(toString(array[i]));\n    }\n    return builder.toString();\n}", "repo_id": "5", "comment": "/**\n * Returns a string containing the supplied unsigned {@code long} values separated by {@code\n * separator}. For example, {@code join(\"-\", 1, 2, 3)} returns the string {@code \"1-2-3\"}.\n *\n * @param separator the text that should appear between consecutive values in the resulting string\n *     (but not at the start or end)\n * @param array an array of unsigned {@code long} values, possibly empty\n */\n", "repo_name": "guava-master/", "id": 4289, "method_signature": "String join(String, long[])", "filename": "UnsignedLongs.join.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.max", "method_implementation": "{\n    checkArgument(array.length > 0);\n    long max = flip(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        long next = flip(array[i]);\n        if (next > max) {\n            max = next;\n        }\n    }\n    return flip(max);\n}", "repo_id": "5", "comment": "/**\n * Returns the greatest value present in {@code array}, treating values as unsigned.\n *\n * @param array a <i>nonempty</i> array of unsigned {@code long} values\n * @return the value present in {@code array} that is greater than or equal to every other value\n *     in the array according to {@link #compare}\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4288, "method_signature": "long max(long[])", "filename": "UnsignedLongs.max.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.min", "method_implementation": "{\n    checkArgument(array.length > 0);\n    long min = flip(array[0]);\n    for (int i = 1; i < array.length; i++) {\n        long next = flip(array[i]);\n        if (next < min) {\n            min = next;\n        }\n    }\n    return flip(min);\n}", "repo_id": "5", "comment": "/**\n * Returns the least value present in {@code array}, treating values as unsigned.\n *\n * @param array a <i>nonempty</i> array of unsigned {@code long} values\n * @return the value present in {@code array} that is less than or equal to every other value in\n *     the array according to {@link #compare}\n * @throws IllegalArgumentException if {@code array} is empty\n */\n", "repo_name": "guava-master/", "id": 4287, "method_signature": "long min(long[])", "filename": "UnsignedLongs.min.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.overflowInParse", "method_implementation": "{\n    if (current >= 0) {\n        if (current < maxValueDivs[radix]) {\n            return false;\n        }\n        if (current > maxValueDivs[radix]) {\n            return true;\n        }\n        // current == maxValueDivs[radix]\n        return (digit > maxValueMods[radix]);\n    }\n    // current < 0: high bit is set\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns true if (current * radix) + digit is a number too large to be represented by an\n * unsigned long. This is useful for detecting overflow while parsing a string representation of\n * a number. Does not verify whether supplied radix is valid, passing an invalid radix will give\n * undefined results or an ArrayIndexOutOfBoundsException.\n */\n", "repo_name": "guava-master/", "id": 4296, "method_signature": "boolean overflowInParse(long, int, int)", "filename": "UnsignedLongs.overflowInParse.json"}
{"callee_method_names": ["String.length", "String.length", "String.charAt"], "method_name": "UnsignedLongs.parseUnsignedLong", "method_implementation": "{\n    checkNotNull(string);\n    if (string.length() == 0) {\n        throw new NumberFormatException(\"empty string\");\n    }\n    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {\n        throw new NumberFormatException(\"illegal radix: \" + radix);\n    }\n    int maxSafePos = ParseOverflowDetection.maxSafeDigits[radix] - 1;\n    long value = 0;\n    for (int pos = 0; pos < string.length(); pos++) {\n        int digit = Character.digit(string.charAt(pos), radix);\n        if (digit == -1) {\n            throw new NumberFormatException(string);\n        }\n        if (pos > maxSafePos && ParseOverflowDetection.overflowInParse(value, digit, radix)) {\n            throw new NumberFormatException(\"Too large for unsigned long: \" + string);\n        }\n        value = (value * radix) + digit;\n    }\n    return value;\n}", "repo_id": "5", "comment": "/**\n * Returns the unsigned {@code long} value represented by a string with the given radix.\n *\n * <p><b>Java 8 users:</b> use {@link Long#parseUnsignedLong(String, int)} instead.\n *\n * @param string the string containing the unsigned {@code long} representation to be parsed.\n * @param radix the radix to use while parsing {@code string}\n * @throws NumberFormatException if the string does not contain a valid unsigned {@code long} with\n *     the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX} and {@link\n *     Character#MAX_RADIX}.\n * @throws NullPointerException if {@code string} is null (in contrast to {@link\n *     Long#parseLong(String)})\n */\n", "repo_name": "guava-master/", "id": 4294, "method_signature": "long parseUnsignedLong(String, int)", "filename": "UnsignedLongs.parseUnsignedLong.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.remainder", "method_implementation": "{\n    if (divisor < 0) {\n        // i.e., divisor >= 2^63:\n        if (compare(dividend, divisor) < 0) {\n            // dividend < divisor\n            return dividend;\n        } else {\n            // dividend >= divisor\n            return dividend - divisor;\n        }\n    }\n    // Optimization - use signed modulus if dividend < 2^63\n    if (dividend >= 0) {\n        return dividend % divisor;\n    }\n    /*\n     * Otherwise, approximate the quotient, check, and correct if necessary. Our approximation is\n     * guaranteed to be either exact or one less than the correct value. This follows from the fact\n     * that floor(floor(x)/i) == floor(x/i) for any real x and integer i != 0. The proof is not\n     * quite trivial.\n     */\n    long quotient = ((dividend >>> 1) / divisor) << 1;\n    long rem = dividend - quotient * divisor;\n    return rem - (compare(rem, divisor) >= 0 ? divisor : 0);\n}", "repo_id": "5", "comment": "/**\n * Returns dividend % divisor, where the dividend and divisor are treated as unsigned 64-bit\n * quantities.\n *\n * <p><b>Java 8 users:</b> use {@link Long#remainderUnsigned(long, long)} instead.\n *\n * @param dividend the dividend (numerator)\n * @param divisor the divisor (denominator)\n * @throws ArithmeticException if divisor is 0\n * @since 11.0\n */\n", "repo_name": "guava-master/", "id": 4293, "method_signature": "long remainder(long, long)", "filename": "UnsignedLongs.remainder.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.sort", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] = flip(array[i]);\n    }\n    Arrays.sort(array, fromIndex, toIndex);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] = flip(array[i]);\n    }\n}", "repo_id": "5", "comment": "/**\n * Sorts the array between {@code fromIndex} inclusive and {@code toIndex} exclusive, treating its\n * elements as unsigned 64-bit integers.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4290, "method_signature": "void sort(long[], int, int)", "filename": "UnsignedLongs.sort.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.sortDescending", "method_implementation": "{\n    checkNotNull(array);\n    checkPositionIndexes(fromIndex, toIndex, array.length);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] ^= Long.MAX_VALUE;\n    }\n    Arrays.sort(array, fromIndex, toIndex);\n    for (int i = fromIndex; i < toIndex; i++) {\n        array[i] ^= Long.MAX_VALUE;\n    }\n}", "repo_id": "5", "comment": "/**\n * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}\n * exclusive in descending order, interpreting them as unsigned 64-bit integers.\n *\n * @since 23.1\n */\n", "repo_name": "guava-master/", "id": 4291, "method_signature": "void sortDescending(long[], int, int)", "filename": "UnsignedLongs.sortDescending.json"}
{"callee_method_names": [], "method_name": "UnsignedLongs.toString", "method_implementation": "{\n    checkArgument(radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX, \"radix (%s) must be between Character.MIN_RADIX and Character.MAX_RADIX\", radix);\n    if (x == 0) {\n        // Simply return \"0\"\n        return \"0\";\n    } else if (x > 0) {\n        return Long.toString(x, radix);\n    } else {\n        char[] buf = new char[64];\n        int i = buf.length;\n        if ((radix & (radix - 1)) == 0) {\n            // Radix is a power of two so we can avoid division.\n            int shift = Integer.numberOfTrailingZeros(radix);\n            int mask = radix - 1;\n            do {\n                buf[--i] = Character.forDigit(((int) x) & mask, radix);\n                x >>>= shift;\n            } while (x != 0);\n        } else {\n            // Separate off the last digit using unsigned division. That will leave\n            // a number that is nonnegative as a signed integer.\n            long quotient;\n            if ((radix & 1) == 0) {\n                // Fast path for the usual case where the radix is even.\n                quotient = (x >>> 1) / (radix >>> 1);\n            } else {\n                quotient = divide(x, radix);\n            }\n            long rem = x - quotient * radix;\n            buf[--i] = Character.forDigit((int) rem, radix);\n            x = quotient;\n            // Simple modulo/division approach\n            while (x > 0) {\n                buf[--i] = Character.forDigit((int) (x % radix), radix);\n                x /= radix;\n            }\n        }\n        // Generate string\n        return new String(buf, i, buf.length - i);\n    }\n}", "repo_id": "5", "comment": "/**\n * Returns a string representation of {@code x} for the given radix, where {@code x} is treated as\n * unsigned.\n *\n * <p><b>Java 8 users:</b> use {@link Long#toUnsignedString(long, int)} instead.\n *\n * @param x the value to convert to a string.\n * @param radix the radix to use while working with {@code x}\n * @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}\n *     and {@link Character#MAX_RADIX}.\n */\n", "repo_name": "guava-master/", "id": 4297, "method_signature": "String toString(long, int)", "filename": "UnsignedLongs.toString.json"}
{"callee_method_names": ["Random.nextLong"], "method_name": "UnsignedLongsBenchmark.randomDivisor", "method_implementation": "{\n    long r = RANDOM_SOURCE.nextLong();\n    if (dividend == -1) {\n        return r;\n    } else {\n        return UnsignedLongs.remainder(r, dividend + 1);\n    }\n}", "repo_id": "5", "comment": "// not have a big impact on the measurement.\n", "repo_name": "guava-master/", "id": 3475, "method_signature": "long randomDivisor(long)", "filename": "UnsignedLongsBenchmark.randomDivisor.json"}
{"callee_method_names": [], "method_name": "UrlEscapersTest.assertBasicUrlEscaper", "method_implementation": "{\n    assertBasicUrlEscaperExceptPercent(e);\n    // The escape character must always be escaped\n    assertEscaping(e, \"%25\", '%');\n}", "repo_id": "5", "comment": "// Helper to assert common expected behaviour of uri escapers.\n", "repo_name": "guava-master/", "id": 4044, "method_signature": "void assertBasicUrlEscaper(UnicodeEscaper)", "filename": "UrlEscapersTest.assertBasicUrlEscaper.json"}
{"callee_method_ids": [4266, 4266, 4266, 4266, 4266], "callee_method_names": ["UnicodeEscaper.escape", "UnicodeEscaper.escape", "UnicodeEscaper.escape", "UnicodeEscaper.escape", "UnicodeEscaper.escape"], "method_name": "UrlEscapersTest.assertBasicUrlEscaperExceptPercent", "method_implementation": "{\n    // URL escapers should throw null pointer exceptions for null input\n    try {\n        e.escape((String) null);\n        fail(\"Escaping null string should throw exception\");\n    } catch (NullPointerException x) {\n        // pass\n    }\n    // All URL escapers should leave 0-9, A-Z, a-z unescaped\n    assertUnescaped(e, 'a');\n    assertUnescaped(e, 'z');\n    assertUnescaped(e, 'A');\n    assertUnescaped(e, 'Z');\n    assertUnescaped(e, '0');\n    assertUnescaped(e, '9');\n    // Unreserved characters used in java.net.URLEncoder\n    assertUnescaped(e, '-');\n    assertUnescaped(e, '_');\n    assertUnescaped(e, '.');\n    assertUnescaped(e, '*');\n    // nul\n    assertEscaping(e, \"%00\", '\\u0000');\n    // del\n    assertEscaping(e, \"%7F\", '\\u007f');\n    // xx-00010,x-000000\n    assertEscaping(e, \"%C2%80\", '\\u0080');\n    // xx-11111,x-111111\n    assertEscaping(e, \"%DF%BF\", '\\u07ff');\n    // xxx-0000,x-100000,x-00,0000\n    assertEscaping(e, \"%E0%A0%80\", '\\u0800');\n    // xxx-1111,x-111111,x-11,1111\n    assertEscaping(e, \"%EF%BF%BF\", '\\uffff');\n    assertUnicodeEscaping(e, \"%F0%90%80%80\", '\\uD800', '\\uDC00');\n    assertUnicodeEscaping(e, \"%F4%8F%BF%BF\", '\\uDBFF', '\\uDFFF');\n    assertEquals(\"\", e.escape(\"\"));\n    assertEquals(\"safestring\", e.escape(\"safestring\"));\n    assertEquals(\"embedded%00null\", e.escape(\"embedded\\0null\"));\n    assertEquals(\"max%EF%BF%BFchar\", e.escape(\"max\\uffffchar\"));\n}", "repo_id": "5", "comment": "/**\n * Helper to assert common expected behaviour of uri escapers. You should call\n * assertBasicUrlEscaper() unless the escaper explicitly does not escape '%'.\n */\n", "repo_name": "guava-master/", "id": 4043, "method_signature": "void assertBasicUrlEscaperExceptPercent(UnicodeEscaper)", "filename": "UrlEscapersTest.assertBasicUrlEscaperExceptPercent.json"}
{"callee_method_names": ["CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "Utf8.encodedLength", "method_implementation": "{\n    // Warning to maintainers: this implementation is highly optimized.\n    int utf16Length = sequence.length();\n    int utf8Length = utf16Length;\n    int i = 0;\n    // This loop optimizes for pure ASCII.\n    while (i < utf16Length && sequence.charAt(i) < 0x80) {\n        i++;\n    }\n    // This loop optimizes for chars less than 0x800.\n    for (; i < utf16Length; i++) {\n        char c = sequence.charAt(i);\n        if (c < 0x800) {\n            // branch free!\n            utf8Length += ((0x7f - c) >>> 31);\n        } else {\n            utf8Length += encodedLengthGeneral(sequence, i);\n            break;\n        }\n    }\n    if (utf8Length < utf16Length) {\n        // Necessary and sufficient condition for overflow because of maximum 3x expansion\n        throw new IllegalArgumentException(\"UTF-8 length does not fit in int: \" + (utf8Length + (1L << 32)));\n    }\n    return utf8Length;\n}", "repo_id": "5", "comment": "/**\n * Returns the number of bytes in the UTF-8-encoded form of {@code sequence}. For a string, this\n * method is equivalent to {@code string.getBytes(UTF_8).length}, but is more efficient in both\n * time and space.\n *\n * @throws IllegalArgumentException if {@code sequence} contains ill-formed UTF-16 (unpaired\n *     surrogates)\n */\n", "repo_name": "guava-master/", "id": 4990, "method_signature": "int encodedLength(CharSequence)", "filename": "Utf8.encodedLength.json"}
{"callee_method_names": [], "method_name": "Utf8.isWellFormed", "method_implementation": "{\n    int end = off + len;\n    checkPositionIndexes(off, end, bytes.length);\n    // Look for the first non-ASCII character.\n    for (int i = off; i < end; i++) {\n        if (bytes[i] < 0) {\n            return isWellFormedSlowPath(bytes, i, end);\n        }\n    }\n    return true;\n}", "repo_id": "5", "comment": "/**\n * Returns whether the given byte array slice is a well-formed UTF-8 byte sequence, as defined by\n * {@link #isWellFormed(byte[])}. Note that this can be false even when {@code\n * isWellFormed(bytes)} is true.\n *\n * @param bytes the input buffer\n * @param off the offset in the buffer of the first byte to read\n * @param len the number of bytes to read from the buffer\n */\n", "repo_name": "guava-master/", "id": 4991, "method_signature": "boolean isWellFormed(byte[], int, int)", "filename": "Utf8.isWellFormed.json"}
{"callee_method_names": ["String.getBytes"], "method_name": "Utf8Test.testBytes", "method_implementation": "{\n    byte[] bytes = new byte[numBytes];\n    if (lim == -1) {\n        lim = 1L << (numBytes * 8);\n    }\n    long countRoundTripped = 0;\n    for (long byteChar = start; byteChar < lim; byteChar++) {\n        long tmpByteChar = byteChar;\n        for (int i = 0; i < numBytes; i++) {\n            bytes[bytes.length - i - 1] = (byte) tmpByteChar;\n            tmpByteChar = tmpByteChar >> 8;\n        }\n        boolean isRoundTrippable = Utf8.isWellFormed(bytes);\n        assertEquals(isRoundTrippable, Utf8.isWellFormed(bytes, 0, numBytes));\n        String s = new String(bytes, Charsets.UTF_8);\n        byte[] bytesReencoded = s.getBytes(Charsets.UTF_8);\n        boolean bytesEqual = Arrays.equals(bytes, bytesReencoded);\n        if (bytesEqual != isRoundTrippable) {\n            fail();\n        }\n        if (isRoundTrippable) {\n            countRoundTripped++;\n        }\n    }\n    assertEquals(expectedCount, countRoundTripped);\n}", "repo_id": "5", "comment": "/**\n * Helper to run the loop to test all the permutations for the number of bytes specified. This\n * overload is useful for debugging to get the loop to start at a certain character.\n *\n * @param numBytes the number of bytes in the byte array\n * @param expectedCount the expected number of roundtrippable permutations\n * @param start the starting bytes encoded as a long as big-endian\n * @param lim the limit of bytes to process encoded as a long as big-endian, or -1 to mean the max\n *     limit for numBytes\n */\n", "repo_name": "guava-master/", "id": 3718, "method_signature": "void testBytes(int, long, long, long)", "filename": "Utf8Test.testBytes.json"}
{"callee_method_names": [], "method_name": "Utf8Test.testIsWellFormed_1Byte", "method_implementation": "{\n    testBytes(1, EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT);\n}", "repo_id": "5", "comment": "/**\n * Tests that round tripping of all two byte permutations work.\n */\n", "repo_name": "guava-master/", "id": 3712, "method_signature": "void testIsWellFormed_1Byte()", "filename": "Utf8Test.testIsWellFormed_1Byte.json"}
{"callee_method_names": [], "method_name": "Utf8Test.testIsWellFormed_2Bytes", "method_implementation": "{\n    testBytes(2, EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT);\n}", "repo_id": "5", "comment": "/**\n * Tests that round tripping of all two byte permutations work.\n */\n", "repo_name": "guava-master/", "id": 3713, "method_signature": "void testIsWellFormed_2Bytes()", "filename": "Utf8Test.testIsWellFormed_2Bytes.json"}
{"callee_method_names": [], "method_name": "Utf8Test.testIsWellFormed_3Bytes", "method_implementation": "{\n    testBytes(3, EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT);\n}", "repo_id": "5", "comment": "/**\n * Tests that round tripping of all three byte permutations work.\n */\n", "repo_name": "guava-master/", "id": 3714, "method_signature": "void testIsWellFormed_3Bytes()", "filename": "Utf8Test.testIsWellFormed_3Bytes.json"}
{"callee_method_names": [], "method_name": "Utf8Test.testIsWellFormed_4BytesSamples", "method_implementation": "{\n    // Valid 4 byte.\n    assertWellFormed(0xF0, 0xA4, 0xAD, 0xA2);\n    // Bad trailing bytes\n    assertNotWellFormed(0xF0, 0xA4, 0xAD, 0x7F);\n    assertNotWellFormed(0xF0, 0xA4, 0xAD, 0xC0);\n    // Special cases for byte2\n    assertNotWellFormed(0xF0, 0x8F, 0xAD, 0xA2);\n    assertNotWellFormed(0xF4, 0x90, 0xAD, 0xA2);\n}", "repo_id": "5", "comment": "/**\n * Tests that round tripping of a sample of four byte permutations work. All permutations are\n * prohibitively expensive to test for automated runs. This method tests specific four-byte cases.\n */\n", "repo_name": "guava-master/", "id": 3715, "method_signature": "void testIsWellFormed_4BytesSamples()", "filename": "Utf8Test.testIsWellFormed_4BytesSamples.json"}
{"callee_method_names": [], "method_name": "Utf8Test.testSomeSequences", "method_implementation": "{\n    // Empty\n    assertWellFormed();\n    // One-byte characters, including control characters\n    // \"\\u0000abc\\u007f\"\n    assertWellFormed(0x00, 0x61, 0x62, 0x63, 0x7F);\n    // Two-byte characters\n    // \"\\u00a2\\u00a2\"\n    assertWellFormed(0xC2, 0xA2, 0xC2, 0xA2);\n    // Three-byte characters\n    // \"\\u020ac\\u020ac\"\n    assertWellFormed(0xc8, 0x8a, 0x63, 0xc8, 0x8a, 0x63);\n    // Four-byte characters\n    // \"\\u024B62\\u024B62\"\n    assertWellFormed(0xc9, 0x8b, 0x36, 0x32, 0xc9, 0x8b, 0x36, 0x32);\n    // Mixed string\n    // \"a\\u020ac\\u00a2b\\\\u024B62u020acc\\u00a2de\\u024B62\"\n    assertWellFormed(0x61, 0xc8, 0x8a, 0x63, 0xc2, 0xa2, 0x62, 0x5c, 0x75, 0x30, 0x32, 0x34, 0x42, 0x36, 0x32, 0x75, 0x30, 0x32, 0x30, 0x61, 0x63, 0x63, 0xc2, 0xa2, 0x64, 0x65, 0xc9, 0x8b, 0x36, 0x32);\n    // Not a valid string\n    assertNotWellFormed(-1, 0, -1, 0);\n}", "repo_id": "5", "comment": "/**\n * Tests some hard-coded test cases.\n */\n", "repo_name": "guava-master/", "id": 3716, "method_signature": "void testSomeSequences()", "filename": "Utf8Test.testSomeSequences.json"}
{"callee_method_names": [], "method_name": "ValueGraphBuilder.allowsSelfLoops", "method_implementation": "{\n    this.allowsSelfLoops = allowsSelfLoops;\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies whether the graph will allow self-loops (edges that connect a node to itself).\n * Attempting to add a self-loop to a graph that does not allow them will throw an {@link\n * UnsupportedOperationException}.\n *\n * <p>The default value is {@code false}.\n */\n", "repo_name": "guava-master/", "id": 6740, "method_signature": "ValueGraphBuilder<N,V> allowsSelfLoops(boolean)", "filename": "ValueGraphBuilder.allowsSelfLoops.json"}
{"callee_method_names": [], "method_name": "ValueGraphBuilder.expectedNodeCount", "method_implementation": "{\n    this.expectedNodeCount = Optional.of(checkNonNegative(expectedNodeCount));\n    return this;\n}", "repo_id": "5", "comment": "/**\n * Specifies the expected number of nodes in the graph.\n *\n * @throws IllegalArgumentException if {@code expectedNodeCount} is negative\n */\n", "repo_name": "guava-master/", "id": 6741, "method_signature": "ValueGraphBuilder<N,V> expectedNodeCount(int)", "filename": "ValueGraphBuilder.expectedNodeCount.json"}
{"callee_method_names": ["ValueGraph<N,V>.isDirected", "ValueGraph<N,V>.allowsSelfLoops", "ValueGraph<N,V>.nodeOrder", "ValueGraph<N,V>.incidentEdgeOrder"], "method_name": "ValueGraphBuilder.from", "method_implementation": "{\n    return new ValueGraphBuilder<N, V>(graph.isDirected()).allowsSelfLoops(graph.allowsSelfLoops()).nodeOrder(graph.nodeOrder()).incidentEdgeOrder(graph.incidentEdgeOrder());\n}", "repo_id": "5", "comment": "/**\n * Returns a {@link ValueGraphBuilder} initialized with all properties queryable from {@code\n * graph}.\n *\n * <p>The \"queryable\" properties are those that are exposed through the {@link ValueGraph}\n * interface, such as {@link ValueGraph#isDirected()}. Other properties, such as {@link\n * #expectedNodeCount(int)}, are not set in the new builder.\n */\n", "repo_name": "guava-master/", "id": 6739, "method_signature": "ValueGraphBuilder<N,V> from(ValueGraph)", "filename": "ValueGraphBuilder.from.json"}
{"callee_method_names": ["ElementOrder<N1>.type", "ElementOrder<N1>.type"], "method_name": "ValueGraphBuilder.incidentEdgeOrder", "method_implementation": "{\n    checkArgument(incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED || incidentEdgeOrder.type() == ElementOrder.Type.STABLE, \"The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports\" + \" ElementOrder.unordered() and ElementOrder.stable().\", incidentEdgeOrder);\n    ValueGraphBuilder<N1, V> newBuilder = cast();\n    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n    return newBuilder;\n}", "repo_id": "5", "comment": "/**\n * Specifies the order of iteration for the elements of {@link ValueGraph#edges()}, {@link\n * ValueGraph#adjacentNodes(Object)}, {@link ValueGraph#predecessors(Object)}, {@link\n * ValueGraph#successors(Object)} and {@link ValueGraph#incidentEdges(Object)}.\n *\n * <p>The default value is {@link ElementOrder#unordered() unordered} for mutable graphs. For\n * immutable graphs, this value is ignored; they always have a {@link ElementOrder#stable()\n * stable} order.\n *\n * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code\n *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.\n * @since 29.0\n */\n", "repo_name": "guava-master/", "id": 6743, "method_signature": "ValueGraphBuilder<N1,V> incidentEdgeOrder(ElementOrder)", "filename": "ValueGraphBuilder.incidentEdgeOrder.json"}
{"callee_method_names": [], "method_name": "ValueGraphBuilder.nodeOrder", "method_implementation": "{\n    ValueGraphBuilder<N1, V> newBuilder = cast();\n    newBuilder.nodeOrder = checkNotNull(nodeOrder);\n    return newBuilder;\n}", "repo_id": "5", "comment": "/**\n * Specifies the order of iteration for the elements of {@link Graph#nodes()}.\n *\n * <p>The default value is {@link ElementOrder#insertion() insertion order}.\n */\n", "repo_name": "guava-master/", "id": 6742, "method_signature": "ValueGraphBuilder<N1,V> nodeOrder(ElementOrder)", "filename": "ValueGraphBuilder.nodeOrder.json"}
{"callee_method_names": [], "method_name": "Values.writeReplace", "method_implementation": "{\n    return super.writeReplace();\n}", "repo_id": "5", "comment": "// redeclare to help optimizers with b/310253115\n", "repo_name": "guava-master/", "id": 6673, "method_signature": "Object writeReplace()", "filename": "Values.writeReplace.json"}
{"callee_method_names": [], "method_name": "Verify.verify", "method_implementation": "{\n    if (!expression) {\n        throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n    }\n}", "repo_id": "5", "comment": "/**\n * Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a\n * custom message otherwise.\n *\n * <p>See {@link #verify(boolean, String, Object...)} for details.\n *\n * @since 23.1 (varargs overload since 17.0)\n */\n", "repo_name": "guava-master/", "id": 5155, "method_signature": "void verify(boolean, String, Object, Object, Object, Object)", "filename": "Verify.verify.json"}
{"callee_method_names": [], "method_name": "Verify.verifyNotNull", "method_implementation": "{\n    if (reference == null) {\n        throw new VerifyException(lenientFormat(errorMessageTemplate, errorMessageArgs));\n    }\n    return reference;\n}", "repo_id": "5", "comment": "/**\n * Ensures that {@code reference} is non-null, throwing a {@code VerifyException} with a custom\n * message otherwise.\n *\n * @param errorMessageTemplate a template for the exception message should the check fail. The\n *     message is formed by replacing each {@code %s} placeholder in the template with an\n *     argument. These are matched by position - the first {@code %s} gets {@code\n *     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in\n *     square braces. Unmatched placeholders will be left as-is.\n * @param errorMessageArgs the arguments to be substituted into the message template. Arguments\n *     are converted to strings using {@link String#valueOf(Object)}.\n * @return {@code reference}, guaranteed to be non-null, for convenience\n * @throws VerifyException if {@code reference} is {@code null}\n * @see Preconditions#checkNotNull Preconditions.checkNotNull()\n */\n", "repo_name": "guava-master/", "id": 5156, "method_signature": "T verifyNotNull(T, String, Object[])", "filename": "Verify.verifyNotNull.json"}
{"callee_method_names": [], "method_name": "WildcardSubtypingTests.explicitTypeBoundIsSubtypeOfImplicitTypeBound", "method_implementation": "{\n    return isSubtype(obj);\n}", "repo_id": "5", "comment": "// Foo<?> and Foo<? extends Bar> equal for class Foo<T extends Bar>\n", "repo_name": "guava-master/", "id": 3623, "method_signature": "UseIterable<?> explicitTypeBoundIsSubtypeOfImplicitTypeBound(UseIterable)", "filename": "WildcardSubtypingTests.explicitTypeBoundIsSubtypeOfImplicitTypeBound.json"}
{"callee_method_names": [], "method_name": "WildcardSubtypingTests.implicitTypeBoundIsSubtypeOfExplicitTypeBound", "method_implementation": "{\n    return isSubtype(obj);\n}", "repo_id": "5", "comment": "// Foo<?> and Foo<? extends Bar> equal for class Foo<T extends Bar>\n", "repo_name": "guava-master/", "id": 3624, "method_signature": "UseIterable<? extends Iterable<?>> implicitTypeBoundIsSubtypeOfExplicitTypeBound(UseIterable)", "filename": "WildcardSubtypingTests.implicitTypeBoundIsSubtypeOfExplicitTypeBound.json"}
{"callee_method_names": [], "method_name": "WildcardSubtypingTests.omittedTypeBoundIsSubtypeOfExplicitTypeBound", "method_implementation": "{\n    return isSubtype(obj);\n}", "repo_id": "5", "comment": "// Foo<?> and Foo<? extends Bar> equal for class Foo<T extends Bar>\n", "repo_name": "guava-master/", "id": 3625, "method_signature": "UseIterable<? extends Iterable<?>> omittedTypeBoundIsSubtypeOfExplicitTypeBound(UseIterable)", "filename": "WildcardSubtypingTests.omittedTypeBoundIsSubtypeOfExplicitTypeBound.json"}
{"callee_method_names": ["Map<E, LockGraphNode>.get"], "method_name": "WithExplicitOrdering.newReentrantLock", "method_implementation": "{\n    return policy == Policies.DISABLED ? new ReentrantLock(fair) : // requireNonNull is safe because createNodes inserts an entry for every E.\n    // (If the caller passes `null` for the `rank` parameter, this will throw, but that's OK.)\n    new CycleDetectingReentrantLock(requireNonNull(lockGraphNodes.get(rank)), fair);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link ReentrantLock} with the given fairness policy and rank. The values returned\n * by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the lock in\n * warning or exception output.\n *\n * @throws IllegalStateException If the factory has already created a {@code Lock} with the\n *     specified rank.\n */\n", "repo_name": "guava-master/", "id": 5478, "method_signature": "ReentrantLock newReentrantLock(E, boolean)", "filename": "WithExplicitOrdering.newReentrantLock.json"}
{"callee_method_names": ["Map<E, LockGraphNode>.get"], "method_name": "WithExplicitOrdering.newReentrantReadWriteLock", "method_implementation": "{\n    return policy == Policies.DISABLED ? new ReentrantReadWriteLock(fair) : // requireNonNull is safe because createNodes inserts an entry for every E.\n    // (If the caller passes `null` for the `rank` parameter, this will throw, but that's OK.)\n    new CycleDetectingReentrantReadWriteLock(requireNonNull(lockGraphNodes.get(rank)), fair);\n}", "repo_id": "5", "comment": "/**\n * Creates a {@link ReentrantReadWriteLock} with the given fairness policy and rank. The values\n * returned by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the\n * lock in warning or exception output.\n *\n * @throws IllegalStateException If the factory has already created a {@code Lock} with the\n *     specified rank.\n */\n", "repo_name": "guava-master/", "id": 5479, "method_signature": "ReentrantReadWriteLock newReentrantReadWriteLock(E, boolean)", "filename": "WithExplicitOrdering.newReentrantReadWriteLock.json"}
{"callee_method_ids": [5947], "callee_method_names": ["WrappedCollection.addToMap", "Map<K,Collection<V>>.put"], "method_name": "WrappedCollection.addToMap", "method_implementation": "{\n    if (ancestor != null) {\n        ancestor.addToMap();\n    } else {\n        map.put(key, delegate);\n    }\n}", "repo_id": "5", "comment": "/**\n * Add the delegate to the map. Other {@code WrappedCollection} methods should call this method\n * after adding elements to a previously empty collection.\n *\n * <p>Subcollection add the ancestor's delegate instead.\n */\n", "repo_name": "guava-master/", "id": 5947, "method_signature": "void addToMap()", "filename": "WrappedCollection.addToMap.json"}
{"callee_method_ids": [5945], "callee_method_names": ["WrappedCollection.refreshIfEmpty", "WrappedCollection.getDelegate", "Collection<V>.isEmpty", "Map<K,Collection<V>>.get"], "method_name": "WrappedCollection.refreshIfEmpty", "method_implementation": "{\n    if (ancestor != null) {\n        ancestor.refreshIfEmpty();\n        if (ancestor.getDelegate() != ancestorDelegate) {\n            throw new ConcurrentModificationException();\n        }\n    } else if (delegate.isEmpty()) {\n        Collection<V> newDelegate = map.get(key);\n        if (newDelegate != null) {\n            delegate = newDelegate;\n        }\n    }\n}", "repo_id": "5", "comment": "/**\n * If the delegate collection is empty, but the multimap has values for the key, replace the\n * delegate with the new collection for the key.\n *\n * <p>For a subcollection, refresh its ancestor and validate that the ancestor delegate hasn't\n * changed.\n */\n", "repo_name": "guava-master/", "id": 5945, "method_signature": "void refreshIfEmpty()", "filename": "WrappedCollection.refreshIfEmpty.json"}
{"callee_method_ids": [5946], "callee_method_names": ["WrappedCollection.removeIfEmpty", "Collection<V>.isEmpty", "Map<K,Collection<V>>.remove"], "method_name": "WrappedCollection.removeIfEmpty", "method_implementation": "{\n    if (ancestor != null) {\n        ancestor.removeIfEmpty();\n    } else if (delegate.isEmpty()) {\n        map.remove(key);\n    }\n}", "repo_id": "5", "comment": "/**\n * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}. For\n * subcollections, check whether the ancestor collection is empty.\n */\n", "repo_name": "guava-master/", "id": 5946, "method_signature": "void removeIfEmpty()", "filename": "WrappedCollection.removeIfEmpty.json"}
{"callee_method_names": [], "method_name": "WrappedCollection.validateIterator", "method_implementation": "{\n    refreshIfEmpty();\n    if (delegate != originalDelegate) {\n        throw new ConcurrentModificationException();\n    }\n}", "repo_id": "5", "comment": "/**\n * If the delegate changed since the iterator was created, the iterator is no longer valid.\n */\n", "repo_name": "guava-master/", "id": 5948, "method_signature": "void validateIterator()", "filename": "WrappedCollection.validateIterator.json"}
{"callee_method_names": [], "method_name": "WrappedIterator.validateIterator", "method_implementation": "{\n    refreshIfEmpty();\n    if (delegate != originalDelegate) {\n        throw new ConcurrentModificationException();\n    }\n}", "repo_id": "5", "comment": "/**\n * If the delegate changed since the iterator was created, the iterator is no longer valid.\n */\n", "repo_name": "guava-master/", "id": 5949, "method_signature": "void validateIterator()", "filename": "WrappedIterator.validateIterator.json"}
{"callee_method_names": ["Equivalence<Object>.equivalent"], "method_name": "Wrapper.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof Wrapper) {\n        // note: not necessarily a Wrapper<T>\n        Wrapper<?> that = (Wrapper<?>) obj;\n        if (this.equivalence.equals(that.equivalence)) {\n            /*\n           * We'll accept that as sufficient \"proof\" that either equivalence should be able to\n           * handle either reference, so it's safe to circumvent compile-time type checking.\n           */\n            @SuppressWarnings(\"unchecked\")\n            Equivalence<Object> equivalence = (Equivalence<Object>) this.equivalence;\n            return equivalence.equivalent(this.reference, that.reference);\n        }\n    }\n    return false;\n}", "repo_id": "5", "comment": "/**\n * Returns {@code true} if {@link Equivalence#equivalent(Object, Object)} applied to the wrapped\n * references is {@code true} and both wrappers use the {@link Object#equals(Object) same}\n * equivalence.\n */\n", "repo_name": "guava-master/", "id": 5161, "method_signature": "boolean equals(Object)", "filename": "Wrapper.equals.json"}
{"callee_method_names": ["Callable<Object>.call"], "method_name": "WrappingExecutorService.wrapTask", "method_implementation": "{\n    Callable<Object> wrapped = wrapTask(Executors.callable(command, null));\n    return () -> {\n        try {\n            wrapped.call();\n        } catch (Exception e) {\n            restoreInterruptIfIsInterruptedException(e);\n            throwIfUnchecked(e);\n            throw new RuntimeException(e);\n        }\n    };\n}", "repo_id": "5", "comment": "/**\n * Wraps a {@code Runnable} for submission to the underlying executor. The default implementation\n * delegates to {@link #wrapTask(Callable)}.\n */\n", "repo_name": "guava-master/", "id": 5463, "method_signature": "Runnable wrapTask(Runnable)", "filename": "WrappingExecutorService.wrapTask.json"}
{"callee_method_names": ["ImmutableList.Builder<Callable<T>>.add", "ImmutableList.Builder<Callable<T>>.build"], "method_name": "WrappingExecutorService.wrapTasks", "method_implementation": "{\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}", "repo_id": "5", "comment": "/**\n * Wraps a collection of tasks.\n *\n * @throws NullPointerException if any element of {@code tasks} is null\n */\n", "repo_name": "guava-master/", "id": 5464, "method_signature": "ImmutableList<Callable<T>> wrapTasks(Collection)", "filename": "WrappingExecutorService.wrapTasks.json"}
{"callee_method_names": ["ExecutorService.submit"], "method_name": "WrappingExecutorServiceTest.invokeAny", "method_implementation": "{\n    assertTaskWrapped(tasks);\n    lastMethodCalled = \"invokeAny\";\n    return inline.submit(Iterables.get(tasks, 0)).get();\n}", "repo_id": "5", "comment": "// Define the invokeAny methods to invoke the first task\n", "repo_name": "guava-master/", "id": 3820, "method_signature": "T invokeAny(Collection)", "filename": "WrappingExecutorServiceTest.invokeAny.json"}
{"callee_method_names": ["TestExecutor.awaitTermination", "MockExecutor.assertLastMethodCalled", "TestExecutor.isTerminated", "MockExecutor.assertLastMethodCalled", "TestExecutor.isShutdown", "MockExecutor.assertLastMethodCalled", "TestExecutor.shutdown", "MockExecutor.assertLastMethodCalled", "TestExecutor.shutdownNow", "MockExecutor.assertLastMethodCalled"], "method_name": "WrappingExecutorServiceTest.testDelegations", "method_implementation": "{\n    MockExecutor mock = new MockExecutor();\n    TestExecutor testExecutor = new TestExecutor(mock);\n    assertFalse(testExecutor.awaitTermination(10, TimeUnit.MILLISECONDS));\n    mock.assertLastMethodCalled(\"awaitTermination\");\n    assertFalse(testExecutor.isTerminated());\n    mock.assertLastMethodCalled(\"isTerminated\");\n    assertFalse(testExecutor.isShutdown());\n    mock.assertLastMethodCalled(\"isShutdown\");\n    testExecutor.shutdown();\n    mock.assertLastMethodCalled(\"shutdown\");\n    List<Runnable> list = testExecutor.shutdownNow();\n    mock.assertLastMethodCalled(\"shutdownNow\");\n    assertEquals(ImmutableList.of(), list);\n}", "repo_id": "5", "comment": "// Uninteresting delegations\n", "repo_name": "guava-master/", "id": 3819, "method_signature": "void testDelegations()", "filename": "WrappingExecutorServiceTest.testDelegations.json"}
{"callee_method_ids": [4258, 4258, 4258, 4258, 4258, 4258, 4258, 4258, 4258], "callee_method_names": ["CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape", "CharEscaper.escape"], "method_name": "XmlEscapersTest.assertBasicXmlEscaper", "method_implementation": "{\n    // Simple examples (smoke tests)\n    assertEquals(\"xxx\", xmlEscaper.escape(\"xxx\"));\n    assertEquals(\"test &amp; test &amp; test\", xmlEscaper.escape(\"test & test & test\"));\n    assertEquals(\"test &lt;&lt; 1\", xmlEscaper.escape(\"test << 1\"));\n    assertEquals(\"test &gt;&gt; 1\", xmlEscaper.escape(\"test >> 1\"));\n    assertEquals(\"&lt;tab&gt;\", xmlEscaper.escape(\"<tab>\"));\n    // Test all non-escaped ASCII characters.\n    String s = \"!@#$%^*()_+=-/?\\\\|]}[{,.;:\" + \"abcdefghijklmnopqrstuvwxyz\" + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"1234567890\";\n    assertEquals(s, xmlEscaper.escape(s));\n    // Test ASCII control characters.\n    for (char ch = 0; ch < 0x20; ch++) {\n        if (ch == '\\t' || ch == '\\n' || ch == '\\r') {\n            // Only these whitespace chars are permitted in XML,\n            if (shouldEscapeWhitespaceChars) {\n                assertEscaping(xmlEscaper, \"&#x\" + Integer.toHexString(ch).toUpperCase() + \";\", ch);\n            } else {\n                assertUnescaped(xmlEscaper, ch);\n            }\n        } else {\n            // and everything else is replaced with FFFD.\n            assertEscaping(xmlEscaper, \"\\uFFFD\", ch);\n        }\n    }\n    // Test _all_ allowed characters (including surrogate values).\n    for (char ch = 0x20; ch <= 0xFFFD; ch++) {\n        // There are a small number of cases to consider, so just do it manually.\n        if (ch == '&') {\n            assertEscaping(xmlEscaper, \"&amp;\", ch);\n        } else if (ch == '<') {\n            assertEscaping(xmlEscaper, \"&lt;\", ch);\n        } else if (ch == '>') {\n            assertEscaping(xmlEscaper, \"&gt;\", ch);\n        } else if (shouldEscapeQuotes && ch == '\\'') {\n            assertEscaping(xmlEscaper, \"&apos;\", ch);\n        } else if (shouldEscapeQuotes && ch == '\"') {\n            assertEscaping(xmlEscaper, \"&quot;\", ch);\n        } else {\n            String input = String.valueOf(ch);\n            String escaped = xmlEscaper.escape(input);\n            assertEquals(\"char 0x\" + Integer.toString(ch, 16) + \" should not be escaped\", input, escaped);\n        }\n    }\n    // Test that 0xFFFE and 0xFFFF are replaced with 0xFFFD\n    assertEscaping(xmlEscaper, \"\\uFFFD\", '\\uFFFE');\n    assertEscaping(xmlEscaper, \"\\uFFFD\", '\\uFFFF');\n    assertEquals(\"0xFFFE is forbidden and should be replaced during escaping\", \"[\\uFFFD]\", xmlEscaper.escape(\"[\\ufffe]\"));\n    assertEquals(\"0xFFFF is forbidden and should be replaced during escaping\", \"[\\uFFFD]\", xmlEscaper.escape(\"[\\uffff]\"));\n}", "repo_id": "5", "comment": "// Helper to assert common properties of xml escapers.\n", "repo_name": "guava-master/", "id": 3654, "method_signature": "void assertBasicXmlEscaper(CharEscaper, boolean, boolean)", "filename": "XmlEscapersTest.assertBasicXmlEscaper.json"}
