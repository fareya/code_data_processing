{"A.getId": {"callee_method_names": [], "method_name": "A.getId", "method_implementation": "{\n    return \"nice!\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2541, "method_signature": "String getId()"}, "AbstractColumn.toString": {"callee_method_names": [], "method_name": "AbstractColumn.toString", "method_implementation": "{\n    final String tableName = this.getTable() != null ? this.getTable().getName() : \"N/A\";\n    final String mapping = this.getMapping() != null ? \" \" + this.getMapping().toString() + \" \" : \"\";\n    return this.getClass().getSimpleName() + mapping + \" [name=\" + this.getName() + \", type=\" + this.getSqlType() + \", length=\" + this.getLength() + \", precision=\" + this.getPrecision() + \", scale=\" + this.getScale() + \", table=\" + tableName + \"]\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1134, "method_signature": "String toString()"}, "AbstractCriteriaQueryImpl.distinct": {"callee_method_names": [], "method_name": "AbstractCriteriaQueryImpl.distinct", "method_implementation": "{\n    this.distinct = distinct;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 529, "method_signature": "AbstractQuery<T> distinct(boolean)"}, "AbstractCriteriaQueryImpl.ensureSelection": {"callee_method_names": [], "method_name": "AbstractCriteriaQueryImpl.ensureSelection", "method_implementation": "{\n    if (this.selection == null) {\n        if (this.getRoots().size() == 1) {\n            return this.selection = (AbstractSelection<T>) this.getRoots().iterator().next();\n        } else {\n            throw new PersistenceException(\"Selection is not specified\");\n        }\n    }\n    return this.selection;\n}", "repo_id": "1", "comment": "/**\n * Ensures that there is a valid selection.\n *\n * @return the selection\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 530, "method_signature": "AbstractSelection<T> ensureSelection()"}, "AbstractCriteriaQueryImpl.from": {"callee_method_names": [], "method_name": "AbstractCriteriaQueryImpl.from", "method_implementation": "{\n    final RootImpl<X> r = new RootImpl<X>((EntityTypeImpl<X>) entity);\n    this.roots.add(r);\n    return r;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 532, "method_signature": "RootImpl<X> from(EntityType)"}, "AbstractCriteriaQueryImpl.generateJpql": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "RootImpl<?>.generateJpqlJoins", "StringBuilder.append", "StringBuilder.toString", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "AbstractCriteriaQueryImpl.generateJpql", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    this.ensureSelection();\n    builder.append(\"select \");\n    // append distinct if necessary\n    if (this.distinct) {\n        builder.append(\"distinct \");\n    }\n    builder.append(this.selection.generateJpqlSelect(this, true));\n    final Collection<String> roots = Collections2.transform(this.getRoots(), new Function<Root<?>, String>() {\n\n        @Override\n        public String apply(Root<?> input) {\n            final RootImpl<?> root = (RootImpl<?>) input;\n            final StringBuilder builder = new StringBuilder(input.getModel().getName());\n            if (StringUtils.isNotBlank(input.getAlias())) {\n                builder.append(\" as \").append(input.getAlias());\n            }\n            final String joins = root.generateJpqlJoins(AbstractCriteriaQueryImpl.this);\n            if (StringUtils.isNotBlank(joins)) {\n                builder.append(\"\\n\").append(BatooUtils.indent(joins));\n            }\n            return builder.toString();\n        }\n    });\n    builder.append(\"\\nfrom \").append(Joiner.on(\", \").join(roots));\n    if (this.getRestriction() != null) {\n        builder.append(\"\\nwhere\\n\\t\").append(this.getRestriction().generateJpqlRestriction(this));\n    }\n    if (this.getGroupList().size() > 0) {\n        final String groupBy = Joiner.on(\", \").join(Lists.transform(this.getGroupList(), new Function<Expression<?>, String>() {\n\n            @Override\n            public String apply(Expression<?> input) {\n                return ((AbstractExpression<?>) input).generateJpqlRestriction(AbstractCriteriaQueryImpl.this);\n            }\n        }));\n        builder.append(\"\\ngroup by\\n\\t\").append(groupBy);\n    }\n    if (this.getGroupRestriction() != null) {\n        builder.append(\"\\nhaving\\n\\t\").append(this.getGroupRestriction().generateJpqlRestriction(this));\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 533, "method_signature": "String generateJpql()"}, "AbstractCriteriaQueryImpl.generateSql": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "List<String>.add", "RootImpl<?>.generateSqlFrom", "Map<Joinable, String>.values"], "method_name": "AbstractCriteriaQueryImpl.generateSql", "method_implementation": "{\n    this.ensureSelection();\n    AbstractCriteriaQueryImpl.LOG.debug(\"Preparing SQL for {0}\", AbstractCriteriaQueryImpl.LOG.lazyBoxed(this));\n    final Map<Joinable, String> joins = Maps.newLinkedHashMap();\n    // generate the select chunk\n    final StringBuilder select = new StringBuilder();\n    select.append(\"SELECT\");\n    if (this.distinct && !this.internal) {\n        select.append(\" DISTINCT\");\n    }\n    select.append(\"\\n\");\n    select.append(BatooUtils.indent(this.selection.generateSqlSelect(this, true)));\n    // generate from chunk\n    final List<String> froms = Lists.newArrayList();\n    for (final Root<?> r : this.getRoots()) {\n        final RootImpl<?> root = (RootImpl<?>) r;\n        froms.add(root.generateSqlFrom(this));\n    }\n    final String where = this.generateSqlRestriction();\n    final String groupBy = this.getGroupList().size() == 0 ? null : Joiner.on(\", \").join(Lists.transform(this.getGroupList(), new Function<Expression<?>, String>() {\n\n        @Override\n        public String apply(Expression<?> input) {\n            return ((AbstractExpression<?>) input).generateSqlSelect(AbstractCriteriaQueryImpl.this, false);\n        }\n    }));\n    final String having = this.getGroupRestriction() != null ? this.getGroupRestriction().generateSqlRestriction(this) : null;\n    for (final Root<?> root : this.getRoots()) {\n        ((RootImpl<?>) root).generateSqlJoins(this, joins);\n    }\n    final String from = \"FROM \" + Joiner.on(\", \").join(froms);\n    final String join = Joiner.on(\"\\n\").skipNulls().join(joins.values());\n    return //\n    Joiner.on(\"\\n\").skipNulls().//\n    join(//\n    select, //\n    from, //\n    StringUtils.isBlank(join) ? null : BatooUtils.indent(join), //\n    StringUtils.isBlank(where) ? null : \"WHERE\\n\\t\" + where, //\n    StringUtils.isBlank(groupBy) ? null : \"GROUP BY\\n\\t\" + groupBy, StringUtils.isBlank(having) ? null : \"HAVING\\n\\t\" + having);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 534, "method_signature": "String generateSql()"}, "AbstractCriteriaQueryImpl.generateSqlRestriction": {"callee_method_names": ["Iterator<Root<?>>.hasNext", "Iterator<Root<?>>.next"], "method_name": "AbstractCriteriaQueryImpl.generateSqlRestriction", "method_implementation": "{\n    final String[] restrictions = new String[this.getRoots().size() + 1];\n    if (this.getRestriction() != null) {\n        restrictions[0] = this.restriction.generateSqlRestriction(this);\n    }\n    int i = 0;\n    final Iterator<Root<?>> j = this.getRoots().iterator();\n    while (j.hasNext()) {\n        final Root<?> root = j.next();\n        restrictions[++i] = ((RootImpl<?>) root).generateDiscrimination(false);\n    }\n    final String restriction = Joiner.on(\") AND (\").skipNulls().join(restrictions);\n    if (StringUtils.isBlank(restriction)) {\n        return null;\n    }\n    return \"(\" + restriction + \")\";\n}", "repo_id": "1", "comment": "/**\n * Returns the restriction for the query.\n *\n * @return the restriction\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 535, "method_signature": "String generateSqlRestriction()"}, "AbstractCriteriaQueryImpl.getGroupList": {"callee_method_names": ["List<Expression<?>>.addAll"], "method_name": "AbstractCriteriaQueryImpl.getGroupList", "method_implementation": "{\n    final List<Expression<?>> groupList = Lists.newArrayList();\n    groupList.addAll(this.groupList);\n    return groupList;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 536, "method_signature": "List<Expression<?>> getGroupList()"}, "AbstractCriteriaQueryImpl.groupBy": {"callee_method_names": ["List<Expression<?>>.size", "List<Expression<?>>.get"], "method_name": "AbstractCriteriaQueryImpl.groupBy", "method_implementation": "{\n    this.groupList.clear();\n    for (int i = 0; i < grouping.size(); i++) {\n        this.groupList.add((AbstractExpression<?>) grouping.get(i));\n    }\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 538, "method_signature": "AbstractQuery<T> groupBy(List)"}, "AbstractCriteriaQueryImpl.having": {"callee_method_names": [], "method_name": "AbstractCriteriaQueryImpl.having", "method_implementation": "{\n    this.groupRestriction = new PredicateImpl(false, BooleanOperator.AND, restrictions);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 540, "method_signature": "AbstractQuery<T> having(Predicate[])"}, "AbstractCriteriaQueryImpl.internal": {"callee_method_names": [], "method_name": "AbstractCriteriaQueryImpl.internal", "method_implementation": "{\n    this.internal = true;\n    this.distinct(true);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * Marks the query as internal entity query.\n *\n * @return self\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 541, "method_signature": "AbstractCriteriaQueryImpl<T> internal()"}, "AbstractCriteriaQueryImpl.select": {"callee_method_names": [], "method_name": "AbstractCriteriaQueryImpl.select", "method_implementation": "{\n    this.selection = (AbstractSelection<T>) selection;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * Sets the selection\n *\n * @param selection\n *            the selection\n * @return the modified query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 542, "method_signature": "AbstractCriteriaQueryImpl<T> select(Selection)"}, "AbstractCriteriaQueryImpl.updateResultClass": {"callee_method_names": ["List<Selection<?>>.size", "List<Selection<?>>.get", "Selection<?>.getJavaType"], "method_name": "AbstractCriteriaQueryImpl.updateResultClass", "method_implementation": "{\n    if (selections.size() == 1) {\n        final Selection<?> selection = selections.get(0);\n        this.resultType = (Class<T>) selection.getJavaType();\n    } else {\n        this.resultType = (Class<T>) Object[].class;\n    }\n}", "repo_id": "1", "comment": "/**\n * @param selections\n *            the selections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 543, "method_signature": "void updateResultClass(List)"}, "AbstractCriteriaQueryImpl.where": {"callee_method_names": [], "method_name": "AbstractCriteriaQueryImpl.where", "method_implementation": "{\n    this.restriction = new PredicateImpl(false, BooleanOperator.AND, restrictions);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 545, "method_signature": "AbstractQuery<T> where(Predicate[])"}, "AbstractExpression.as": {"callee_method_names": [], "method_name": "AbstractExpression.as", "method_implementation": "{\n    if (this.getJavaType() == type) {\n        return (Expression<X>) this;\n    }\n    if (type == BigDecimal.class) {\n        this.setConverter(ExpressionConverter.BIG_DECIMAL);\n    } else if (type == BigInteger.class) {\n        this.setConverter(ExpressionConverter.BIG_INTEGER);\n    } else if (type == Double.class) {\n        this.setConverter(ExpressionConverter.DOUBLE);\n    } else if (type == Float.class) {\n        this.setConverter(ExpressionConverter.FLOAT);\n    } else if (type == Integer.class) {\n        this.setConverter(ExpressionConverter.INTEGER);\n    } else if (type == Long.class) {\n        this.setConverter(ExpressionConverter.LONG);\n    } else if (type == String.class) {\n        this.setConverter(ExpressionConverter.STRING);\n    }\n    throw new PersistenceException(\"Cannot cast to :\" + type);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 664, "method_signature": "Expression<X> as(Class)"}, "AbstractExpression.in": {"callee_method_names": [], "method_name": "AbstractExpression.in", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 665, "method_signature": "PredicateImpl in(Expression)"}, "AbstractExpression.setConverter": {"callee_method_names": [], "method_name": "AbstractExpression.setConverter", "method_implementation": "{\n    this.converter = converter;\n    return (Expression<N>) this;\n}", "repo_id": "1", "comment": "/**\n * Sets the numeric converter of the expression\n *\n * @param converter\n *            the numeric converter instance\n * @param <N>\n *            the type of the conversion\n * @return the same expression\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 666, "method_signature": "Expression<N> setConverter(ExpressionConverter)"}, "AbstractFrom.ensureAlias": {"callee_method_names": ["BaseQueryImpl<?>.getAlias"], "method_name": "AbstractFrom.ensureAlias", "method_implementation": "{\n    if (StringUtils.isBlank(this.getAlias())) {\n        this.alias(query.getAlias(this));\n    }\n}", "repo_id": "1", "comment": "/**\n * Ensure that the alias is assigned.\n *\n * @param query\n *            the criteria query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 834, "method_signature": "void ensureAlias(BaseQueryImpl)"}, "AbstractFrom.generateJpqlJoins": {"callee_method_names": ["List<String>.add", "List<String>.add", "String.generateJpqlJoins"], "method_name": "AbstractFrom.generateJpqlJoins", "method_implementation": "{\n    this.ensureAlias(criteriaQuery);\n    final List<String> joins = Lists.newArrayList();\n    if (this.selected) {\n        final String fetches = this.fetchRoot.generateJpqlFetches(this.getAlias());\n        if (StringUtils.isNotBlank(fetches)) {\n            joins.add(fetches);\n        }\n    }\n    for (final AbstractJoin<X, ?> join : this.joins) {\n        joins.add(join.generateJpqlJoins(criteriaQuery));\n    }\n    return Joiner.on(\"\\n\").join(joins);\n}", "repo_id": "1", "comment": "/**\n * Returns the JPQL joins fragment.\n *\n * @param criteriaQuery\n *            the criteria query\n * @return the JPQL joins fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 835, "method_signature": "String generateJpqlJoins(AbstractCriteriaQueryImpl)"}, "AbstractFrom.generateJpqlRestriction": {"callee_method_names": [], "method_name": "AbstractFrom.generateJpqlRestriction", "method_implementation": "{\n    this.ensureAlias(query);\n    return this.getAlias();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 836, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "AbstractFrom.generateJpqlSelect": {"callee_method_names": [], "method_name": "AbstractFrom.generateJpqlSelect", "method_implementation": "{\n    this.selected |= selected;\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 837, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "AbstractFrom.generateSqlJoins": {"callee_method_names": ["String.generateSqlJoins"], "method_name": "AbstractFrom.generateSqlJoins", "method_implementation": "{\n    this.fetchRoot.generateSqlJoins(query, joins, this.selected);\n    for (final AbstractJoin<X, ?> join : this.joins) {\n        join.generateSqlJoins(query, joins);\n    }\n}", "repo_id": "1", "comment": "/**\n * Generates SQL joins fragment.\n *\n * @param query\n *            the query\n * @param joins\n *            the map of joins\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 838, "method_signature": "void generateSqlJoins(AbstractCriteriaQueryImpl, Map)"}, "AbstractFrom.generateSqlSelect": {"callee_method_names": [], "method_name": "AbstractFrom.generateSqlSelect", "method_implementation": "{\n    this.select(selected);\n    return this.fetchRoot.generateSqlSelect(query, selected, this.getParentPath() == null);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 839, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "AbstractFrom.getCorrelationParent": {"callee_method_names": [], "method_name": "AbstractFrom.getCorrelationParent", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 840, "method_signature": "From<Z,X> getCorrelationParent()"}, "AbstractFrom.getJoins": {"callee_method_names": ["Set<Join<X, ?>>.addAll"], "method_name": "AbstractFrom.getJoins", "method_implementation": "{\n    final Set<Join<X, ?>> joins = Sets.newHashSet();\n    joins.addAll(this.joins);\n    return joins;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 841, "method_signature": "Set<Join<X,?>> getJoins()"}, "AbstractFrom.handle": {"callee_method_names": [], "method_name": "AbstractFrom.handle", "method_implementation": "{\n    if (this.entity != null) {\n        return this.fetchRoot.handle(session, row);\n    }\n    return this.fetchRoot.handleElementFetch(row).getValue();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 842, "method_signature": "X handle(QueryImpl, SessionImpl, ResultSet)"}, "AbstractFrom.isCorrelated": {"callee_method_names": [], "method_name": "AbstractFrom.isCorrelated", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 843, "method_signature": "boolean isCorrelated()"}, "AbstractFrom.join": {"callee_method_names": ["JoinedMapping<X, ?, Y>.getMappingType", "JoinedMapping<X, ?, Y>.getMappingType", "AbstractMapping<? super X, ?, ?>.getAttribute", "PluralAttributeImpl<? super X, ?, Y>.getCollectionType"], "method_name": "AbstractFrom.join", "method_implementation": "{\n    AbstractMapping<? super X, ?, ?> mapping = null;\n    if (this.entity != null) {\n        mapping = this.entity.getRootMapping().getChild(attributeName);\n    } else if (this.mapping.getMappingType() == MappingType.ELEMENT_COLLECTION) {\n        mapping = (AbstractMapping<? super X, ?, ?>) ((ElementCollectionMappingImpl<? super Z, ?, ?>) this.mapping).getMapping(attributeName);\n    } else if (this.mapping.getMappingType() == MappingType.EMBEDDABLE) {\n        mapping = (AbstractMapping<? super X, ?, ?>) ((EmbeddedMappingImpl<? super Z, ?>) this.mapping).getChild(attributeName);\n    }\n    AbstractJoin<X, Y> join = null;\n    // FIXME Remove that\n    try {\n        final JoinedMapping<X, ?, Y> joinedMapping = (JoinedMapping<X, ?, Y>) mapping;\n        if ((joinedMapping.getMappingType() == MappingType.SINGULAR_ASSOCIATION) || (joinedMapping.getMappingType() == MappingType.EMBEDDABLE)) {\n            join = new SingularJoin<X, Y>(this, joinedMapping, jt);\n        } else {\n            final PluralAttributeImpl<? super X, ?, Y> attribute = (PluralAttributeImpl<? super X, ?, Y>) mapping.getAttribute();\n            switch(attribute.getCollectionType()) {\n                case SET:\n                    join = new SetJoinImpl<X, Y>(this, (PluralMappingEx<? super X, Set<Y>, Y>) joinedMapping, jt);\n                    break;\n                case COLLECTION:\n                    join = new CollectionJoinImpl<X, Y>(this, (PluralMappingEx<? super X, Collection<Y>, Y>) joinedMapping, jt);\n                    break;\n                case LIST:\n                    join = new ListJoinImpl<X, Y>(this, (PluralMappingEx<? super X, List<Y>, Y>) joinedMapping, jt);\n                    break;\n                case MAP:\n                    join = new MapJoinImpl(this, (PluralMappingEx<? super X, Map<?, Y>, Y>) joinedMapping, jt);\n            }\n        }\n    } catch (final NullPointerException e) {\n        throw e;\n    }\n    this.joins.add(join);\n    return join;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 848, "method_signature": "AbstractJoin<X,Y> join(String, JoinType)"}, "AbstractFrom.joinCollection": {"callee_method_names": [], "method_name": "AbstractFrom.joinCollection", "method_implementation": "{\n    return (CollectionJoinImpl<X, Y>) this.join(attributeName, jt);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 849, "method_signature": "CollectionJoinImpl<X,Y> joinCollection(String, JoinType)"}, "AbstractFrom.joinList": {"callee_method_names": [], "method_name": "AbstractFrom.joinList", "method_implementation": "{\n    return (ListJoinImpl<X, Y>) this.join(attributeName, jt);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 850, "method_signature": "ListJoinImpl<X,Y> joinList(String, JoinType)"}, "AbstractFrom.joinMap": {"callee_method_names": [], "method_name": "AbstractFrom.joinMap", "method_implementation": "{\n    return (MapJoinImpl<X, K, V>) this.join(attributeName, jt);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 851, "method_signature": "MapJoinImpl<X,K,V> joinMap(String, JoinType)"}, "AbstractFrom.joinSet": {"callee_method_names": [], "method_name": "AbstractFrom.joinSet", "method_implementation": "{\n    return (SetJoinImpl<X, Y>) this.join(attributeName, jt);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 852, "method_signature": "SetJoinImpl<X,Y> joinSet(String, JoinType)"}, "AbstractFrom.type": {"callee_method_names": [], "method_name": "AbstractFrom.type", "method_implementation": "{\n    if ((this.entity != null) && (this.entity.getRootType().getInheritanceType() != null)) {\n        return new EntityTypeExpression<X>(this, this.entity.getRootType().getDiscriminatorColumn());\n    }\n    if (this.entity != null) {\n        return new StaticTypeExpression<X>(this, this.entity.getJavaType());\n    }\n    return new StaticTypeExpression<X>(this, this.getModel().getBindableJavaType());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 853, "method_signature": "Expression<Class<? extends X>> type()"}, "AbstractInternalDataSource.cropPrefixFromProperties": {"callee_method_names": ["Map<String,Object>.keySet", "Object.startsWith", "Properties.setProperty", "Object.substring", "String.length", "Map<String,Object>.get"], "method_name": "AbstractInternalDataSource.cropPrefixFromProperties", "method_implementation": "{\n    Properties cpProps = new Properties();\n    for (String key : mapProps.keySet()) {\n        if (key.startsWith(prefix)) {\n            cpProps.setProperty(key.substring(prefix.length()), (String) mapProps.get(key));\n        }\n    }\n    return cpProps;\n}", "repo_id": "1", "comment": "/**\n * remove the prefixed keys prefix and return them as pro\n * @param mapProps\n * @param prefix\n * @return\n * @throws Exception\n */\n", "repo_name": "BatooJPA-master/", "id": 1205, "method_signature": "Properties cropPrefixFromProperties(Map, String)"}, "AbstractJdbcAdaptor.applyCast": {"callee_method_names": [], "method_name": "AbstractJdbcAdaptor.applyCast", "method_implementation": "{\n    final String className = this.getCastClassName(clazz);\n    return \"CAST(\" + argument + \" AS \" + className + \")\";\n}", "repo_id": "1", "comment": "/**\n * Applies cast operation to the expression.\n *\n * @param argument\n *            the SQL argument\n * @param clazz\n *            the class to cast\n * @return the casted expression\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1312, "method_signature": "String applyCast(String, Class)"}, "AbstractJdbcAdaptor.applyTrim": {"callee_method_names": ["StringBuilder.append", "Trimspec.toString", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "AbstractJdbcAdaptor.applyTrim", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"TRIM(\");\n    if (trimspec != null) {\n        builder.append(trimspec.toString()).append(\" \");\n    }\n    if (trimChar != null) {\n        builder.append(trimChar).append(\" \");\n    }\n    if ((trimspec != null) || (trimChar != null)) {\n        builder.append(\"FROM \");\n    }\n    return builder.append(argument).append(\")\").toString();\n}", "repo_id": "1", "comment": "/**\n * Applies the trim to argument\n *\n * @param trimspec\n *            the trim spec\n * @param trimChar\n *            the trim character\n * @param argument\n *            the argument\n * @return the trim SQL fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1313, "method_signature": "String applyTrim(Trimspec, String, String)"}, "AbstractJdbcAdaptor.getAdapter": {"callee_method_names": ["JdbcAdaptor.getClass"], "method_name": "AbstractJdbcAdaptor.getAdapter", "method_implementation": "{\n    final JdbcAdaptor jdbcAdaptor = AbstractJdbcAdaptor.ADAPTERS.get(databaseProductName);\n    if (jdbcAdaptor == null) {\n        throw new PersistenceException(\"Cannot locate JDBC Adaptor for '\" + databaseProductName + \"'\");\n    }\n    try {\n        return jdbcAdaptor.getClass().newInstance();\n    } catch (final Exception e) {\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns the JDBC Adapter.\n *\n * @param classloader\n *            the class loader\n * @param databaseProductName\n *            the name of the database product\n *\n * @return the adapters\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1311, "method_signature": "JdbcAdaptor getAdapter(ClassLoader, String)"}, "AbstractJdbcAdaptor.getCastClassName": {"callee_method_names": ["Class<?>.getSimpleName"], "method_name": "AbstractJdbcAdaptor.getCastClassName", "method_implementation": "{\n    if (clazz == String.class) {\n        return \"VARCHAR\";\n    }\n    return clazz.getSimpleName();\n}", "repo_id": "1", "comment": "/**\n * Returns the clazz to DB type data type.\n *\n * @param clazz\n *            the original cast class\n * @return the converted DB type name\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1314, "method_signature": "String getCastClassName(Class)"}, "AbstractJoin.generateJpqlJoins": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "AbstractJoin.generateJpqlJoins", "method_implementation": "{\n    this.ensureAlias(criteriaQuery);\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.joinType == JoinType.LEFT ? \"left\" : \"inner\");\n    //\n    builder.append(\" join \").append(this.getParent().getAlias()).append(\".\").append(//\n    this.mapping.getAttribute().getName()).append(\" as \").append(this.getAlias());\n    final String joins = super.generateJpqlJoins(criteriaQuery);\n    if (StringUtils.isNotBlank(joins)) {\n        builder.append(\"\\n\").append(joins);\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 832, "method_signature": "String generateJpqlJoins(AbstractCriteriaQueryImpl)"}, "AbstractJoin.generateJpqlSelect": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "AbstractJoin.generateJpqlSelect", "method_implementation": "{\n    super.generateJpqlSelect(query, selected);\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.getParent().generateJpqlSelect(query, false));\n    builder.append(\".\").append(this.mapping.getAttribute().getName());\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        builder.append(\" as \").append(this.getAlias());\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 833, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "AbstractMapping.equals": {"callee_method_names": ["AbstractMapping<?, ?, ?>.getPath"], "method_name": "AbstractMapping.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    final AbstractMapping<?, ?, ?> other = (AbstractMapping<?, ?, ?>) obj;\n    return this.getPath().equals(other.getPath());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 377, "method_signature": "boolean equals(Object)"}, "AbstractMapping.get": {"callee_method_names": ["Object.getClass"], "method_name": "AbstractMapping.get", "method_implementation": "{\n    if (instance == null) {\n        return null;\n    }\n    if (!this.root && !instance.getClass().isAssignableFrom(this.getParent().getJavaType())) {\n        instance = this.getParent().get(instance);\n    }\n    return this.attribute.get(instance);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 378, "method_signature": "X get(Object)"}, "AbstractMapping.set": {"callee_method_names": ["Object.getClass", "EntityTypeImpl<? extends Object>.extendz"], "method_name": "AbstractMapping.set", "method_implementation": "{\n    if (!this.root) {\n        Z newInstance = this.parent.get(instance);\n        if (newInstance == null) {\n            newInstance = ((EmbeddedMappingImpl<?, Z>) this.parent).getAttribute().newInstance();\n            this.parent.set(instance, newInstance);\n            instance = newInstance;\n        } else {\n            instance = newInstance;\n        }\n    }\n    if (!this.inherited) {\n        this.attribute.set(instance, value);\n    } else {\n        final EntityTypeImpl<? extends Object> type = this.metamodel.getEntity(instance.getClass());\n        if (type.extendz(this.entity)) {\n            this.attribute.set(instance, value);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 379, "method_signature": "void set(Object, Object)"}, "AbstractParameterExpressionImpl.ensureTypeResolved": {"callee_method_ids": [297], "callee_method_names": ["MetamodelImpl.createBasicType"], "method_name": "AbstractParameterExpressionImpl.ensureTypeResolved", "method_implementation": "{\n    if (this.type == null) {\n        this.type = metamodel.createBasicType(this.getJavaType());\n    }\n}", "repo_id": "1", "comment": "/**\n * Ensures the type has been resolved.\n *\n * @param metamodel\n *            the metamodel\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 603, "method_signature": "void ensureTypeResolved(MetamodelImpl)"}, "AbstractParameterExpressionImpl.generateSqlSelect": {"callee_method_names": [], "method_name": "AbstractParameterExpressionImpl.generateSqlSelect", "method_implementation": "{\n    this.ensureAlias(query);\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 604, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "AbstractParameterExpressionImpl.getExpandedCount": {"callee_method_names": [], "method_name": "AbstractParameterExpressionImpl.getExpandedCount", "method_implementation": "{\n    if (this.getJavaType() == Class.class) {\n        return 1;\n    }\n    this.ensureTypeResolved(metamodelImpl);\n    if ((this.type == null) || (this.type.getPersistenceType() == PersistenceType.BASIC)) {\n        return 1;\n    } else if (this.type.getPersistenceType() == PersistenceType.EMBEDDABLE) {\n        return ((EmbeddableTypeImpl<?>) this.type).getAttributeCount();\n    }\n    return ((EntityTypeImpl<?>) this.type).getPrimaryTable().getPkColumns().size();\n}", "repo_id": "1", "comment": "/**\n * Returns the number of SQL parameters when expanded.\n *\n * @param metamodelImpl\n *            the metamodel\n * @return the number of SQL parameters when expanded\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 605, "method_signature": "int getExpandedCount(MetamodelImpl)"}, "AbstractParameterExpressionImpl.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.setNextSqlParam", "BaseQueryImpl<?>.getMetamodel"], "method_name": "AbstractParameterExpressionImpl.getSqlRestrictionFragments", "method_implementation": "{\n    this.ensureAlias(query);\n    query.setNextSqlParam(this);\n    final String[] restrictions = new String[this.getExpandedCount(query.getMetamodel())];\n    for (int i = 0; i < restrictions.length; i++) {\n        restrictions[i] = \"?\";\n    }\n    return restrictions;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 606, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "AbstractParameterExpressionImpl.setParameter": {"callee_method_ids": [300, 317], "callee_method_names": ["MetamodelImpl.entity", "EntityTypeImpl<?>.getRootType", "EntityTypeImpl<?>.getName", "MutableInt.intValue", "EntityTypeImpl<?>.getDiscriminatorValue", "MutableInt.increment", "MutableInt.intValue", "MutableInt.increment", "MetamodelImpl.type", "Object.getClass", "TypeImpl<? extends Object>.getPersistenceType", "MutableInt.intValue", "MutableInt.increment"], "method_name": "AbstractParameterExpressionImpl.setParameter", "method_implementation": "{\n    // type parameter\n    if (this.getJavaType() == Class.class) {\n        final EntityTypeImpl<?> entity = metamodel.entity((Class<?>) value);\n        if (entity == null) {\n            throw new IllegalArgumentException(\"Type is not managed: \" + value);\n        }\n        if (entity.getRootType().getInheritanceType() == null) {\n            throw new IllegalArgumentException(\"Entity does not have inheritence: \" + entity.getName());\n        }\n        parameters[sqlIndex.intValue()] = entity.getDiscriminatorValue();\n        sqlIndex.increment();\n    } else {\n        this.ensureTypeResolved(metamodel);\n        if ((this.type == null) || (this.type.getPersistenceType() == PersistenceType.BASIC)) {\n            parameters[sqlIndex.intValue()] = value;\n            sqlIndex.increment();\n        } else {\n            final TypeImpl<? extends Object> valueType = value == null ? this.type : metamodel.type(value.getClass());\n            if ((valueType != null) && (valueType.getPersistenceType() == PersistenceType.BASIC)) {\n                parameters[sqlIndex.intValue()] = value;\n                sqlIndex.increment();\n            } else if (this.type.getPersistenceType() == PersistenceType.ENTITY) {\n                final EntityTypeImpl<?> type = (EntityTypeImpl<?>) this.type;\n                this.setParameter(connection, parameters, sqlIndex, value, type);\n            } else {\n                final EmbeddableTypeImpl<?> type = (EmbeddableTypeImpl<?>) this.type;\n                this.setParameter(connection, parameters, sqlIndex, value, type);\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the parameters expanding if necessary.\n *\n * @param metamodel\n *            the metamodel\n * @param connection\n *            the connection\n * @param parameters\n *            the SQL parameters\n * @param sqlIndex\n *            the index corresponding to expanded SQL parameter\n * @param value\n *            the value to set to the parameter\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 607, "method_signature": "void setParameter(MetamodelImpl, Connection, Object[], MutableInt, Object)"}, "AbstractParentMapping.addAssociations": {"callee_method_names": ["List<AssociationMappingImpl<?,?,?>>.add"], "method_name": "AbstractParentMapping.addAssociations", "method_implementation": "{\n    for (final Mapping<? super X, ?, ?> mapping : this.children.values()) {\n        if (mapping instanceof AssociationMappingImpl) {\n            associations.add((AssociationMappingImpl<?, ?, ?>) mapping);\n        } else if (mapping instanceof AbstractParentMapping) {\n            ((AbstractParentMapping<? super X, ?>) mapping).addAssociations(associations);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the associations to the list of associations.\n *\n * @param associations\n *            the list of associations\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 382, "method_signature": "void addAssociations(List)"}, "AbstractParentMapping.addBasicMappings": {"callee_method_names": ["List<BasicMappingImpl<?,?>>.add"], "method_name": "AbstractParentMapping.addBasicMappings", "method_implementation": "{\n    for (final Mapping<? super X, ?, ?> mapping : this.children.values()) {\n        if (mapping instanceof BasicMappingImpl) {\n            mappings.add((BasicMappingImpl<?, ?>) mapping);\n        } else if (mapping instanceof AbstractParentMapping) {\n            ((AbstractParentMapping<? super X, ?>) mapping).addBasicMappings(mappings);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the basic mappings to the list of mappings.\n *\n * @param mappings\n *            the list of mappings\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 383, "method_signature": "void addBasicMappings(List)"}, "AbstractParentMapping.addJoinedMappings": {"callee_method_names": ["JoinedMapping<?, ?, ?>.isJoined", "List<JoinedMapping<?,?,?>>.add"], "method_name": "AbstractParentMapping.addJoinedMappings", "method_implementation": "{\n    for (final Mapping<? super X, ?, ?> mapping : this.children.values()) {\n        if (mapping instanceof JoinedMapping) {\n            final JoinedMapping<?, ?, ?> joinedMapping = (JoinedMapping<?, ?, ?>) mapping;\n            if ((joinedMapping.isJoined())) {\n                mappingsJoined.add(joinedMapping);\n            }\n        } else if (mapping instanceof AbstractParentMapping) {\n            ((AbstractParentMapping<? super X, ?>) mapping).addJoinedMappings(mappingsJoined);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the joined mappings to the list of mappings.\n *\n * @param mappingsJoined\n *            the list of mappings\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 384, "method_signature": "void addJoinedMappings(List)"}, "AbstractParentMapping.addPluralMappings": {"callee_method_names": ["List<PluralMappingEx<?,?,?>>.add"], "method_name": "AbstractParentMapping.addPluralMappings", "method_implementation": "{\n    for (final Mapping<? super X, ?, ?> mapping : this.children.values()) {\n        if (mapping instanceof PluralMappingEx) {\n            elementCollections.add((PluralMappingEx<?, ?, ?>) mapping);\n        } else if (mapping instanceof AbstractParentMapping) {\n            ((AbstractParentMapping<? super X, ?>) mapping).addPluralMappings(elementCollections);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the plural mappings to the list of element collections.\n *\n * @param elementCollections\n *            the list of element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 385, "method_signature": "void addPluralMappings(List)"}, "AbstractParentMapping.addSingularMappings": {"callee_method_names": ["AbstractMapping<?, ?, ?>.isCollection", "List<AbstractMapping<?,?,?>>.add"], "method_name": "AbstractParentMapping.addSingularMappings", "method_implementation": "{\n    for (final Mapping<? super X, ?, ?> mapping : this.children.values()) {\n        if (mapping instanceof AbstractParentMapping) {\n            ((AbstractParentMapping<? super X, ?>) mapping).addSingularMappings(mappings);\n        } else if (!mapping.isCollection()) {\n            mappings.add((AbstractMapping<?, ?, ?>) mapping);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the singular mappings to the list of mappings.\n *\n * @param mappings\n *            the list of mappings\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 386, "method_signature": "void addSingularMappings(List)"}, "AbstractParentMapping.createEmbeddedMapping": {"callee_method_names": ["EmbeddedAttribute<? super X,Y>.getName", "EmbeddedMappingImpl<X, Y>.createMappings"], "method_name": "AbstractParentMapping.createEmbeddedMapping", "method_implementation": "{\n    final EmbeddedMappingImpl<X, Y> mapping = new EmbeddedMappingImpl<X, Y>(this, attribute);\n    this.children.put(attribute.getName(), mapping);\n    mapping.createMappings();\n}", "repo_id": "1", "comment": "/**\n * Creates an embedded mapping for the attribute.\n *\n * @param attribute\n *            the attribute\n * @param <Y>\n *            the type of the attribute\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 387, "method_signature": "void createEmbeddedMapping(EmbeddedAttribute)"}, "AbstractParentMapping.createMappings": {"callee_method_names": ["EmbeddedAttribute<? super X,Y>.getDeclaringType", "EmbeddedAttribute<? super X,Y>.getDeclaringType", "EntityTypeImpl<X>.getRootType", "EmbeddedAttribute<? super X,Y>.getDeclaringType"], "method_name": "AbstractParentMapping.createMappings", "method_implementation": "{\n    for (final Attribute<? super X, ?> attribute : this.getType().getAttributes()) {\n        // if the declaring type is not this mapping's type then inspect\n        if (attribute.getDeclaringType() != this.getType()) {\n            // if the declaring type is mapped super type then inspect\n            if (attribute.getDeclaringType() instanceof MappedSuperclassTypeImpl) {\n                final EntityTypeImpl<X> type = (EntityTypeImpl<X>) this.getType();\n                if (type.getRootType() != type) {\n                    continue;\n                }\n            } else if (attribute.getDeclaringType() instanceof EntityTypeImpl) {\n                continue;\n            }\n        }\n        this.createMapping(attribute);\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates the mappings.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 388, "method_signature": "void createMappings()"}, "AbstractParentMapping.getEagerMappings": {"callee_method_names": ["JoinedMapping<?, ?, ?>.isEager", "List<JoinedMapping<?, ?, ?>>.add", "List<JoinedMapping<?, ?, ?>>.size", "List<JoinedMapping<?, ?, ?>>.toArray"], "method_name": "AbstractParentMapping.getEagerMappings", "method_implementation": "{\n    if (this.eagerMappings != null) {\n        return this.eagerMappings;\n    }\n    synchronized (this) {\n        if (this.eagerMappings != null) {\n            return this.eagerMappings;\n        }\n        final List<JoinedMapping<?, ?, ?>> eagerMappings = Lists.newArrayList();\n        for (final Mapping<? super X, ?, ?> mapping : this.children.values()) {\n            if (mapping instanceof JoinedMapping) {\n                final JoinedMapping<?, ?, ?> joinedMapping = (JoinedMapping<?, ?, ?>) mapping;\n                if (joinedMapping.isEager()) {\n                    eagerMappings.add(joinedMapping);\n                }\n            }\n        }\n        final JoinedMapping<?, ?, ?>[] eagerMappings0 = new JoinedMapping[eagerMappings.size()];\n        eagerMappings.toArray(eagerMappings0);\n        return this.eagerMappings = eagerMappings0;\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the eager mappings.\n *\n * @return the array of mappings eager\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 389, "method_signature": "JoinedMapping<?,?,?>[] getEagerMappings()"}, "AbstractParentMapping.inherit": {"callee_method_names": ["EmbeddedMappingImpl<X, Y>.getName"], "method_name": "AbstractParentMapping.inherit", "method_implementation": "{\n    for (final Mapping<? super X, ?, ?> mapping : children) {\n        this.children.put(mapping.getName(), mapping);\n    }\n}", "repo_id": "1", "comment": "/**\n * Inherits the mappings from the parent.\n *\n * @param children\n *            the children to inherit\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 390, "method_signature": "void inherit(Collection)"}, "AbstractPath.getRootPath": {"callee_method_names": ["AbstractPath<?>.getParentPath", "AbstractPath<?>.getParentPath"], "method_name": "AbstractPath.getRootPath", "method_implementation": "{\n    AbstractPath<?> root = this;\n    while ((root.getParentPath() != null) && !(root instanceof Joinable)) {\n        root = root.getParentPath();\n    }\n    return (Joinable) root;\n}", "repo_id": "1", "comment": "/**\n * Returns the root of the path.\n *\n * @return the root of the path\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 799, "method_signature": "Joinable getRootPath()"}, "AbstractPersistable.equals": {"callee_method_names": ["Object.getClass", "AbstractPersistable<?>.getId"], "method_name": "AbstractPersistable.equals", "method_implementation": "{\n    if (null == obj) {\n        return false;\n    }\n    if (this == obj) {\n        return true;\n    }\n    if (!this.getClass().equals(obj.getClass())) {\n        return false;\n    }\n    final AbstractPersistable<?> that = (AbstractPersistable<?>) obj;\n    return null == this.getId() ? false : this.getId().equals(that.getId());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2482, "method_signature": "boolean equals(Object)"}, "AbstractPersistable.hashCode": {"callee_method_names": [], "method_name": "AbstractPersistable.hashCode", "method_implementation": "{\n    int hashCode = 17;\n    hashCode += null == this.getId() ? 0 : this.getId().hashCode() * 31;\n    return hashCode;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2483, "method_signature": "int hashCode()"}, "AbstractPluralJoin.getMapping": {"callee_method_names": ["ElementCollectionMappingImpl<? super Z, C, E>.getType", "ElementCollectionMappingImpl<? super Z, C, E>.getMapping"], "method_name": "AbstractPluralJoin.getMapping", "method_implementation": "{\n    AbstractMapping<? super E, ?, ?> child = null;\n    if (this.getMapping().getMappingType() == MappingType.ELEMENT_COLLECTION) {\n        final ElementCollectionMappingImpl<? super Z, C, E> elementCollectionMapping = (ElementCollectionMappingImpl<? super Z, C, E>) this.getMapping();\n        if (elementCollectionMapping.getType().getPersistenceType() == PersistenceType.EMBEDDABLE) {\n            child = (AbstractMapping<? super E, ?, ?>) elementCollectionMapping.getMapping(name);\n        }\n    } else {\n        child = ((PluralAssociationMappingImpl<? super Z, C, E>) this.getMapping()).getType().getRootMapping().getChild(name);\n    }\n    if (child == null) {\n        throw this.cannotDereference(name);\n    }\n    return (AbstractMapping<? super E, CC, Y>) child;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 806, "method_signature": "AbstractMapping<? super E,CC,Y> getMapping(String)"}, "AbstractSelection.alias": {"callee_method_names": [], "method_name": "AbstractSelection.alias", "method_implementation": "{\n    if (alias == null) {\n        throw new NullPointerException();\n    }\n    this.alias = alias;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 752, "method_signature": "Selection<X> alias(String)"}, "AbstractTable.addColumn": {"callee_method_names": ["AbstractColumn.getLocator", "AbstractColumn.getName", "JoinColumn.isInsertable", "JoinColumn.isUpdatable", "JoinColumn.setVirtual", "AbstractColumn.isInsertable", "AbstractColumn.isUpdatable", "AbstractColumn.getName", "AbstractColumn.getLocator", "AbstractColumn.getLocator", "AbstractColumn.getName"], "method_name": "AbstractTable.addColumn", "method_implementation": "{\n    if ((column instanceof BasicColumn) && ((BasicColumn) column).isVersion()) {\n        if (this.versionColumn != null) {\n            throw new MappingException(\"There can be only one version column\", this.versionColumn.getLocator(), column.getLocator());\n        }\n        this.versionColumn = (BasicColumn) column;\n    }\n    final AbstractColumn existing = this.columnMap.get(column.getName());\n    if (existing != null) {\n        if (column instanceof JoinColumn) {\n            final JoinColumn joinColumn = (JoinColumn) column;\n            if (!joinColumn.isInsertable() && !joinColumn.isUpdatable()) {\n                joinColumn.setVirtual(existing);\n            }\n            return;\n        }\n        // Allow read-only access to columns already defined\n        if (!column.isInsertable() && !column.isUpdatable()) {\n            return;\n        }\n        throw new MappingException(\"Duplicate column names \" + column.getName() + \" on table \" + this.name, column.getLocator(), existing.getLocator());\n    }\n    this.columnMap.put(column.getName(), column);\n}", "repo_id": "1", "comment": "/**\n * Adds the column to the table\n *\n * @param column\n *            the column to add\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1222, "method_signature": "void addColumn(AbstractColumn)"}, "AbstractTable.generateInsertSql": {"callee_method_names": ["EntityTypeDescriptor.getName", "List<AbstractColumn>.add", "Collection<String>.size", "ColumnTransformerMetadata.getWrite", "List<AbstractColumn>.toArray", "List<AbstractColumn>.size"], "method_name": "AbstractTable.generateInsertSql", "method_implementation": "{\n    final String sqlKey = type != null ? type.getName() + size : \"\" + size;\n    String sql = this.insertSqlMap.get(sqlKey);\n    if (sql != null) {\n        // other thread finished the job for us\n        return;\n    }\n    final List<AbstractColumn> insertColumns = Lists.newArrayList();\n    // Filter out the identity physicalColumns\n    final Collection<AbstractColumn> filteredColumns = type == null ? this.columnMap.values() : Collections2.filter(this.columnMap.values(), new Predicate<AbstractColumn>() {\n\n        @Override\n        public boolean apply(AbstractColumn input) {\n            return AbstractTable.this.isInsertableColumn(type, input);\n        }\n    });\n    // prepare the names tuple in the form of \"COLNAME [, COLNAME]*\"\n    final Collection<String> columnNames = Collections2.transform(filteredColumns, new Function<AbstractColumn, String>() {\n\n        @Override\n        public String apply(AbstractColumn input) {\n            insertColumns.add(input);\n            return input.getName();\n        }\n    });\n    if (columnNames.size() == 0) {\n        // TODO investigate in others with identity\n        sql = \"INSERT INTO \" + this.getQName() + \" DEFAULT VALUES\";\n    } else {\n        final Collection<String> singleParams = Collections2.transform(filteredColumns, new Function<AbstractColumn, String>() {\n\n            @Override\n            public String apply(AbstractColumn input) {\n                String writeParam = null;\n                if (input instanceof BasicColumn) {\n                    final ColumnTransformerMetadata columnTransformer = ((BasicColumn) input).getMapping().getColumnTransformer();\n                    writeParam = columnTransformer != null ? columnTransformer.getWrite() : null;\n                }\n                writeParam = Strings.isNullOrEmpty(writeParam) ? \"?\" : writeParam;\n                return writeParam;\n            }\n        });\n        // prepare the parameters in the form of \"? [, ?]*\"\n        final String singleParamStr = \"\\t(\" + Joiner.on(\", \").join(singleParams) + \")\";\n        final String parametersStr = StringUtils.repeat(singleParamStr, \",\\n\", size);\n        final String columnNamesStr = Joiner.on(\", \").join(columnNames);\n        // INSERT INTO SCHEMA.TABLE\n        // (COL [, COL]*)\n        // VALUES (PARAM [, PARAM]*)\n        sql = //\n        \"INSERT INTO \" + this.getQName() + \"\\n(\" + columnNamesStr + //\n        \")\" + \"\\nVALUES\\n\" + parametersStr;\n    }\n    this.insertSqlMap.put(sqlKey, sql);\n    this.insertColumnsMap.put(sqlKey, insertColumns.toArray(new AbstractColumn[insertColumns.size()]));\n}", "repo_id": "1", "comment": "/**\n * Generates the insert statement for the type.\n *\n * @param type\n *            the type to generate the insert statement for\n * @param pkColumns\n *            the primary key columns\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1223, "method_signature": "void generateInsertSql(EntityTypeDescriptor, int)"}, "AbstractTable.generateUpdateSql": {"callee_method_names": ["List<AbstractColumn>.add", "List<AbstractColumn>.toArray", "List<AbstractColumn>.size", "List<AbstractColumn>.toArray", "List<AbstractColumn>.size"], "method_name": "AbstractTable.generateUpdateSql", "method_implementation": "{\n    String sql = this.updateSqlMap.get(type);\n    if (sql != null) {\n        // other thread finished the job for us\n        return;\n    }\n    final List<AbstractColumn> updateColumns = Lists.newArrayList();\n    // Filter out the identity physicalColumns\n    final Collection<AbstractColumn> filteredColumns = type == null ? this.columnMap.values() : Collections2.filter(this.columnMap.values(), new Predicate<AbstractColumn>() {\n\n        @Override\n        public boolean apply(AbstractColumn input) {\n            return AbstractTable.this.isUpdatableColumn(type, input);\n        }\n    });\n    // prepare the names tuple in the form of \"COLNAME = ? [, COLNAME = ?]*\"\n    final Collection<String> columnNames = Collections2.transform(filteredColumns, new Function<AbstractColumn, String>() {\n\n        @Override\n        public String apply(AbstractColumn input) {\n            if (!input.isPrimaryKey()) {\n                updateColumns.add(input);\n                return input.getName() + \" = ?\";\n            }\n            return null;\n        }\n    });\n    final String columnNamesStr = Joiner.on(\", \").skipNulls().join(columnNames);\n    // UPDATE SCHEMA.TABLE SET\n    // (COL [, COL]*)\n    // WHERE ID = ? [, ID = ?]*)\n    sql = //\n    \"UPDATE \" + this.getQName() + \" SET\" + \"\\n\" + //\n    columnNamesStr + \"\\nWHERE \" + this.getRestrictionSql(pkColumns);\n    if (type != null) {\n        this.updateSqlMap.put(type, sql);\n        this.updateColumnsMap.put(type, updateColumns.toArray(new AbstractColumn[updateColumns.size()]));\n    } else {\n        this.updateSql = sql;\n        this.updateColumns = updateColumns.toArray(new AbstractColumn[updateColumns.size()]);\n    }\n}", "repo_id": "1", "comment": "/**\n * Generates the update statement for the type.\n *\n * @param type\n *            the type to generate the update statement for\n *\n * @since 2.0.0\n * @param pkColumns\n */\n", "repo_name": "BatooJPA-master/", "id": 1224, "method_signature": "void generateUpdateSql(EntityTypeDescriptor, Map)"}, "AbstractTable.getColumnNames": {"callee_method_names": [], "method_name": "AbstractTable.getColumnNames", "method_implementation": "{\n    return Collections2.transform(this.columnMap.values(), new Function<AbstractColumn, String>() {\n\n        @Override\n        public String apply(AbstractColumn input) {\n            return input.getName();\n        }\n    });\n}", "repo_id": "1", "comment": "/**\n * Returns the set of column names.\n *\n * @return the set of column names\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1225, "method_signature": "Collection<String> getColumnNames()"}, "AbstractTable.getColumns": {"callee_method_names": [], "method_name": "AbstractTable.getColumns", "method_implementation": "{\n    FinalWrapper<AbstractColumn[]> wrapper = this.columns;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.columns == null) {\n                this.columns = new FinalWrapper<AbstractColumn[]>(this.columnMap.values().toArray(new AbstractColumn[this.columnMap.values().size()]));\n            }\n            wrapper = this.columns;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the array of columns the table has\n *\n * @return the array of columns the table has\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1226, "method_signature": "AbstractColumn[] getColumns()"}, "AbstractTable.getInsertSql": {"callee_method_names": ["EntityTypeDescriptor.getName"], "method_name": "AbstractTable.getInsertSql", "method_implementation": "{\n    final String sqlKey = entity != null ? entity.getName() + size : \"\" + size;\n    final String sql = this.insertSqlMap.get(sqlKey);\n    if (sql != null) {\n        // other thread finished the job for us\n        return sql;\n    }\n    this.generateInsertSql(entity, size);\n    return this.insertSqlMap.get(sqlKey);\n}", "repo_id": "1", "comment": "/**\n * Returns the insert statement for the table specifically.\n *\n * @param entity\n *            the entity to return insert statement for or null for generic SQL\n * @param size\n *            the batch size\n * @return the insert statement\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1227, "method_signature": "String getInsertSql(EntityTypeDescriptor, int)"}, "AbstractTable.getRestrictionSql": {"callee_method_names": ["List<AbstractColumn>.addAll", "Map<String,AbstractColumn>.values", "Map<String,AbstractColumn>.values", "List<AbstractColumn>.add", "List<AbstractColumn>.toArray", "List<AbstractColumn>.size"], "method_name": "AbstractTable.getRestrictionSql", "method_implementation": "{\n    FinalWrapper<String> wrapper = this.restrictionSql;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.restrictionSql == null) {\n                final List<AbstractColumn> _restrictionColumns = Lists.newArrayList();\n                _restrictionColumns.addAll(pkColumns.values());\n                String _restrictionSql = Joiner.on(\" AND \").join(Collections2.transform(pkColumns.values(), new Function<AbstractColumn, String>() {\n\n                    @Override\n                    public String apply(AbstractColumn input) {\n                        return input.getName() + \" = ?\";\n                    }\n                }));\n                if (this.versionColumn != null) {\n                    _restrictionColumns.add(this.versionColumn);\n                    _restrictionSql += \" AND \" + this.versionColumn.getName() + \" = ?\";\n                }\n                this.restrictionColumns = _restrictionColumns.toArray(new AbstractColumn[_restrictionColumns.size()]);\n                this.restrictionSql = new FinalWrapper<String>(_restrictionSql);\n            }\n            wrapper = this.restrictionSql;\n        }\n    }\n    return this.restrictionSql.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the restriction SQL fragment.\n *\n * @param pkColumns\n *            the primary key column\n * @return the restriction SQL fragment\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 1228, "method_signature": "String getRestrictionSql(Map)"}, "AbstractTable.getSelectVersionSql": {"callee_method_names": ["Map<String,AbstractColumn>.values", "List<AbstractColumn>.add", "AbstractColumn.getName", "List<AbstractColumn>.toArray", "List<AbstractColumn>.size"], "method_name": "AbstractTable.getSelectVersionSql", "method_implementation": "{\n    FinalWrapper<String> wrapper = this.versionSelectSql;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.versionSelectSql == null) {\n                AbstractColumn versionColumn = null;\n                for (final AbstractColumn column : this.getColumns()) {\n                    if ((column instanceof BasicColumn) && ((BasicColumn) column).isVersion()) {\n                        versionColumn = column;\n                    }\n                }\n                final List<AbstractColumn> selectVersionColumns = Lists.newArrayList();\n                final Collection<String> restrictions = Collections2.transform(pkColumns.values(), new Function<AbstractColumn, String>() {\n\n                    @Override\n                    public String apply(AbstractColumn input) {\n                        selectVersionColumns.add(input);\n                        return input.getName() + \" = ?\";\n                    }\n                });\n                final String restrictionStr = Joiner.on(\" AND \").join(restrictions);\n                if (versionColumn != null) {\n                    // SELECT VERSION_COLUMN FROM SCHEMA.TABLE SET\n                    // WHERE (PARAM [, PARAM]*)\n                    this.versionSelectSql = new FinalWrapper<String>(//\n                    \"SELECT \" + versionColumn.getName() + \" FROM \" + //\n                    this.getQName() + \"\\nWHERE \" + restrictionStr);\n                    this.selectVersionColumns = selectVersionColumns.toArray(new AbstractColumn[selectVersionColumns.size()]);\n                }\n            }\n            wrapper = this.versionSelectSql;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the version select statement for the table specifically.\n *\n * @param pkColumns\n *            the primary key columns\n * @return the select statement\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1229, "method_signature": "String getSelectVersionSql(Map)"}, "AbstractTable.getUpdateColumns": {"callee_method_names": [], "method_name": "AbstractTable.getUpdateColumns", "method_implementation": "{\n    if (entity == null) {\n        return this.updateColumns;\n    }\n    return this.updateColumnsMap.get(entity);\n}", "repo_id": "1", "comment": "/**\n * Returns the columns for the update.\n *\n * @param entity\n *            the entity to returns columns for or null for generic columns\n * @return the insert columns\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1230, "method_signature": "AbstractColumn[] getUpdateColumns(EntityTypeDescriptor)"}, "AbstractTable.getUpdateSql": {"callee_method_names": [], "method_name": "AbstractTable.getUpdateSql", "method_implementation": "{\n    if (entity == null) {\n        if (this.updateSql == null) {\n            this.generateUpdateSql(null, pkColumns);\n        }\n        return this.updateSql;\n    }\n    String sql = this.updateSqlMap.get(entity);\n    if (sql == null) {\n        this.generateUpdateSql(entity, pkColumns);\n        sql = this.updateSqlMap.get(entity);\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * Returns the update statement for the table specifically.\n *\n * @param entity\n *            the entity to return update statement for or null for generic SQL\n * @param pkColumns\n *            the primary key columns\n * @return the insert statement\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1231, "method_signature": "String getUpdateSql(EntityTypeDescriptor, Map)"}, "AbstractTable.getVersionUpdateSql": {"callee_method_names": [], "method_name": "AbstractTable.getVersionUpdateSql", "method_implementation": "{\n    FinalWrapper<String> wrapper = this.versionUpdateSql;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.versionUpdateSql == null) {\n                // UPDATE SCHEMA.TABLE SET\n                // VERSION = ?\n                // VALUES (PARAM [, PARAM]*)\n                // WHERE ID = ? [AND ID = ?]* AND VERSION = ?\n                this.versionUpdateSql = new FinalWrapper<String>(//\n                \"UPDATE \" + this.getQName() + \" SET\" + \"\\n\" + this.versionColumn.getName() + //\n                \" = ?\" + \"\\nWHERE \" + this.getRestrictionSql(pkColumns));\n            }\n            wrapper = this.versionUpdateSql;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the version update statement for the table specifically.\n *\n * @param pkColumns\n *            the primary key columns\n * @return the update statement\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1232, "method_signature": "String getVersionUpdateSql(Map)"}, "AbstractTypeExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "AbstractTypeExpression.generateJpqlSelect", "method_implementation": "{\n    if (this.getAlias() != null) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 650, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "AbstractTypeExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "AbstractTypeExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    final String innerExpression = //\n    this.path instanceof BasicPath ? //\n    this.path.getSqlRestrictionFragments(query)[0] : this.getSqlRestrictionFragments(query)[0];\n    if (selected) {\n        return innerExpression + \" AS \" + this.alias;\n    }\n    return innerExpression;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 651, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "Address.equals": {"callee_method_names": ["Object.getClass"], "method_name": "Address.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final Address other = (Address) obj;\n    if (this.id == null) {\n        return false;\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2206, "method_signature": "boolean equals(Object)"}, "Address.getId": {"callee_method_names": [], "method_name": "Address.getId", "method_implementation": "{\n    return this.id;\n}", "repo_id": "1", "comment": "/**\n * Returns the id.\n *\n * @return the id\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2460, "method_signature": "Integer getId()"}, "Address.hashCode": {"callee_method_names": [], "method_name": "Address.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2207, "method_signature": "int hashCode()"}, "Address.setPerson": {"callee_method_names": [], "method_name": "Address.setPerson", "method_implementation": "{\n    if (this.person != null) {\n        this.person.getAddresses().remove(this);\n    }\n    this.person = person;\n    if (this.person != null) {\n        this.person.getAddresses().add(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the person of the Address.\n *\n * @param person\n *            the person to set for Address\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2495, "method_signature": "void setPerson(Person)"}, "Address2.setPerson": {"callee_method_names": [], "method_name": "Address2.setPerson", "method_implementation": "{\n    if (this.person != null) {\n        this.person.getAddresses().remove(this);\n    }\n    this.person = person;\n    if (this.person != null) {\n        this.person.getAddresses2().add(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the person of the Address.\n *\n * @param person\n *            the person to set for Address\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2200, "method_signature": "void setPerson(Person)"}, "AggregationExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "AggregationExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 551, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "AggregationExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "AggregationExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 552, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "AggregationExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "AggregationExpression.getSqlRestrictionFragments", "method_implementation": "{\n    return new String[] { MessageFormat.format(this.type.sqlFragment, this.x.getSqlRestrictionFragments(query)[0]) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 553, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "AggregationExpression.handle": {"callee_method_names": ["ResultSet.getLong", "ResultSet.getDouble", "ResultSet.getObject"], "method_name": "AggregationExpression.handle", "method_implementation": "{\n    if (this.getJavaType() == Long.class) {\n        return (T) (Long) row.getLong(this.alias);\n    }\n    if (this.getJavaType() == Double.class) {\n        return (T) (Double) row.getDouble(this.alias);\n    }\n    return (T) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 554, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "AggregationTest.prepareCountries": {"callee_method_names": [], "method_name": "AggregationTest.prepareCountries", "method_implementation": "{\n    this.begin();\n    this.persist(AggregationTest.TR);\n    this.persist(AggregationTest.USA);\n    this.persist(AggregationTest.UK);\n    this.persist(AggregationTest.BROKEN);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2395, "method_signature": "void prepareCountries()"}, "AggregationTest.testAgregation": {"callee_method_names": [], "method_name": "AggregationTest.testAgregation", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    final String testMode = System.getProperty(\"testMode\");\n    String qlString = \"select avg(func(cast, '(', p.age, ' as double)')) from Person p\";\n    if (\"mysql\".equals(testMode) || \"pgsql\".equals(testMode)) {\n        qlString = \"select avg(p.age) from Person p\";\n    } else if (\"mssql\".equals(testMode)) {\n        qlString = \"select avg(func(cast, '(', p.age, ' as float)')) from Person p\";\n    } else if (\"oracle\".equals(testMode)) {\n        qlString = \"select avg(func(cast, '(', p.age, ' as double precision)')) from Person p\";\n    }\n    Assert.assertEquals(37.5d, this.cq(qlString, Number.class).getSingleResult().doubleValue());\n    Assert.assertEquals(75, this.cq(\"select sum(p.age) from Person p\", Number.class).getSingleResult().intValue());\n    Assert.assertEquals(40, this.cq(\"select max(p.age) from Person p\", Number.class).getSingleResult().intValue());\n    Assert.assertEquals(35, this.cq(\"select min(p.age) from Person p\", Number.class).getSingleResult().intValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2396, "method_signature": "void testAgregation()"}, "AggregationTest.testAgregation2": {"callee_method_names": [], "method_name": "AggregationTest.testAgregation2", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    Assert.assertEquals(70, ((Number) this.cq(\"select p.age, sum(p.age) from Person p group by p.age order by p.age\", Object[].class).getResultList().get(0)[1]).intValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2397, "method_signature": "void testAgregation2()"}, "AggregationTest.testCount": {"callee_method_names": [], "method_name": "AggregationTest.testCount", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    Assert.assertEquals((Long) 4l, this.cq(\"select count(p.age) from Person p\", Long.class).getSingleResult());\n    Assert.assertEquals((Long) 2l, this.cq(\"select count(distinct p.age) from Person p\", Long.class).getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2398, "method_signature": "void testCount()"}, "AggregationTest.testHaving": {"callee_method_names": [], "method_name": "AggregationTest.testHaving", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    Assert.assertEquals(2l, this.cq(\"select p.age, count(p.age) from Person p group by p.age having p.age > 35\", Object[].class).getSingleResult()[1]);\n    Assert.assertEquals(1l, this.cq(\"select p.age, count(distinct p.age) from Person p group by p.age having p.age > 35\", Object[].class).getSingleResult()[1]);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2399, "method_signature": "void testHaving()"}, "AndroidPersistenceParserImpl.getSharedCacheMode": {"callee_method_names": ["PersistenceUnitCachingType.name"], "method_name": "AndroidPersistenceParserImpl.getSharedCacheMode", "method_implementation": "{\n    final PersistenceUnitCachingType cacheMode = this.persistenceUnit.getSharedCacheMode();\n    return cacheMode == null ? SharedCacheMode.NONE : SharedCacheMode.valueOf(cacheMode.name());\n}", "repo_id": "1", "comment": "/**\n * Returns the specification of how the provider must use a second-level cache for the persistence unit.\n *\n * @return the second-level cache mode that must be used by the provider for the persistence unit\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 970, "method_signature": "SharedCacheMode getSharedCacheMode()"}, "ArithmeticExression.generateJpqlSelect": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ArithmeticExression.generateJpqlSelect", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.x.generateJpqlRestriction(query));\n    builder.append(this.operation.getFragment());\n    builder.append(this.y.generateJpqlRestriction(query));\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        builder.append(\" as \").append(this.getAlias());\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 585, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "ArithmeticExression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "ArithmeticExression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 586, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "ArithmeticExression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "ArithmeticExression.getSqlRestrictionFragments", "method_implementation": "{\n    return new String[] { //\n    this.x.getSqlRestrictionFragments(query)[0] + //\n    this.operation.getFragment() + this.y.getSqlRestrictionFragments(query)[0] };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 587, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "ArithmeticExression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "ArithmeticExression.handle", "method_implementation": "{\n    final N value = (N) row.getObject(this.alias);\n    return (N) (this.getConverter() != null ? this.getConverter().convert(value) : value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 588, "method_signature": "N handle(QueryImpl, SessionImpl, ResultSet)"}, "Assert.doesNotContain": {"callee_method_names": ["String.indexOf"], "method_name": "Assert.doesNotContain", "method_implementation": "{\n    if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) && (textToSearch.indexOf(substring) != -1)) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that the given text does not contain the given substring.\n *\n * <pre class=\"code\">\n * Assert.doesNotContain(name, &quot;rod&quot;, &quot;Name must not contain 'rod'&quot;);\n * </pre>\n *\n * @param textToSearch\n *            the text to search\n * @param substring\n *            the substring to find within the text\n * @param message\n *            the exception message to use if the assertion fails\n */\n", "repo_name": "BatooJPA-master/", "id": 156, "method_signature": "void doesNotContain(String, String, String)"}, "Assert.hasLength": {"callee_method_names": [], "method_name": "Assert.hasLength", "method_implementation": "{\n    if (!StringUtils.hasLength(text)) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that the given String is not empty; that is, it must not be <code>null</code> and not the empty String.\n *\n * <pre class=\"code\">\n * Assert.hasLength(name, &quot;Name must not be empty&quot;);\n * </pre>\n *\n * @param text\n *            the String to check\n * @param message\n *            the exception message to use if the assertion fails\n * @see StringUtils#hasLength\n */\n", "repo_name": "BatooJPA-master/", "id": 157, "method_signature": "void hasLength(String, String)"}, "Assert.hasText": {"callee_method_names": [], "method_name": "Assert.hasText", "method_implementation": "{\n    if (!StringUtils.hasText(text)) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that the given String has valid text content; that is, it must not be <code>null</code> and must contain at least one\n * non-whitespace character.\n *\n * <pre class=\"code\">\n * Assert.hasText(name, &quot;'name' must not be empty&quot;);\n * </pre>\n *\n * @param text\n *            the String to check\n * @param message\n *            the exception message to use if the assertion fails\n * @see StringUtils#hasText\n */\n", "repo_name": "BatooJPA-master/", "id": 158, "method_signature": "void hasText(String, String)"}, "Assert.isAssignable": {"callee_method_names": ["Class<?>.isAssignableFrom"], "method_name": "Assert.isAssignable", "method_implementation": "{\n    Assert.notNull(superType, \"Type to check against must not be null\");\n    if ((subType == null) || !superType.isAssignableFrom(subType)) {\n        throw new IllegalArgumentException(message + subType + \" is not assignable to \" + superType);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that <code>superType.isAssignableFrom(subType)</code> is <code>true</code>.\n *\n * <pre class=\"code\">\n * Assert.isAssignable(Number.class, myClass);\n * </pre>\n *\n * @param superType\n *            the super type to check against\n * @param subType\n *            the sub type to check\n * @param message\n *            a message which will be prepended to the message produced by the function itself, and which may be used to provide\n *            context. It should normally end in a \": \" or \". \" so that the function generate message looks ok when prepended to it.\n * @throws IllegalArgumentException\n *             if the classes are not assignable\n */\n", "repo_name": "BatooJPA-master/", "id": 159, "method_signature": "void isAssignable(Class, Class, String)"}, "Assert.isInstanceOf": {"callee_method_names": ["Class<?>.isInstance", "Object.getClass"], "method_name": "Assert.isInstanceOf", "method_implementation": "{\n    Assert.notNull(type, \"Type to check against must not be null\");\n    if (!type.isInstance(obj)) {\n        throw new IllegalArgumentException(message + \". Object of class [\" + (obj != null ? obj.getClass().getName() : \"null\") + \"] must be an instance of \" + type);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that the provided object is an instance of the provided class.\n *\n * <pre class=\"code\">\n * Assert.instanceOf(Foo.class, foo);\n * </pre>\n *\n * @param type\n *            the type to check against\n * @param obj\n *            the object to check\n * @param message\n *            a message which will be prepended to the message produced by the function itself, and which may be used to provide\n *            context. It should normally end in a \": \" or \". \" so that the function generate message looks ok when prepended to it.\n * @throws IllegalArgumentException\n *             if the object is not an instance of clazz\n * @see Class#isInstance\n */\n", "repo_name": "BatooJPA-master/", "id": 160, "method_signature": "void isInstanceOf(Class, Object, String)"}, "Assert.isNull": {"callee_method_names": [], "method_name": "Assert.isNull", "method_implementation": "{\n    if (object != null) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that an object is <code>null</code> .\n *\n * <pre class=\"code\">\n * Assert.isNull(value, &quot;The value must be null&quot;);\n * </pre>\n *\n * @param object\n *            the object to check\n * @param message\n *            the exception message to use if the assertion fails\n * @throws IllegalArgumentException\n *             if the object is not <code>null</code>\n */\n", "repo_name": "BatooJPA-master/", "id": 161, "method_signature": "void isNull(Object, String)"}, "Assert.isTrue": {"callee_method_names": [], "method_name": "Assert.isTrue", "method_implementation": "{\n    if (!expression) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert a boolean expression, throwing <code>IllegalArgumentException</code> if the test result is <code>false</code>.\n *\n * <pre class=\"code\">\n * Assert.isTrue(i &gt; 0, &quot;The value must be greater than zero&quot;);\n * </pre>\n *\n * @param expression\n *            a boolean expression\n * @param message\n *            the exception message to use if the assertion fails\n * @throws IllegalArgumentException\n *             if expression is <code>false</code>\n */\n", "repo_name": "BatooJPA-master/", "id": 162, "method_signature": "void isTrue(boolean, String)"}, "Assert.noNullElements": {"callee_method_names": [], "method_name": "Assert.noNullElements", "method_implementation": "{\n    if (array != null) {\n        for (final Object element : array) {\n            if (element == null) {\n                throw new IllegalArgumentException(message);\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that an array has no null elements. Note: Does not complain if the array is empty!\n *\n * <pre class=\"code\">\n * Assert.noNullElements(array, &quot;The array must have non-null elements&quot;);\n * </pre>\n *\n * @param array\n *            the array to check\n * @param message\n *            the exception message to use if the assertion fails\n * @throws IllegalArgumentException\n *             if the object array contains a <code>null</code> element\n */\n", "repo_name": "BatooJPA-master/", "id": 163, "method_signature": "void noNullElements(Object[], String)"}, "Assert.notBlank": {"callee_method_names": [], "method_name": "Assert.notBlank", "method_implementation": "{\n    if (StringUtils.isBlank(string)) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that a string is not null, and has charachters other than white space characters.\n *\n * <pre class=\"code\">\n * Assert.notEmpty(string, &quot;String must have elements&quot;);\n * </pre>\n *\n * @param string\n *            the string to check\n * @param message\n *            the exception message to use if the assertion fails\n * @throws IllegalArgumentException\n *             if the string is empty\n */\n", "repo_name": "BatooJPA-master/", "id": 164, "method_signature": "void notBlank(String, String)"}, "Assert.notEmpty": {"callee_method_names": [], "method_name": "Assert.notEmpty", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that an array has elements; that is, it must not be <code>null</code> and must have at least one element.\n *\n * <pre class=\"code\">\n * Assert.notEmpty(array, &quot;The array must have elements&quot;);\n * </pre>\n *\n * @param array\n *            the array to check\n * @param message\n *            the exception message to use if the assertion fails\n * @throws IllegalArgumentException\n *             if the object array is <code>null</code> or has no elements\n */\n", "repo_name": "BatooJPA-master/", "id": 167, "method_signature": "void notEmpty(Object[], String)"}, "Assert.notNull": {"callee_method_names": [], "method_name": "Assert.notNull", "method_implementation": "{\n    if (object == null) {\n        throw new IllegalArgumentException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert that an object is not <code>null</code> .\n *\n * <pre class=\"code\">\n * Assert.notNull(clazz, &quot;The class must not be null&quot;);\n * </pre>\n *\n * @param object\n *            the object to check\n * @param message\n *            the exception message to use if the assertion fails\n * @throws IllegalArgumentException\n *             if the object is <code>null</code>\n */\n", "repo_name": "BatooJPA-master/", "id": 168, "method_signature": "void notNull(Object, String)"}, "Assert.state": {"callee_method_names": [], "method_name": "Assert.state", "method_implementation": "{\n    if (!expression) {\n        throw new IllegalStateException(message);\n    }\n}", "repo_id": "1", "comment": "/**\n * Assert a boolean expression, throwing <code>IllegalStateException</code> if the test result is <code>false</code>. Call isTrue if you\n * wish to throw IllegalArgumentException on an assertion failure.\n *\n * <pre class=\"code\">\n * Assert.state(id == null, &quot;The id property must not already be initialized&quot;);\n * </pre>\n *\n * @param expression\n *            a boolean expression\n * @param message\n *            the exception message to use if the assertion fails\n * @throws IllegalStateException\n *             if expression is <code>false</code>\n */\n", "repo_name": "BatooJPA-master/", "id": 169, "method_signature": "void state(boolean, String)"}, "AssociatedSingularAttribute.getType": {"callee_method_names": [], "method_name": "AssociatedSingularAttribute.getType", "method_implementation": "{\n    if (this.type == null) {\n        this.type = this.getMetamodel().entity(this.getBindableJavaType());\n    }\n    return this.type;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 283, "method_signature": "EntityTypeImpl<T> getType()"}, "AssociatedSingularAttribute.toString": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "AssociatedSingularAttribute.toString", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"association\").append(super.toString());\n    if (this.getPersistentAttributeType() == PersistentAttributeType.MANY_TO_ONE) {\n        if (this.isOptional()) {\n            builder.append(\" <*..0>\");\n        } else {\n            builder.append(\" <*..1>\");\n        }\n    } else {\n        if (this.isOptional()) {\n            builder.append(\" <0..1>\");\n        } else {\n            builder.append(\" <1..1>\");\n        }\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 284, "method_signature": "String toString()"}, "AssociationAttributeMetadataImpl.handleId": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "AssociationAttributeMetadataImpl.handleId", "method_implementation": "{\n    final Id annotation = ReflectHelper.getAnnotation(member, Id.class);\n    if (annotation != null) {\n        parsed.add(Id.class);\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link Id} annotation on OneToOne and ManyToOne annotations.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1027, "method_signature": "boolean handleId(Member, Set)"}, "AssociationAttributeMetadataImpl.handleMapKey": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKey.name"], "method_name": "AssociationAttributeMetadataImpl.handleMapKey", "method_implementation": "{\n    final MapKey annotation = ReflectHelper.getAnnotation(member, MapKey.class);\n    if (annotation != null) {\n        parsed.add(MapKey.class);\n        return annotation.name();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKey} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1028, "method_signature": "String handleMapKey(Member, Set)"}, "AssociationAttributeMetadataImpl.handleMapKeyClassName": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKeyClass.value"], "method_name": "AssociationAttributeMetadataImpl.handleMapKeyClassName", "method_implementation": "{\n    final MapKeyClass annotation = ReflectHelper.getAnnotation(member, MapKeyClass.class);\n    if (annotation != null) {\n        parsed.add(MapKeyClass.class);\n        return annotation.value().getName();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyClass} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1029, "method_signature": "String handleMapKeyClassName(Member, Set)"}, "AssociationAttributeMetadataImpl.handleMapKeyColumn": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "AssociationAttributeMetadataImpl.handleMapKeyColumn", "method_implementation": "{\n    final MapKeyColumn annotation = ReflectHelper.getAnnotation(member, MapKeyColumn.class);\n    if (annotation != null) {\n        parsed.add(MapKeyColumn.class);\n        return new ColumnMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyColumn} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1030, "method_signature": "ColumnMetadata handleMapKeyColumn(Member, Set)"}, "AssociationAttributeMetadataImpl.handleMapKeyEnumType": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKeyEnumerated.value"], "method_name": "AssociationAttributeMetadataImpl.handleMapKeyEnumType", "method_implementation": "{\n    final MapKeyEnumerated annotation = ReflectHelper.getAnnotation(member, MapKeyEnumerated.class);\n    if (annotation != null) {\n        parsed.add(MapKeyEnumerated.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyEnumerated} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1031, "method_signature": "EnumType handleMapKeyEnumType(Member, Set)"}, "AssociationAttributeMetadataImpl.handleMapKeyTemporalType": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKeyTemporal.value"], "method_name": "AssociationAttributeMetadataImpl.handleMapKeyTemporalType", "method_implementation": "{\n    final MapKeyTemporal annotation = ReflectHelper.getAnnotation(member, MapKeyTemporal.class);\n    if (annotation != null) {\n        parsed.add(MapKeyTemporal.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyTemporal} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1032, "method_signature": "TemporalType handleMapKeyTemporalType(Member, Set)"}, "AssociationAttributeMetadataImpl.handleMapsId": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapsId.value"], "method_name": "AssociationAttributeMetadataImpl.handleMapsId", "method_implementation": "{\n    final MapsId annotation = ReflectHelper.getAnnotation(member, MapsId.class);\n    if (annotation != null) {\n        parsed.add(MapsId.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapsId} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1033, "method_signature": "String handleMapsId(Member, Set)"}, "AssociationAttributeMetadataImpl.handleOrderBy": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "OrderBy.value"], "method_name": "AssociationAttributeMetadataImpl.handleOrderBy", "method_implementation": "{\n    final OrderBy annotation = ReflectHelper.getAnnotation(member, OrderBy.class);\n    if (annotation != null) {\n        parsed.add(OrderBy.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link OrderBy} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1034, "method_signature": "String handleOrderBy(Member, Set)"}, "AssociationAttributeMetadataImpl.handleOrderColumn": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "AssociationAttributeMetadataImpl.handleOrderColumn", "method_implementation": "{\n    final OrderColumn annotation = ReflectHelper.getAnnotation(member, OrderColumn.class);\n    if (annotation != null) {\n        parsed.add(OrderColumn.class);\n        return new ColumnMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link OrderColumn} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1035, "method_signature": "ColumnMetadata handleOrderColumn(Member, Set)"}, "AssociationElement.generate": {"callee_method_names": [], "method_name": "AssociationElement.generate", "method_implementation": "{\n    super.generate();\n    this.targetEntity = this.getAttribute(ElementConstants.ATTR_TARGET_ENTITY, ElementConstants.EMPTY);\n    this.fetchType = FetchType.valueOf(this.getAttribute(ElementConstants.ATTR_FETCH, this.fetchType.name()));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1107, "method_signature": "void generate()"}, "AssociationElement.handleChild": {"callee_method_names": [], "method_name": "AssociationElement.handleChild", "method_implementation": "{\n    if (child instanceof CascadesElement) {\n        this.cascades = ((CascadesElement) child).getCascades();\n    }\n    if (child instanceof JoinColumnElement) {\n        this.joinColumns.add((JoinColumnMetadata) child);\n    }\n    if (child instanceof JoinTableElement) {\n        this.joinTable = (JoinTableMetadata) child;\n    }\n    if (child instanceof PrimaryKeyJoinColumnElement) {\n        this.primaryKeyJoinColumns.add((PrimaryKeyJoinColumnMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1108, "method_signature": "void handleChild(Element)"}, "AssociationMappingImpl.getAssociationMetadata": {"callee_method_names": ["AttributeImpl<?, ?>.getDeclaringType", "AttributeImpl<?, ?>.getDeclaringType"], "method_name": "AssociationMappingImpl.getAssociationMetadata", "method_implementation": "{\n    AssociationMetadata metadata = null;\n    final String path = this.getParent().getRootPath(this.getName());\n    final AttributeImpl<?, ?> rootAttribute = this.getParent().getRootAttribute(this.getAttribute());\n    /**\n     * The priorities are like below:\n     *\n     * 1. If the root attribute is defined in the root type (thus the entity) then locate the association override on the attribute\n     * chain<br />\n     * 2. If the root attribute is defined in a parent mapped super class then locate the association on the entity<br />\n     * 3. If the parent is an embeddable mapping then locate the attribute override again on the association chain<br />\n     * 4. return the association metadata from the attribute<br />\n     */\n    // Clause 1\n    if ((rootAttribute.getDeclaringType() == this.getRoot().getType()) && (this.getParent() instanceof EmbeddedMappingImpl)) {\n        metadata = ((EmbeddedMappingImpl<?, ?>) this.getParent()).getAssociationOverride(path);\n        if (metadata != null) {\n            return metadata;\n        }\n    }\n    // Clause 2\n    if (rootAttribute.getDeclaringType() instanceof MappedSuperclassTypeImpl) {\n        metadata = ((EntityTypeImpl<Y>) this.getRoot().getType()).getAssociationOverride(path);\n        if (metadata != null) {\n            return metadata;\n        }\n    }\n    // Clause 3\n    if (this.getParent() instanceof EmbeddedMappingImpl) {\n        metadata = ((EmbeddedMappingImpl<?, ?>) this.getParent()).getAssociationOverride(path);\n        if (metadata != null) {\n            return metadata;\n        }\n    }\n    // Clause 4: fall back to attribute's column metadata\n    return (AssociationMetadata) this.getAttribute().getMetadata();\n}", "repo_id": "1", "comment": "/**\n * Returns the effective association metadata for the attribute checking with the parent mappings and entities.\n *\n * @return the column metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 374, "method_signature": "AssociationMetadata getAssociationMetadata()"}, "AssociationMappingImpl.getSelectCriteria": {"callee_method_ids": [300], "callee_method_names": ["MetamodelImpl.getEntityManagerFactory", "MetamodelImpl.entity"], "method_name": "AssociationMappingImpl.getSelectCriteria", "method_implementation": "{\n    if (this.selectCriteria != null) {\n        return this.selectCriteria;\n    }\n    synchronized (this) {\n        // other thread prepared before this one\n        if (this.selectCriteria != null) {\n            return this.selectCriteria;\n        }\n        final MetamodelImpl metamodel = ((EntityTypeImpl<?>) this.getRoot().getType()).getMetamodel();\n        final CriteriaBuilderImpl cb = metamodel.getEntityManagerFactory().getCriteriaBuilder();\n        @SuppressWarnings(\"unchecked\")\n        final Class<Y> bindableType = (Class<Y>) (this.getAttribute() instanceof PluralAttributeImpl ? ((PluralAttributeImpl<?, ?, ?>) this.getAttribute()).getBindableJavaType() : ((SingularAttributeImpl<?, ?>) this.getAttribute()).getBindableJavaType());\n        final EntityTypeImpl<Y> entity = metamodel.entity(bindableType);\n        this.ownerSelect = this.isOwner() || PersistentAttributeType.MANY_TO_MANY == getAttribute().getPersistentAttributeType();\n        if (this.ownerSelect) {\n            return this.generateOwnerSelectCriteria(metamodel, cb, bindableType, entity);\n        } else {\n            return this.generateMappedSelectCriteria(metamodel, cb, bindableType, entity);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the select criteria.\n *\n * @return the select criteria\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 375, "method_signature": "CriteriaQueryImpl<Y> getSelectCriteria()"}, "AssociationMappingImpl.join": {"callee_method_names": [], "method_name": "AssociationMappingImpl.join", "method_implementation": "{\n    if (this.getForeignKey() != null) {\n        return this.getForeignKey().createDestinationJoin(joinType, parentAlias, alias);\n    } else if ((this.getInverse() != null) && (this.getInverse().getForeignKey() != null)) {\n        return this.getInverse().getForeignKey().createSourceJoin(joinType, parentAlias, alias);\n    } else if (this.getJoinTable() != null) {\n        return this.getJoinTable().createJoin(joinType, parentAlias, alias, true);\n    } else {\n        return this.getInverse().getJoinTable().createJoin(joinType, parentAlias, alias, false);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 376, "method_signature": "String join(String, String, JoinType)"}, "AssociationOverrideElement.handleChild": {"callee_method_names": [], "method_name": "AssociationOverrideElement.handleChild", "method_implementation": "{\n    if (child instanceof JoinColumnElement) {\n        this.joinColumns.add((JoinColumnMetadata) child);\n    }\n    if (child instanceof JoinTableElement) {\n        this.joinTable = (JoinTableMetadata) child;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1062, "method_signature": "void handleChild(Element)"}, "AttributeElement.equals": {"callee_method_names": [], "method_name": "AttributeElement.equals", "method_implementation": "{\n    if (object == null) {\n        return false;\n    }\n    // if the object is a string provide equality based on name and object equality\n    if (object instanceof String) {\n        return this.name.equals(object);\n    }\n    // provide equality based on this attribute's name and the object's name\n    return this.name.equals(((AttributeMetadata) object).getName());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1113, "method_signature": "boolean equals(Object)"}, "AttributeElement.generate": {"callee_method_names": [], "method_name": "AttributeElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n    this.access = this.getAttribute(ElementConstants.ATTR_ACCESS) != null ? AccessType.valueOf(this.getAttribute(ElementConstants.ATTR_ACCESS)) : null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1114, "method_signature": "void generate()"}, "AttributeImpl.get": {"callee_method_names": [], "method_name": "AttributeImpl.get", "method_implementation": "{\n    if (instance == null) {\n        return null;\n    }\n    return (Y) this.accessor.get(instance);\n}", "repo_id": "1", "comment": "/**\n * Returns the attribute value of instance.\n *\n * @param instance\n *            the instance of which the value to be returned\n * @return the attribute value of instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 288, "method_signature": "Y get(Object)"}, "AttributeMetadataImpl.toString": {"callee_method_names": [], "method_name": "AttributeMetadataImpl.toString", "method_implementation": "{\n    return //\n    new ToStringBuilder(this).excludeFieldNames(//\n    \"access\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1036, "method_signature": "String toString()"}, "AttributeOverrideElement.handleChild": {"callee_method_names": [], "method_name": "AttributeOverrideElement.handleChild", "method_implementation": "{\n    if (child instanceof ColumnElement) {\n        this.column = (ColumnMetadata) child;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1120, "method_signature": "void handleChild(Element)"}, "AttributesElement.handleChild": {"callee_method_names": [], "method_name": "AttributesElement.handleChild", "method_implementation": "{\n    if (child instanceof TransientElement) {\n        this.getTransients().add((TransientAttributeMetadata) child);\n    }\n    if (child instanceof IdAttributeElement) {\n        this.ids.add((IdAttributeElement) child);\n    }\n    if (child instanceof EmbeddedIdAttributeElement) {\n        this.embeddedIds.add((EmbeddedIdAttributeElement) child);\n    }\n    if (child instanceof VersionAttributeElement) {\n        this.versions.add((VersionAttributeElement) child);\n    }\n    if (child instanceof BasicAttributeElement) {\n        this.basics.add((BasicAttributeElement) child);\n    }\n    if (child instanceof EmbeddedAttributeElement) {\n        this.embeddeds.add((EmbeddedAttributeMetadata) child);\n    }\n    if (child instanceof ElementCollectionAttributeElement) {\n        this.elementCollections.add((ElementCollectionAttributeMetadata) child);\n    }\n    if (child instanceof OneToOneAttributeMetadata) {\n        this.oneToOnes.add((OneToOneAttributeMetadata) child);\n    }\n    if (child instanceof OneToManyAttributeMetadata) {\n        this.oneToManies.add((OneToManyAttributeMetadata) child);\n    }\n    if (child instanceof ManyToOneAttributeMetadata) {\n        this.manyToOnes.add((ManyToOneAttributeMetadata) child);\n    }\n    if (child instanceof ManyToManyAttributeMetadata) {\n        this.manyToManies.add((ManyToManyAttributeMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1103, "method_signature": "void handleChild(Element)"}, "AttributesMetadataImpl.consolidateAttributes": {"callee_method_names": ["PluralAttributeImpl<? super X, ?, Y>.getName", "AttributeMetadata.getLocator", "PluralAttributeImpl<? super X, ?, Y>.getLocator", "PluralAttributeImpl<? super X, ?, Y>.getName"], "method_name": "AttributesMetadataImpl.consolidateAttributes", "method_implementation": "{\n    for (final AttributeMetadata attribute : attributes) {\n        final AttributeMetadata existing = this.ormAttributeMap.get(attribute.getName());\n        if (existing != null) {\n            throw new MappingException(\"Duplicate attribute names.\", existing.getLocator(), attribute.getLocator());\n        }\n        this.ormAttributeMap.put(attribute.getName(), attribute);\n    }\n}", "repo_id": "1", "comment": "/**\n * Consolidates a partition of attributes.\n *\n * @param attributes\n *            the list of attributes to consolidate\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1010, "method_signature": "void consolidateAttributes(List)"}, "AttributesMetadataImpl.handleBasics": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleBasics", "method_implementation": "{\n    final List<BasicAttributeMetadata> list = this.metadata != null ? this.metadata.getBasics() : null;\n    return new AttributesParser<BasicAttributeMetadata>(this.memberMap, list, null) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected BasicAttributeMetadata parseAttribute(String name, Member member, BasicAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new BasicAttributeMetadataImpl(member, metadata);\n            } else {\n                return new BasicAttributeMetadataImpl(member, name, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the basic attributes.\n *\n * @return the list of basic attributes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1011, "method_signature": "List<BasicAttributeMetadata> handleBasics()"}, "AttributesMetadataImpl.handleElementCollections": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleElementCollections", "method_implementation": "{\n    final List<ElementCollectionAttributeMetadata> list = this.metadata != null ? this.metadata.getElementCollections() : null;\n    return new AttributesParser<ElementCollectionAttributeMetadata>(this.memberMap, list, ElementCollection.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected ElementCollectionAttributeMetadata parseAttribute(String name, Member member, ElementCollectionAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new ElementCollectionAttributeMetadataImpl(member, metadata);\n            } else {\n                final ElementCollection elementCollection = ReflectHelper.getAnnotation(member, ElementCollection.class);\n                return new ElementCollectionAttributeMetadataImpl(member, name, elementCollection, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the element collection attributes.\n *\n * @return list of element collections attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1012, "method_signature": "List<ElementCollectionAttributeMetadata> handleElementCollections()"}, "AttributesMetadataImpl.handleEmbeddedIds": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleEmbeddedIds", "method_implementation": "{\n    final List<EmbeddedIdAttributeMetadata> list = this.metadata != null ? this.metadata.getEmbeddedIds() : null;\n    return new AttributesParser<EmbeddedIdAttributeMetadata>(this.memberMap, list, EmbeddedId.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected EmbeddedIdAttributeMetadata parseAttribute(String name, Member member, EmbeddedIdAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new EmbeddedIdAttributeMetadataImpl(member, metadata);\n            } else {\n                return new EmbeddedIdAttributeMetadataImpl(member, name, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the embedded id attributes.\n *\n * @return list of embedded ids.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1013, "method_signature": "List<EmbeddedIdAttributeMetadata> handleEmbeddedIds()"}, "AttributesMetadataImpl.handleEmbeddeds": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleEmbeddeds", "method_implementation": "{\n    final List<EmbeddedAttributeMetadata> list = this.metadata != null ? this.metadata.getEmbeddeds() : null;\n    return new AttributesParser<EmbeddedAttributeMetadata>(this.memberMap, list, Embedded.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected EmbeddedAttributeMetadata parseAttribute(String name, Member member, EmbeddedAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new EmbeddedAttributeMetadataImpl(member, metadata);\n            } else {\n                return new EmbeddedAttributeMetadataImpl(member, name, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the embedded attributes.\n *\n * @return list of embedded attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1014, "method_signature": "List<EmbeddedAttributeMetadata> handleEmbeddeds()"}, "AttributesMetadataImpl.handleIds": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleIds", "method_implementation": "{\n    final List<IdAttributeMetadata> list = this.metadata != null ? this.metadata.getIds() : null;\n    return new AttributesParser<IdAttributeMetadata>(this.memberMap, list, Id.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected IdAttributeMetadata parseAttribute(String name, Member member, IdAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new IdAttributeMetadataImpl(member, metadata);\n            } else {\n                return new IdAttributeMetadataImpl(member, name, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the id attributes.\n *\n * @return list of id attributes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1015, "method_signature": "List<IdAttributeMetadata> handleIds()"}, "AttributesMetadataImpl.handleManyToManies": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleManyToManies", "method_implementation": "{\n    final List<ManyToManyAttributeMetadata> list = this.metadata != null ? this.metadata.getManyToManies() : null;\n    return new AttributesParser<ManyToManyAttributeMetadata>(this.memberMap, list, ManyToMany.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected ManyToManyAttributeMetadata parseAttribute(String name, Member member, ManyToManyAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new ManyToManyAttributeMetadataImpl(member, metadata);\n            } else {\n                final ManyToMany manyToMany = ReflectHelper.getAnnotation(member, ManyToMany.class);\n                return new ManyToManyAttributeMetadataImpl(member, name, manyToMany, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the many-to-many attributes.\n *\n * @return list of many-to-many attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1016, "method_signature": "List<ManyToManyAttributeMetadata> handleManyToManies()"}, "AttributesMetadataImpl.handleManyToOnes": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleManyToOnes", "method_implementation": "{\n    final List<ManyToOneAttributeMetadata> list = this.metadata != null ? this.metadata.getManyToOnes() : null;\n    return new AttributesParser<ManyToOneAttributeMetadata>(this.memberMap, list, ManyToOne.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected ManyToOneAttributeMetadata parseAttribute(String name, Member member, ManyToOneAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new ManyToOneAttributeMetadataImpl(member, metadata);\n            } else {\n                final ManyToOne manyToOne = ReflectHelper.getAnnotation(member, ManyToOne.class);\n                return new ManyToOneAttributeMetadataImpl(member, name, manyToOne, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the many-to-one attributes.\n *\n * @return list of many-to-one attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1017, "method_signature": "List<ManyToOneAttributeMetadata> handleManyToOnes()"}, "AttributesMetadataImpl.handleOneToManies": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleOneToManies", "method_implementation": "{\n    final List<OneToManyAttributeMetadata> list = this.metadata != null ? this.metadata.getOneToManies() : null;\n    return new AttributesParser<OneToManyAttributeMetadata>(this.memberMap, list, OneToMany.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected OneToManyAttributeMetadata parseAttribute(String name, Member member, OneToManyAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new OneToManyAttributeMetadataImpl(member, metadata);\n            } else {\n                final OneToMany oneToMany = ReflectHelper.getAnnotation(member, OneToMany.class);\n                return new OneToManyAttributeMetadataImpl(member, name, oneToMany, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the one-to-many attributes.\n *\n * @return list of one-to-many attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1018, "method_signature": "List<OneToManyAttributeMetadata> handleOneToManies()"}, "AttributesMetadataImpl.handleOneToOnes": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleOneToOnes", "method_implementation": "{\n    final List<OneToOneAttributeMetadata> list = this.metadata != null ? this.metadata.getOneToOnes() : null;\n    return new AttributesParser<OneToOneAttributeMetadata>(this.memberMap, list, OneToOne.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected OneToOneAttributeMetadata parseAttribute(String name, Member member, OneToOneAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new OneToOneAttributeMetadataImpl(member, metadata);\n            } else {\n                final OneToOne oneToOne = ReflectHelper.getAnnotation(member, OneToOne.class);\n                return new OneToOneAttributeMetadataImpl(member, name, oneToOne, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the one-to-one attributes.\n *\n * @return list of one-to-one attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1019, "method_signature": "List<OneToOneAttributeMetadata> handleOneToOnes()"}, "AttributesMetadataImpl.handleTransients": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleTransients", "method_implementation": "{\n    final List<TransientAttributeMetadata> list = this.metadata != null ? this.metadata.getTransients() : null;\n    return new AttributesParser<TransientAttributeMetadata>(this.memberMap, list, Transient.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected TransientAttributeMetadata parseAttribute(String name, Member member, TransientAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new TransientAttributeMetadataImpl(member, metadata);\n            } else {\n                return new TransientAttributeMetadataImpl(member, name, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the id attributes.\n *\n * @return the list of transient attributes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1020, "method_signature": "List<TransientAttributeMetadata> handleTransients()"}, "AttributesMetadataImpl.handleVersions": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.handleVersions", "method_implementation": "{\n    final List<VersionAttributeMetadata> list = this.metadata != null ? this.metadata.getVersions() : null;\n    return new AttributesParser<VersionAttributeMetadata>(this.memberMap, list, Version.class) {\n\n        private static final long serialVersionUID = BatooVersion.SERIAL_VERSION_UID;\n\n        @Override\n        protected VersionAttributeMetadata parseAttribute(String name, Member member, VersionAttributeMetadata metadata, Set<Class<? extends Annotation>> parsed) {\n            if (metadata != null) {\n                return new VersionAttributeMetadataImpl(member, metadata);\n            } else {\n                return new VersionAttributeMetadataImpl(member, name, parsed);\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Handles the version attributes\n *\n * @return the list of version attributes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1021, "method_signature": "List<VersionAttributeMetadata> handleVersions()"}, "AttributesMetadataImpl.isApplicableToAccessType": {"callee_method_names": ["AttributeMetadata.getAccess", "AttributeMetadata.getAccess", "Access.value", "Access.value"], "method_name": "AttributesMetadataImpl.isApplicableToAccessType", "method_implementation": "{\n    AccessType effective;\n    // if metadata is complete, and ormMetadata is null then we should skip the member\n    if (this.parent.isMetadataComplete() && (ormMetadata == null)) {\n        return false;\n    }\n    // if ORM Metadata sets an access type the that is effective\n    if ((ormMetadata != null) && (ormMetadata.getAccess() != null)) {\n        effective = ormMetadata.getAccess();\n    } else // inspect the members optional @Access annotation\n    {\n        final Access access = ReflectHelper.getAnnotation(member, Access.class);\n        // if access is present then infer the effective value from it\n        if (access != null) {\n            // if access doesn't set the preference then infer the effective value by type of the member\n            if (access.value() == null) {\n                if (member instanceof Field) {\n                    effective = AccessType.FIELD;\n                } else {\n                    effective = AccessType.PROPERTY;\n                }\n            } else // if access sets the preference then use it as effective\n            {\n                effective = access.value();\n                // check validity\n                if ((member instanceof Field) && (effective == AccessType.PROPERTY)) {\n                    throw new MappingException(\"Illegal @Access(AccessType.PROPERTY) on field \" + member);\n                }\n                if ((member instanceof Method) && (effective == AccessType.FIELD)) {\n                    throw new MappingException(\"Illegal @Access(AccessType.FIELD) on property \" + member);\n                }\n            }\n        } else // use context access type\n        {\n            effective = this.parent.getAccessType();\n        }\n    }\n    // finally check if member is applicable to the effective access type\n    switch(effective) {\n        case FIELD:\n            return member instanceof Field;\n        default:\n            return member instanceof Method;\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns if the member should be parsed based on its access type specification.\n * <p>\n * Gets the access type of the <code>member</code>.\n * <p>\n * if the <code>ormMetada</code> is present, and <code>ormMetadata</code>'s access type is present, then its value returned. Otherwise,\n * if exists, the <code>member</code> has {@link Access} annotation then its value is inspected.\n * <p>\n * Finally inferred access type is compared with the required access type and if equals returns true or false otherwise.\n *\n * @param member\n *            the member\n * @param ormMetadata\n *            the optional ORM Metadata\n * @return true if should parse, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1022, "method_signature": "boolean isApplicableToAccessType(Member, AttributeMetadata)"}, "AttributesMetadataImpl.probeAttributes": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.probeAttributes", "method_implementation": "{\n    final AccessType accessType = this.parent.getAccessType();\n    // based on the access type preference give priority to fields or properties\n    switch(accessType) {\n        case FIELD:\n            this.probeFields(clazz, accessType);\n            this.probeProperties(clazz, accessType);\n            break;\n        case PROPERTY:\n            this.probeProperties(clazz, accessType);\n            this.probeFields(clazz, accessType);\n            break;\n    }\n}", "repo_id": "1", "comment": "/**\n * Default entry point for a managed type to parse fields and properties of the class.\n * <p>\n * Based on the {@link AccessType} of the context, fields or properties is given priority.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1023, "method_signature": "void probeAttributes(Class)"}, "AttributesMetadataImpl.probeFields": {"callee_method_names": ["Class<?>.getDeclaredFields", "String.getName", "String.getModifiers", "String.getModifiers"], "method_name": "AttributesMetadataImpl.probeFields", "method_implementation": "{\n    for (final Field field : clazz.getDeclaredFields()) {\n        final String name = field.getName();\n        // if the field is transient then skip it\n        if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {\n            continue;\n        }\n        // locate the ORM Metadata attribute\n        final AttributeMetadata ormMetadata = AttributesMetadataImpl.this.ormAttributeMap.get(name);\n        // find out if it is applicable\n        final boolean applicable = AttributesMetadataImpl.this.isApplicableToAccessType(field, ormMetadata);\n        // if applicable then add to the member map\n        if (applicable) {\n            AttributesMetadataImpl.this.memberMap.put(name, field);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Entry point to probe the fields.\n * <p>\n * Enumerates the fields of the class and inspects each.\n *\n * @param clazz\n *            the java class\n * @param accessType\n *            the default {@link AccessType} of the context\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1024, "method_signature": "void probeFields(Class, AccessType)"}, "AttributesMetadataImpl.probeProperties": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.probeProperties", "method_implementation": "{\n    // get the properties of the class\n    final PropertyDescriptor[] properties = ReflectHelper.getProperties(clazz);\n    // for each of the properties if there is a no arg getter then inspect it\n    for (final PropertyDescriptor property : properties) {\n        final Method method = property.getReader();\n        final String name = property.getName();\n        // locate the ORM Metadata attribute\n        final AttributeMetadata ormMetadata = this.ormAttributeMap.get(name);\n        // find out if it is applicable\n        final boolean applicable = this.isApplicableToAccessType(method, ormMetadata);\n        // if applicable then add to the member map\n        if (applicable) {\n            this.memberMap.put(name, method);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Entry point to parse the properties.\n * <p>\n * Enumerates the getters of the class and inspects each.\n *\n * @param clazz\n *            the java class\n * @param accessType\n *            the default {@link AccessType} of the context\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1025, "method_signature": "void probeProperties(Class, AccessType)"}, "AttributesMetadataImpl.toString": {"callee_method_names": [], "method_name": "AttributesMetadataImpl.toString", "method_implementation": "{\n    return //\n    new ToStringBuilder(this).excludeFieldNames(\"parent\", \"ormMetadata\", \"ormAttributeMap\", //\n    \"memberMap\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1026, "method_signature": "String toString()"}, "BLoggerImpl.boxed": {"callee_method_names": ["String.replaceAll", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString"], "method_name": "BLoggerImpl.boxed", "method_implementation": "{\n    try {\n        if ((parameters != null) && (parameters.length > 0)) {\n            block += \"\\n\\n\" + Arrays.toString(parameters);\n        }\n        block = block.replaceAll(\"\\\\t\", \"    \");\n        final List<String> lines = IOUtils.readLines(new StringReader(block));\n        int max = 0;\n        for (final String line : lines) {\n            max = Math.max(max, line.length());\n        }\n        max += 4;\n        final StringBuffer boxed = new StringBuffer(\"\\n\");\n        boxed.append(StringUtils.repeat(\"-\", max));\n        boxed.append(\"\\n\");\n        for (final String line : lines) {\n            boxed.append(\"| \");\n            boxed.append(StringUtils.rightPad(line, max - 4));\n            boxed.append(\" |\\n\");\n        }\n        boxed.append(StringUtils.repeat(\"-\", max));\n        return boxed.toString();\n    } catch (final Exception e) {\n        return block;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 170, "method_signature": "String boxed(String, Object[])"}, "BLoggerImpl.debug": {"callee_method_names": [], "method_name": "BLoggerImpl.debug", "method_implementation": "{\n    if (this.logger.isDebugEnabled()) {\n        if (t != null) {\n            this.logger.debug(this.format(message, params), t);\n        } else {\n            this.logger.debug(this.format(message, params));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Convenience method to log a message\n *\n * @param t\n *            the {@link Throwable} applicable to the log\n * @param message\n *            the format message\n * @param params\n *            the params to the message\n */\n", "repo_name": "BatooJPA-master/", "id": 171, "method_signature": "void debug(Throwable, String, Object[])"}, "BLoggerImpl.fatal": {"callee_method_names": [], "method_name": "BLoggerImpl.fatal", "method_implementation": "{\n    if (t != null) {\n        this.logger.error(this.fatalMarker, BLoggerImpl.FATAL_PREFIX + this.format(message, params), t);\n    } else {\n        this.logger.error(this.fatalMarker, BLoggerImpl.FATAL_PREFIX + this.format(message, params));\n    }\n}", "repo_id": "1", "comment": "/**\n * Convenience method to log a message\n *\n * @param t\n *            the {@link Throwable} applicable to the log\n * @param message\n *            the format message\n * @param params\n *            the params to the message\n */\n", "repo_name": "BatooJPA-master/", "id": 172, "method_signature": "void fatal(Throwable, String, Object[])"}, "BLoggerImpl.info": {"callee_method_names": [], "method_name": "BLoggerImpl.info", "method_implementation": "{\n    if (this.logger.isInfoEnabled()) {\n        if (t != null) {\n            this.logger.info(this.format(message, params), t);\n        } else {\n            this.logger.info(this.format(message, params));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Convenience method to log a message\n *\n * @param t\n *            the {@link Throwable} applicable to the log\n * @param message\n *            the format message\n * @param params\n *            the params to the message\n */\n", "repo_name": "BatooJPA-master/", "id": 173, "method_signature": "void info(Throwable, String, Object[])"}, "BLoggerImpl.lazyBoxed": {"callee_method_names": ["Object.toString"], "method_name": "BLoggerImpl.lazyBoxed", "method_implementation": "{\n    return new Callable<String>() {\n\n        @Override\n        public String call() throws Exception {\n            return BLoggerImpl.this.boxed(block != null ? block.toString() : null, parameters);\n        }\n\n        @Override\n        public String toString() {\n            try {\n                return this.call();\n            } catch (final Exception e) {\n                return null;\n            }\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * Returns an object that lazily boxes the block.\n *\n * @param block\n *            the block to box\n * @param parameters\n *            the array of parameters\n * @return the object\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 174, "method_signature": "Object lazyBoxed(Object, Object[])"}, "BLoggerImpl.trace": {"callee_method_names": [], "method_name": "BLoggerImpl.trace", "method_implementation": "{\n    if (this.logger.isTraceEnabled()) {\n        if (t != null) {\n            this.logger.trace(this.format(message, params), t);\n        } else {\n            this.logger.trace(this.format(message, params));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Convenience method to log a message\n *\n * @param t\n *            the {@link Throwable} applicable to the log\n * @param message\n *            the format message\n * @param params\n *            the params to the message\n */\n", "repo_name": "BatooJPA-master/", "id": 175, "method_signature": "void trace(Throwable, String, Object[])"}, "BLoggerImpl.warn": {"callee_method_names": [], "method_name": "BLoggerImpl.warn", "method_implementation": "{\n    if (this.logger.isWarnEnabled()) {\n        if (t != null) {\n            this.logger.warn(this.format(message, params), t);\n        } else {\n            this.logger.warn(this.format(message, params));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Convenience method to log a message\n *\n * @param t\n *            the {@link Throwable} applicable to the log\n * @param message\n *            the format message\n * @param params\n *            the params to the message\n */\n", "repo_name": "BatooJPA-master/", "id": 176, "method_signature": "void warn(Throwable, String, Object[])"}, "Bar3.equals": {"callee_method_names": ["Object.getClass"], "method_name": "Bar3.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final Bar3 other = (Bar3) obj;\n    if (this.intValue != other.intValue) {\n        return false;\n    }\n    if (this.strValue == null) {\n        if (other.strValue != null) {\n            return false;\n        }\n    } else if (!this.strValue.equals(other.strValue)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2259, "method_signature": "boolean equals(Object)"}, "Bar3.hashCode": {"callee_method_names": [], "method_name": "Bar3.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + this.intValue;\n    result = (prime * result) + ((this.strValue == null) ? 0 : this.strValue.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2260, "method_signature": "int hashCode()"}, "BaseAnnotatedClassLocator.isPersistentClass": {"callee_method_names": ["ClassLoader.loadClass", "Class<?>.getAnnotation", "Class<?>.getAnnotation", "Class<?>.getAnnotation", "String.startsWith"], "method_name": "BaseAnnotatedClassLocator.isPersistentClass", "method_implementation": "{\n    try {\n        final Class<?> clazz = classloader.loadClass(className);\n        if (//\n        (clazz.getAnnotation(Embeddable.class) != null) || //\n        (clazz.getAnnotation(MappedSuperclass.class) != null) || (clazz.getAnnotation(Entity.class) != null)) {\n            return clazz;\n        }\n    } catch (final Throwable e) {\n        // nasty eclipse JUnit fragment spits bogus class loading errors\n        if (!className.startsWith(\"org.eclipse.jdt\")) {\n            BaseAnnotatedClassLocator.LOG.debug(e, \"Unable to read class: {0}\" + className);\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns if the class with then name <code>className</code> is an annotated persistent class.\n *\n * @param classloader\n *            the class loader\n * @param className\n *            the name of the class\n * @return true if the class with then name <code>className</code> is an annotated persistent class, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1055, "method_signature": "Class<?> isPersistentClass(ClassLoader, String)"}, "BaseAnnotatedClassLocator.locatePersistentClasses": {"callee_method_names": ["PersistenceUnitInfo.getClassLoader", "PersistenceUnitInfo.getJarFileUrls", "PersistenceUnitInfo.getManagedClassNames", "PersistenceUnitInfo.excludeUnlistedClasses", "List<URL>.isEmpty", "Set<Class<?>>.add", "ClassLoader.loadClass", "PersistenceUnitInfo.getPersistenceUnitRootUrl"], "method_name": "BaseAnnotatedClassLocator.locatePersistentClasses", "method_implementation": "{\n    final ClassLoader classLoader = puInfo.getClassLoader();\n    final List<URL> jarFiles = puInfo.getJarFileUrls();\n    final List<String> managedClassNames = puInfo.getManagedClassNames();\n    final boolean excludeUnlistedClasses = puInfo.excludeUnlistedClasses();\n    final Set<Class<?>> classes = Sets.newHashSet();\n    if ((jarFiles != null) && !jarFiles.isEmpty()) {\n        for (final URL jarUrl : jarFiles) {\n            BaseAnnotatedClassLocator.locateClasses(puInfo, classes, jarUrl);\n        }\n    }\n    for (final String className : managedClassNames) {\n        try {\n            classes.add(classLoader.loadClass(className));\n        } catch (final ClassNotFoundException e) {\n            throw new PersistenceException(\"Unable to load listed persistent class \" + className, e);\n        }\n    }\n    if (!excludeUnlistedClasses) {\n        BaseAnnotatedClassLocator.locateClasses(puInfo, classes, puInfo.getPersistenceUnitRootUrl());\n    }\n    return classes;\n}", "repo_id": "1", "comment": "/**\n * Locates the classes available.\n *\n * @param puInfo\n *            the persistence unit info\n * @return the array of classes located\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1054, "method_signature": "Set<Class<?>> locatePersistentClasses(PersistenceUnitInfo)"}, "BaseColumnElement.generate": {"callee_method_names": [], "method_name": "BaseColumnElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ATTR_NAME, EMPTY);\n    this.columnDefinition = this.getAttribute(ATTR_COLUMN_DEFINITION, EMPTY);\n    this.insertable = this.getAttribute(ATTR_INSERTABLE, false);\n    this.nullable = this.getAttribute(ATTR_NULLABLE, false);\n    this.table = this.getAttribute(ATTR_TABLE, EMPTY);\n    this.unique = this.getAttribute(ATTR_UNIQUE, false);\n    this.updatable = this.getAttribute(ATTR_UPDATABLE, true);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1071, "method_signature": "void generate()"}, "BaseCoreTest.close": {"callee_method_names": [], "method_name": "BaseCoreTest.close", "method_implementation": "{\n    this.cleanupTx();\n    this.cleanUpEm();\n}", "repo_id": "1", "comment": "/**\n * Closes the Entity Manager.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2544, "method_signature": "void close()"}, "BaseCoreTest.commit": {"callee_method_names": [], "method_name": "BaseCoreTest.commit", "method_implementation": "{\n    this.tx().commit();\n    this.tx = null;\n}", "repo_id": "1", "comment": "/**\n * Commits the transaction.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2545, "method_signature": "void commit()"}, "BaseCoreTest.em": {"callee_method_names": [], "method_name": "BaseCoreTest.em", "method_implementation": "{\n    if (this.em != null) {\n        return this.em;\n    }\n    return this.em = this.emf().createEntityManager();\n}", "repo_id": "1", "comment": "/**\n * Returns the Entity Manager\n *\n * @return the Entity Manager\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2546, "method_signature": "EntityManagerImpl em()"}, "BaseCoreTest.emf": {"callee_method_names": [], "method_name": "BaseCoreTest.emf", "method_implementation": "{\n    if (this.emf == null) {\n        this.emf = this.setupEmf();\n    }\n    return this.emf;\n}", "repo_id": "1", "comment": "/**\n * Returns the Entity Manager Factory.\n *\n * @return the Entity Manager Factory\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2547, "method_signature": "EntityManagerFactoryImpl emf()"}, "BaseCoreTest.ensureTx": {"callee_method_names": [], "method_name": "BaseCoreTest.ensureTx", "method_implementation": "{\n    if ((this.tx == null) || !this.tx.isActive()) {\n        this.begin();\n    }\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2548, "method_signature": "void ensureTx()"}, "BaseCoreTest.exec": {"callee_method_names": ["Process.waitFor", "Process.exitValue", "Process.getErrorStream", "Process.getErrorStream"], "method_name": "BaseCoreTest.exec", "method_implementation": "{\n    try {\n        final Process process = Runtime.getRuntime().exec(cmd);\n        if (process.waitFor() != 0) {\n            BaseCoreTest.LOG.error(\"Command failed: \" + process.exitValue());\n            IOUtils.copy(process.getErrorStream(), System.err);\n        }\n        IOUtils.copy(process.getErrorStream(), System.out);\n    } catch (final Exception e) {\n        throw new RuntimeException(e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Executes an artbitrary command as external process and waits for the termination.\n *\n * @param cmd\n *            the command to execute\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2472, "method_signature": "void exec(String)"}, "BaseCoreTest.merge": {"callee_method_names": [], "method_name": "BaseCoreTest.merge", "method_implementation": "{\n    this.ensureTx();\n    return this.em().merge(entity);\n}", "repo_id": "1", "comment": "/**\n * Merges the entity.\n *\n * @param entity\n * @param <T>\n *            the type of the entity\n *\n * @since 2.0.0\n * @return\n */\n", "repo_name": "BatooJPA-master/", "id": 2549, "method_signature": "T merge(T)"}, "BaseCoreTest.persist": {"callee_method_names": [], "method_name": "BaseCoreTest.persist", "method_implementation": "{\n    this.ensureTx();\n    this.em().persist(entity);\n}", "repo_id": "1", "comment": "/**\n * Persists the entity.\n *\n * @param entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2550, "method_signature": "void persist(Object)"}, "BaseCoreTest.remove": {"callee_method_names": [], "method_name": "BaseCoreTest.remove", "method_implementation": "{\n    this.ensureTx();\n    this.em().remove(entity);\n}", "repo_id": "1", "comment": "/**\n * Persists the entity.\n *\n * @param entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2551, "method_signature": "void remove(Object)"}, "BaseCoreTest.rollback": {"callee_method_names": [], "method_name": "BaseCoreTest.rollback", "method_implementation": "{\n    this.tx().rollback();\n    this.tx = null;\n}", "repo_id": "1", "comment": "/**\n * Rolls the transaction back.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2552, "method_signature": "void rollback()"}, "BaseCoreTest.setup": {"callee_method_ids": [1157, 1157, 1157, 1156, 1157], "callee_method_names": ["QueryRunner.update", "QueryRunner.update", "QueryRunner.update", "Connection.close", "QueryRunner.query", "QueryRunner.update", "Connection.close"], "method_name": "BaseCoreTest.setup", "method_implementation": "{\n    if (this.testMode == null) {\n        this.testMode = System.getProperty(\"testMode\");\n        if (!this.noDatasource) {\n            this.testMode = \"hsql\";\n            System.setProperty(\"testMode\", this.testMode);\n            System.setProperty(\"javax.persistence.jdbc.driver\", \"org.hsqldb.jdbcDriver\");\n            System.setProperty(\"javax.persistence.jdbc.url\", \"jdbc:hsqldb:mem:test\");\n            System.setProperty(\"javax.persistence.jdbc.user\", \"sa\");\n            System.setProperty(\"javax.persistence.jdbc.password\", \"\");\n        }\n    }\n    if (\"mssql\".equals(this.testMode)) {\n        final String username = System.getProperty(\"javax.persistence.jdbc.user\");\n        final String password = System.getProperty(\"javax.persistence.jdbc.password\");\n        final Connection connection = DriverManager.getConnection(System.getProperty(\"javax.persistence.jdbc.url\"), username, password);\n        try {\n            final QueryRunner qr = new QueryRunner(true, false);\n            qr.update(connection, \"use master\");\n            qr.update(connection, \"drop database test\");\n            qr.update(connection, \"create database test\");\n        } finally {\n            connection.close();\n        }\n    }\n    if (\"oracle\".equals(this.testMode)) {\n        final String username = System.getProperty(\"javax.persistence.jdbc.user\");\n        final String password = System.getProperty(\"javax.persistence.jdbc.password\");\n        final Connection connection = DriverManager.getConnection(System.getProperty(\"javax.persistence.jdbc.url\"), username, password);\n        try {\n            final QueryRunner qr = new QueryRunner(true, false);\n            final List<Object[]> tables = qr.query(connection, \"select TABLE_NAME from user_tables\", new ArrayListHandler());\n            for (final Object[] table : tables) {\n                try {\n                    qr.update(connection, \"DROP TABLE \" + table[0] + \" CASCADE CONSTRAINTS\");\n                } catch (final Exception e) {\n                }\n            }\n        } finally {\n            connection.close();\n        }\n    }\n    if (!this.lazySetup()) {\n        this.emf = this.setupEmf();\n    }\n}", "repo_id": "1", "comment": "/**\n * Builds the session factory.\n *\n * @throws SQLException\n *             th\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2553, "method_signature": "void setup()"}, "BaseCoreTest.setupEmf": {"callee_method_names": ["Thread.setContextClassLoader", "Thread.getContextClassLoader", "Thread.setContextClassLoader", "TestClassLoader.setRoot"], "method_name": "BaseCoreTest.setupEmf", "method_implementation": "{\n    final Thread currentThread = Thread.currentThread();\n    if (this.oldContextClassLoader != null) {\n        currentThread.setContextClassLoader(this.oldContextClassLoader);\n    }\n    this.oldContextClassLoader = currentThread.getContextClassLoader();\n    final TestClassLoader cl = new TestClassLoader(this.oldContextClassLoader);\n    currentThread.setContextClassLoader(cl);\n    cl.setRoot(this.getRootPackage());\n    return (EntityManagerFactoryImpl) Persistence.createEntityManagerFactory(puName);\n}", "repo_id": "1", "comment": "/**\n * Sets up the entity manager factory.\n *\n * @param puName\n *            the persistence unit name\n * @return the entity manager factory\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2554, "method_signature": "EntityManagerFactoryImpl setupEmf(String)"}, "BaseCoreTest.starting": {"callee_method_names": ["Description.getAnnotation", "PersistenceContext.unitName", "PersistenceContext.unitName", "Description.getAnnotation"], "method_name": "BaseCoreTest.starting", "method_implementation": "{\n    BaseCoreTest.this.persistenceUnitName = BaseCoreTest.DEFAULT;\n    final PersistenceContext persistenceContext = description.getAnnotation(PersistenceContext.class);\n    if (persistenceContext != null) {\n        // if unit name is not the default set the unit name\n        if (StringUtils.isNotBlank(persistenceContext.unitName())) {\n            BaseCoreTest.this.persistenceUnitName = persistenceContext.unitName();\n        }\n    }\n    BaseCoreTest.this.noDatasource = description.getAnnotation(NoDatasource.class) != null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2543, "method_signature": "void starting(Description)"}, "BaseCoreTest.teardown": {"callee_method_ids": [1157, 440, 1157, 440, 1157, 440, 1157, 1157, 1157], "callee_method_names": ["QueryRunner.update", "EntityManagerImpl.getConnection", "QueryRunner.update", "EntityManagerImpl.getConnection", "QueryRunner.update", "EntityManagerImpl.getConnection", "QueryRunner.update", "QueryRunner.update", "QueryRunner.update", "Connection.close"], "method_name": "BaseCoreTest.teardown", "method_implementation": "{\n    final String testMode = System.getProperty(\"testMode\");\n    this.cleanupTx();\n    final QueryRunner qr = \"mssql\".equals(testMode) ? new QueryRunner(true, false) : new QueryRunner();\n    if (this.emf != null) {\n        if (\"mysql\".equals(testMode)) {\n            final EntityManagerImpl em = this.em();\n            qr.update(em.getConnection(), \"drop database test\");\n            qr.update(em.getConnection(), \"create database test\");\n        } else if (\"hsql\".equals(testMode)) {\n            final EntityManagerImpl em = this.em();\n            qr.update(em.getConnection(), \"shutdown\");\n        }\n    }\n    this.cleanUpEm();\n    if ((this.emf != null) && this.emf.isOpen()) {\n        try {\n            this.emf.close();\n        } catch (final Exception e) {\n        }\n        this.emf = null;\n    }\n    if (\"mssql\".equals(testMode)) {\n        final String username = System.getProperty(\"javax.persistence.jdbc.user\");\n        final String password = System.getProperty(\"javax.persistence.jdbc.password\");\n        final Connection connection = DriverManager.getConnection(System.getProperty(\"javax.persistence.jdbc.url\"), username, password);\n        try {\n            qr.update(connection, \"use master\");\n            qr.update(connection, \"drop database test\");\n            qr.update(connection, \"create database test\");\n        } finally {\n            connection.close();\n        }\n    }\n    if (StringUtils.isBlank(testMode) || \"derby\".equals(testMode)) {\n        try {\n            DriverManager.getConnection(\"jdbc:derby:memory:test;drop=true\");\n        } catch (final Exception e) {\n        }\n    } else if (\"pgsql\".equals(testMode)) {\n        this.exec(\"/usr/bin/dropdb test -U postgres -h localhost\");\n        this.exec(\"/usr/bin/createdb test -U postgres -h localhost\");\n    }\n    Thread.currentThread().setContextClassLoader(this.oldContextClassLoader);\n    this.oldContextClassLoader = null;\n}", "repo_id": "1", "comment": "/**\n * Cleans up the test\n *\n * @throws SQLException\n *             thrown if the tear down fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2555, "method_signature": "void teardown()"}, "BaseCoreTest.tx": {"callee_method_names": [], "method_name": "BaseCoreTest.tx", "method_implementation": "{\n    if (this.tx != null) {\n        return this.tx;\n    }\n    return this.tx = this.em().getTransaction();\n}", "repo_id": "1", "comment": "/**\n * Returns the active transaction from the entity manager.\n *\n * @return the active transaction\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2556, "method_signature": "EntityTransaction tx()"}, "BaseEntity.equals": {"callee_method_names": ["Object.getClass"], "method_name": "BaseEntity.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final BaseEntity other = (BaseEntity) obj;\n    if (this.id == null) {\n        if (other.id != null) {\n            return false;\n        }\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2232, "method_signature": "boolean equals(Object)"}, "BaseEntity.hashCode": {"callee_method_names": [], "method_name": "BaseEntity.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.getDisplayText() == null) ? 0 : this.getDisplayText().hashCode());\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2233, "method_signature": "int hashCode()"}, "BaseEntity.initTimeStamps": {"callee_method_names": [], "method_name": "BaseEntity.initTimeStamps", "method_implementation": "{\n    if (this.createdOn == null) {\n        this.createdOn = new Date();\n    }\n    this.modifiedOn = this.createdOn;\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2234, "method_signature": "void initTimeStamps()"}, "BaseQueryImpl.getAlias": {"callee_method_names": [], "method_name": "BaseQueryImpl.getAlias", "method_implementation": "{\n    String alias = this.selections.get(selection);\n    if (alias == null) {\n        alias = \"S\" + this.nextSelection++;\n        this.selections.put(selection, alias);\n    }\n    return alias;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 746, "method_signature": "String getAlias(AbstractSelection)"}, "BaseQueryImpl.getFieldAlias": {"callee_method_names": ["List<AbstractColumn>.indexOf", "List<AbstractColumn>.add", "List<AbstractColumn>.size"], "method_name": "BaseQueryImpl.getFieldAlias", "method_implementation": "{\n    List<AbstractColumn> fields = this.fields.get(tableAlias);\n    if (fields == null) {\n        fields = Lists.newArrayList();\n        this.fields.put(tableAlias, fields);\n    }\n    final int i = fields.indexOf(column);\n    if (i >= 0) {\n        return Integer.toString(i);\n    }\n    fields.add(column);\n    return Integer.toString(fields.size() - 1);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 747, "method_signature": "String getFieldAlias(String, AbstractColumn)"}, "BaseQueryImpl.getJpql": {"callee_method_names": [], "method_name": "BaseQueryImpl.getJpql", "method_implementation": "{\n    FinalWrapper<String> wrapper = this.jpql;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.jpql == null) {\n                this.jpql = new FinalWrapper<String>(this.generateJpql());\n            }\n            wrapper = this.jpql;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 748, "method_signature": "String getJpql()"}, "BaseQueryImpl.getParameters": {"callee_method_names": ["Set<ParameterExpression<?>>.add"], "method_name": "BaseQueryImpl.getParameters", "method_implementation": "{\n    final Set<ParameterExpression<?>> parameters = Sets.newHashSet();\n    for (final AbstractParameterExpressionImpl<?> parameter : this.parameters.keySet()) {\n        if (parameter instanceof ParameterExpressionImpl) {\n            parameters.add((ParameterExpression<?>) parameter);\n        }\n    }\n    return parameters;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 749, "method_signature": "Set<ParameterExpression<?>> getParameters()"}, "BaseQueryImpl.getSql": {"callee_method_names": [], "method_name": "BaseQueryImpl.getSql", "method_implementation": "{\n    FinalWrapper<String> wrapper = this.sql;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.sql == null) {\n                try {\n                    this.sql = new FinalWrapper<String>(this.generateSql());\n                } catch (final Exception e) {\n                    String jpql = null;\n                    try {\n                        jpql = this.getJpql();\n                        throw new PersistenceException(\"Cannot generate query for: \" + jpql, e);\n                    } catch (final Exception e2) {\n                    }\n                    if (e instanceof RuntimeException) {\n                        throw (RuntimeException) e;\n                    }\n                    throw new PersistenceException(\"Cannot generate SQL for query\", e);\n                }\n            }\n            wrapper = this.sql;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 750, "method_signature": "String getSql()"}, "BaseQueryImpl.setNextSqlParam": {"callee_method_names": [], "method_name": "BaseQueryImpl.setNextSqlParam", "method_implementation": "{\n    if (parameter instanceof ParameterExpressionImpl) {\n        final Integer position = ((ParameterExpressionImpl<?>) parameter).getPosition();\n        if (position != null) {\n            this.sqlParameters.add(parameter);\n            return position;\n        }\n    }\n    this.sqlParameters.add(parameter);\n    return this.sqlParameters.size() - 1;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 751, "method_signature": "int setNextSqlParam(AbstractParameterExpressionImpl)"}, "BasicAttribute.clone": {"callee_method_names": [], "method_name": "BasicAttribute.clone", "method_implementation": "{\n    if (this.version) {\n        return new BasicAttribute<Z, T>(type, (VersionAttributeMetadata) this.getMetadata());\n    }\n    if (this.idType != null) {\n        return new BasicAttribute<Z, T>(type, (IdAttributeMetadata) this.getMetadata());\n    }\n    return new BasicAttribute<Z, T>(type, (BasicAttributeMetadata) this.getMetadata());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 281, "method_signature": "BasicAttribute<Z,T> clone(EntityTypeImpl)"}, "BasicAttribute.fillValue": {"callee_method_names": ["EntityTypeImpl<?>.getMappedId", "ManagedInstance<?>.getInstance"], "method_name": "BasicAttribute.fillValue", "method_implementation": "{\n    T value = this.get(instance);\n    // if the attribute already has value, bail out\n    if (value != null) {\n        return true;\n    }\n    if (this.idType == null) {\n        if (value == null) {\n            value = (T) type.getMappedId(this.getName(), managedInstance.getInstance());\n            if (value != null) {\n                this.set(instance, value);\n                return true;\n            }\n        }\n        throw new PersistenceException(\"Ids should be manually assigned\");\n    }\n    Long id;\n    // fill the id\n    switch(this.idType) {\n        case IDENTITY:\n            // indicate a requirement for an implicit flush\n            return false;\n        case SEQUENCE:\n            // fill with the sequence\n            id = this.getMetamodel().getNextSequence(this.generator);\n            this.set(instance, ReflectHelper.convertNumber(id, this.getJavaType()));\n            break;\n        case TABLE:\n            // fill with the next table generator id\n            id = this.getMetamodel().getNextTableValue(this.generator);\n            this.set(instance, ReflectHelper.convertNumber(id, this.getJavaType()));\n            break;\n        case MANUAL:\n            // not possible, manual already handled\n            break;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * Fills the sequence / table generated value.\n * <p>\n * The operation returns false if at least one entity needs to obtain identity from the database.\n *\n * @param type\n *            the entity type\n * @param managedInstance\n *            the managed instance\n * @param instance\n *            the instance to fill ids.\n * @return false if all OK, true if if at least one entity needs to obtain identity from the database\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 282, "method_signature": "boolean fillValue(EntityTypeImpl, ManagedInstance, Object)"}, "BasicAttributeElement.generate": {"callee_method_names": [], "method_name": "BasicAttributeElement.generate", "method_implementation": "{\n    super.generate();\n    this.fetchType = FetchType.valueOf(this.getAttribute(ElementConstants.ATTR_FETCH, FetchType.EAGER.name()));\n    this.optional = this.getAttribute(ElementConstants.ATTR_OPTIONAL, true);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1109, "method_signature": "void generate()"}, "BasicAttributeElement.handleChild": {"callee_method_names": [], "method_name": "BasicAttributeElement.handleChild", "method_implementation": "{\n    super.handleChild(child);\n    if (child instanceof EnumeratedElement) {\n        this.enumType = ((EnumeratedElement) child).getEnumType();\n    }\n    if (child instanceof LobElement) {\n        this.lob = true;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1110, "method_signature": "void handleChild(Element)"}, "BasicColumn.setTable": {"callee_method_names": [], "method_name": "BasicColumn.setTable", "method_implementation": "{\n    this.table = table;\n    this.table.addColumn(this);\n}", "repo_id": "1", "comment": "/**\n * Sets the table of the column.\n *\n * @param table\n *            the owning table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1153, "method_signature": "void setTable(AbstractTable)"}, "BasicMappingImpl.getColumnMetadata": {"callee_method_names": ["AttributeImpl<?, ?>.getDeclaringType", "AttributeImpl<?, ?>.getDeclaringType", "AttributeImpl<?, ?>.getDeclaringType"], "method_name": "BasicMappingImpl.getColumnMetadata", "method_implementation": "{\n    ColumnMetadata metadata = null;\n    final String path = this.getParent().getRootPath(this.attribute.getName());\n    final AttributeImpl<?, ?> rootAttribute = this.getParent().getRootAttribute(this.attribute);\n    /**\n     * The priorities are like below:\n     *\n     * 1. If the root attribute is defined in the root type (thus the entity) then locate the attribute override on the attribute chain<br />\n     * 2. If the root attribute is defined in a parent mapped super class then locate the attribute on the entity<br />\n     * 3. If the parent is an embeddable mapping then locate the attribute override again on the attribute chain<br />\n     * 4. return the column metadata from the attribute<br />\n     */\n    // Clause 0\n    if ((rootAttribute.getDeclaringType() == this.getRoot().getType()) && (this.getParent() instanceof EmbeddedMappingImpl)) {\n        metadata = ((EmbeddedMappingImpl<?, ?>) this.getParent()).getAttributeOverride(path);\n        if (metadata != null) {\n            return metadata;\n        }\n    }\n    // Clause 1\n    if ((rootAttribute.getDeclaringType() == this.getRoot().getType()) && (this.getParent() instanceof EmbeddedMappingImpl)) {\n        metadata = ((EmbeddedMappingImpl<?, ?>) this.getParent()).getAttributeOverride(path);\n        if (metadata != null) {\n            return metadata;\n        }\n    }\n    // Clause 2\n    if (rootAttribute.getDeclaringType() instanceof MappedSuperclassTypeImpl) {\n        metadata = ((EntityTypeImpl<?>) this.getRoot().getType()).getAttributeOverride(path);\n        if (metadata != null) {\n            return metadata;\n        }\n    }\n    // Clause 3\n    if (this.getParent() instanceof EmbeddedMappingImpl) {\n        metadata = ((EmbeddedMappingImpl<?, ?>) this.getParent()).getAttributeOverride(path);\n        if (metadata != null) {\n            return metadata;\n        }\n    }\n    // Clause 4: fall back to attribute's column metadata\n    return this.attribute.getMetadata().getColumn();\n}", "repo_id": "1", "comment": "/**\n * Returns the effective column metadata for the attribute checking with the parent mappings and entities.\n *\n * @return the column metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 380, "method_signature": "ColumnMetadata getColumnMetadata()"}, "BasicMappingImpl.getIdType": {"callee_method_names": [], "method_name": "BasicMappingImpl.getIdType", "method_implementation": "{\n    if (this.attribute.getIdType() != null) {\n        return this.attribute.getIdType();\n    }\n    final AbstractParentMapping<?, Z> parent = this.getParent();\n    if (parent instanceof EmbeddedMappingImpl) {\n        return ((EmbeddedMappingImpl<?, Z>) parent).getIdType();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 381, "method_signature": "IdType getIdType()"}, "BasicPath.generateJpqlRestriction": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "BasicPath.generateJpqlRestriction", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.getParentPath().generateJpqlRestriction(query));\n    builder.append(\".\").append(this.mapping.getAttribute().getName());\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 785, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "BasicPath.generateJpqlSelect": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "BasicPath.generateJpqlSelect", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.getParentPath().generateJpqlSelect(query, false));\n    builder.append(\".\").append(this.mapping.getAttribute().getName());\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        builder.append(\" as \").append(this.getAlias());\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 786, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "BasicPath.generateSqlSelect": {"callee_method_names": ["Joinable.getTableAlias", "BasicColumn.getTable", "AbstractCriteriaQueryImpl<?>.getFieldAlias", "BasicColumn.getName", "BasicColumn.getName"], "method_name": "BasicPath.generateSqlSelect", "method_implementation": "{\n    final BasicColumn column = this.mapping.getColumn();\n    final Joinable rootPath = this.getRootPath();\n    final String tableAlias = rootPath.getTableAlias(query, column.getTable());\n    this.fieldAlias = tableAlias + \"_F\" + query.getFieldAlias(tableAlias, column);\n    if (selected) {\n        return tableAlias + \".\" + column.getName() + \" AS \" + this.fieldAlias;\n    } else {\n        return tableAlias + \".\" + column.getName();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 787, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "BasicPath.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.isQuery", "BasicColumn.getTable", "BasicColumn.getName", "BasicColumn.getName"], "method_name": "BasicPath.getSqlRestrictionFragments", "method_implementation": "{\n    final BasicColumn column = this.mapping.getColumn();\n    if (query.isQuery()) {\n        String columnAlias = this.getParentPath().getColumnAlias(query, column);\n        if (columnAlias == null) {\n            // force join\n            this.getParentPath().getFetchRoot();\n            columnAlias = this.getRootPath().getTableAlias(query, column.getTable()) + \".\" + column.getName();\n        }\n        return new String[] { columnAlias };\n    }\n    return new String[] { column.getName() };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 788, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "BasicPath.handle": {"callee_method_names": ["ResultSet.getStatement", "ResultSet.getObject"], "method_name": "BasicPath.handle", "method_implementation": "{\n    final X value = (X) this.mapping.getColumn().convertValue(row.getStatement().getConnection(), row.getObject(this.fieldAlias));\n    return (X) (this.getConverter() != null ? this.getConverter().convert(value) : value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 789, "method_signature": "X handle(QueryImpl, SessionImpl, ResultSet)"}, "BatooEnhancerMojo.execute": {"callee_method_names": ["String.endsWith", "String.substring", "String.length", "URLClassLoader.loadClass", "Class<?>.getName", "FileOutputStream.write", "FileOutputStream.close"], "method_name": "BatooEnhancerMojo.execute", "method_implementation": "{\n    if (this.skipMojo()) {\n        return;\n    }\n    final URLClassLoader cl = this.extendRealmClasspath();\n    final List<File> classes = this.findEntityClassFiles();\n    final int classRootLength = this.classes.toString().length() + 1;\n    for (final File classPath : classes) {\n        try {\n            final String absolutePath = classPath.getAbsolutePath();\n            if (absolutePath.endsWith(\"$Enhanced.class\")) {\n                continue;\n            }\n            final String className = absolutePath.substring(classRootLength, absolutePath.length() - 6).replace('\\\\', '.').replace('/', '.');\n            this.getLog().info(\"Enhancing: \" + className);\n            final Class<?> clazz = cl.loadClass(className);\n            final byte[] byteCode = Enhancer.create(clazz);\n            final String outputFile = this.classes.getAbsolutePath() + \"/\" + clazz.getName().replaceAll(\"\\\\.\", \"/\") + Enhancer.SUFFIX_ENHANCED + \".class\";\n            this.getLog().info(\"Writing  : \" + outputFile);\n            final FileOutputStream os = new FileOutputStream(outputFile);\n            try {\n                os.write(byteCode);\n            } finally {\n                os.close();\n            }\n        } catch (final Exception e) {\n            throw new MojoExecutionException(\"Enhancement failed for \" + classPath.getName());\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n *\n * @see org.apache.maven.plugin.Mojo#execute()\n */\n", "repo_name": "BatooJPA-master/", "id": 2567, "method_signature": "void execute()"}, "BatooEnhancerMojo.extendRealmClasspath": {"callee_method_names": ["File.toURI", "List.add", "List.toArray", "List.size"], "method_name": "BatooEnhancerMojo.extendRealmClasspath", "method_implementation": "{\n    final List urls = new ArrayList();\n    for (final Iterator itor = this.compileClasspathElements.iterator(); itor.hasNext(); ) {\n        final File pathElem = new File((String) itor.next());\n        try {\n            final URL url = pathElem.toURI().toURL();\n            urls.add(url);\n            this.getLog().debug(\"Added classpathElement URL \" + url);\n        } catch (final MalformedURLException e) {\n            throw new MojoExecutionException(\"Error in adding the classpath \" + pathElem, e);\n        }\n    }\n    return new URLClassLoader((URL[]) urls.toArray(new URL[urls.size()]), this.getClass().getClassLoader());\n}", "repo_id": "1", "comment": "/**\n * This will prepare the current ClassLoader and add all jars and local classpaths (e.g. target/classes) needed by the OpenJPA task.\n *\n * @return the class loader\n *\n * @throws MojoExecutionException\n *             on any error inside the mojo\n */\n", "repo_name": "BatooJPA-master/", "id": 2568, "method_signature": "URLClassLoader extendRealmClasspath()"}, "BatooEnhancerMojo.findEntityClassFiles": {"callee_method_names": [], "method_name": "BatooEnhancerMojo.findEntityClassFiles", "method_implementation": "{\n    List files = new ArrayList();\n    try {\n        files = FileUtils.getFiles(this.getEntityClasses(), this.includes, this.excludes);\n    } catch (final IOException e) {\n        throw new MojoExecutionException(\"Error while scanning for '\" + this.includes + \"' in \" + \"'\" + this.getEntityClasses().getAbsolutePath() + \"'.\", e);\n    }\n    return files;\n}", "repo_id": "1", "comment": "/**\n * Locates and returns a list of class files found under specified class directory.\n *\n * @return list of class files.\n * @throws MojoExecutionException\n *             if there was an error scanning class file resources.\n */\n", "repo_name": "BatooJPA-master/", "id": 2569, "method_signature": "List findEntityClassFiles()"}, "BatooEnhancerMojo.skipMojo": {"callee_method_names": [], "method_name": "BatooEnhancerMojo.skipMojo", "method_implementation": "{\n    if (this.skip) {\n        this.getLog().info(\"Skiping enhancement execution\");\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Returns if the execution should be skipped.\n *\n * @return true if the execution should be skipped, flase otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2570, "method_signature": "boolean skipMojo()"}, "BatooPersistenceProvider.createContainerEntityManagerFactory": {"callee_method_names": ["PersistenceParser.getJtaDataSource", "PersistenceUnitInfo.getPersistenceUnitName", "PersistenceUnitInfo.getPersistenceUnitName", "PersistenceUnitInfo.getPersistenceUnitName"], "method_name": "BatooPersistenceProvider.createContainerEntityManagerFactory", "method_implementation": "{\n    try {\n        final PersistenceParser parser = new org.batoo.jpa.parser.PersistenceParserImpl(info, map);\n        return //\n        parser.getJtaDataSource() != null ? new org.batoo.jpa.core.impl.manager.JtaEntityManagerFactoryImpl(info.getPersistenceUnitName(), parser) : new EntityManagerFactoryImpl(info.getPersistenceUnitName(), parser);\n    } catch (final PersistenceException e) {\n        throw e;\n    } catch (final MappingException e) {\n        throw e;\n    } catch (final BatooException e) {\n        throw e;\n    } catch (final Exception e) {\n        throw new PersistenceException(\"Unable to build the entity manager factory for persistence unit: \" + info.getPersistenceUnitName(), e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 179, "method_signature": "EntityManagerFactoryImpl createContainerEntityManagerFactory(PersistenceUnitInfo, Map)"}, "BatooPersistenceProvider.createEntityManagerFactory": {"callee_method_names": [], "method_name": "BatooPersistenceProvider.createEntityManagerFactory", "method_implementation": "{\n    try {\n        // create the persistence parser\n        final PersistenceParser parser = new org.batoo.jpa.parser.AndroidPersistenceParserImpl(map, classes);\n        // finally, create the entity manager factory\n        return new EntityManagerFactoryImpl(emName, parser);\n    } catch (final Exception e) {\n        if ((e instanceof PersistenceException) || (e instanceof MappingException) || (e instanceof BatooException)) {\n            throw (RuntimeException) e;\n        }\n        BatooPersistenceProvider.LOG.info(e, \"Unable to build persistence unit: \" + emName);\n        return null;\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates a persistence unit without persistence.xml file. Suitable for non-standard platforms such as Android.\n *\n * @param emName\n *            the name of the persistence unit\n * @param map\n *            the properties\n * @param classes\n *            the list of classes\n * @return the entity manager factory\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 181, "method_signature": "EntityManagerFactory createEntityManagerFactory(String, Map, String[])"}, "BatooUtils.acronym": {"callee_method_names": ["String.length", "String.charAt", "StringBuilder.append", "String.charAt", "StringBuilder.length", "StringBuilder.append", "String.charAt", "StringBuilder.toString"], "method_name": "BatooUtils.acronym", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < name.length(); i++) {\n        if (Character.isUpperCase(name.charAt(i))) {\n            builder.append(name.charAt(i));\n        }\n    }\n    if (builder.length() == 0) {\n        builder.append(name.charAt(0));\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * Returns the acronym of the name\n *\n * @param name\n *            the name\n * @return the acronym\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 69, "method_signature": "String acronym(String)"}, "BatooUtils.addAll": {"callee_method_names": ["List<? extends E>.size", "Collection<E>.add", "List<? extends E>.get", "Collection<E>.addAll"], "method_name": "BatooUtils.addAll", "method_implementation": "{\n    if (source instanceof List) {\n        final List<? extends E> list = (List<? extends E>) source;\n        for (int i = 0; i < list.size(); i++) {\n            target.add(list.get(i));\n        }\n    } else {\n        target.addAll(source);\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds all the elements in the source to target.\n *\n * @param source\n *            the source collection\n * @param target\n *            the destination collection\n * @param <E>\n *            the type of the collections\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 70, "method_signature": "void addAll(Collection, Collection)"}, "BatooUtils.indent": {"callee_method_names": ["String.replaceAll"], "method_name": "BatooUtils.indent", "method_implementation": "{\n    if (StringUtils.isBlank(str)) {\n        return \"\";\n    }\n    return \"\\t\" + str.replaceAll(\"\\n\", \"\\n\\t\");\n}", "repo_id": "1", "comment": "/**\n * Indents the <code>string</code> by one <code>tab</code>.\n *\n * @param str\n *            string to indent\n * @return the indented string\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 71, "method_signature": "String indent(String)"}, "BatooUtils.loadRuntimeProperties": {"callee_method_names": ["Properties.load", "InputStream.close", "Properties.entrySet", "Map<String, Object>.put", "Entry.getKey", "Entry.getValue"], "method_name": "BatooUtils.loadRuntimeProperties", "method_implementation": "{\n    try {\n        final InputStream inRuntimeProperties = BatooUtils.class.getClassLoader().getResourceAsStream(\"batoo-jpa-runtime.properties\");\n        if (inRuntimeProperties != null) {\n            Properties runtimeProperties = new Properties();\n            runtimeProperties.load(inRuntimeProperties);\n            inRuntimeProperties.close();\n            if (runtimeProperties != null) {\n                final Map<String, Object> propertiesMap = Maps.newHashMap();\n                for (final Map.Entry<Object, Object> entry : runtimeProperties.entrySet()) {\n                    propertiesMap.put((String) entry.getKey(), entry.getValue());\n                }\n                return propertiesMap;\n            }\n        }\n    } catch (Exception ignored) {\n    }\n    return Maps.newHashMap();\n}", "repo_id": "1", "comment": "/**\n * Load Batoo runtime properties\n *\n * @return runtime properties\n */\n", "repo_name": "BatooJPA-master/", "id": 72, "method_signature": "Map<String,Object> loadRuntimeProperties()"}, "BatooUtils.subtract": {"callee_method_names": ["Map<X,Y>.entrySet", "Map<X,Y>.get", "Map<X,Y>.containsKey", "Y.equals", "Map<X, Y>.put"], "method_name": "BatooUtils.subtract", "method_implementation": "{\n    final Map<X, Y> map = Maps.newHashMap();\n    for (Map.Entry<X, Y> entryA : a.entrySet()) {\n        final X key = entryA.getKey();\n        final Y valueA = entryA.getValue();\n        final Y valueB = b.get(key);\n        if (!(b.containsKey(key) && valueB.equals(valueA))) {\n            map.put(key, valueB);\n        }\n    }\n    return map;\n}", "repo_id": "1", "comment": "/**\n * @param <X>\n *            type of key\n * @param <Y>\n *            type of value\n * @param a\n *            first map\n * @param b\n *            second map\n * @return the subtracted map\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 74, "method_signature": "Map<X,Y> subtract(Map, Map)"}, "BatooUtils.tree": {"callee_method_names": ["String.replaceAll"], "method_name": "BatooUtils.tree", "method_implementation": "{\n    if (StringUtils.isBlank(str)) {\n        return \"\";\n    }\n    return \"|-->\" + str.replaceAll(\"\\n\", \"\\n|   \");\n}", "repo_id": "1", "comment": "/**\n * Indents the <code>string</code> by one <code>tab</code>.\n *\n * @param str\n *            string to indent\n * @return the indented string\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 75, "method_signature": "String tree(String)"}, "BooleanExpression.generateSqlRestriction": {"callee_method_names": ["BaseQueryImpl<?>.getJdbcAdaptor"], "method_name": "BooleanExpression.generateSqlRestriction", "method_implementation": "{\n    if (this.inner instanceof BasicPath) {\n        return query.getJdbcAdaptor().castBoolean(this.inner.getSqlRestrictionFragments(query)[0]);\n    }\n    return this.inner.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * Returns the SQL where fragment.\n *\n * @param query\n *            the query\n * @return the SQL select fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 643, "method_signature": "String generateSqlRestriction(BaseQueryImpl)"}, "BooleanExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "BooleanExpression.getSqlRestrictionFragments", "method_implementation": "{\n    if (this.inner != null) {\n        return this.inner.getSqlRestrictionFragments(query);\n    }\n    return new String[] { this.generateSqlRestriction(query) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 644, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "Callback.fire": {"callee_method_names": [], "method_name": "Callback.fire", "method_implementation": "{\n    try {\n        if (this.callbackType == CallbackType.CALLBACK) {\n            this.method.invoke(instance);\n        } else {\n            this.method.invoke(this.instance, instance);\n        }\n    } catch (final Exception e) {\n        throw new PersistenceException(\"Error while invoking callback or listener\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Fires the callback.\n *\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 498, "method_signature": "void fire(Object)"}, "CallbackAvailability.updateAvailability": {"callee_method_names": ["CallbackManager.preRemove", "CallbackManager.postRemove", "CallbackManager.prePersist", "CallbackManager.preUpdate", "CallbackManager.postPersist", "CallbackManager.postUpdate", "CallbackManager.postLoad"], "method_name": "CallbackAvailability.updateAvailability", "method_implementation": "{\n    this.preRemove |= callbackManager.preRemove() != null;\n    this.postRemove |= callbackManager.postRemove() != null;\n    this.preWrite |= (callbackManager.prePersist() != null) || (callbackManager.preUpdate() != null);\n    this.postWrite |= (callbackManager.postPersist() != null) || (callbackManager.postUpdate() != null);\n    this.postLoad |= callbackManager.postLoad() != null;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * Updates the availability.\n *\n * @param callbackManager\n *            the callback manager\n * @return the updated availability\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 425, "method_signature": "CallbackAvailability updateAvailability(CallbackManager)"}, "CallbackManager.fireCallbacks": {"callee_method_names": [], "method_name": "CallbackManager.fireCallbacks", "method_implementation": "{\n    Callback[] callbacks = null;\n    switch(type) {\n        case POST_LOAD:\n            callbacks = this.postLoad;\n            break;\n        case POST_REMOVE:\n            callbacks = this.postRemove;\n            break;\n        case POST_PERSIST:\n            callbacks = this.postPersist;\n            break;\n        case POST_UPDATE:\n            callbacks = this.postUpdate;\n            break;\n        case PRE_PERSIST:\n            callbacks = this.prePersist;\n            break;\n        case PRE_REMOVE:\n            callbacks = this.preRemove;\n            break;\n        case PRE_UPDATE:\n            callbacks = this.preUpdate;\n            break;\n    }\n    if (callbacks != null) {\n        for (final Callback callback : callbacks) {\n            callback.fire(instance);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Fires the callbacks.\n *\n * @param instance\n *            the instance\n * @param type\n *            the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 473, "method_signature": "void fireCallbacks(Object, EntityListenerType)"}, "CallbackManager.getAvailibility": {"callee_method_ids": [425], "callee_method_names": ["MetamodelImpl.updateAvailability", "IdentifiableTypeImpl<?>.updateAvailability", "CallbackAvailability.updateAvailability"], "method_name": "CallbackManager.getAvailibility", "method_implementation": "{\n    final CallbackAvailability availability = new CallbackAvailability();\n    if (!this.excludeDefaultListeners) {\n        metamodel.updateAvailability(availability);\n    }\n    if (!this.excludeSuperclassListeners && (superType != null)) {\n        superType.updateAvailability(availability, null);\n    }\n    return availability.updateAvailability(this);\n}", "repo_id": "1", "comment": "/**\n * Returns the callback availability.\n *\n * @param metamodel\n *            the metamodel\n * @param superType\n *            the super type, may be <code>null</code>\n * @return the availability\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 474, "method_signature": "CallbackAvailability getAvailibility(MetamodelImpl, IdentifiableTypeImpl)"}, "CaseImpl.generateJpqlRestriction": {"callee_method_names": ["AbstractExpression<Boolean>.generateJpqlRestriction", "AbstractExpression<? extends T>.generateJpqlRestriction"], "method_name": "CaseImpl.generateJpqlRestriction", "method_implementation": "{\n    final String whens = Joiner.on(\"\\n\\t\").join(//\n    Lists.//\n    transform(//\n    this.conditions, new Function<Pair<Expression<Boolean>, Expression<? extends T>>, String>() {\n\n        @Override\n        public String apply(Pair<Expression<Boolean>, Expression<? extends T>> input) {\n            final AbstractExpression<Boolean> when = (AbstractExpression<Boolean>) input.getFirst();\n            final AbstractExpression<? extends T> then = (AbstractExpression<? extends T>) input.getSecond();\n            return \"when \" + when.generateJpqlRestriction(query) + \" then \" + then.generateJpqlRestriction(query);\n        }\n    }));\n    final String otherwise = \"\\n\\telse \" + ((AbstractExpression<? extends T>) this.otherwise).generateJpqlRestriction(query);\n    return \"case\\n\\t\" + whens + otherwise + \"\\nend\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 670, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "CaseImpl.generateJpqlSelect": {"callee_method_names": [], "method_name": "CaseImpl.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 671, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CaseImpl.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "CaseImpl.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 672, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CaseImpl.getSqlRestrictionFragments": {"callee_method_names": ["AbstractExpression<Boolean>.getSqlRestrictionFragments", "AbstractExpression<? extends T>.getSqlRestrictionFragments"], "method_name": "CaseImpl.getSqlRestrictionFragments", "method_implementation": "{\n    final String whens = Joiner.on(\"\\n\\t\").join(//\n    Lists.//\n    transform(//\n    this.conditions, new Function<Pair<Expression<Boolean>, Expression<? extends T>>, String>() {\n\n        @Override\n        public String apply(Pair<Expression<Boolean>, Expression<? extends T>> input) {\n            final AbstractExpression<Boolean> when = (AbstractExpression<Boolean>) input.getFirst();\n            final AbstractExpression<? extends T> then = (AbstractExpression<? extends T>) input.getSecond();\n            return \"WHEN \" + when.getSqlRestrictionFragments(query)[0] + \" THEN \" + then.getSqlRestrictionFragments(query)[0];\n        }\n    }));\n    final String otherwise = \"\\n\\tELSE \" + ((AbstractExpression<? extends T>) this.otherwise).getSqlRestrictionFragments(query)[0];\n    return new String[] { \"CASE\\n\\t\" + whens + otherwise + \"\\nEND\" };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 673, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "CaseImpl.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "CaseImpl.handle", "method_implementation": "{\n    return (T) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 674, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "CaseImpl.otherwise": {"callee_method_names": [], "method_name": "CaseImpl.otherwise", "method_implementation": "{\n    this.otherwise = result;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 675, "method_signature": "Expression<T> otherwise(Expression)"}, "CaseImpl.when": {"callee_method_names": [], "method_name": "CaseImpl.when", "method_implementation": "{\n    this.conditions.add(new Pair<Expression<Boolean>, Expression<? extends T>>(condition, result));\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 676, "method_signature": "Case<T> when(Expression, Expression)"}, "CaseJpqlTest.testCase1": {"callee_method_names": [], "method_name": "CaseJpqlTest.testCase1", "method_implementation": "{\n    this.persist(new Foo(1, \"1\", FooType.TYPE1));\n    this.persist(new Foo(2, \"2\", FooType.TYPE2));\n    this.persist(new Foo(3, \"3\", FooType.TYPE3));\n    this.commit();\n    this.close();\n    //\n    Assert.//\n    assertEquals(//\n    14, this.cq(//\n    \"select sum(case\\n\" + //\n    \"    when f.number = 1 then 1 * f.number\\n\" + //\n    \"    when f.number = 2 then 2 * f.number\\n\" + //\n    \"    else 3 * f.number\\n\" + //\n    \"  end)\\n\" + \"from Foo f\", Number.class).getSingleResult().intValue());\n    //\n    Assert.//\n    assertEquals(//\n    14, this.cq(//\n    \"select sum(case f.number\\n\" + //\n    \"    when 1 then 1 * f.number\\n\" + //\n    \"    when 2 then 2 * f.number\\n\" + //\n    \"    else 3 * f.number\\n\" + //\n    \"  end)\\n\" + \"from Foo f\", Number.class).getSingleResult().intValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2403, "method_signature": "void testCase1()"}, "CaseJpqlTest.testCase2": {"callee_method_names": [], "method_name": "CaseJpqlTest.testCase2", "method_implementation": "{\n    this.persist(new Foo(null, 1));\n    this.persist(new Foo(5, 7));\n    this.persist(new Foo(3, null));\n    this.commit();\n    this.close();\n    Assert.assertEquals(9, this.cq(\"select sum(coalesce(f.number, f.number2)) from Foo f\", Number.class).getSingleResult().intValue());\n    Assert.assertEquals(11, this.cq(\"select sum(coalesce(f.number2, f.number)) from Foo f\", Number.class).getSingleResult().intValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2404, "method_signature": "void testCase2()"}, "CaseJpqlTest.testNullif": {"callee_method_names": [], "method_name": "CaseJpqlTest.testNullif", "method_implementation": "{\n    this.persist(new Foo(2, 1));\n    this.persist(new Foo(5, 7));\n    this.persist(new Foo(null, 2));\n    this.commit();\n    this.close();\n    Assert.assertEquals(5, this.cq(\"select sum(nullif(f.number, 2)) from Foo f\", Number.class).getSingleResult().intValue());\n    Assert.assertEquals(8, this.cq(\"select sum(nullif(coalesce(f.number2, f.number), 2)) from Foo f\", Number.class).getSingleResult().intValue());\n    Assert.assertEquals(10, this.cq(\"select sum(nullif(coalesce(f.number2, f.number), 5)) from Foo f\", Number.class).getSingleResult().intValue());\n    Assert.assertEquals(10, this.cq(\"select sum(nullif(coalesce(f.number2, f.number), 99)) from Foo f\", Number.class).getSingleResult().intValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2405, "method_signature": "void testNullif()"}, "CaseTransformationExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "CaseTransformationExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 679, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CaseTransformationExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "CaseTransformationExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.generateSqlRestriction(query) + \" AS \" + this.alias;\n    }\n    return this.generateSqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 680, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CastExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "CastExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 558, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CastExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "CastExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 559, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CastExpression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "CastExpression.handle", "method_implementation": "{\n    return (T) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 560, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "ChildElement.toString": {"callee_method_names": [], "method_name": "ChildElement.toString", "method_implementation": "{\n    return //\n    new ToStringBuilder(this, DetailLevel.SHORT).excludeFieldNames(\"parent\", \"attributes\", //\n    \"expectedChildElements\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1088, "method_signature": "String toString()"}, "ClassloaderAnnotatedClassLocator.locateClasses": {"callee_method_names": ["URL.getFile", "PersistenceUnitInfo.getClassLoader", "HashSet<Class<?>>.toString"], "method_name": "ClassloaderAnnotatedClassLocator.locateClasses", "method_implementation": "{\n    final String root = FilenameUtils.separatorsToUnix(FilenameUtils.normalize(url.getFile()));\n    ClassloaderAnnotatedClassLocator.LOG.info(\"Checking persistence root {0} for persistence classes...\", root);\n    final HashSet<Class<?>> classes = Sets.newHashSet();\n    try {\n        return this.findClasses(persistenceUnitInfo.getClassLoader(), classes, root, root);\n    } finally {\n        ClassloaderAnnotatedClassLocator.LOG.info(\"Found persistent classes {0}\", classes.toString());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1052, "method_signature": "Set<Class<?>> locateClasses(PersistenceUnitInfo, URL)"}, "CoalesceExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "CoalesceExpression.generateJpqlRestriction", "method_implementation": "{\n    return \"coalesce(\" + Joiner.on(\", \").join(Lists.transform(this.values, new Function<Expression<? extends T>, String>() {\n\n        @Override\n        public String apply(Expression<? extends T> input) {\n            return ((AbstractExpression<? extends T>) input).generateJpqlRestriction(query);\n        }\n    })) + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 608, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "CoalesceExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "CoalesceExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 609, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CoalesceExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "CoalesceExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 610, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CoalesceExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "CoalesceExpression.getSqlRestrictionFragments", "method_implementation": "{\n    return new String[] { \"COALESCE(\" + Joiner.on(\", \").join(Lists.transform(this.values, new Function<Expression<? extends T>, String>() {\n\n        @Override\n        public String apply(Expression<? extends T> input) {\n            return ((AbstractExpression<? extends T>) input).getSqlRestrictionFragments(query)[0];\n        }\n    })) + \")\" };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 611, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "CoalesceExpression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "CoalesceExpression.handle", "method_implementation": "{\n    return (T) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 612, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "CoalesceExpression.value": {"callee_method_names": [], "method_name": "CoalesceExpression.value", "method_implementation": "{\n    this.values.add(value);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 613, "method_signature": "CoalesceExpression<T> value(Expression)"}, "CollectionAttributeImpl.newCollection": {"callee_method_names": [], "method_name": "CollectionAttributeImpl.newCollection", "method_implementation": "{\n    return new ManagedList<X, E>(mapping, managedInstance, (Collection<? extends E>) values);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 287, "method_signature": "Collection<E> newCollection(PluralMappingEx, ManagedInstance, Object)"}, "CollectionJoinImpl.getModel": {"callee_method_names": [], "method_name": "CollectionJoinImpl.getModel", "method_implementation": "{\n    return (CollectionAttribute<? super Z, E>) this.getAttribute();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 854, "method_signature": "CollectionAttribute<? super Z,E> getModel()"}, "CollectionTable.link": {"callee_method_names": ["EntityTypeDescriptor.getName", "ColumnMetadata.getName", "ColumnMetadata.getName", "TypeDescriptor.getJavaType"], "method_name": "CollectionTable.link", "method_implementation": "{\n    if (StringUtils.isBlank(this.getName())) {\n        this.setName(entity.getName() + \"_\" + defaultName);\n    }\n    this.key.link(null, entity);\n    this.key.setTable(this);\n    this.elementColumn = new //\n    ElementColumn(//\n    this.jdbcAdaptor, //\n    this.mapping, //\n    this, //\n    (metadata == null) || StringUtils.isBlank(metadata.getName()) ? defaultName : metadata.getName(), //\n    type.getJavaType(), //\n    enumType, //\n    temporalType, //\n    lob, metadata);\n}", "repo_id": "1", "comment": "/**\n * Links the collection table.\n *\n * @param entity\n *            the root entity\n * @param type\n *            the type of the collection\n * @param defaultName\n *            the default name\n * @param metadata\n *            the column metadata\n * @param lob\n *            if the column is a lob type\n * @param temporalType\n *            the temporal type\n * @param enumType\n *            the enum type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1336, "method_signature": "void link(EntityTypeDescriptor, TypeDescriptor, String, ColumnMetadata, EnumType, TemporalType, boolean)"}, "CollectionTable.performInsert": {"callee_method_names": ["Joinable[].getIndex", "Joinable[].getKey", "Joinable[].getValue", "AbstractColumn.getValue", "AbstractColumn.getValue", "Joinable[].getValue", "AbstractColumn.isLob"], "method_name": "CollectionTable.performInsert", "method_implementation": "{\n    final String insertSql = this.getInsertSql(null, size);\n    final AbstractColumn[] insertColumns = this.getInsertColumns(null, size);\n    // prepare the parameters\n    final Object[] params = new Object[insertColumns.length * size];\n    boolean hasLob = false;\n    int paramIndex = 0;\n    for (int i = 0; i < size; i++) {\n        for (final AbstractColumn column : insertColumns) {\n            if (column == this.orderColumn) {\n                params[paramIndex++] = batch[i].getIndex();\n            } else if (column == this.keyColumn) {\n                params[paramIndex++] = this.keyColumn.getValue(connection, batch[i].getKey());\n            } else if (this.elementColumn == column) {\n                params[paramIndex++] = this.elementColumn.getValue(connection, batch[i].getValue());\n            } else if (column instanceof JoinColumn) {\n                params[paramIndex++] = column.getValue(connection, source);\n            } else {\n                params[paramIndex++] = column.getValue(connection, batch[i].getValue());\n            }\n            hasLob |= column.isLob();\n        }\n    }\n    new QueryRunner(this.jdbcAdaptor, hasLob).update(connection, insertSql, params);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1337, "method_signature": "void performInsert(Connection, Object, Joinable[], int)"}, "CollectionTable.performRemove": {"callee_method_names": ["AbstractColumn.getValue", "AbstractColumn.getValue", "AbstractColumn.getValue", "AbstractColumn.isLob"], "method_name": "CollectionTable.performRemove", "method_implementation": "{\n    final String removeSql = this.getRemoveSql();\n    final Object[] params = new Object[this.removeColumns.length];\n    boolean hasLob = false;\n    int i = 0;\n    for (final AbstractColumn column : this.removeColumns) {\n        if (column instanceof ElementColumn) {\n            params[i++] = column.getValue(connection, destination);\n        } else if (column == this.keyColumn) {\n            params[i++] = this.keyColumn.getValue(connection, key);\n            ;\n        } else if (column instanceof JoinColumn) {\n            params[i++] = column.getValue(connection, source);\n        } else {\n            params[i++] = column.getValue(connection, destination);\n        }\n        hasLob |= column.isLob();\n    }\n    new QueryRunner(this.jdbcAdaptor, hasLob).update(connection, removeSql, params);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1338, "method_signature": "void performRemove(Connection, Object, Object, Object)"}, "CollectionTable.performRemoveAll": {"callee_method_names": [], "method_name": "CollectionTable.performRemoveAll", "method_implementation": "{\n    final String removeAllSql = this.getRemoveAllSql();\n    final Object[] params = new Object[this.removeAllColumns.length];\n    int i = 0;\n    for (final JoinColumn sourceRemoveColumn : this.removeAllColumns) {\n        params[i++] = sourceRemoveColumn.getValue(connection, source);\n    }\n    new QueryRunner(this.jdbcAdaptor, false).update(connection, removeAllSql, params);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1339, "method_signature": "void performRemoveAll(Connection, Object)"}, "CollectionTableElement.handleChild": {"callee_method_names": [], "method_name": "CollectionTableElement.handleChild", "method_implementation": "{\n    super.handleChild(child);\n    if (child instanceof JoinColumnMetadata) {\n        this.joinColumns.add((JoinColumnMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1085, "method_signature": "void handleChild(Element)"}, "CollectionUtils.contains": {"callee_method_names": ["Iterator<?>.hasNext", "Iterator<?>.next"], "method_name": "CollectionUtils.contains", "method_implementation": "{\n    if (iterator != null) {\n        while (iterator.hasNext()) {\n            final Object candidate = iterator.next();\n            if (ObjectUtils.nullSafeEquals(candidate, element)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Check whether the given Iterator contains the given element.\n *\n * @param iterator\n *            the Iterator to check\n * @param element\n *            the element to look for\n * @return <code>true</code> if found, <code>false</code> else\n */\n", "repo_name": "BatooJPA-master/", "id": 106, "method_signature": "boolean contains(Iterator, Object)"}, "CollectionUtils.containsAny": {"callee_method_names": ["Collection<?>.contains"], "method_name": "CollectionUtils.containsAny", "method_implementation": "{\n    if (CollectionUtils.isEmpty(source) || CollectionUtils.isEmpty(candidates)) {\n        return false;\n    }\n    for (final Object candidate : candidates) {\n        if (source.contains(candidate)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Return <code>true</code> if any element in '<code>candidates</code>' is contained in '<code>source</code>'; otherwise returns\n * <code>false</code>.\n *\n * @param source\n *            the source Collection\n * @param candidates\n *            the candidates to search for\n * @return whether any of the candidates has been found\n */\n", "repo_name": "BatooJPA-master/", "id": 107, "method_signature": "boolean containsAny(Collection, Collection)"}, "CollectionUtils.containsInstance": {"callee_method_names": [], "method_name": "CollectionUtils.containsInstance", "method_implementation": "{\n    if (collection != null) {\n        for (final Object candidate : collection) {\n            if (candidate == element) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Check whether the given Collection contains the given element instance.\n * <p>\n * Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.\n *\n * @param collection\n *            the Collection to check\n * @param element\n *            the element to look for\n * @return <code>true</code> if found, <code>false</code> else\n */\n", "repo_name": "BatooJPA-master/", "id": 108, "method_signature": "boolean containsInstance(Collection, Object)"}, "CollectionUtils.findCommonElementType": {"callee_method_names": [], "method_name": "CollectionUtils.findCommonElementType", "method_implementation": "{\n    if (CollectionUtils.isEmpty(collection)) {\n        return null;\n    }\n    Class<?> candidate = null;\n    for (final Object val : collection) {\n        if (val != null) {\n            if (candidate == null) {\n                candidate = val.getClass();\n            } else if (candidate != val.getClass()) {\n                return null;\n            }\n        }\n    }\n    return candidate;\n}", "repo_id": "1", "comment": "/**\n * Find the common element type of the given Collection, if any.\n *\n * @param collection\n *            the Collection to check\n * @return the common element type, or <code>null</code> if no clear common type has been found (or the collection was empty)\n */\n", "repo_name": "BatooJPA-master/", "id": 109, "method_signature": "Class<?> findCommonElementType(Collection)"}, "CollectionUtils.findFirstMatch": {"callee_method_names": ["Collection<?>.contains"], "method_name": "CollectionUtils.findFirstMatch", "method_implementation": "{\n    if (CollectionUtils.isEmpty(source) || CollectionUtils.isEmpty(candidates)) {\n        return null;\n    }\n    for (final Object candidate : candidates) {\n        if (source.contains(candidate)) {\n            return candidate;\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '\n * <code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection}\n * implementation specific.\n *\n * @param source\n *            the source Collection\n * @param candidates\n *            the candidates to search for\n * @return the first present object, or <code>null</code> if not found\n */\n", "repo_name": "BatooJPA-master/", "id": 110, "method_signature": "Object findFirstMatch(Collection, Collection)"}, "CollectionUtils.findValueOfType": {"callee_method_names": ["Class<T>.isInstance"], "method_name": "CollectionUtils.findValueOfType", "method_implementation": "{\n    if (CollectionUtils.isEmpty(collection)) {\n        return null;\n    }\n    T value = null;\n    for (final Object element : collection) {\n        if ((type == null) || type.isInstance(element)) {\n            if (value != null) {\n                // More than one value found... no clear single value.\n                return null;\n            }\n            value = (T) element;\n        }\n    }\n    return value;\n}", "repo_id": "1", "comment": "/**\n * Find a single value of the given type in the given Collection.\n *\n * @param collection\n *            the Collection to search\n * @param type\n *            the type to look for\n * @return a value of the given type found if there is a clear match, or <code>null</code> if none or more than one such value found\n * @param <T>\n *            the type of the type\n */\n", "repo_name": "BatooJPA-master/", "id": 112, "method_signature": "T findValueOfType(Collection, Class)"}, "CollectionUtils.hasUniqueObject": {"callee_method_names": [], "method_name": "CollectionUtils.hasUniqueObject", "method_implementation": "{\n    if (CollectionUtils.isEmpty(collection)) {\n        return false;\n    }\n    boolean hasCandidate = false;\n    Object candidate = null;\n    for (final Object elem : collection) {\n        if (!hasCandidate) {\n            hasCandidate = true;\n            candidate = elem;\n        } else if (candidate != elem) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * Determine whether the given Collection only contains a single unique object.\n *\n * @param collection\n *            the Collection to check\n * @return <code>true</code> if the collection contains a single reference or multiple references to the same instance,\n *         <code>false</code> else\n */\n", "repo_name": "BatooJPA-master/", "id": 113, "method_signature": "boolean hasUniqueObject(Collection)"}, "CollectionUtils.mergeArrayIntoCollection": {"callee_method_names": ["Collection.add"], "method_name": "CollectionUtils.mergeArrayIntoCollection", "method_implementation": "{\n    if (collection == null) {\n        throw new IllegalArgumentException(\"Collection must not be null\");\n    }\n    final Object[] arr = ObjectUtils.toObjectArray(array);\n    for (final Object elem : arr) {\n        collection.add(elem);\n    }\n}", "repo_id": "1", "comment": "/**\n * Merge the given array into the given Collection.\n *\n * @param array\n *            the array to merge (may be <code>null</code>)\n * @param collection\n *            the target Collection to merge the array into\n */\n", "repo_name": "BatooJPA-master/", "id": 114, "method_signature": "void mergeArrayIntoCollection(Object, Collection)"}, "CollectionUtils.mergePropertiesIntoMap": {"callee_method_names": ["Properties.propertyNames", "Properties.getProperty", "Properties.get", "Map.put"], "method_name": "CollectionUtils.mergePropertiesIntoMap", "method_implementation": "{\n    if (map == null) {\n        throw new IllegalArgumentException(\"Map must not be null\");\n    }\n    if (props != null) {\n        for (final Enumeration<?> en = props.propertyNames(); en.hasMoreElements(); ) {\n            final String key = (String) en.nextElement();\n            Object value = props.getProperty(key);\n            if (value == null) {\n                // Potentially a non-String value...\n                value = props.get(key);\n            }\n            map.put(key, value);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Merge the given Properties instance into the given Map, copying all properties (key-value pairs) over.\n * <p>\n * Uses <code>Properties.propertyNames()</code> to even catch default properties linked into the original Properties instance.\n *\n * @param props\n *            the Properties instance to merge (may be <code>null</code>)\n * @param map\n *            the target Map to merge the properties into\n */\n", "repo_name": "BatooJPA-master/", "id": 115, "method_signature": "void mergePropertiesIntoMap(Properties, Map)"}, "CollectionUtils.toArray": {"callee_method_names": ["Enumeration<E>.hasMoreElements", "ArrayList<A>.add", "Enumeration<E>.nextElement", "ArrayList<A>.toArray"], "method_name": "CollectionUtils.toArray", "method_implementation": "{\n    final ArrayList<A> elements = new ArrayList<A>();\n    while (enumeration.hasMoreElements()) {\n        elements.add(enumeration.nextElement());\n    }\n    return elements.toArray(array);\n}", "repo_id": "1", "comment": "/**\n * Marshal the elements from the given enumeration into an array of the given type. Enumeration elements must be assignable to the type\n * of the given array. The array returned will be a different instance than the array given.\n *\n * @param enumeration\n *            the enumeration\n * @param array\n *            the array\n * @return the array representation of the enumeration\n * @param <A>\n *            the type of the array\n * @param <E>\n *            the type of th enumeration\n */\n", "repo_name": "BatooJPA-master/", "id": 116, "method_signature": "A[] toArray(Enumeration, A[])"}, "CollectionUtils.unmodifiableMultiValueMap": {"callee_method_names": ["MultiValueMap<? extends K,? extends V>.size", "MultiValueMap<? extends K,? extends V>.entrySet", "Entry.getValue", "Map<K, List<V>>.put", "Entry.getKey"], "method_name": "CollectionUtils.unmodifiableMultiValueMap", "method_implementation": "{\n    Assert.notNull(map, \"'map' must not be null\");\n    final Map<K, List<V>> result = new LinkedHashMap<K, List<V>>(map.size());\n    for (final Map.Entry<? extends K, ? extends List<? extends V>> entry : map.entrySet()) {\n        final List<V> values = Collections.unmodifiableList(entry.getValue());\n        result.put(entry.getKey(), values);\n    }\n    final Map<K, List<V>> unmodifiableMap = Collections.unmodifiableMap(result);\n    return CollectionUtils.toMultiValueMap(unmodifiableMap);\n}", "repo_id": "1", "comment": "/**\n * Returns an unmodifiable view of the specified multi-value map.\n *\n * @param map\n *            the map for which an unmodifiable view is to be returned.\n * @return an unmodifiable view of the specified multi-value map.\n * @param <K>\n *            the key type of the map\n * @param <V>\n *            the value type of the map\n */\n", "repo_name": "BatooJPA-master/", "id": 117, "method_signature": "MultiValueMap<K,V> unmodifiableMultiValueMap(MultiValueMap)"}, "ColumnElement.generate": {"callee_method_names": [], "method_name": "ColumnElement.generate", "method_implementation": "{\n    super.generate();\n    this.length = this.getAttribute(ElementConstants.ATTR_LENGTH, 255);\n    this.precision = this.getAttribute(ElementConstants.ATTR_PRECISION, 0);\n    this.scale = this.getAttribute(ElementConstants.ATTR_SCALE, 0);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1128, "method_signature": "void generate()"}, "ColumnNameListHandler.handle": {"callee_method_names": ["ResultSet.getMetaData", "ResultSetMetaData.getColumnCount", "List<String>.add", "ResultSetMetaData.getColumnName", "List<String>.toString"], "method_name": "ColumnNameListHandler.handle", "method_implementation": "{\n    final List<String> list = Lists.newArrayList();\n    final ResultSetMetaData metaData = rs.getMetaData();\n    final int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n        list.add(metaData.getColumnName(i).toLowerCase(Locale.ENGLISH));\n    }\n    Collections.sort(list);\n    return list.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2444, "method_signature": "String handle(ResultSet)"}, "ColumnTransformerTest.testPersist": {"callee_method_names": [], "method_name": "ColumnTransformerTest.testPersist", "method_implementation": "{\n    final FooRead fooRead = this.newFooRead();\n    this.persist(fooRead);\n    final FooWrite fooWrite = this.newFooWrite();\n    this.persist(fooWrite);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM FooRead\", new SingleValueHandler<Number>()).intValue());\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM FooWrite\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if fails\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2462, "method_signature": "void testPersist()"}, "ColumnTransformerTest.testRead": {"callee_method_names": ["FooRead.getId", "FooRead.getId", "FooRead.getId", "FooRead.getValue", "FooRead.getValue"], "method_name": "ColumnTransformerTest.testRead", "method_implementation": "{\n    final FooRead foo = this.newFooRead();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooRead foo2 = this.find(FooRead.class, foo.getId());\n    Assert.assertEquals(foo.getId(), foo2.getId());\n    Assert.assertEquals(foo.getValue().trim(), foo2.getValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2463, "method_signature": "void testRead()"}, "ColumnTransformerTest.testWrite": {"callee_method_names": ["String.trim"], "method_name": "ColumnTransformerTest.testWrite", "method_implementation": "{\n    final FooWrite foo = this.newFooWrite();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    Assert.assertEquals(WRITE_STR.trim(), new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT colname FROM FooWrite\", new SingleValueHandler<String>()));\n}", "repo_id": "1", "comment": "/**\n * @throws SQLException  \t            thrown if fails\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2464, "method_signature": "void testWrite()"}, "ColumnTransformerTest.testWrite2": {"callee_method_names": ["FooWrite.getId", "FooWrite.getId", "FooWrite.getId", "String.trim", "FooWrite.getValue"], "method_name": "ColumnTransformerTest.testWrite2", "method_implementation": "{\n    final FooWrite foo = this.newFooWrite();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooWrite foo2 = this.find(FooWrite.class, foo.getId());\n    this.refresh(foo2);\n    Assert.assertEquals(foo.getId(), foo2.getId());\n    Assert.assertEquals(WRITE_STR.trim(), foo2.getValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2465, "method_signature": "void testWrite2()"}, "CommonTreePrinter.toString": {"callee_method_names": ["StringBuilder.toString"], "method_name": "CommonTreePrinter.toString", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    CommonTreePrinter.print(builder, root, \"\", true);\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * Returns the string representation of a common tree.\n *\n * @param root\n *            the root of the tree\n * @return the string representation of a common tree\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2508, "method_signature": "String toString(Tree)"}, "ComparisonExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "ComparisonExpression.generateJpqlRestriction", "method_implementation": "{\n    if (this.z != null) {\n        return //\n        MessageFormat.//\n        format(//\n        this.comparison.fragment, //\n        this.x.generateJpqlRestriction(query), //\n        this.y.generateJpqlRestriction(query), this.z.generateJpqlRestriction(query));\n    }\n    return //\n    MessageFormat.//\n    format(//\n    this.comparison.fragment, //\n    this.x.generateJpqlRestriction(query), this.y.generateJpqlRestriction(query));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 577, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "ComparisonExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "ComparisonExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 578, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "ComparisonExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "ComparisonExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 579, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "ComparisonExpression.getSqlRestrictionFragments": {"callee_method_names": ["List<String>.add", "List<String>.add"], "method_name": "ComparisonExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final String[] left = this.x.getSqlRestrictionFragments(query);\n    final String[] right1 = this.y.getSqlRestrictionFragments(query);\n    final String[] right2 = this.z != null ? this.z.getSqlRestrictionFragments(query) : null;\n    final List<String> restrictions = Lists.newArrayList();\n    for (int i = 0; i < left.length; i++) {\n        if (this.z != null) {\n            restrictions.add(MessageFormat.format(this.comparison.fragment, left[i], right1[i], right2[i]));\n        } else {\n            restrictions.add(MessageFormat.format(this.comparison.fragment, left[i], right1[i]));\n        }\n    }\n    return new String[] { Joiner.on(\" AND \").join(restrictions) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 580, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "ComplexInheritanceTest.testComplex1": {"callee_method_names": [], "method_name": "ComplexInheritanceTest.testComplex1", "method_implementation": "{\n    this.em();\n    this.setupEmf();\n}", "repo_id": "1", "comment": "/**\n * Tests the complex select\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2231, "method_signature": "void testComplex1()"}, "ComplianceTest.prepareCountries": {"callee_method_names": [], "method_name": "ComplianceTest.prepareCountries", "method_implementation": "{\n    this.begin();\n    this.persist(ComplianceTest.TR);\n    this.persist(ComplianceTest.USA);\n    this.persist(ComplianceTest.UK);\n    this.persist(ComplianceTest.BROKEN);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2400, "method_signature": "void prepareCountries()"}, "ComplianceTest.testCast": {"callee_method_names": [], "method_name": "ComplianceTest.testCast", "method_implementation": "{\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    Assert.assertEquals(Byte.class, this.cq(\"select cast(p.age as byte) from Person p\", Number.class).getSingleResult().getClass());\n    Assert.assertEquals(Short.class, this.cq(\"select cast(p.age as short) from Person p\", Number.class).getSingleResult().getClass());\n    Assert.assertEquals(Integer.class, this.cq(\"select cast(p.age as int) from Person p\", Number.class).getSingleResult().getClass());\n    Assert.assertEquals(Integer.class, this.cq(\"select cast(p.age as integer) from Person p\", Number.class).getSingleResult().getClass());\n    Assert.assertEquals(Long.class, this.cq(\"select cast(p.age as long) from Person p\", Number.class).getSingleResult().getClass());\n    Assert.assertEquals(Float.class, this.cq(\"select cast(p.age as float) from Person p\", Number.class).getSingleResult().getClass());\n    Assert.assertEquals(Double.class, this.cq(\"select cast(p.age as double) from Person p\", Number.class).getSingleResult().getClass());\n    Assert.assertEquals(String.class, this.cq(\"select cast(p.age as string) from Person p\", String.class).getSingleResult().getClass());\n    Assert.assertEquals(String.class, this.cq(\"select cast(p.age as varchar) from Person p\", String.class).getSingleResult().getClass());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2401, "method_signature": "void testCast()"}, "ComplianceTest.testFetchAllProperties": {"callee_method_names": ["PersistenceUnitUtil.isLoaded", "PersistenceUnitUtil.isLoaded", "PersistenceUnitUtil.isLoaded"], "method_name": "ComplianceTest.testFetchAllProperties", "method_implementation": "{\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    final Person person = this.cq(\"select distinct p from Person p fetch all properties inner join p.workPhones w\", Person.class).getSingleResult();\n    final PersistenceUnitUtil util = this.em().getEntityManagerFactory().getPersistenceUnitUtil();\n    Assert.assertTrue(util.isLoaded(person, \"addresses\"));\n    Assert.assertTrue(util.isLoaded(person, \"phones\"));\n    Assert.assertTrue(util.isLoaded(person, \"workPhones\"));\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2402, "method_signature": "void testFetchAllProperties()"}, "CompoundSelectionImpl.generateJpqlSelect": {"callee_method_names": [], "method_name": "CompoundSelectionImpl.generateJpqlSelect", "method_implementation": "{\n    return Joiner.on(\", \").join(Lists.transform(this.selections, new Function<AbstractSelection<?>, String>() {\n\n        @Override\n        public String apply(AbstractSelection<?> input) {\n            return input.generateJpqlSelect(null, selected);\n        }\n    }));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 740, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CompoundSelectionImpl.generateSqlSelect": {"callee_method_names": [], "method_name": "CompoundSelectionImpl.generateSqlSelect", "method_implementation": "{\n    return Joiner.on(\",\\n\").join(Lists.transform(this.selections, new Function<AbstractSelection<?>, String>() {\n\n        @Override\n        public String apply(AbstractSelection<?> input) {\n            return input.generateSqlSelect(query, selected);\n        }\n    }));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 741, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CompoundSelectionImpl.getAliases": {"callee_method_names": ["AbstractSelection<X>.getAlias"], "method_name": "CompoundSelectionImpl.getAliases", "method_implementation": "{\n    if (this.aliases != null) {\n        return this.aliases;\n    }\n    this.aliases = Lists.newArrayList();\n    for (final AbstractSelection<?> selection : this.selections) {\n        this.aliases.add(selection.getAlias());\n    }\n    return this.aliases;\n}", "repo_id": "1", "comment": "/**\n * Returns the alias.\n *\n * @return the alias\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 742, "method_signature": "List<String> getAliases()"}, "CompoundSelectionImpl.handle": {"callee_method_names": [], "method_name": "CompoundSelectionImpl.handle", "method_implementation": "{\n    final Object[] values = new Object[this.selections.size()];\n    for (int i = 0; i < this.selections.size(); i++) {\n        values[i] = this.selections.get(i).handle(query, session, row);\n    }\n    if (this.getJavaType() == Tuple.class) {\n        return (X) new TupleImpl(this.getAliases(), this.selections, values);\n    }\n    try {\n        return (X) (this.constructor != null ? this.constructor.newInstance(values) : values);\n    } catch (final Exception e) {\n        throw new PersistenceException(\"Cannot construct result object\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 743, "method_signature": "X handle(QueryImpl, SessionImpl, ResultSet)"}, "CompoundSelectionImpl.isEntityList": {"callee_method_names": ["AbstractSelection<X>.isEntityList"], "method_name": "CompoundSelectionImpl.isEntityList", "method_implementation": "{\n    for (final AbstractSelection<?> selection : this.selections) {\n        if (!selection.isEntityList()) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 744, "method_signature": "boolean isEntityList()"}, "ConcatExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "ConcatExpression.generateJpqlRestriction", "method_implementation": "{\n    final String expressions = Joiner.on(\", \").join(Lists.transform(this.arguments, new Function<Expression<String>, String>() {\n\n        @Override\n        public String apply(Expression<String> input) {\n            return ((AbstractExpression<String>) input).generateJpqlRestriction(query);\n        }\n    }));\n    return \"concat (\" + expressions + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 592, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "ConcatExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "ConcatExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 593, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "ConcatExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "ConcatExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.generateSqlRestriction(query) + \" AS \" + this.alias;\n    }\n    return this.generateSqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 594, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "ConnectionProxy.close": {"callee_method_names": [], "method_name": "ConnectionProxy.close", "method_implementation": "{\n    if (this.dataSourcePool != null) {\n        this.dataSourcePool.releaseConnection(this.connection);\n    } else {\n        this.connection.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1145, "method_signature": "void close()"}, "ConnectionProxy.createStatement": {"callee_method_names": ["Statement.setFetchSize"], "method_name": "ConnectionProxy.createStatement", "method_implementation": "{\n    final Statement statement = this.connection.createStatement();\n    statement.setFetchSize(this.jdbcFetchSize);\n    return statement;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1146, "method_signature": "Statement createStatement()"}, "ConnectionProxy.prepareStatement": {"callee_method_names": ["PreparedStatementProxy.setFetchSize"], "method_name": "ConnectionProxy.prepareStatement", "method_implementation": "{\n    final PreparedStatementProxy statement = new PreparedStatementProxy(sql, this.connection.prepareStatement(sql, columnNames), this.slowSqlThreshold, this.sqlLogging);\n    statement.setFetchSize(this.jdbcFetchSize);\n    return statement;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1152, "method_signature": "PreparedStatement prepareStatement(String, String[])"}, "CountExpression.generateJpqlRestriction": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CountExpression.generateJpqlRestriction", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"count(\");\n    if (this.distinct) {\n        builder.append(\"distinct \");\n    }\n    builder.append(this.inner.generateJpqlRestriction(query));\n    builder.append(\")\");\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 561, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "CountExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "CountExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 562, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CountExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "CountExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 563, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CountExpression.getSqlRestrictionFragments": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CountExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"COUNT(\");\n    if (this.distinct) {\n        builder.append(\"DISTINCT \");\n    }\n    builder.append(this.inner.getSqlRestrictionFragments(query)[0]);\n    builder.append(\")\");\n    return new String[] { builder.toString() };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 564, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "CriteriaBuilderImpl.and": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.and", "method_implementation": "{\n    return new PredicateImpl(false, BooleanOperator.AND, x, y);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 506, "method_signature": "PredicateImpl and(Expression, Expression)"}, "CriteriaBuilderImpl.between": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.between", "method_implementation": "{\n    if (x instanceof Expression && y instanceof Expression) {\n        return this.between(v, (Expression<? extends Y>) x, (Expression<? extends Y>) y);\n    }\n    final AbstractExpression<Y> constExpX;\n    final AbstractExpression<Y> constExpY;\n    if (v instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) v).getModel();\n        final Y toJdbcX = (Y) ValueConverter.toJdbc(x, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExpX = this.createConstant(toJdbcX, model.getJavaType());\n        final Y toJdbcY = (Y) ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExpY = this.createConstant(toJdbcY, model.getJavaType());\n    } else {\n        constExpX = this.createConstant(x);\n        constExpY = this.createConstant(y);\n    }\n    return new PredicateImpl(new ComparisonExpression(Comparison.BETWEEN, v, constExpX, constExpY));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 507, "method_signature": "PredicateImpl between(Expression, Y, Y)"}, "CriteriaBuilderImpl.concat": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.concat", "method_implementation": "{\n    return new ConcatExpression(this.createConstant(x), y);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 510, "method_signature": "Expression<String> concat(String, Expression)"}, "CriteriaBuilderImpl.conjunction": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.conjunction", "method_implementation": "{\n    return new PredicateImpl();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 511, "method_signature": "PredicateImpl conjunction()"}, "CriteriaBuilderImpl.createConstant": {"callee_method_names": ["X.getClass", "X.getClass", "TypeImpl<X>.getPersistenceType", "TypeImpl<X>.getPersistenceType"], "method_name": "CriteriaBuilderImpl.createConstant", "method_implementation": "{\n    if (x == null) {\n        throw new NullPointerException(\"Constant expression cannot be null\");\n    }\n    final Class<X> clazz = (Class<X>) (x instanceof EnhancedInstance ? x.getClass().getSuperclass() : x.getClass());\n    final TypeImpl<X> type = this.metamodel.type(clazz);\n    if ((type == null) || (type.getPersistenceType() == PersistenceType.MAPPED_SUPERCLASS)) {\n        throw new IllegalArgumentException(\"Cannot locate a type for the constant class: \" + x);\n    }\n    return type.getPersistenceType() == PersistenceType.BASIC ? new SimpleConstantExpression<X>(type, x) : new EntityConstantExpression<X>(type, x);\n}", "repo_id": "1", "comment": "/**\n * Checks to see the constant expression is not null and basic type.\n *\n * @param x\n *            the constant value\n * @return the type of the constant\n * @param <X>\n *            the type of the constant\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 512, "method_signature": "AbstractExpression<X> createConstant(X)"}, "CriteriaBuilderImpl.equal": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.equal", "method_implementation": "{\n    if (y instanceof Expression) {\n        return this.equal(x, (Expression<?>) y);\n    }\n    final AbstractExpression<Object> constExp;\n    if (x instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) x).getModel();\n        final Object toJdbc = ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExp = this.createConstant(toJdbc, model.getJavaType());\n    } else {\n        constExp = this.createConstant(y);\n    }\n    return new PredicateImpl(new ComparisonExpression(Comparison.EQUAL, x, constExp));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 513, "method_signature": "PredicateImpl equal(Expression, Object)"}, "CriteriaBuilderImpl.greaterThan": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.greaterThan", "method_implementation": "{\n    if (y instanceof Expression) {\n        return this.greaterThan(x, (Expression<? extends Y>) y);\n    }\n    final AbstractExpression<Y> constExp;\n    if (x instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) x).getModel();\n        final Y toJdbc = (Y) ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExp = this.createConstant(toJdbc, model.getJavaType());\n    } else {\n        constExp = this.createConstant(y);\n    }\n    return new PredicateImpl(new ComparisonExpression(Comparison.GREATER, x, constExp));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 514, "method_signature": "PredicateImpl greaterThan(Expression, Y)"}, "CriteriaBuilderImpl.greaterThanOrEqualTo": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.greaterThanOrEqualTo", "method_implementation": "{\n    if (y instanceof Expression) {\n        return this.greaterThanOrEqualTo(x, (Expression<? extends Y>) y);\n    }\n    final AbstractExpression<Y> constExp;\n    if (x instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) x).getModel();\n        final Y toJdbc = (Y) ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExp = this.createConstant(toJdbc, model.getJavaType());\n    } else {\n        constExp = this.createConstant(y);\n    }\n    return new PredicateImpl(new ComparisonExpression(Comparison.GREATER_OR_EQUAL, x, constExp));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 515, "method_signature": "PredicateImpl greaterThanOrEqualTo(Expression, Y)"}, "CriteriaBuilderImpl.lessThan": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.lessThan", "method_implementation": "{\n    if (y instanceof Expression) {\n        return this.greaterThan(x, (Expression<? extends Y>) y);\n    }\n    final AbstractExpression<Y> constExp;\n    if (x instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) x).getModel();\n        final Y toJdbc = (Y) ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExp = this.createConstant(toJdbc, model.getJavaType());\n    } else {\n        constExp = this.createConstant(y);\n    }\n    return new PredicateImpl(new ComparisonExpression(Comparison.LESS, x, constExp));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 516, "method_signature": "PredicateImpl lessThan(Expression, Y)"}, "CriteriaBuilderImpl.lessThanOrEqualTo": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.lessThanOrEqualTo", "method_implementation": "{\n    if (y instanceof Expression) {\n        return this.lessThanOrEqualTo(x, (Expression<? extends Y>) y);\n    }\n    final AbstractExpression<Y> constExp;\n    if (x instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) x).getModel();\n        final Y toJdbc = (Y) ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExp = this.createConstant(toJdbc, model.getJavaType());\n    } else {\n        constExp = this.createConstant(y);\n    }\n    return new PredicateImpl(new ComparisonExpression(Comparison.LESS_OR_EQUAL, x, constExp));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 517, "method_signature": "Predicate lessThanOrEqualTo(Expression, Y)"}, "CriteriaBuilderImpl.like": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.like", "method_implementation": "{\n    return new PredicateImpl(new LikeExpression(x, new EntityConstantExpression<String>(null, pattern), new EntityConstantExpression<Character>(null, escapeChar), false));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 518, "method_signature": "PredicateImpl like(Expression, String, char)"}, "CriteriaBuilderImpl.literal": {"callee_method_names": ["T.getClass"], "method_name": "CriteriaBuilderImpl.literal", "method_implementation": "{\n    return new SimpleConstantExpression<T>((TypeImpl<T>) this.metamodel.createBasicType(value.getClass()), value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 519, "method_signature": "SimpleConstantExpression<T> literal(T)"}, "CriteriaBuilderImpl.not": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.not", "method_implementation": "{\n    return new PredicateImpl(true, BooleanOperator.AND, restriction);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 520, "method_signature": "PredicateImpl not(Expression)"}, "CriteriaBuilderImpl.notEqual": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.notEqual", "method_implementation": "{\n    if (y instanceof Expression) {\n        return this.notEqual(x, (Expression<?>) y);\n    }\n    final AbstractExpression<Object> constExp;\n    if (x instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) x).getModel();\n        final Object toJdbc = ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExp = this.createConstant(toJdbc, model.getJavaType());\n    } else {\n        constExp = this.createConstant(y);\n    }\n    return new PredicateImpl(new ComparisonExpression(Comparison.NOT_EQUAL, x, constExp));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 521, "method_signature": "PredicateImpl notEqual(Expression, Object)"}, "CriteriaBuilderImpl.notLike": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.notLike", "method_implementation": "{\n    return new PredicateImpl(new LikeExpression(x, new EntityConstantExpression<String>(null, pattern), new EntityConstantExpression<Character>(null, escapeChar), true));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 522, "method_signature": "PredicateImpl notLike(Expression, String, char)"}, "CriteriaBuilderImpl.nullif": {"callee_method_names": ["BasicAttribute<?, ?>.getJavaType", "BasicAttribute<?, ?>.getTemporalType", "BasicAttribute<?, ?>.getEnumType", "BasicAttribute<?, ?>.isLob", "BasicAttribute<?, ?>.getJavaType"], "method_name": "CriteriaBuilderImpl.nullif", "method_implementation": "{\n    if (y instanceof Expression) {\n        return this.nullif(x, (Expression<Y>) y);\n    }\n    final AbstractExpression<Y> constExp;\n    if (x instanceof BasicPath) {\n        final BasicAttribute<?, ?> model = ((BasicPath<?>) x).getModel();\n        final Y toJdbc = (Y) ValueConverter.toJdbc(y, model.getJavaType(), model.getTemporalType(), model.getEnumType(), model.isLob());\n        constExp = this.createConstant(toJdbc, model.getJavaType());\n    } else {\n        constExp = this.createConstant(y);\n    }\n    return new NullIfExpression<Y>(x, constExp);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 523, "method_signature": "Expression<Y> nullif(Expression, Y)"}, "CriteriaBuilderImpl.or": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.or", "method_implementation": "{\n    return new PredicateImpl(false, BooleanOperator.OR, x, y);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 524, "method_signature": "PredicateImpl or(Expression, Expression)"}, "CriteriaBuilderImpl.substring": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.substring", "method_implementation": "{\n    return new //\n    SubstringExpression(//\n    x, //\n    new EntityConstantExpression<Integer>(this.metamodel.type(Integer.class), from), new EntityConstantExpression<Integer>(this.metamodel.type(Integer.class), len));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 525, "method_signature": "Expression<String> substring(Expression, int, int)"}, "CriteriaBuilderImpl.sum": {"callee_method_names": ["N.getClass"], "method_name": "CriteriaBuilderImpl.sum", "method_implementation": "{\n    final TypeImpl<N> type = (TypeImpl<N>) this.metamodel.type(x.getClass());\n    return new ArithmeticExression<N>(ArithmeticOperation.ADD, new EntityConstantExpression<N>(type, x), y);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 527, "method_signature": "Expression<N> sum(N, Expression)"}, "CriteriaBuilderImpl.tuple": {"callee_method_names": [], "method_name": "CriteriaBuilderImpl.tuple", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 528, "method_signature": "CompoundSelection<Tuple> tuple(Selection<?>[])"}, "CriteriaDeleteImpl.generateJpql": {"callee_method_names": ["RootImpl<T>.getAlias", "RootImpl<T>.getAlias"], "method_name": "CriteriaDeleteImpl.generateJpql", "method_implementation": "{\n    final RootImpl<T> root = this.getRoot();\n    if (StringUtils.isBlank(root.getAlias())) {\n        this.getRoot().alias(\"r\");\n    }\n    String restriction = \"\";\n    if (this.getRestriction() != null) {\n        restriction = \"\\n\" + this.getRestriction().generateJpqlRestriction(this);\n    }\n    return \"delete \" + this.getRoot().generateJpqlRestriction(this) + \" as \" + root.getAlias() + restriction;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 772, "method_signature": "String generateJpql()"}, "CriteriaDeleteImpl.generateSql": {"callee_method_names": [], "method_name": "CriteriaDeleteImpl.generateSql", "method_implementation": "{\n    final String sqlRestriction = this.generateSqlRestriction();\n    return \"DELETE FROM \" + this.getRoot().generateSqlFrom(this) + (StringUtils.isNotBlank(sqlRestriction) ? \"\\nWHERE \" + sqlRestriction : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 773, "method_signature": "String generateSql()"}, "CriteriaModify.from": {"callee_method_names": [], "method_name": "CriteriaModify.from", "method_implementation": "{\n    if (this.root != null) {\n        throw new IllegalStateException(\"Root has already assigned\");\n    }\n    return this.root = new RootImpl<T>((EntityTypeImpl<T>) entity);\n}", "repo_id": "1", "comment": "/**\n * Create and add a query root corresponding to the entity that is the target of the delete. A CriteriaDelete object has a single root,\n * the object that is being deleted.\n *\n * @param entity\n *            metamodel entity representing the entity of type X\n * @return query root corresponding to the given entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 693, "method_signature": "Root<T> from(EntityType)"}, "CriteriaModify.generateSqlRestriction": {"callee_method_names": [], "method_name": "CriteriaModify.generateSqlRestriction", "method_implementation": "{\n    final String[] restrictions = new String[2];\n    if (this.getRestriction() != null) {\n        restrictions[0] = this.getRestriction().generateSqlRestriction(this);\n    }\n    restrictions[1] = this.getRoot().generateDiscrimination(false);\n    final String restriction = Joiner.on(\") AND (\").skipNulls().join(restrictions);\n    if (StringUtils.isBlank(restriction)) {\n        return null;\n    }\n    return \"(\" + restriction + \")\";\n}", "repo_id": "1", "comment": "/**\n * Returns the restriction for the query.\n *\n * @return the restriction\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 694, "method_signature": "String generateSqlRestriction()"}, "CriteriaModify.getJpql": {"callee_method_names": [], "method_name": "CriteriaModify.getJpql", "method_implementation": "{\n    if (this.jpql != null) {\n        return this.jpql;\n    }\n    synchronized (this) {\n        if (this.jpql != null) {\n            return this.jpql;\n        }\n        return this.jpql = this.generateJpql();\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the JPQL for the query.\n *\n * @return the the JPQL\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 695, "method_signature": "String getJpql()"}, "CriteriaModify.where": {"callee_method_names": [], "method_name": "CriteriaModify.where", "method_implementation": "{\n    this.restriction = new PredicateImpl(this.restriction);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * Modify the query to restrict the target of the deletion according to the conjunction of the specified restriction predicates.\n * Replaces the previously added restriction(s), if any. If no restrictions are specified, any previously added restrictions are simply\n * removed.\n *\n * @param restrictions\n *            zero or more restriction predicates\n * @return the modified query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 697, "method_signature": "CriteriaModify<T> where(Predicate[])"}, "CriteriaQueryImpl.generateJpql": {"callee_method_names": [], "method_name": "CriteriaQueryImpl.generateJpql", "method_implementation": "{\n    if (this.orderList.size() > 0) {\n        final String orderBy = Joiner.on(\", \").join(Lists.transform(this.orderList, new Function<OrderImpl, String>() {\n\n            @Override\n            public String apply(OrderImpl input) {\n                return //\n                input.isAscending() ? //\n                input.getExpression().generateJpqlRestriction(CriteriaQueryImpl.this) + \" asc\" : input.getExpression().generateJpqlRestriction(CriteriaQueryImpl.this) + \" desc\";\n            }\n        }));\n        return super.generateJpql() + \"\\norder by\\n\\t\" + orderBy;\n    }\n    return super.generateJpql();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 735, "method_signature": "String generateJpql()"}, "CriteriaQueryImpl.generateSql": {"callee_method_names": [], "method_name": "CriteriaQueryImpl.generateSql", "method_implementation": "{\n    if (this.orderList.size() > 0) {\n        final String orderBy = Joiner.on(\", \").join(Lists.transform(this.orderList, new Function<OrderImpl, String>() {\n\n            @Override\n            public String apply(OrderImpl input) {\n                return //\n                input.isAscending() ? //\n                input.getExpression().generateSqlSelect(CriteriaQueryImpl.this, false) + \" asc\" : input.getExpression().generateSqlSelect(CriteriaQueryImpl.this, false) + \" desc\";\n            }\n        }));\n        return super.generateSql() + \"\\nORDER BY\\n\\t\" + orderBy;\n    }\n    return super.generateSql();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 736, "method_signature": "String generateSql()"}, "CriteriaQueryImpl.getOrderList": {"callee_method_names": ["List<Order>.addAll"], "method_name": "CriteriaQueryImpl.getOrderList", "method_implementation": "{\n    final List<Order> orderList = Lists.newArrayList();\n    orderList.addAll(this.orderList);\n    return orderList;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 737, "method_signature": "List<Order> getOrderList()"}, "CriteriaQueryImpl.orderBy": {"callee_method_names": [], "method_name": "CriteriaQueryImpl.orderBy", "method_implementation": "{\n    this.orderList.clear();\n    for (final Order order : o) {\n        this.orderList.add((OrderImpl) order);\n    }\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 739, "method_signature": "CriteriaQuery<T> orderBy(Order[])"}, "CriteriaUpdateImpl.generateJpql": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CriteriaUpdateImpl.generateJpql", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(\"update \" + this.getRoot().getEntity().getName());\n    if (this.getRestriction() != null) {\n        builder.append(\"\\nwhere\\n\\t\").append(this.getRestriction().generateJpqlRestriction(this));\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 753, "method_signature": "String generateJpql()"}, "CriteriaUpdateImpl.generateSql": {"callee_method_names": [], "method_name": "CriteriaUpdateImpl.generateSql", "method_implementation": "{\n    final String update = Joiner.on(\",\").join(Collections2.transform(this.updates.entrySet(), new Function<Entry<AbstractPath<?>, AbstractExpression<?>>, String>() {\n\n        @Override\n        public String apply(Entry<AbstractPath<?>, AbstractExpression<?>> input) {\n            return \"\\t\" + input.getKey().getSqlRestrictionFragments(CriteriaUpdateImpl.this)[0] + \" = \" + input.getValue().getSqlRestrictionFragments(CriteriaUpdateImpl.this)[0];\n        }\n    }));\n    final String sqlRestriction = this.generateSqlRestriction();\n    return //\n    \"UPDATE \" + this.getRoot().generateSqlFrom(this) + \" SET\\n\" + update + (StringUtils.isNotBlank(sqlRestriction) ? \"\\nWHERE \" + sqlRestriction : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 754, "method_signature": "String generateSql()"}, "CriteriaUpdateImpl.set": {"callee_method_names": [], "method_name": "CriteriaUpdateImpl.set", "method_implementation": "{\n    this.updates.put((AbstractPath<?>) attribute, (AbstractExpression<?>) value);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * Adds the set item.\n *\n * @param attribute\n *            the attribute\n * @param value\n *            the value\n * @return the same update criteria\n * @param <Y>\n *            the typ of the attribute\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 755, "method_signature": "CriteriaUpdateImpl<T> set(Path, Expression)"}, "CurrentTemporalExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "CurrentTemporalExpression.generateJpqlRestriction", "method_implementation": "{\n    switch(this.temporalType) {\n        case DATE:\n            return \"current_date\";\n        case TIME:\n            return \"current_time\";\n        default:\n            return \"current_timestamp\";\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 652, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "CurrentTemporalExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "CurrentTemporalExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 653, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CurrentTemporalExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "CurrentTemporalExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 654, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "CurrentTemporalExpression.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.getJdbcAdaptor", "BaseQueryImpl<?>.getJdbcAdaptor", "BaseQueryImpl<?>.getJdbcAdaptor"], "method_name": "CurrentTemporalExpression.getSqlRestrictionFragments", "method_implementation": "{\n    switch(this.temporalType) {\n        case DATE:\n            return new String[] { query.getJdbcAdaptor().getCurrentDate() };\n        case TIME:\n            return new String[] { query.getJdbcAdaptor().getCurrentTime() };\n        default:\n            return new String[] { query.getJdbcAdaptor().getCurrentTimeStamp() };\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 655, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "CurrentTemporalExpression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "CurrentTemporalExpression.handle", "method_implementation": "{\n    return (T) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 656, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "Customer.equals": {"callee_method_names": [], "method_name": "Customer.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof Customer)) {\n        return false;\n    }\n    final Customer other = (Customer) obj;\n    if (this.id == null) {\n        if (other.id != null) {\n            return false;\n        }\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2284, "method_signature": "boolean equals(Object)"}, "Customer.hashCode": {"callee_method_names": [], "method_name": "Customer.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2285, "method_signature": "int hashCode()"}, "DataSourceProxy.close": {"callee_method_names": ["Method.invoke"], "method_name": "DataSourceProxy.close", "method_implementation": "{\n    if (!this.external && !this.externalPoolDS) {\n        try {\n            // close the datasource via reflection\n            final Method closeMethod = this.datasource.getClass().getMethod(\"close\");\n            if (closeMethod != null) {\n                closeMethod.invoke(this.datasource);\n            }\n        } catch (final Exception e) {\n            DataSourceProxy.LOG.error(e, \"Cannot close() the internal datasource\");\n        }\n    } else if (this.externalPoolDS) {\n        ((AbstractDataSource) this.datasource).close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Closes the resource local datasource.\n */\n", "repo_name": "BatooJPA-master/", "id": 1144, "method_signature": "void close()"}, "DateTimeExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "DateTimeExpression.generateJpqlRestriction", "method_implementation": "{\n    final String xExpr = this.x.generateJpqlRestriction(query);\n    return MessageFormat.format(this.type.getJpqlFragment(), xExpr);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 639, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "DateTimeExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "DateTimeExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 640, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "DateTimeExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "DateTimeExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 641, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "DateTimeExpression.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.getJdbcAdaptor"], "method_name": "DateTimeExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final String xExpr = this.x.getSqlRestrictionFragments(query)[0];\n    return new String[] { MessageFormat.format(query.getJdbcAdaptor().getDateTimeFunctionTemplate(this.type), xExpr) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 642, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "DdlManager.perform": {"callee_method_names": [], "method_name": "DdlManager.perform", "method_implementation": "{\n    switch(this.ddlPhase) {\n        case TABLES:\n            this.getMetamodel().performTablesDdl(this.datasource, this.ddlMode, type);\n            break;\n        case FOREIGN_KEYS:\n            this.getMetamodel().performForeignKeysDdl(this.datasource, this.ddlMode, type);\n            break;\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 188, "method_signature": "Void perform(EntityTypeImpl)"}, "DdlTest.testDdlTEST0_Drop": {"callee_method_names": [], "method_name": "DdlTest.testDdlTEST0_Drop", "method_implementation": "{\n    this.setupEmf().close();\n    this.setupEmf().close();\n}", "repo_id": "1", "comment": "/**\n * Tests the ddl drop mode.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2503, "method_signature": "void testDdlTEST0_Drop()"}, "DdlTest.testDdlTEST3_Update": {"callee_method_names": [], "method_name": "DdlTest.testDdlTEST3_Update", "method_implementation": "{\n    this.setupEmf(\"update1\").close();\n    this.setupEmf(\"update2\").close();\n}", "repo_id": "1", "comment": "/**\n * Tests the ddl drop mode.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2504, "method_signature": "void testDdlTEST3_Update()"}, "DefaultPersistenceProviderResolver.addProviderNames": {"callee_method_names": ["URL.openStream", "BufferedReader.readLine", "String.trim", "Matcher.find", "Collection<ProviderName>.add", "Matcher.group", "InputStream.close"], "method_name": "DefaultPersistenceProviderResolver.addProviderNames", "method_implementation": "{\n    InputStream in = null;\n    try {\n        in = url.openStream();\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            line = line.trim();\n            final Matcher m = DefaultPersistenceProviderResolver.nonCommentPattern.matcher(line);\n            if (m.find()) {\n                providerNames.add(new ProviderName(m.group().trim(), url));\n            }\n        }\n    } catch (final IOException ioe) {\n        throw new PersistenceException(\"IOException caught reading: \" + url, ioe);\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (final IOException e) {\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * For each services file look for uncommented provider names on each line.\n */\n", "repo_name": "BatooJPA-master/", "id": 2564, "method_signature": "void addProviderNames(URL, Collection)"}, "DefaultPersistenceProviderResolver.getProviderNames": {"callee_method_names": ["ClassLoader.getResources", "Enumeration<URL>.hasMoreElements", "Enumeration<URL>.nextElement"], "method_name": "DefaultPersistenceProviderResolver.getProviderNames", "method_implementation": "{\n    Enumeration<URL> resources = null;\n    try {\n        resources = loader.getResources(DefaultPersistenceProviderResolver.SERVICE_PROVIDER_FILE);\n    } catch (final IOException ioe) {\n        throw new PersistenceException(\"IOException caught: \" + loader + \".getResources(\" + DefaultPersistenceProviderResolver.SERVICE_PROVIDER_FILE + \")\", ioe);\n    }\n    final Collection<ProviderName> providerNames = new ArrayList<ProviderName>();\n    while (resources.hasMoreElements()) {\n        final URL url = resources.nextElement();\n        this.addProviderNames(url, providerNames);\n    }\n    return providerNames;\n}", "repo_id": "1", "comment": "/**\n * Locate all JPA provider services files and collect all of the provider names available.\n */\n", "repo_name": "BatooJPA-master/", "id": 2565, "method_signature": "Collection<ProviderName> getProviderNames(ClassLoader)"}, "Dependent.equals": {"callee_method_names": [], "method_name": "Dependent.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof Dependent)) {\n        return false;\n    }\n    final Dependent other = (Dependent) obj;\n    if (this.emp == null) {\n        if (other.emp != null) {\n            return false;\n        }\n    } else if (!this.emp.equals(other.emp)) {\n        return false;\n    }\n    if (this.name == null) {\n        if (other.name != null) {\n            return false;\n        }\n    } else if (!this.name.equals(other.name)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2117, "method_signature": "boolean equals(Object)"}, "Dependent.hashCode": {"callee_method_names": [], "method_name": "Dependent.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.emp == null) ? 0 : this.emp.hashCode());\n    result = (prime * result) + ((this.name == null) ? 0 : this.name.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2118, "method_signature": "int hashCode()"}, "DependentId.equals": {"callee_method_names": [], "method_name": "DependentId.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof DependentId)) {\n        return false;\n    }\n    final DependentId other = (DependentId) obj;\n    if (this.emp == null) {\n        if (other.emp != null) {\n            return false;\n        }\n    } else if (!this.emp.equals(other.emp)) {\n        return false;\n    }\n    if (this.name == null) {\n        if (other.name != null) {\n            return false;\n        }\n    } else if (!this.name.equals(other.name)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2111, "method_signature": "boolean equals(Object)"}, "DependentId.hashCode": {"callee_method_names": [], "method_name": "DependentId.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.emp == null) ? 0 : this.emp.hashCode());\n    result = (prime * result) + ((this.name == null) ? 0 : this.name.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2112, "method_signature": "int hashCode()"}, "DeploymentManager.equals": {"callee_method_names": ["Object.getClass"], "method_name": "DeploymentManager.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final DeploymentUnitFuture other = (DeploymentUnitFuture) obj;\n    if (this.task == null) {\n        if (other.task != null) {\n            return false;\n        }\n    } else if (!this.task.equals(other.task)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 189, "method_signature": "boolean equals(Object)"}, "DeploymentManager.handleException": {"callee_method_names": ["Throwable.getCause", "Throwable.getCause", "Throwable.getCause"], "method_name": "DeploymentManager.handleException", "method_implementation": "{\n    if (t instanceof BatooException) {\n        throw (BatooException) t;\n    }\n    if (t.getCause() != null) {\n        throw new BatooException(\"Unknown error occurred during deployment\", t.getCause());\n    }\n    this.handleException(t.getCause());\n}", "repo_id": "1", "comment": "/**\n * Handles the exception.\n *\n * @param t\n *            the exception\n * @throws BatooException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 191, "method_signature": "void handleException(Throwable)"}, "DeploymentManager.hasPerformed": {"callee_method_names": [], "method_name": "DeploymentManager.hasPerformed", "method_implementation": "{\n    if (type == null) {\n        return true;\n    }\n    if (!this.types.contains(type)) {\n        return true;\n    }\n    return this.performed.contains(type);\n}", "repo_id": "1", "comment": "/**\n * Returns if the type has performed.\n *\n * @param type\n *            the type\n * @return true if the type has performed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 192, "method_signature": "boolean hasPerformed(TypeImpl)"}, "DeploymentManager.hashCode": {"callee_method_names": [], "method_name": "DeploymentManager.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.task == null) ? 0 : this.task.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 190, "method_signature": "int hashCode()"}, "DeploymentManager.perform": {"callee_method_ids": [185], "callee_method_names": ["List<Future<?>>.add", "List<DeploymentUnitTask>.size", "List<DeploymentUnitTask>.iterator", "int.hasNext", "int.next", "DeploymentUnitTask.compareTo", "int.remove", "List<DeploymentUnitTask>.add", "List<Future<?>>.add"], "method_name": "DeploymentManager.perform", "method_implementation": "{\n    final long start = System.currentTimeMillis();\n    // Submit the tasks\n    final List<Future<?>> futures = Lists.newArrayList();\n    if (this.context == Context.NAMED_QUERIES) {\n        for (final NamedQueryMetadata query : this.namedQueries) {\n            futures.add(this.executer.submit(new DeploymentUnitTask(this, query)));\n        }\n    } else {\n        final List<DeploymentUnitTask> unSortedTasks = Lists.newArrayList(Lists.transform(this.types, new Function<ManagedType<?>, DeploymentUnitTask>() {\n\n            @Override\n            public DeploymentUnitTask apply(ManagedType<?> type) {\n                return new DeploymentUnitTask(DeploymentManager.this, type);\n            }\n        }));\n        final List<DeploymentUnitTask> sortedTasks = Lists.newArrayList();\n        while (unSortedTasks.size() > 0) {\n            for (final Iterator<DeploymentUnitTask> i = unSortedTasks.iterator(); i.hasNext(); ) {\n                final DeploymentUnitTask task = i.next();\n                boolean hasDependency = false;\n                for (final DeploymentUnitTask other : unSortedTasks) {\n                    if (task.compareTo(other) > 0) {\n                        hasDependency = true;\n                        break;\n                    }\n                }\n                if (!hasDependency) {\n                    i.remove();\n                    sortedTasks.add(task);\n                    break;\n                }\n            }\n        }\n        for (final DeploymentUnitTask task : sortedTasks) {\n            futures.add(this.executer.submit(task));\n        }\n    }\n    // wait until tasks finish or one bails out with an exception\n    try {\n        for (final Future<?> future : futures) {\n            future.get();\n        }\n    } catch (final Exception t) {\n        this.handleException(t);\n    } finally {\n        this.executer.shutdownNow();\n    }\n    this.log.debug(\"Deployment pass took {0} msecs\", System.currentTimeMillis() - start);\n}", "repo_id": "1", "comment": "/**\n * Performs the deployment unit for all the types.\n *\n * @since 2.0.0\n * @throws BatooException\n */\n", "repo_name": "BatooJPA-master/", "id": 193, "method_signature": "void perform()"}, "DeploymentManager.performed": {"callee_method_names": [], "method_name": "DeploymentManager.performed", "method_implementation": "{\n    if (!(type instanceof NamedQueryMetadata)) {\n        this.performed.add((TypeImpl<?>) type);\n    }\n}", "repo_id": "1", "comment": "/**\n * Marks the type as performed.\n *\n * @param type\n *            the type to mark\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 194, "method_signature": "void performed(X)"}, "DeploymentUnitFuture.equals": {"callee_method_names": ["Object.getClass"], "method_name": "DeploymentUnitFuture.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final DeploymentUnitFuture other = (DeploymentUnitFuture) obj;\n    if (this.task == null) {\n        if (other.task != null) {\n            return false;\n        }\n    } else if (!this.task.equals(other.task)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 195, "method_signature": "boolean equals(Object)"}, "DeploymentUnitFuture.hashCode": {"callee_method_names": [], "method_name": "DeploymentUnitFuture.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.task == null) ? 0 : this.task.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 196, "method_signature": "int hashCode()"}, "DeploymentUnitTask.call": {"callee_method_names": [], "method_name": "DeploymentUnitTask.call", "method_implementation": "{\n    this.waitForSuper();\n    this.waitforIdDependency();\n    try {\n        return this.manager.perform(this.unit);\n    } finally {\n        this.manager.performed(this.unit);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 184, "method_signature": "Void call()"}, "DeploymentUnitTask.compareTo": {"callee_method_names": ["ManagedType<?>.getJavaType", "ManagedType<?>.getJavaType", "ManagedType<?>.getJavaType", "ManagedType<?>.getJavaType"], "method_name": "DeploymentUnitTask.compareTo", "method_implementation": "{\n    // named queries has no precedence\n    if (this.unit instanceof NamedQueryMetadata) {\n        return 0;\n    }\n    final ManagedType<?> thisUnit = (ManagedType<?>) this.unit;\n    final ManagedType<?> otherUnit = (ManagedType<?>) o.unit;\n    // if this type is Embeddable and the other type is not then perform this earlier\n    if ((thisUnit instanceof EmbeddableTypeImpl) && (!(otherUnit instanceof EmbeddableTypeImpl))) {\n        return -1;\n    }\n    // if the other type is Embeddable and this type is not then perform the other earlier\n    if ((otherUnit instanceof EmbeddableTypeImpl) && (!(thisUnit instanceof EmbeddableTypeImpl))) {\n        return 1;\n    }\n    // if this type is a MappedSuperClass and the other type is not then perform this earlier\n    if ((thisUnit instanceof MappedSuperclassTypeImpl) && (!(otherUnit instanceof MappedSuperclassTypeImpl))) {\n        return -1;\n    }\n    // if the other type is a MappedSuperClass and this type is not then perform this later\n    if ((otherUnit instanceof MappedSuperclassTypeImpl) && (!(thisUnit instanceof MappedSuperclassTypeImpl))) {\n        return 1;\n    }\n    // if this type is super type of other type then perform this earlier\n    if (thisUnit.getJavaType().isAssignableFrom(otherUnit.getJavaType())) {\n        return -1;\n    }\n    // if the other type is super type of this type then perform other earlier\n    if (otherUnit.getJavaType().isAssignableFrom(thisUnit.getJavaType())) {\n        return 1;\n    }\n    // No precedence\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 185, "method_signature": "int compareTo(DeploymentUnitTask)"}, "DeploymentUnitTask.equals": {"callee_method_names": ["Object.getClass"], "method_name": "DeploymentUnitTask.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final DeploymentUnitTask other = (DeploymentUnitTask) obj;\n    if (this.unit == null) {\n        if (other.unit != null) {\n            return false;\n        }\n    } else if (!this.unit.equals(other.unit)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 186, "method_signature": "boolean equals(Object)"}, "DeploymentUnitTask.hashCode": {"callee_method_names": [], "method_name": "DeploymentUnitTask.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.unit == null) ? 0 : this.unit.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 187, "method_signature": "int hashCode()"}, "DerbyAdaptor.applyLikeEscape": {"callee_method_names": [], "method_name": "DerbyAdaptor.applyLikeEscape", "method_implementation": "{\n    return \" {ESCAPE \" + escapePattern + \"}\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1327, "method_signature": "String applyLikeEscape(String)"}, "DerbyAdaptor.applyLock": {"callee_method_names": [], "method_name": "DerbyAdaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1328, "method_signature": "String applyLock(String, LockModeType)"}, "DerbyAdaptor.applyPagination": {"callee_method_names": [], "method_name": "DerbyAdaptor.applyPagination", "method_implementation": "{\n    if (startPosition != 0) {\n        sql = sql + \"\\nOFFSET ? ROWS\";\n    }\n    if (maxResult != Integer.MAX_VALUE) {\n        sql = sql + \"\\nFETCH FIRST ? ROWS ONLY\";\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1329, "method_signature": "String applyPagination(String, int, int)"}, "DerbyAdaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getIdType", "AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable", "AbstractColumn.isUnique"], "method_name": "DerbyAdaptor.createColumnDDL", "method_implementation": "{\n    final boolean identity = column.getIdType() == IdType.IDENTITY;\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // not null part\n    (column.isUnique() ? \" UNIQUE\" : \"\") + // auto increment part\n    (identity ? \" GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1)\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1330, "method_signature": "String createColumnDDL(AbstractColumn)"}, "DerbyAdaptor.createSequenceIfNecessary": {"callee_method_names": ["SequenceGenerator.getQName", "SequenceGenerator.getInitialValue", "SequenceGenerator.getAllocationSize", "SequenceGenerator.getSequenceName"], "method_name": "DerbyAdaptor.createSequenceIfNecessary", "method_implementation": "{\n    try {\n        final String sql = //\n        \"CREATE SEQUENCE \" + sequence.getQName() + \" START WITH \" + //\n        sequence.getInitialValue() + \" INCREMENT BY \" + sequence.getAllocationSize();\n        new QueryRunner(datasource).update(sql);\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot create sequence\" + sequence.getSequenceName());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1331, "method_signature": "void createSequenceIfNecessary(DataSource, SequenceGenerator)"}, "DerbyAdaptor.getNextSequence": {"callee_method_names": [], "method_name": "DerbyAdaptor.getNextSequence", "method_implementation": "{\n    return //\n    new QueryRunner(datasource).query(\"VALUES (NEXT VALUE FOR \" + sequenceName + \")\", new SingleValueHandler<Number>()).longValue();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1332, "method_signature": "long getNextSequence(DataSource, String)"}, "DerbyAdaptor.modifyParameters": {"callee_method_names": [], "method_name": "DerbyAdaptor.modifyParameters", "method_implementation": "{\n    for (int i = 0; i < params.length; i++) {\n        final Object param = params[i];\n        if (param == null) {\n            continue;\n        }\n        if (param instanceof Character) {\n            params[i] = ((Character) param).toString();\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1333, "method_signature": "void modifyParameters(ParameterMetaData, Object[])"}, "DerbyAdaptor.supports": {"callee_method_names": [], "method_name": "DerbyAdaptor.supports", "method_implementation": "{\n    if (type == null) {\n        return IdType.SEQUENCE;\n    }\n    switch(type) {\n        case IDENTITY:\n            return IdType.IDENTITY;\n        case SEQUENCE:\n            return IdType.SEQUENCE;\n        case TABLE:\n            return IdType.TABLE;\n        default:\n            return IdType.SEQUENCE;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1334, "method_signature": "IdType supports(GenerationType)"}, "DerivedIdsTest.test1aJPQL": {"callee_method_names": ["TypedQuery<Dependent>.getSingleResult", "Dependent.getName", "Dependent.getEmp"], "method_name": "DerivedIdsTest.test1aJPQL", "method_implementation": "{\n    final Employee employee = new Employee(\"Sam\");\n    this.persist(employee);\n    this.commit();\n    final Dependent dependent1 = new Dependent(\"Joe\", employee);\n    this.persist(dependent1);\n    this.commit();\n    this.close();\n    final TypedQuery<Dependent> q = this.cq(\"select d from Dependent d where d.name = 'Joe' AND d.emp.empName = 'Sam'\", Dependent.class);\n    final Dependent dependent2 = q.getSingleResult();\n    Assert.assertNotNull(dependent2);\n    Assert.assertEquals(\"Joe\", dependent2.getName());\n    Assert.assertEquals(\"Sam\", dependent2.getEmp().getEmpName());\n}", "repo_id": "1", "comment": "/**\n * Example-1 Case (a):\n * <p>\n * The parent entity has a simple primary key.\n * <p>\n * The dependent entity uses IdClass to represent a composite key.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2097, "method_signature": "void test1aJPQL()"}, "DerivedIdsTest.test1bJPQL": {"callee_method_names": ["Employee.getEmpId", "TypedQuery<Dependent>.getSingleResult", "Dependent.getId", "Dependent.getEmp"], "method_name": "DerivedIdsTest.test1bJPQL", "method_implementation": "{\n    final Employee employee = new Employee(\"Sam\");\n    this.persist(employee);\n    this.commit();\n    final DependentId dependentId1 = new DependentId(\"Joe\", employee.getEmpId());\n    final Dependent dependent1 = new Dependent(dependentId1, employee);\n    this.persist(dependent1);\n    this.commit();\n    this.close();\n    final TypedQuery<Dependent> q = this.cq(\"select d from Dependent d where d.id.name = 'Joe' and d.emp.empName = 'Sam'\", Dependent.class);\n    final Dependent dependent2 = q.getSingleResult();\n    Assert.assertNotNull(dependent2);\n    Assert.assertEquals(\"Joe\", dependent2.getId().getName());\n    Assert.assertEquals(\"Sam\", dependent2.getEmp().getEmpName());\n}", "repo_id": "1", "comment": "/**\n * Example-1 Case (b):\n * <p>\n * The parent entity has a simple primary key\n * <p>\n * The dependent entity uses EmbeddedId to represent a composite key:\n *\n * @author asimarslan\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2105, "method_signature": "void test1bJPQL()"}, "DerivedIdsTest.test2aJPQL": {"callee_method_names": ["TypedQuery<Dependent>.getResultList", "List<Dependent>.size", "List<Dependent>.get", "List<Dependent>.get", "List<Dependent>.get"], "method_name": "DerivedIdsTest.test2aJPQL", "method_implementation": "{\n    final Employee employee = new Employee(\"Sam\", \"Doe\");\n    final Dependent dependent1 = new Dependent(\"Joe\", employee);\n    this.persist(employee);\n    this.persist(dependent1);\n    this.commit();\n    this.close();\n    final String qstr = \"select d from Dependent d where d.name = 'Joe' and d.emp.firstName = 'Sam'\";\n    final TypedQuery<Dependent> q = this.cq(qstr, Dependent.class);\n    final List<Dependent> resultList = q.getResultList();\n    Assert.assertNotNull(resultList);\n    Assert.assertEquals(1, resultList.size());\n    Assert.assertEquals(\"Joe\", resultList.get(0).getName());\n    Assert.assertEquals(\"Sam\", resultList.get(0).getEmp().getFirstName());\n    Assert.assertEquals(\"Doe\", resultList.get(0).getEmp().getLastName());\n}", "repo_id": "1", "comment": "/**\n * Example-2 Case (a):\n * <p>\n * The parent entity uses IdClass\n * <p>\n * The dependent entity uses IdClass\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2077, "method_signature": "void test2aJPQL()"}, "DerivedIdsTest.test2bJPQL": {"callee_method_names": ["Employee.getFirstName", "Employee.getLastName", "TypedQuery<Dependent>.getSingleResult"], "method_name": "DerivedIdsTest.test2bJPQL", "method_implementation": "{\n    final Employee employee = new Employee(\"Sam\", \"Doe\");\n    this.persist(employee);\n    this.commit();\n    final Dependent dependent1 = new Dependent(new DependentId(\"Joe\", new EmployeeId(employee.getFirstName(), employee.getLastName())), employee);\n    this.persist(dependent1);\n    this.commit();\n    this.close();\n    final TypedQuery<Dependent> q = this.cq(\"select d from Dependent d where d.id.name = 'Joe' and d.emp.firstName = 'Sam'\", Dependent.class);\n    final Dependent dependent2 = q.getSingleResult();\n    Assert.assertEquals(dependent1, dependent2);\n}", "repo_id": "1", "comment": "/**\n * Example-2 Case (b):\n * <p>\n * The parent entity uses IdClass\n * <p>\n * The dependent entity uses EmbeddedId to represent a composite key:\n *\n * @author asimarslan\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2087, "method_signature": "void test2bJPQL()"}, "DerivedIdsTest.test3aJPQL": {"callee_method_names": ["TypedQuery<Dependent>.getResultList", "List<Dependent>.size", "List<Dependent>.get", "List<Dependent>.get", "List<Dependent>.get"], "method_name": "DerivedIdsTest.test3aJPQL", "method_implementation": "{\n    final Employee employee = new Employee(new EmployeeId(\"Sam\", \"Doe\"));\n    this.persist(employee);\n    final Dependent dependent1 = new Dependent(\"Joe\", employee);\n    this.persist(dependent1);\n    this.commit();\n    this.close();\n    final String qstr = \"select d from Dependent d where d.name = 'Joe' and d.emp.empId.firstName = 'Sam'\";\n    final TypedQuery<Dependent> q = this.cq(qstr, Dependent.class);\n    final List<Dependent> resultList = q.getResultList();\n    Assert.assertNotNull(resultList);\n    Assert.assertEquals(1, resultList.size());\n    Assert.assertEquals(\"Joe\", resultList.get(0).getName());\n    Assert.assertEquals(\"Sam\", resultList.get(0).getEmp().getEmpId().getFirstName());\n    Assert.assertEquals(\"Doe\", resultList.get(0).getEmp().getEmpId().getLastName());\n}", "repo_id": "1", "comment": "/**\n * Example-3 Case (a):\n * <p>\n * The parent entity uses EmbeddedId:\n * <p>\n * The dependent entity uses IdClass:\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2113, "method_signature": "void test3aJPQL()"}, "DerivedIdsTest.test3bJPQL": {"callee_method_names": ["TypedQuery<Dependent>.getResultList", "List<Dependent>.size", "List<Dependent>.get"], "method_name": "DerivedIdsTest.test3bJPQL", "method_implementation": "{\n    final Employee employee = new Employee(new EmployeeId(\"Sam\", \"Doe\"));\n    this.persist(employee);\n    this.commit();\n    final Dependent dependent1 = new Dependent(new DependentId(\"Joe\", employee), employee);\n    this.persist(dependent1);\n    this.commit();\n    this.close();\n    final TypedQuery<Dependent> q = this.cq(\"select d from Dependent d where d.id.name = 'Joe' and d.emp.empId.firstName = 'Sam'\", Dependent.class);\n    final List<Dependent> resultList = q.getResultList();\n    Assert.assertNotNull(resultList);\n    Assert.assertEquals(1, resultList.size());\n    Assert.assertEquals(\"Joe\", resultList.get(0).getId().getName());\n}", "repo_id": "1", "comment": "/**\n * Example-3 Case (b):\n * <p>\n * The parent entity uses EmbeddedId:\n * <p>\n * The dependent entity uses EmbeddedId\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2067, "method_signature": "void test3bJPQL()"}, "DerivedIdsTest.testColumnNames": {"callee_method_names": [], "method_name": "DerivedIdsTest.testColumnNames", "method_implementation": "{\n    final Employee employee = new Employee(new EmployeeId(\"Sam\", \"Doe\"));\n    this.persist(employee);\n    final Dependent dependent1 = new Dependent(\"Joe\", employee);\n    this.persist(dependent1);\n    this.commit();\n    this.close();\n    Assert.assertEquals(\"[dep_name, fk1, fk2]\", new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT * FROM Dependent\", new ColumnNameListHandler()));\n}", "repo_id": "1", "comment": "/**\n * Tests generated DDL column names\n *\n * @throws SQLException\n *             thrown in case of an error\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2114, "method_signature": "void testColumnNames()"}, "DiscriminatorColumn.getJavaType": {"callee_method_names": ["DiscriminatorColumnMetadata.getDiscriminatorType"], "method_name": "DiscriminatorColumn.getJavaType", "method_implementation": "{\n    if (metadata == null) {\n        return String.class;\n    }\n    switch(metadata.getDiscriminatorType()) {\n        case STRING:\n            return String.class;\n        case INTEGER:\n            return Integer.class;\n        default:\n            return char.class;\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the java type of the discriminator column.\n *\n * @param metadata\n * @return the java type of the discriminator column\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1164, "method_signature": "Class<?> getJavaType(DiscriminatorColumnMetadata)"}, "DiscriminatorColumn.getSqlType": {"callee_method_names": [], "method_name": "DiscriminatorColumn.getSqlType", "method_implementation": "{\n    switch(this.discriminatorType) {\n        case CHAR:\n        case STRING:\n            return Types.VARCHAR;\n        default:\n            return Types.INTEGER;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1165, "method_signature": "int getSqlType()"}, "DiscriminatorColumnElement.generate": {"callee_method_names": [], "method_name": "DiscriminatorColumnElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, \"DTYPE\");\n    this.columnDefinition = this.getAttribute(ElementConstants.ATTR_COLUMN_DEFINITION);\n    this.discriminatorType = DiscriminatorType.valueOf(this.getAttribute(ElementConstants.ATTR_DISCRIMINATOR_TYPE, DiscriminatorType.STRING.name()));\n    this.length = this.getAttribute(ElementConstants.ATTR_LENGTH, 31);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1072, "method_signature": "void generate()"}, "E.getId": {"callee_method_names": [], "method_name": "E.getId", "method_implementation": "{\n    return this.id;\n}", "repo_id": "1", "comment": "/**\n * Returns the id of the E.\n *\n * @return the id of the E\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2253, "method_signature": "Long getId()"}, "E3.getE1": {"callee_method_names": [], "method_name": "E3.getE1", "method_implementation": "{\n    return this.e1;\n}", "repo_id": "1", "comment": "/**\n * Returns the e1 of the E3.\n *\n * @return the e1 of the E3\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2251, "method_signature": "E1 getE1()"}, "E5.getE1": {"callee_method_names": [], "method_name": "E5.getE1", "method_implementation": "{\n    return this.e1;\n}", "repo_id": "1", "comment": "/**\n * Returns the e1 of the E3.\n *\n * @return the e1 of the E3\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2252, "method_signature": "E1 getE1()"}, "EagerTest.initCountries": {"callee_method_names": [], "method_name": "EagerTest.initCountries", "method_implementation": "{\n    EagerTest.TR = new Country(1, \"Turkey\");\n    EagerTest.USA = new Country(2, \"USA\");\n    EagerTest.UK = new Country(3, \"UK\");\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2304, "method_signature": "void initCountries()"}, "EagerTest.prepareCountries": {"callee_method_names": [], "method_name": "EagerTest.prepareCountries", "method_implementation": "{\n    this.persist(EagerTest.TR);\n    this.persist(EagerTest.USA);\n    this.persist(EagerTest.UK);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2305, "method_signature": "void prepareCountries()"}, "EagerTest.testFind": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses", "Person.getAddresses"], "method_name": "EagerTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n    for (final Address address : person2.getAddresses()) {\n        if (\"Istanbul\".equals(address.getCity())) {\n            Assert.assertEquals(address.getCountry().getId(), EagerTest.TR.getId());\n            break;\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2306, "method_signature": "void testFind()"}, "EagerTest.testFindInSession": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "EagerTest.testFindInSession", "method_implementation": "{\n    this.persist(EagerTest.TR);\n    this.persist(EagerTest.USA);\n    this.persist(EagerTest.UK);\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2307, "method_signature": "void testFindInSession()"}, "EagerTest.testPersistAddress": {"callee_method_names": [], "method_name": "EagerTest.testPersistAddress", "method_implementation": "{\n    this.persist(this.person().getAddresses().get(0));\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} address which does not cascade to Parent. PersistenceException expected.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2308, "method_signature": "void testPersistAddress()"}, "EagerTest.testPersistPerson": {"callee_method_names": [], "method_name": "EagerTest.testPersistPerson", "method_implementation": "{\n    Assert.assertEquals(4, this.em().getMetamodel().getEntities().size());\n    this.persist(this.person());\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} Parent which cascades to Child1.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2309, "method_signature": "void testPersistPerson()"}, "Element.end": {"callee_method_names": [], "method_name": "Element.end", "method_implementation": "{\n    this.generate();\n    if (this.parent != null) {\n        Element.LOG.trace(\"Parsed child {0}\", this);\n        this.parent.handleChild(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates the element and hands over to the parent.\n * <p>\n * if the parent is null, that the factory is {@link EntityMappings}, the model element is added to the metamodel.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1076, "method_signature": "void end()"}, "Element.expected": {"callee_method_names": [], "method_name": "Element.expected", "method_implementation": "{\n    if (!this.expectedChildElements.contains(element)) {\n        throw new MappingException(\"Unexpected element '\" + element + \"' encountered.\", this.locator);\n    }\n}", "repo_id": "1", "comment": "/**\n * Checks if the <code>element</code> is expected.\n *\n * @param element\n *            the name of the element\n * @param locator\n *            the XML locator\n * @throws MappingException\n *             thrown if the <code>element</code> is not expected.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1077, "method_signature": "void expected(String, Locator)"}, "Element.forElement": {"callee_method_names": ["XmlLocator.getLocalName", "Class<?>.getConstructor", "Constructor<?>.newInstance", "Element.setLocator"], "method_name": "Element.forElement", "method_implementation": "{\n    final Class<?> clazz = Element.factoryMap.get(xmlLocator.getLocalName());\n    try {\n        final Constructor<?> constructor = clazz.getConstructor(ParentElement.class, Map.class);\n        final Element element = (Element) constructor.newInstance(parent, attributes);\n        element.setLocator(xmlLocator);\n        return element;\n    } catch (final Exception e) {\n        Element.LOG.error(e, \"Error while processing element: {0}\", xmlLocator);\n    }\n    // not possible\n    // unreachable\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Constructs and Element for the <code>element</code>\n *\n * @param parent\n *            the parent element\n * @param attributes\n *            the attributes of the element\n * @param xmlLocator\n *            the XML locator of the element\n * @return the element created\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1075, "method_signature": "Element forElement(Element, Map, XmlLocator)"}, "Element.getAttribute": {"callee_method_names": [], "method_name": "Element.getAttribute", "method_implementation": "{\n    final String value = this.attributes.get(name);\n    return value != null ? value : devault;\n}", "repo_id": "1", "comment": "/**\n * Returns the attribute value for the <code>name</code>.\n *\n * @param name\n *            the name of the attribute\n * @param devault\n *            the default value\n * @return the value or null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1080, "method_signature": "String getAttribute(String, String)"}, "ElementCollectionAttributeElement.generate": {"callee_method_names": [], "method_name": "ElementCollectionAttributeElement.generate", "method_implementation": "{\n    super.generate();\n    this.targetClass = this.getAttribute(ElementConstants.ATTR_TARGET_CLASS);\n    this.fetchType = FetchType.valueOf(this.getAttribute(ElementConstants.ATTR_FETCH, FetchType.LAZY.name()));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1101, "method_signature": "void generate()"}, "ElementCollectionAttributeElement.handleChild": {"callee_method_names": [], "method_name": "ElementCollectionAttributeElement.handleChild", "method_implementation": "{\n    if (child instanceof AttributeOverrideElement) {\n        this.attributeOverrides.add((AttributeOverrideElement) child);\n    }\n    if (child instanceof AssociationOverrideElement) {\n        this.associationOverrides.add((AssociationOverrideElement) child);\n    }\n    if (child instanceof CollectionTableMetadata) {\n        this.collectionTable = (CollectionTableMetadata) child;\n    }\n    if (child instanceof MapKeyColumnElement) {\n        this.mapKeyColumn = (ColumnMetadata) child;\n    }\n    if (child instanceof ColumnMetadata) {\n        this.column = (ColumnMetadata) child;\n    }\n    if (child instanceof EnumeratedElement) {\n        this.enumType = ((EnumeratedElement) child).getEnumType();\n    }\n    if (child instanceof TemporalElement) {\n        this.temporalType = ((TemporalElement) child).getTemporalType();\n    }\n    if (child instanceof LobElement) {\n        this.lob = true;\n    }\n    if (child instanceof MapKeyElement) {\n        this.mapKey = ((MapKeyElement) child).getName();\n    }\n    if (child instanceof MapKeyAttributeOverrideElement) {\n        this.mapKeyAttributeOverrides.add((AttributeOverrideElement) child);\n    }\n    if (child instanceof MapKeyClassElement) {\n        this.mapKeyClassName = ((MapKeyClassElement) child).getClazz();\n    }\n    if (child instanceof MapKeyEnumeratedElement) {\n        this.mapKeyEnumType = ((MapKeyEnumeratedElement) child).getEnumType();\n    }\n    if (child instanceof MapKeyTemporalElement) {\n        this.mapKeyTemporalType = ((MapKeyTemporalElement) child).getTemporalType();\n    }\n    if (child instanceof OrderByElement) {\n        this.orderBy = ((OrderByElement) child).getOrderBy();\n    }\n    if (child instanceof OrderColumnElement) {\n        this.orderColumn = ((OrderColumnElement) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1102, "method_signature": "void handleChild(Element)"}, "ElementCollectionAttributeMetadataImpl.handleAttributeOverrides": {"callee_method_names": ["AttributeOverrides.value", "AttributeOverrides.value", "Set<Class<? extends Annotation>>.add", "AttributeOverrides.value", "Set<Class<? extends Annotation>>.add"], "method_name": "ElementCollectionAttributeMetadataImpl.handleAttributeOverrides", "method_implementation": "{\n    final AttributeOverrides attributeOverrides = ReflectHelper.getAnnotation(member, AttributeOverrides.class);\n    final AttributeOverride attributeOverride = ReflectHelper.getAnnotation(member, AttributeOverride.class);\n    if ((attributeOverrides != null) && (attributeOverrides.value() != null) && (attributeOverrides.value().length > 0)) {\n        parsed.add(AttributeOverrides.class);\n        for (final AttributeOverride a : attributeOverrides.value()) {\n            this.attributeOverrides.add(new AttributeOverrideMetadataImpl(this.getLocator(), a));\n        }\n    } else if (attributeOverride != null) {\n        parsed.add(AttributeOverride.class);\n        this.attributeOverrides.add(new AttributeOverrideMetadataImpl(this.getLocator(), attributeOverride));\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the attribute overrides.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1037, "method_signature": "void handleAttributeOverrides(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleCollectionTable": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "ElementCollectionAttributeMetadataImpl.handleCollectionTable", "method_implementation": "{\n    final CollectionTable annotation = ReflectHelper.getAnnotation(member, CollectionTable.class);\n    if (annotation != null) {\n        parsed.add(CollectionTable.class);\n        return new CollectionTableMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link CollectionTable} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the collection table metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1038, "method_signature": "CollectionTableMetadata handleCollectionTable(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleColumn": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "ElementCollectionAttributeMetadataImpl.handleColumn", "method_implementation": "{\n    final Column annotation = ReflectHelper.getAnnotation(member, Column.class);\n    if (annotation != null) {\n        parsed.add(Column.class);\n        return new ColumnMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link Column} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1039, "method_signature": "ColumnMetadata handleColumn(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleEnumType": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "Enumerated.value", "Class<Object>.isEnum"], "method_name": "ElementCollectionAttributeMetadataImpl.handleEnumType", "method_implementation": "{\n    final Enumerated annotation = ReflectHelper.getAnnotation(member, Enumerated.class);\n    if (annotation != null) {\n        parsed.add(Enumerated.class);\n        return annotation.value();\n    }\n    final Class<?> memberType = ReflectHelper.getMemberType(member);\n    final int index = (memberType == Map.class) ? 1 : 0;\n    final Class<Object> type = ReflectHelper.getGenericType(member, index);\n    return type.isEnum() ? EnumType.ORDINAL : null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link Enumerated} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1040, "method_signature": "EnumType handleEnumType(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleLob": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "ElementCollectionAttributeMetadataImpl.handleLob", "method_implementation": "{\n    final Lob annotation = ReflectHelper.getAnnotation(member, Lob.class);\n    if (annotation != null) {\n        parsed.add(Lob.class);\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link Lob} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1041, "method_signature": "boolean handleLob(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleMapKey": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKey.name"], "method_name": "ElementCollectionAttributeMetadataImpl.handleMapKey", "method_implementation": "{\n    final MapKey annotation = ReflectHelper.getAnnotation(member, MapKey.class);\n    if (annotation != null) {\n        parsed.add(MapKey.class);\n        return annotation.name();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKey} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1042, "method_signature": "String handleMapKey(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleMapKeyClassName": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKeyClass.value"], "method_name": "ElementCollectionAttributeMetadataImpl.handleMapKeyClassName", "method_implementation": "{\n    final MapKeyClass annotation = ReflectHelper.getAnnotation(member, MapKeyClass.class);\n    if (annotation != null) {\n        parsed.add(MapKeyClass.class);\n        return annotation.value().getName();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyClass} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1043, "method_signature": "String handleMapKeyClassName(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleMapKeyColumn": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "ElementCollectionAttributeMetadataImpl.handleMapKeyColumn", "method_implementation": "{\n    final MapKeyColumn annotation = ReflectHelper.getAnnotation(member, MapKeyColumn.class);\n    if (annotation != null) {\n        parsed.add(MapKeyColumn.class);\n        return new ColumnMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyColumn} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1044, "method_signature": "ColumnMetadata handleMapKeyColumn(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleMapKeyEnumType": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKeyEnumerated.value"], "method_name": "ElementCollectionAttributeMetadataImpl.handleMapKeyEnumType", "method_implementation": "{\n    final MapKeyEnumerated annotation = ReflectHelper.getAnnotation(member, MapKeyEnumerated.class);\n    if (annotation != null) {\n        parsed.add(MapKeyEnumerated.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyEnumerated} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1045, "method_signature": "EnumType handleMapKeyEnumType(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleMapKeyTemporalType": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKeyTemporal.value"], "method_name": "ElementCollectionAttributeMetadataImpl.handleMapKeyTemporalType", "method_implementation": "{\n    final MapKeyTemporal annotation = ReflectHelper.getAnnotation(member, MapKeyTemporal.class);\n    if (annotation != null) {\n        parsed.add(MapKeyTemporal.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link MapKeyTemporal} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1046, "method_signature": "TemporalType handleMapKeyTemporalType(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleOrderBy": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "OrderBy.value"], "method_name": "ElementCollectionAttributeMetadataImpl.handleOrderBy", "method_implementation": "{\n    final OrderBy annotation = ReflectHelper.getAnnotation(member, OrderBy.class);\n    if (annotation != null) {\n        parsed.add(OrderBy.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link OrderBy} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1047, "method_signature": "String handleOrderBy(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleOrderColumn": {"callee_method_names": ["Set<Class<? extends Annotation>>.add"], "method_name": "ElementCollectionAttributeMetadataImpl.handleOrderColumn", "method_implementation": "{\n    final OrderColumn annotation = ReflectHelper.getAnnotation(member, OrderColumn.class);\n    if (annotation != null) {\n        parsed.add(OrderColumn.class);\n        return new ColumnMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link OrderColumn} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1048, "method_signature": "ColumnMetadata handleOrderColumn(Member, Set)"}, "ElementCollectionAttributeMetadataImpl.handleTemporalType": {"callee_method_names": ["Set<Class<? extends Annotation>>.add", "MapKeyTemporal.value"], "method_name": "ElementCollectionAttributeMetadataImpl.handleTemporalType", "method_implementation": "{\n    final MapKeyTemporal annotation = ReflectHelper.getAnnotation(member, MapKeyTemporal.class);\n    if (annotation != null) {\n        parsed.add(MapKeyTemporal.class);\n        return annotation.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the {@link Temporal} annotation.\n *\n * @param member\n *            the member\n * @param parsed\n *            the list of annotations parsed\n * @return the map key value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1049, "method_signature": "TemporalType handleTemporalType(Member, Set)"}, "ElementCollectionCriteriaTest.testCollection": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<ElementCollectionParent>.from", "RootImpl<ElementCollectionParent>.alias", "RootImpl<ElementCollectionParent>.fetch", "RootImpl<ElementCollectionParent>.fetch", "RootImpl<ElementCollectionParent>.fetch", "RootImpl<ElementCollectionParent>.fetch", "CriteriaQueryImpl<ElementCollectionParent>.select", "List<ElementCollectionParent>.size"], "method_name": "ElementCollectionCriteriaTest.testCollection", "method_implementation": "{\n    this.persist(this.parent());\n    this.persist(this.parent());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = (CriteriaBuilderImpl) this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<ElementCollectionParent> q = cb.createQuery(ElementCollectionParent.class);\n    final RootImpl<ElementCollectionParent> r = q.from(ElementCollectionParent.class);\n    r.alias(\"p\");\n    r.fetch(\"codes1\");\n    r.fetch(\"codes2\");\n    r.fetch(\"codes3\");\n    r.fetch(\"codes4\");\n    q.select(r);\n    final List<ElementCollectionParent> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(4, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2352, "method_signature": "void testCollection()"}, "ElementCollectionCriteriaTest.testMapEntries": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Entry>.from", "RootImpl<ElementCollectionParent>.alias", "RootImpl<ElementCollectionParent>.joinMap", "MapJoinImpl<ElementCollectionParent, String, String>.entry", "CriteriaQueryImpl<Entry>.select", "Order.getKey", "List<Entry>.toString"], "method_name": "ElementCollectionCriteriaTest.testMapEntries", "method_implementation": "{\n    this.persist(this.parent2());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = (CriteriaBuilderImpl) this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Entry> q = cb.createQuery(Entry.class);\n    final RootImpl<ElementCollectionParent> r = q.from(ElementCollectionParent.class);\n    r.alias(\"p\");\n    final MapJoinImpl<ElementCollectionParent, String, String> j = (MapJoinImpl<ElementCollectionParent, String, String>) r.<String, String>joinMap(\"codes5\");\n    final Expression<Entry<String, String>> k = j.entry();\n    q.select(k);\n    final List<Entry> resultList = this.em().createQuery(q).getResultList();\n    Collections.sort(resultList, new Comparator<Entry>() {\n\n        @Override\n        public int compare(Entry o1, Entry o2) {\n            return ((String) o1.getKey()).compareTo((String) o2.getKey());\n        }\n    });\n    Assert.assertEquals(\"[Key1=Value1, Key2=Value2]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2353, "method_signature": "void testMapEntries()"}, "ElementCollectionCriteriaTest.testMapKey": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<String>.from", "RootImpl<ElementCollectionParent>.alias", "RootImpl<ElementCollectionParent>.joinMap", "MapJoinImpl<ElementCollectionParent, String, String>.key", "CriteriaQueryImpl<String>.select", "List<String>.toString"], "method_name": "ElementCollectionCriteriaTest.testMapKey", "method_implementation": "{\n    this.persist(this.parent2());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = (CriteriaBuilderImpl) this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<String> q = cb.createQuery(String.class);\n    final RootImpl<ElementCollectionParent> r = q.from(ElementCollectionParent.class);\n    r.alias(\"p\");\n    final MapJoinImpl<ElementCollectionParent, String, String> j = (MapJoinImpl<ElementCollectionParent, String, String>) r.<String, String>joinMap(\"codes5\");\n    final Path<String> k = j.key();\n    q.select(k);\n    final List<String> resultList = this.em().createQuery(q).getResultList();\n    Collections.sort(resultList);\n    Assert.assertEquals(\"[Key1, Key2]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2354, "method_signature": "void testMapKey()"}, "ElementCollectionCriteriaTest.testMapValues": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<String>.from", "RootImpl<ElementCollectionParent>.alias", "RootImpl<ElementCollectionParent>.joinMap", "MapJoinImpl<ElementCollectionParent, String, String>.value", "CriteriaQueryImpl<String>.select", "List<String>.toString"], "method_name": "ElementCollectionCriteriaTest.testMapValues", "method_implementation": "{\n    this.persist(this.parent2());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = (CriteriaBuilderImpl) this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<String> q = cb.createQuery(String.class);\n    final RootImpl<ElementCollectionParent> r = q.from(ElementCollectionParent.class);\n    r.alias(\"p\");\n    final MapJoinImpl<ElementCollectionParent, String, String> j = (MapJoinImpl<ElementCollectionParent, String, String>) r.<String, String>joinMap(\"codes5\");\n    final Path<String> k = j.value();\n    q.select(k);\n    final List<String> resultList = this.em().createQuery(q).getResultList();\n    Collections.sort(resultList);\n    Assert.assertEquals(\"[Value1, Value2]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2355, "method_signature": "void testMapValues()"}, "ElementCollectionMappingImpl.enhance": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedInstance<?>.getInstance", "ManagedInstance<?>.getInstance"], "method_name": "ElementCollectionMappingImpl.enhance", "method_implementation": "{\n    final C c = this.get(instance.getInstance());\n    if (c == null) {\n        this.set(instance.getInstance(), this.attribute.newCollection(this, instance, false));\n    } else {\n        this.set(instance.getInstance(), this.attribute.newCollection(this, instance, c));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 348, "method_signature": "void enhance(ManagedInstance)"}, "ElementCollectionMappingImpl.flush": {"callee_method_names": ["ManagedInstance<?>.getInstance"], "method_name": "ElementCollectionMappingImpl.flush", "method_implementation": "{\n    final Object collection = this.get(managedInstance.getInstance());\n    if (collection != null) {\n        ((ManagedCollection<E>) collection).flush(connection, removals, force);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 349, "method_signature": "void flush(Connection, ManagedInstance, boolean, boolean)"}, "ElementCollectionMappingImpl.getOrderColumn": {"callee_method_names": [], "method_name": "ElementCollectionMappingImpl.getOrderColumn", "method_implementation": "{\n    if (this.collectionTable != null) {\n        return this.collectionTable.getOrderColumn();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 350, "method_signature": "OrderColumn getOrderColumn()"}, "ElementCollectionMappingImpl.link": {"callee_method_names": ["MapAttributeImpl<? super Z, Map<?, E>, E>.getKeyJavaType"], "method_name": "ElementCollectionMappingImpl.link", "method_implementation": "{\n    this.type = this.attribute.getElementType();\n    if (this.type.getPersistenceType() == PersistenceType.EMBEDDABLE) {\n        this.rootMapping = new ElementMappingImpl<E>(this, (EmbeddableTypeImpl<E>) this.type);\n    }\n    if (this.attribute.getCollectionType() == CollectionType.MAP) {\n        final MapAttributeImpl<? super Z, Map<?, E>, E> mapAttribute = (MapAttributeImpl<? super Z, Map<?, E>, E>) this.attribute;\n        if (this.mapKey != null) {\n            if (this.type.getPersistenceType() == PersistenceType.EMBEDDABLE) {\n                this.keyMapping = (SingularMappingEx<? super E, ?>) this.rootMapping.getMapping(this.mapKey);\n            }\n            if (this.keyMapping == null) {\n                throw new MappingException(\"Cannot locate the MapKey: \" + this.mapKey, this.attribute.getLocator());\n            }\n        } else {\n            final String name = //\n            (this.mapKeyColumn != null) && StringUtils.isNotBlank(this.mapKeyColumn.getName()) ? this.mapKeyColumn.getName() : this.attribute.getName() + \"_KEY\";\n            this.collectionTable.setKeyColumn(this.mapKeyColumn, name, this.mapKeyTemporalType, this.mapKeyEnumType, mapAttribute.getKeyJavaType());\n        }\n    }\n    final String defaultName = this.getAttribute().getName();\n    if (this.type.getPersistenceType() == PersistenceType.EMBEDDABLE) {\n        this.collectionTable.link((EntityTypeDescriptor) this.getRoot().getTypeDescriptor(), (EmbeddableTypeImpl<E>) this.type, defaultName, this.rootMapping);\n    } else {\n        this.collectionTable.link((EntityTypeDescriptor) this.getRoot().getTypeDescriptor(), this.type, defaultName, this.column, this.enumType, this.temporalType, this.lob);\n    }\n    if (this.attribute.getCollectionType() == CollectionType.LIST) {\n        final String name = (this.orderColumn != null) && StringUtils.isNotBlank(this.orderColumn.getName()) ? this.orderColumn.getName() : this.attribute.getName() + \"_ORDER\";\n        this.collectionTable.setOrderColumn(this.orderColumn, name, this.attribute.getLocator());\n    }\n}", "repo_id": "1", "comment": "/**\n * Links the attribute to its collection table\n *\n * @throws MappingException\n *             thrown in case of a linkage error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 351, "method_signature": "void link()"}, "ElementCollectionMappingImpl.load": {"callee_method_names": ["ManagedCollection<E>.initialize", "ManagedInstance<?>.getInstance"], "method_name": "ElementCollectionMappingImpl.load", "method_implementation": "{\n    final ManagedCollection<E> collection = (ManagedCollection<E>) this.attribute.newCollection(this, instance, true);\n    collection.initialize();\n    this.set(instance.getInstance(), collection);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 352, "method_signature": "void load(ManagedInstance)"}, "ElementCollectionMappingImpl.loadCollection": {"callee_method_names": ["ManagedInstance<?>.getSession", "EntityManagerImpl.createQuery", "QueryImpl<E>.setParameter", "ManagedInstance<?>.getInstance", "QueryImpl<E>.getResultList"], "method_name": "ElementCollectionMappingImpl.loadCollection", "method_implementation": "{\n    final EntityManagerImpl em = instance.getSession().getEntityManager();\n    final QueryImpl<E> q = em.createQuery(this.getSelectCriteria());\n    q.setParameter(1, instance.getInstance());\n    return q.getResultList();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 353, "method_signature": "Collection<? extends E> loadCollection(ManagedInstance)"}, "ElementCollectionMappingImpl.loadMap": {"callee_method_names": ["ManagedInstance<?>.getSession", "EntityManagerImpl.createQuery", "QueryImpl<Object[]>.setParameter", "ManagedInstance<?>.getInstance", "QueryImpl<Object[]>.getResultList", "HashMap<K, E>.put"], "method_name": "ElementCollectionMappingImpl.loadMap", "method_implementation": "{\n    final EntityManagerImpl em = instance.getSession().getEntityManager();\n    final QueryImpl<Object[]> q = em.createQuery(this.getSelectMapCriteria());\n    q.setParameter(1, instance.getInstance());\n    final HashMap<K, E> resultMap = Maps.newHashMap();\n    for (final Object[] pair : q.getResultList()) {\n        resultMap.put((K) pair[0], (E) pair[1]);\n    }\n    return resultMap;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 354, "method_signature": "Map<? extends K,? extends E> loadMap(ManagedInstance)"}, "ElementCollectionMappingImpl.sortList": {"callee_method_names": ["ManagedList<Z, E>.isInitialized", "ManagedList<Z, E>.getDelegate"], "method_name": "ElementCollectionMappingImpl.sortList", "method_implementation": "{\n    final ManagedList<Z, E> list = (ManagedList<Z, E>) this.get(instance);\n    if (list.isInitialized()) {\n        Collections.sort(list.getDelegate(), this.getComparator());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 355, "method_signature": "void sortList(Object)"}, "ElementCollectionTest.testElementCollection1": {"callee_method_names": ["Foo.setValue", "Foo.getCodes", "Foo.getCodes", "Foo.getCodes", "Foo.getCodes", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getCodes"], "method_name": "ElementCollectionTest.testElementCollection1", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"Foo2\");\n    foo.getCodes().add(\"TR\");\n    foo.getCodes().add(\"UK\");\n    foo.getCodes().add(\"US\");\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getCodes().add(\"FR\");\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo.getKey());\n    Assert.assertEquals(4, foo.getCodes().size());\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2261, "method_signature": "void testElementCollection1()"}, "ElementCollectionTest.testElementCollection2": {"callee_method_names": ["Foo.setValue", "Foo.getCodes2", "Foo.getCodes2", "Foo.getCodes2", "Foo.getCodes2", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getCodes2"], "method_name": "ElementCollectionTest.testElementCollection2", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"Foo2\");\n    foo.getCodes2().add(\"TR\");\n    foo.getCodes2().add(\"UK\");\n    foo.getCodes2().add(\"US\");\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getCodes2().add(\"FR\");\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo.getKey());\n    Assert.assertEquals(4, foo.getCodes2().size());\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2262, "method_signature": "void testElementCollection2()"}, "ElementCollectionTest.testElementCollection3": {"callee_method_names": ["Foo.setValue", "Foo.getCodes3", "Foo.getCodes3", "Foo.getCodes3", "Foo.getCodes3", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getCodes3"], "method_name": "ElementCollectionTest.testElementCollection3", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"Foo2\");\n    foo.getCodes3().add(FooType.TYPE1);\n    foo.getCodes3().add(FooType.TYPE2);\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getCodes3().remove(FooType.TYPE1);\n    foo.getCodes3().add(FooType.TYPE3);\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo.getKey());\n    Assert.assertEquals(2, foo.getCodes3().size());\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2263, "method_signature": "void testElementCollection3()"}, "ElementCollectionTest.testElementCollection4": {"callee_method_names": ["Foo.setValue", "Foo.getCodes4", "Foo.getCodes4", "Foo.getCodes4", "Foo.getCodes4", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getCodes4"], "method_name": "ElementCollectionTest.testElementCollection4", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"Foo2\");\n    foo.getCodes4().add(FooType.TYPE1);\n    foo.getCodes4().add(FooType.TYPE2);\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getCodes4().remove(FooType.TYPE1);\n    foo.getCodes4().add(FooType.TYPE3);\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo.getKey());\n    Assert.assertEquals(2, foo.getCodes4().size());\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2264, "method_signature": "void testElementCollection4()"}, "ElementCollectionTest2.testElementCollection": {"callee_method_names": ["Foo2.getImages", "Foo2.getImages", "Foo2.getImages", "Foo2.getImages", "Foo2.getImages", "Foo2.getKey", "Foo2.getKey", "Foo2.getKey", "Foo2.getImages", "Foo2.getImages", "Foo2.getImages"], "method_name": "ElementCollectionTest2.testElementCollection", "method_implementation": "{\n    Foo2 foo = new Foo2();\n    foo.getImages().put(\"photo1\", \"~/home/photos/photo1.jpg\");\n    foo.getImages().put(\"photo2\", \"~/home/photos/photo2.jpg\");\n    foo.getImages().put(\"photo3\", \"~/home/photos/photo3.jpg\");\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getImages().remove(\"photo1\");\n    foo.getImages().put(\"photo4\", \"~/home/photos/photo4.jpg\");\n    this.commit();\n    this.close();\n    foo = this.find(Foo2.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo.getKey());\n    Assert.assertEquals(3, foo.getImages().size());\n    Assert.assertNull(foo.getImages().get(\"photo1\"));\n    Assert.assertEquals(\"~/home/photos/photo4.jpg\", foo.getImages().get(\"photo4\"));\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2268, "method_signature": "void testElementCollection()"}, "ElementCollectionTest3.testElementCollection1": {"callee_method_names": ["Foo3.getImages", "Foo3.getImages", "Foo3.getImages", "Foo3.getImages", "Foo3.getImages", "Foo3.getKey", "Foo3.getKey", "Foo3.getKey", "Foo3.getImages"], "method_name": "ElementCollectionTest3.testElementCollection1", "method_implementation": "{\n    Foo3 foo = new Foo3();\n    foo.getImages().add(new Bar3(1, \"~/home/photos/photo1.jpg\"));\n    foo.getImages().add(new Bar3(2, \"~/home/photos/photo2.jpg\"));\n    foo.getImages().add(new Bar3(3, \"~/home/photos/photo3.jpg\"));\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getImages().remove(new Bar3(1, \"~/home/photos/photo1.jpg\"));\n    foo.getImages().add(new Bar3(4, \"~/home/photos/photo4.jpg\"));\n    this.commit();\n    this.close();\n    foo = this.find(Foo3.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo.getKey());\n    Assert.assertEquals(3, foo.getImages().size());\n}", "repo_id": "1", "comment": "/**\n * Tests the embeddable element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2269, "method_signature": "void testElementCollection1()"}, "ElementCollectionTest3.testElementCollection2": {"callee_method_names": ["Foo3.getImages2", "Foo3.getImages2", "Foo3.getImages2", "Foo3.getImages2", "Foo3.getImages2", "Foo3.getKey", "Foo3.getKey", "Foo3.getKey", "Foo3.getImages2"], "method_name": "ElementCollectionTest3.testElementCollection2", "method_implementation": "{\n    Foo3 foo = new Foo3();\n    foo.getImages2().put(1, new Bar3(1, \"~/home/photos/photo1.jpg\"));\n    foo.getImages2().put(2, new Bar3(2, \"~/home/photos/photo2.jpg\"));\n    foo.getImages2().put(3, new Bar3(3, \"~/home/photos/photo3.jpg\"));\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getImages2().remove(1);\n    foo.getImages2().put(4, new Bar3(4, \"~/home/photos/photo4.jpg\"));\n    this.commit();\n    this.close();\n    foo = this.find(Foo3.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo.getKey());\n    Assert.assertEquals(3, foo.getImages2().size());\n}", "repo_id": "1", "comment": "/**\n * Tests the embeddable element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2270, "method_signature": "void testElementCollection2()"}, "ElementCollectionTest4.testElementCollection": {"callee_method_names": ["Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getKey", "Foo4.getKey", "Foo4.getKey", "Foo4.getTextMap", "Map<FieldLocale, String>.keySet", "Map<FieldLocale, String>.size", "Map<FieldLocale, String>.get", "Map<FieldLocale, String>.get", "Map<FieldLocale, String>.get"], "method_name": "ElementCollectionTest4.testElementCollection", "method_implementation": "{\n    final Foo4 foo = new Foo4();\n    foo.getTextMap().put(FieldLocale.TR, \"Merhaba\");\n    foo.getTextMap().put(FieldLocale.FR, \"Bonjour\");\n    foo.getTextMap().put(FieldLocale.EN, \"Hello\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    //\n    final Foo4 foo2 = this.find(Foo4.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    final Map<FieldLocale, String> textMap = foo2.getTextMap();\n    for (final Object fl : textMap.keySet()) {\n        Assert.assertTrue(fl instanceof FieldLocale);\n    }\n    Assert.assertEquals(3, textMap.size());\n    Assert.assertEquals(\"Merhaba\", textMap.get(FieldLocale.TR));\n    Assert.assertEquals(\"Hello\", textMap.get(FieldLocale.EN));\n    Assert.assertEquals(\"Bonjour\", textMap.get(FieldLocale.FR));\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2265, "method_signature": "void testElementCollection()"}, "ElementCollectionTest4.testElementCollectionWithQuery": {"callee_method_names": ["Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getKey", "Foo4.getKey", "Foo4.getTextMap", "Map<FieldLocale, String>.keySet", "Map<FieldLocale, String>.size", "Map<FieldLocale, String>.get", "Map<FieldLocale, String>.get", "Map<FieldLocale, String>.get"], "method_name": "ElementCollectionTest4.testElementCollectionWithQuery", "method_implementation": "{\n    final Foo4 foo = new Foo4();\n    foo.getTextMap().put(FieldLocale.TR, \"Merhaba\");\n    foo.getTextMap().put(FieldLocale.FR, \"Bonjour\");\n    foo.getTextMap().put(FieldLocale.EN, \"Hello\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo4 foo2 = (Foo4) this.cq(\"select f from Foo4 f\").getSingleResult();\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    final Map<FieldLocale, String> textMap = foo2.getTextMap();\n    for (final Object fl : textMap.keySet()) {\n        Assert.assertTrue(fl instanceof FieldLocale);\n    }\n    Assert.assertEquals(3, textMap.size());\n    Assert.assertEquals(\"Merhaba\", textMap.get(FieldLocale.TR));\n    Assert.assertEquals(\"Hello\", textMap.get(FieldLocale.EN));\n    Assert.assertEquals(\"Bonjour\", textMap.get(FieldLocale.FR));\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections with jpql\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2266, "method_signature": "void testElementCollectionWithQuery()"}, "ElementCollectionTest4.testElementCollectionWithRemove": {"callee_method_names": ["Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getTextMap", "Foo4.getKey", "Foo4.getKey", "Foo4.getKey", "Foo4.getTextMap", "Map<FieldLocale, String>.keySet", "Map<FieldLocale, String>.size", "Map<FieldLocale, String>.get", "Map<FieldLocale, String>.get", "Map<FieldLocale, String>.get"], "method_name": "ElementCollectionTest4.testElementCollectionWithRemove", "method_implementation": "{\n    final Foo4 foo = new Foo4();\n    foo.getTextMap().put(FieldLocale.TR, \"Merhaba\");\n    foo.getTextMap().put(FieldLocale.FR, \"Bonjour\");\n    foo.getTextMap().put(FieldLocale.EN, \"Hello\");\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo.getTextMap().remove(FieldLocale.EN);\n    foo.getTextMap().put(FieldLocale.EN, \"Hi\");\n    this.commit();\n    this.close();\n    //\n    final Foo4 foo2 = this.find(Foo4.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    final Map<FieldLocale, String> textMap = foo2.getTextMap();\n    for (final Object fl : textMap.keySet()) {\n        Assert.assertTrue(fl instanceof FieldLocale);\n    }\n    Assert.assertEquals(3, textMap.size());\n    Assert.assertEquals(\"Merhaba\", textMap.get(FieldLocale.TR));\n    Assert.assertEquals(\"Hi\", textMap.get(FieldLocale.EN));\n    Assert.assertEquals(\"Bonjour\", textMap.get(FieldLocale.FR));\n}", "repo_id": "1", "comment": "/**\n * Tests the element collections\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2267, "method_signature": "void testElementCollectionWithRemove()"}, "ElementMappingImpl.getMapping": {"callee_method_names": ["Iterator<String>.hasNext", "Iterator<String>.next"], "method_name": "ElementMappingImpl.getMapping", "method_implementation": "{\n    final Iterator<String> segments = Splitter.on('.').split(path).iterator();\n    AbstractMapping<?, ?, ?> mapping = this;\n    while (segments.hasNext()) {\n        if (mapping instanceof AbstractParentMapping) {\n            mapping = ((AbstractParentMapping<?, ?>) mapping).getChild(segments.next());\n            if (mapping == null) {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    return mapping;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 337, "method_signature": "AbstractMapping<?,?,?> getMapping(String)"}, "EmbeddableElementFactory.generate": {"callee_method_names": [], "method_name": "EmbeddableElementFactory.generate", "method_implementation": "{\n    this.className = this.getAttribute(ElementConstants.ATTR_CLASS, ElementConstants.EMPTY);\n    this.metadataComplete = this.getAttribute(ElementConstants.ATTR_METADATA_COMPLETE, false);\n    this.accessType = this.getAttribute(ElementConstants.ATTR_ACCESS) != null ? AccessType.valueOf(this.getAttribute(ElementConstants.ATTR_ACCESS)) : null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1065, "method_signature": "void generate()"}, "EmbeddableElementFactory.handleChild": {"callee_method_names": [], "method_name": "EmbeddableElementFactory.handleChild", "method_implementation": "{\n    if (child instanceof AttributesElement) {\n        this.attrs = (AttributesElement) child;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1066, "method_signature": "void handleChild(Element)"}, "EmbeddableOverrides2Test.testFind": {"callee_method_names": ["Customer.getId", "Customer.getId", "Customer.getId", "Customer.getName", "Customer.getName", "Customer.getAddress", "Customer.getAddress", "Customer.getAddress", "Customer.getAddress", "Customer.getAddress", "Customer.getAddress"], "method_name": "EmbeddableOverrides2Test.testFind", "method_implementation": "{\n    final Customer customer = this.customer();\n    this.persist(customer);\n    this.commit();\n    this.close();\n    final Customer customer2 = this.find(Customer.class, customer.getId());\n    Assert.assertEquals(customer.getId(), customer2.getId());\n    Assert.assertEquals(customer.getName(), customer2.getName());\n    Assert.assertEquals(customer.getAddress().getCity(), customer2.getAddress().getCity());\n    Assert.assertEquals(customer.getAddress().getZipcode().getZip(), customer2.getAddress().getZipcode().getZip());\n    Assert.assertEquals(customer.getAddress().getZipcode().getPlusfour(), customer2.getAddress().getZipcode().getPlusfour());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} with two level deep override.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2435, "method_signature": "void testFind()"}, "EmbeddableOverrides2Test.testPersist": {"callee_method_names": ["Number.intValue"], "method_name": "EmbeddableOverrides2Test.testPersist", "method_implementation": "{\n    final Customer customer = this.customer();\n    this.persist(customer);\n    this.commit();\n    final Number count = new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Customer\", new SingleValueHandler<Number>());\n    Assert.assertEquals(1, count.intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} with two level deep override.\n *\n * @throws SQLException\n *             thrown if SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2436, "method_signature": "void testPersist()"}, "EmbeddableOverridesTest.testFind": {"callee_method_names": ["Foo.getId", "Foo.getId", "Foo.getId", "Foo.getValue", "Foo.getValue", "Foo.getHomeAddress", "Foo.getHomeAddress", "Foo.getHomeAddress", "Foo.getHomeAddress", "Foo.getWorkAddress", "Foo.getWorkAddress", "Foo.getWorkAddress", "Foo.getWorkAddress"], "method_name": "EmbeddableOverridesTest.testFind", "method_implementation": "{\n    final Foo foo = this.foo();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getId());\n    Assert.assertEquals(foo.getId(), foo2.getId());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getHomeAddress().getCity(), foo2.getHomeAddress().getCity());\n    Assert.assertEquals(foo.getHomeAddress().getStreet(), foo2.getHomeAddress().getStreet());\n    Assert.assertEquals(foo.getWorkAddress().getCity(), foo2.getWorkAddress().getCity());\n    Assert.assertEquals(foo.getWorkAddress().getStreet(), foo2.getWorkAddress().getStreet());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2437, "method_signature": "void testFind()"}, "EmbeddableOverridesTest.testPersist": {"callee_method_names": [], "method_name": "EmbeddableOverridesTest.testPersist", "method_implementation": "{\n    final Foo foo = this.foo();\n    this.persist(foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2438, "method_signature": "void testPersist()"}, "EmbeddableTest.testFind": {"callee_method_names": ["Foo.getId", "Foo.getId", "Foo.getId", "Foo.getValue", "Foo.getValue", "Foo.getAddress", "Foo.getAddress", "Foo.getAddress", "Foo.getAddress"], "method_name": "EmbeddableTest.testFind", "method_implementation": "{\n    final Foo foo = this.foo();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getId());\n    Assert.assertEquals(foo.getId(), foo2.getId());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getAddress().getCity(), foo2.getAddress().getCity());\n    Assert.assertEquals(foo.getAddress().getStreet(), foo2.getAddress().getStreet());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2439, "method_signature": "void testFind()"}, "EmbeddableTest.testPersist": {"callee_method_names": [], "method_name": "EmbeddableTest.testPersist", "method_implementation": "{\n    final Foo foo = this.foo();\n    this.persist(foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2440, "method_signature": "void testPersist()"}, "EmbeddableTypeImpl.getAttributeCount": {"callee_method_names": [], "method_name": "EmbeddableTypeImpl.getAttributeCount", "method_implementation": "{\n    FinalWrapper<Integer> wrapper = this.attributeCount;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.attributeCount == null) {\n                int attributeCount = 0;\n                for (final SingularAttribute<?, ?> attribute : this.getSingularAttributes()) {\n                    switch(attribute.getPersistentAttributeType()) {\n                        case BASIC:\n                            attributeCount++;\n                            break;\n                        case EMBEDDED:\n                            attributeCount += ((EmbeddableTypeImpl<?>) attribute).getAttributeCount();\n                            break;\n                        case MANY_TO_ONE:\n                        case ONE_TO_ONE:\n                            attributeCount += ((EntityTypeImpl<?>) attribute.getType()).getPrimaryTable().getPkColumns().size();\n                            break;\n                        case ELEMENT_COLLECTION:\n                        case MANY_TO_MANY:\n                        case ONE_TO_MANY:\n                            break;\n                    }\n                }\n                this.attributeCount = new FinalWrapper<Integer>(attributeCount);\n            }\n            wrapper = this.attributeCount;\n        }\n    }\n    return this.attributeCount.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the attribute count of the embeddable.\n *\n * @return the attribute count of the embeddable\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 198, "method_signature": "int getAttributeCount()"}, "EmbeddableTypeImpl.getSingularMappings": {"callee_method_names": ["List<SingularAttributeImpl<? super X, ?>>.add", "AssociatedSingularAttribute<? super X, ?>.isOwner", "AssociatedSingularAttribute<? super X, ?>.isJoined", "List<SingularAttributeImpl<? super X, ?>>.add", "Object.getAttributeId", "Object.getAttributeId", "List<SingularAttributeImpl<? super X, ?>>.toArray", "List<SingularAttributeImpl<? super X, ?>>.size"], "method_name": "EmbeddableTypeImpl.getSingularMappings", "method_implementation": "{\n    FinalWrapper<SingularAttributeImpl<?, ?>[]> wrapper = this.singularMappings;\n    if (this.singularMappings == null) {\n        synchronized (this) {\n            if (this.singularMappings == null) {\n                final List<SingularAttributeImpl<? super X, ?>> singularMappings = Lists.newArrayList();\n                for (final SingularAttribute<? super X, ?> attribute : this.getSingularAttributes()) {\n                    switch(attribute.getPersistentAttributeType()) {\n                        case BASIC:\n                        case EMBEDDED:\n                            singularMappings.add((SingularAttributeImpl<? super X, ?>) attribute);\n                            break;\n                        case MANY_TO_ONE:\n                        case ONE_TO_ONE:\n                            final AssociatedSingularAttribute<? super X, ?> association = (AssociatedSingularAttribute<? super X, ?>) attribute;\n                            if (!association.isOwner() || !association.isJoined()) {\n                                continue;\n                            }\n                            singularMappings.add((SingularAttributeImpl<? super X, ?>) attribute);\n                        case ELEMENT_COLLECTION:\n                        case MANY_TO_MANY:\n                        case ONE_TO_MANY:\n                    }\n                }\n                Collections.sort(singularMappings, new Comparator<SingularAttributeImpl<? super X, ?>>() {\n\n                    @Override\n                    public int compare(SingularAttributeImpl<? super X, ?> o1, SingularAttributeImpl<? super X, ?> o2) {\n                        return o1.getAttributeId().compareTo(o2.getAttributeId());\n                    }\n                });\n                this.singularMappings = new FinalWrapper<SingularAttributeImpl<?, ?>[]>(singularMappings.toArray(new SingularAttributeImpl[singularMappings.size()]));\n            }\n            wrapper = this.singularMappings;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the sorted singular mappings of the embeddable.\n *\n * @return the list of sorted singular attributes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 199, "method_signature": "SingularAttributeImpl<?,?>[] getSingularMappings()"}, "EmbeddableTypeImpl.newInstance": {"callee_method_names": [], "method_name": "EmbeddableTypeImpl.newInstance", "method_implementation": "{\n    try {\n        return (X) this.constructor.newInstance(EmbeddableTypeImpl.EMPTY_PARAMS);\n    }// not possible at this stage\n     catch (final Exception e) {\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns a new instance of the type\n *\n * @return a new instance of the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 200, "method_signature": "X newInstance()"}, "EmbeddedAttribute.getAssociationOverride": {"callee_method_names": [], "method_name": "EmbeddedAttribute.getAssociationOverride", "method_implementation": "{\n    for (final AssociationMetadata override : this.associationOverrides) {\n        if (override.getName().equals(path)) {\n            return override;\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns the association override if one exists for the path.\n *\n * @param path\n *            the path\n * @return the association override if one exists for the path, otherwise <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 278, "method_signature": "AssociationMetadata getAssociationOverride(String)"}, "EmbeddedAttribute.getAttributeOverride": {"callee_method_names": [], "method_name": "EmbeddedAttribute.getAttributeOverride", "method_implementation": "{\n    for (final AttributeOverrideMetadata override : this.attributeOverrides) {\n        if (override.getName().equals(path)) {\n            return override.getColumn();\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns the attribute override if one exists for the path.\n *\n * @param path\n *            the path\n * @return the attribute override if one exists for the path, otherwise <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 279, "method_signature": "ColumnMetadata getAttributeOverride(String)"}, "EmbeddedAttribute.getType": {"callee_method_names": [], "method_name": "EmbeddedAttribute.getType", "method_implementation": "{\n    if (this.type != null) {\n        return this.type;\n    }\n    return this.type = this.getMetamodel().embeddable(this.getBindableJavaType());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 280, "method_signature": "EmbeddableTypeImpl<T> getType()"}, "EmbeddedAttributeElement.handleChild": {"callee_method_names": [], "method_name": "EmbeddedAttributeElement.handleChild", "method_implementation": "{\n    if (child instanceof AttributeOverrideElement) {\n        this.attributeOverrides.add((AttributeOverrideMetadata) child);\n    }\n    if (child instanceof AssociationOverrideElement) {\n        this.associationOverrides.add((AssociationMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1115, "method_signature": "void handleChild(Element)"}, "EmbeddedAttributePath.generateJpqlRestriction": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "EmbeddedAttributePath.generateJpqlRestriction", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.getParentPath().generateJpqlRestriction(query));\n    builder.append(\".\").append(this.mapping.getAttribute().getName());\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 793, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "EmbeddedAttributePath.generateJpqlSelect": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "EmbeddedAttributePath.generateJpqlSelect", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.getParentPath().generateJpqlSelect(query, false));\n    builder.append(\".\").append(this.mapping.getAttribute().getName());\n    if (selected && StringUtils.isNotBlank(this.getAlias())) {\n        builder.append(\" as \").append(this.getAlias());\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 794, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "EmbeddedAttributePath.generateSqlSelect": {"callee_method_names": [], "method_name": "EmbeddedAttributePath.generateSqlSelect", "method_implementation": "{\n    final List<String> fragments = Lists.newArrayList();\n    this.generateSqlSelect(query, fragments, this.mapping.getSingularMappings());\n    return Joiner.on(\", \").join(fragments);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 795, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "EmbeddedAttributePath.getMapping": {"callee_method_names": [], "method_name": "EmbeddedAttributePath.getMapping", "method_implementation": "{\n    final AbstractMapping<? super X, ?, ?> child = this.mapping.getChild(name);\n    if (child == null) {\n        throw this.cannotDereference(name);\n    }\n    return (AbstractMapping<? super X, C, Y>) child;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 796, "method_signature": "AbstractMapping<? super X,C,Y> getMapping(String)"}, "EmbeddedAttributePath.getSqlRestrictionFragments": {"callee_method_names": ["List<BasicMappingImpl<?, ?>>.add", "E.getAttribute", "E.getAttribute", "EmbeddedMappingImpl<? super Z, X>.getColumn", "List<String>.add", "Joinable.getTableAlias", "BasicColumn.getTable", "BasicColumn.getName", "List<String>.toArray", "List<String>.size"], "method_name": "EmbeddedAttributePath.getSqlRestrictionFragments", "method_implementation": "{\n    final List<String> restrictions = Lists.newArrayList();\n    final Joinable rootPath = this.getRootPath();\n    final List<BasicMappingImpl<?, ?>> mappings = Lists.newArrayList();\n    for (final Mapping<? super X, ?, ?> mapping : this.mapping.getChildren()) {\n        if (mapping instanceof BasicMappingImpl) {\n            mappings.add((BasicMappingImpl<?, ?>) mapping);\n        }\n    }\n    Collections.sort(mappings, new Comparator<BasicMappingImpl<?, ?>>() {\n\n        @Override\n        public int compare(BasicMappingImpl<?, ?> o1, BasicMappingImpl<?, ?> o2) {\n            return o1.getAttribute().getAttributeId().compareTo(o2.getAttribute().getAttributeId());\n        }\n    });\n    for (final BasicMappingImpl<?, ?> mapping : mappings) {\n        final BasicColumn column = mapping.getColumn();\n        restrictions.add(rootPath.getTableAlias(query, column.getTable()) + \".\" + column.getName());\n    }\n    return restrictions.toArray(new String[restrictions.size()]);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 797, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "EmbeddedAttributePath.handle": {"callee_method_names": [], "method_name": "EmbeddedAttributePath.handle", "method_implementation": "{\n    final Object instance = this.getParentPath().handle(query, session, row);\n    return this.mapping.get(instance);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 798, "method_signature": "X handle(QueryImpl, SessionImpl, ResultSet)"}, "EmbeddedCriteriaTest.prepareCountries": {"callee_method_names": [], "method_name": "EmbeddedCriteriaTest.prepareCountries", "method_implementation": "{\n    this.begin();\n    this.persist(EmbeddedCriteriaTest.TR);\n    this.persist(EmbeddedCriteriaTest.USA);\n    this.persist(EmbeddedCriteriaTest.UK);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2362, "method_signature": "void prepareCountries()"}, "EmbeddedCriteriaTest.testEmbedded": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Person2>.from", "CriteriaQueryImpl<Person2>.select", "RootImpl<Person2>.fetch", "Fetch<Person2, Contact>.fetch", "Fetch<Contact, Address2>.fetch", "Fetch<Person2, Contact>.fetch", "List<Person2>.toString"], "method_name": "EmbeddedCriteriaTest.testEmbedded", "method_implementation": "{\n    this.persist(this.person1());\n    this.persist(this.person2());\n    this.persist(this.person3());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Person2> q = cb.createQuery(Person2.class);\n    final RootImpl<Person2> r = q.from(Person2.class);\n    q.select(r);\n    final Fetch<Person2, Contact> c = r.<Contact>fetch(\"contact\");\n    final Fetch<Contact, Address2> a = c.<Address2>fetch(\"address\");\n    a.fetch(\"country\");\n    c.fetch(\"phone\");\n    final List<Person2> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(\"[[name=Michael Jackson, contact=Contact [address=Address2 [country=Country [name=United States of America], city=New York], phone=Phone [phoneNo=111 111-1111]]], \" + \"[name=Sting, contact=Contact [address=Address2 [country=Country [name=United Kingdom], city=London], phone=Phone [phoneNo=222 222-22222]]], \" + \"[name=Tarkan, contact=Contact [address=Address2 [country=Country [name=Turkey], city=Istanbul], phone=Phone [phoneNo=333 333-3333]]]]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2363, "method_signature": "void testEmbedded()"}, "EmbeddedCriteriaTest.testEmbedded0": {"callee_method_names": ["Person2.getId", "Person2.toString"], "method_name": "EmbeddedCriteriaTest.testEmbedded0", "method_implementation": "{\n    final Person2 person1 = this.person1();\n    final Person2 person2 = this.person2();\n    final Person2 person3 = this.person3();\n    this.persist(person1);\n    this.persist(person2);\n    this.persist(person3);\n    this.commit();\n    this.close();\n    final Person2 person = this.find(Person2.class, person1.getId());\n    Assert.assertEquals(\"[name=Michael Jackson, contact=Contact [address=Address2 [country=Country [name=United States of America], city=New York], phone=Phone [phoneNo=111 111-1111]]]\", person.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2364, "method_signature": "void testEmbedded0()"}, "EmbeddedIdAttributeElement.handleChild": {"callee_method_names": [], "method_name": "EmbeddedIdAttributeElement.handleChild", "method_implementation": "{\n    if (child instanceof AttributeOverrideElement) {\n        this.attributeOverrides.add((AttributeOverrideMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1106, "method_signature": "void handleChild(Element)"}, "EmbeddedIdTest.testEmbeddedId": {"callee_method_names": ["Foo.getId", "Foo.getId", "Foo.getId", "Foo.getId"], "method_name": "EmbeddedIdTest.testEmbeddedId", "method_implementation": "{\n    final FooPk fooPk1 = new FooPk(\"key1\", 1);\n    final Foo foo1 = new Foo(fooPk1, \"Foo1\");\n    final FooPk fooPk2 = new FooPk(\"key2\", 2);\n    final Foo foo2 = new Foo(fooPk2, \"Foo2\");\n    this.persist(foo1);\n    this.persist(foo2);\n    this.commit();\n    this.close();\n    this.begin();\n    final Foo foo3 = this.find(Foo.class, foo1.getId());\n    final Foo foo4 = this.find(Foo.class, foo1.getId());\n    Assert.assertEquals(foo1.getId(), foo3.getId());\n    Assert.assertSame(foo4, foo3);\n    this.rollback();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with identity value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2187, "method_signature": "void testEmbeddedId()"}, "EmbeddedIdTest.testEmbeddedIdManyToOne": {"callee_method_names": ["Bar.getId", "Bar.getFoo", "Bar.getFoo", "Bar.getFoo"], "method_name": "EmbeddedIdTest.testEmbeddedIdManyToOne", "method_implementation": "{\n    final FooPk fooPk = new FooPk(\"key1\", 1);\n    final Foo foo = new Foo(fooPk, \"Foo\");\n    final Bar bar = new Bar(1l, foo);\n    this.persist(bar);\n    this.commit();\n    this.close();\n    final Bar bar2 = this.cq(\"select o from Bar o\", Bar.class).getSingleResult();\n    Assert.assertEquals(1, bar2.getId());\n    Assert.assertEquals(\"Foo\", bar2.getFoo().getValue());\n    Assert.assertEquals(\"key1\", bar2.getFoo().getId().getStrKey());\n    Assert.assertEquals(1, bar2.getFoo().getId().getIntKey().intValue());\n}", "repo_id": "1", "comment": "/**\n * Test embeddedId in a MonyToOne relation\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2188, "method_signature": "void testEmbeddedIdManyToOne()"}, "EmbeddedMappingImpl.fillValue": {"callee_method_names": [], "method_name": "EmbeddedMappingImpl.fillValue", "method_implementation": "{\n    X value = this.get(instance);\n    if (value == null) {\n        value = this.getAttribute().newInstance();\n        this.getAttribute().set(instance, value);\n    }\n    for (final Mapping<? super X, ?, ?> mapping : this.getChildren()) {\n        // mapping is another embedded mapping\n        if (mapping instanceof EmbeddedMappingImpl) {\n            ((EmbeddedMappingImpl<? super X, ?>) mapping).fillValue(type, managedInstance, value);\n        } else // mapping is basic mapping\n        if (mapping instanceof BasicMappingImpl) {\n            ((BasicMappingImpl<? super X, ?>) mapping).getAttribute().fillValue(type, managedInstance, value);\n        } else // no other mappings allowed in id classes\n        if (!(mapping instanceof SingularAssociationMappingImpl)) {\n            throw new MappingException(\"Embbeded ids can only have basic and embedded attributes.\", this.getType().getLocator());\n        }\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 332, "method_signature": "boolean fillValue(EntityTypeImpl, ManagedInstance, Object)"}, "EmbeddedMappingImpl.getAssociationOverride": {"callee_method_names": [], "method_name": "EmbeddedMappingImpl.getAssociationOverride", "method_implementation": "{\n    AssociationMetadata metadata = null;\n    if (this.getParent() instanceof EmbeddedMappingImpl) {\n        metadata = ((EmbeddedMappingImpl<?, Z>) this.getParent()).getAssociationOverride(this.getAttribute().getName() + \".\" + path);\n    }\n    if (metadata != null) {\n        return metadata;\n    }\n    return this.getAttribute().getAssociationOverride(path);\n}", "repo_id": "1", "comment": "/**\n * Returns the association override or <code>null</code>\n *\n * @param path\n *            the current path\n * @return the association override or <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 333, "method_signature": "AssociationMetadata getAssociationOverride(String)"}, "EmbeddedMappingImpl.getAttributeOverride": {"callee_method_names": [], "method_name": "EmbeddedMappingImpl.getAttributeOverride", "method_implementation": "{\n    ColumnMetadata metadata = null;\n    if (this.getParent() instanceof EmbeddedMappingImpl) {\n        metadata = ((EmbeddedMappingImpl<?, Z>) this.getParent()).getAttributeOverride(this.getAttribute().getName() + \".\" + path);\n    }\n    if (metadata != null) {\n        return metadata;\n    }\n    return this.getAttribute().getAttributeOverride(path);\n}", "repo_id": "1", "comment": "/**\n * Returns the attribute override or <code>null</code>\n *\n * @param path\n *            the current path\n * @return the attribute override or <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 334, "method_signature": "ColumnMetadata getAttributeOverride(String)"}, "EmbeddedMappingImpl.getIdType": {"callee_method_names": [], "method_name": "EmbeddedMappingImpl.getIdType", "method_implementation": "{\n    if (this.attribute.isId()) {\n        return IdType.MANUAL;\n    }\n    final AbstractParentMapping<?, Z> parent = this.getParent();\n    if (parent instanceof EmbeddedMappingImpl) {\n        return ((EmbeddedMappingImpl<?, Z>) parent).getIdType();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 335, "method_signature": "IdType getIdType()"}, "EmbeddedMappingImpl.getSingularMappings": {"callee_method_names": ["AttributeImpl<?, ?>.getPersistentAttributeType", "List<AbstractMapping<? super X, ?, ?>>.add", "SingularAssociationMappingImpl<? super X, ?>.isOwner", "SingularAssociationMappingImpl<? super X, ?>.getJoinTable", "List<AbstractMapping<? super X, ?, ?>>.add", "Object.getAttribute", "Object.getAttribute", "List<AbstractMapping<? super X, ?, ?>>.toArray", "List<AbstractMapping<? super X, ?, ?>>.size"], "method_name": "EmbeddedMappingImpl.getSingularMappings", "method_implementation": "{\n    if (this.singularMappings != null) {\n        return this.singularMappings;\n    }\n    synchronized (this) {\n        if (this.singularMappings != null) {\n            return this.singularMappings;\n        }\n        final List<AbstractMapping<? super X, ?, ?>> singularMappings = Lists.newArrayList();\n        for (final Mapping<? super X, ?, ?> mapping : this.getChildren()) {\n            final AttributeImpl<?, ?> attribute = ((AbstractMapping<? super X, ?, ?>) mapping).getAttribute();\n            switch(attribute.getPersistentAttributeType()) {\n                case BASIC:\n                case EMBEDDED:\n                    singularMappings.add((AbstractMapping<? super X, ?, ?>) mapping);\n                    break;\n                case MANY_TO_ONE:\n                case ONE_TO_ONE:\n                    final SingularAssociationMappingImpl<? super X, ?> association = (SingularAssociationMappingImpl<? super X, ?>) mapping;\n                    if (!association.isOwner()) {\n                        continue;\n                    }\n                    if (association.getJoinTable() != null) {\n                        continue;\n                    }\n                    singularMappings.add((AbstractMapping<? super X, ?, ?>) mapping);\n                case ONE_TO_MANY:\n                case MANY_TO_MANY:\n                case ELEMENT_COLLECTION:\n            }\n        }\n        Collections.sort(singularMappings, new Comparator<AbstractMapping<? super X, ?, ?>>() {\n\n            @Override\n            public int compare(AbstractMapping<? super X, ?, ?> o1, AbstractMapping<? super X, ?, ?> o2) {\n                return o1.getAttribute().getAttributeId().compareTo(o2.getAttribute().getAttributeId());\n            }\n        });\n        return this.singularMappings = singularMappings.toArray(new AbstractMapping[singularMappings.size()]);\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the sorted singular mappings of the embeddable\n *\n * @return the list of sorted singular attributes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 336, "method_signature": "AbstractMapping<? super X,?,?>[] getSingularMappings()"}, "Employee.equals": {"callee_method_names": [], "method_name": "Employee.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof Employee)) {\n        return false;\n    }\n    final Employee other = (Employee) obj;\n    if (this.id == null) {\n        if (other.id != null) {\n            return false;\n        }\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2254, "method_signature": "boolean equals(Object)"}, "Employee.hashCode": {"callee_method_names": [], "method_name": "Employee.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2255, "method_signature": "int hashCode()"}, "Employee.setManager": {"callee_method_names": [], "method_name": "Employee.setManager", "method_implementation": "{\n    if (this.manager != null) {\n        this.manager.getEmployees().remove(this);\n    }\n    this.manager = manager;\n    if (this.manager != null) {\n        this.manager.getEmployees().add(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the manager of the Employee.\n *\n * @param manager\n *            the manager to set for Employee\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2367, "method_signature": "void setManager(Manager)"}, "EmployeeId.equals": {"callee_method_names": [], "method_name": "EmployeeId.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof EmployeeId)) {\n        return false;\n    }\n    final EmployeeId other = (EmployeeId) obj;\n    if (this.firstName == null) {\n        if (other.firstName != null) {\n            return false;\n        }\n    } else if (!this.firstName.equals(other.firstName)) {\n        return false;\n    }\n    if (this.lastName == null) {\n        if (other.lastName != null) {\n            return false;\n        }\n    } else if (!this.lastName.equals(other.lastName)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2115, "method_signature": "boolean equals(Object)"}, "EmployeeId.hashCode": {"callee_method_names": [], "method_name": "EmployeeId.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.firstName == null) ? 0 : this.firstName.hashCode());\n    result = (prime * result) + ((this.lastName == null) ? 0 : this.lastName.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2116, "method_signature": "int hashCode()"}, "EnhanceTest.testEnhance": {"callee_method_names": ["Class<? extends Person>.getConstructor", "Constructor<? extends Person>.newInstance"], "method_name": "EnhanceTest.testEnhance", "method_implementation": "{\n    final EntityType<Person> type = this.em().getMetamodel().entity(Person.class);\n    final Class<? extends Person> enhanced = Enhancer.enhance(type);\n    final Constructor<? extends Person> constructor = enhanced.getConstructor(Class.class, SessionImpl.class, Object.class, boolean.class);\n    constructor.newInstance(null, null, null, true);\n}", "repo_id": "1", "comment": "/**\n * Tests the enhancement\n *\n * @throws Exception\n *             thrown in case of failure\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2287, "method_signature": "void testEnhance()"}, "EnhanceTest.testEnhanceAbstractClass": {"callee_method_names": ["Class<? extends AbstractEntity>.getSuperclass", "Class<? extends AbstractEntity>.getConstructor", "Constructor<? extends AbstractEntity>.newInstance"], "method_name": "EnhanceTest.testEnhanceAbstractClass", "method_implementation": "{\n    final EntityType<AbstractEntity> type = this.em().getMetamodel().entity(AbstractEntity.class);\n    final Class<? extends AbstractEntity> enhanced = Enhancer.enhance(type);\n    Assert.assertEquals(AbstractEntity.class, enhanced.getSuperclass());\n    final Constructor<? extends AbstractEntity> constructor = enhanced.getConstructor(Class.class, SessionImpl.class, Object.class, boolean.class);\n    constructor.newInstance(null, null, null, true);\n}", "repo_id": "1", "comment": "/**\n * Test enhance for abstract class\n *\n * @throws Exception\n */\n", "repo_name": "BatooJPA-master/", "id": 2288, "method_signature": "void testEnhanceAbstractClass()"}, "EnhanceTest.testEnhanceClassExtendsAbstractClass": {"callee_method_names": ["Class<? extends ConcreteEntity>.getSuperclass", "Class<? extends ConcreteEntity>.getConstructor", "Constructor<? extends ConcreteEntity>.newInstance"], "method_name": "EnhanceTest.testEnhanceClassExtendsAbstractClass", "method_implementation": "{\n    final EntityType<ConcreteEntity> type = this.em().getMetamodel().entity(ConcreteEntity.class);\n    final Class<? extends ConcreteEntity> enhanced = Enhancer.enhance(type);\n    Assert.assertEquals(ConcreteEntity.class, enhanced.getSuperclass());\n    final Constructor<? extends ConcreteEntity> constructor = enhanced.getConstructor(Class.class, SessionImpl.class, Object.class, boolean.class);\n    constructor.newInstance(null, null, null, true);\n}", "repo_id": "1", "comment": "/**\n * Test enhance for a class that extends an abstract class\n *\n * @throws Exception\n */\n", "repo_name": "BatooJPA-master/", "id": 2289, "method_signature": "void testEnhanceClassExtendsAbstractClass()"}, "Enhancer.create": {"callee_method_names": ["ClassWriter.visit", "ClassWriter.visitField", "ClassWriter.visitField", "ClassWriter.visitField", "ClassWriter.visitField", "ClassWriter.visitField", "ClassWriter.visitField", "ClassWriter.visitField", "Class<?>.getDeclaredMethods", "Method.getModifiers", "Method.isSynthetic", "Method.isBridge", "Method.getName", "Method.getParameterTypes", "Map<String, Method>.get", "Map<String, Method>.put", "Class<?>.getSuperclass", "Map<String, Method>.values", "Method.getName", "ClassWriter.visitEnd", "ClassWriter.toByteArray"], "method_name": "Enhancer.create", "method_implementation": "{\n    final String enhancingClassName = Type.getInternalName(clazz);\n    final String enhancedClassName = enhancingClassName + Enhancer.SUFFIX_ENHANCED;\n    final String descEnhancer = Enhancer.makeClassDesc(enhancedClassName);\n    final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n    cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, enhancedClassName, null, enhancingClassName, new String[] { Type.getInternalName(EnhancedInstance.class) });\n    // Field: serialVersionUID\n    cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, Enhancer.FIELD_SERIAL_VERSION_UID, Type.getDescriptor(Long.TYPE), null, Long.valueOf(1L)).visitEnd();\n    // Container fields\n    cw.visitField(Opcodes.ACC_PRIVATE, Enhancer.FIELD_ENHANCED_INITIALIZED, Enhancer.DESCRIPTOR_BOOLEAN, null, null).visitEnd();\n    cw.visitField(Opcodes.ACC_PRIVATE, Enhancer.FIELD_ENHANCED_INTERNAL, Enhancer.DESCRIPTOR_BOOLEAN, null, null).visitEnd();\n    cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_TRANSIENT, Enhancer.FIELD_ENHANCED_ID, Enhancer.DESCRIPTOR_OBJECT, null, null).visitEnd();\n    cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_TRANSIENT, Enhancer.FIELD_ENHANCED_TYPE, Enhancer.DESCRIPTOR_CLASS, null, null).visitEnd();\n    cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_TRANSIENT, Enhancer.FIELD_ENHANCED_SESSION, Enhancer.DESCRIPTOR_SESSION, null, null).visitEnd();\n    cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_TRANSIENT, Enhancer.FIELD_ENHANCED_MANAGED_INSTANCE, Enhancer.DESCRIPTOR_MANAGED_INSTANCE, null, null).visitEnd();\n    // Constructors\n    Enhancer.createNoArgConstructor(enhancingClassName, enhancedClassName, descEnhancer, cw);\n    Enhancer.createContainerConstructor(enhancingClassName, enhancedClassName, descEnhancer, cw);\n    Enhancer.createMethodIsInitialized(enhancedClassName, descEnhancer, cw);\n    Enhancer.createMethodSetInitialized(enhancedClassName, descEnhancer, cw);\n    Enhancer.createMethodCheck(enhancedClassName, descEnhancer, cw);\n    Enhancer.createMethodGetManagedInstance(enhancedClassName, descEnhancer, cw);\n    Enhancer.createMethodSetManagedInstance(enhancedClassName, descEnhancer, cw);\n    Enhancer.createMethodSetInternal(enhancedClassName, descEnhancer, cw);\n    final Map<String, Method> methods = Maps.newHashMap();\n    Class<?> currentClass = clazz;\n    while (currentClass != Object.class) {\n        // we are not interested in Object.class\n        for (final Method method : currentClass.getDeclaredMethods()) {\n            int modifiers = method.getModifiers();\n            if (Modifier.isAbstract(modifiers) || Modifier.isStatic(modifiers) || Modifier.isPrivate(modifiers) || method.isSynthetic() || method.isBridge()) {\n                continue;\n            }\n            // Filter out the details that we are not interested\n            modifiers &= Modifier.ABSTRACT;\n            modifiers &= Modifier.FINAL;\n            modifiers &= Modifier.NATIVE;\n            modifiers &= Modifier.PRIVATE;\n            modifiers &= Modifier.PROTECTED;\n            modifiers &= Modifier.STATIC;\n            modifiers &= Modifier.STRICT;\n            if ((modifiers == Modifier.PUBLIC) || (modifiers == 0)) {\n                // we are not interested in the return type to omit the overridden methods\n                final String desc = method.getName() + Enhancer.makeDescription(Void.TYPE, method.getParameterTypes());\n                if (methods.get(desc) == null) {\n                    methods.put(desc, method);\n                }\n            }\n        }\n        currentClass = currentClass.getSuperclass();\n    }\n    for (final Method method : methods.values()) {\n        if (!Enhancer.IGNORED_METHODS.contains(method.getName())) {\n            Enhancer.createOverrriddenMethod(enhancingClassName, enhancedClassName, descEnhancer, cw, method);\n        }\n    }\n    cw.visitEnd();\n    return cw.toByteArray();\n}", "repo_id": "1", "comment": "//@formatter:off\n", "repo_name": "BatooJPA-master/", "id": 967, "method_signature": "byte[] create(Class)"}, "Enhancer.enhance": {"callee_method_names": ["EntityType<T>.getJavaType", "Class<T>.getClassLoader", "EntityType<T>.getJavaType"], "method_name": "Enhancer.enhance", "method_implementation": "{\n    final Class<T> javaType = type.getJavaType();\n    final ClassLoader classLoader = javaType.getClassLoader();\n    final String className = type.getJavaType().getName() + Enhancer.CLASS_ENHANCED_SUFFIX;\n    // try if loaded\n    final Class<T> enhancedClass = (Class<T>) Enhancer.tryLoadClass(classLoader, className);\n    if (enhancedClass != null) {\n        return enhancedClass;\n    }\n    return Enhancer.enhance0(javaType, classLoader, className);\n}", "repo_id": "1", "comment": "/**\n * Enhances a type.\n *\n * @param <T>\n *            the type of the entity\n * @param type\n *            the type for the class\n * @return the enhanced class\n * @throws Exception\n *             thrown if the enhancement fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 968, "method_signature": "Class<T> enhance(EntityType)"}, "Enhancer.loadClass": {"callee_method_names": ["Class<?>.getDeclaredMethod", "java.lang.reflect.Method.setAccessible", "java.lang.reflect.Method.invoke", "java.lang.reflect.Method.setAccessible"], "method_name": "Enhancer.loadClass", "method_implementation": "{\n    final Class<?> cls = Class.forName(\"java.lang.ClassLoader\");\n    final java.lang.reflect.Method method = cls.getDeclaredMethod(\"defineClass\", new Class[] { String.class, byte[].class, Integer.TYPE, Integer.TYPE });\n    // protected method invocation\n    method.setAccessible(true);\n    try {\n        final Object[] args = new Object[] { className, byteCode, Integer.valueOf(0), Integer.valueOf(byteCode.length) };\n        return (Class<T>) method.invoke(classLoader, args);\n    } finally {\n        method.setAccessible(false);\n    }\n}", "repo_id": "1", "comment": "/**\n * Loads the class.\n *\n * @param classLoader\n *            the class loader\n * @param byteCode\n *            the bytecode\n * @param className\n *            the name of the class\n * @param <T>\n *            the type of the class\n * @return the loaded class\n * @throws Exception\n *             if class cannot be loaded\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 969, "method_signature": "Class<T> loadClass(ClassLoader, byte[], String)"}, "EntityConstantExpression.ensureAlias": {"callee_method_names": ["BaseQueryImpl<?>.getAlias"], "method_name": "EntityConstantExpression.ensureAlias", "method_implementation": "{\n    if (this.position == null) {\n        this.position = query.getAlias(this);\n        if (StringUtils.isBlank(this.getAlias())) {\n            this.alias(\"const\" + this.position);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 677, "method_signature": "void ensureAlias(BaseQueryImpl)"}, "EntityConstantExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "EntityConstantExpression.generateJpqlRestriction", "method_implementation": "{\n    if (Number.class.isAssignableFrom(this.getJavaType())) {\n        return this.value.toString();\n    } else {\n        return \"'\" + this.value.toString() + \"'\";\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 678, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "EntityElementFactory.generate": {"callee_method_names": [], "method_name": "EntityElementFactory.generate", "method_implementation": "{\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n    this.className = this.getAttribute(ElementConstants.ATTR_CLASS, ElementConstants.EMPTY);\n    this.metadataComplete = this.getAttribute(ElementConstants.ATTR_METADATA_COMPLETE, false);\n    this.cachable = this.getAttribute(ElementConstants.ATTR_CACHABLE) != null ? Boolean.valueOf(this.getAttribute(ElementConstants.ATTR_CACHABLE)) : null;\n    this.accessType = this.getAttribute(ElementConstants.ATTR_ACCESS) != null ? AccessType.valueOf(this.getAttribute(ElementConstants.ATTR_ACCESS)) : null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1069, "method_signature": "void generate()"}, "EntityElementFactory.handleChild": {"callee_method_names": [], "method_name": "EntityElementFactory.handleChild", "method_implementation": "{\n    if (child instanceof AttributesElement) {\n        this.attrs = (AttributesElement) child;\n    }\n    if (child instanceof SequenceGeneratorMetadata) {\n        this.sequenceGenerator = (SequenceGeneratorMetadata) child;\n    }\n    if (child instanceof TableGeneratorMetadata) {\n        this.tableGenerator = (TableGeneratorMetadata) child;\n    }\n    if (child instanceof TableElement) {\n        this.table = (TableMetadata) child;\n    }\n    if (child instanceof SecondaryTableElement) {\n        this.secondaryTables.add((SecondaryTableMetadata) child);\n    }\n    if (child instanceof AttributeOverrideElement) {\n        this.attributeOverrides.add((AttributeOverrideMetadata) child);\n    }\n    if (child instanceof AssociationOverrideElement) {\n        this.associationOverrides.add((AssociationMetadata) child);\n    }\n    if (child instanceof InheritanceMetadata) {\n        this.inheritanceType = ((InheritanceMetadata) child).getInheritanceType();\n    }\n    if (child instanceof DiscriminatorColumnMetadata) {\n        this.discriminatorColumn = (DiscriminatorColumnMetadata) child;\n    }\n    if (child instanceof DiscriminatorValueElement) {\n        this.discriminatorValue = ((DiscriminatorValueElement) child).getDiscriminatorValue();\n    }\n    if (child instanceof IdClassElement) {\n        this.idClass = ((IdClassElement) child).getIdClass();\n    }\n    if (child instanceof EntityListenersElement) {\n        this.listeners.addAll(((EntityListenersElement) child).getListeners());\n    }\n    if (child instanceof CallbackMetadata) {\n        this.callbacks.add((CallbackMetadata) this.callbacks);\n    }\n    if (child instanceof ExcludeDefaultListenersElement) {\n        this.excludeDefaultListeners = true;\n    }\n    if (child instanceof ExcludeSuperclassListenersElement) {\n        this.excludeSuperclassListeners = true;\n    }\n    if (child instanceof NamedQueryMetadata) {\n        this.namedQueries.add((NamedQueryMetadata) child);\n    }\n    if (child instanceof NamedNativeQueryMetadata) {\n        this.namedNativeQueries.add((NamedNativeQueryMetadata) child);\n    }\n    if (child instanceof SqlResultSetMappingMetadata) {\n        this.sqlResultSetMappings.add((SqlResultSetMappingMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1070, "method_signature": "void handleChild(Element)"}, "EntityListenerMetadataImpl.handleCallbacks": {"callee_method_names": ["Class<?>.getMethods", "Method.getDeclaringClass", "Method.getAnnotation", "Set<Class<? extends Annotation>>.add", "Method.getAnnotation", "Set<Class<? extends Annotation>>.add", "Method.getAnnotation", "Set<Class<? extends Annotation>>.add", "Method.getAnnotation", "Set<Class<? extends Annotation>>.add", "Method.getAnnotation", "Set<Class<? extends Annotation>>.add", "Method.getAnnotation", "Set<Class<? extends Annotation>>.add", "Method.getAnnotation", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityListenerMetadataImpl.handleCallbacks", "method_implementation": "{\n    for (final Method method : clazz.getMethods()) {\n        if (method.getDeclaringClass() != clazz) {\n            continue;\n        }\n        if (method.getAnnotation(PrePersist.class) != null) {\n            if (annotationsParsed != null) {\n                annotationsParsed.add(PrePersist.class);\n            }\n            this.callbacks.add(this.createCallback(method, EntityListenerType.PRE_PERSIST));\n        }\n        if (method.getAnnotation(PreUpdate.class) != null) {\n            if (annotationsParsed != null) {\n                annotationsParsed.add(PreUpdate.class);\n            }\n            this.callbacks.add(this.createCallback(method, EntityListenerType.PRE_UPDATE));\n        }\n        if (method.getAnnotation(PreRemove.class) != null) {\n            if (annotationsParsed != null) {\n                annotationsParsed.add(PreRemove.class);\n            }\n            this.callbacks.add(this.createCallback(method, EntityListenerType.PRE_REMOVE));\n        }\n        if (method.getAnnotation(PostLoad.class) != null) {\n            if (annotationsParsed != null) {\n                annotationsParsed.add(PostLoad.class);\n            }\n            this.callbacks.add(this.createCallback(method, EntityListenerType.POST_LOAD));\n        }\n        if (method.getAnnotation(PostPersist.class) != null) {\n            if (annotationsParsed != null) {\n                annotationsParsed.add(PostPersist.class);\n            }\n            this.callbacks.add(this.createCallback(method, EntityListenerType.POST_PERSIST));\n        }\n        if (method.getAnnotation(PostRemove.class) != null) {\n            if (annotationsParsed != null) {\n                annotationsParsed.add(PostRemove.class);\n            }\n            this.callbacks.add(this.createCallback(method, EntityListenerType.POST_REMOVE));\n        }\n        if (method.getAnnotation(PostUpdate.class) != null) {\n            if (annotationsParsed != null) {\n                annotationsParsed.add(PostUpdate.class);\n            }\n            this.callbacks.add(this.createCallback(method, EntityListenerType.POST_UPDATE));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the callbacks.\n *\n * @param clazz\n *\n * @since 2.0.0\n * @param annotationsParsed\n */\n", "repo_name": "BatooJPA-master/", "id": 1051, "method_signature": "void handleCallbacks(Class, Set)"}, "EntityListenersElement.handleChild": {"callee_method_names": [], "method_name": "EntityListenersElement.handleChild", "method_implementation": "{\n    if (child instanceof EntityListenerMetadata) {\n        this.listeners.add((EntityListenerMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1125, "method_signature": "void handleChild(Element)"}, "EntityManagerFactoryImpl.addNamedQuery": {"callee_method_names": ["QueryImpl<?>.getCriteriaQuery", "QueryImpl<?>.getHints", "QueryImpl<?>.getLockMode"], "method_name": "EntityManagerFactoryImpl.addNamedQuery", "method_implementation": "{\n    final QueryImpl<?> typedQuery = (QueryImpl<?>) query;\n    final String jpql = typedQuery.getCriteriaQuery().getJpql();\n    new JpqlQuery(this, this.criteriaBuilder, new NamedQueryMetadata() {\n\n        @Override\n        public Map<String, Object> getHints() {\n            return typedQuery.getHints();\n        }\n\n        @Override\n        public AbstractLocator getLocator() {\n            return null;\n        }\n\n        @Override\n        public LockModeType getLockMode() {\n            return typedQuery.getLockMode();\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public String getQuery() {\n            return jpql;\n        }\n    });\n}", "repo_id": "1", "comment": "/**\n * Adds the query to the named queries.\n *\n * @param name\n *            the name fo the query\n * @param query\n *            the query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 459, "method_signature": "void addNamedQuery(String, Query)"}, "EntityManagerFactoryImpl.assertOpen": {"callee_method_names": [], "method_name": "EntityManagerFactoryImpl.assertOpen", "method_implementation": "{\n    if (!this.open) {\n        throw new IllegalStateException(\"EntityManagerFactory has been previously closed\");\n    }\n}", "repo_id": "1", "comment": "/**\n * Checks if the entity manager factory is open.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 460, "method_signature": "void assertOpen()"}, "EntityManagerFactoryImpl.close": {"callee_method_names": [], "method_name": "EntityManagerFactoryImpl.close", "method_implementation": "{\n    this.assertOpen();\n    this.metamodel.stopIdGenerators();\n    final String dropOnClose = (String) this.getProperty(BJPASettings.DROP_ON_CLOSE);\n    if (\"true\".equalsIgnoreCase(dropOnClose)) {\n        this.metamodel.dropAllTables(this.dataSource);\n    }\n    this.dataSource.close();\n    this.open = false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 461, "method_signature": "void close()"}, "EntityManagerFactoryImpl.createEntityManager": {"callee_method_names": [], "method_name": "EntityManagerFactoryImpl.createEntityManager", "method_implementation": "{\n    this.assertOpen();\n    return new EntityManagerImpl(this, this.metamodel, this.dataSource, map, this.jdbcAdaptor);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 463, "method_signature": "EntityManager createEntityManager(Map)"}, "EntityManagerFactoryImpl.createJdbcAdaptor": {"callee_method_names": ["Connection.getMetaData", "JdbcAdaptor.setInsertBatchSize", "JdbcAdaptor.setRemoveBatchSize", "Connection.close"], "method_name": "EntityManagerFactoryImpl.createJdbcAdaptor", "method_implementation": "{\n    int insertBatchSize;\n    try {\n        insertBatchSize = //\n        this.getProperty(BJPASettings.INSERT_BATCH_SIZE) != null ? //\n        Integer.valueOf(((String) this.getProperty(BJPASettings.INSERT_BATCH_SIZE))) : BJPASettings.DEFAULT_INSERT_BATCH_SIZE;\n    } catch (final Exception e) {\n        throw new IllegalArgumentException(\"Illegal value \" + this.getProperty(BJPASettings.INSERT_BATCH_SIZE) + \" for \" + BJPASettings.INSERT_BATCH_SIZE);\n    }\n    int removeBatchSize;\n    try {\n        removeBatchSize = //\n        this.getProperty(BJPASettings.REMOVE_BATCH_SIZE) != null ? //\n        Integer.valueOf(((String) this.getProperty(BJPASettings.REMOVE_BATCH_SIZE))) : BJPASettings.DEFAULT_REMOVE_BATCH_SIZE;\n    } catch (final Exception e) {\n        throw new IllegalArgumentException(\"Illegal value \" + this.getProperty(BJPASettings.REMOVE_BATCH_SIZE) + \" for \" + BJPASettings.REMOVE_BATCH_SIZE);\n    }\n    try {\n        final Connection connection = this.dataSource.getConnection();\n        try {\n            final JdbcAdaptor adapter = AbstractJdbcAdaptor.getAdapter(this.classloader, connection.getMetaData().getDatabaseProductName());\n            adapter.setInsertBatchSize(insertBatchSize);\n            adapter.setRemoveBatchSize(removeBatchSize);\n            return adapter;\n        } finally {\n            connection.close();\n        }\n    } catch (final SQLException e) {\n        throw new BatooException(\"Unable to get connection from the datasource\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates the JDBC adaptor.\n *\n * @return the JDBC Adaptor\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 464, "method_signature": "JdbcAdaptor createJdbcAdaptor()"}, "EntityManagerFactoryImpl.getCriteriaBuilder": {"callee_method_names": [], "method_name": "EntityManagerFactoryImpl.getCriteriaBuilder", "method_implementation": "{\n    this.assertOpen();\n    return this.criteriaBuilder;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 465, "method_signature": "CriteriaBuilderImpl getCriteriaBuilder()"}, "EntityManagerFactoryImpl.getJpqlQuery": {"callee_method_names": ["E.getLastUsed", "E.getLastUsed", "JpqlQuery[].getQueryString", "E.getCause", "E.getCause", "E.getCause", "E.getCause"], "method_name": "EntityManagerFactoryImpl.getJpqlQuery", "method_implementation": "{\n    try {\n        EntityManagerFactoryImpl.LOG.debug(\"JPQL: {0}\", qlString);\n        JpqlQuery jpqlQuery = this.jpqlCache.get(qlString);\n        if (jpqlQuery == null) {\n            jpqlQuery = new JpqlQuery(EntityManagerFactoryImpl.this, qlString);\n            // clean up job\n            if (this.jpqlCache.size() == EntityManagerFactoryImpl.NO_QUERIES_MAX) {\n                synchronized (this) {\n                    if (this.jpqlCache.size() == EntityManagerFactoryImpl.NO_QUERIES_MAX) {\n                        final JpqlQuery[] queries = Lists.newArrayList(this.jpqlCache.values()).toArray(new JpqlQuery[this.jpqlCache.size()]);\n                        Arrays.sort(queries, new Comparator<JpqlQuery>() {\n\n                            @Override\n                            public int compare(JpqlQuery o1, JpqlQuery o2) {\n                                if (o1.getLastUsed() > o2.getLastUsed()) {\n                                    return 1;\n                                }\n                                return -1;\n                            }\n                        });\n                        for (int i = 0; i < EntityManagerFactoryImpl.NO_QUERIES_TRIM; i++) {\n                            this.jpqlCache.remove(queries[i].getQueryString());\n                        }\n                    }\n                }\n            }\n            this.jpqlCache.put(qlString, jpqlQuery);\n        }\n        return jpqlQuery;\n    } catch (final Exception e) {\n        if (e.getCause() instanceof PersistenceException) {\n            throw (PersistenceException) e.getCause();\n        }\n        if (e.getCause() instanceof IllegalArgumentException) {\n            throw (IllegalArgumentException) e.getCause();\n        }\n        throw new PersistenceException(\"Cannot parse query: \" + qlString, e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns a lazy created {@link JpqlQuery} for the query.\n *\n * @param qlString\n *            the JPQL query string\n * @return the Jpql Query object\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 466, "method_signature": "JpqlQuery getJpqlQuery(String)"}, "EntityManagerFactoryImpl.unwrap": {"callee_method_names": [], "method_name": "EntityManagerFactoryImpl.unwrap", "method_implementation": "{\n    if (clazz == EntityManagerFactoryImpl.class) {\n        return (T) this;\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 467, "method_signature": "T unwrap(Class)"}, "EntityManagerImpl.assertOpen": {"callee_method_names": [], "method_name": "EntityManagerImpl.assertOpen", "method_implementation": "{\n    if (!this.open) {\n        throw new IllegalStateException(\"EntityManager has been previously closed\");\n    }\n    // if (this.rollbackOnly) {\n    // throw new IllegalStateException(\"EntityManager previously encountered an exception.\");\n    // }\n}", "repo_id": "1", "comment": "/**\n * Checks if the entity manager is open.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 428, "method_signature": "void assertOpen()"}, "EntityManagerImpl.assertTransaction": {"callee_method_names": [], "method_name": "EntityManagerImpl.assertTransaction", "method_implementation": "{\n    this.assertOpen();\n    if ((this.transaction == null) || !this.transaction.isActive()) {\n        throw new TransactionRequiredException(\"No active transaction\");\n    }\n}", "repo_id": "1", "comment": "/**\n * Asserts that a transaction is active.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 429, "method_signature": "void assertTransaction()"}, "EntityManagerImpl.cascadeMerge": {"callee_method_names": ["EntityTypeImpl<T>.getAssociations", "PluralAssociationMappingImpl<?, ?, ?>.getAttribute", "PluralAssociationMappingImpl<?, ?, ?>.get", "Map<?, ?>.values", "PluralAssociationMappingImpl<?, ?, ?>.get", "List<?>.size", "List<?>.get", "SingularAssociationMappingImpl<? super X, ?>.cascadesMerge", "SingularAssociationMappingImpl<? super X, ?>.cascadesMerge", "SingularAssociationMappingImpl<? super X, ?>.get", "SingularAssociationMappingImpl<? super X, ?>.cascadesMerge"], "method_name": "EntityManagerImpl.cascadeMerge", "method_implementation": "{\n    for (final AssociationMappingImpl<?, ?, ?> association : type.getAssociations()) {\n        // if the association is a plural association\n        if (association instanceof PluralAssociationMappingImpl) {\n            final PluralAssociationMappingImpl<?, ?, ?> mapping = (PluralAssociationMappingImpl<?, ?, ?>) association;\n            Collection<?> children;\n            if (mapping.getAttribute().getCollectionType() == CollectionType.MAP) {\n                final Map<?, ?> map = (Map<?, ?>) mapping.get(entity);\n                children = map.values();\n            } else {\n                // get the children\n                children = (Collection<?>) mapping.get(entity);\n            }\n            if (children != null) {\n                // iterate over children and merge them all\n                if (children instanceof List) {\n                    final List<?> childrenList = (List<?>) children;\n                    for (int i = 0; i < childrenList.size(); i++) {\n                        this.mergeImpl(childrenList.get(i), requiresFlush, processed, instances, association.cascadesMerge());\n                    }\n                } else {\n                    for (final Object child : children) {\n                        this.mergeImpl(child, requiresFlush, processed, instances, association.cascadesMerge());\n                    }\n                }\n            }\n        } else // if the association is a singular association\n        {\n            final Object associate = association.get(entity);\n            // merge the entity\n            this.mergeImpl(associate, requiresFlush, processed, instances, association.cascadesMerge());\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Cascades the merge operation\n *\n * @param type\n *            the entity type\n * @param entity\n *            the entity\n * @param requiresFlush\n *            if an implicit flush is required\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the persisted instances\n * @param <T>\n *            the type of the entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 430, "method_signature": "void cascadeMerge(EntityTypeImpl, T, MutableBoolean, IdentityHashMap, LinkedList)"}, "EntityManagerImpl.clear": {"callee_method_names": [], "method_name": "EntityManagerImpl.clear", "method_implementation": "{\n    this.assertOpen();\n    if ((this.transaction != null) && this.transaction.isActive()) {\n        this.transaction.rollback();\n        EntityManagerImpl.LOG.warn(\"Session cleared with active and transaction. Updated persistent types will become stale...\");\n    }\n    this.session.clear();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 431, "method_signature": "void clear()"}, "EntityManagerImpl.close": {"callee_method_names": [], "method_name": "EntityManagerImpl.close", "method_implementation": "{\n    this.assertOpen();\n    if ((this.transaction != null) && this.transaction.isActive()) {\n        this.transaction.rollback();\n        EntityManagerImpl.LOG.warn(\"Entity manager closed with an active transaction. Updated persistent types will become stale...\");\n    }\n    this.closeConnection();\n    this.open = false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 432, "method_signature": "void close()"}, "EntityManagerImpl.closeConnection": {"callee_method_names": [], "method_name": "EntityManagerImpl.closeConnection", "method_implementation": "{\n    if (this.connection != null) {\n        try {\n            this.connection.close();\n        } catch (final SQLException e) {\n        }\n    }\n    this.connection = null;\n}", "repo_id": "1", "comment": "/**\n * Closes the database connection.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 433, "method_signature": "void closeConnection()"}, "EntityManagerImpl.contains": {"callee_method_names": ["ManagedInstance<Object>.getInstance"], "method_name": "EntityManagerImpl.contains", "method_implementation": "{\n    this.assertOpen();\n    final ManagedInstance<Object> instance = this.session.get(entity);\n    return (instance != null) && (instance.getInstance() == entity);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 434, "method_signature": "boolean contains(Object)"}, "EntityManagerImpl.createNamedQuery": {"callee_method_ids": [769], "callee_method_names": ["JpqlQuery.createTypedQuery"], "method_name": "EntityManagerImpl.createNamedQuery", "method_implementation": "{\n    final JpqlQuery query = this.emf.getNamedQuery(name);\n    if (query == null) {\n        throw new IllegalArgumentException(\"No named query found with the name: \" + name);\n    }\n    return query.createTypedQuery(this);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 436, "method_signature": "TypedQuery<T> createNamedQuery(String, Class)"}, "EntityManagerImpl.detach": {"callee_method_names": ["ManagedInstance<?>.cascadeDetach"], "method_name": "EntityManagerImpl.detach", "method_implementation": "{\n    if (entity == null) {\n        return;\n    }\n    this.assertOpen();\n    final ManagedInstance<?> instance = this.session.remove(entity);\n    if (instance != null) {\n        instance.cascadeDetach(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 437, "method_signature": "void detach(Object)"}, "EntityManagerImpl.find": {"callee_method_names": [], "method_name": "EntityManagerImpl.find", "method_implementation": "{\n    if (primaryKey == null) {\n        throw new NullPointerException();\n    }\n    // try to locate in the session\n    final EntityTypeImpl<T> type = this.metamodel.entity(entityClass);\n    return this.findImpl(primaryKey, lockMode, properties, type);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 438, "method_signature": "T find(Class, Object, LockModeType, Map)"}, "EntityManagerImpl.flush": {"callee_method_names": ["E.getConstraintViolations"], "method_name": "EntityManagerImpl.flush", "method_implementation": "{\n    if (this.inFlush) {\n        return;\n    }\n    this.assertTransaction();\n    this.inFlush = true;\n    try {\n        this.session.handleExternals();\n        final ManagedInstance<?>[] instances = this.session.handleAdditions();\n        this.session.cascadeRemovals(instances);\n        this.session.handleOrphans(instances);\n        this.session.flush(this.getConnection());\n    } catch (final SQLException e) {\n        EntityManagerImpl.LOG.error(e, \"Flush failed\");\n        throw new PersistenceException(\"Flush failed\", e);\n    } catch (final ConstraintViolationException e) {\n        EntityManagerImpl.LOG.debug(e, \"Flush failed due to validation errors:\\n\\t\" + Joiner.on(\"\\n\\t\").join(e.getConstraintViolations()));\n        throw e;\n    } catch (final RuntimeException e) {\n        EntityManagerImpl.LOG.error(e, \"Flush failed\");\n        throw e;\n    } finally {\n        this.inFlush = false;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 439, "method_signature": "void flush()"}, "EntityManagerImpl.getConnection": {"callee_method_names": [], "method_name": "EntityManagerImpl.getConnection", "method_implementation": "{\n    // if the connection exists then simply return it\n    if (this.connection != null) {\n        return this.connection;\n    }\n    try {\n        this.joinTransaction();\n        // create a new connection and return it\n        return this.connection = this.datasource.getConnection();\n    } catch (final SQLException e) {\n        throw new PersistenceException(\"Unable to obtain connection from the datasource\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the active connection.\n *\n * @return the connection\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 440, "method_signature": "Connection getConnection()"}, "EntityManagerImpl.getDelegate": {"callee_method_names": [], "method_name": "EntityManagerImpl.getDelegate", "method_implementation": "{\n    this.assertOpen();\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 441, "method_signature": "Object getDelegate()"}, "EntityManagerImpl.getLockMode": {"callee_method_names": ["ManagedInstance<Object>.getLockMode"], "method_name": "EntityManagerImpl.getLockMode", "method_implementation": "{\n    final ManagedInstance<Object> instance = this.session.get(entity);\n    return instance.getLockMode();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 442, "method_signature": "LockModeType getLockMode(Object)"}, "EntityManagerImpl.getReference": {"callee_method_names": ["ManagedInstance<? extends T>.getInstance", "EntityTypeImpl<T>.getManagedInstanceById", "ManagedInstance<? extends T>.getInstance"], "method_name": "EntityManagerImpl.getReference", "method_implementation": "{\n    if (primaryKey == null) {\n        throw new NullPointerException();\n    }\n    // try to locate in the session\n    final EntityTypeImpl<T> type = this.metamodel.entity(entityClass);\n    final ManagedId<T> managedId = new ManagedId<T>(primaryKey, type);\n    // try to locate in the session\n    ManagedInstance<? extends T> instance = this.session.get(managedId);\n    if (instance != null) {\n        return instance.getInstance();\n    }\n    // create a lazy instance\n    instance = type.getManagedInstanceById(this.session, managedId, true);\n    this.session.put(instance);\n    // and return it\n    return instance.getInstance();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 443, "method_signature": "T getReference(Class, Object)"}, "EntityManagerImpl.getTransaction": {"callee_method_names": [], "method_name": "EntityManagerImpl.getTransaction", "method_implementation": "{\n    // if the transaction exists simply return it\n    if (this.transaction != null) {\n        return this.transaction;\n    }\n    this.assertOpen();\n    // create the new transaction and return it\n    return this.transaction = new EntityTransactionImpl(this, this.getConnection());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 444, "method_signature": "EntityTransactionImpl getTransaction()"}, "EntityManagerImpl.hasTransactionMarkedForRollback": {"callee_method_names": [], "method_name": "EntityManagerImpl.hasTransactionMarkedForRollback", "method_implementation": "{\n    if (this.transaction != null) {\n        return this.transaction.getRollbackOnly();\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Returns if the entity manager has a transaction which is marked for rollback.\n *\n * @return true if the entity manager has a transaction which is marked for rollback, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 445, "method_signature": "boolean hasTransactionMarkedForRollback()"}, "EntityManagerImpl.isValid": {"callee_method_names": [], "method_name": "EntityManagerImpl.isValid", "method_implementation": "{\n    if (this.transaction != transaction) {\n        throw new PersistenceException(\"Transaction is stale\");\n    }\n}", "repo_id": "1", "comment": "/**\n * Check if the transaction is valid and belongs to this entity manager.\n *\n * @param transaction\n *            the transaction to test the validity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 446, "method_signature": "void isValid(EntityTransactionImpl)"}, "EntityManagerImpl.lock": {"callee_method_names": ["ManagedInstance<?>.getType", "EntityTypeImpl<?>.hasVersionAttribute", "ManagedInstance<?>.getType", "ManagedInstance<?>.incrementVersion", "ManagedInstance<?>.incrementVersion"], "method_name": "EntityManagerImpl.lock", "method_implementation": "{\n    // check optimistic lock is supported\n    if ((lockMode == LockModeType.OPTIMISTIC) || (lockMode == LockModeType.OPTIMISTIC_FORCE_INCREMENT)) {\n        final EntityTypeImpl<?> type = instance.getType().getRootType();\n        if (!type.hasVersionAttribute()) {\n            throw new PersistenceException(\"OPTIMISTIC and OPTIMISTIC_FORCE_INCREMENT not supported on non-versioned entity \" + instance.getType().getName());\n        }\n        try {\n            if (lockMode == LockModeType.OPTIMISTIC_FORCE_INCREMENT) {\n                this.assertTransaction();\n                instance.incrementVersion(this.getConnection(), true);\n            } else {\n                instance.incrementVersion(this.getConnection(), false);\n            }\n        } catch (final SQLException e) {\n            throw new PersistenceException(\"Unabled to update the version\", e);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Locks the entity.\n *\n * @param instance\n *            the managed instance\n * @param lockMode\n *            the lock mode\n * @param properties\n *            the properties\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 447, "method_signature": "void lock(ManagedInstance, LockModeType, Map)"}, "EntityManagerImpl.merge": {"callee_method_names": ["MutableBoolean.booleanValue", "ManagedInstance<?>.fireCallbacks"], "method_name": "EntityManagerImpl.merge", "method_implementation": "{\n    final MutableBoolean requiresFlush = new MutableBoolean(false);\n    final LinkedList<ManagedInstance<?>> persistedInstances = Lists.newLinkedList();\n    final T mergedEntity = this.mergeImpl(entity, requiresFlush, Maps.<Object, Object>newIdentityHashMap(), persistedInstances, true);\n    if (requiresFlush.booleanValue()) {\n        this.flush();\n    }\n    for (final ManagedInstance<?> instance : persistedInstances) {\n        instance.fireCallbacks(EntityListenerType.PRE_PERSIST);\n    }\n    return mergedEntity;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 448, "method_signature": "T merge(T)"}, "EntityManagerImpl.mergeImpl": {"callee_method_names": ["IdentityHashMap<Object,Object>.get", "T.getClass", "Class<?>.getSuperclass", "ManagedInstance<T>.getStatus", "ManagedInstance<T>.getStatus", "ManagedInstance<T>.getStatus", "IdentityHashMap<Object,Object>.put", "ManagedInstance<T>.getInstance", "ManagedInstance<T>.getStatus", "LinkedList<ManagedInstance<?>>.add", "ManagedInstance<T>.getInstance", "ManagedInstance<T>.mergeWith", "ManagedInstance<T>.getInstance", "EntityTypeImpl<T>.getInstanceId", "IdentityHashMap<Object,Object>.put", "ManagedInstance<T>.getInstance", "ManagedInstance<T>.mergeWith", "ManagedInstance<T>.getInstance", "EntityTypeImpl<T>.getManagedInstanceById", "ManagedInstance<T>.setStatus", "ManagedInstance<T>.enhanceCollections", "IdentityHashMap<Object,Object>.put", "ManagedInstance<T>.getInstance", "LinkedList<ManagedInstance<?>>.add", "ManagedInstance<T>.mergeWith", "ManagedInstance<T>.fillIdValues", "MutableBoolean.setValue", "ManagedInstance<T>.getInstance"], "method_name": "EntityManagerImpl.mergeImpl", "method_implementation": "{\n    if (entity == null) {\n        return null;\n    }\n    // if already processed just return\n    final T processedEntity = (T) processed.get(entity);\n    if (processedEntity != null) {\n        return processedEntity;\n    }\n    // try to locate the instance in the session\n    ManagedInstance<T> instance = this.session.get(entity);\n    Class<?> clazz = entity.getClass();\n    if (entity instanceof EnhancedInstance) {\n        clazz = clazz.getSuperclass();\n    }\n    final EntityTypeImpl<T> type = (EntityTypeImpl<T>) this.metamodel.entity(clazz);\n    // if it is in the session then test its status\n    if (instance != null) {\n        // if it is a removed entity then throw\n        if (instance.getStatus() == Status.REMOVED) {\n            throw new IllegalArgumentException(\"Entity has been previously removed\");\n        }\n        // if it is an existing instance then merge and return\n        if ((instance.getStatus() == Status.MANAGED) || (instance.getStatus() == Status.NEW)) {\n            processed.put(entity, instance.getInstance());\n            if (instance.getStatus() == Status.NEW) {\n                instances.add(instance);\n            }\n            if (instance.getInstance() != entity) {\n                instance.mergeWith(this, entity, requiresFlush, processed, instances);\n            } else {\n                this.cascadeMerge(type, entity, requiresFlush, processed, instances);\n            }\n            return instance.getInstance();\n        }\n    }\n    // get the id of the entity\n    final Object id = type.getInstanceId(entity);\n    // if it has an id try to locate instance in the database\n    if (id != null) {\n        T existingEntity = null;\n        try {\n            existingEntity = this.find((Class<T>) clazz, id);\n        } catch (final NoResultException e) {\n        }\n        // if it is found in the database then merge and return\n        if (existingEntity != null) {\n            instance = (ManagedInstance<T>) ((EnhancedInstance) existingEntity).__enhanced__$$__getManagedInstance();\n            processed.put(entity, instance.getInstance());\n            instance.mergeWith(this, entity, requiresFlush, processed, instances);\n            return instance.getInstance();\n        }\n    }\n    // it is a new instance, create a new instance and merge with it\n    final ManagedId<T> managedId = new ManagedId<T>(id, type);\n    instance = type.getManagedInstanceById(this.session, managedId, false);\n    instance.setStatus(Status.NEW);\n    instance.enhanceCollections();\n    this.session.putExternal(instance);\n    processed.put(entity, instance.getInstance());\n    instances.add(instance);\n    instance.mergeWith(this, entity, requiresFlush, processed, instances);\n    if (!instance.fillIdValues()) {\n        requiresFlush.setValue(true);\n    }\n    return instance.getInstance();\n}", "repo_id": "1", "comment": "/**\n * Cascaded implementation of {@link #merge(Object)}.\n * <p>\n * Also manages a direct or indirect requirement to an implicit flush.\n *\n * @param entity\n *            the entity to cascade\n * @param requiresFlush\n *            if an implicit flush is required\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the persisted instances\n * @param cascade\n *            cascades the merge operation\n * @param <T>\n *            the type of the entity\n * @return true if an implicit flush is required, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 449, "method_signature": "T mergeImpl(T, MutableBoolean, IdentityHashMap, LinkedList, boolean)"}, "EntityManagerImpl.persist": {"callee_method_names": ["ManagedInstance<T>.fireCallbacks"], "method_name": "EntityManagerImpl.persist", "method_implementation": "{\n    this.assertTransaction();\n    final LinkedList<ManagedInstance<?>> persistedInstances = Lists.newLinkedList();\n    if (this.persistImpl(entity, Lists.newArrayList(), persistedInstances)) {\n        this.flush();\n    }\n    for (final ManagedInstance<?> instance : persistedInstances) {\n        instance.fireCallbacks(EntityListenerType.PRE_PERSIST);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 450, "method_signature": "void persist(Object)"}, "EntityManagerImpl.persistImpl": {"callee_method_names": ["ArrayList<Object>.contains", "ManagedInstance<T>.getStatus", "ArrayList<Object>.add", "LinkedList<ManagedInstance<?>>.add", "ManagedInstance<T>.getStatus", "ManagedInstance<T>.setStatus", "ManagedInstance<T>.cascadePersist", "ManagedInstance<T>.cascadePersist", "T.getClass", "T.getClass", "EntityTypeImpl<T>.getManagedInstance", "ManagedInstance<T>.setStatus", "ManagedInstance<T>.enhanceCollections", "ManagedInstance<T>.fillIdValues", "ArrayList<Object>.add", "LinkedList<ManagedInstance<?>>.add", "ManagedInstance<T>.cascadePersist"], "method_name": "EntityManagerImpl.persistImpl", "method_implementation": "{\n    if (entity == null) {\n        return false;\n    }\n    if (processed.contains(entity)) {\n        return false;\n    }\n    if (entity instanceof EnhancedInstance) {\n        final ManagedInstance<T> instance = (ManagedInstance<T>) ((EnhancedInstance) entity).__enhanced__$$__getManagedInstance();\n        if (instance.getStatus() == Status.DETACHED) {\n            throw new EntityExistsException(\"Entity has been previously detached\");\n        }\n    }\n    final ManagedInstance<T> existing = this.session.get(entity);\n    if (existing != null) {\n        processed.add(entity);\n        instances.add(existing);\n        switch(existing.getStatus()) {\n            case REMOVED:\n                existing.setStatus(Status.MANAGED);\n                return existing.cascadePersist(this, processed, instances);\n            case NEW:\n            case MANAGED:\n                return existing.cascadePersist(this, processed, instances);\n            case DETACHED:\n        }\n    }\n    final Class<T> clazz = (Class<T>) (entity instanceof EnhancedInstance ? entity.getClass().getSuperclass() : entity.getClass());\n    final EntityTypeImpl<T> type = this.metamodel.entity(clazz);\n    final ManagedInstance<T> instance = type.getManagedInstance(this.session, entity);\n    instance.setStatus(Status.NEW);\n    instance.enhanceCollections();\n    boolean requiresFlush = !instance.fillIdValues();\n    this.session.putExternal(instance);\n    processed.add(entity);\n    instances.add(instance);\n    requiresFlush |= instance.cascadePersist(this, processed, instances);\n    return requiresFlush;\n}", "repo_id": "1", "comment": "/**\n * Cascaded implementation of {@link #persist(Object)}.\n * <p>\n * Also manages a direct or indirect requirement to an implicit flush.\n *\n * @param entity\n *            the entity to cascade\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the managed instances\n * @param <T>\n *            the type of the entity\n * @return true if an implicit flush is required, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 451, "method_signature": "boolean persistImpl(T, ArrayList, LinkedList)"}, "EntityManagerImpl.refresh": {"callee_method_names": [], "method_name": "EntityManagerImpl.refresh", "method_implementation": "{\n    this.assertOpen();\n    this.refreshImpl(entity, lockMode, Sets.newHashSet());\n    this.closeConnectionIfNecessary();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 452, "method_signature": "void refresh(Object, LockModeType, Map)"}, "EntityManagerImpl.refreshImpl": {"callee_method_names": ["Set<Object>.contains", "ManagedInstance<?>.getSession", "ManagedInstance<?>.getStatus", "ManagedInstance<?>.refresh", "Set<Object>.add"], "method_name": "EntityManagerImpl.refreshImpl", "method_implementation": "{\n    if (entity == null) {\n        return null;\n    }\n    // if already processed just return\n    if (processed.contains(entity)) {\n        return null;\n    }\n    if (entity instanceof EnhancedInstance) {\n        final ManagedInstance<?> instance = ((EnhancedInstance) entity).__enhanced__$$__getManagedInstance();\n        if ((instance.getSession() == this.session) && (instance.getStatus() == Status.MANAGED)) {\n            instance.refresh(this, this.getConnection(), lockMode, processed);\n            processed.add(instance);\n            return instance;\n        }\n    }\n    throw new IllegalArgumentException(\"entity is not managed\");\n}", "repo_id": "1", "comment": "/**\n * Recursive refresh implementation.\n *\n * @param entity\n *            the entity to refresh\n * @param lockMode\n *            the lock mode\n * @param processed\n *            registry of processed entities\n * @return the managed instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 453, "method_signature": "ManagedInstance<?> refreshImpl(Object, LockModeType, Set)"}, "EntityManagerImpl.remove": {"callee_method_names": ["ManagedInstance<?>.fireCallbacks"], "method_name": "EntityManagerImpl.remove", "method_implementation": "{\n    this.assertOpen();\n    final LinkedList<ManagedInstance<?>> removedInstances = Lists.newLinkedList();\n    this.removeImpl(entity, Lists.newArrayList(), removedInstances);\n    for (final ManagedInstance<?> instance : removedInstances) {\n        instance.fireCallbacks(EntityListenerType.PRE_REMOVE);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 454, "method_signature": "void remove(Object)"}, "EntityManagerImpl.removeImpl": {"callee_method_names": ["ArrayList<Object>.contains", "EnhancedInstance.__enhanced__$$__getManagedInstance", "ManagedInstance<Object>.getStatus", "ManagedInstance<Object>.getStatus", "ManagedInstance<Object>.setStatus", "ArrayList<Object>.add", "LinkedList<ManagedInstance<?>>.add", "ManagedInstance<Object>.cascadeRemove", "ManagedInstance<Object>.getStatus", "ManagedInstance<Object>.getInstance", "ManagedInstance<Object>.setStatus", "ArrayList<Object>.add", "LinkedList<ManagedInstance<?>>.add", "ManagedInstance<Object>.cascadeRemove"], "method_name": "EntityManagerImpl.removeImpl", "method_implementation": "{\n    if ((processed != null) && processed.contains(entity)) {\n        return;\n    }\n    if (entity instanceof EnhancedInstance) {\n        final EnhancedInstance enhancedInstance = (EnhancedInstance) entity;\n        final ManagedInstance<?> instance = enhancedInstance.__enhanced__$$__getManagedInstance();\n        if ((instance != null) && (instance.getStatus() == Status.DETACHED)) {\n            throw new IllegalArgumentException(\"Entity has been previously detached\");\n        }\n    }\n    final ManagedInstance<Object> instance = this.session.get(entity);\n    if (instance != null) {\n        if (instance.getStatus() == Status.MANAGED) {\n            instance.setStatus(Status.REMOVED);\n            this.session.setChanged(instance);\n            if (processed != null) {\n                processed.add(entity);\n                instances.add(instance);\n            }\n            instance.cascadeRemove(this, processed, instances);\n        } else if (instance.getStatus() == Status.NEW) {\n            this.session.remove(instance.getInstance());\n            instance.setStatus(Status.DETACHED);\n            if (processed != null) {\n                processed.add(entity);\n                instances.add(instance);\n            }\n            instance.cascadeRemove(this, processed, instances);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Cascaded implementation of {@link #remove(Object)}.\n *\n * @param entity\n *            the entity to cascade\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the managed instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 455, "method_signature": "void removeImpl(Object, ArrayList, LinkedList)"}, "EntityManagerImpl.setRollbackOnly": {"callee_method_names": [], "method_name": "EntityManagerImpl.setRollbackOnly", "method_implementation": "{\n    if (this.transaction != null) {\n        this.transaction.setRollbackOnly();\n    }\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 456, "method_signature": "void setRollbackOnly()"}, "EntityManagerImpl.unwrap": {"callee_method_names": [], "method_name": "EntityManagerImpl.unwrap", "method_implementation": "{\n    if (clazz == DataSource.class) {\n        return (T) this.datasource;\n    }\n    if (clazz == Connection.class) {\n        return (T) this.connection;\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 457, "method_signature": "T unwrap(Class)"}, "EntityMapping.getMapping": {"callee_method_names": ["Iterator<String>.hasNext", "Iterator<String>.next"], "method_name": "EntityMapping.getMapping", "method_implementation": "{\n    final Iterator<String> segments = Splitter.on('.').split(path).iterator();\n    AbstractMapping<?, ?, ?> mapping = this;\n    while (segments.hasNext()) {\n        if (mapping instanceof AbstractParentMapping) {\n            mapping = ((AbstractParentMapping<?, ?>) mapping).getChild(segments.next());\n            if (mapping == null) {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    return mapping;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 338, "method_signature": "AbstractMapping<?,?,?> getMapping(String)"}, "EntityMappings.handleChild": {"callee_method_names": ["PersistenceUnitMetadataElement.getPersistenceUnitDefaults", "PersistenceUnitDefaults.getAccessType", "PersistenceUnitDefaults.getCatalog", "PersistenceUnitDefaults.getSchema", "PersistenceUnitDefaults.isCascadePersist", "PersistenceUnitDefaults.getListeners", "PersistenceUnitMetadataElement.isXmlMappingMetadataComplete"], "method_name": "EntityMappings.handleChild", "method_implementation": "{\n    if (child instanceof AccessElement) {\n        this.accessType = ((AccessElement) child).getAccessType();\n    }\n    if (child instanceof PersistenceUnitMetadataElement) {\n        final PersistenceUnitMetadataElement element = (PersistenceUnitMetadataElement) child;\n        final PersistenceUnitDefaults persistenceUnitDefaults = element.getPersistenceUnitDefaults();\n        if (persistenceUnitDefaults != null) {\n            this.accessType = persistenceUnitDefaults.getAccessType();\n            this.catalog = persistenceUnitDefaults.getCatalog();\n            this.schema = persistenceUnitDefaults.getSchema();\n            this.cascadePersist = persistenceUnitDefaults.isCascadePersist();\n            this.entityListeners.addAll(persistenceUnitDefaults.getListeners());\n        }\n        this.xmlMappingMetadataComplete = element.isXmlMappingMetadataComplete();\n    }\n    if (child instanceof CatalogElement) {\n        this.catalog = ((CatalogElement) child).getCatalog();\n    }\n    if (child instanceof SchemaElement) {\n        this.schema = ((SchemaElement) child).getSchema();\n    }\n    if (child instanceof SequenceGeneratorElement) {\n        this.sequenceGenerators.add((SequenceGeneratorElement) child);\n    }\n    if (child instanceof TableGeneratorElement) {\n        this.tableGenerators.add((TableGeneratorElement) child);\n    }\n    if (child instanceof EmbeddableMetadata) {\n        this.entities.add((EmbeddableMetadata) child);\n    }\n    if (child instanceof MappedSuperclassMetadata) {\n        this.entities.add((MappedSuperclassMetadata) child);\n    }\n    if (child instanceof EntityListenersElement) {\n        this.entityListeners.addAll(((EntityListenersElement) child).getListeners());\n    }\n    if (child instanceof EntityMetadata) {\n        this.entities.add((EntityMetadata) child);\n    }\n    if (child instanceof NamedQueryMetadata) {\n        this.namedQueries.add((NamedQueryMetadata) child);\n    }\n    if (child instanceof NamedNativeQueryMetadata) {\n        this.namedNativeQueries.add((NamedNativeQueryMetadata) child);\n    }\n    if (child instanceof SqlResultSetMappingMetadata) {\n        this.sqlResultSetMappings.add((SqlResultSetMappingMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1061, "method_signature": "void handleChild(Element)"}, "EntityMetadataImpl.handleAssociationOverrides": {"callee_method_names": ["EntityMetadata.getAssociationOverrides", "EntityMetadata.getAssociationOverrides", "AssociationOverrides.value", "Set<Class<? extends Annotation>>.add", "AssociationOverrides.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleAssociationOverrides", "method_implementation": "{\n    if ((metadata != null) && (metadata.getAssociationOverrides().size() > 0)) {\n        this.associationOverrides.addAll(metadata.getAssociationOverrides());\n    } else {\n        final AssociationOverrides overrides = this.getClazz().getAnnotation(AssociationOverrides.class);\n        if ((overrides != null) && (overrides.value().length > 0)) {\n            parsed.add(AttributeOverrides.class);\n            for (final AssociationOverride override : overrides.value()) {\n                this.associationOverrides.add(new AssociationOverrideMetadataImpl(this.getLocator(), override));\n            }\n        } else {\n            final AssociationOverride override = this.getClazz().getAnnotation(AssociationOverride.class);\n            parsed.add(AssociationOverride.class);\n            if (override != null) {\n                this.associationOverrides.add(new AssociationOverrideMetadataImpl(this.getLocator(), override));\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the association override definitions of the entity.\n * <p>\n * If metadata provides at least one association override definition then the its definitions are added to {@link #attributeOverrides}.\n * <p>\n * Else if either {@link AssociationOverrides} or {@link AssociationOverride} annotations present, then definition based on the\n * annotation is added to {@link #associationOverrides}.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 996, "method_signature": "void handleAssociationOverrides(EntityMetadata, Set)"}, "EntityMetadataImpl.handleAttributeOverrides": {"callee_method_names": ["EntityMetadata.getAttributeOverrides", "EntityMetadata.getAttributeOverrides", "AttributeOverrides.value", "Set<Class<? extends Annotation>>.add", "AttributeOverrides.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleAttributeOverrides", "method_implementation": "{\n    if ((metadata != null) && (metadata.getAttributeOverrides().size() > 0)) {\n        this.attributeOverrides.addAll(metadata.getAttributeOverrides());\n    } else {\n        final AttributeOverrides overrides = this.getClazz().getAnnotation(AttributeOverrides.class);\n        if ((overrides != null) && (overrides.value().length > 0)) {\n            parsed.add(AttributeOverrides.class);\n            for (final AttributeOverride override : overrides.value()) {\n                this.attributeOverrides.add(new AttributeOverrideMetadataImpl(this.getLocator(), override));\n            }\n        } else {\n            final AttributeOverride override = this.getClazz().getAnnotation(AttributeOverride.class);\n            parsed.add(AttributeOverride.class);\n            if (override != null) {\n                this.attributeOverrides.add(new AttributeOverrideMetadataImpl(this.getLocator(), override));\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the attribute override definitions of the entity.\n * <p>\n * If metadata provides at least one attribute override definition then the its definitions are added to {@link #attributeOverrides}.\n * <p>\n * Else if either {@link AttributeOverrides} or {@link AttributeOverride} annotations present, then definition based on the annotation\n * is added to {@link #attributeOverrides}.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 997, "method_signature": "void handleAttributeOverrides(EntityMetadata, Set)"}, "EntityMetadataImpl.handleCacheable": {"callee_method_names": ["EntityMetadata.getCacheable", "EntityMetadata.getCacheable", "Set<Class<? extends Annotation>>.add", "Cacheable.value"], "method_name": "EntityMetadataImpl.handleCacheable", "method_implementation": "{\n    if ((metadata != null) && (metadata.getCacheable() != null)) {\n        return metadata.getCacheable();\n    }\n    final Cacheable cacheable = this.getClazz().getAnnotation(Cacheable.class);\n    if (cacheable != null) {\n        parsed.add(Cacheable.class);\n        return cacheable.value();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the cacheability of the entity.\n * <p>\n * If metadata specifies the cacheability definition, the definition is returned.\n * <p>\n * Then if the {@link Cacheable} annotation present, then returned true.\n * <p>\n * Finally entity class's simple name is returned\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotation parsed\n * @return the name\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 998, "method_signature": "Boolean handleCacheable(EntityMetadata, Set)"}, "EntityMetadataImpl.handleIndexes": {"callee_method_names": ["Indexes.value", "Set<Class<? extends Annotation>>.add", "Indexes.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleIndexes", "method_implementation": "{\n    final Indexes indexes = this.getClazz().getAnnotation(Indexes.class);\n    if ((indexes != null) && (indexes.value().length > 0)) {\n        parsed.add(Indexes.class);\n        for (final Index index : indexes.value()) {\n            this.indexes.add(new IndexMetadataImpl(this.getLocator(), index));\n        }\n    } else {\n        final Index index = this.getClazz().getAnnotation(Index.class);\n        parsed.add(Index.class);\n        if (index != null) {\n            this.indexes.add(new IndexMetadataImpl(this.getLocator(), index));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the index definitions of the entity.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 999, "method_signature": "void handleIndexes(EntityMetadata, Set)"}, "EntityMetadataImpl.handleInheritance": {"callee_method_names": ["EntityMetadata.getInheritanceType", "EntityMetadata.getDiscriminatorColumn", "EntityMetadata.getDiscriminatorValue", "Inheritance.strategy", "Set<Class<? extends Annotation>>.add", "Set<Class<? extends Annotation>>.add", "DiscriminatorValue.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleInheritance", "method_implementation": "{\n    if (metadata != null) {\n        this.inheritanceType = metadata.getInheritanceType();\n        this.discriminatorColumn = metadata.getDiscriminatorColumn();\n        this.discriminatorValue = metadata.getDiscriminatorValue();\n    }\n    if (this.inheritanceType == null) {\n        final Inheritance inheritance = this.getClazz().getAnnotation(Inheritance.class);\n        if (inheritance != null) {\n            this.inheritanceType = inheritance.strategy();\n            parsed.add(Inheritance.class);\n        }\n    }\n    if (this.discriminatorColumn == null) {\n        final DiscriminatorColumn discriminatorColumn = this.getClazz().getAnnotation(DiscriminatorColumn.class);\n        if (discriminatorColumn != null) {\n            this.discriminatorColumn = new DiscriminatorColumnMetadataImpl(this.getLocator(), discriminatorColumn);\n            parsed.add(DiscriminatorColumn.class);\n        }\n    }\n    if (this.discriminatorValue == null) {\n        final DiscriminatorValue discriminatorValue = this.getClazz().getAnnotation(DiscriminatorValue.class);\n        if (discriminatorValue != null) {\n            this.discriminatorValue = discriminatorValue.value();\n            parsed.add(DiscriminatorValue.class);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the inheritance definition of the entity.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1000, "method_signature": "void handleInheritance(EntityMetadata, Set)"}, "EntityMetadataImpl.handleName": {"callee_method_names": ["EntityMetadata.getName", "EntityMetadata.getName", "Entity.name", "Set<Class<? extends Annotation>>.add", "Entity.name"], "method_name": "EntityMetadataImpl.handleName", "method_implementation": "{\n    if ((metadata != null) && StringUtils.isNotBlank(metadata.getName())) {\n        return metadata.getName();\n    }\n    final Entity entity = this.getClazz().getAnnotation(Entity.class);\n    if ((entity != null) && StringUtils.isNotBlank(entity.name())) {\n        parsed.add(Entity.class);\n        return entity.name();\n    }\n    return this.getClazz().getSimpleName();\n}", "repo_id": "1", "comment": "/**\n * Handles the name of the entity.\n * <p>\n * If metadata provides a name definition, the definition is returned.\n * <p>\n * Then if the {@link Entity} annotation present, then name on the annotation is returned.\n * <p>\n * Finally entity class's simple name is returned\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotation parsed\n * @return the name\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1001, "method_signature": "String handleName(EntityMetadata, Set)"}, "EntityMetadataImpl.handleNamedNativeQuery": {"callee_method_names": ["EntityMetadata.getNamedNativeQueries", "EntityMetadata.getNamedNativeQueries", "NamedNativeQueries.value", "Set<Class<? extends Annotation>>.add", "NamedNativeQueries.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleNamedNativeQuery", "method_implementation": "{\n    if ((metadata != null) && (metadata.getNamedNativeQueries().size() > 0)) {\n        this.namedNativeQueries.addAll(metadata.getNamedNativeQueries());\n    }\n    final NamedNativeQueries namedQueries = this.getClazz().getAnnotation(NamedNativeQueries.class);\n    if ((namedQueries != null) && (namedQueries.value().length > 0)) {\n        parsed.add(NamedNativeQueries.class);\n        for (final NamedNativeQuery namedQuery : namedQueries.value()) {\n            this.namedNativeQueries.add(new NamedNativeQueryMetadataImpl(this.getLocator(), namedQuery));\n        }\n    } else {\n        final NamedNativeQuery namedQuery = this.getClazz().getAnnotation(NamedNativeQuery.class);\n        parsed.add(NamedNativeQuery.class);\n        if (namedQuery != null) {\n            this.namedNativeQueries.add(new NamedNativeQueryMetadataImpl(this.getLocator(), namedQuery));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the named native query definitions of the entity.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1002, "method_signature": "void handleNamedNativeQuery(EntityMetadata, Set)"}, "EntityMetadataImpl.handleNamedQuery": {"callee_method_names": ["EntityMetadata.getNamedQueries", "EntityMetadata.getNamedQueries", "NamedQueries.value", "Set<Class<? extends Annotation>>.add", "NamedQueries.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleNamedQuery", "method_implementation": "{\n    if ((metadata != null) && (metadata.getNamedQueries().size() > 0)) {\n        this.namedQueries.addAll(metadata.getNamedQueries());\n    }\n    final NamedQueries namedQueries = this.getClazz().getAnnotation(NamedQueries.class);\n    if ((namedQueries != null) && (namedQueries.value().length > 0)) {\n        parsed.add(NamedQueries.class);\n        for (final NamedQuery namedQuery : namedQueries.value()) {\n            this.namedQueries.add(new NamedQueryMetadataImpl(this.getLocator(), namedQuery));\n        }\n    } else {\n        final NamedQuery namedQuery = this.getClazz().getAnnotation(NamedQuery.class);\n        parsed.add(NamedQuery.class);\n        if (namedQuery != null) {\n            this.namedQueries.add(new NamedQueryMetadataImpl(this.getLocator(), namedQuery));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the named query definitions of the entity.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1003, "method_signature": "void handleNamedQuery(EntityMetadata, Set)"}, "EntityMetadataImpl.handleSecondaryTables": {"callee_method_names": ["EntityMetadata.getSecondaryTables", "EntityMetadata.getSecondaryTables", "SecondaryTables.value", "Set<Class<? extends Annotation>>.add", "SecondaryTables.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleSecondaryTables", "method_implementation": "{\n    if ((metadata != null) && (metadata.getSecondaryTables().size() > 0)) {\n        this.secondaryTables.addAll(metadata.getSecondaryTables());\n    } else {\n        final SecondaryTables secondaryTables = this.getClazz().getAnnotation(SecondaryTables.class);\n        if ((secondaryTables != null) && (secondaryTables.value().length > 0)) {\n            parsed.add(SecondaryTables.class);\n            for (final SecondaryTable secondaryTable : secondaryTables.value()) {\n                this.secondaryTables.add(new SecondaryTableMetadataImpl(this.getLocator(), secondaryTable));\n            }\n        } else {\n            final SecondaryTable secondaryTable = this.getClazz().getAnnotation(SecondaryTable.class);\n            if (secondaryTable != null) {\n                parsed.add(SecondaryTable.class);\n                this.secondaryTables.add(new SecondaryTableMetadataImpl(this.getLocator(), secondaryTable));\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the secondary table definitions of the entity.\n * <p>\n * If metadata provides at least one secondary table definition then the its definitions are added to {@link #secondaryTables}.\n * <p>\n * Else if either {@link SecondaryTables} or {@link SecondaryTable} annotations present, then definition based on the annotation is\n * added to {@link #secondaryTables}.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1004, "method_signature": "void handleSecondaryTables(EntityMetadata, Set)"}, "EntityMetadataImpl.handleSequenceGenerator": {"callee_method_names": ["EntityMetadata.getSequenceGenerator", "EntityMetadata.getSequenceGenerator", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleSequenceGenerator", "method_implementation": "{\n    if ((metadata != null) && (metadata.getSequenceGenerator() != null)) {\n        return metadata.getSequenceGenerator();\n    }\n    final SequenceGenerator annotation = this.getClazz().getAnnotation(SequenceGenerator.class);\n    if (annotation != null) {\n        parsed.add(SequenceGenerator.class);\n        return new SequenceGeneratorMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the sequence generator definition of the entity.\n * <p>\n * If metadata provides a sequence generator then the definition is returned.\n * <p>\n * Then if the {@link SequenceGenerator} annotation present, then definition based on the annotation is returned.\n * <p>\n * Finally null value is returned\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotation parsed\n * @return the sequence generator metadata or null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1005, "method_signature": "SequenceGeneratorMetadata handleSequenceGenerator(EntityMetadata, Set)"}, "EntityMetadataImpl.handleSqlResultSetMappings": {"callee_method_names": ["EntityMetadata.getSqlResultSetMappings", "EntityMetadata.getSqlResultSetMappings", "SqlResultSetMappings.value", "Set<Class<? extends Annotation>>.add", "SqlResultSetMappings.value", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleSqlResultSetMappings", "method_implementation": "{\n    if ((metadata != null) && (metadata.getSqlResultSetMappings() != null)) {\n        this.sqlResultSetMappings.addAll(metadata.getSqlResultSetMappings());\n    }\n    final SqlResultSetMappings sqlResultSetMappings = this.getClazz().getAnnotation(SqlResultSetMappings.class);\n    if ((sqlResultSetMappings != null) && (sqlResultSetMappings.value().length > 0)) {\n        parsed.add(SqlResultSetMappings.class);\n        for (final SqlResultSetMapping sqlResultSetMapping : sqlResultSetMappings.value()) {\n            this.sqlResultSetMappings.add(new SqlResultSetMappingMetadataImpl(this.getLocator(), sqlResultSetMapping));\n        }\n    } else {\n        final SqlResultSetMapping annotation = this.getClazz().getAnnotation(SqlResultSetMapping.class);\n        if (annotation != null) {\n            parsed.add(SqlResultSetMapping.class);\n            this.sqlResultSetMappings.add(new SqlResultSetMappingMetadataImpl(this.getLocator(), annotation));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles Sql ResultSet Mapping for Native queries\n *\n * @param metadata\n * @param parsed\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 1006, "method_signature": "void handleSqlResultSetMappings(EntityMetadata, Set)"}, "EntityMetadataImpl.handleTable": {"callee_method_names": ["EntityMetadata.getTable", "EntityMetadata.getTable", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleTable", "method_implementation": "{\n    if ((metadata != null) && (metadata.getTable() != null)) {\n        return metadata.getTable();\n    }\n    final Table annotation = this.getClazz().getAnnotation(Table.class);\n    if (annotation != null) {\n        parsed.add(Table.class);\n        return new TableMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the table definition of the entity.\n * <p>\n * <p>\n * If metadata provides a table definition then the definition is returned.\n * <p>\n * Then if the {@link Table} annotation present, then definition based on the annotation is returned.\n * <p>\n * Finally null value is returned\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotation parsed\n * @return the table metadata or null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1007, "method_signature": "TableMetadata handleTable(EntityMetadata, Set)"}, "EntityMetadataImpl.handleTableGenerator": {"callee_method_names": ["EntityMetadata.getTableGenerator", "EntityMetadata.getTableGenerator", "Set<Class<? extends Annotation>>.add"], "method_name": "EntityMetadataImpl.handleTableGenerator", "method_implementation": "{\n    if ((metadata != null) && (metadata.getTableGenerator() != null)) {\n        return metadata.getTableGenerator();\n    }\n    final TableGenerator annotation = this.getClazz().getAnnotation(TableGenerator.class);\n    if (annotation != null) {\n        parsed.add(TableGenerator.class);\n        return new TableGeneratorMetadataImpl(this.getLocator(), annotation);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the table generator definition of the entity.\n * <p>\n * If metadata provides a table generator then the definition is returned.\n * <p>\n * Then if the {@link TableGenerator} annotation present, then definition based on the annotation is returned.\n * <p>\n * Finally null value is returned\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotation parsed\n * @return the table generator metadata or null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1008, "method_signature": "TableGeneratorMetadata handleTableGenerator(EntityMetadata, Set)"}, "EntityPath.generateJpqlRestriction": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "EntityPath.generateJpqlRestriction", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.getParentPath().generateJpqlRestriction(query));\n    builder.append(\".\").append(this.pathName);\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 774, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "EntityPath.generateJpqlSelect": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "EntityPath.generateJpqlSelect", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    if ((this.getParentPath() instanceof AbstractFrom) && StringUtils.isNotBlank(this.getParentPath().getAlias())) {\n        builder.append(this.getParentPath().getAlias());\n    } else {\n        builder.append(this.getParentPath().generateJpqlSelect(null, false));\n    }\n    builder.append(\".\").append(this.pathName);\n    if (selected && StringUtils.isNotBlank(this.getAlias())) {\n        builder.append(\" as \").append(this.getAlias());\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 775, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "EntityPath.getColumnAlias": {"callee_method_names": [], "method_name": "EntityPath.getColumnAlias", "method_implementation": "{\n    for (final JoinColumn joinColumn : this.mapping.getForeignKey().getJoinColumns()) {\n        if (joinColumn.getReferencedColumn() == column) {\n            final String columnAlias = this.getParentPath().getColumnAlias(query, joinColumn);\n            if (columnAlias != null) {\n                return columnAlias;\n            }\n            return this.getParentPath().getRootPath().getTableAlias(query, joinColumn.getTable()) + \".\" + joinColumn.getName();\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 776, "method_signature": "String getColumnAlias(BaseQueryImpl, AbstractColumn)"}, "EntityPath.getFetchRoot": {"callee_method_names": [], "method_name": "EntityPath.getFetchRoot", "method_implementation": "{\n    if (this.fetchRoot == null) {\n        this.fetchRoot = (FetchImpl<Z, X>) this.getParentPath().getFetchRoot().join(this.pathName, JoinType.LEFT);\n    }\n    return this.fetchRoot;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 777, "method_signature": "FetchParentImpl<?,X> getFetchRoot()"}, "EntityPath.getMapping": {"callee_method_names": [], "method_name": "EntityPath.getMapping", "method_implementation": "{\n    final AbstractMapping<? super X, C, Y> mapping = (AbstractMapping<? super X, C, Y>) this.entity.getRootMapping().getChild(name);\n    if (mapping == null) {\n        throw this.cannotDereference(name);\n    }\n    return mapping;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 778, "method_signature": "AbstractMapping<? super X,C,Y> getMapping(String)"}, "EntityPath.getSqlRestrictionFragments": {"callee_method_names": ["ForeignKey.getTable", "ForeignKey.getJoinColumns", "List<String>.add", "AbstractColumn.getName", "List<String>.toArray", "List<String>.size"], "method_name": "EntityPath.getSqlRestrictionFragments", "method_implementation": "{\n    if (!this.mapping.isOwner() || (this.mapping.getForeignKey() == null)) {\n        return this.getFetchRoot().getSqlRestrictionFragments(query, MapSelectType.VALUE);\n    }\n    final List<String> restrictions = Lists.newArrayList();\n    final ForeignKey foreignKey = this.mapping.getForeignKey();\n    final String tableAlias = this.getParentPath().getFetchRoot().getTableAlias(query, foreignKey.getTable());\n    for (final AbstractColumn column : foreignKey.getJoinColumns()) {\n        restrictions.add(tableAlias + \".\" + column.getName());\n    }\n    return restrictions.toArray(new String[restrictions.size()]);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 779, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "EntityPath.type": {"callee_method_names": [], "method_name": "EntityPath.type", "method_implementation": "{\n    if (this.entity.getRootType().getInheritanceType() != null) {\n        return new EntityTypeExpression<X>(this, this.entity.getRootType().getDiscriminatorColumn());\n    }\n    return new StaticTypeExpression<X>(this, this.getModel().getBindableJavaType());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 780, "method_signature": "AbstractTypeExpression<X> type()"}, "EntityResultElement.generate": {"callee_method_names": [], "method_name": "EntityResultElement.generate", "method_implementation": "{\n    this.entityClass = this.getAttribute(ElementConstants.ATTR_ENTITY_CLASS, ElementConstants.EMPTY);\n    this.discriminatorColumn = this.getAttribute(ElementConstants.ATTR_DISCRIMINATOR_COLUMN, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1126, "method_signature": "void generate()"}, "EntityResultElement.handleChild": {"callee_method_names": [], "method_name": "EntityResultElement.handleChild", "method_implementation": "{\n    if (child instanceof FieldResultElement) {\n        this.fields.add((FieldResultMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1127, "method_signature": "void handleChild(Element)"}, "EntityTable.addColumn": {"callee_method_names": ["AbstractColumn.isPrimaryKey", "AbstractColumn.getName", "AbstractColumn.getIdType", "JoinColumn.isPrimaryKey", "AbstractColumn.getName"], "method_name": "EntityTable.addColumn", "method_implementation": "{\n    super.addColumn(column);\n    if (column.isPrimaryKey()) {\n        this.pkColumns.put(column.getName(), column);\n        if (column.getIdType() == IdType.IDENTITY) {\n            this.identityColumn = (BasicColumn) column;\n        }\n    } else if (column instanceof JoinColumn) {\n        final JoinColumn joinColumn = (JoinColumn) column;\n        if (joinColumn.isPrimaryKey()) {\n            this.pkColumns.put(column.getName(), joinColumn);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1135, "method_signature": "void addColumn(AbstractColumn)"}, "EntityTable.addIndex": {"callee_method_names": [], "method_name": "EntityTable.addIndex", "method_implementation": "{\n    if (this.indexes.containsKey(name)) {\n        return true;\n    }\n    this.indexes.put(name, columns);\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Adds the index to table.\n *\n * @param name\n *            the name of the index\n * @param columns\n *            the columns\n * @return true if an index with the <code>name</code> already existed, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1136, "method_signature": "boolean addIndex(String, BasicColumn[])"}, "EntityTable.getIdFields": {"callee_method_names": ["HashMap<AbstractColumn, String>.put", "AbstractColumn.getName"], "method_name": "EntityTable.getIdFields", "method_implementation": "{\n    if (this.idColumns != null) {\n        return this.idColumns.value;\n    }\n    synchronized (this) {\n        if (this.idColumns != null) {\n            return this.idColumns.value;\n        }\n        final HashMap<AbstractColumn, String> _idFields = Maps.newHashMap();\n        for (final AbstractColumn column : this.pkColumns.values()) {\n            _idFields.put(column, column.getName());\n        }\n        this.idColumns = new FinalWrapper<HashMap<AbstractColumn, String>>(_idFields);\n    }\n    return this.idColumns.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the id fields of the table.\n *\n * @return the id fields of the table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1137, "method_signature": "HashMap<AbstractColumn,String> getIdFields()"}, "EntityTable.performInsert": {"callee_method_names": ["EntityTypeDescriptor.getDiscriminatorValue", "AbstractColumn.getValue", "AbstractColumn.isLob"], "method_name": "EntityTable.performInsert", "method_implementation": "{\n    // Do not inline, generation of the insert SQL will initialize the insertColumns!\n    final String insertSql = this.getInsertSql(entityType, size);\n    final AbstractColumn[] insertColumns = this.getInsertColumns(entityType, size);\n    // prepare the parameters\n    final Object[] params = new Object[insertColumns.length * size];\n    boolean hasLob = false;\n    for (int i = 0; i < size; i++) {\n        final Object instance = instances[i];\n        for (int j = 0; j < insertColumns.length; j++) {\n            final AbstractColumn column = insertColumns[j];\n            if (column instanceof DiscriminatorColumn) {\n                params[(i * insertColumns.length) + j] = entityType.getDiscriminatorValue();\n            } else {\n                params[(i * insertColumns.length) + j] = column.getValue(connection, instance);\n            }\n            hasLob |= column.isLob();\n        }\n    }\n    new QueryRunner(this.jdbcAdaptor, hasLob).update(connection, insertSql, params);\n    // if there is an identity column, extract the identity and set it back to the instance\n    if (this.identityColumn != null) {\n        final String selectLastIdSql = this.jdbcAdaptor.getSelectLastIdentitySql(this.identityColumn);\n        final Number id = new QueryRunner(this.jdbcAdaptor, false).query(connection, selectLastIdSql, new SingleValueHandler<Number>());\n        this.identityColumn.setValue(instances[0], id);\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs inserts to the table for the managed instance or joins.\n *\n * @param connection\n *            the connection to use\n * @param entityType\n *            the entity type of the instances\n * @param instances\n *            the instances to perform insert for\n * @param size\n *            the size of the batch\n * @throws SQLException\n *             thrown in case of underlying SQLException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1138, "method_signature": "void performInsert(Connection, EntityTypeDescriptor, Object[], int)"}, "EntityTable.performRemove": {"callee_method_ids": [1157], "callee_method_names": ["AbstractColumn.getValue", "QueryRunner.update"], "method_name": "EntityTable.performRemove", "method_implementation": "{\n    final String removeSql = this.getRemoveSql(size);\n    // prepare the parameters\n    final AbstractColumn[] restrictionColumns = this.getRestrictionColumns();\n    final Object[] params = new Object[size * restrictionColumns.length];\n    for (int i = 0; i < size; i++) {\n        final Object instance = instances[i];\n        for (int j = 0; j < restrictionColumns.length; j++) {\n            final AbstractColumn column = restrictionColumns[j];\n            params[(i * restrictionColumns.length) + j] = column.getValue(connection, instance);\n        }\n    }\n    final QueryRunner runner = new QueryRunner(this.jdbcAdaptor, false);\n    if (size != runner.update(connection, removeSql, params)) {\n        throw new OptimisticLockFailedException();\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs removes from the table for the managed instance or joins.\n *\n * @param connection\n *            the connection to use\n * @param instances\n *            the instances to perform remove for\n * @param size\n *            the size of the batch\n * @throws SQLException\n *             thrown in case of underlying SQLException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1139, "method_signature": "void performRemove(Connection, Object[], int)"}, "EntityTable.performUpdate": {"callee_method_ids": [1157], "callee_method_names": ["AbstractColumn.getValue", "AbstractColumn.isLob", "AbstractColumn.isVersion", "AbstractColumn.getValue", "QueryRunner.update"], "method_name": "EntityTable.performUpdate", "method_implementation": "{\n    // Do not inline, generation of the update SQL will initialize the insertColumns!\n    final String updateSql = this.getUpdateSql(type, this.pkColumns);\n    final AbstractColumn[] updateColumns = this.getUpdateColumns(type);\n    final AbstractColumn[] restrictionColumns = this.getRestrictionColumns();\n    boolean hasLob = false;\n    int nextParamNo = 0;\n    // prepare the parameters\n    final Object[] params = new Object[updateColumns.length + restrictionColumns.length];\n    for (final AbstractColumn column : updateColumns) {\n        params[nextParamNo++] = column.getValue(connection, instance);\n        hasLob |= column.isLob();\n    }\n    for (final AbstractColumn column : restrictionColumns) {\n        if (column.isVersion()) {\n            params[nextParamNo++] = oldVersion;\n        } else {\n            params[nextParamNo++] = column.getValue(connection, instance);\n        }\n    }\n    // execute the insert\n    final QueryRunner runner = new QueryRunner(this.jdbcAdaptor, hasLob);\n    if (1 != runner.update(connection, updateSql, params)) {\n        throw new OptimisticLockFailedException();\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs update to the table for the managed instance or joins.\n *\n * @param connection\n *            the connection to use\n * @param type\n *            the entity type of the instance\n * @param instance\n *            the instance to perform update for\n * @param oldVersion\n *            the old version value\n * @throws SQLException\n *             thrown in case of underlying SQLException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1140, "method_signature": "void performUpdate(Connection, EntityTypeDescriptor, Object, Object)"}, "EntityTable.performUpdateWithUpdatability": {"callee_method_ids": [1157], "callee_method_names": ["AbstractColumn.getValue", "AbstractColumn.isLob", "AbstractColumn.isVersion", "AbstractColumn.getValue", "QueryRunner.update"], "method_name": "EntityTable.performUpdateWithUpdatability", "method_implementation": "{\n    // Do not inline, generation of the update SQL will initialize the insertColumns!\n    final String updateSql = this.getUpdateSql(type, this.pkColumns);\n    final AbstractColumn[] updateColumns = this.getUpdateColumns(type);\n    final AbstractColumn[] restrictionColumns = this.getRestrictionColumns();\n    if (updateColumns.length == 0) {\n        return false;\n    }\n    int nextParam = 0;\n    boolean hasLob = false;\n    // prepare the parameters\n    final Object[] params = new Object[updateColumns.length + restrictionColumns.length];\n    for (final AbstractColumn column : updateColumns) {\n        params[nextParam++] = column.getValue(connection, instance);\n        hasLob |= column.isLob();\n    }\n    for (final AbstractColumn column : restrictionColumns) {\n        if (column.isVersion()) {\n            params[nextParam++] = oldVersion;\n        } else {\n            params[nextParam++] = column.getValue(connection, instance);\n        }\n    }\n    // execute the insert\n    final QueryRunner runner = new QueryRunner(this.jdbcAdaptor, hasLob);\n    if (1 != runner.update(connection, updateSql, params)) {\n        throw new OptimisticLockFailedException();\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * Performs update to the table for the managed instance or joins. In addition checks if the table participates in update.\n *\n * @param connection\n *            the connection to use\n * @param type\n *            the entity type of the instance\n * @param instance\n *            the instance to perform update for\n * @param oldVersion\n *            the old version value\n * @return returns true if the table is updatable\n * @throws SQLException\n *             thrown in case of underlying SQLException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1141, "method_signature": "boolean performUpdateWithUpdatability(Connection, EntityTypeDescriptor, Object, Object)"}, "EntityTable.performVersionUpdate": {"callee_method_names": ["AbstractColumn.getValue"], "method_name": "EntityTable.performVersionUpdate", "method_implementation": "{\n    // Do not inline, generation of the update SQL will initialize the insertColumns!\n    final String updateSql = this.getVersionUpdateSql(this.pkColumns);\n    final AbstractColumn[] restrictionColumns = this.getRestrictionColumns();\n    // prepare the parameters\n    final Object[] params = new Object[restrictionColumns.length];\n    params[0] = newVersion;\n    for (int i = 1; i < (restrictionColumns.length - 1); i++) {\n        final AbstractColumn column = restrictionColumns[i];\n        params[i] = column.getValue(connection, instance);\n    }\n    params[params.length - 1] = oldVersion;\n    // execute the update\n    if (1 != new QueryRunner(this.jdbcAdaptor, false).update(connection, updateSql, params)) {\n        throw new OptimisticLockFailedException();\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs version update to the table.\n *\n * @param connection\n *            the connection to use\n * @param instance\n *            the instance to perform version update for\n * @param oldVersion\n *            the old version value\n * @param newVersion\n *            the new version value\n * @throws SQLException\n *             thrown in case of underlying SQLException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1142, "method_signature": "void performVersionUpdate(Connection, Object, Object, Object)"}, "EntityTable.toString": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString"], "method_name": "EntityTable.toString", "method_implementation": "{\n    final String columns = Joiner.on(\", \").join(Collections2.transform(this.getColumnMap().values(), new Function<AbstractColumn, String>() {\n\n        @Override\n        public String apply(AbstractColumn input) {\n            final StringBuffer out = new StringBuffer();\n            out.append(input.isPrimaryKey() ? \"ID [\" : \"COL [\");\n            out.append(\"name=\");\n            out.append(input.getName());\n            out.append(\", type=\");\n            out.append(input.getSqlType());\n            out.append(\"]\");\n            return out.toString();\n        }\n    }));\n    return //\n    \"Table [owner=\" + this.entity.getName() + \", name=\" + //\n    this.getQName() + \", columns=[\" + columns + \"]]\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1143, "method_signature": "String toString()"}, "EntityTransactionImpl.assertValid": {"callee_method_names": [], "method_name": "EntityTransactionImpl.assertValid", "method_implementation": "{\n    if (this.rollbackOnly) {\n        throw new PersistenceException(\"Transaction is set to rollback only\");\n    }\n    this.em.isValid(this);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 499, "method_signature": "void assertValid()"}, "EntityTransactionImpl.begin": {"callee_method_names": [], "method_name": "EntityTransactionImpl.begin", "method_implementation": "{\n    this.assertValid();\n    try {\n        if (!this.active) {\n            this.connection.setAutoCommit(false);\n        }\n    } catch (final SQLException e) {\n        throw new PersistenceException(\"Unable to begin transaction\", e);\n    }\n    this.active = true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 500, "method_signature": "void begin()"}, "EntityTransactionImpl.commit": {"callee_method_names": [], "method_name": "EntityTransactionImpl.commit", "method_implementation": "{\n    if (!this.active) {\n        throw new TransactionRequiredException(\"Transaction has not been started\");\n    }\n    this.assertValid();\n    if (this.rollbackOnly) {\n        throw new TransactionRequiredException(\"Transaction is marked as rollback only\");\n    }\n    try {\n        this.em.flush();\n        this.connection.commit();\n        this.connection.setAutoCommit(true);\n        this.em.clearTransaction();\n        this.active = false;\n    } catch (final SQLException e) {\n        throw new PersistenceException(\"Unable to commit transaction\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 501, "method_signature": "void commit()"}, "EntityTransactionImpl.rollback": {"callee_method_names": [], "method_name": "EntityTransactionImpl.rollback", "method_implementation": "{\n    this.assertValid();\n    try {\n        this.connection.rollback();\n        this.em.clearTransaction();\n    } catch (final SQLException e) {\n        throw new PersistenceException(\"Unable to rollback transaction\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 502, "method_signature": "void rollback()"}, "EntityTypeExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "EntityTypeExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final String tableAlias = this.getPath().getRootPath().getTableAlias(query, this.discriminatorColumn.getTable());\n    return new String[] { tableAlias + \".\" + this.discriminatorColumn.getName() };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 575, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "EntityTypeExpression.handle": {"callee_method_names": ["SessionImpl.getEntityManager"], "method_name": "EntityTypeExpression.handle", "method_implementation": "{\n    if (this.entity == null) {\n        this.entity = session.getEntityManager().getMetamodel().entity(this.getPath().getJavaType()).getRootType();\n    }\n    final String discriminatorValue = this.handle(row).toString();\n    return (Class<? extends T>) this.entity.getChildType(discriminatorValue).getJavaType();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 576, "method_signature": "Class<? extends T> handle(QueryImpl, SessionImpl, ResultSet)"}, "EntityTypeImpl.addAttribute": {"callee_method_names": ["AttributeImpl<? super X,?>.getPersistentAttributeType", "AttributeImpl<? super X,?>.getPersistentAttributeType", "AssociatedSingularAttribute<? super X, ?>.getMapsId", "AssociatedSingularAttribute<? super X, ?>.getMapsId"], "method_name": "EntityTypeImpl.addAttribute", "method_implementation": "{\n    super.addAttribute(attribute);\n    if ((attribute.getPersistentAttributeType() == PersistentAttributeType.MANY_TO_ONE) || (attribute.getPersistentAttributeType() == PersistentAttributeType.ONE_TO_ONE)) {\n        final AssociatedSingularAttribute<? super X, ?> singularAttribute = (AssociatedSingularAttribute<? super X, ?>) attribute;\n        if (StringUtils.isNotBlank(singularAttribute.getMapsId())) {\n            this.idMap.put(singularAttribute.getMapsId(), singularAttribute);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 227, "method_signature": "void addAttribute(AttributeImpl)"}, "EntityTypeImpl.extendz": {"callee_method_names": ["IdentifiableTypeImpl<? super X>.getSupertype"], "method_name": "EntityTypeImpl.extendz", "method_implementation": "{\n    IdentifiableTypeImpl<? super X> supertype = this;\n    do {\n        if (supertype == parent) {\n            return true;\n        }\n        supertype = supertype.getSupertype();\n    } while (supertype != null);\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Returns if this entity extends the parent entity.\n *\n * @param parent\n *            the parent to test\n * @return true if this entity extends the parent entity, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 228, "method_signature": "boolean extendz(EntityTypeImpl)"}, "EntityTypeImpl.getAllTables": {"callee_method_names": ["Map<String, EntityTable>.size", "Map<String, EntityTable>.values", "Object.getName", "Object.getName"], "method_name": "EntityTypeImpl.getAllTables", "method_implementation": "{\n    FinalWrapper<EntityTable[]> wrapper = this.allTables;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.allTables == null) {\n                final Map<String, EntityTable> _tableMap = Maps.newHashMap();\n                this.getAllTables(_tableMap);\n                final EntityTable[] _tables = new EntityTable[_tableMap.size()];\n                _tableMap.values().toArray(_tables);\n                Arrays.sort(_tables, new Comparator<EntityTable>() {\n\n                    @Override\n                    public int compare(EntityTable o1, EntityTable o2) {\n                        if ((o1 instanceof SecondaryTable) && !(o2 instanceof SecondaryTable)) {\n                            return 1;\n                        }\n                        if ((o2 instanceof SecondaryTable) && !(o1 instanceof SecondaryTable)) {\n                            return -1;\n                        }\n                        return o1.getName().compareTo(o2.getName());\n                    }\n                });\n                this.allTables = new FinalWrapper<EntityTable[]>(_tables);\n            }\n            wrapper = this.allTables;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns all the tables in the inheritance chain.\n *\n * @return the array of tables\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 229, "method_signature": "EntityTable[] getAllTables()"}, "EntityTypeImpl.getAssociationOverride": {"callee_method_names": [], "method_name": "EntityTypeImpl.getAssociationOverride", "method_implementation": "{\n    for (final AssociationMetadata override : this.metadata.getAssociationOverrides()) {\n        if (override.getName().equals(path)) {\n            return override;\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns if attribute with the <code>path</code> is overridden by the entity.\n *\n * @param path\n *            the path of the attribute\n * @return the association metadata or <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 230, "method_signature": "AssociationMetadata getAssociationOverride(String)"}, "EntityTypeImpl.getAssociations": {"callee_method_names": ["List<AssociationMappingImpl<?, ?, ?>>.size", "List<AssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociations", "method_implementation": "{\n    FinalWrapper<AssociationMappingImpl<?, ?, ?>[]> wrapper = this.associations;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associations == null) {\n                final List<AssociationMappingImpl<?, ?, ?>> _associations = Lists.newArrayList();\n                this.entityMapping.addAssociations(_associations);\n                final AssociationMappingImpl<?, ?, ?>[] __associatedAttributes = new AssociationMappingImpl[_associations.size()];\n                _associations.toArray(__associatedAttributes);\n                this.associations = new FinalWrapper<AssociationMappingImpl<?, ?, ?>[]>(__associatedAttributes);\n            }\n            wrapper = this.associations;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the associations of the type.\n *\n * @return the associations of the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 231, "method_signature": "AssociationMappingImpl<?,?,?>[] getAssociations()"}, "EntityTypeImpl.getAssociationsDetachable": {"callee_method_names": ["AssociatedSingularAttribute<? super X, ?>.cascadesDetach", "List<AssociationMappingImpl<?, ?, ?>>.add", "List<AssociationMappingImpl<?, ?, ?>>.size", "List<AssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsDetachable", "method_implementation": "{\n    FinalWrapper<AssociationMappingImpl<?, ?, ?>[]> wrapper = this.associationsDetachable;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsDetachable == null) {\n                final List<AssociationMappingImpl<?, ?, ?>> _associationsDetachable = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> association : this.getAssociations()) {\n                    if (association.cascadesDetach()) {\n                        _associationsDetachable.add(association);\n                    }\n                }\n                final AssociationMappingImpl<?, ?, ?>[] __associationsDetachable = new AssociationMappingImpl[_associationsDetachable.size()];\n                _associationsDetachable.toArray(__associationsDetachable);\n                this.associationsDetachable = new FinalWrapper<AssociationMappingImpl<?, ?, ?>[]>(__associationsDetachable);\n            }\n            wrapper = this.associationsDetachable;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the associated attributes that are detachable by the type.\n *\n * @return the associated attributes that are detachable by the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 232, "method_signature": "AssociationMappingImpl<?,?,?>[] getAssociationsDetachable()"}, "EntityTypeImpl.getAssociationsJoined": {"callee_method_names": ["AssociatedSingularAttribute<? super X, ?>.getJoinTable", "List<AssociationMappingImpl<?, ?, ?>>.add", "List<AssociationMappingImpl<?, ?, ?>>.size", "List<AssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsJoined", "method_implementation": "{\n    final FinalWrapper<AssociationMappingImpl<?, ?, ?>[]> wrapper = this.associationsJoined;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsJoined == null) {\n                final List<AssociationMappingImpl<?, ?, ?>> joinedAssociations = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> association : this.getAssociations()) {\n                    if (association.getJoinTable() != null) {\n                        joinedAssociations.add(association);\n                    }\n                }\n                final AssociationMappingImpl<?, ?, ?>[] __joinedAssociations = new AssociationMappingImpl[joinedAssociations.size()];\n                joinedAssociations.toArray(__joinedAssociations);\n                this.associationsJoined = new FinalWrapper<AssociationMappingImpl<?, ?, ?>[]>(__joinedAssociations);\n            }\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the associated attributes that are joined.\n *\n * @return the associated attributes that are joined\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 233, "method_signature": "AssociationMappingImpl<?,?,?>[] getAssociationsJoined()"}, "EntityTypeImpl.getAssociationsNotPersistable": {"callee_method_names": ["List<AssociationMappingImpl<?, ?, ?>>.add", "List<AssociationMappingImpl<?, ?, ?>>.size", "List<AssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsNotPersistable", "method_implementation": "{\n    FinalWrapper<AssociationMappingImpl<?, ?, ?>[]> wrapper = this.associationsNotPersistable;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsNotPersistable == null) {\n                final List<AssociationMappingImpl<?, ?, ?>> _associationsNotPersistable = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> mapping : this.getAssociations()) {\n                    // skip persistable associations\n                    if (mapping.cascadesPersist()) {\n                        continue;\n                    }\n                    _associationsNotPersistable.add(mapping);\n                }\n                final AssociationMappingImpl<?, ?, ?>[] __associationsNotPersistable = new AssociationMappingImpl[_associationsNotPersistable.size()];\n                _associationsNotPersistable.toArray(__associationsNotPersistable);\n                this.associationsNotPersistable = new FinalWrapper<AssociationMappingImpl<?, ?, ?>[]>(__associationsNotPersistable);\n            }\n            wrapper = this.associationsNotPersistable;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the plural associations that are not persistable.\n *\n * @return the plural associations that are not persistable\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 234, "method_signature": "AssociationMappingImpl<?,?,?>[] getAssociationsNotPersistable()"}, "EntityTypeImpl.getAssociationsPersistable": {"callee_method_names": ["AssociatedSingularAttribute<? super X, ?>.cascadesPersist", "List<AssociationMappingImpl<?, ?, ?>>.add", "List<AssociationMappingImpl<?, ?, ?>>.size", "List<AssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsPersistable", "method_implementation": "{\n    FinalWrapper<AssociationMappingImpl<?, ?, ?>[]> wrapper = this.associationsPersistable;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsPersistable == null) {\n                final List<AssociationMappingImpl<?, ?, ?>> _associationsPersistable = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> association : this.getAssociations()) {\n                    if (association.cascadesPersist()) {\n                        _associationsPersistable.add(association);\n                    }\n                }\n                final AssociationMappingImpl<?, ?, ?>[] __associationsPersistable = new AssociationMappingImpl[_associationsPersistable.size()];\n                _associationsPersistable.toArray(__associationsPersistable);\n                this.associationsPersistable = new FinalWrapper<AssociationMappingImpl<?, ?, ?>[]>(__associationsPersistable);\n            }\n            wrapper = this.associationsPersistable;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the associated attributes that are persistable by the type.\n *\n * @return the associated attributes that are persistable by the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 235, "method_signature": "AssociationMappingImpl<?,?,?>[] getAssociationsPersistable()"}, "EntityTypeImpl.getAssociationsPlural": {"callee_method_names": ["List<PluralAssociationMappingImpl<?, ?, ?>>.add", "List<PluralAssociationMappingImpl<?, ?, ?>>.size", "List<PluralAssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsPlural", "method_implementation": "{\n    FinalWrapper<PluralAssociationMappingImpl<?, ?, ?>[]> wrapper = this.associationsPlural;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsPlural == null) {\n                final List<PluralAssociationMappingImpl<?, ?, ?>> _associationsPlural = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> mapping : this.getAssociations()) {\n                    if (mapping instanceof PluralAssociationMappingImpl) {\n                        _associationsPlural.add((PluralAssociationMappingImpl<?, ?, ?>) mapping);\n                    }\n                }\n                final PluralAssociationMappingImpl<?, ?, ?>[] __associationsPlural = new PluralAssociationMappingImpl[_associationsPlural.size()];\n                _associationsPlural.toArray(__associationsPlural);\n                this.associationsPlural = new FinalWrapper<PluralAssociationMappingImpl<?, ?, ?>[]>(__associationsPlural);\n            }\n            wrapper = this.associationsPlural;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the plural associations.\n *\n * @return the plural associations\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 236, "method_signature": "PluralAssociationMappingImpl<?,?,?>[] getAssociationsPlural()"}, "EntityTypeImpl.getAssociationsRemovable": {"callee_method_names": ["AssociatedSingularAttribute<? super X, ?>.cascadesRemove", "AssociatedSingularAttribute<? super X, ?>.removesOrphans", "List<AssociationMappingImpl<?, ?, ?>>.add", "List<AssociationMappingImpl<?, ?, ?>>.size", "List<AssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsRemovable", "method_implementation": "{\n    FinalWrapper<AssociationMappingImpl<?, ?, ?>[]> wrapper = this.associationsRemovable;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsRemovable == null) {\n                final List<AssociationMappingImpl<?, ?, ?>> _associationsRemovable = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> association : this.getAssociations()) {\n                    if (association.cascadesRemove() || association.removesOrphans()) {\n                        _associationsRemovable.add(association);\n                    }\n                }\n                final AssociationMappingImpl<?, ?, ?>[] __associationsRemovable = new AssociationMappingImpl[_associationsRemovable.size()];\n                _associationsRemovable.toArray(__associationsRemovable);\n                this.associationsRemovable = new FinalWrapper<AssociationMappingImpl<?, ?, ?>[]>(__associationsRemovable);\n            }\n            wrapper = this.associationsRemovable;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the associated mappings that are removable by the type.\n *\n * @return the associated mappings that are removable by the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 237, "method_signature": "AssociationMappingImpl<?,?,?>[] getAssociationsRemovable()"}, "EntityTypeImpl.getAssociationsSingular": {"callee_method_names": ["List<SingularAssociationMappingImpl<?, ?>>.add", "List<SingularAssociationMappingImpl<?, ?>>.size", "List<SingularAssociationMappingImpl<?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsSingular", "method_implementation": "{\n    FinalWrapper<SingularAssociationMappingImpl<?, ?>[]> wrapper = this.associationsSingular;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsSingular == null) {\n                final List<SingularAssociationMappingImpl<?, ?>> _associationsSingular = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> association : this.getAssociations()) {\n                    if (association instanceof SingularAssociationMappingImpl) {\n                        _associationsSingular.add((SingularAssociationMappingImpl<?, ?>) association);\n                    }\n                }\n                final SingularAssociationMappingImpl<?, ?>[] __associationsSingular = new SingularAssociationMappingImpl[_associationsSingular.size()];\n                _associationsSingular.toArray(__associationsSingular);\n                this.associationsSingular = new FinalWrapper<SingularAssociationMappingImpl<?, ?>[]>(__associationsSingular);\n            }\n            wrapper = this.associationsSingular;\n        }\n        ;\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the singular associated mappings.\n *\n * @return the singular associated mappings\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 238, "method_signature": "SingularAssociationMappingImpl<?,?>[] getAssociationsSingular()"}, "EntityTypeImpl.getAssociationsSingularOwnerLazy": {"callee_method_names": ["SingularAssociationMappingImpl<?, ?>.isOwner", "SingularAssociationMappingImpl<?, ?>.isEager", "List<SingularAssociationMappingImpl<?, ?>>.add", "List<SingularAssociationMappingImpl<?, ?>>.size", "List<SingularAssociationMappingImpl<?, ?>>.toArray"], "method_name": "EntityTypeImpl.getAssociationsSingularOwnerLazy", "method_implementation": "{\n    FinalWrapper<SingularAssociationMappingImpl<?, ?>[]> wrapper = this.associationsSingularLazy;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.associationsSingularLazy == null) {\n                final List<SingularAssociationMappingImpl<?, ?>> _associationsSingularLazy = Lists.newArrayList();\n                for (final AssociationMappingImpl<?, ?, ?> mapping : this.getAssociations()) {\n                    if (mapping instanceof SingularAssociationMappingImpl) {\n                        final SingularAssociationMappingImpl<?, ?> singularMapping = (SingularAssociationMappingImpl<?, ?>) mapping;\n                        if (singularMapping.isOwner() && !singularMapping.isEager()) {\n                            _associationsSingularLazy.add(singularMapping);\n                        }\n                    }\n                }\n                final SingularAssociationMappingImpl<?, ?>[] __associationsSingularLazy = new SingularAssociationMappingImpl[_associationsSingularLazy.size()];\n                _associationsSingularLazy.toArray(__associationsSingularLazy);\n                this.associationsSingularLazy = new FinalWrapper<SingularAssociationMappingImpl<?, ?>[]>(__associationsSingularLazy);\n            }\n            wrapper = this.associationsSingularLazy;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the array of singular owner lazy association of the type.\n *\n * @return the array of singular owner lazy associations of the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 239, "method_signature": "SingularAssociationMappingImpl<?,?>[] getAssociationsSingularOwnerLazy()"}, "EntityTypeImpl.getAttributeOverride": {"callee_method_names": [], "method_name": "EntityTypeImpl.getAttributeOverride", "method_implementation": "{\n    for (final AttributeOverrideMetadata override : this.metadata.getAttributeOverrides()) {\n        if (override.getName().equals(path)) {\n            return override.getColumn();\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns if attribute with the <code>path</code> is overridden by the entity.\n *\n * @param path\n *            the path of the attribute\n * @return the column metadata or <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 240, "method_signature": "ColumnMetadata getAttributeOverride(String)"}, "EntityTypeImpl.getBasicMappings": {"callee_method_names": ["List<BasicMappingImpl<?, ?>>.size", "List<BasicMappingImpl<?, ?>>.toArray"], "method_name": "EntityTypeImpl.getBasicMappings", "method_implementation": "{\n    FinalWrapper<BasicMappingImpl<?, ?>[]> wrapper = this.basicMappingImpls;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.basicMappingImpls == null) {\n                final List<BasicMappingImpl<?, ?>> _basicMappings = Lists.newArrayList();\n                this.entityMapping.addBasicMappings(_basicMappings);\n                final BasicMappingImpl<?, ?>[] __basicMappings = new BasicMappingImpl[_basicMappings.size()];\n                _basicMappings.toArray(__basicMappings);\n                this.basicMappingImpls = new FinalWrapper<BasicMappingImpl<?, ?>[]>(__basicMappings);\n            }\n            wrapper = this.basicMappingImpls;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the basic mappings of the type.\n *\n * @return the basic mappings of the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 241, "method_signature": "BasicMappingImpl<?,?>[] getBasicMappings()"}, "EntityTypeImpl.getChildType": {"callee_method_names": ["String.equals"], "method_name": "EntityTypeImpl.getChildType", "method_implementation": "{\n    if (discriminatorValue.equals(this.discriminatorValue)) {\n        return this;\n    }\n    return this.children.get(discriminatorValue);\n}", "repo_id": "1", "comment": "/**\n * Returns the child based on the <code>discriminatorValue</code> value.\n *\n * @param discriminatorValue\n *            the discriminator value of the child\n * @return the child type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 242, "method_signature": "EntityTypeImpl<? extends X> getChildType(String)"}, "EntityTypeImpl.getId": {"callee_method_names": ["MutableBoolean.setValue", "MutableBoolean.booleanValue"], "method_name": "EntityTypeImpl.getId", "method_implementation": "{\n    Object id;\n    final MutableBoolean allNull = new MutableBoolean(true);\n    if (this.hasSingleIdAttribute()) {\n        id = this.getIdImpl(session, row, idFields, this.getIdMapping(), allNull);\n    } else {\n        // create the id class\n        id = this.newCompositeId();\n        for (final Pair<SingularMapping<?, ?>, AbstractAccessor> pair : this.getIdMappings()) {\n            final SingularMapping<?, ?> child = pair.getFirst();\n            final Object childId = this.getIdImpl(session, row, idFields, child, allNull);\n            if (childId != null) {\n                allNull.setValue(false);\n            }\n            pair.getSecond().set(id, childId);\n        }\n    }\n    if (allNull.booleanValue()) {\n        return null;\n    }\n    return new ManagedId<X>(id, this);\n}", "repo_id": "1", "comment": "/**\n * Returns the id of the entity from the resultset row.\n *\n * @param session\n *            the session\n * @param row\n *            the row\n * @param idFields\n *            the id fields\n * @return the managedId or null\n * @throws SQLException\n *             if an SQL error occurrs\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 244, "method_signature": "ManagedId<X> getId(SessionImpl, ResultSet, HashMap)"}, "EntityTypeImpl.getIdMapping": {"callee_method_names": [], "method_name": "EntityTypeImpl.getIdMapping", "method_implementation": "{\n    if (this.idMapping != null) {\n        return this.idMapping;\n    }\n    synchronized (this) {\n        if (this.idMapping != null) {\n            return this.idMapping;\n        }\n        for (final Mapping<? super X, ?, ?> mapping : this.entityMapping.getChildren()) {\n            if ((mapping instanceof SingularMappingEx) && ((SingularMappingEx<? super X, ?>) mapping).getAttribute().isId()) {\n                this.idMapping = (SingularMappingEx<? super X, ?>) mapping;\n                return this.idMapping;\n            }\n        }\n        // impossible\n        throw new NullPointerException();\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the single id mapping.\n *\n * @return the single id mapping\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 245, "method_signature": "SingularMappingEx<? super X,?> getIdMapping()"}, "EntityTypeImpl.getIdMappings": {"callee_method_names": ["EntityTypeImpl<?>.hasSingleIdAttribute", "EntityTypeImpl<?>.getIdType", "EntityTypeImpl<?>.getIdClass", "Field.getType", "List<Pair<SingularMapping<?, ?>, AbstractAccessor>>.add", "List<Pair<SingularMapping<?, ?>, AbstractAccessor>>.size", "List<Pair<SingularMapping<?, ?>, AbstractAccessor>>.toArray"], "method_name": "EntityTypeImpl.getIdMappings", "method_implementation": "{\n    if (this.idMappings != null) {\n        return this.idMappings;\n    }\n    // populate the id attributes with the inheritance\n    synchronized (this) {\n        if (this.idMappings != null) {\n            return this.idMappings;\n        }\n        final List<Pair<SingularMapping<?, ?>, AbstractAccessor>> _idMappings = Lists.newArrayList();\n        for (final Mapping<? super X, ?, ?> mapping : this.entityMapping.getChildren()) {\n            // only interested in id mappings\n            if (!(mapping instanceof SingularMappingEx) || !((SingularMappingEx<? super X, ?>) mapping).getAttribute().isId()) {\n                continue;\n            }\n            // must have a corresponding field\n            Field field;\n            try {\n                field = this.getIdClass().getDeclaredField(mapping.getName());\n            } catch (final Exception e) {\n                throw new MappingException(\"Attribute not found: \" + this.getIdClass().getName() + \".\" + mapping.getName(), mapping.getLocator());\n            }\n            final Class<?> javaType;\n            if (mapping instanceof SingularAssociationMappingImpl) {\n                final EntityTypeImpl<?> type = ((SingularAssociationMappingImpl<? super X, ?>) mapping).getType();\n                if (type.hasSingleIdAttribute()) {\n                    javaType = type.getIdType().getJavaType();\n                } else {\n                    javaType = type.getIdClass();\n                }\n            } else {\n                javaType = mapping.getJavaType();\n            }\n            if (field.getType() != javaType) {\n                throw new MappingException(\"Attribute types mismatch: \" + field + \", \" + mapping.getJavaType(), mapping.getLocator());\n            }\n            final SingularMappingEx<? super X, ?> singularMapping = (SingularMappingEx<? super X, ?>) mapping;\n            final AbstractAccessor accessor = ReflectHelper.getAccessor(field);\n            _idMappings.add(new Pair<SingularMapping<?, ?>, AbstractAccessor>(singularMapping, accessor));\n        }\n        final Pair<SingularMapping<?, ?>, AbstractAccessor>[] idMappings0 = new Pair[_idMappings.size()];\n        _idMappings.toArray(idMappings0);\n        this.idMappings = idMappings0;\n    }\n    return this.idMappings;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 246, "method_signature": "Pair<SingularMapping<?,?>,AbstractAccessor>[] getIdMappings()"}, "EntityTypeImpl.getManagedInstance": {"callee_method_names": [], "method_name": "EntityTypeImpl.getManagedInstance", "method_implementation": "{\n    if (instance == null) {\n        throw new NullPointerException();\n    }\n    return new ManagedInstance<X>(this, session, instance);\n}", "repo_id": "1", "comment": "/**\n * Returns the managed instance for the instance.\n *\n * @param instance\n *            the instance to create managed instance for\n * @param session\n *            the session\n * @return managed id for the instance\n * @throws NullPointerException\n *             thrown if the instance is null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 247, "method_signature": "ManagedInstance<X> getManagedInstance(SessionImpl, X)"}, "EntityTypeImpl.getManagedInstanceById": {"callee_method_names": ["ManagedId<X>.getId"], "method_name": "EntityTypeImpl.getManagedInstanceById", "method_implementation": "{\n    try {\n        final X instance = (X) this.constructor.newInstance(new Object[] { this.getJavaType(), session, id.getId(), !lazy });\n        final ManagedInstance<X> managedInstance = new ManagedInstance<X>(this, session, instance, id);\n        ((EnhancedInstance) instance).__enhanced__$$__setManagedInstance(managedInstance);\n        return managedInstance;\n    } catch (final Exception e) {\n        throw new PersistenceException(\"Cannot create instance \" + id, e);\n    }\n    // not possible\n}", "repo_id": "1", "comment": "/**\n * Creates a new managed instance with the id.\n *\n * @param session\n *            the session\n * @param id\n *            the primary key\n * @param lazy\n *            if the instance is lazy\n * @return the managed instance created\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 248, "method_signature": "ManagedInstance<X> getManagedInstanceById(SessionImpl, ManagedId, boolean)"}, "EntityTypeImpl.getMappedId": {"callee_method_names": ["AssociatedSingularAttribute<? super X, ?>.get", "Object.getClass", "EntityTypeImpl<?>.hasSingleIdAttribute", "EntityTypeImpl<?>.getIdMapping"], "method_name": "EntityTypeImpl.getMappedId", "method_implementation": "{\n    final AssociatedSingularAttribute<? super X, ?> attribute = this.idMap.get(name);\n    if (attribute == null) {\n        return null;\n    }\n    final Object mappedEntity = attribute.get(instance);\n    if (mappedEntity == null) {\n        return null;\n    }\n    final EntityTypeImpl<?> entity = this.getMetamodel().entity(mappedEntity.getClass());\n    if (entity.hasSingleIdAttribute()) {\n        return entity.getIdMapping().get(mappedEntity);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Returns the mapped id.\n *\n * @param name\n *            thename of the id field\n * @param instance\n *            the instance\n * @return the id\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 249, "method_signature": "Object getMappedId(String, Object)"}, "EntityTypeImpl.getMappingsJoined": {"callee_method_names": ["List<JoinedMapping<?, ?, ?>>.size", "List<JoinedMapping<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getMappingsJoined", "method_implementation": "{\n    FinalWrapper<JoinedMapping<?, ?, ?>[]> wrapper = this.mappingsJoined;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.mappingsJoined == null) {\n                final List<JoinedMapping<?, ?, ?>> _mappingsJoined = Lists.newArrayList();\n                this.entityMapping.addJoinedMappings(_mappingsJoined);\n                final JoinedMapping<?, ?, ?>[] __mappingsJoined = new JoinedMapping[_mappingsJoined.size()];\n                _mappingsJoined.toArray(__mappingsJoined);\n                this.mappingsJoined = new FinalWrapper<JoinedMapping<?, ?, ?>[]>(__mappingsJoined);\n            }\n            wrapper = this.mappingsJoined;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Retuns the element collection mappings.\n *\n * @return the element collection mappings\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 250, "method_signature": "JoinedMapping<?,?,?>[] getMappingsJoined()"}, "EntityTypeImpl.getMappingsPlural": {"callee_method_names": ["List<PluralMappingEx<?, ?, ?>>.size", "List<PluralMappingEx<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getMappingsPlural", "method_implementation": "{\n    FinalWrapper<PluralMappingEx<?, ?, ?>[]> wrapper = this.mappingsPlural;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.mappingsPlural == null) {\n                final List<PluralMappingEx<?, ?, ?>> _mappingsPlural = Lists.newArrayList();\n                this.entityMapping.addPluralMappings(_mappingsPlural);\n                final PluralMappingEx<?, ?, ?>[] __mappingsPlural = new PluralMappingEx[_mappingsPlural.size()];\n                _mappingsPlural.toArray(__mappingsPlural);\n                this.mappingsPlural = new FinalWrapper<PluralMappingEx<?, ?, ?>[]>(__mappingsPlural);\n            }\n            wrapper = this.mappingsPlural;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Retuns the element collection mappings.\n *\n * @return the element collection mappings\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 251, "method_signature": "PluralMappingEx<?,?,?>[] getMappingsPlural()"}, "EntityTypeImpl.getMappingsPluralSorted": {"callee_method_names": ["List<PluralMappingEx<?, ?, ?>>.add", "List<PluralMappingEx<?, ?, ?>>.size", "List<PluralMappingEx<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getMappingsPluralSorted", "method_implementation": "{\n    FinalWrapper<PluralMappingEx<?, ?, ?>[]> wrapper = this.mappingsPluralSorted;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.mappingsPluralSorted == null) {\n                final List<PluralMappingEx<?, ?, ?>> _mappingsPluralSorted = Lists.newArrayList();\n                for (final PluralMappingEx<?, ?, ?> mapping : this.getMappingsPlural()) {\n                    if (mapping.getOrderBy() != null) {\n                        _mappingsPluralSorted.add(mapping);\n                    }\n                }\n                final PluralMappingEx<?, ?, ?>[] __mappingsPluralSorted = new PluralMappingEx[_mappingsPluralSorted.size()];\n                _mappingsPluralSorted.toArray(__mappingsPluralSorted);\n                this.mappingsPluralSorted = new FinalWrapper<PluralMappingEx<?, ?, ?>[]>(__mappingsPluralSorted);\n            }\n            wrapper = this.mappingsPluralSorted;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the sorted plural associations.\n *\n * @return the sorted plural associations\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 252, "method_signature": "PluralMappingEx<?,?,?>[] getMappingsPluralSorted()"}, "EntityTypeImpl.getMappingsSingular": {"callee_method_names": ["List<AbstractMapping<?, ?, ?>>.size", "List<AbstractMapping<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.getMappingsSingular", "method_implementation": "{\n    FinalWrapper<AbstractMapping<?, ?, ?>[]> wrapper = this.singularMappings;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.singularMappings == null) {\n                final List<AbstractMapping<?, ?, ?>> _singularMappings = Lists.newArrayList();\n                this.entityMapping.addSingularMappings(_singularMappings);\n                final AbstractMapping<?, ?, ?>[] __singularMappings = new AbstractMapping[_singularMappings.size()];\n                _singularMappings.toArray(__singularMappings);\n                this.singularMappings = new FinalWrapper<AbstractMapping<?, ?, ?>[]>(__singularMappings);\n            }\n            wrapper = this.singularMappings;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the singular mappings.\n *\n * @return the singular mappings\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 253, "method_signature": "AbstractMapping<?,?,?>[] getMappingsSingular()"}, "EntityTypeImpl.getParent": {"callee_method_names": [], "method_name": "EntityTypeImpl.getParent", "method_implementation": "{\n    if (this.isRoot()) {\n        return null;\n    }\n    return (EntityTypeImpl<? super X>) this.getSupertype();\n}", "repo_id": "1", "comment": "/**\n * Returns the parent of the entity.\n *\n * @return the parent entity or <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 254, "method_signature": "EntityTypeImpl<? super X> getParent()"}, "EntityTypeImpl.getRootType": {"callee_method_names": ["EntityTypeImpl<? super X>.getSupertype", "EntityTypeImpl<? super X>.getSupertype"], "method_name": "EntityTypeImpl.getRootType", "method_implementation": "{\n    if (this.rootType != null) {\n        return this.rootType;\n    }\n    EntityTypeImpl<? super X> supertype = this;\n    while (supertype.getSupertype() instanceof EntityTypeImpl) {\n        supertype = (EntityTypeImpl<? super X>) supertype.getSupertype();\n    }\n    this.rootType = supertype;\n    return this.rootType;\n}", "repo_id": "1", "comment": "/**\n * Returns the root type of the hierarchy.\n *\n * @return the root type of the hierarchy\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 255, "method_signature": "EntityTypeImpl<? super X> getRootType()"}, "EntityTypeImpl.getTable": {"callee_method_names": [], "method_name": "EntityTypeImpl.getTable", "method_implementation": "{\n    if (StringUtils.isBlank(tableName)) {\n        return this.primaryTable;\n    }\n    return this.tableMap.get(tableName);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 256, "method_signature": "AbstractTable getTable(String)"}, "EntityTypeImpl.getTables": {"callee_method_names": ["Object.getName", "Object.getName"], "method_name": "EntityTypeImpl.getTables", "method_implementation": "{\n    FinalWrapper<EntityTable[]> wrapper = this.tables;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.tables == null) {\n                final EntityTable[] _tables = new EntityTable[this.tableMap.size()];\n                this.tableMap.values().toArray(_tables);\n                Arrays.sort(_tables, new Comparator<EntityTable>() {\n\n                    @Override\n                    public int compare(EntityTable o1, EntityTable o2) {\n                        if ((o1 instanceof SecondaryTable) && !(o2 instanceof SecondaryTable)) {\n                            return 1;\n                        }\n                        if ((o2 instanceof SecondaryTable) && !(o1 instanceof SecondaryTable)) {\n                            return -1;\n                        }\n                        return o1.getName().compareTo(o2.getName());\n                    }\n                });\n                this.tables = new FinalWrapper<EntityTable[]>(_tables);\n            }\n            wrapper = this.tables;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the tables of the type, starting from the top of the hierarchy.\n *\n * @return the tables of the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 257, "method_signature": "EntityTable[] getTables()"}, "EntityTypeImpl.initCustomIndexes": {"callee_method_ids": [1136], "callee_method_names": ["int.getTable", "int.getTable", "int.getName", "int.getLocator", "int.getColumnNames", "int.getName", "int.getLocator", "List<BasicColumn>.add", "EntityTable.addIndex", "int.getName", "List<BasicColumn>.toArray", "List<BasicColumn>.size"], "method_name": "EntityTypeImpl.initCustomIndexes", "method_implementation": "{\n    for (final IndexMetadata index : this.indexes) {\n        final EntityTable table = StringUtils.isNotBlank(index.getTable()) ? this.tableMap.get(index.getTable()) : this.primaryTable;\n        if (table == null) {\n            throw new MappingException(\"Cannot locate table for index \" + index.getName(), index.getLocator());\n        }\n        final List<BasicColumn> columns = Lists.newArrayList();\n        for (final String path : index.getColumnNames()) {\n            final AbstractMapping<?, ?, ?> mapping = this.getRootMapping().getMapping(path);\n            if (!(mapping instanceof BasicMappingImpl)) {\n                throw new MappingException(\"Cannot locate the basic path \" + path + \" for index \" + index.getName(), index.getLocator());\n            }\n            columns.add(((BasicMappingImpl<?, ?>) mapping).getColumn());\n        }\n        table.addIndex(index.getName(), columns.toArray(new BasicColumn[columns.size()]));\n    }\n}", "repo_id": "1", "comment": "/**\n * Initializes the custom indexes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 258, "method_signature": "void initCustomIndexes()"}, "EntityTypeImpl.initIndexes": {"callee_method_ids": [1136], "callee_method_names": ["IndexMetadata.getTable", "IndexMetadata.getTable", "IndexMetadata.getName", "IndexMetadata.getLocator", "EntityTable.addIndex", "IndexMetadata.getName", "IndexMetadata.getName", "IndexMetadata.getLocator"], "method_name": "EntityTypeImpl.initIndexes", "method_implementation": "{\n    for (final BasicMappingImpl<?, ?> basicMapping : this.getBasicMappings()) {\n        final IndexMetadata index = basicMapping.getAttribute().getIndex();\n        if (index != null) {\n            final EntityTable table = StringUtils.isNotBlank(index.getTable()) ? this.tableMap.get(index.getTable()) : this.primaryTable;\n            if (table == null) {\n                throw new MappingException(\"Cannot locate table for index \" + index.getName(), index.getLocator());\n            }\n            if (table.addIndex(index.getName(), basicMapping.getColumn())) {\n                throw new MappingException(\"Duplicate index with the same name \" + index.getName(), index.getLocator());\n            }\n        }\n    }\n    this.initCustomIndexes();\n}", "repo_id": "1", "comment": "/**\n * Initializes the indexes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 259, "method_signature": "void initIndexes()"}, "EntityTypeImpl.initTables": {"callee_method_names": ["EntityMetadata.getTable", "EntityMetadata.getTable", "EntityMetadata.getTable", "EntityMetadata.getTable", "EntityMetadata.getSecondaryTables"], "method_name": "EntityTypeImpl.initTables", "method_implementation": "{\n    if (this.getRootType() != this) {\n        if (this.getRootType().getInheritanceType() == null) {\n            this.getRootType().setInherited();\n        }\n        switch(this.getRootType().getInheritanceType()) {\n            case SINGLE_TABLE:\n                // if this is the root, create the primary table\n                if (this.getRootType() == this) {\n                    this.primaryTable = new EntityTable(this.getMetamodel().getJdbcAdaptor(), this, metadata.getTable());\n                    this.tableMap.put(this.primaryTable.getName(), this.primaryTable);\n                } else // else map the primary key to the root type's primary table and the tables from the parent\n                {\n                    final EntityTypeImpl<? super X> supertype = (EntityTypeImpl<? super X>) this.getSupertype();\n                    this.primaryTable = supertype.primaryTable;\n                    this.tableMap.putAll(supertype.tableMap);\n                }\n                break;\n            case JOINED:\n                // if this is the root, create the primary table\n                if (this.getRootType() == this) {\n                    this.primaryTable = new EntityTable(this.getMetamodel().getJdbcAdaptor(), this, metadata.getTable());\n                    this.tableMap.put(this.primaryTable.getName(), this.primaryTable);\n                } else // else map all the parent tables and create the primary table as secondary table\n                {\n                    final EntityTypeImpl<? super X> supertype = (EntityTypeImpl<? super X>) this.getSupertype();\n                    this.tableMap.putAll(supertype.tableMap);\n                    this.primaryTable = new SecondaryTable(this.getMetamodel().getJdbcAdaptor(), this, metadata.getTable());\n                    this.tableMap.put(this.primaryTable.getName(), this.primaryTable);\n                }\n                break;\n            case TABLE_PER_CLASS:\n                throw new MappingException(\"TABLE_PER_CLASS inheritence type is not yet supported\", this.getRootType().getLocator());\n        }\n    } else // create the primary table\n    {\n        this.primaryTable = new EntityTable(this.getMetamodel().getJdbcAdaptor(), this, metadata.getTable());\n        this.tableMap.put(this.primaryTable.getName(), this.primaryTable);\n    }\n    for (final SecondaryTableMetadata secondaryTableMetadata : metadata.getSecondaryTables()) {\n        final SecondaryTable secondaryTable = new SecondaryTable(this.getMetamodel().getJdbcAdaptor(), this, secondaryTableMetadata);\n        this.tableMap.put(secondaryTableMetadata.getName(), secondaryTable);\n    }\n}", "repo_id": "1", "comment": "/**\n * Initializes the tables.\n *\n * @since 2.0.0\n * @param metadata\n */\n", "repo_name": "BatooJPA-master/", "id": 260, "method_signature": "void initTables(EntityMetadata)"}, "EntityTypeImpl.isIdMethod": {"callee_method_names": ["Method.getName", "String.startsWith", "String.length", "AssociatedSingularAttribute<? super X, ?>.getName", "AssociatedSingularAttribute<? super X, ?>.isId", "String.equals", "Method.getName"], "method_name": "EntityTypeImpl.isIdMethod", "method_implementation": "{\n    if (this.idMethods.containsKey(method)) {\n        // if known id method, let go\n        return true;\n    }\n    final String methodName = method.getName();\n    if (methodName.startsWith(\"get\") && (methodName.length() > 3)) {\n        // check if id method\n        for (final SingularAttribute<? super X, ?> attribute : this.getSingularAttributes()) {\n            final String getterName = \"get\" + StringUtils.capitalize(attribute.getName());\n            if (attribute.isId() && getterName.equals(method.getName())) {\n                this.idMethods.put(method, method);\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Returns if the method is an id method.\n *\n * @param method\n *            the method\n * @return if the method is an id method\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 261, "method_signature": "boolean isIdMethod(Method)"}, "EntityTypeImpl.isSuitableForBatchInsert": {"callee_method_names": [], "method_name": "EntityTypeImpl.isSuitableForBatchInsert", "method_implementation": "{\n    if (this.suitableForBatchInsert != null) {\n        return this.suitableForBatchInsert;\n    }\n    return this.suitableForBatchInsert = this.hasSingleIdAttribute() && (this.idMapping instanceof BasicMappingImpl) && (((BasicMappingImpl<? super X, ?>) this.idMapping).getAttribute().getIdType() != IdType.IDENTITY);\n}", "repo_id": "1", "comment": "/**\n * Returns if the entity is suitable for batch insert, that is not of {@link IdType#IDENTITY}.\n *\n * @return true if the entity is suitable for batch insert, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 262, "method_signature": "boolean isSuitableForBatchInsert()"}, "EntityTypeImpl.linkMappings": {"callee_method_names": ["IdentifiableTypeImpl<? super X>.getSupertype"], "method_name": "EntityTypeImpl.linkMappings", "method_implementation": "{\n    if (this.getRootType().getInheritanceType() != null) {\n        // register the discriminator value\n        IdentifiableTypeImpl<? super X> parent = this;\n        do {\n            ((EntityTypeImpl<? super X>) parent).children.put(this.discriminatorValue, this);\n            parent = parent.getSupertype();\n        } while (parent instanceof EntityTypeImpl);\n    }\n    // if the root type then create the discriminator column\n    if ((this.getRootType() == this) && (this.inheritanceType != null)) {\n        this.discriminatorColumn = new DiscriminatorColumn(this.getMetamodel().getJdbcAdaptor(), this.primaryTable, this.metadata.getDiscriminatorColumn());\n    }\n    this.entityMapping.createMappings();\n    // link the secondary tables\n    for (final EntityTable table : this.tableMap.values()) {\n        if (table instanceof SecondaryTable) {\n            ((SecondaryTable) table).link();\n        }\n    }\n    this.canBatchRemoves = (this.getVersionAttribute() == null) && this.hasSingleIdAttribute() && (this.getIdMapping() instanceof BasicAttribute);\n}", "repo_id": "1", "comment": "/**\n * Links the entity's attribute mappings.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 263, "method_signature": "void linkMappings()"}, "EntityTypeImpl.performInsert": {"callee_method_ids": [1138], "callee_method_names": ["ManagedInstance<?>[].getInstance", "EntityTable.performInsert", "ManagedInstance<?>[].setStatus"], "method_name": "EntityTypeImpl.performInsert", "method_implementation": "{\n    final Object[] instances = new Object[size];\n    for (int i = 0; i < size; i++) {\n        instances[i] = managedInstances[i].getInstance();\n    }\n    for (final EntityTable table : this.getTables()) {\n        table.performInsert(connection, this, instances, size);\n    }\n    for (int i = 0; i < size; i++) {\n        managedInstances[i].setStatus(Status.MANAGED);\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs inserts to each table for the managed instance.\n *\n * @param connection\n *            the connection to use\n * @param managedInstances\n *            the managed instances to perform insert for\n * @param size\n *            the size of the batch\n * @throws SQLException\n *             thrown in case of an SQL Error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 264, "method_signature": "void performInsert(Connection, ManagedInstance<?>[], int)"}, "EntityTypeImpl.performRefresh": {"callee_method_names": ["ManagedInstance<X>.getSession", "SessionImpl.getEntityManager", "Set<Object>.size", "QueryImpl<X>.setLockMode", "ManagedInstance<X>.getId", "QueryImpl<X>.setParameter", "QueryImpl<X>.setParameter", "ManagedInstance<X>.setRefreshing", "QueryImpl<X>.getSingleResult", "ManagedInstance<X>.setRefreshing"], "method_name": "EntityTypeImpl.performRefresh", "method_implementation": "{\n    final SessionImpl session = instance.getSession();\n    final QueryImpl<X> q = session.getEntityManager().createQuery(this.getCriteriaRefresh());\n    if (processed.size() == 0) {\n        q.setLockMode(lockMode);\n    }\n    final Object id = instance.getId().getId();\n    // if has single id then pass it on\n    if (this.hasSingleIdAttribute()) {\n        q.setParameter(1, id);\n    } else {\n        int i = 1;\n        for (final Pair<SingularMapping<?, ?>, AbstractAccessor> pair : this.getIdMappings()) {\n            q.setParameter(i++, pair.getSecond().get(id));\n        }\n    }\n    instance.setRefreshing(true);\n    try {\n        q.getSingleResult();\n    } finally {\n        instance.setRefreshing(false);\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs refresh for the instance\n *\n * @param connection\n *            the connection\n * @param instance\n *            the managed instance\n * @param lockMode\n *            the lock mode\n * @param processed\n *            the set of processed instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 265, "method_signature": "void performRefresh(Connection, ManagedInstance, LockModeType, Set)"}, "EntityTypeImpl.performRemove": {"callee_method_ids": [1139], "callee_method_names": ["ManagedInstance<?>[].getInstance", "EntityTable.performRemove"], "method_name": "EntityTypeImpl.performRemove", "method_implementation": "{\n    final Object[] instances = new Object[size];\n    for (int i = 0; i < size; i++) {\n        instances[i] = managedInstances[i].getInstance();\n    }\n    for (final EntityTable table : this.getTables()) {\n        if (table == this.primaryTable) {\n            continue;\n        }\n        table.performRemove(connection, instances, size);\n    }\n    this.primaryTable.performRemove(connection, instances, size);\n}", "repo_id": "1", "comment": "/**\n * @param connection\n *            the connection to use\n * @param managedInstances\n *            the managed instance to perform remove for\n * @param size\n *            the size of the batch\n * @throws SQLException\n *             thrown in case of an SQL Error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 266, "method_signature": "void performRemove(Connection, ManagedInstance<?>[], int)"}, "EntityTypeImpl.performSelect": {"callee_method_names": ["EntityManagerImpl.createQuery", "QueryImpl<X>.setLockMode", "QueryImpl<X>.setParameter", "QueryImpl<X>.setParameter", "QueryImpl<X>.getSingleResult"], "method_name": "EntityTypeImpl.performSelect", "method_implementation": "{\n    final QueryImpl<X> q = entityManager.createQuery(this.getCriteriaSelect());\n    q.setLockMode(lockMode);\n    // if has single id then pass it on\n    if (this.hasSingleIdAttribute()) {\n        q.setParameter(1, id);\n    } else {\n        int i = 1;\n        for (final Pair<SingularMapping<?, ?>, AbstractAccessor> pair : this.getIdMappings()) {\n            q.setParameter(i++, pair.getSecond().get(id));\n        }\n    }\n    return q.getSingleResult();\n}", "repo_id": "1", "comment": "/**\n * Performs select to find the instance.\n *\n * @param entityManager\n *            the entity manager to use\n * @param id\n *            the id of the instance to select\n * @param lockMode\n *            the lock mode\n * @return the instance found or null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 267, "method_signature": "X performSelect(EntityManagerImpl, Object, LockModeType)"}, "EntityTypeImpl.performUpdate": {"callee_method_ids": [1140], "callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedInstance<?>.getOldVersion", "List<EntityTable>.iterator", "int.hasNext", "int.next", "ManagedInstance<?>.getInstance", "int.remove", "List<EntityTable>.toArray", "List<EntityTable>.size", "EntityTable.performUpdate"], "method_name": "EntityTypeImpl.performUpdate", "method_implementation": "{\n    FinalWrapper<EntityTable[]> wrapper = this.updateTables;\n    final Object instance = managedInstance.getInstance();\n    final Object oldVersion = managedInstance.getOldVersion();\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.updateTables == null) {\n                final List<EntityTable> _updateTables = Lists.newArrayList(this.getTables());\n                for (final Iterator<EntityTable> i = _updateTables.iterator(); i.hasNext(); ) {\n                    if (!i.next().performUpdateWithUpdatability(connection, this, managedInstance.getInstance(), oldVersion)) {\n                        i.remove();\n                    }\n                }\n                this.updateTables = new FinalWrapper<EntityTable[]>(_updateTables.toArray(new EntityTable[_updateTables.size()]));\n            }\n            wrapper = this.updateTables;\n        }\n    } else {\n        for (final EntityTable table : wrapper.value) {\n            table.performUpdate(connection, this, instance, oldVersion);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs the update for the instance.\n *\n * @param connection\n *            the connection to use\n * @param managedInstance\n *            the managed instance to perform update for\n * @throws SQLException\n *             thrown in case of an SQL Error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 268, "method_signature": "void performUpdate(Connection, ManagedInstance)"}, "EntityTypeImpl.prepareDependenciesFor": {"callee_method_names": ["AssociatedSingularAttribute<? super X, ?>.isOwner", "AssociatedSingularAttribute<? super X, ?>.getAttribute", "AssociatedSingularAttribute<? super X, ?>.getAttribute", "AssociatedSingularAttribute<? super X, ?>.getAttribute", "Class<?>.isAssignableFrom", "EntityTypeImpl<?>.getBindableJavaType", "Set<AssociationMappingImpl<?, ?, ?>>.add", "Set<AssociationMappingImpl<?, ?, ?>>.size", "Set<AssociationMappingImpl<?, ?, ?>>.toArray"], "method_name": "EntityTypeImpl.prepareDependenciesFor", "method_implementation": "{\n    // prepare the related associations\n    final Set<AssociationMappingImpl<?, ?, ?>> attributes = Sets.newHashSet();\n    for (final AssociationMappingImpl<?, ?, ?> association : this.getAssociations()) {\n        // only owner associations impose priority\n        if (!association.isOwner()) {\n            continue;\n        }\n        // only relations kept in the row impose priority\n        if (//\n        (association.getAttribute().getPersistentAttributeType() != PersistentAttributeType.ONE_TO_ONE) && (association.getAttribute().getPersistentAttributeType() != PersistentAttributeType.MANY_TO_ONE)) {\n            continue;\n        }\n        final Class<?> javaType = association.getAttribute().getJavaType();\n        if (javaType.isAssignableFrom(associate.getBindableJavaType())) {\n            attributes.add(association);\n        }\n    }\n    final AssociationMappingImpl<?, ?, ?>[] dependencies = new AssociationMappingImpl[attributes.size()];\n    attributes.toArray(dependencies);\n    this.dependencyCount += dependencies.length;\n    this.dependencyMap.put(associate, dependencies);\n}", "repo_id": "1", "comment": "/**\n * Prepares the dependencies for the associate.\n *\n * @param associate\n *            the associate\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 269, "method_signature": "void prepareDependenciesFor(EntityTypeImpl)"}, "EntityTypeImpl.prepareEagerJoins": {"callee_method_names": [], "method_name": "EntityTypeImpl.prepareEagerJoins", "method_implementation": "{\n    if (depth < this.maxFetchJoinDepth) {\n        this.prepareEagerJoins(r, depth, parent, this.entityMapping.getEagerMappings());\n    }\n}", "repo_id": "1", "comment": "/**\n * @param r\n *            the fetch parent\n * @param depth\n *            the depth\n * @param parent\n *            the parent\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 270, "method_signature": "void prepareEagerJoins(FetchParent, int, AssociationMappingImpl)"}, "EntityTypeImpl.runValidators": {"callee_method_names": ["EntityManagerFactoryImpl.getValidationFactory", "ValidatorFactory.usingContext", "ManagedInstance<?>.getStatus", "EntityManagerFactoryImpl.getPersistValidators", "EntityManagerFactoryImpl.getUpdateValidators", "EntityManagerFactoryImpl.getRemoveValidators", "Validator.validate", "ManagedInstance<?>.getInstance"], "method_name": "EntityTypeImpl.runValidators", "method_implementation": "{\n    final ValidatorFactory factory = entityManagerFactory.getValidationFactory();\n    final Validator validator = factory.usingContext().getValidator();\n    Class<?>[] groups;\n    switch(instance.getStatus()) {\n        case NEW:\n            groups = entityManagerFactory.getPersistValidators();\n            break;\n        case MANAGED:\n            groups = entityManagerFactory.getUpdateValidators();\n            break;\n        default:\n            groups = entityManagerFactory.getRemoveValidators();\n            break;\n    }\n    return validator.validate((Object) instance.getInstance(), groups);\n}", "repo_id": "1", "comment": "/**\n * Runs the validators for the instance.\n *\n * @param entityManagerFactory\n *            the entity manager factory\n * @param instance\n *            the instance\n * @return the set of validation errors\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 271, "method_signature": "Set<ConstraintViolation<Object>> runValidators(EntityManagerFactoryImpl, ManagedInstance)"}, "EntityTypeImpl.setId": {"callee_method_names": ["AbstractAccessor.get"], "method_name": "EntityTypeImpl.setId", "method_implementation": "{\n    if (this.hasSingleIdAttribute()) {\n        this.setIdImpl(session, instance, id, this.getIdMapping());\n    } else {\n        for (final Pair<SingularMapping<?, ?>, AbstractAccessor> pair : this.getIdMappings()) {\n            final SingularMapping<?, ?> child = pair.getFirst();\n            final AbstractAccessor accessor = pair.getSecond();\n            final Object childId = id != null ? accessor.get(id) : null;\n            this.setIdImpl(session, instance, childId, child);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the id of the entity from the instance.\n *\n * @param session\n *            the session\n * @param instance\n *            the instance\n * @param id\n *            the id\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 272, "method_signature": "void setId(SessionImpl, Object, Object)"}, "EntryImpl.equals": {"callee_method_names": ["Map.Entry.getKey", "Object.equals", "Map.Entry.getValue", "Object.equals"], "method_name": "EntryImpl.equals", "method_implementation": "{\n    if (!(o instanceof Map.Entry)) {\n        return false;\n    }\n    final Map.Entry e = (Map.Entry) o;\n    final Object k1 = this.getKey();\n    final Object k2 = e.getKey();\n    if ((k1 == k2) || ((k1 != null) && k1.equals(k2))) {\n        final Object v1 = this.getValue();\n        final Object v2 = e.getValue();\n        if ((v1 == v2) || ((v1 != null) && v1.equals(v2))) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 686, "method_signature": "boolean equals(Object)"}, "EnumTest.testFind": {"callee_method_names": ["Foo.getId", "Foo.getFootype", "Foo.getFootype2"], "method_name": "EnumTest.testFind", "method_implementation": "{\n    Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getId());\n    Assert.assertNull(foo.getFootype());\n    Assert.assertNull(foo.getFootype2());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2208, "method_signature": "void testFind()"}, "EnumTest.testFind2": {"callee_method_names": ["Foo.setFootype", "Foo.setFootype2", "Foo.getId", "Foo.getFootype", "Foo.getFootype2"], "method_name": "EnumTest.testFind2", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setFootype(FooType.TYPE1);\n    foo.setFootype2(FooType.TYPE2);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getId());\n    Assert.assertEquals(FooType.TYPE1, foo.getFootype());\n    Assert.assertEquals(FooType.TYPE2, foo.getFootype2());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2209, "method_signature": "void testFind2()"}, "EnumTest.testPersist": {"callee_method_names": [], "method_name": "EnumTest.testPersist", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    Assert.assertNull(new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT FOOTYPE FROM Foo\", new SingleValueHandler<String>()));\n    Assert.assertNull(new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT FOOTYPE2 FROM Foo\", new SingleValueHandler<Integer>()));\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if fails\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2210, "method_signature": "void testPersist()"}, "EnumTest.testPersist2": {"callee_method_names": ["Foo.setFootype", "Foo.setFootype2"], "method_name": "EnumTest.testPersist2", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.setFootype(FooType.TYPE1);\n    foo.setFootype2(FooType.TYPE2);\n    this.persist(foo);\n    this.commit();\n    Assert.assertEquals(FooType.TYPE1.name(), new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT FOOTYPE FROM Foo\", new SingleValueHandler<String>()));\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT FOOTYPE2 FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if fails\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2211, "method_signature": "void testPersist2()"}, "EnumTest.testUpdate": {"callee_method_names": ["Foo.getId", "Foo.setFootype", "Foo.setFootype2", "Foo.getId", "Foo.getFootype", "Foo.getFootype2"], "method_name": "EnumTest.testUpdate", "method_implementation": "{\n    Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    foo.setFootype(FooType.TYPE1);\n    foo.setFootype2(FooType.TYPE2);\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getId());\n    Assert.assertEquals(FooType.TYPE1, foo.getFootype());\n    Assert.assertEquals(FooType.TYPE2, foo.getFootype2());\n}", "repo_id": "1", "comment": "/**\n * Tests to update.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2212, "method_signature": "void testUpdate()"}, "EnumTest.testUpdate2": {"callee_method_names": ["Foo.setFootype", "Foo.setFootype2", "Foo.getId", "Foo.setFootype", "Foo.setFootype2", "Foo.getId", "Foo.getFootype", "Foo.getFootype2"], "method_name": "EnumTest.testUpdate2", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setFootype(FooType.TYPE3);\n    foo.setFootype2(FooType.TYPE3);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    foo.setFootype(FooType.TYPE1);\n    foo.setFootype2(FooType.TYPE2);\n    this.commit();\n    this.close();\n    foo = this.find(Foo.class, foo.getId());\n    Assert.assertEquals(FooType.TYPE1, foo.getFootype());\n    Assert.assertEquals(FooType.TYPE2, foo.getFootype2());\n}", "repo_id": "1", "comment": "/**\n * Tests to update.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2213, "method_signature": "void testUpdate2()"}, "ExpressionConverter.convert": {"callee_method_names": [], "method_name": "ExpressionConverter.convert", "method_implementation": "{\n    if (value == null) {\n        return null;\n    }\n    return this.convertImpl(value);\n}", "repo_id": "1", "comment": "/**\n * Converts the number to <code>T</code> type.\n *\n * @param value\n *            the from value\n * @return the converted <code>T</code> value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 581, "method_signature": "N convert(Object)"}, "FastLinkedList.add": {"callee_method_names": [], "method_name": "FastLinkedList.add", "method_implementation": "{\n    this.checkPositionIndex(index);\n    if (index == this.size) {\n        this.linkLast(element);\n    } else {\n        this.linkBefore(element, this.node(index));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 19, "method_signature": "void add(int, E)"}, "FastLinkedList.addAll": {"callee_method_names": ["Collection<? extends E>.toArray"], "method_name": "FastLinkedList.addAll", "method_implementation": "{\n    this.checkPositionIndex(index);\n    final Object[] a = c.toArray();\n    final int numNew = a.length;\n    if (numNew == 0) {\n        return false;\n    }\n    FastLinkedListNode<E> pred, succ;\n    if (index == this.size) {\n        succ = null;\n        pred = this.last;\n    } else {\n        succ = this.node(index);\n        pred = succ.prev;\n    }\n    for (final Object o : a) {\n        @SuppressWarnings(\"unchecked\")\n        final E e = (E) o;\n        final FastLinkedListNode<E> newNode = new FastLinkedListNode<E>(pred, e, null);\n        if (pred == null) {\n            this.first = newNode;\n        } else {\n            pred.next = newNode;\n        }\n        pred = newNode;\n    }\n    if (succ == null) {\n        this.last = pred;\n    } else {\n        pred.next = succ;\n        succ.prev = pred;\n    }\n    this.size += numNew;\n    this.modCount++;\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 20, "method_signature": "boolean addAll(int, Collection)"}, "FastLinkedList.clear": {"callee_method_names": [], "method_name": "FastLinkedList.clear", "method_implementation": "{\n    this.first = this.last = null;\n    this.size = 0;\n    this.modCount++;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 21, "method_signature": "void clear()"}, "FastLinkedList.clone": {"callee_method_names": ["FastLinkedList<E>.add"], "method_name": "FastLinkedList.clone", "method_implementation": "{\n    final FastLinkedList<E> clone = this.superClone();\n    // Put clone into \"virgin\" state\n    clone.first = clone.last = null;\n    clone.size = 0;\n    clone.modCount = 0;\n    // Initialize clone with our elements\n    for (FastLinkedListNode<E> x = this.first; x != null; x = x.next) {\n        clone.add(x.item);\n    }\n    return clone;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 22, "method_signature": "Object clone()"}, "FastLinkedList.get": {"callee_method_names": [], "method_name": "FastLinkedList.get", "method_implementation": "{\n    this.checkElementIndex(index);\n    return this.node(index).item;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 23, "method_signature": "E get(int)"}, "FastLinkedList.getFirst": {"callee_method_names": [], "method_name": "FastLinkedList.getFirst", "method_implementation": "{\n    final FastLinkedListNode<E> f = this.first;\n    if (f == null) {\n        throw new NoSuchElementException();\n    }\n    return f.item;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 24, "method_signature": "E getFirst()"}, "FastLinkedList.getLast": {"callee_method_names": [], "method_name": "FastLinkedList.getLast", "method_implementation": "{\n    final FastLinkedListNode<E> l = this.last;\n    if (l == null) {\n        throw new NoSuchElementException();\n    }\n    return l.item;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 25, "method_signature": "E getLast()"}, "FastLinkedList.indexOf": {"callee_method_names": ["Object.equals"], "method_name": "FastLinkedList.indexOf", "method_implementation": "{\n    int index = 0;\n    if (o == null) {\n        for (FastLinkedListNode<E> x = this.first; x != null; x = x.next) {\n            if (x.item == null) {\n                return index;\n            }\n            index++;\n        }\n    } else {\n        for (FastLinkedListNode<E> x = this.first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                return index;\n            }\n            index++;\n        }\n    }\n    return -1;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 26, "method_signature": "int indexOf(Object)"}, "FastLinkedList.lastIndexOf": {"callee_method_names": ["Object.equals"], "method_name": "FastLinkedList.lastIndexOf", "method_implementation": "{\n    int index = this.size;\n    if (o == null) {\n        for (FastLinkedListNode<E> x = this.last; x != null; x = x.prev) {\n            index--;\n            if (x.item == null) {\n                return index;\n            }\n        }\n    } else {\n        for (FastLinkedListNode<E> x = this.last; x != null; x = x.prev) {\n            index--;\n            if (o.equals(x.item)) {\n                return index;\n            }\n        }\n    }\n    return -1;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 27, "method_signature": "int lastIndexOf(Object)"}, "FastLinkedList.listIterator": {"callee_method_names": [], "method_name": "FastLinkedList.listIterator", "method_implementation": "{\n    this.checkPositionIndex(index);\n    return new FastLinkedListIterator<E>(this, index, true);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 28, "method_signature": "FastLinkedListIterator<E> listIterator(int)"}, "FastLinkedList.node": {"callee_method_names": [], "method_name": "FastLinkedList.node", "method_implementation": "{\n    // assert isElementIndex(index);\n    if (index < (this.size >> 1)) {\n        FastLinkedListNode<E> x = this.first;\n        for (int i = 0; i < index; i++) {\n            x = x.next;\n        }\n        return x;\n    } else {\n        FastLinkedListNode<E> x = this.last;\n        for (int i = this.size - 1; i > index; i--) {\n            x = x.prev;\n        }\n        return x;\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the (non-null) Node at the specified element index.\n */\n", "repo_name": "BatooJPA-master/", "id": 29, "method_signature": "FastLinkedListNode<E> node(int)"}, "FastLinkedList.offerFirst": {"callee_method_names": [], "method_name": "FastLinkedList.offerFirst", "method_implementation": "{\n    this.addFirst(e);\n    return true;\n}", "repo_id": "1", "comment": "/**\n * Inserts the specified element at the front of this list.\n *\n * @param e\n *            the element to insert\n * @return {@code true} (as specified by {@link Deque#offerFirst})\n * @since 1.6\n */\n", "repo_name": "BatooJPA-master/", "id": 30, "method_signature": "boolean offerFirst(E)"}, "FastLinkedList.offerLast": {"callee_method_names": [], "method_name": "FastLinkedList.offerLast", "method_implementation": "{\n    this.addLast(e);\n    return true;\n}", "repo_id": "1", "comment": "/**\n * Inserts the specified element at the end of this list.\n *\n * @param e\n *            the element to insert\n * @return {@code true} (as specified by {@link Deque#offerLast})\n * @since 1.6\n */\n", "repo_name": "BatooJPA-master/", "id": 31, "method_signature": "boolean offerLast(E)"}, "FastLinkedList.peek": {"callee_method_names": [], "method_name": "FastLinkedList.peek", "method_implementation": "{\n    final FastLinkedListNode<E> f = this.first;\n    return (f == null) ? null : f.item;\n}", "repo_id": "1", "comment": "/**\n * Retrieves, but does not remove, the head (first element) of this list.\n *\n * @return the head of this list, or {@code null} if this list is empty\n * @since 1.5\n */\n", "repo_name": "BatooJPA-master/", "id": 32, "method_signature": "E peek()"}, "FastLinkedList.peekFirst": {"callee_method_names": [], "method_name": "FastLinkedList.peekFirst", "method_implementation": "{\n    final FastLinkedListNode<E> f = this.first;\n    return (f == null) ? null : f.item;\n}", "repo_id": "1", "comment": "/**\n * Retrieves, but does not remove, the first element of this list, or returns {@code null} if this list is empty.\n *\n * @return the first element of this list, or {@code null} if this list is empty\n * @since 1.6\n */\n", "repo_name": "BatooJPA-master/", "id": 33, "method_signature": "E peekFirst()"}, "FastLinkedList.peekLast": {"callee_method_names": [], "method_name": "FastLinkedList.peekLast", "method_implementation": "{\n    final FastLinkedListNode<E> l = this.last;\n    return (l == null) ? null : l.item;\n}", "repo_id": "1", "comment": "/**\n * Retrieves, but does not remove, the last element of this list, or returns {@code null} if this list is empty.\n *\n * @return the last element of this list, or {@code null} if this list is empty\n * @since 1.6\n */\n", "repo_name": "BatooJPA-master/", "id": 34, "method_signature": "E peekLast()"}, "FastLinkedList.poll": {"callee_method_names": [], "method_name": "FastLinkedList.poll", "method_implementation": "{\n    final FastLinkedListNode<E> f = this.first;\n    return (f == null) ? null : this.unlinkFirst(f);\n}", "repo_id": "1", "comment": "/**\n * Retrieves and removes the head (first element) of this list.\n *\n * @return the head of this list, or {@code null} if this list is empty\n * @since 1.5\n */\n", "repo_name": "BatooJPA-master/", "id": 35, "method_signature": "E poll()"}, "FastLinkedList.pollFirst": {"callee_method_names": [], "method_name": "FastLinkedList.pollFirst", "method_implementation": "{\n    final FastLinkedListNode<E> f = this.first;\n    return (f == null) ? null : this.unlinkFirst(f);\n}", "repo_id": "1", "comment": "/**\n * Retrieves and removes the first element of this list, or returns {@code null} if this list is empty.\n *\n * @return the first element of this list, or {@code null} if this list is empty\n * @since 1.6\n */\n", "repo_name": "BatooJPA-master/", "id": 36, "method_signature": "E pollFirst()"}, "FastLinkedList.pollLast": {"callee_method_names": [], "method_name": "FastLinkedList.pollLast", "method_implementation": "{\n    final FastLinkedListNode<E> l = this.last;\n    return (l == null) ? null : this.unlinkLast(l);\n}", "repo_id": "1", "comment": "/**\n * Retrieves and removes the last element of this list, or returns {@code null} if this list is empty.\n *\n * @return the last element of this list, or {@code null} if this list is empty\n * @since 1.6\n */\n", "repo_name": "BatooJPA-master/", "id": 37, "method_signature": "E pollLast()"}, "FastLinkedList.readObject": {"callee_method_names": ["java.io.ObjectInputStream.defaultReadObject", "java.io.ObjectInputStream.readInt", "java.io.ObjectInputStream.readObject"], "method_name": "FastLinkedList.readObject", "method_implementation": "{\n    // Read in any hidden serialization magic\n    s.defaultReadObject();\n    // Read in size\n    final int size = s.readInt();\n    // Read in all elements in the proper order.\n    for (int i = 0; i < size; i++) {\n        this.linkLast((E) s.readObject());\n    }\n}", "repo_id": "1", "comment": "/**\n * Reconstitutes this {@code ChildrenList} instance from a stream (that is, deserializes it).\n */\n", "repo_name": "BatooJPA-master/", "id": 38, "method_signature": "void readObject(java.io.ObjectInputStream)"}, "FastLinkedList.remove": {"callee_method_names": ["Object.equals"], "method_name": "FastLinkedList.remove", "method_implementation": "{\n    if (o == null) {\n        for (FastLinkedListNode<E> x = this.first; x != null; x = x.next) {\n            if (x.item == null) {\n                this.unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (FastLinkedListNode<E> x = this.first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                this.unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it\n * is unchanged. More formally, removes the element with the lowest index {@code i} such that\n * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt> (if such an element exists). Returns {@code true} if this\n * list contained the specified element (or equivalently, if this list changed as a result of the call).\n *\n * @param o\n *            element to be removed from this list, if present\n * @return {@code true} if this list contained the specified element\n */\n", "repo_name": "BatooJPA-master/", "id": 40, "method_signature": "boolean remove(Object)"}, "FastLinkedList.removeFirst": {"callee_method_names": [], "method_name": "FastLinkedList.removeFirst", "method_implementation": "{\n    final FastLinkedListNode<E> f = this.first;\n    if (f == null) {\n        throw new NoSuchElementException();\n    }\n    return this.unlinkFirst(f);\n}", "repo_id": "1", "comment": "/**\n * Removes and returns the first element from this list.\n *\n * @return the first element from this list\n * @throws NoSuchElementException\n *             if this list is empty\n */\n", "repo_name": "BatooJPA-master/", "id": 41, "method_signature": "E removeFirst()"}, "FastLinkedList.removeLast": {"callee_method_names": [], "method_name": "FastLinkedList.removeLast", "method_implementation": "{\n    final FastLinkedListNode<E> l = this.last;\n    if (l == null) {\n        throw new NoSuchElementException();\n    }\n    return this.unlinkLast(l);\n}", "repo_id": "1", "comment": "/**\n * Removes and returns the last element from this list.\n *\n * @return the last element from this list\n * @throws NoSuchElementException\n *             if this list is empty\n */\n", "repo_name": "BatooJPA-master/", "id": 42, "method_signature": "E removeLast()"}, "FastLinkedList.removeLastOccurrence": {"callee_method_names": ["Object.equals"], "method_name": "FastLinkedList.removeLastOccurrence", "method_implementation": "{\n    if (o == null) {\n        for (FastLinkedListNode<E> x = this.last; x != null; x = x.prev) {\n            if (x.item == null) {\n                this.unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (FastLinkedListNode<E> x = this.last; x != null; x = x.prev) {\n            if (o.equals(x.item)) {\n                this.unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Removes the last occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not\n * contain the element, it is unchanged.\n *\n * @param o\n *            element to be removed from this list, if present\n * @return {@code true} if the list contained the specified element\n * @since 1.6\n */\n", "repo_name": "BatooJPA-master/", "id": 43, "method_signature": "boolean removeLastOccurrence(Object)"}, "FastLinkedList.set": {"callee_method_names": [], "method_name": "FastLinkedList.set", "method_implementation": "{\n    this.checkElementIndex(index);\n    final FastLinkedListNode<E> x = this.node(index);\n    final E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}", "repo_id": "1", "comment": "/**\n * Replaces the element at the specified position in this list with the specified element.\n *\n * @param index\n *            index of the element to replace\n * @param element\n *            element to be stored at the specified position\n * @return the element previously at the specified position\n * @throws IndexOutOfBoundsException\n *             {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 44, "method_signature": "E set(int, E)"}, "FastLinkedList.toArray": {"callee_method_names": ["T[].getClass"], "method_name": "FastLinkedList.toArray", "method_implementation": "{\n    if (a.length < this.size) {\n        a = (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), this.size);\n    }\n    int i = 0;\n    final Object[] result = a;\n    for (FastLinkedListNode<E> x = this.first; x != null; x = x.next) {\n        result[i++] = x.item;\n    }\n    if (a.length > this.size) {\n        a[this.size] = null;\n    }\n    return a;\n}", "repo_id": "1", "comment": "/**\n * Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the\n * returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new\n * array is allocated with the runtime type of the specified array and the size of this list.\n *\n * <p>\n * If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the\n * array immediately following the end of the list is set to {@code null}. (This is useful in determining the length of the list\n * <i>only</i> if the caller knows that the list does not contain any null elements.)\n *\n * <p>\n * Like the {@link #toArray()} method, this method acts as bridge between array-based and collection-based APIs. Further, this method\n * allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation\n * costs.\n *\n * <p>\n * Suppose {@code x} is a list known to contain only strings. The following code can be used to dump the list into a newly allocated\n * array of {@code String}:\n *\n * <pre>\n * String[] y = x.toArray(new String[0]);\n * </pre>\n *\n * Note that {@code toArray(new Object[0])} is identical in function to {@code toArray()}.\n *\n * @param a\n *            the array into which the elements of the list are to be stored, if it is big enough; otherwise, a new array of the same\n *            runtime type is allocated for this purpose.\n * @return an array containing the elements of the list\n * @throws ArrayStoreException\n *             if the runtime type of the specified array is not a supertype of the runtime type of every element in this list\n * @throws NullPointerException\n *             if the specified array is null\n */\n", "repo_name": "BatooJPA-master/", "id": 46, "method_signature": "T[] toArray(T[])"}, "FastLinkedList.unlink": {"callee_method_names": ["AbstractListListener<E>.elementRemoved"], "method_name": "FastLinkedList.unlink", "method_implementation": "{\n    final E element = x.item;\n    final FastLinkedListNode<E> next = x.next;\n    final FastLinkedListNode<E> prev = x.prev;\n    if (prev == null) {\n        this.first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n    if (next == null) {\n        this.last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;\n    this.size--;\n    this.modCount++;\n    final AbstractListListener<E> listener = this.listener;\n    if (listener != null) {\n        listener.elementRemoved(element);\n    }\n    return element;\n}", "repo_id": "1", "comment": "/**\n * Unlinks non-null node x.\n */\n", "repo_name": "BatooJPA-master/", "id": 47, "method_signature": "E unlink(FastLinkedListNode)"}, "FastLinkedList.unlinkFirst": {"callee_method_names": ["AbstractListListener<E>.elementRemoved"], "method_name": "FastLinkedList.unlinkFirst", "method_implementation": "{\n    final E element = f.item;\n    final FastLinkedListNode<E> next = f.next;\n    f.item = null;\n    // help GC\n    f.next = null;\n    this.first = next;\n    if (next == null) {\n        this.last = null;\n    } else {\n        next.prev = null;\n    }\n    this.size--;\n    this.modCount++;\n    final AbstractListListener<E> listener = this.listener;\n    if (listener != null) {\n        listener.elementRemoved(element);\n    }\n    return element;\n}", "repo_id": "1", "comment": "/**\n * Unlinks non-null first node f.\n */\n", "repo_name": "BatooJPA-master/", "id": 48, "method_signature": "E unlinkFirst(FastLinkedListNode)"}, "FastLinkedList.unlinkLast": {"callee_method_names": ["AbstractListListener<E>.elementRemoved"], "method_name": "FastLinkedList.unlinkLast", "method_implementation": "{\n    final E element = l.item;\n    final FastLinkedListNode<E> prev = l.prev;\n    l.item = null;\n    // help GC\n    l.prev = null;\n    this.last = prev;\n    if (prev == null) {\n        this.first = null;\n    } else {\n        prev.next = null;\n    }\n    this.size--;\n    this.modCount++;\n    final AbstractListListener<E> listener = this.listener;\n    if (listener != null) {\n        listener.elementRemoved(element);\n    }\n    return element;\n}", "repo_id": "1", "comment": "/**\n * Unlinks non-null last node l.\n */\n", "repo_name": "BatooJPA-master/", "id": 49, "method_signature": "E unlinkLast(FastLinkedListNode)"}, "FastLinkedList.writeObject": {"callee_method_names": ["java.io.ObjectOutputStream.defaultWriteObject", "java.io.ObjectOutputStream.writeInt", "java.io.ObjectOutputStream.writeObject"], "method_name": "FastLinkedList.writeObject", "method_implementation": "{\n    // Write out any hidden serialization magic\n    s.defaultWriteObject();\n    // Write out size\n    s.writeInt(this.size);\n    // Write out all elements in the proper order.\n    for (FastLinkedListNode<E> x = this.first; x != null; x = x.next) {\n        s.writeObject(x.item);\n    }\n}", "repo_id": "1", "comment": "/**\n * Saves the state of this {@code ChildrenList} instance to a stream (that is, serializes it).\n *\n * @serialData The size of the list (the number of elements it contains) is emitted (int), followed by all of its elements (each an\n *             Object) in the proper order.\n */\n", "repo_name": "BatooJPA-master/", "id": 50, "method_signature": "void writeObject(java.io.ObjectOutputStream)"}, "FastLinkedListIterator.add": {"callee_method_names": [], "method_name": "FastLinkedListIterator.add", "method_implementation": "{\n    this.lastReturned = null;\n    if (this.next == null) {\n        this.list.linkLast(e);\n    } else {\n        this.list.linkBefore(e, this.next);\n    }\n    this.nextIndex++;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 51, "method_signature": "void add(E)"}, "FastLinkedListIterator.hasNext": {"callee_method_names": [], "method_name": "FastLinkedListIterator.hasNext", "method_implementation": "{\n    if (this.forward) {\n        return this.nextIndex < this.list.size;\n    }\n    return this.nextIndex > 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 52, "method_signature": "boolean hasNext()"}, "FastLinkedListIterator.hasPrevious": {"callee_method_names": [], "method_name": "FastLinkedListIterator.hasPrevious", "method_implementation": "{\n    if (this.forward) {\n        return this.nextIndex > 0;\n    }\n    return this.nextIndex < this.list.size;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 53, "method_signature": "boolean hasPrevious()"}, "FastLinkedListIterator.next": {"callee_method_names": [], "method_name": "FastLinkedListIterator.next", "method_implementation": "{\n    if (this.forward) {\n        return this.realNext();\n    }\n    return this.realPrevious();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 54, "method_signature": "E next()"}, "FastLinkedListIterator.previous": {"callee_method_names": [], "method_name": "FastLinkedListIterator.previous", "method_implementation": "{\n    // if (!this.hasPrevious()) {\n    // throw new NoSuchElementException();\n    // }\n    if (this.forward) {\n        return this.realPrevious();\n    }\n    return this.realNext();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 55, "method_signature": "E previous()"}, "FastLinkedListIterator.remove": {"callee_method_names": [], "method_name": "FastLinkedListIterator.remove", "method_implementation": "{\n    if (this.lastReturned == null) {\n        throw new IllegalStateException();\n    }\n    final FastLinkedListNode<E> lastNext = this.lastReturned.next;\n    this.list.unlink(this.lastReturned);\n    if (this.next == this.lastReturned) {\n        this.next = lastNext;\n    } else {\n        this.nextIndex--;\n    }\n    this.lastReturned = null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 56, "method_signature": "void remove()"}, "FastLinkedListIterator.set": {"callee_method_names": [], "method_name": "FastLinkedListIterator.set", "method_implementation": "{\n    if (this.lastReturned == null) {\n        throw new IllegalStateException();\n    }\n    this.lastReturned.item = e;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 57, "method_signature": "void set(E)"}, "FetchImpl.generateJpqlFetches": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "FetchImpl.generateJpqlFetches", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(\"left join fetch \");\n    builder.append(parent).append(\".\").append(this.mapping.getAttribute().getName());\n    final String children = super.generateJpqlFetches(parent + \".\" + this.mapping.getAttribute().getName());\n    if (StringUtils.isNotBlank(children)) {\n        builder.append(\"\\n\").append(children);\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * Returns the description of the fetch.\n *\n * @param parent\n *            the parent\n * @return the description of the fetch\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 807, "method_signature": "String generateJpqlFetches(String)"}, "FetchImpl.generateSqlJoins": {"callee_method_names": ["List<String>.add"], "method_name": "FetchImpl.generateSqlJoins", "method_implementation": "{\n    final String parentAlias = this.getParent().getPrimaryTableAlias(query);\n    final String alias = this.getPrimaryTableAlias(query);\n    selfJoins.add(this.mapping.join(parentAlias, alias, this.joinType));\n    super.generateSqlJoins(query, selfJoins);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 808, "method_signature": "void generateSqlJoins(AbstractCriteriaQueryImpl, List)"}, "FetchImpl.getPrimaryTableAlias": {"callee_method_names": [], "method_name": "FetchImpl.getPrimaryTableAlias", "method_implementation": "{\n    if (this.mapping.getMappingType() == MappingType.EMBEDDABLE) {\n        return this.parent.getPrimaryTableAlias(query);\n    }\n    return super.getPrimaryTableAlias(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 809, "method_signature": "String getPrimaryTableAlias(BaseQueryImpl)"}, "FetchParentImpl.fetch": {"callee_method_names": [], "method_name": "FetchParentImpl.fetch", "method_implementation": "{\n    final AbstractMapping<?, ?, ?> _mapping = this.getMapping(attributeName);\n    if (!(_mapping instanceof JoinedMapping)) {\n        throw new IllegalArgumentException(\"Cannot dereference attribute \" + attributeName);\n    }\n    if (this.fetches.get(_mapping) != null) {\n        return (FetchImpl<X, Y>) this.fetches.get(_mapping);\n    }\n    final FetchImpl<X, Y> fetch = new FetchImpl<X, Y>(this, (JoinedMapping<? super X, ?, Y>) _mapping, jt);\n    this.fetches.put(_mapping, fetch);\n    return fetch;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 811, "method_signature": "FetchImpl<X,Y> fetch(String, JoinType)"}, "FetchParentImpl.generateDiscrimination": {"callee_method_names": [], "method_name": "FetchParentImpl.generateDiscrimination", "method_implementation": "{\n    if ((this.entity.getRootType().getInheritanceType() == null) || (this.entity == this.entity.getRootType())) {\n        return null;\n    }\n    final Collection<String> discriminators = Collections2.transform(this.entity.getDiscriminators(), new Function<String, String>() {\n\n        @Override\n        public String apply(String input) {\n            return \"'\" + input + \"'\";\n        }\n    });\n    if (noQualification) {\n        return this.entity.getRootType().getDiscriminatorColumn().getName() + \" IN (\" + Joiner.on(\",\").join(discriminators) + \")\";\n    }\n    return this.primaryTableAlias + \".\" + this.entity.getRootType().getDiscriminatorColumn().getName() + \" IN (\" + Joiner.on(\",\").join(discriminators) + \")\";\n}", "repo_id": "1", "comment": "/**\n * Returns the restriction based on discrimination.\n *\n * @param noQualification\n *            if the fields should not be quelified\n * @return the restriction based on discrimination, <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 812, "method_signature": "String generateDiscrimination(boolean)"}, "FetchParentImpl.generateJpqlFetches": {"callee_method_names": ["StringBuilder.append", "StringBuilder.toString"], "method_name": "FetchParentImpl.generateJpqlFetches", "method_implementation": "{\n    final StringBuilder description = new StringBuilder();\n    final Collection<String> _fetches = Collections2.transform(this.fetches.values(), new Function<FetchImpl<X, ?>, String>() {\n\n        @Override\n        public String apply(FetchImpl<X, ?> input) {\n            if (input.getMapping().getMappingType() == MappingType.EMBEDDABLE) {\n                return null;\n            }\n            return input.generateJpqlFetches(parent);\n        }\n    });\n    description.append(Joiner.on(\"\\n\").skipNulls().join(_fetches));\n    return description.toString();\n}", "repo_id": "1", "comment": "/**\n * Returns the description of the fetch.\n *\n * @param parent\n *            the parent\n * @return the description of the fetch *\n */\n", "repo_name": "BatooJPA-master/", "id": 813, "method_signature": "String generateJpqlFetches(String)"}, "FetchParentImpl.generateSqlJoins": {"callee_method_names": ["String.trim", "Map<Joinable,String>.put", "Map<Joinable,String>.put", "AbstractMapping<? super E, ?, ?>.generateSqlJoins", "FetchImpl<X, Y>.generateSqlJoins"], "method_name": "FetchParentImpl.generateSqlJoins", "method_implementation": "{\n    final List<String> selfJoins = Lists.newArrayList();\n    this.generateSqlJoins(query, selfJoins);\n    final String join = Joiner.on(\"\\n\").skipNulls().join(selfJoins);\n    if ((join != null) && (join.trim().length() > 0)) {\n        joins.put(this, join);\n    } else {\n        joins.put(this, null);\n    }\n    for (final FetchImpl<X, ?> child : this.joins) {\n        child.generateSqlJoins(query, joins, false);\n    }\n    if (recurse) {\n        for (final FetchImpl<X, ?> fetch : this.fetches.values()) {\n            fetch.generateSqlJoins(query, joins, true);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Generates joins SQL fragment for the fetch chain.\n *\n * @param query\n *            the query\n * @param joins\n *            the map of joins\n * @param recurse\n *            recurse to fetch children\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 815, "method_signature": "void generateSqlJoins(AbstractCriteriaQueryImpl, Map, boolean)"}, "FetchParentImpl.generateSqlSelect": {"callee_method_names": ["List<String>.add", "FetchImpl<X, Y>.generateSqlSelect", "List<String>.add"], "method_name": "FetchParentImpl.generateSqlSelect", "method_implementation": "{\n    final List<String> selects = Lists.newArrayList();\n    // skip the embeddable mappings\n    if (!(this.getMapping() instanceof EmbeddedMappingImpl)) {\n        selects.add(this.generateSqlSelectImpl(query, selected, root, selectType));\n    }\n    for (final FetchImpl<X, ?> fetch : this.fetches.values()) {\n        final String select = fetch.generateSqlSelect(query, selected, false);\n        if (StringUtils.isNotBlank(select)) {\n            selects.add(select);\n        }\n    }\n    return Joiner.on(\",\\n\").join(selects);\n}", "repo_id": "1", "comment": "/**\n * Returns the generated SQL fragment.\n *\n * @param query\n *            the query\n * @param selected\n *            if the item is selected\n * @param root\n *            if the generation is at root\n * @param selectType\n *            the select type\n * @return the generated SQL fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 816, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean, boolean, MapSelectType)"}, "FetchParentImpl.getAlias": {"callee_method_names": ["BaseQueryImpl<?>.generateTableAlias"], "method_name": "FetchParentImpl.getAlias", "method_implementation": "{\n    if (this.alias == null) {\n        this.alias = query.generateTableAlias(this.entity != null);\n    }\n    return this.alias;\n}", "repo_id": "1", "comment": "/**\n * Returns the alias of the fetch.\n *\n * @param query\n *            the query\n * @return the alias of the fetch\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 817, "method_signature": "String getAlias(BaseQueryImpl)"}, "FetchParentImpl.getAssociatedId": {"callee_method_names": ["SingularAssociationMappingImpl<?,?>.getForeignKey", "HashMap<AbstractColumn, String>.put", "SingularAssociationMappingImpl<?,?>.getType"], "method_name": "FetchParentImpl.getAssociatedId", "method_implementation": "{\n    final HashMap<AbstractColumn, String> translatedIdFields = Maps.newHashMap();\n    for (final JoinColumn joinColumn : mapping.getForeignKey().getJoinColumns()) {\n        String field = null;\n        if (!joinColumn.isVirtual()) {\n            field = this.joinFields.get(joinColumn);\n        } else {\n            final AbstractColumn masterColumn = joinColumn.getMasterColumn();\n            for (int i = 0; i < this.columns.length; i++) {\n                if (this.columns[i] == masterColumn) {\n                    field = this.fields[i];\n                    break;\n                }\n            }\n        }\n        translatedIdFields.put(joinColumn.getReferencedColumn(), field);\n    }\n    return mapping.getType().getId(session, row, translatedIdFields);\n}", "repo_id": "1", "comment": "/**\n * creates a managed Id using joinColumns instead of Id Columns\n *\n * @param session\n * @param row\n *            Sql result row\n * @param mapping\n *            the singular mapping\n * @return managedId\n *\n * @throws SQLException\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 818, "method_signature": "ManagedId<?> getAssociatedId(SessionImpl, ResultSet, SingularAssociationMappingImpl)"}, "FetchParentImpl.getFetches": {"callee_method_names": ["Set<Fetch<X, ?>>.addAll"], "method_name": "FetchParentImpl.getFetches", "method_implementation": "{\n    final Set<Fetch<X, ?>> _fetches = Sets.newHashSet();\n    _fetches.addAll(this.fetches.values());\n    return _fetches;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 819, "method_signature": "Set<Fetch<X,?>> getFetches()"}, "FetchParentImpl.getInstance": {"callee_method_ids": [487, 491, 492], "callee_method_names": ["SessionImpl.get", "ManagedInstance<Y>.getInstance", "ManagedInstance<Y>.getInstance", "EnhancedInstance.__enhanced__$$__isInitialized", "SessionImpl.lazyInstanceLoading", "EnhancedInstance.__enhanced__$$__setInitialized", "ResultSet.getObject", "EntityTypeImpl<Y>.getManagedInstanceById", "SessionImpl.put"], "method_name": "FetchParentImpl.getInstance", "method_implementation": "{\n    // get the id of for the instance\n    final ManagedId<X> managedId = this.entity.getId(session, row, this.idFields);\n    if (managedId == null) {\n        return null;\n    }\n    // look for it in the session\n    ManagedInstance<Y> instance = session.get(managedId);\n    // if found then return it\n    if (instance != null) {\n        // if it is a new instance simply return it\n        if (!(instance.getInstance() instanceof EnhancedInstance)) {\n            return instance;\n        }\n        final EnhancedInstance enhancedInstance = (EnhancedInstance) instance.getInstance();\n        // if it is a lazy instance mark as loading and initialize\n        if (!enhancedInstance.__enhanced__$$__isInitialized()) {\n            this.initializeInstance(session, row, instance);\n            session.lazyInstanceLoading(instance);\n            enhancedInstance.__enhanced__$$__setInitialized();\n        }\n        return instance;\n    }\n    // if no inheritance then initialize and return\n    if (this.entity.getInheritanceType() == null) {\n        instance = (ManagedInstance<Y>) this.entity.getManagedInstanceById(session, managedId, false);\n    } else // inheritance is in place then locate the correct child type\n    {\n        final String discriminatorValue = row.getObject(this.discriminatorAlias).toString();\n        // check if we have a legal discriminator value\n        final EntityTypeImpl<Y> effectiveType = (EntityTypeImpl<Y>) this.entity.getChildType(discriminatorValue);\n        if (effectiveType == null) {\n            throw new IllegalArgumentException(\"Discriminator \" + discriminatorValue + \" not found in the type \" + this.entity.getName());\n        }\n        // initialize and return\n        instance = effectiveType.getManagedInstanceById(session, (ManagedId<Y>) managedId, false);\n    }\n    this.initializeInstance(session, row, instance);\n    session.put(instance);\n    return instance;\n}", "repo_id": "1", "comment": "/**\n * Returns the managed instance based on the id.\n *\n * @param session\n *            the session\n * @param row\n *            the data row\n * @return the managed instance or null if the id is null\n * @throws SQLException\n *             thrown in case of an underlying SQL Error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 820, "method_signature": "ManagedInstance<Y> getInstance(SessionImpl, ResultSet)"}, "FetchParentImpl.getPrimaryTableAlias": {"callee_method_names": [], "method_name": "FetchParentImpl.getPrimaryTableAlias", "method_implementation": "{\n    if (this.primaryTableAlias == null) {\n        this.primaryTableAlias = this.getAlias(query) + \"_P\";\n    }\n    return this.primaryTableAlias;\n}", "repo_id": "1", "comment": "/**\n * Returns the alias of the primary table.\n *\n * @param query\n *            the query\n * @return the alias of the primary table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 821, "method_signature": "String getPrimaryTableAlias(BaseQueryImpl)"}, "FetchParentImpl.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.isQuery", "List<String>.add", "BasicColumn.getName", "List<String>.add", "BasicColumn.getName", "ElementCollectionMappingImpl<?, ?, ?>.getCollectionTable", "CollectionTable.getElementColumn", "List<String>.add", "ElementColumn.getName", "List<String>.toArray", "List<String>.size"], "method_name": "FetchParentImpl.getSqlRestrictionFragments", "method_implementation": "{\n    final List<String> restrictions = Lists.newArrayList();\n    if (this.entity != null) {\n        for (final AbstractColumn column : this.entity.getRootType().getPrimaryTable().getPkColumns()) {\n            if (query.isQuery()) {\n                restrictions.add(this.getPrimaryTableAlias(query) + \".\" + column.getName());\n            } else {\n                restrictions.add(column.getName());\n            }\n        }\n    }\n    if (this.mapping instanceof ElementCollectionMappingImpl) {\n        final ElementCollectionMappingImpl<?, ?, ?> elementCollectionMapping = (ElementCollectionMappingImpl<?, ?, ?>) this.mapping;\n        final CollectionTable collectionTable = elementCollectionMapping.getCollectionTable();\n        final ElementColumn elementColumn = collectionTable.getElementColumn();\n        restrictions.add(this.getPrimaryTableAlias(query) + \".\" + elementColumn.getName());\n    }\n    return restrictions.toArray(new String[restrictions.size()]);\n}", "repo_id": "1", "comment": "/**\n * Returns the SQL restriction in pairs of table alias and column.\n *\n * @param query\n *            the query\n * @param selectType\n *            the select type\n * @return the SQL restriction in pairs of table alias and column\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 822, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl, MapSelectType)"}, "FetchParentImpl.getTableAlias": {"callee_method_names": [], "method_name": "FetchParentImpl.getTableAlias", "method_implementation": "{\n    if (table instanceof SecondaryTable) {\n        String _alias = this.tableAliases.get(table);\n        if (_alias == null) {\n            _alias = this.alias + \"_S\" + this.nextTableAlias++;\n            this.tableAliases.put((SecondaryTable) table, _alias);\n        }\n        return _alias;\n    }\n    return this.getPrimaryTableAlias(query);\n}", "repo_id": "1", "comment": "/**\n * Returns the alias for the table.\n * <p>\n * if table does not have an alias, it is generated.\n *\n * @param query\n *            the query\n * @param table\n *            the table\n * @return the alias for the table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 823, "method_signature": "String getTableAlias(BaseQueryImpl, AbstractTable)"}, "FetchParentImpl.handleElementFetch": {"callee_method_names": ["ElementCollectionMappingImpl<? super X, ?, ?>.getCollectionTable", "ElementCollectionMappingImpl<? super X, ?, ?>.getCollectionTable", "ResultSet.getObject", "ResultSet.getObject"], "method_name": "FetchParentImpl.handleElementFetch", "method_implementation": "{\n    if ((selectType == MapSelectType.VALUE) || !this.mapping.isMap()) {\n        return new EntryImpl<Object, X>(null, this.handleElement(row));\n    }\n    if (this.keyColumnAlias != null) {\n        if (this.keyColumn == null) {\n            @SuppressWarnings(\"unchecked\")\n            final ElementCollectionMappingImpl<? super X, ?, ?> _mapping = (ElementCollectionMappingImpl<? super X, ?, ?>) this.mapping;\n            if (_mapping.getCollectionTable() != null) {\n                this.keyColumn = _mapping.getCollectionTable().getKeyColumn();\n            }\n        }\n        final Object object = (this.keyColumn != null) ? this.keyColumn.convertValueForSet(row.getObject(this.keyColumnAlias)) : row.getObject(this.keyColumnAlias);\n        if (selectType == MapSelectType.KEY) {\n            return new EntryImpl<Object, X>(object, null);\n        } else {\n            return new EntryImpl<Object, X>(object, this.handleElement(row));\n        }\n    }\n    final X value = this.handleElement(row);\n    final Object key = ((ElementCollectionMappingImpl<? super Z, ?, X>) this.mapping).extractKey(value);\n    return new EntryImpl<Object, X>(key, value);\n}", "repo_id": "1", "comment": "/**\n * Handles the row\n *\n * @param row\n *            the row\n * @param selectType\n *            the select type\n * @return the collection element\n * @throws SQLException\n *             thrown in case of an underlying SQL Error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 824, "method_signature": "EntryImpl<Object,X> handleElementFetch(ResultSet, MapSelectType)"}, "FetchParentImpl.handleFetch": {"callee_method_names": ["ManagedInstance<? extends X>.isRefreshing", "ManagedInstance<? extends X>.isLoading", "ManagedInstance<? extends X>.getInstance", "ResultSet.getObject", "ManagedInstance<? extends X>.getInstance"], "method_name": "FetchParentImpl.handleFetch", "method_implementation": "{\n    // if instance is null then break\n    final ManagedInstance<? extends X> instance = this.getInstance(session, row);\n    if (instance == null) {\n        return null;\n    }\n    // if instance is refreshing then re-initialize instance\n    if (instance.isRefreshing()) {\n        this.initializeInstance(session, row, instance);\n    }\n    // if the instance is loading then continue processing\n    if (instance.isLoading()) {\n        this.handleFetches(session, row, instance.getInstance());\n    }\n    if ((selectType == MapSelectType.VALUE) || (this.mapping == null) || !this.mapping.isMap()) {\n        return new EntryImpl<Object, ManagedInstance<?>>(null, instance);\n    }\n    if (this.keyColumnAlias != null) {\n        final Object key = row.getObject(this.keyColumnAlias);\n        return new EntryImpl<Object, ManagedInstance<?>>(key, instance);\n    }\n    final Object key = this.mapping.extractKey(instance.getInstance());\n    return new EntryImpl<Object, ManagedInstance<?>>(key, instance);\n}", "repo_id": "1", "comment": "/**\n * Handles the row.\n *\n * @param session\n *            the session\n * @param row\n *            the current row\n * @param selectType\n *            the map select type\n * @return the instance\n * @throws SQLException\n *             thrown in case of an underlying SQL Error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 825, "method_signature": "EntryImpl<Object,ManagedInstance<?>> handleFetch(SessionImpl, ResultSet, MapSelectType)"}, "FetchParentImpl.ignoreJoin": {"callee_method_names": ["SingularAssociationMappingImpl<?,?>.getInverse", "SingularAssociationMappingImpl<?,?>.getInverse", "FetchImpl<X, Y>.getMapping"], "method_name": "FetchParentImpl.ignoreJoin", "method_implementation": "{\n    // if we are joined on this mapping then ignore\n    if ((mapping.getInverse() != null) && (mapping.getInverse() == this.getMapping())) {\n        return true;\n    }\n    // if we will join on that mapping then ignore\n    for (final FetchImpl<X, ?> fetch : this.fetches.values()) {\n        if (fetch.getMapping() == mapping) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Returns if the join should be ignored\n *\n * @param mapping\n *            the mapping\n * @return true if the join should be ignored, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 826, "method_signature": "boolean ignoreJoin(SingularAssociationMappingImpl)"}, "FetchParentImpl.join": {"callee_method_names": [], "method_name": "FetchParentImpl.join", "method_implementation": "{\n    final AbstractMapping<?, ?, ?> _mapping = this.getMapping(attributeName);\n    if (!(_mapping instanceof JoinedMapping)) {\n        throw new IllegalArgumentException(\"Cannot dereference attribute \" + attributeName);\n    }\n    final FetchImpl<X, Y> fetch = new FetchImpl<X, Y>(this, (JoinedMapping<? super X, ?, Y>) _mapping, jt);\n    this.joins.add(fetch);\n    return fetch;\n}", "repo_id": "1", "comment": "/**\n * Joins instead of fetch.\n *\n * @param attributeName\n *            the name of the attribute\n * @param jt\n *            the join type\n * @param <Y>\n *            the type of the return join\n * @return the fetch for the join\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 827, "method_signature": "FetchImpl<X,Y> join(String, JoinType)"}, "FetchStrategyTest.init": {"callee_method_names": [], "method_name": "FetchStrategyTest.init", "method_implementation": "{\n    FetchStrategyTest.TR = new Country(1, \"Turkey\");\n    FetchStrategyTest.USA = new Country(2, \"USA\");\n    FetchStrategyTest.UK = new Country(3, \"UK\");\n    FetchStrategyTest.ISTANBUL = new City(1, \"ISTANBUL\", FetchStrategyTest.TR);\n    FetchStrategyTest.NEWYORK = new City(2, \"NEWYORK\", FetchStrategyTest.USA);\n    FetchStrategyTest.LONDON = new City(3, \"LONDON\", FetchStrategyTest.UK);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2299, "method_signature": "void init()"}, "FetchStrategyTest.prepareCountries": {"callee_method_names": [], "method_name": "FetchStrategyTest.prepareCountries", "method_implementation": "{\n    this.persist(FetchStrategyTest.TR);\n    this.persist(FetchStrategyTest.USA);\n    this.persist(FetchStrategyTest.UK);\n    this.persist(FetchStrategyTest.ISTANBUL);\n    this.persist(FetchStrategyTest.NEWYORK);\n    this.persist(FetchStrategyTest.LONDON);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2300, "method_signature": "void prepareCountries()"}, "FetchStrategyTest.testFind": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses", "Person.getAddresses", "Address.getCity", "Address.getCity"], "method_name": "FetchStrategyTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n    for (final Address address : person2.getAddresses()) {\n        if (\"ISTANBUL\".equals(address.getCity().getName())) {\n            Assert.assertEquals(address.getCity().getCountry().getId(), FetchStrategyTest.TR.getId());\n            break;\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2301, "method_signature": "void testFind()"}, "FetchTest.testEmpty": {"callee_method_names": ["Manager.getId", "TypedQuery<Integer>.getSingleResult", "Manager.getId", "TypedQuery<Integer>.getSingleResult"], "method_name": "FetchTest.testEmpty", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    this.persist(qa);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager qaManager2 = new Manager(\"Manager2\", qa, 100000);\n    this.persist(qaManager);\n    this.persist(qaManager2);\n    final Employee employee1 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", qaManager, qa, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    this.commit();\n    this.close();\n    TypedQuery<Integer> q;\n    q = this.cq(\"select m.id from Manager m where m.employees is empty\", Integer.class);\n    Assert.assertEquals(qaManager2.getId(), q.getSingleResult());\n    q = this.cq(\"select m.id from Manager m where m.employees is not empty\", Integer.class);\n    Assert.assertEquals(qaManager.getId(), q.getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2356, "method_signature": "void testEmpty()"}, "FetchTest.testExists": {"callee_method_ids": [2367, 2367, 2367], "callee_method_names": ["Employee.setName", "Employee.setName", "Employee.setName", "Employee.setName", "Manager.setName", "Manager.setName", "Employee.setManager", "Employee.setManager", "Employee.setManager", "TypedQuery<Integer>.getResultList", "TypedQuery<Integer>.getResultList"], "method_name": "FetchTest.testExists", "method_implementation": "{\n    final Employee employee1 = new Employee();\n    employee1.setName(\"Employee1\");\n    final Employee employee2 = new Employee();\n    employee2.setName(\"Employee2\");\n    final Employee employee3 = new Employee();\n    employee3.setName(\"Employee3\");\n    final Employee employee4 = new Employee();\n    employee4.setName(\"Employee4\");\n    final Manager manager1 = new Manager();\n    manager1.setName(\"Manager1\");\n    final Manager manager2 = new Manager();\n    manager2.setName(\"Manager2\");\n    employee1.setManager(manager1);\n    employee2.setManager(manager1);\n    employee4.setManager(manager2);\n    this.persist(employee1);\n    this.persist(employee2);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(manager1);\n    this.persist(manager2);\n    this.commit();\n    TypedQuery<Integer> q;\n    q = this.cq(\"select e.id from Employee e where exists (select m from Manager m where e.manager = m) order by e.id\", Integer.class);\n    Assert.assertEquals(\"[1, 2, 4]\", q.getResultList().toString());\n    q = this.cq(\"select e.id from Employee e where not exists (select m.id from Manager m where e.manager = m)\", Integer.class);\n    Assert.assertEquals(\"[3]\", q.getResultList().toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2357, "method_signature": "void testExists()"}, "FetchTest.testMemberOf": {"callee_method_names": ["TypedQuery<Integer>.getSingleResult"], "method_name": "FetchTest.testMemberOf", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    final Department rnd = new Department(\"RND\");\n    this.persist(qa);\n    this.persist(rnd);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager rndManager = new Manager(\"Manager2\", rnd, 100000);\n    this.persist(rndManager);\n    this.persist(qaManager);\n    final Employee employee1 = new Employee(\"Employee1\", rndManager, rnd, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", rndManager, rnd, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    final Employee employee3 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee4 = new Employee(\"Employee2\", qaManager, qa, 110000);\n    final Employee employee5 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee6 = new Employee(\"Employee2\", null, qa, 90000);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(employee5);\n    this.persist(employee6);\n    this.commit();\n    TypedQuery<Integer> q;\n    q = this.cq(\"select m.id from Manager m where :p member of m.employees\", Integer.class).setParameter(\"p\", employee1);\n    Assert.assertEquals((Integer) 3, q.getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2359, "method_signature": "void testMemberOf()"}, "FetchTest.testSize": {"callee_method_ids": [2367, 2367, 2367], "callee_method_names": ["Employee.setName", "Employee.setName", "Employee.setName", "Employee.setName", "Manager.setName", "Manager.setName", "Employee.setManager", "Employee.setManager", "Employee.setManager"], "method_name": "FetchTest.testSize", "method_implementation": "{\n    final Employee employee1 = new Employee();\n    employee1.setName(\"Employee1\");\n    final Employee employee2 = new Employee();\n    employee2.setName(\"Employee2\");\n    final Employee employee3 = new Employee();\n    employee3.setName(\"Employee3\");\n    final Employee employee4 = new Employee();\n    employee4.setName(\"Employee4\");\n    final Manager manager1 = new Manager();\n    manager1.setName(\"Manager1\");\n    final Manager manager2 = new Manager();\n    manager2.setName(\"Manager2\");\n    employee1.setManager(manager1);\n    employee2.setManager(manager1);\n    employee4.setManager(manager2);\n    this.persist(employee1);\n    this.persist(employee2);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(manager1);\n    this.persist(manager2);\n    this.commit();\n    Assert.assertEquals(2, this.cq(\"select size(m.employees) from Manager m where size(m.employees) = 2\", Number.class).getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2360, "method_signature": "void testSize()"}, "FetchTest.testSubQuery": {"callee_method_names": ["Employee.getId", "TypedQuery<Number>.getSingleResult"], "method_name": "FetchTest.testSubQuery", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    final Department rnd = new Department(\"RND\");\n    this.persist(qa);\n    this.persist(rnd);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager rndManager = new Manager(\"Manager2\", rnd, 100000);\n    this.persist(rndManager);\n    this.persist(qaManager);\n    final Employee employee1 = new Employee(\"Employee1\", rndManager, rnd, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", rndManager, rnd, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    final Employee employee3 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee4 = new Employee(\"Employee2\", qaManager, qa, 110000);\n    final Employee employee5 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee6 = new Employee(\"Employee2\", qaManager, qa, 90000);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(employee5);\n    this.persist(employee6);\n    this.commit();\n    TypedQuery<Number> q;\n    q = this.cq(\"select e.id from Employee e where e.salary > (select m.salary from Manager m where m.department = e.department)\", Number.class);\n    Assert.assertEquals(employee4.getId(), q.getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2361, "method_signature": "void testSubQuery()"}, "FetchTest.testfetche": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Employee>.from", "CriteriaQueryImpl<Employee>.select", "List<Employee>.size"], "method_name": "FetchTest.testfetche", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    final Department rnd = new Department(\"RND\");\n    this.persist(qa);\n    this.persist(rnd);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager rndManager = new Manager(\"Manager2\", rnd, 100000);\n    final Manager qaManager2 = new Manager(\"Manager3\", qa, 80000);\n    this.persist(rndManager);\n    this.persist(qaManager);\n    this.persist(qaManager2);\n    final Employee employee1 = new Employee(\"Employee1\", rndManager, rnd, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", rndManager, rnd, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    final Employee employee3 = new Employee(\"Employee3\", qaManager, qa, 90000);\n    final Employee employee4 = new Employee(\"Employee4\", qaManager, qa, 110000);\n    final Employee employee5 = new Employee(\"Employee5\", qaManager, qa, 90000);\n    final Employee employee6 = new Employee(\"Employee6\", qaManager, qa, 90000);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(employee5);\n    this.persist(employee6);\n    this.commit();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Employee> q = cb.createQuery(Employee.class);\n    final RootImpl<Employee> r = q.from(Employee.class);\n    q.select(r);\n    // r.join(\"manager\");\n    // r.fetch(\"manager\").fetch(\"employees\");\n    // r.fetch(\"department\");\n    // final Join<Employee, Manager> a = r.join(\"manager\");\n    // a.fetch(\"person\");\n    // a.fetch(\"manager\");\n    final List<Employee> resultList = this.em().createQuery(q).getResultList();\n    for (final Employee emp : resultList) {\n        System.out.println(emp.getManager().getDepartment().getName());\n    }\n    Assert.assertEquals(6, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2358, "method_signature": "void testfetche()"}, "FieldAccessor.get": {"callee_method_names": [], "method_name": "FieldAccessor.get", "method_implementation": "{\n    try {\n        return this.field.get(instance);\n    } catch (final Exception e) {\n        throw new BatooException(\"Cannot get field value: \" + this.field, e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 3, "method_signature": "Object get(Object)"}, "FieldAccessor.getPrimitiveType": {"callee_method_names": ["Class<?>.isPrimitive"], "method_name": "FieldAccessor.getPrimitiveType", "method_implementation": "{\n    final Class<?> type = this.field.getType();\n    if (type.isPrimitive()) {\n        for (final PrimitiveType primitiveType : PrimitiveType.values()) {\n            if (primitiveType.clazz == type) {\n                return primitiveType;\n            }\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * @return\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 4, "method_signature": "PrimitiveType getPrimitiveType()"}, "FieldAccessor.set": {"callee_method_names": ["Object.getClass"], "method_name": "FieldAccessor.set", "method_implementation": "{\n    if (instance == null) {\n        throw new NullPointerException();\n    }\n    try {\n        if (this.primitiveType == null) {\n            if ((this.numberType != null) && (value != null) && (this.numberType != value.getClass())) {\n                final Number number = ReflectHelper.convertNumber((Number) value, this.numberType);\n                this.field.set(instance, number);\n            } else {\n                this.field.set(instance, value);\n            }\n        } else {\n            switch(this.primitiveType) {\n                case BOOLEAN:\n                    if (value instanceof Number) {\n                        this.field.set(instance, ((Number) value).byteValue() == 0 ? false : true);\n                    } else {\n                        this.field.set(instance, value);\n                    }\n                    break;\n                case INTEGER:\n                    this.field.set(instance, value);\n                    break;\n                case FLOAT:\n                    this.field.set(instance, ((Number) value).floatValue());\n                    break;\n                case DOUBLE:\n                    this.field.set(instance, value);\n                    break;\n                case LONG:\n                    this.field.set(instance, value);\n                    break;\n                case SHORT:\n                    this.field.set(instance, ((Number) value).shortValue());\n                    break;\n                case BYTE:\n                    this.field.set(instance, ((Number) value).byteValue());\n                    break;\n                default:\n                    // CHAR\n                    if (value == null) {\n                        this.field.set(instance, '\\u0000');\n                    } else {\n                        this.field.set(instance, value);\n                    }\n                    break;\n            }\n        }\n    } catch (final Exception e) {\n        throw new RuntimeException(\"Cannot set field value: \" + this.field, e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 5, "method_signature": "void set(Object, Object)"}, "FieldResultElement.generate": {"callee_method_names": [], "method_name": "FieldResultElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n    this.column = this.getAttribute(ElementConstants.ATTR_COLUMN, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1073, "method_signature": "void generate()"}, "Foo.equals": {"callee_method_names": [], "method_name": "Foo.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (!super.equals(obj)) {\n        return false;\n    }\n    if (!(obj instanceof Foo)) {\n        return false;\n    }\n    final Foo other = (Foo) obj;\n    if (this.fooValue == null) {\n        if (other.fooValue != null) {\n            return false;\n        }\n    } else if (!this.fooValue.equals(other.fooValue)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2484, "method_signature": "boolean equals(Object)"}, "Foo.hashCode": {"callee_method_names": [], "method_name": "Foo.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.key == null) ? 0 : this.key.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2219, "method_signature": "int hashCode()"}, "Foo1.setFoo2": {"callee_method_names": [], "method_name": "Foo1.setFoo2", "method_implementation": "{\n    if (this.foo2 != null) {\n        this.foo2.setFoo1(null);\n    }\n    this.foo2 = foo2;\n    if (this.foo2 != null) {\n        this.foo2.setFoo1(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the foo2 of the Foo1.\n *\n * @param foo2\n *            the foo2 to set for Foo1\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2158, "method_signature": "void setFoo2(Foo2)"}, "FooListener.postLoad": {"callee_method_names": [], "method_name": "FooListener.postLoad", "method_implementation": "{\n    final String string = \"listener1PostLoad\";\n    this.update(instance, string);\n}", "repo_id": "1", "comment": "/**\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2417, "method_signature": "void postLoad(Object)"}, "FooListener.postPersist": {"callee_method_names": [], "method_name": "FooListener.postPersist", "method_implementation": "{\n    final String string = \"listener1PostPersist\";\n    this.update(instance, string);\n}", "repo_id": "1", "comment": "/**\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2418, "method_signature": "void postPersist(Object)"}, "FooListener.postRemove": {"callee_method_names": [], "method_name": "FooListener.postRemove", "method_implementation": "{\n    final String string = \"listener1PostRemove\";\n    this.update(instance, string);\n}", "repo_id": "1", "comment": "/**\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2419, "method_signature": "void postRemove(Object)"}, "FooListener.preLoad": {"callee_method_names": [], "method_name": "FooListener.preLoad", "method_implementation": "{\n    final String string = \"listener1PostUpdate\";\n    this.update(instance, string);\n}", "repo_id": "1", "comment": "/**\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2420, "method_signature": "void preLoad(Object)"}, "FooListener.prePersist": {"callee_method_names": [], "method_name": "FooListener.prePersist", "method_implementation": "{\n    final String string = \"listener1PrePersist\";\n    this.update(instance, string);\n}", "repo_id": "1", "comment": "/**\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2421, "method_signature": "void prePersist(Object)"}, "FooListener.preRemove": {"callee_method_names": [], "method_name": "FooListener.preRemove", "method_implementation": "{\n    final String string = \"listener1PreRemove\";\n    this.update(instance, string);\n}", "repo_id": "1", "comment": "/**\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2422, "method_signature": "void preRemove(Object)"}, "FooListener.preUpdate": {"callee_method_names": [], "method_name": "FooListener.preUpdate", "method_implementation": "{\n    final String string = \"listener1PreUpdate\";\n    this.update(instance, string);\n}", "repo_id": "1", "comment": "/**\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2423, "method_signature": "void preUpdate(Object)"}, "FooPk.equals": {"callee_method_names": ["Object.getClass"], "method_name": "FooPk.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final FooPk other = (FooPk) obj;\n    if (this.intKey == null) {\n        if (other.intKey != null) {\n            return false;\n        }\n    } else if (!this.intKey.equals(other.intKey)) {\n        return false;\n    }\n    if (this.strKey == null) {\n        if (other.strKey != null) {\n            return false;\n        }\n    } else if (!this.strKey.equals(other.strKey)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2185, "method_signature": "boolean equals(Object)"}, "FooPk.hashCode": {"callee_method_names": [], "method_name": "FooPk.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.intKey == null) ? 0 : this.intKey.hashCode());\n    result = (prime * result) + ((this.strKey == null) ? 0 : this.strKey.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2186, "method_signature": "int hashCode()"}, "ForeignKey.createDestinationJoin": {"callee_method_names": [], "method_name": "ForeignKey.createDestinationJoin", "method_implementation": "{\n    if (this.inverseOwner) {\n        return this.createSourceJoin(joinType, parentAlias, alias);\n    }\n    return this.createJoin(joinType, parentAlias, alias, this.joinColumns.get(0).getReferencedTable().getQName(), false);\n}", "repo_id": "1", "comment": "/**\n * Creates the join for destination foreign keys.\n *\n * @param joinType\n *            the type of the join\n * @param parentAlias\n *            the alias of the parent table\n * @param alias\n *            the alias of the table\n * @return the join SQL fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1206, "method_signature": "String createDestinationJoin(JoinType, String, String)"}, "ForeignKey.getAllChildrenSql": {"callee_method_names": ["List<JoinColumn>.add", "List<JoinColumn>.toArray", "List<JoinColumn>.size"], "method_name": "ForeignKey.getAllChildrenSql", "method_implementation": "{\n    FinalWrapper<String> wrapper = this.allChildrenSql;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.allChildrenSql == null) {\n                final List<JoinColumn> allChildrenRestrictions = Lists.newArrayList();\n                final String updates = Joiner.on(\", \").join(Lists.transform(this.joinColumns, new Function<JoinColumn, String>() {\n\n                    @Override\n                    public String apply(JoinColumn input) {\n                        return input.getName() + \" = NULL\";\n                    }\n                }));\n                final String restrictions = Joiner.on(\", \").join(Lists.transform(this.joinColumns, new Function<JoinColumn, String>() {\n\n                    @Override\n                    public String apply(JoinColumn input) {\n                        allChildrenRestrictions.add(input);\n                        return input.getName() + \" = ?\";\n                    }\n                }));\n                final String order;\n                if (this.orderColumn != null) {\n                    order = \", \" + this.orderColumn.getName() + \" = NULL\";\n                } else {\n                    order = \"\";\n                }\n                this.allChildrenRestrictions = allChildrenRestrictions.toArray(new JoinColumn[allChildrenRestrictions.size()]);\n                this.allChildrenSql = new FinalWrapper<String>(\"UPDATE \" + this.table.getQName() + \"\\nSET \" + updates + order + \"\\nWHERE \" + restrictions);\n            }\n            wrapper = this.allChildrenSql;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the single child SQL.\n *\n * @return the single child SQL\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1207, "method_signature": "String getAllChildrenSql()"}, "ForeignKey.getName": {"callee_method_names": ["E.getName", "E.getName", "List<JoinColumn>.get", "List<JoinColumn>.get", "JoinColumn.getName"], "method_name": "ForeignKey.getName", "method_implementation": "{\n    final List<JoinColumn> columns = Lists.newArrayList(this.joinColumns);\n    // sort the column names for consistent order\n    Collections.sort(columns, new Comparator<JoinColumn>() {\n\n        @Override\n        public int compare(JoinColumn o1, JoinColumn o2) {\n            return o1.getName().compareTo(o2.getName());\n        }\n    });\n    final int prime = 31;\n    int id = 31 * columns.get(0).getReferencedTable().getQName().hashCode();\n    id = 31 * columns.get(0).getTable().getQName().hashCode();\n    for (final JoinColumn joinColumn : columns) {\n        id = (prime * id) + joinColumn.getName().hashCode();\n    }\n    return \"FK_\" + Integer.toHexString(id).toUpperCase();\n}", "repo_id": "1", "comment": "/**\n * Returns a generated name for the foreign key.\n *\n * @return the name of the foreign key\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1208, "method_signature": "String getName()"}, "ForeignKey.getSingleChildSql": {"callee_method_names": ["List<AbstractColumn>.add", "List<AbstractColumn>.add", "EntityTable.getPkColumns", "List<AbstractColumn>.add", "List<AbstractColumn>.toArray", "List<AbstractColumn>.size", "List<AbstractColumn>.toArray", "List<AbstractColumn>.size"], "method_name": "ForeignKey.getSingleChildSql", "method_implementation": "{\n    FinalWrapper<String> wrapper = this.singleChildSql;\n    if (wrapper == null) {\n        synchronized (this) {\n            if (this.singleChildSql == null) {\n                final List<AbstractColumn> singleChildRestrictions = Lists.newArrayList();\n                final List<AbstractColumn> singleChildUpdates = Lists.newArrayList();\n                final String updates = Joiner.on(\", \").join(Lists.transform(this.joinColumns, new Function<JoinColumn, String>() {\n\n                    @Override\n                    public String apply(JoinColumn input) {\n                        singleChildUpdates.add(input);\n                        return input.getName() + \" = ?\";\n                    }\n                }));\n                final String order;\n                if (this.orderColumn != null) {\n                    singleChildUpdates.add(this.orderColumn);\n                    order = \", \" + this.orderColumn.getName() + \" = ?\";\n                } else {\n                    order = \"\";\n                }\n                final EntityTable table = (EntityTable) this.table;\n                final String restrictions = Joiner.on(\" AND \").join(Collections2.transform(table.getPkColumns(), new Function<AbstractColumn, String>() {\n\n                    @Override\n                    public String apply(AbstractColumn input) {\n                        singleChildRestrictions.add(input);\n                        return input.getName() + \" = ?\";\n                    }\n                }));\n                this.singleChildRestrictions = singleChildRestrictions.toArray(new AbstractColumn[singleChildRestrictions.size()]);\n                this.singleChildUpdates = singleChildUpdates.toArray(new AbstractColumn[singleChildUpdates.size()]);\n                this.singleChildSql = new FinalWrapper<String>(\"UPDATE \" + this.table.getQName() + \"\\nSET \" + updates + order + \"\\nWHERE \" + restrictions);\n            }\n            wrapper = this.singleChildSql;\n        }\n    }\n    return wrapper.value;\n}", "repo_id": "1", "comment": "/**\n * Returns the single child SQL.\n *\n * @return the single child SQL\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1209, "method_signature": "String getSingleChildSql()"}, "ForeignKey.isReadOnly": {"callee_method_names": [], "method_name": "ForeignKey.isReadOnly", "method_implementation": "{\n    for (final JoinColumnMetadata columnMetadata : metadata) {\n        if (!columnMetadata.isUpdatable() && !columnMetadata.isInsertable()) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Returns if the foreign key is read only.\n *\n * @param metadata\n *            the metadata\n * @return if the foreign key is read only\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1210, "method_signature": "boolean isReadOnly(List)"}, "ForeignKey.link": {"callee_method_names": ["SingularAssociationMapping<?, ?>.getMapsId", "SingularAssociationMapping<?, ?>.getRoot", "EntityTypeDescriptor.hasSingleIdAttribute", "EntityTypeDescriptor.getIdMapping", "AssociationMapping<?,?,?>.getLocator", "EntityTypeDescriptor.getIdMapping", "String.isEmpty", "EmbeddedMapping<?, ?>.getChild", "EmbeddedMapping<?, ?>.getChild", "AssociationMapping<?,?,?>.getName", "AssociationMapping<?,?,?>.getLocator", "EntityTypeDescriptor.hasSingleIdAttribute", "EntityTypeDescriptor.getIdMapping", "EntityTypeDescriptor.getIdClass", "Class<?>.getName", "AssociationMapping<?,?,?>.getLocator", "EntityTypeDescriptor.hasSingleIdAttribute", "EntityTypeDescriptor.getIdMapping", "EntityTypeDescriptor.getIdMappings", "AssociationMapping<?,?,?>.getRoot"], "method_name": "ForeignKey.link", "method_implementation": "{\n    if (mapping instanceof SingularAssociationMapping) {\n        final SingularAssociationMapping<?, ?> singularAssociationMapping = (SingularAssociationMapping<?, ?>) mapping;\n        final String mapsId = singularAssociationMapping.getMapsId();\n        if (mapsId != null) {\n            final EntityTypeDescriptor type = (EntityTypeDescriptor) singularAssociationMapping.getRoot().getTypeDescriptor();\n            if (!type.hasSingleIdAttribute() || !(type.getIdMapping() instanceof EmbeddedMapping)) {\n                throw new MappingException(\"MapsId can only be used in combination with EmbeddedId\", mapping.getLocator());\n            }\n            final EmbeddedMapping<?, ?> embeddedMapping = (EmbeddedMapping<?, ?>) type.getIdMapping();\n            if (!mapsId.isEmpty()) {\n                this.masterMapping = embeddedMapping.getChild(mapsId);\n            } else {\n                this.masterMapping = embeddedMapping.getChild(mapping.getName());\n            }\n            if (this.masterMapping == null) {\n                throw new MappingException(\"Cannot locate the mapping declared by MapsId \" + mapsId, mapping.getLocator());\n            }\n            final Class<?> idClass = targetEntity.hasSingleIdAttribute() ? targetEntity.getIdMapping().getJavaType() : targetEntity.getIdClass();\n            if (idClass != this.masterMapping.getJavaType()) {\n                throw new MappingException(\"MapsId mapped attribute type \" + this.masterMapping.getJavaType().getName() + \" is not compatible with target entity primary key type \" + idClass.getName(), mapping.getLocator());\n            }\n        }\n    }\n    // single primary key\n    if (targetEntity.hasSingleIdAttribute()) {\n        this.linkImpl(mapping, targetEntity.getIdMapping());\n    } else // multiple id\n    {\n        for (final Pair<?, AbstractAccessor> pair : targetEntity.getIdMappings()) {\n            this.linkImpl(mapping, (SingularMapping<?, ?>) pair.getFirst());\n        }\n    }\n    if (mapping != null) {\n        final AbstractTable table = ((EntityTypeDescriptor) mapping.getRoot().getTypeDescriptor()).getTable(this.tableName);\n        if (table == null) {\n            throw new MappingException(\"Table \" + this.tableName + \" could not be found\");\n        }\n        this.setTable(table);\n    }\n}", "repo_id": "1", "comment": "/**\n * Links the foreign key.\n *\n * @param mapping\n *            the owner attribute\n * @param targetEntity\n *            the target entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1211, "method_signature": "void link(AssociationMapping, EntityTypeDescriptor)"}, "ForeignKey.performAttachChild": {"callee_method_names": ["AbstractColumn.getValue", "Joinable.getIndex", "AbstractColumn.getValue", "Joinable.getValue"], "method_name": "ForeignKey.performAttachChild", "method_implementation": "{\n    final String sql = this.getSingleChildSql();\n    final Object[] parameters = new Object[this.singleChildUpdates.length + this.singleChildRestrictions.length];\n    for (int i = 0; i < size; i++) {\n        final Joinable joinable = batch[i];\n        int paramIndex = 0;\n        for (final AbstractColumn column : this.singleChildUpdates) {\n            if (column instanceof JoinColumn) {\n                parameters[paramIndex++] = column.getValue(connection, instance);\n            } else {\n                parameters[paramIndex++] = joinable.getIndex();\n            }\n        }\n        for (final AbstractColumn column : this.singleChildRestrictions) {\n            try {\n                parameters[paramIndex++] = column.getValue(connection, joinable.getValue());\n            } catch (final NullPointerException e) {\n                System.out.println(\"\");\n            }\n        }\n        new QueryRunner(this.jdbcAdaptor, false).update(connection, sql, parameters);\n    }\n}", "repo_id": "1", "comment": "/**\n * Attaches the child to the managed instance.\n *\n * @param connection\n *            the connection\n * @param instance\n *            the instance\n * @param batch\n *            the batch of joinables\n * @param size\n *            the size of the batch\n * @throws SQLException\n *             thrown in case of an SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1212, "method_signature": "void performAttachChild(Connection, Object, Joinable[], int)"}, "ForeignKey.performDetachAll": {"callee_method_names": ["AbstractColumn.getValue"], "method_name": "ForeignKey.performDetachAll", "method_implementation": "{\n    final String sql = this.getAllChildrenSql();\n    final Object[] parameters = new Object[this.allChildrenRestrictions.length];\n    int i = 0;\n    for (final AbstractColumn column : this.allChildrenRestrictions) {\n        parameters[i++] = column.getValue(connection, instance);\n    }\n    new QueryRunner(this.jdbcAdaptor, false).update(connection, sql, parameters);\n}", "repo_id": "1", "comment": "/**\n * Detaches the instance from all the children.\n *\n * @param connection\n *            the connection\n * @param instance\n *            the instance\n * @throws SQLException\n *             thrown in case of an SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1213, "method_signature": "void performDetachAll(Connection, Object)"}, "ForeignKey.performDetachChild": {"callee_method_names": ["AbstractColumn.getValue"], "method_name": "ForeignKey.performDetachChild", "method_implementation": "{\n    final String sql = this.getSingleChildSql();\n    final Object[] parameters = new Object[this.singleChildUpdates.length + this.singleChildRestrictions.length];\n    int i = 0;\n    for (final AbstractColumn column : this.singleChildUpdates) {\n        if (column instanceof JoinColumn) {\n            parameters[i++] = null;\n        } else {\n            parameters[i++] = 0;\n        }\n    }\n    for (final AbstractColumn column : this.singleChildRestrictions) {\n        parameters[i++] = column.getValue(connection, child);\n    }\n    new QueryRunner(this.jdbcAdaptor, false).update(connection, sql, parameters);\n}", "repo_id": "1", "comment": "/**\n * Detaches the child.\n *\n * @param connection\n *            the connection\n * @param key\n *            the key object\n * @param child\n *            the child\n * @throws SQLException\n *             thrown in case of an SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1214, "method_signature": "void performDetachChild(Connection, Object, Object)"}, "ForeignKey.setTable": {"callee_method_ids": [1219], "callee_method_names": ["JoinColumn.setTable"], "method_name": "ForeignKey.setTable", "method_implementation": "{\n    this.table = table;\n    for (final JoinColumn joinColumn : this.joinColumns) {\n        joinColumn.setTable(table);\n    }\n    this.table.addForeignKey(this);\n}", "repo_id": "1", "comment": "/**\n * Sets the table of the foreign key.\n *\n * @param table\n *            the table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1215, "method_signature": "void setTable(AbstractTable)"}, "FunctionExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "FunctionExpression.generateJpqlRestriction", "method_implementation": "{\n    return this.function + \"(\" + Joiner.on(\", \").join(Lists.transform(this.arguments, new Function<Expression<?>, String>() {\n\n        @Override\n        public String apply(Expression<?> input) {\n            return ((AbstractExpression<?>) input).generateJpqlRestriction(query);\n        }\n    })) + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 645, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "FunctionExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "FunctionExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 646, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "FunctionExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "FunctionExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 647, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "FunctionExpression.getSqlRestrictionFragments": {"callee_method_names": ["String.startsWith", "String.substring", "String.length"], "method_name": "FunctionExpression.getSqlRestrictionFragments", "method_implementation": "{\n    return new String[] { this.function + Joiner.on(\"\").join(Lists.transform(this.arguments, new Function<Expression<?>, String>() {\n\n        @Override\n        public String apply(Expression<?> input) {\n            if (input instanceof SimpleConstantExpression) {\n                final String result = ((AbstractExpression<?>) input).getSqlRestrictionFragments(query)[0];\n                if (result.startsWith(\"'\")) {\n                    return result.substring(1, result.length() - 1);\n                }\n                return result;\n            }\n            return ((AbstractExpression<?>) input).getSqlRestrictionFragments(query)[0];\n        }\n    })) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 648, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "FunctionExpression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "FunctionExpression.handle", "method_implementation": "{\n    return (T) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 649, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "GeneratedValueElement.generate": {"callee_method_names": [], "method_name": "GeneratedValueElement.generate", "method_implementation": "{\n    this.generator = this.getAttribute(ElementConstants.ATTR_GENERATOR, ElementConstants.EMPTY);\n    this.strategy = GenerationType.valueOf(this.getAttribute(ElementConstants.ATTR_STRATEGY, GenerationType.TABLE.name()));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1059, "method_signature": "void generate()"}, "GeneratorElement.generate": {"callee_method_names": [], "method_name": "GeneratorElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ATTR_NAME, EMPTY);\n    this.catalog = this.getAttribute(ATTR_CATALOG, EMPTY);\n    this.schema = this.getAttribute(ATTR_SCHEMA, EMPTY);\n    this.allocationSize = this.getAttribute(ATTR_ALLOCATION_SIZE, 50);\n    this.initialValue = this.getAttribute(ATTR_INITIAL_VALUE, 1);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1093, "method_signature": "void generate()"}, "GeneratorThreadFactory.newThread": {"callee_method_names": ["Thread.setPriority"], "method_name": "GeneratorThreadFactory.newThread", "method_implementation": "{\n    final Thread thread = new Thread(r, \"Id Generator - \" + GeneratorThreadFactory.nextThreadNo++);\n    thread.setPriority(Thread.MAX_PRIORITY);\n    return thread;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 318, "method_signature": "Thread newThread(Runnable)"}, "GenericSuperClassTest.testPersist": {"callee_method_names": [], "method_name": "GenericSuperClassTest.testPersist", "method_implementation": "{\n    final Foo Foo = new Foo(\"FooValue\");\n    this.persist(Foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if test fails.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2481, "method_signature": "void testPersist()"}, "H2Adaptor.applyLikeEscape": {"callee_method_names": [], "method_name": "H2Adaptor.applyLikeEscape", "method_implementation": "{\n    return \" {ESCAPE \" + escapePattern + \"}\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1254, "method_signature": "String applyLikeEscape(String)"}, "H2Adaptor.applyLock": {"callee_method_names": [], "method_name": "H2Adaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1255, "method_signature": "String applyLock(String, LockModeType)"}, "H2Adaptor.applyPagination": {"callee_method_names": [], "method_name": "H2Adaptor.applyPagination", "method_implementation": "{\n    if ((startPosition != 0) || (maxResult != Integer.MAX_VALUE)) {\n        sql = sql + \"\\nLIMIT ?\";\n        if (startPosition != 0) {\n            sql = sql + \"OFFSET ?\";\n        }\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1256, "method_signature": "String applyPagination(String, int, int)"}, "H2Adaptor.applyTrim": {"callee_method_names": ["StringBuilder.append", "Trimspec.toString", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "H2Adaptor.applyTrim", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"TRIM(\");\n    if ((trimspec != null) || (trimChar != null)) {\n        if (trimspec == null) {\n            trimspec = Trimspec.BOTH;\n        }\n        builder.append(trimspec.toString()).append(\" \");\n    }\n    if (trimChar != null) {\n        builder.append(trimChar).append(\" \");\n    }\n    if ((trimspec != null) || (trimChar != null)) {\n        builder.append(\"FROM \");\n    }\n    return builder.append(argument).append(\")\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1257, "method_signature": "String applyTrim(Trimspec, String, String)"}, "H2Adaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getIdType", "AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable", "AbstractColumn.isUnique"], "method_name": "H2Adaptor.createColumnDDL", "method_implementation": "{\n    final boolean identity = column.getIdType() == IdType.IDENTITY;\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // not null part\n    (column.isUnique() ? \" UNIQUE\" : \"\") + // auto increment part\n    (identity ? \" GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1258, "method_signature": "String createColumnDDL(AbstractColumn)"}, "H2Adaptor.createSequenceIfNecessary": {"callee_method_names": ["SequenceGenerator.getQName", "SequenceGenerator.getInitialValue", "SequenceGenerator.getAllocationSize", "SequenceGenerator.getName"], "method_name": "H2Adaptor.createSequenceIfNecessary", "method_implementation": "{\n    final String sql = // ;\n    \"CREATE SEQUENCE \" + sequence.getQName() + \" START WITH \" + //\n    sequence.getInitialValue() + \" INCREMENT BY \" + sequence.getAllocationSize();\n    try {\n        new QueryRunner(datasource).update(sql);\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot create sequence \" + sequence.getName());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1259, "method_signature": "void createSequenceIfNecessary(DataSource, SequenceGenerator)"}, "H2Adaptor.getCastClassName": {"callee_method_names": [], "method_name": "H2Adaptor.getCastClassName", "method_implementation": "{\n    if (clazz == Byte.class) {\n        return \"TINYINT\";\n    } else if (clazz == Short.class) {\n        return \"SMALLINT\";\n    } else if (clazz == Float.class) {\n        return \"FLOAT4\";\n    }\n    return super.getCastClassName(clazz);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1260, "method_signature": "String getCastClassName(Class)"}, "H2Adaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "H2Adaptor.getColumnType", "method_implementation": "{\n    switch(sqlType) {\n        case Types.BLOB:\n            return \"VARBINARY(\" + cd.getLength() + \")\";\n        case Types.CLOB:\n            return \"CLOB(\" + cd.getLength() + \")\";\n        case Types.VARCHAR:\n            return \"VARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n            return \"TIME\";\n        case Types.DATE:\n            return \"DATE\";\n        case Types.TIMESTAMP:\n            return \"TIMESTAMP\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"BOOLEAN\";\n        case Types.TINYINT:\n        case Types.SMALLINT:\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"BIGINT\";\n        case Types.FLOAT:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DOUBLE:\n            return \"DOUBLE\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"DECIMAL\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1261, "method_signature": "String getColumnType(AbstractColumn, int)"}, "H2Adaptor.getDropForeignKeySql": {"callee_method_names": [], "method_name": "H2Adaptor.getDropForeignKeySql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(schema, table);\n    return \"ALTER TABLE \" + qualifiedName + \" DROP CONSTRAINT \" + foreignKey;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1262, "method_signature": "String getDropForeignKeySql(String, String, String)"}, "H2Adaptor.getNextSequence": {"callee_method_names": [], "method_name": "H2Adaptor.getNextSequence", "method_implementation": "{\n    return //\n    new QueryRunner(datasource).query(\"CALL NEXT VALUE FOR \" + sequenceName, new SingleValueHandler<Number>()).longValue();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1263, "method_signature": "long getNextSequence(DataSource, String)"}, "H2Adaptor.supports": {"callee_method_names": [], "method_name": "H2Adaptor.supports", "method_implementation": "{\n    if (type == null) {\n        return IdType.SEQUENCE;\n    }\n    switch(type) {\n        case IDENTITY:\n            return IdType.IDENTITY;\n        case SEQUENCE:\n            return IdType.SEQUENCE;\n        case TABLE:\n            return IdType.TABLE;\n        default:\n            return IdType.SEQUENCE;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1264, "method_signature": "IdType supports(GenerationType)"}, "HashMapBug.hashMapBug": {"callee_method_names": ["Map<String, Integer>.put", "Map<String, Integer>.put", "Map<String, Integer>.put", "Map<String, Integer>.put", "Map<String, Integer>.keySet", "Map<String, Integer>.keySet", "Map<String, Integer>.entrySet", "Map<String, Integer>.entrySet", "Map<String, Integer>.values", "Map<String, Integer>.values"], "method_name": "HashMapBug.hashMapBug", "method_implementation": "{\n    final Map<String, Integer> map1 = new HashMap<String, Integer>();\n    final Map<String, Integer> map2 = new HashMap<String, Integer>();\n    map1.put(\"1\", 1);\n    map1.put(\"2\", 2);\n    map2.put(\"1\", 1);\n    map2.put(\"2\", 2);\n    Assert.assertEquals(map1, map2);\n    Assert.assertEquals(map1.keySet(), map2.keySet());\n    Assert.assertEquals(map1.entrySet(), map2.entrySet());\n    Assert.assertEquals(map1.values(), map2.values());\n}", "repo_id": "1", "comment": "/**\n * Test to demonstrate the hash map bug\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2537, "method_signature": "void hashMapBug()"}, "HintElement.generate": {"callee_method_names": [], "method_name": "HintElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n    this.value = this.getAttribute(ElementConstants.ATTR_VALUE, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1117, "method_signature": "void generate()"}, "HsqlAdaptor.applyLikeEscape": {"callee_method_names": [], "method_name": "HsqlAdaptor.applyLikeEscape", "method_implementation": "{\n    return \" {ESCAPE \" + escapePattern + \"}\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1233, "method_signature": "String applyLikeEscape(String)"}, "HsqlAdaptor.applyLock": {"callee_method_names": [], "method_name": "HsqlAdaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1234, "method_signature": "String applyLock(String, LockModeType)"}, "HsqlAdaptor.applyPagination": {"callee_method_names": [], "method_name": "HsqlAdaptor.applyPagination", "method_implementation": "{\n    if ((startPosition != 0) || (maxResult != Integer.MAX_VALUE)) {\n        sql = sql + \"\\nLIMIT \" + maxResult;\n        if (startPosition != 0) {\n            sql = sql + \"OFFSET \" + startPosition;\n        }\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1235, "method_signature": "String applyPagination(String, int, int)"}, "HsqlAdaptor.applyTrim": {"callee_method_names": ["StringBuilder.append", "Trimspec.toString", "StringBuilder.append", "StringBuilder.append"], "method_name": "HsqlAdaptor.applyTrim", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"TRIM(\");\n    if (trimspec != null) {\n        builder.append(trimspec.toString()).append(\" \");\n    }\n    if (trimChar != null) {\n        builder.append(trimChar).append(\" \");\n    }\n    return builder.append(\"FROM \").append(argument).append(\")\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1236, "method_signature": "String applyTrim(Trimspec, String, String)"}, "HsqlAdaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getIdType", "AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable"], "method_name": "HsqlAdaptor.createColumnDDL", "method_implementation": "{\n    final boolean identity = column.getIdType() == IdType.IDENTITY;\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // auto increment part\n    (identity ? \" GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1237, "method_signature": "String createColumnDDL(AbstractColumn)"}, "HsqlAdaptor.createCreateTableStatement": {"callee_method_names": ["StringBuilder.append", "AbstractTable.getQName", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "HsqlAdaptor.createCreateTableStatement", "method_implementation": "{\n    // HSQL handles the unique columns as constraints only\n    final String columns = Joiner.on(\",\\n\\t\").join(ddlColumns);\n    final String keys = Joiner.on(\", \").join(pkColumns);\n    final String uniques = Joiner.on(\", \").join(uniqueColumns);\n    final StringBuilder statement = new StringBuilder();\n    // table part\n    statement.append(\"CREATE TABLE \").append(table.getQName()).append(\" (\\n\\t\");\n    // columns part\n    statement.append(columns);\n    if (StringUtils.isNotBlank(uniques)) {\n        statement.append(\",\");\n        statement.append(\"\\nUNIQUE(\").append(uniques).append(\")\");\n    }\n    if (StringUtils.isNotBlank(keys)) {\n        statement.append(\",\");\n        statement.append(\"\\nPRIMARY KEY(\").append(keys).append(\")\");\n    }\n    statement.append(\")\");\n    return statement.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1238, "method_signature": "String createCreateTableStatement(AbstractTable, Collection, List, List)"}, "HsqlAdaptor.createSequenceIfNecessary": {"callee_method_names": ["SequenceGenerator.getQName", "SequenceGenerator.getInitialValue", "SequenceGenerator.getAllocationSize", "SequenceGenerator.getName"], "method_name": "HsqlAdaptor.createSequenceIfNecessary", "method_implementation": "{\n    final String sql = //\n    \"CREATE SEQUENCE \" + sequence.getQName() + // ;\n    \" AS BIGINT\" + \" START WITH \" + //\n    sequence.getInitialValue() + \" INCREMENT BY \" + sequence.getAllocationSize();\n    try {\n        new QueryRunner(datasource).update(sql);\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot create sequence \" + sequence.getName());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1239, "method_signature": "void createSequenceIfNecessary(DataSource, SequenceGenerator)"}, "HsqlAdaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "HsqlAdaptor.getColumnType", "method_implementation": "{\n    switch(sqlType) {\n        case Types.BLOB:\n        case Types.CLOB:\n            return \"VARBINARY(\" + cd.getLength() + \")\";\n        case Types.VARCHAR:\n            return \"VARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n            return \"TIME\";\n        case Types.DATE:\n            return \"DATE\";\n        case Types.TIMESTAMP:\n            return \"TIMESTAMP\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"BOOLEAN\";\n        case Types.TINYINT:\n        case Types.SMALLINT:\n            return \"SMALLINT\";\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"BIGINT\";\n        case Types.FLOAT:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DOUBLE:\n            return \"DOUBLE\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"DECIMAL\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1240, "method_signature": "String getColumnType(AbstractColumn, int)"}, "HsqlAdaptor.getDropForeignKeySql": {"callee_method_names": [], "method_name": "HsqlAdaptor.getDropForeignKeySql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(schema, table);\n    return \"ALTER TABLE \" + qualifiedName + \" DROP CONSTRAINT \" + foreignKey;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1241, "method_signature": "String getDropForeignKeySql(String, String, String)"}, "HsqlAdaptor.getNextSequence": {"callee_method_names": [], "method_name": "HsqlAdaptor.getNextSequence", "method_implementation": "{\n    return //\n    new QueryRunner(datasource).query(\"CALL NEXT VALUE FOR \" + sequenceName, new SingleValueHandler<Number>()).longValue();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1242, "method_signature": "long getNextSequence(DataSource, String)"}, "HsqlAdaptor.supports": {"callee_method_names": [], "method_name": "HsqlAdaptor.supports", "method_implementation": "{\n    if (type == null) {\n        return IdType.SEQUENCE;\n    }\n    switch(type) {\n        case IDENTITY:\n            return IdType.IDENTITY;\n        case SEQUENCE:\n            return IdType.SEQUENCE;\n        case TABLE:\n            return IdType.TABLE;\n        default:\n            return IdType.SEQUENCE;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1243, "method_signature": "IdType supports(GenerationType)"}, "IdAttributeElement.handleChild": {"callee_method_names": [], "method_name": "IdAttributeElement.handleChild", "method_implementation": "{\n    super.handleChild(child);\n    if (child instanceof GeneratedValueElement) {\n        this.generatedValue = (GeneratedValueElement) child;\n    }\n    if (child instanceof SequenceGeneratorElement) {\n        this.sequenceGenerator = (SequenceGeneratorElement) child;\n    }\n    if (child instanceof TableGeneratorElement) {\n        this.tableGenerator = (TableGeneratorElement) child;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1105, "method_signature": "void handleChild(Element)"}, "IdClassTestTest.testIdClass": {"callee_method_names": ["Foo.setStrKey", "Foo.setIntKey", "Foo.setValue", "Foo.setStrKey", "Foo.setIntKey", "Foo.setValue", "Foo.getIntKey", "Foo.getStrKey"], "method_name": "IdClassTestTest.testIdClass", "method_implementation": "{\n    final Foo foo1 = new Foo();\n    foo1.setStrKey(\"key1\");\n    foo1.setIntKey(1);\n    foo1.setValue(\"Foo2\");\n    final Foo foo2 = new Foo();\n    foo2.setStrKey(\"key1\");\n    foo2.setIntKey(2);\n    foo2.setValue(\"Foo2\");\n    this.persist(foo1);\n    this.persist(foo2);\n    this.commit();\n    this.close();\n    final Foo foo3 = this.find(Foo.class, new FooPk(foo1.getIntKey(), foo1.getStrKey()));\n    Assert.assertEquals(foo1, foo3);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with IdClass\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2151, "method_signature": "void testIdClass()"}, "IdQueue.doTopUp": {"callee_method_names": [], "method_name": "IdQueue.doTopUp", "method_implementation": "{\n    if (this.idExecuter.isShutdown()) {\n        return;\n    }\n    if (this.size() <= (this.allocationSize)) {\n        IdQueue.LOG.debug(\"Ids will be fetched for {0} from the database...\", this.name);\n        try {\n            final long nextSequence = this.getNextId();\n            for (int i = 0; i < this.allocationSize; i++) {\n                this.put(nextSequence + i);\n            }\n        } catch (final InterruptedException e) {\n            return;\n        } catch (final Exception e) {\n            try {\n                Thread.currentThread();\n                Thread.sleep(1000);\n            } catch (final InterruptedException e1) {\n            }\n            if (this.idExecuter.isShutdown()) {\n                return;\n            }\n            IdQueue.LOG.fatal(e, \"Cannot get next id from the database!\");\n        }\n    }\n    try {\n        Thread.sleep(1);\n    } catch (final InterruptedException e) {\n        return;\n    }\n}", "repo_id": "1", "comment": "/**\n * Tops up the queue.\n *\n * @param runnable\n *            the runnable to run to top-up\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1162, "method_signature": "void doTopUp(Runnable)"}, "IdQueue.poll": {"callee_method_names": [], "method_name": "IdQueue.poll", "method_implementation": "{\n    if (this.size() < (this.allocationSize * 2)) {\n        this.idExecuter.execute(new TopUpTask());\n    }\n    return super.poll(timeout, unit);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1163, "method_signature": "Long poll(long, TimeUnit)"}, "IdentifiableMetadataImpl.getCallbacks": {"callee_method_names": [], "method_name": "IdentifiableMetadataImpl.getCallbacks", "method_implementation": "{\n    if (this.selfListener != null) {\n        return this.selfListener.getCallbacks();\n    } else {\n        return Collections.emptyList();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 990, "method_signature": "List<CallbackMetadata> getCallbacks()"}, "IdentifiableMetadataImpl.handleCallbacks": {"callee_method_names": ["IdentifiableTypeMetadata.getCallbacks", "IdentifiableTypeMetadata.getLocator"], "method_name": "IdentifiableMetadataImpl.handleCallbacks", "method_implementation": "{\n    if ((metadata != null) && (metadata.getCallbacks().size() > 0)) {\n        return new EntityListenerMetadataImpl(metadata.getLocator(), metadata, this.getClassName());\n    } else {\n        return new EntityListenerMetadataImpl(this.getLocator(), this.getClazz(), this.getAnnotationsParsed());\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the callbacks.\n *\n * @param metadata\n *            the metadata\n * @return the entity listener metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 991, "method_signature": "EntityListenerMetadata handleCallbacks(IdentifiableTypeMetadata)"}, "IdentifiableMetadataImpl.handleDefaultListeners": {"callee_method_names": ["IdentifiableTypeMetadata.excludeDefaultListeners"], "method_name": "IdentifiableMetadataImpl.handleDefaultListeners", "method_implementation": "{\n    if ((metadata != null) && metadata.excludeDefaultListeners()) {\n        return true;\n    }\n    final ExcludeDefaultListeners annotation = this.getClazz().getAnnotation(ExcludeDefaultListeners.class);\n    if (annotation != null) {\n        this.getAnnotationsParsed().add(ExcludeDefaultListeners.class);\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Handles the default listeners exclusion.\n *\n * @param metadata\n *            the metadata\n * @return if default listeners excluded\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 992, "method_signature": "boolean handleDefaultListeners(IdentifiableTypeMetadata)"}, "IdentifiableMetadataImpl.handleEntityListeners": {"callee_method_names": ["IdentifiableTypeMetadata.getListeners", "IdentifiableTypeMetadata.getListeners", "IdentifiableTypeMetadata.getLocator", "IdentifiableTypeMetadata.getListeners", "EntityListeners.value"], "method_name": "IdentifiableMetadataImpl.handleEntityListeners", "method_implementation": "{\n    if ((metadata != null) && (metadata.getListeners().size() > 0)) {\n        for (final EntityListenerMetadata listener : metadata.getListeners()) {\n            new EntityListenerMetadataImpl(metadata.getLocator(), listener);\n        }\n        this.listeners.addAll(metadata.getListeners());\n    } else {\n        final EntityListeners entityListeners = this.getClazz().getAnnotation(EntityListeners.class);\n        if (entityListeners != null) {\n            this.getAnnotationsParsed().add(EntityListeners.class);\n            for (final Class<?> clazz : entityListeners.value()) {\n                this.listeners.add(new EntityListenerMetadataImpl(this.getLocator(), clazz));\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the entity listeners.\n *\n * @param metadata\n *            the metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 993, "method_signature": "void handleEntityListeners(IdentifiableTypeMetadata)"}, "IdentifiableMetadataImpl.handleIdClass": {"callee_method_names": ["IdentifiableTypeMetadata.getIdClass", "IdentifiableTypeMetadata.getIdClass", "IdClass.value"], "method_name": "IdentifiableMetadataImpl.handleIdClass", "method_implementation": "{\n    if ((metadata != null) && StringUtils.isNotBlank(metadata.getIdClass())) {\n        return metadata.getIdClass();\n    }\n    final IdClass idClass = this.getClazz().getAnnotation(IdClass.class);\n    if (idClass != null) {\n        this.getAnnotationsParsed().add(IdClass.class);\n        return idClass.value().getName();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Handles the id class definition of the entity.\n *\n * @param metadata\n *            the metadata\n * @param parsed\n *            the set of annotations parsed\n * @return the id class attribute\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 994, "method_signature": "String handleIdClass(IdentifiableTypeMetadata)"}, "IdentifiableMetadataImpl.handleSuperclassListeners": {"callee_method_names": ["IdentifiableTypeMetadata.excludeSuperclassListeners"], "method_name": "IdentifiableMetadataImpl.handleSuperclassListeners", "method_implementation": "{\n    if ((metadata != null) && metadata.excludeSuperclassListeners()) {\n        return true;\n    }\n    final ExcludeSuperclassListeners annotation = this.getClazz().getAnnotation(ExcludeSuperclassListeners.class);\n    if (annotation != null) {\n        this.getAnnotationsParsed().add(ExcludeSuperclassListeners.class);\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Handles the super class listeners exclusion.\n *\n * @param metadata\n *            the metadata\n * @return if default listeners excluded\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 995, "method_signature": "boolean handleSuperclassListeners(IdentifiableTypeMetadata)"}, "IdentifiableTypeImpl.addAttribute": {"callee_method_names": ["BasicAttribute<? super X, ?>.isId", "AttributeImpl<? super X,?>.getDeclaringType", "AttributeImpl<? super X,?>.getName", "AttributeImpl<? super X,?>.getLocator", "AttributeImpl<? super X,?>.getLocator", "AttributeImpl<? super X,?>.getName", "BasicAttribute<? super X, ?>.isVersion", "AttributeImpl<? super X,?>.getLocator", "AttributeImpl<? super X,?>.getDeclaringType", "EmbeddedAttribute<? super X, ?>.isId", "AttributeImpl<? super X,?>.getLocator", "EmbeddedAttribute<? super X, ?>.getDeclaringType", "AttributeImpl<? super X,?>.getName", "AssociatedSingularAttribute<? super X, ?>.isId", "AttributeImpl<? super X,?>.getDeclaringType", "AttributeImpl<? super X,?>.getName", "AttributeImpl<? super X,?>.getLocator", "AttributeImpl<? super X,?>.getLocator", "AttributeImpl<? super X,?>.getName"], "method_name": "IdentifiableTypeImpl.addAttribute", "method_implementation": "{\n    if (attribute instanceof BasicAttribute) {\n        final BasicAttribute<? super X, ?> basicAttribute = (BasicAttribute<? super X, ?>) attribute;\n        if (basicAttribute.isId()) {\n            if (attribute.getDeclaringType() == this) {\n                this.declaredIdAttributes.put(attribute.getName(), (BasicAttribute<X, ?>) basicAttribute);\n            }\n            if (this.embeddedId != null) {\n                throw new //\n                MappingException(//\n                \"Embbeded id attributes cannot be combined with other id attributes.\", attribute.getLocator(), this.embeddedId.getLocator());\n            }\n            if ((this.idClass == null) && (this.idAttributes.size() > 1)) {\n                throw new //\n                MappingException(//\n                \"Multiple id attributes are only allowed with id class declaration.\", attribute.getLocator(), this.idAttributes.values().iterator().next().getLocator());\n            }\n            this.idAttributes.put(attribute.getName(), basicAttribute);\n        }\n        if (basicAttribute.isVersion()) {\n            if (basicAttribute == this.versionAttribute) {\n                // Inheritance. The version attribute is already set\n                return;\n            }\n            if (this.versionAttribute != null) {\n                throw new MappingException(\"Multiple version attributes not supported.\", this.versionAttribute.getLocator(), attribute.getLocator());\n            }\n            if (attribute.getDeclaringType() == this) {\n                this.declaredVersionAttribute = (BasicAttribute<X, ?>) basicAttribute;\n            }\n            this.versionAttribute = basicAttribute;\n            this.versionType = VersionType.versionType(this.versionAttribute.getJavaType());\n        }\n    } else if (attribute instanceof EmbeddedAttribute) {\n        final EmbeddedAttribute<? super X, ?> embeddedAttribute = (EmbeddedAttribute<? super X, ?>) attribute;\n        if (embeddedAttribute.isId()) {\n            if (this.idClass != null) {\n                throw new MappingException(\"When IdClass defined, it is illegal to use embedded id attributes.\", this.getLocator());\n            }\n            if (this.idAttributes.size() > 0) {\n                throw new //\n                MappingException(//\n                \"Embedded id attributes cannot be combined with other id attributes.\", attribute.getLocator(), this.idAttributes.values().iterator().next().getLocator());\n            }\n            if (embeddedAttribute.getDeclaringType() == this) {\n                this.declaredEmbeddedId = (EmbeddedAttribute<X, ?>) embeddedAttribute;\n            }\n            this.idAttributes.put(attribute.getName(), embeddedAttribute);\n            this.embeddedId = embeddedAttribute;\n        }\n    } else if (attribute instanceof AssociatedSingularAttribute) {\n        final AssociatedSingularAttribute<? super X, ?> associatedSingularAttribute = (AssociatedSingularAttribute<? super X, ?>) attribute;\n        if (associatedSingularAttribute.isId()) {\n            if (attribute.getDeclaringType() == this) {\n                this.declaredIdAttributes.put(attribute.getName(), (SingularAttributeImpl<X, ?>) associatedSingularAttribute);\n            }\n            if (this.embeddedId != null) {\n                throw new //\n                MappingException(//\n                \"Embbeded id attributes cannot be combined with other id attributes.\", attribute.getLocator(), this.embeddedId.getLocator());\n            }\n            if ((this.idClass == null) && (this.idAttributes.size() > 1)) {\n                throw new //\n                MappingException(//\n                \"Multiple id attributes are only allowed with id class declaration.\", attribute.getLocator(), this.idAttributes.values().iterator().next().getLocator());\n            }\n            this.idAttributes.put(attribute.getName(), associatedSingularAttribute);\n        }\n    }\n    super.addAttribute(attribute);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 319, "method_signature": "void addAttribute(AttributeImpl)"}, "IdentifiableTypeImpl.addAttributes": {"callee_method_names": ["AttributeImpl<? super X,?>.getDeclaringType"], "method_name": "IdentifiableTypeImpl.addAttributes", "method_implementation": "{\n    if (this.supertype != null) {\n        for (Attribute<? super X, ?> attribute : this.supertype.getAttributes()) {\n            if ((attribute.getDeclaringType() instanceof MappedSuperclassTypeImpl) && (this instanceof EntityTypeImpl)) {\n                attribute = ((AttributeImpl<? super X, ?>) attribute).clone((EntityTypeImpl<X>) this);\n            }\n            this.addAttribute((AttributeImpl<? super X, ?>) attribute);\n        }\n    }\n    super.addAttributes(entityMetadata);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 320, "method_signature": "void addAttributes(ManagedTypeMetadata)"}, "IdentifiableTypeImpl.addIdAttributes": {"callee_method_names": ["ManagedTypeMetadata.getAttributes", "AttributesMetadata.getEmbeddedIds", "AttributesMetadata.getIds", "AttributesMetadata.getVersions"], "method_name": "IdentifiableTypeImpl.addIdAttributes", "method_implementation": "{\n    final AttributesMetadata attributes = metadata.getAttributes();\n    // embedded-id attributes\n    for (final EmbeddedIdAttributeMetadata attribute : attributes.getEmbeddedIds()) {\n        this.addAttribute(new EmbeddedAttribute(this, attribute));\n    }\n    // add id attributes\n    for (final IdAttributeMetadata attribute : attributes.getIds()) {\n        this.addAttribute(new BasicAttribute(this, attribute));\n    }\n    // add version attributes\n    for (final VersionAttributeMetadata attribute : attributes.getVersions()) {\n        this.declaredVersionAttribute = new BasicAttribute(this, attribute);\n        this.addAttribute(this.declaredVersionAttribute);\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates and adds the attributes of the managed type from the metadata.\n *\n * @param metadata\n *            the metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 321, "method_signature": "void addIdAttributes(ManagedTypeMetadata)"}, "IdentifiableTypeImpl.fireCallbacks": {"callee_method_names": [], "method_name": "IdentifiableTypeImpl.fireCallbacks", "method_implementation": "{\n    if (!this.callbackManager.excludeDefaultListeners() && self) {\n        this.getMetamodel().fireCallbacks(instance, type);\n    }\n    if ((this.getSupertype() != null) && !this.callbackManager.excludeSuperclassListeners()) {\n        this.getSupertype().fireCallbacks(false, instance, type);\n    }\n    this.callbackManager.fireCallbacks(instance, type);\n}", "repo_id": "1", "comment": "/**\n * Fires the callbacks.\n *\n * @param instance\n *            the instance\n * @param type\n *            the listener type\n * @param self\n *            if the object belongs to this type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 322, "method_signature": "void fireCallbacks(boolean, Object, EntityListenerType)"}, "IdentifiableTypeImpl.getAvailability": {"callee_method_names": [], "method_name": "IdentifiableTypeImpl.getAvailability", "method_implementation": "{\n    if (this.callbackAvailability != null) {\n        return this.callbackAvailability;\n    }\n    synchronized (this) {\n        if (this.callbackAvailability != null) {\n            return this.callbackAvailability;\n        }\n        return this.callbackAvailability = this.callbackManager.getAvailibility(this.getMetamodel(), this.getSupertype());\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the callback availability.\n *\n * @return the callback availability\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 323, "method_signature": "CallbackAvailability getAvailability()"}, "IdentifiableTypeImpl.getDeclaredId": {"callee_method_names": [], "method_name": "IdentifiableTypeImpl.getDeclaredId", "method_implementation": "{\n    if ((this.declaredEmbeddedId != null) && (type == this.declaredEmbeddedId.getJavaType())) {\n        return (SingularAttribute<X, Y>) this.declaredEmbeddedId;\n    }\n    if (this.idClass != null) {\n        throw new IllegalStateException(\"Type defines multiple id attributes\");\n    }\n    if (this.declaredIdAttributes.size() > 1) {\n        return (SingularAttribute<X, Y>) this.declaredIdAttributes.values().iterator().next();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 324, "method_signature": "SingularAttribute<X,Y> getDeclaredId(Class)"}, "IdentifiableTypeImpl.getDeclaredVersion": {"callee_method_names": [], "method_name": "IdentifiableTypeImpl.getDeclaredVersion", "method_implementation": "{\n    return (SingularAttribute<X, Y>) this.versionAttribute;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 325, "method_signature": "SingularAttribute<X,Y> getDeclaredVersion(Class)"}, "IdentifiableTypeImpl.getId": {"callee_method_names": ["SingularAttributeImpl<? super X, Y>.getJavaType"], "method_name": "IdentifiableTypeImpl.getId", "method_implementation": "{\n    if ((this.embeddedId != null) && (type == this.embeddedId.getJavaType())) {\n        return (SingularAttribute<? super X, Y>) this.embeddedId;\n    }\n    if (this.idClass != null) {\n        throw new IllegalArgumentException(\"Type defines multiple id attributes\");\n    }\n    if (this.idAttributes.size() > 1) {\n        return (SingularAttribute<? super X, Y>) this.idAttributes.values().iterator().next();\n    }\n    final SingularAttributeImpl<? super X, Y> attribute = (SingularAttributeImpl<? super X, Y>) this.idAttributes.values().iterator().next();\n    return attribute.getJavaType() == type ? attribute : null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 326, "method_signature": "SingularAttribute<? super X,Y> getId(Class)"}, "IdentifiableTypeImpl.getIdClass": {"callee_method_names": ["IdentifiableTypeMetadata.getIdClass", "IdentifiableTypeMetadata.getIdClass"], "method_name": "IdentifiableTypeImpl.getIdClass", "method_implementation": "{\n    final String idClass = metadata.getIdClass();\n    if (StringUtils.isNotBlank(idClass)) {\n        try {\n            return this.getMetamodel().getEntityManagerFactory().getClassloader().loadClass(metadata.getIdClass());\n        } catch (final ClassNotFoundException e) {\n            throw new MappingException(\"Cannot load id class \" + idClass + \" for entity \" + this.getJavaType().getName(), this.getLocator());\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * Retrurns the id class of the entity if it is specified.\n *\n * @param metadata\n *            the metadata\n * @return the id class of the entity if it is specified or <code>null</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 327, "method_signature": "Class<?> getIdClass(IdentifiableTypeMetadata)"}, "IdentifiableTypeImpl.getIdClassAttributes": {"callee_method_names": ["Set<SingularAttribute<? super X, ?>>.addAll"], "method_name": "IdentifiableTypeImpl.getIdClassAttributes", "method_implementation": "{\n    final Set<SingularAttribute<? super X, ?>> idAttributes = Sets.newHashSet();\n    if (this.idClass != null) {\n        idAttributes.addAll(this.idAttributes.values());\n    }\n    return idAttributes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 328, "method_signature": "Set<SingularAttribute<? super X,?>> getIdClassAttributes()"}, "IdentifiableTypeImpl.getIdType": {"callee_method_names": [], "method_name": "IdentifiableTypeImpl.getIdType", "method_implementation": "{\n    if (this.embeddedId != null) {\n        return this.embeddedId.getType();\n    }\n    if (this.idAttributes.size() >= 2) {\n        throw new MappingException(\"Entity \" + this.getJavaType() + \" with multiple id attributes, must declare the @IdClass\", this.getLocator());\n    }\n    return this.idAttributes.values().iterator().next().getType();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 329, "method_signature": "Type<?> getIdType()"}, "IdentifiableTypeImpl.getVersion": {"callee_method_names": ["Class<Y>.getName"], "method_name": "IdentifiableTypeImpl.getVersion", "method_implementation": "{\n    if (this.versionAttribute == null) {\n        return null;\n    }\n    if (this.versionAttribute.getJavaType() != type) {\n        throw new IllegalArgumentException(\"Version does not match specified type : \" + type.getName());\n    }\n    return (BasicAttribute<? super X, Y>) this.versionAttribute;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 330, "method_signature": "BasicAttribute<? super X,Y> getVersion(Class)"}, "IdentifiableTypeImpl.newCompositeId": {"callee_method_names": [], "method_name": "IdentifiableTypeImpl.newCompositeId", "method_implementation": "{\n    try {\n        return this.idConstructor.newInstance(IdentifiableTypeImpl.EMPTY_PARAMS);\n    } catch (final Exception e) {\n        // impossible at this stage\n        return null;\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns a generated idClass instance based on the id class.\n *\n * @return a generated idClass instance based on the id class\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 331, "method_signature": "Object newCompositeId()"}, "IdentityTest.testIdentiy": {"callee_method_names": ["Foo.setValue", "Foo.setValue", "Foo.setOther", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getOther", "Foo.getOther"], "method_name": "IdentityTest.testIdentiy", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.setValue(\"Foo2\");\n    final Foo foo2 = new Foo();\n    foo2.setValue(\"Foo2\");\n    foo2.setOther(foo);\n    this.persist(foo2);\n    this.commit();\n    this.close();\n    final Foo foo3 = this.find(Foo.class, foo2.getKey());\n    Assert.assertEquals(foo2.getKey(), foo3.getKey());\n    Assert.assertEquals(foo2.getOther().getKey(), foo3.getOther().getKey());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with identity value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2250, "method_signature": "void testIdentiy()"}, "ImportTest.testIndex": {"callee_method_names": [], "method_name": "ImportTest.testIndex", "method_implementation": "{\n    Assert.assertEquals(3, this.em().createQuery(\"select count(distinct f) from Foo f\", Long.class).getSingleResult().intValue());\n    Assert.assertEquals(6, this.em().createQuery(\"select sum(f.id) from Foo f\", Number.class).getSingleResult().intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests the index creation.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2281, "method_signature": "void testIndex()"}, "InExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "InExpression.generateJpqlRestriction", "method_implementation": "{\n    final String values = Joiner.on(\", \").join(Lists.transform(this.values, new Function<AbstractExpression<?>, String>() {\n\n        @Override\n        public String apply(AbstractExpression<?> input) {\n            return input.generateJpqlRestriction(query);\n        }\n    }));\n    if (this.not) {\n        return this.inner.generateJpqlRestriction(query) + \" not in (\" + values + \")\";\n    }\n    return this.inner.generateJpqlRestriction(query) + \" in (\" + values + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 599, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "InExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "InExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 600, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "InExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "InExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 601, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "InExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "InExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final String inner = this.inner.getSqlRestrictionFragments(query)[0];\n    final String values = Joiner.on(\", \").join(Lists.transform(this.values, new Function<AbstractExpression<?>, String>() {\n\n        @Override\n        public String apply(AbstractExpression<?> input) {\n            return input.getSqlRestrictionFragments(query)[0];\n        }\n    }));\n    if (this.not) {\n        return new String[] { inner + \" NOT IN (\" + values + \")\" };\n    }\n    return new String[] { inner + \" IN (\" + values + \")\" };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 602, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "InPredicate.value": {"callee_method_names": [], "method_name": "InPredicate.value", "method_implementation": "{\n    this.inExpr.add((AbstractExpression<?>) value);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 756, "method_signature": "In<T> value(Expression)"}, "IndexExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "IndexExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 555, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "IndexExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "IndexExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 556, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "IndexExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "IndexExpression.getSqlRestrictionFragments", "method_implementation": "{\n    String tableAlias = this.listJoin.getTableAlias(query, this.orderColumn.getTable());\n    if (this.orderColumn.getTable() instanceof JoinTable) {\n        tableAlias += \"_J\";\n    }\n    return new String[] { tableAlias + \".\" + this.orderColumn.getName() };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 557, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "InheritanceTest.testInheritance": {"callee_method_names": ["FooExt1.setValue", "FooExt1.setValueExt1", "FooExt1.getKey", "FooExt1.getKey", "FooExt1.getKey", "FooExt1.getValue", "FooExt1.getValue", "FooExt1.getValueExt1", "FooExt1.getValueExt1"], "method_name": "InheritanceTest.testInheritance", "method_implementation": "{\n    final FooExt1 foo = new FooExt1();\n    foo.setValue(\"Foo2\");\n    foo.setValueExt1(\"Bar1\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt1 foo2 = (FooExt1) this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo.getValueExt1());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with identity value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2223, "method_signature": "void testInheritance()"}, "InheritanceTest.testSimpleInheritance2": {"callee_method_names": ["FooExt11.setValue", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getValue", "FooExt11.getValue", "FooExt11.getValueExt1", "FooExt11.getValueExt1"], "method_name": "InheritanceTest.testSimpleInheritance2", "method_implementation": "{\n    final FooExt11 foo = new FooExt11();\n    foo.setValue(\"Foo2\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt11 foo2 = this.find(FooExt11.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo.getValueExt1());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with identity value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2224, "method_signature": "void testSimpleInheritance2()"}, "InheritanceTest.testSimpleInheritance3": {"callee_method_names": ["FooExt1.setValue", "FooExt1.getKey"], "method_name": "InheritanceTest.testSimpleInheritance3", "method_implementation": "{\n    final FooExt1 foo = new FooExt1();\n    foo.setValue(\"Foo2\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    Assert.assertNull(this.find(FooExt11.class, foo.getKey()));\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with identity value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2225, "method_signature": "void testSimpleInheritance3()"}, "InheritenceCriteriaTest.testType1": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Class>.from", "RootImpl<Bar>.joinSet", "SetJoinImpl<Bar, BaseFoo>.type", "CriteriaQueryImpl<Class>.select", "Order.getName", "List<Class>.toString"], "method_name": "InheritenceCriteriaTest.testType1", "method_implementation": "{\n    this.persist(this.bar());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Class> q = cb.createQuery(Class.class);\n    final RootImpl<Bar> r = q.from(Bar.class);\n    final SetJoinImpl<Bar, BaseFoo> b = r.joinSet(\"foos\");\n    final Expression<Class<? extends BaseFoo>> type = b.type();\n    q.select(type);\n    final List<Class> resultList = this.em().createQuery(q).getResultList();\n    Collections.sort(resultList, new Comparator<Class>() {\n\n        @Override\n        public int compare(Class o1, Class o2) {\n            return o1.getName().compareTo(o2.getName());\n        }\n    });\n    Assert.assertEquals(\"[class org.batoo.jpa.core.test.q.FooType1, class org.batoo.jpa.core.test.q.FooType2]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2350, "method_signature": "void testType1()"}, "InheritenceCriteriaTest.testType2": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Class>.from", "RootImpl<Bar>.join", "Path<Integer>.type", "CriteriaQueryImpl<Class>.select", "List<Class>.toString"], "method_name": "InheritenceCriteriaTest.testType2", "method_implementation": "{\n    this.persist(this.bar());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Class> q = cb.createQuery(Class.class);\n    final RootImpl<Bar> r = q.from(Bar.class);\n    final Path<Integer> path = r.join(\"foos\").<Integer>get(\"id\");\n    final Expression<Class<? extends Integer>> type = path.type();\n    q.select(type);\n    final List<Class> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(\"[class java.lang.Integer, class java.lang.Integer]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2351, "method_signature": "void testType2()"}, "InheritenceJpqlTest.testCaseType": {"callee_method_names": [], "method_name": "InheritenceJpqlTest.testCaseType", "method_implementation": "{\n    this.persist(new Employee());\n    this.persist(new Exempt());\n    this.persist(new Exempt());\n    this.persist(new Contractor());\n    this.commit();\n    this.close();\n    //\n    Assert.//\n    assertEquals(//\n    \"[Contractor, Employee, Exempt, Exempt]\", this.cq(//\n    \"select case type(e) \\n\" + //\n    \"    when Exempt then 'Exempt'\\n\" + //\n    \"    when Contractor then 'Contractor'\\n\" + //\n    \"    else 'Employee'\\n\" + //\n    \"  end\\n\" + \"from Employee e order by type(e)\", String.class).getResultList().toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2393, "method_signature": "void testCaseType()"}, "InheritenceJpqlTest.testType": {"callee_method_names": ["TypedQuery<Employee>.getResultList", "TypedQuery<Employee>.getResultList", "TypedQuery<Class>.getResultList", "TypedQuery<Class>.getResultList"], "method_name": "InheritenceJpqlTest.testType", "method_implementation": "{\n    this.persist(new Employee());\n    this.persist(new Exempt());\n    this.persist(new Exempt());\n    this.persist(new Contractor());\n    this.commit();\n    this.close();\n    TypedQuery<Class> q2;\n    TypedQuery<Employee> q = this.cq(\"select e from Employee e where type(e) = Exempt\", Employee.class);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select object(e) from Employee e where type(e) = :p\", Employee.class).setParameter(\"p\", Exempt.class);\n    Assert.assertEquals(2, q.getResultList().size());\n    q2 = this.cq(\"select type(e) from Employee e where type(e) = :p\", Class.class).setParameter(\"p\", Exempt.class);\n    Assert.assertEquals(Exempt.class, q2.getResultList().get(0));\n    q2 = this.cq(\"select type(e.id) from Employee e where type(e) = :p\", Class.class).setParameter(\"p\", Exempt.class);\n    Assert.assertEquals(Integer.class, q2.getResultList().get(0));\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2394, "method_signature": "void testType()"}, "InverseJoinColumnElement.generate": {"callee_method_names": [], "method_name": "InverseJoinColumnElement.generate", "method_implementation": "{\n    super.generate();\n    this.referencedColumnName = this.getAttribute(ElementConstants.ATTR_REFERENCED_COLUMN_NAME, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1084, "method_signature": "void generate()"}, "IsEmptyExpression.getSqlRestrictionFragments": {"callee_method_ids": [513, 519], "callee_method_names": ["BaseQueryImpl<?>.getMetamodel", "BaseQueryImpl<?>.subquery", "SubqueryImpl<Integer>.from", "Joinable.getEntity", "Root<?>.join", "CriteriaBuilderImpl.exists", "CriteriaBuilderImpl.exists", "SubqueryImpl<Integer>.where", "CriteriaBuilderImpl.equal", "SubqueryImpl<Integer>.select", "CriteriaBuilderImpl.literal", "PredicateImpl.getSqlRestrictionFragments"], "method_name": "IsEmptyExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final CriteriaBuilderImpl cb = query.getMetamodel().getEntityManagerFactory().getCriteriaBuilder();\n    final Joinable rp = this.inner.getParentPath().getRootPath();\n    final SubqueryImpl<Integer> s = query.subquery(Integer.class);\n    final Root<?> r = s.from(rp.getEntity());\n    r.join(this.inner.getMapping().getAttribute().getName());\n    final PredicateImpl p = this.not ? cb.exists(s) : cb.exists(s).not();\n    s.where(cb.equal(r, (AbstractExpression<?>) rp));\n    s.select(cb.literal(1));\n    return p.getSqlRestrictionFragments(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 681, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "IsNullExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "IsNullExpression.generateJpqlRestriction", "method_implementation": "{\n    if (this.not) {\n        return this.inner.generateJpqlRestriction(query) + \" is not null\";\n    }\n    return this.inner.generateJpqlRestriction(query) + \" is null\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 682, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "IsNullExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "IsNullExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 683, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "IsNullExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "IsNullExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 684, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "IsNullExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "IsNullExpression.getSqlRestrictionFragments", "method_implementation": "{\n    if (this.not) {\n        return new String[] { this.inner.getSqlRestrictionFragments(query)[0] + \" IS NOT NULL\" };\n    }\n    return new String[] { this.inner.getSqlRestrictionFragments(query)[0] + \" IS NULL\" };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 685, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "JBoss7AnnotatedClassLocator.locateClasses": {"callee_method_names": ["URL.getFile", "PersistenceUnitMetadata.getAnnotationIndex", "PersistenceUnitMetadata.getAnnotationIndex", "PersistenceUnitMetadata.getClassLoader", "PersistenceUnitMetadata.getClassLoader", "PersistenceUnitMetadata.getClassLoader", "Set<Class<?>>.toString"], "method_name": "JBoss7AnnotatedClassLocator.locateClasses", "method_implementation": "{\n    JBoss7AnnotatedClassLocator.LOG.info(\"Checking persistence root {0} for persistence classes...\", url.getFile());\n    JBoss7AnnotatedClassLocator.lock.lock();\n    final Set<Class<?>> classes = Sets.newHashSet();\n    try {\n        final PersistenceUnitMetadata pu = (PersistenceUnitMetadata) persistenceUnitInfo;\n        if (pu.getAnnotationIndex() != null) {\n            final Index index = pu.getAnnotationIndex().get(url);\n            if (index == null) {\n                JBoss7AnnotatedClassLocator.LOG.info(\"No classes present in the jar url {0}\", url);\n                return Collections.emptySet();\n            }\n            this.locateClassesFor(pu.getClassLoader(), index, Embeddable.class, classes);\n            this.locateClassesFor(pu.getClassLoader(), index, MappedSuperclass.class, classes);\n            this.locateClassesFor(pu.getClassLoader(), index, Entity.class, classes);\n            JBoss7AnnotatedClassLocator.getClassCache(pu).put(url, classes);\n            return classes;\n        } else {\n            return JBoss7AnnotatedClassLocator.getClassCache(pu).get(url);\n        }\n    } finally {\n        JBoss7AnnotatedClassLocator.lock.unlock();\n        JBoss7AnnotatedClassLocator.LOG.info(\"Found persistent classes {0}\", classes.toString());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1056, "method_signature": "Set<Class<?>> locateClasses(PersistenceUnitInfo, URL)"}, "JarAnnotatedClassLocator.locateClasses": {"callee_method_names": ["URL.getFile", "Set<Class<?>>.toString"], "method_name": "JarAnnotatedClassLocator.locateClasses", "method_implementation": "{\n    final Set<Class<?>> classes = Sets.newHashSet();\n    try {\n        JarAnnotatedClassLocator.LOG.info(\"Checking persistence root {0} for persistence classes...\", url.getFile());\n        return this.findClasses(persistenceUnitInfo, url, classes);\n    } catch (final URISyntaxException e) {\n        throw new PersistenceException(\"Unable to read JAR url: \" + url, e);\n    } catch (final IOException e) {\n        throw new PersistenceException(\"Unable to read JAR url: \" + url, e);\n    } finally {\n        JarAnnotatedClassLocator.LOG.info(\"Found persistent classes {0}\", classes.toString());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1053, "method_signature": "Set<Class<?>> locateClasses(PersistenceUnitInfo, URL)"}, "JavaLocator.toString": {"callee_method_names": [], "method_name": "JavaLocator.toString", "method_implementation": "{\n    if (this.member != null) {\n        return ReflectHelper.createMemberName(this.member);\n    }\n    return this.clazz.getName();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1050, "method_signature": "String toString()"}, "JdbcAdaptor.createAlterTableStatement": {"callee_method_names": ["List<String>.add", "StringBuilder.append", "AbstractTable.getQName", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JdbcAdaptor.createAlterTableStatement", "method_implementation": "{\n    final List<String> ddlColumns = Lists.newArrayList();\n    for (final AbstractColumn column : columnsToAdd) {\n        final String columnDef = \"ADD COLUMN \" + this.createColumnDefinition(column);\n        ddlColumns.add(columnDef);\n    }\n    final StringBuilder statement = new StringBuilder();\n    // table part\n    statement.append(\"ALTER TABLE \").append(table.getQName()).append(\"\\n\\t\");\n    // columns part\n    statement.append(Joiner.on(\"\\n\\t\").join(ddlColumns));\n    return statement.toString();\n}", "repo_id": "1", "comment": "/**\n * Returns the SQL to alter the table.\n *\n * @param table\n *            the table\n * @param columnsToAdd\n *            the list of columns to add\n * @return the SQL to alter the table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1274, "method_signature": "String createAlterTableStatement(AbstractTable, List)"}, "JdbcAdaptor.createColumnDefinition": {"callee_method_names": ["AbstractColumn.getColumnDefinition", "AbstractColumn.getName", "AbstractColumn.getColumnDefinition"], "method_name": "JdbcAdaptor.createColumnDefinition", "method_implementation": "{\n    return (// check column definition\n    StringUtils.isBlank(column.getColumnDefinition()) ? // column definition is blank so generate one\n    this.createColumnDDL(column) : // use the column definition\n    column.getName() + \" \" + column.getColumnDefinition());\n}", "repo_id": "1", "comment": "/**\n * Creates column definition DDL for the column using the columnDefinition parameter.\n *\n * @param column\n * @return column definition DDL\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 1275, "method_signature": "String createColumnDefinition(AbstractColumn)"}, "JdbcAdaptor.createCreateTableStatement": {"callee_method_names": ["StringBuilder.append", "AbstractTable.getQName", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JdbcAdaptor.createCreateTableStatement", "method_implementation": "{\n    final String columns = Joiner.on(\",\\n\\t\").join(ddlColumns);\n    final String keys = Joiner.on(\", \").join(pkColumns);\n    final StringBuilder statement = new StringBuilder();\n    // table part\n    statement.append(\"CREATE TABLE \").append(table.getQName()).append(\" (\\n\\t\");\n    // columns part\n    statement.append(columns);\n    if (StringUtils.isNotBlank(keys)) {\n        statement.append(\",\");\n        statement.append(\"\\nPRIMARY KEY(\").append(keys).append(\")\");\n    }\n    statement.append(\")\");\n    return statement.toString();\n}", "repo_id": "1", "comment": "/**\n * Creates the create table statement\n *\n * @param table\n *            the definition of the table\n * @param ddlColumns\n *            the DDL for the columns\n * @param pkColumns\n *            the list of primary key column names\n * @param uniqueColumns\n *            the list of columns that are unique\n * @return the generated column fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1277, "method_signature": "String createCreateTableStatement(AbstractTable, Collection, List, List)"}, "JdbcAdaptor.createForeignKey": {"callee_method_ids": [1208, 1326, 1208, 1157, 1208, 1157, 1208, 1157], "callee_method_names": ["ForeignKey.getTable", "JdbcTable.getForeignKey", "ForeignKey.getName", "JdbcForeignKey.matches", "JdbcTable.getSchema", "JdbcTable.getName", "ForeignKey.getName", "QueryRunner.update", "ForeignKey.getReferencedTableQName", "ForeignKey.getTable", "ForeignKey.getJoinColumns", "ForeignKey.getJoinColumns", "ForeignKey.getName", "QueryRunner.update", "ForeignKey.getName", "QueryRunner.update"], "method_name": "JdbcAdaptor.createForeignKey", "method_implementation": "{\n    final QueryRunner runner = new QueryRunner(datasource, this.isPmdBroken());\n    try {\n        // locate the foreign key metada\n        final JdbcTable tableMetadata = this.getTableMetadata(datasource, foreignKey.getTable());\n        if (tableMetadata == null) {\n            JdbcAdaptor.LOG.warn(\"Foreign key {0} cannot be created, table not found: \", foreignKey);\n            return;\n        }\n        final JdbcForeignKey foreignKeyMetadata = tableMetadata.getForeignKey(foreignKey.getName());\n        // if it exists, then if there is no change then bail out, otherwise drop and continue with the creation\n        if (foreignKeyMetadata != null) {\n            if (!foreignKeyMetadata.matches(foreignKey)) {\n                final String sql = this.getDropForeignKeySql(tableMetadata.getSchema(), tableMetadata.getName(), foreignKey.getName());\n                runner.update(sql);\n            } else {\n                return;\n            }\n        }\n        // create the foreign key\n        final String referenceTableName = foreignKey.getReferencedTableQName();\n        final String tableName = foreignKey.getTable().getQName();\n        final String foreignKeyColumns = Joiner.on(\", \").join(Lists.transform(foreignKey.getJoinColumns(), new Function<JoinColumn, String>() {\n\n            @Override\n            public String apply(JoinColumn input) {\n                return input.getReferencedColumnName();\n            }\n        }));\n        final String keyColumns = Joiner.on(\", \").join(Lists.transform(foreignKey.getJoinColumns(), new Function<JoinColumn, String>() {\n\n            @Override\n            public String apply(JoinColumn input) {\n                return input.getName();\n            }\n        }));\n        final String sql = //\n        \"ALTER TABLE \" + tableName + \"\\n\\tADD CONSTRAINT \" + foreignKey.getName() + \" FOREIGN KEY (\" + keyColumns + //\n        \")\" + \"\\n\\tREFERENCES \" + referenceTableName + \"(\" + foreignKeyColumns + \")\";\n        runner.update(sql);\n        // create a foreign key index if not auto generated by DB\n        if (!isForeignKeyHasDefaultIndex()) {\n            final String sqlIndex = \"CREATE INDEX \" + foreignKey.getName() + \"_NDX\" + \" ON \" + referenceTableName + \"(\" + foreignKeyColumns + \")\";\n            runner.update(sqlIndex);\n        }\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot (re)create foreign key.\");\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates a foreign key on the table\n *\n * @param datasource\n *            the datasource\n * @param foreignKey\n *            the foreign key\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1278, "method_signature": "void createForeignKey(DataSource, ForeignKey)"}, "JdbcAdaptor.createIndex": {"callee_method_names": ["EntityTable.getQName"], "method_name": "JdbcAdaptor.createIndex", "method_implementation": "{\n    final String columnNames = Joiner.on(\", \").join(Lists.transform(Lists.newArrayList(columns), new Function<BasicColumn, String>() {\n\n        @Override\n        public String apply(BasicColumn input) {\n            return input.getName();\n        }\n    }));\n    new QueryRunner(datasource, this.isPmdBroken()).update(\"CREATE INDEX \" + indexName + \" ON \" + table.getQName() + \"(\" + columnNames + \")\");\n}", "repo_id": "1", "comment": "/**\n * Creates the index for the table.\n *\n * @param datasource\n *            the datasource\n * @param table\n *            the table\n * @param indexName\n *            the name of the index\n * @param columns\n *            the columns\n * @throws SQLException\n *             throw in case index creation fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1279, "method_signature": "void createIndex(DataSource, EntityTable, String, BasicColumn[])"}, "JdbcAdaptor.createOrUpdateTable": {"callee_method_names": ["AbstractTable.getQName"], "method_name": "JdbcAdaptor.createOrUpdateTable", "method_implementation": "{\n    try {\n        if ((ddlMode == DDLMode.DROP) || (ddlMode == DDLMode.CREATE)) {\n            final JdbcTable tableMetadata = this.getTableMetadata(datasource, table);\n            if (tableMetadata == null) {\n                this.createTable(datasource, table);\n            }\n        } else if (ddlMode == DDLMode.UPDATE) {\n            final JdbcTable tableMetadata = this.getTableMetadata(datasource, table);\n            if (tableMetadata == null) {\n                this.createTable(datasource, table);\n            } else {\n                this.updateTable(datasource, table);\n            }\n        }\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Table DDL Failed for table \" + table.getQName());\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates or update the table.\n *\n * @param table\n *            the table\n * @param datasource\n *            the datasource\n * @param ddlMode\n *            the ddl mode\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1280, "method_signature": "void createOrUpdateTable(AbstractTable, DataSource, DDLMode)"}, "JdbcAdaptor.createTableGeneratorIfNecessary": {"callee_method_names": ["TableGenerator.getCatalog", "TableGenerator.getSchema", "TableGenerator.getTable", "TableGenerator.getQName", "TableGenerator.getPkColumnName", "TableGenerator.getValueColumnName", "TableGenerator.getPkColumnName", "TableGenerator.getTable"], "method_name": "JdbcAdaptor.createTableGeneratorIfNecessary", "method_implementation": "{\n    try {\n        if (this.getTableMetadata(datasource, table.getCatalog(), table.getSchema(), table.getTable()) == null) {\n            final String sql = //\n            \"CREATE TABLE \" + table.getQName() + \" (\" + \"\\n\\t\" + table.getPkColumnName() + //\n            \" VARCHAR(255),\" + \"\\n\\t\" + table.getValueColumnName() + //\n            \" INT,\" + \"\\nPRIMARY KEY(\" + table.getPkColumnName() + \"))\";\n            new QueryRunner(datasource, this.isPmdBroken()).update(sql);\n        }\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot create table generator \" + table.getTable());\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates the table generator if not exists.\n *\n * @param datasource\n *            the datasource to use\n * @param table\n *            the table generator\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1281, "method_signature": "void createTableGeneratorIfNecessary(DataSource, TableGenerator)"}, "JdbcAdaptor.dropAllForeignKeys": {"callee_method_ids": [1208, 1208], "callee_method_names": ["Set<AbstractTable>.toArray", "Set<AbstractTable>.size", "E.getForeignKeys", "Object.getReferencedTableQName", "E.getQName", "E.getForeignKeys", "Object.getReferencedTableQName", "E.getQName", "TableGenerator.getName", "JdbcTable.getForeignKeys", "TableGenerator.getSchema", "TableGenerator.getName", "ForeignKey.getName", "ForeignKey.getName"], "method_name": "JdbcAdaptor.dropAllForeignKeys", "method_implementation": "{\n    final AbstractTable[] tables = tableSet.toArray(new AbstractTable[tableSet.size()]);\n    try {\n        // Order tables by dependency\n        Arrays.sort(tables, new Comparator<AbstractTable>() {\n\n            @Override\n            public int compare(AbstractTable o1, AbstractTable o2) {\n                if ((o1 instanceof JoinTable) && !(o2 instanceof JoinTable)) {\n                    return -1;\n                }\n                if ((o2 instanceof JoinTable) && !(o1 instanceof JoinTable)) {\n                    return 1;\n                }\n                if ((o1 instanceof CollectionTable) && !(o2 instanceof CollectionTable)) {\n                    return -1;\n                }\n                if ((o2 instanceof CollectionTable) && !(o1 instanceof CollectionTable)) {\n                    return 1;\n                }\n                if ((o1 instanceof SecondaryTable) && !(o2 instanceof SecondaryTable)) {\n                    return -1;\n                }\n                if ((o2 instanceof SecondaryTable) && !(o1 instanceof SecondaryTable)) {\n                    return 1;\n                }\n                for (final ForeignKey key : o1.getForeignKeys()) {\n                    if (key.getReferencedTableQName().equals(o2.getQName())) {\n                        return 1;\n                    }\n                }\n                for (final ForeignKey key : o2.getForeignKeys()) {\n                    if (key.getReferencedTableQName().equals(o2.getQName())) {\n                        return -1;\n                    }\n                }\n                return 0;\n            }\n        });\n    } catch (final IllegalArgumentException e) {\n        JdbcAdaptor.LOG.warn(e, \"\");\n    }\n    for (final AbstractTable table : tables) {\n        JdbcTable tableMetadata = null;\n        try {\n            tableMetadata = this.getTableMetadata(datasource, table);\n        } catch (final SQLException e) {\n            this.logRelaxed(e, \"Cannot drop foreign keys for table \" + table.getName());\n        }\n        if (tableMetadata != null) {\n            for (final JdbcForeignKey foreignKey : tableMetadata.getForeignKeys()) {\n                try {\n                    new QueryRunner(datasource, this.isPmdBroken()).update(this.getDropForeignKeySql(table.getSchema(), table.getName(), foreignKey.getName()));\n                } catch (final SQLException e) {\n                    this.logRelaxed(e, \"Cannot drop foreign key \" + foreignKey.getName());\n                }\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * @param datasource\n *            the datasource\n * @param tableSet\n *            the foreign keys\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1282, "method_signature": "void dropAllForeignKeys(DataSource, Set)"}, "JdbcAdaptor.dropAllSequences": {"callee_method_names": [], "method_name": "JdbcAdaptor.dropAllSequences", "method_implementation": "{\n    final QueryRunner runner = new QueryRunner(datasource, this.isPmdBroken());\n    for (final SequenceGenerator sequence : sequences) {\n        try {\n            this.dropSequence(runner, sequence);\n        } catch (final SQLException e) {\n            this.logRelaxed(e, \"Cannot drop sequence.\");\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * @param datasource\n *            the datasource\n * @param sequences\n *            the sequences\n * @throws SQLException\n *             thrown if the SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1283, "method_signature": "void dropAllSequences(DataSource, Collection)"}, "JdbcAdaptor.dropAllTables": {"callee_method_ids": [1157], "callee_method_names": ["TableGenerator.getName", "QueryRunner.update"], "method_name": "JdbcAdaptor.dropAllTables", "method_implementation": "{\n    final QueryRunner runner = new QueryRunner(datasource, this.isPmdBroken());\n    for (final AbstractTable table : tables) {\n        try {\n            final JdbcTable tableMetadata = this.getTableMetadata(datasource, table);\n            this.tables.remove(table);\n            if (tableMetadata != null) {\n                this.dropTable(runner, table);\n            }\n        } catch (final SQLException e) {\n            this.logRelaxed(e, \"Cannot drop table \" + table.getName());\n        }\n    }\n    try {\n        runner.update(\"DROP TABLE BATOO_ID\");\n    } catch (final SQLException e) {\n    }\n}", "repo_id": "1", "comment": "/**\n * Drops the tables in the database\n *\n * @param datasource\n *            the datasource\n * @param tables\n *            the set of tables to drop\n * @throws SQLException\n *             thrown if the SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1284, "method_signature": "void dropAllTables(DataSource, Collection)"}, "JdbcAdaptor.escape": {"callee_method_names": ["String.toUpperCase"], "method_name": "JdbcAdaptor.escape", "method_implementation": "{\n    if (name == null) {\n        return null;\n    }\n    if (this.words.contains(name.toUpperCase(Locale.ENGLISH))) {\n        return name + \"_\";\n    }\n    return name;\n}", "repo_id": "1", "comment": "/**\n * Escapes an SQL name\n *\n * @param name\n *            the original name\n * @return the escaped name\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1285, "method_signature": "String escape(String)"}, "JdbcAdaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "JdbcAdaptor.getColumnType", "method_implementation": "{\n    switch(sqlType) {\n        case Types.BLOB:\n            return \"BLOB(\" + cd.getLength() + \")\";\n        case Types.CLOB:\n            return \"CLOB(\" + cd.getLength() + \")\";\n        case Types.VARCHAR:\n            return \"VARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n            return \"TIME\";\n        case Types.DATE:\n            return \"DATE\";\n        case Types.TIMESTAMP:\n            return \"TIMESTAMP\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"BOOLEAN\";\n        case Types.TINYINT:\n        case Types.SMALLINT:\n            return \"SMALLINT\";\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"BIGINT\";\n        case Types.FLOAT:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DOUBLE:\n            return \"DOUBLE\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"DECIMAL\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * Returns the data type of the column.\n *\n * @param cd\n *            the column definition\n * @param sqlType\n *            the sql type\n * @return the data type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1287, "method_signature": "String getColumnType(AbstractColumn, int)"}, "JdbcAdaptor.getColumns": {"callee_method_ids": [1226], "callee_method_names": ["AbstractTable.getColumns", "E.isPrimaryKey", "E.isPrimaryKey", "E.isPrimaryKey", "E.isPrimaryKey", "E.getName", "E.getName"], "method_name": "JdbcAdaptor.getColumns", "method_implementation": "{\n    final List<AbstractColumn> columns = Lists.newArrayList(table.getColumns());\n    Collections.sort(columns, new Comparator<AbstractColumn>() {\n\n        @Override\n        public int compare(AbstractColumn o1, AbstractColumn o2) {\n            if (o1.isPrimaryKey() && !o2.isPrimaryKey()) {\n                return -1;\n            }\n            if (o2.isPrimaryKey() && !o1.isPrimaryKey()) {\n                return 1;\n            }\n            return o1.getName().compareTo(o2.getName());\n        }\n    });\n    return columns;\n}", "repo_id": "1", "comment": "/**\n * Returns the sorted columns.\n *\n * @param table\n *            the table\n * @return the sorted columns\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1286, "method_signature": "Collection<AbstractColumn> getColumns(AbstractTable)"}, "JdbcAdaptor.getDateTimeFunctionTemplate": {"callee_method_names": [], "method_name": "JdbcAdaptor.getDateTimeFunctionTemplate", "method_implementation": "{\n    switch(type) {\n        case SECOND:\n            return \"SECOND({0})\";\n        case MINUTE:\n            return \"MINUTE({0})\";\n        case HOUR:\n            return \"HOUR({0})\";\n        case DAYOFMONTH:\n            return \"DAY_OF_MONTH({0})\";\n        case DAYOFWEEK:\n            return \"DAY_OF_WEEK({0})\";\n        case DAYOFYEAR:\n            return \"DAY_OF_YEAR({0})\";\n        case MONTH:\n            return \"MONTH({0})\";\n        case WEEK:\n            return \"WEEK({0})\";\n        default:\n            // YEAR\n            return \"YEAR({0})\";\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the date time function template for the type <code>type</code>.\n *\n * @param type\n *            the type of the function\n * @return the date time function template for the type <code>type</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1288, "method_signature": "String getDateTimeFunctionTemplate(DateTimeFunctionType)"}, "JdbcAdaptor.getDropForeignKeySql": {"callee_method_names": [], "method_name": "JdbcAdaptor.getDropForeignKeySql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(schema, table);\n    return \"ALTER TABLE \" + qualifiedName + \" DROP FOREIGN KEY \" + foreignKey;\n}", "repo_id": "1", "comment": "/**\n * Returns the SQL to drop the foreign key.\n *\n * @param schema\n *            the name of the schema\n * @param table\n *            the name of the table\n * @param foreignKey\n *            the name of the foreign key\n * @return the SQL to drop the foreign key\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1289, "method_signature": "String getDropForeignKeySql(String, String, String)"}, "JdbcAdaptor.getNumericFunctionTemplate": {"callee_method_names": [], "method_name": "JdbcAdaptor.getNumericFunctionTemplate", "method_implementation": "{\n    switch(type) {\n        case ABS:\n            return \"ABS({0})\";\n        case LENGTH:\n            return \"LENGTH({0})\";\n        case MOD:\n            return \"MOD({0}, {1})\";\n        default:\n            return \"SQRT({0})\";\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the numeric function template.\n *\n * @param type\n *            the id type\n * @return the {@link IdType} selected, the {@link Id} passed or null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1290, "method_signature": "String getNumericFunctionTemplate(NumericFunctionType)"}, "JdbcAdaptor.getPkCreateSql": {"callee_method_names": [], "method_name": "JdbcAdaptor.getPkCreateSql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(new String[] { schema, table });\n    return \"ALTER TABLE \" + qualifiedName + \" ADD PRIMARY KEY (\" + Joiner.on(\", \").join(pkColumns) + \")\";\n}", "repo_id": "1", "comment": "/**\n * Returns the priary key drop SQL.\n *\n * @param schema\n *            the name of the schema\n * @param table\n *            the name of the table\n * @param pkColumns\n *            the set of the primary key column names\n * @return the priary key drop SQL\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1291, "method_signature": "String getPkCreateSql(String, String, Set)"}, "JdbcAdaptor.getPkDropSql": {"callee_method_names": [], "method_name": "JdbcAdaptor.getPkDropSql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(new String[] { schema, table });\n    return \"ALTER TABLE \" + qualifiedName + \" DROP PRIMARY KEY\";\n}", "repo_id": "1", "comment": "/**\n * Returns the priary key drop SQL.\n *\n * @param schema\n *            the name of the schema\n * @param table\n *            the name of the table\n * @param pkName\n *            the name of the primary key\n * @return the priary key drop SQL\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1292, "method_signature": "String getPkDropSql(String, String, String)"}, "JdbcAdaptor.importSql": {"callee_method_names": ["ClassLoader.getResourceAsStream", "InputStream.close", "DataSource.getConnection", "Connection.setAutoCommit", "Connection.createStatement", "BufferedReader.readLine", "String.trim", "String.startsWith", "String.startsWith", "String.startsWith", "Iterator<String>.hasNext", "Statement.execute", "Iterator<String>.next", "Connection.setAutoCommit"], "method_name": "JdbcAdaptor.importSql", "method_implementation": "{\n    // no import sql\n    if (StringUtils.isBlank(importSqlFileName)) {\n        return;\n    }\n    final InputStream is = classLoader.getResourceAsStream(importSqlFileName);\n    if (is == null) {\n        JdbcAdaptor.LOG.error(\"Cannot load the import sql resource: {0}\", importSqlFileName);\n        return;\n    }\n    final String sql;\n    try {\n        sql = IOUtils.toString(is);\n    } catch (final Exception e) {\n        JdbcAdaptor.LOG.error(e, \"Cannot load the import sql resource: {0}\", importSqlFileName);\n        return;\n    } finally {\n        try {\n            is.close();\n        } catch (final IOException e) {\n        }\n    }\n    JdbcAdaptor.LOG.info(\"Executing import sql: {0}\", importSqlFileName);\n    try {\n        final Connection connection = dataSource.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            final Statement statement = connection.createStatement();\n            try {\n                final BufferedReader reader = new BufferedReader(new StringReader(sql));\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    final String sqlLine = line.trim();\n                    if (sqlLine.startsWith(\"--\")) {\n                        continue;\n                    } else if (sqlLine.startsWith(\"//\")) {\n                        continue;\n                    } else if (sqlLine.startsWith(\"/*\")) {\n                        continue;\n                    }\n                    final Iterator<String> statements = Splitter.on(\";\").omitEmptyStrings().split(sqlLine).iterator();\n                    while (statements.hasNext()) {\n                        try {\n                            statement.execute(statements.next());\n                        } catch (final SQLException e) {\n                            JdbcAdaptor.LOG.error(\"Error executing sql import fragment: {0}\", sqlLine);\n                            throw e;\n                        }\n                    }\n                }\n                connection.setAutoCommit(true);\n            } finally {\n                DbUtils.closeQuietly(statement);\n            }\n        } finally {\n            DbUtils.closeQuietly(connection);\n        }\n    } catch (final Exception e) {\n        JdbcAdaptor.LOG.error(e, \"Error executing import sql: {0}\", importSqlFileName);\n    }\n    JdbcAdaptor.LOG.info(\"Import successful.\");\n}", "repo_id": "1", "comment": "/**\n * Executes the initial import sql.\n *\n * @param classLoader\n *            the class loader\n * @param dataSource\n *            the datasource\n * @param importSqlFileName\n *            the name of the import sql\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1293, "method_signature": "void importSql(ClassLoader, DataSource, String)"}, "JdbcAdaptor.qualified": {"callee_method_names": [], "method_name": "JdbcAdaptor.qualified", "method_implementation": "{\n    if (StringUtils.isBlank(schema)) {\n        return jdbcClassName;\n    }\n    return schema + \".\" + jdbcClassName;\n}", "repo_id": "1", "comment": "/**\n * Returns the schema if it is set otherwise falls back to the default schema.\n *\n * @param schema\n *            the schema name\n * @param jdbcClassName\n *            the name of the table or sequence\n * @return the proper schema name\n * @throws SQLException\n *             thrown in case of an SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1294, "method_signature": "String qualified(String, String)"}, "JdbcForeignKey.addColumn": {"callee_method_names": ["ResultSet.getString", "ResultSet.getString", "String.toUpperCase"], "method_name": "JdbcForeignKey.addColumn", "method_implementation": "{\n    final String columnName = metadata.getString(JdbcForeignKey.FKCOLUMN_NAME);\n    final String referencedColumnName = metadata.getString(JdbcForeignKey.PKCOLUMN_NAME);\n    this.columns.put(columnName.toUpperCase(), referencedColumnName);\n}", "repo_id": "1", "comment": "/**\n * Adds a column to the foreign key.\n *\n * @param metadata\n *            the column metadata\n * @throws SQLException\n *             thrown in case of an SQL error.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1325, "method_signature": "void addColumn(ResultSet)"}, "JdbcForeignKey.matches": {"callee_method_names": ["ForeignKey.getReferencedTableName", "ForeignKey.getJoinColumns", "ForeignKey.getJoinColumns", "JoinColumn.getName", "String.equalsIgnoreCase", "JoinColumn.getReferencedColumnName"], "method_name": "JdbcForeignKey.matches", "method_implementation": "{\n    // referenced table name must match\n    if (!this.refTable.equalsIgnoreCase(foreignKey.getReferencedTableName())) {\n        return false;\n    }\n    // number of columns must match\n    if (this.columns.size() != foreignKey.getJoinColumns().size()) {\n        return false;\n    }\n    // each column must match\n    for (final JoinColumn joinColumn : foreignKey.getJoinColumns()) {\n        final String referencedColumnName = this.columns.get(joinColumn.getName().toUpperCase());\n        if ((referencedColumnName == null) || !referencedColumnName.equalsIgnoreCase(joinColumn.getReferencedColumnName())) {\n            return false;\n        }\n    }\n    // keys match!\n    return true;\n}", "repo_id": "1", "comment": "/**\n * Checks if the metadata matches the foreign key definition.\n *\n * @param foreignKey\n *            the foreign key definition\n * @return true if it matches, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1326, "method_signature": "boolean matches(ForeignKey)"}, "JdbcTable.logNotNullExtraColumns": {"callee_method_names": ["Set<String>.add", "AbstractColumn.isNullable", "Set<String>.contains", "AbstractColumn.getName", "Set<String>.add", "AbstractColumn.getName", "Set<String>.isEmpty"], "method_name": "JdbcTable.logNotNullExtraColumns", "method_implementation": "{\n    final Set<String> nonNullColumns = Sets.newHashSet();\n    final Set<String> columns2 = Sets.newHashSet();\n    for (final String columnName : columns) {\n        columns2.add(columnName.toUpperCase());\n    }\n    for (final JdbcColumn column : this.columns.values()) {\n        if (!column.isNullable() && !columns2.contains(column.getName().toUpperCase())) {\n            nonNullColumns.add(column.getName());\n        }\n    }\n    if (!nonNullColumns.isEmpty()) {\n        JdbcTable.LOG.warn(\"Table {0} has non null columns that are not referenced by the persistence unit {1}\", this.name, nonNullColumns);\n    }\n}", "repo_id": "1", "comment": "/**\n * Logs the list of columns that do now exist in the persistence unit yet not nullable.\n *\n * @param columns\n *            the set of columns\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1309, "method_signature": "void logNotNullExtraColumns(Collection)"}, "JdbcTable.requiresPkDrop": {"callee_method_names": ["Set<String>.add", "Set<String>.equals"], "method_name": "JdbcTable.requiresPkDrop", "method_implementation": "{\n    if (this.pkColumns.isEmpty()) {\n        return false;\n    }\n    final Set<String> pkColumnNames2 = Sets.newHashSet();\n    for (final String columnName : pkColumnNames) {\n        pkColumnNames2.add(columnName.toUpperCase());\n    }\n    return !pkColumnNames2.equals(this.pkColumns);\n}", "repo_id": "1", "comment": "/**\n * Returns if primary key drop is required.\n *\n * @param pkColumnNames\n *            the set of required primary keys\n * @return true if primary key drop is required, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1310, "method_signature": "boolean requiresPkDrop(Set)"}, "JoinColumn.getValue": {"callee_method_names": [], "method_name": "JoinColumn.getValue", "method_implementation": "{\n    final Object value = this.mapping != null ? this.mapping.get(instance) : instance;\n    return value != null ? this.referencedColumn.getValue(connection, value) : null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1216, "method_signature": "Object getValue(Connection, Object)"}, "JoinColumn.setColumnProperties": {"callee_method_names": ["AssociationMapping<?,?,?>.getName", "AbstractColumn.getName", "AbstractColumn.getMapping", "EntityTypeDescriptor.getName", "AbstractColumn.getName"], "method_name": "JoinColumn.setColumnProperties", "method_implementation": "{\n    // if attribute present then the join column belongs to an entity table\n    if (mapping != null) {\n        this.mapping = mapping;\n        if (StringUtils.isBlank(this.name)) {\n            this.name = this.jdbcAdaptor.escape(mapping.getName() + \"_\" + referencedColumn.getName());\n        }\n    } else {\n        final EntityTypeDescriptor type = (EntityTypeDescriptor) referencedColumn.getMapping().getRoot().getTypeDescriptor();\n        if (StringUtils.isBlank(this.name)) {\n            this.name = this.jdbcAdaptor.escape(type.getName() + \"_\" + referencedColumn.getName());\n        }\n    }\n    if (id) {\n        super.setId();\n    }\n    this.setColumnProperties(referencedColumn);\n}", "repo_id": "1", "comment": "/**\n * Sets the column definition.\n *\n * @param mapping\n *            the owner mapping\n * @param referencedColumn\n *            the referenced column\n * @param id\n *            if the column is id column\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1218, "method_signature": "void setColumnProperties(AssociationMapping, AbstractColumn, boolean)"}, "JoinColumn.setTable": {"callee_method_names": [], "method_name": "JoinColumn.setTable", "method_implementation": "{\n    this.table = table;\n    if (!this.isVirtual()) {\n        this.table.addColumn(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1219, "method_signature": "void setTable(AbstractTable)"}, "JoinColumn.setValue": {"callee_method_names": [], "method_name": "JoinColumn.setValue", "method_implementation": "{\n    if (this.mapping != null) {\n        this.mapping.set(instance, value);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1220, "method_signature": "void setValue(Object, Object)"}, "JoinColumn.toString": {"callee_method_names": [], "method_name": "JoinColumn.toString", "method_implementation": "{\n    final String tableName = this.getTable() != null ? this.getTable().getName() : \"N/A\";\n    final String mapping = this.getMapping() != null ? \" \" + this.getMapping().toString() + \" \" : \"\";\n    return this.getClass().getSimpleName() + mapping + \" [name=\" + this.getName() + \", type=\" + this.getSqlType() + \", length=\" + this.getLength() + \", precision=\" + this.getPrecision() + \", scale=\" + this.getScale() + \", table=\" + tableName + \", refrencedColumn=\" + this.referencedColumn + \"]\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1221, "method_signature": "String toString()"}, "JoinColumnElement.generate": {"callee_method_names": [], "method_name": "JoinColumnElement.generate", "method_implementation": "{\n    super.generate();\n    this.referencedColumnName = this.getAttribute(ElementConstants.ATTR_REFERENCED_COLUMN_NAME, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1124, "method_signature": "void generate()"}, "JoinTable.createJoin": {"callee_method_names": [], "method_name": "JoinTable.createJoin", "method_implementation": "{\n    String sourceJoin, destinationJoin;\n    if (forward) {\n        sourceJoin = this.sourceKey.createSourceJoin(joinType, parentAlias, alias + \"_J\");\n        destinationJoin = this.destinationKey.createDestinationJoin(joinType, alias + \"_J\", alias);\n    } else {\n        sourceJoin = this.destinationKey.createSourceJoin(joinType, parentAlias, alias + \"_J\");\n        destinationJoin = this.sourceKey.createDestinationJoin(joinType, alias + \"_J\", alias);\n    }\n    return sourceJoin + \"\\n\" + destinationJoin;\n}", "repo_id": "1", "comment": "/**\n * Creates a join between the source and destination entities\n *\n * @param joinType\n *            the type of the join\n * @param parentAlias\n *            the alias of the parent table\n * @param alias\n *            the alias of the table\n * @param forward\n *            if the join if forward or backwards\n * @return the join SQL fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1340, "method_signature": "String createJoin(JoinType, String, String, boolean)"}, "JoinTable.link": {"callee_method_names": ["EntityTypeDescriptor.getName", "EntityTypeDescriptor.getName"], "method_name": "JoinTable.link", "method_implementation": "{\n    if (this.getName() == null) {\n        this.setName(source.getName() + \"_\" + destination.getName());\n    }\n    this.sourceKey.link(null, source);\n    this.destinationKey.link(null, destination);\n    this.sourceKey.setTable(this);\n    this.destinationKey.setTable(this);\n}", "repo_id": "1", "comment": "/**\n * @param source\n *            the source entity\n * @param destination\n *            the destination entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1341, "method_signature": "void link(EntityTypeDescriptor, EntityTypeDescriptor)"}, "JoinTable.performInsert": {"callee_method_names": ["Joinable.getValue", "Joinable.getIndex", "AbstractColumn.getValue"], "method_name": "JoinTable.performInsert", "method_implementation": "{\n    final String insertSql = this.getInsertSql(null, size);\n    final AbstractColumn[] insertColumns = this.getInsertColumns(null, size);\n    // prepare the parameters\n    final Object[] params = new Object[insertColumns.length * size];\n    int paramIndex = 0;\n    for (int i = 0; i < size; i++) {\n        for (final AbstractColumn column : insertColumns) {\n            final Joinable joinable = batch[i];\n            final Object destination = joinable.getValue();\n            final int order = joinable.getIndex();\n            final Object object = this.sourceKey.getJoinColumns().contains(column) ? source : destination;\n            if (column != this.orderColumn) {\n                params[paramIndex++] = column.getValue(connection, object);\n            } else {\n                params[paramIndex++] = order;\n            }\n        }\n    }\n    new QueryRunner(this.jdbcAdaptor, false).update(connection, insertSql, params);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1342, "method_signature": "void performInsert(Connection, Object, Joinable[], int)"}, "JoinTable.performRemove": {"callee_method_names": [], "method_name": "JoinTable.performRemove", "method_implementation": "{\n    final String removeSql = this.getRemoveSql();\n    final Object[] params = new Object[this.sourceKey.getJoinColumns().size() + this.destinationKey.getJoinColumns().size()];\n    int i = 0;\n    for (final JoinColumn sourceRemoveColumn : this.sourceRemoveColumns) {\n        params[i++] = sourceRemoveColumn.getValue(connection, source);\n    }\n    for (final JoinColumn destinationRemoveColumn : this.destinationRemoveColumns) {\n        params[i++] = destinationRemoveColumn.getValue(connection, destination);\n    }\n    new QueryRunner(this.jdbcAdaptor, false).update(connection, removeSql, params);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1343, "method_signature": "void performRemove(Connection, Object, Object, Object)"}, "JoinTable.performRemoveAll": {"callee_method_names": [], "method_name": "JoinTable.performRemoveAll", "method_implementation": "{\n    final String removeAllSql = this.getRemoveAllSql();\n    final Object[] params = new Object[this.removeAllColumns.length];\n    int i = 0;\n    for (final JoinColumn sourceRemoveColumn : this.removeAllColumns) {\n        params[i++] = sourceRemoveColumn.getValue(connection, source);\n    }\n    new QueryRunner(this.jdbcAdaptor, false).update(connection, removeAllSql, params);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1344, "method_signature": "void performRemoveAll(Connection, Object)"}, "JoinTableElement.handleChild": {"callee_method_names": [], "method_name": "JoinTableElement.handleChild", "method_implementation": "{\n    super.handleChild(child);\n    if (child instanceof JoinTableElement) {\n        this.joinColumns.add((JoinColumnMetadata) child);\n    }\n    if (child instanceof InverseJoinColumnElement) {\n        this.inverseJoinColumns.add((JoinColumnMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1074, "method_signature": "void handleChild(Element)"}, "JoinedInheritanceSimpleTest.testSimpleInheritance0": {"callee_method_names": ["Foo.setValue", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getValue", "Foo.getValue"], "method_name": "JoinedInheritanceSimpleTest.testSimpleInheritance0", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.setValue(\"Value\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with root type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2214, "method_signature": "void testSimpleInheritance0()"}, "JoinedInheritanceSimpleTest.testSimpleInheritance1": {"callee_method_names": ["FooExt1.setValue", "FooExt1.setValueExt1", "FooExt1.getKey", "FooExt1.getKey", "FooExt1.getKey", "FooExt1.getValue", "FooExt1.getValue", "FooExt1.getValueExt1", "FooExt1.getValueExt1"], "method_name": "JoinedInheritanceSimpleTest.testSimpleInheritance1", "method_implementation": "{\n    final FooExt1 foo = new FooExt1();\n    foo.setValue(\"Value\");\n    foo.setValueExt1(\"ValueExt1\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt1 foo2 = this.find(FooExt1.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo2.getValueExt1());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with extending type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2215, "method_signature": "void testSimpleInheritance1()"}, "JoinedInheritanceSimpleTest.testSimpleInheritance11": {"callee_method_names": ["FooExt11.setValue", "FooExt11.setValueExt1", "FooExt11.setValueExt11", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getValue", "FooExt11.getValue", "FooExt11.getValueExt1", "FooExt11.getValueExt1", "FooExt11.getValueExt11", "FooExt11.getValueExt11"], "method_name": "JoinedInheritanceSimpleTest.testSimpleInheritance11", "method_implementation": "{\n    final FooExt11 foo = new FooExt11();\n    foo.setValue(\"Value\");\n    foo.setValueExt1(\"ValueExt1\");\n    foo.setValueExt11(\"ValueExt11\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt11 foo2 = this.find(FooExt11.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo2.getValueExt1());\n    Assert.assertEquals(foo.getValueExt11(), foo2.getValueExt11());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with further extending type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2216, "method_signature": "void testSimpleInheritance11()"}, "JoinedInheritanceSimpleTest.testSimpleInheritance3": {"callee_method_names": ["FooExt11.setValue", "FooExt11.setValueExt1", "FooExt11.setValueExt11", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getValue", "FooExt11.getValue", "FooExt11.getValueExt1", "FooExt11.getValueExt1", "FooExt11.getValueExt11", "FooExt11.getValueExt11"], "method_name": "JoinedInheritanceSimpleTest.testSimpleInheritance3", "method_implementation": "{\n    final FooExt11 foo = new FooExt11();\n    foo.setValue(\"Value\");\n    foo.setValueExt1(\"ValueExt1\");\n    foo.setValueExt11(\"ValueExt11\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt11 foo2 = (FooExt11) this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo2.getValueExt1());\n    Assert.assertEquals(foo.getValueExt11(), foo2.getValueExt11());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with root type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2217, "method_signature": "void testSimpleInheritance3()"}, "JoinedInheritanceTest.testSimpleInheritence0": {"callee_method_names": ["Foo.setValue", "Foo.setValue", "Bar.getFoos", "Bar.getFoos", "Bar.getKey", "Bar.getFoos", "Bar.getFoos"], "method_name": "JoinedInheritanceTest.testSimpleInheritence0", "method_implementation": "{\n    final Foo foo1 = new Foo();\n    foo1.setValue(\"Value\");\n    final Foo foo2 = new Foo();\n    foo2.setValue(\"Value\");\n    final Bar bar = new Bar();\n    bar.getFoos().add(foo1);\n    bar.getFoos().add(foo2);\n    this.persist(bar);\n    this.commit();\n    this.close();\n    final Bar bar2 = this.em().find(Bar.class, bar.getKey());\n    final Set<Foo> foos = Sets.newHashSet(foo1, foo2);\n    final Set<Foo> foos2 = Sets.newHashSet(bar2.getFoos());\n    Assert.assertEquals(bar2.getFoos().size(), 2);\n    Assert.assertEquals(foos, foos2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with root type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2220, "method_signature": "void testSimpleInheritence0()"}, "JoinedInheritanceTest.testSimpleInheritence1": {"callee_method_names": ["Foo.setValue", "FooExt1.setValue", "FooExt1.setValueExt1", "Bar.getFoos", "Bar.getFoos", "Bar.getKey", "Bar.getFoos", "Bar.getFoos"], "method_name": "JoinedInheritanceTest.testSimpleInheritence1", "method_implementation": "{\n    final Foo foo1 = new Foo();\n    foo1.setValue(\"Value\");\n    final FooExt1 foo2 = new FooExt1();\n    foo2.setValue(\"Value\");\n    foo2.setValueExt1(\"ValueExt1\");\n    final Bar bar = new Bar();\n    bar.getFoos().add(foo1);\n    bar.getFoos().add(foo2);\n    this.persist(bar);\n    this.commit();\n    this.close();\n    final Bar bar2 = this.em().find(Bar.class, bar.getKey());\n    final Set<Foo> foos = Sets.newHashSet(foo1, foo2);\n    final Set<Foo> foos2 = Sets.newHashSet(bar2.getFoos());\n    Assert.assertEquals(bar2.getFoos().size(), 2);\n    Assert.assertEquals(foos, foos2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with root type with mixed classes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2221, "method_signature": "void testSimpleInheritence1()"}, "JoinedInheritanceTest.testSimpleInheritence2": {"callee_method_names": ["FooExt1.setValue", "FooExt1.setValueExt1", "FooExt11.setValue", "FooExt11.setValueExt1", "Bar2.getFoos", "Bar2.getFoos", "Bar2.getKey", "Bar2.getFoos", "Bar2.getFoos"], "method_name": "JoinedInheritanceTest.testSimpleInheritence2", "method_implementation": "{\n    final FooExt1 foo1 = new FooExt1();\n    foo1.setValue(\"Value\");\n    foo1.setValueExt1(\"ValueExt1\");\n    final FooExt11 foo2 = new FooExt11();\n    foo2.setValue(\"Value\");\n    foo2.setValueExt1(\"ValueExt1\");\n    final Bar2 bar = new Bar2();\n    bar.getFoos().add(foo1);\n    bar.getFoos().add(foo2);\n    this.persist(bar);\n    this.commit();\n    this.close();\n    final Bar2 bar2 = this.em().find(Bar2.class, bar.getKey());\n    final Set<FooExt1> foos = Sets.newHashSet(foo1, foo2);\n    final Set<FooExt1> foos2 = Sets.newHashSet(bar2.getFoos());\n    Assert.assertEquals(bar2.getFoos().size(), 2);\n    Assert.assertEquals(foos, foos2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with root type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2222, "method_signature": "void testSimpleInheritence2()"}, "JpqlLexer.mA": {"callee_method_names": [], "method_name": "JpqlLexer.mA", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:23:12: ( 'A' | 'a' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'A' || input.LA(1) == 'a') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"A\"\n", "repo_name": "BatooJPA-master/", "id": 1468, "method_signature": "void mA()"}, "JpqlLexer.mABS": {"callee_method_names": [], "method_name": "JpqlLexer.mABS", "method_implementation": "{\n    try {\n        int _type = ABS;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:78:5: ( A B S )\n        // org/batoo/jpa/jpql/JpqlLexer.g:79:5: A B S\n        {\n            mA();\n            mB();\n            mS();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ABS\"\n", "repo_name": "BatooJPA-master/", "id": 1495, "method_signature": "void mABS()"}, "JpqlLexer.mALL": {"callee_method_names": [], "method_name": "JpqlLexer.mALL", "method_implementation": "{\n    try {\n        int _type = ALL;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:81:5: ( A L L )\n        // org/batoo/jpa/jpql/JpqlLexer.g:82:5: A L L\n        {\n            mA();\n            mL();\n            mL();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ALL\"\n", "repo_name": "BatooJPA-master/", "id": 1496, "method_signature": "void mALL()"}, "JpqlLexer.mAND": {"callee_method_names": [], "method_name": "JpqlLexer.mAND", "method_implementation": "{\n    try {\n        int _type = AND;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:84:5: ( A N D )\n        // org/batoo/jpa/jpql/JpqlLexer.g:85:5: A N D\n        {\n            mA();\n            mN();\n            mD();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"AND\"\n", "repo_name": "BatooJPA-master/", "id": 1497, "method_signature": "void mAND()"}, "JpqlLexer.mANY": {"callee_method_names": [], "method_name": "JpqlLexer.mANY", "method_implementation": "{\n    try {\n        int _type = ANY;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:87:5: ( A N Y )\n        // org/batoo/jpa/jpql/JpqlLexer.g:88:5: A N Y\n        {\n            mA();\n            mN();\n            mY();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ANY\"\n", "repo_name": "BatooJPA-master/", "id": 1498, "method_signature": "void mANY()"}, "JpqlLexer.mAS": {"callee_method_names": [], "method_name": "JpqlLexer.mAS", "method_implementation": "{\n    try {\n        int _type = AS;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:90:4: ( A S )\n        // org/batoo/jpa/jpql/JpqlLexer.g:91:5: A S\n        {\n            mA();\n            mS();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"AS\"\n", "repo_name": "BatooJPA-master/", "id": 1499, "method_signature": "void mAS()"}, "JpqlLexer.mASC": {"callee_method_names": [], "method_name": "JpqlLexer.mASC", "method_implementation": "{\n    try {\n        int _type = ASC;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:93:5: ( A S C )\n        // org/batoo/jpa/jpql/JpqlLexer.g:94:5: A S C\n        {\n            mA();\n            mS();\n            mC();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ASC\"\n", "repo_name": "BatooJPA-master/", "id": 1500, "method_signature": "void mASC()"}, "JpqlLexer.mAVG": {"callee_method_names": [], "method_name": "JpqlLexer.mAVG", "method_implementation": "{\n    try {\n        int _type = AVG;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:96:5: ( A V G )\n        // org/batoo/jpa/jpql/JpqlLexer.g:97:5: A V G\n        {\n            mA();\n            mV();\n            mG();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"AVG\"\n", "repo_name": "BatooJPA-master/", "id": 1501, "method_signature": "void mAVG()"}, "JpqlLexer.mB": {"callee_method_names": [], "method_name": "JpqlLexer.mB", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:25:12: ( 'B' | 'b' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'B' || input.LA(1) == 'b') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"B\"\n", "repo_name": "BatooJPA-master/", "id": 1469, "method_signature": "void mB()"}, "JpqlLexer.mBETWEEN": {"callee_method_names": [], "method_name": "JpqlLexer.mBETWEEN", "method_implementation": "{\n    try {\n        int _type = BETWEEN;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:99:9: ( B E T W E E N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:100:5: B E T W E E N\n        {\n            mB();\n            mE();\n            mT();\n            mW();\n            mE();\n            mE();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"BETWEEN\"\n", "repo_name": "BatooJPA-master/", "id": 1502, "method_signature": "void mBETWEEN()"}, "JpqlLexer.mBIT_LENGTH": {"callee_method_names": [], "method_name": "JpqlLexer.mBIT_LENGTH", "method_implementation": "{\n    try {\n        int _type = BIT_LENGTH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:102:12: ( B I T Underscore )\n        // org/batoo/jpa/jpql/JpqlLexer.g:103:5: B I T Underscore\n        {\n            mB();\n            mI();\n            mT();\n            mUnderscore();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"BIT_LENGTH\"\n", "repo_name": "BatooJPA-master/", "id": 1503, "method_signature": "void mBIT_LENGTH()"}, "JpqlLexer.mBOTH": {"callee_method_names": [], "method_name": "JpqlLexer.mBOTH", "method_implementation": "{\n    try {\n        int _type = BOTH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:105:6: ( B O T H )\n        // org/batoo/jpa/jpql/JpqlLexer.g:106:5: B O T H\n        {\n            mB();\n            mO();\n            mT();\n            mH();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"BOTH\"\n", "repo_name": "BatooJPA-master/", "id": 1504, "method_signature": "void mBOTH()"}, "JpqlLexer.mBY": {"callee_method_names": [], "method_name": "JpqlLexer.mBY", "method_implementation": "{\n    try {\n        int _type = BY;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:108:4: ( B Y )\n        // org/batoo/jpa/jpql/JpqlLexer.g:109:5: B Y\n        {\n            mB();\n            mY();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"BY\"\n", "repo_name": "BatooJPA-master/", "id": 1505, "method_signature": "void mBY()"}, "JpqlLexer.mBYTE": {"callee_method_names": [], "method_name": "JpqlLexer.mBYTE", "method_implementation": "{\n    try {\n        int _type = BYTE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:111:6: ( B Y T E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:112:2: B Y T E\n        {\n            mB();\n            mY();\n            mT();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"BYTE\"\n", "repo_name": "BatooJPA-master/", "id": 1506, "method_signature": "void mBYTE()"}, "JpqlLexer.mC": {"callee_method_names": [], "method_name": "JpqlLexer.mC", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:27:12: ( 'C' | 'c' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'C' || input.LA(1) == 'c') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"C\"\n", "repo_name": "BatooJPA-master/", "id": 1470, "method_signature": "void mC()"}, "JpqlLexer.mCASE": {"callee_method_names": [], "method_name": "JpqlLexer.mCASE", "method_implementation": "{\n    try {\n        int _type = CASE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:114:6: ( C A S E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:115:5: C A S E\n        {\n            mC();\n            mA();\n            mS();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CASE\"\n", "repo_name": "BatooJPA-master/", "id": 1507, "method_signature": "void mCASE()"}, "JpqlLexer.mCAST": {"callee_method_names": [], "method_name": "JpqlLexer.mCAST", "method_implementation": "{\n    try {\n        int _type = CAST;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:117:6: ( C A S T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:118:2: C A S T\n        {\n            mC();\n            mA();\n            mS();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CAST\"\n", "repo_name": "BatooJPA-master/", "id": 1508, "method_signature": "void mCAST()"}, "JpqlLexer.mCHARACTER_LENGTH": {"callee_method_names": [], "method_name": "JpqlLexer.mCHARACTER_LENGTH", "method_implementation": "{\n    try {\n        int _type = CHARACTER_LENGTH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:123:18: ( C H A R A C T E R Underscore L E N G H T H )\n        // org/batoo/jpa/jpql/JpqlLexer.g:124:5: C H A R A C T E R Underscore L E N G H T H\n        {\n            mC();\n            mH();\n            mA();\n            mR();\n            mA();\n            mC();\n            mT();\n            mE();\n            mR();\n            mUnderscore();\n            mL();\n            mE();\n            mN();\n            mG();\n            mH();\n            mT();\n            mH();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CHARACTER_LENGTH\"\n", "repo_name": "BatooJPA-master/", "id": 1510, "method_signature": "void mCHARACTER_LENGTH()"}, "JpqlLexer.mCHAR_LENGTH": {"callee_method_names": [], "method_name": "JpqlLexer.mCHAR_LENGTH", "method_implementation": "{\n    try {\n        int _type = CHAR_LENGTH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:120:13: ( C H A R Underscore L E N G H T H )\n        // org/batoo/jpa/jpql/JpqlLexer.g:121:5: C H A R Underscore L E N G H T H\n        {\n            mC();\n            mH();\n            mA();\n            mR();\n            mUnderscore();\n            mL();\n            mE();\n            mN();\n            mG();\n            mH();\n            mT();\n            mH();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CHAR_LENGTH\"\n", "repo_name": "BatooJPA-master/", "id": 1509, "method_signature": "void mCHAR_LENGTH()"}, "JpqlLexer.mCLASS": {"callee_method_names": [], "method_name": "JpqlLexer.mCLASS", "method_implementation": "{\n    try {\n        int _type = CLASS;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:126:7: ( C L A S S )\n        // org/batoo/jpa/jpql/JpqlLexer.g:127:5: C L A S S\n        {\n            mC();\n            mL();\n            mA();\n            mS();\n            mS();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CLASS\"\n", "repo_name": "BatooJPA-master/", "id": 1511, "method_signature": "void mCLASS()"}, "JpqlLexer.mCOALESCE": {"callee_method_names": [], "method_name": "JpqlLexer.mCOALESCE", "method_implementation": "{\n    try {\n        int _type = COALESCE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:129:10: ( C O A L E S C E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:130:5: C O A L E S C E\n        {\n            mC();\n            mO();\n            mA();\n            mL();\n            mE();\n            mS();\n            mC();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"COALESCE\"\n", "repo_name": "BatooJPA-master/", "id": 1512, "method_signature": "void mCOALESCE()"}, "JpqlLexer.mCOMMENT": {"callee_method_names": [], "method_name": "JpqlLexer.mCOMMENT", "method_implementation": "{\n    try {\n        int _type = COMMENT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:17:9: ( ( Start_Comment ( options {greedy=false; } : . )* End_Comment )+ )\n        // org/batoo/jpa/jpql/JpqlLexer.g:18:5: ( Start_Comment ( options {greedy=false; } : . )* End_Comment )+\n        {\n            // org/batoo/jpa/jpql/JpqlLexer.g:18:5: ( Start_Comment ( options {greedy=false; } : . )* End_Comment )+\n            int cnt2 = 0;\n            loop2: do {\n                int alt2 = 2;\n                switch(input.LA(1)) {\n                    case '/':\n                        {\n                            alt2 = 1;\n                        }\n                        break;\n                }\n                switch(alt2) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlLexer.g:18:7: Start_Comment ( options {greedy=false; } : . )* End_Comment\n                        {\n                            mStart_Comment();\n                            // org/batoo/jpa/jpql/JpqlLexer.g:18:21: ( options {greedy=false; } : . )*\n                            loop1: do {\n                                int alt1 = 2;\n                                int LA1_0 = input.LA(1);\n                                if ((LA1_0 == '*')) {\n                                    int LA1_1 = input.LA(2);\n                                    if ((LA1_1 == '/')) {\n                                        alt1 = 2;\n                                    } else if (((LA1_1 >= '\\u0000' && LA1_1 <= '.') || (LA1_1 >= '0' && LA1_1 <= '\\uFFFF'))) {\n                                        alt1 = 1;\n                                    }\n                                } else if (((LA1_0 >= '\\u0000' && LA1_0 <= ')') || (LA1_0 >= '+' && LA1_0 <= '\\uFFFF'))) {\n                                    alt1 = 1;\n                                }\n                                switch(alt1) {\n                                    case 1:\n                                        // org/batoo/jpa/jpql/JpqlLexer.g:18:47: .\n                                        {\n                                            matchAny();\n                                        }\n                                        break;\n                                    default:\n                                        break loop1;\n                                }\n                            } while (true);\n                            mEnd_Comment();\n                        }\n                        break;\n                    default:\n                        if (cnt2 >= 1)\n                            break loop2;\n                        EarlyExitException eee = new EarlyExitException(2, input);\n                        throw eee;\n                }\n                cnt2++;\n            } while (true);\n            _channel = HIDDEN;\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"COMMENT\"\n", "repo_name": "BatooJPA-master/", "id": 1466, "method_signature": "void mCOMMENT()"}, "JpqlLexer.mCONCAT": {"callee_method_names": [], "method_name": "JpqlLexer.mCONCAT", "method_implementation": "{\n    try {\n        int _type = CONCAT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:132:8: ( C O N C A T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:133:5: C O N C A T\n        {\n            mC();\n            mO();\n            mN();\n            mC();\n            mA();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CONCAT\"\n", "repo_name": "BatooJPA-master/", "id": 1513, "method_signature": "void mCONCAT()"}, "JpqlLexer.mCOUNT": {"callee_method_names": [], "method_name": "JpqlLexer.mCOUNT", "method_implementation": "{\n    try {\n        int _type = COUNT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:135:7: ( C O U N T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:136:5: C O U N T\n        {\n            mC();\n            mO();\n            mU();\n            mN();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"COUNT\"\n", "repo_name": "BatooJPA-master/", "id": 1514, "method_signature": "void mCOUNT()"}, "JpqlLexer.mCURRENT_DATE": {"callee_method_names": [], "method_name": "JpqlLexer.mCURRENT_DATE", "method_implementation": "{\n    try {\n        int _type = CURRENT_DATE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:138:14: ( C U R R E N T Underscore D A T E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:139:5: C U R R E N T Underscore D A T E\n        {\n            mC();\n            mU();\n            mR();\n            mR();\n            mE();\n            mN();\n            mT();\n            mUnderscore();\n            mD();\n            mA();\n            mT();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CURRENT_DATE\"\n", "repo_name": "BatooJPA-master/", "id": 1515, "method_signature": "void mCURRENT_DATE()"}, "JpqlLexer.mCURRENT_TIME": {"callee_method_names": [], "method_name": "JpqlLexer.mCURRENT_TIME", "method_implementation": "{\n    try {\n        int _type = CURRENT_TIME;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:141:14: ( C U R R E N T Underscore T I M E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:142:5: C U R R E N T Underscore T I M E\n        {\n            mC();\n            mU();\n            mR();\n            mR();\n            mE();\n            mN();\n            mT();\n            mUnderscore();\n            mT();\n            mI();\n            mM();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CURRENT_TIME\"\n", "repo_name": "BatooJPA-master/", "id": 1516, "method_signature": "void mCURRENT_TIME()"}, "JpqlLexer.mCURRENT_TIMESTAMP": {"callee_method_names": [], "method_name": "JpqlLexer.mCURRENT_TIMESTAMP", "method_implementation": "{\n    try {\n        int _type = CURRENT_TIMESTAMP;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:144:19: ( C U R R E N T Underscore T I M E S T A M P )\n        // org/batoo/jpa/jpql/JpqlLexer.g:145:5: C U R R E N T Underscore T I M E S T A M P\n        {\n            mC();\n            mU();\n            mR();\n            mR();\n            mE();\n            mN();\n            mT();\n            mUnderscore();\n            mT();\n            mI();\n            mM();\n            mE();\n            mS();\n            mT();\n            mA();\n            mM();\n            mP();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"CURRENT_TIMESTAMP\"\n", "repo_name": "BatooJPA-master/", "id": 1517, "method_signature": "void mCURRENT_TIMESTAMP()"}, "JpqlLexer.mColumn": {"callee_method_names": [], "method_name": "JpqlLexer.mColumn", "method_implementation": "{\n    try {\n        int _type = Column;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:426:8: ( ':' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:427:5: ':'\n        {\n            match(':');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Column\"\n", "repo_name": "BatooJPA-master/", "id": 1611, "method_signature": "void mColumn()"}, "JpqlLexer.mComma": {"callee_method_names": [], "method_name": "JpqlLexer.mComma", "method_implementation": "{\n    try {\n        int _type = Comma;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:420:7: ( ',' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:421:5: ','\n        {\n            match(',');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Comma\"\n", "repo_name": "BatooJPA-master/", "id": 1609, "method_signature": "void mComma()"}, "JpqlLexer.mConcatenation_Operator": {"callee_method_names": [], "method_name": "JpqlLexer.mConcatenation_Operator", "method_implementation": "{\n    try {\n        int _type = Concatenation_Operator;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:399:24: ( '||' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:400:5: '||'\n        {\n            match(\"||\");\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Concatenation_Operator\"\n", "repo_name": "BatooJPA-master/", "id": 1602, "method_signature": "void mConcatenation_Operator()"}, "JpqlLexer.mD": {"callee_method_names": [], "method_name": "JpqlLexer.mD", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:29:12: ( 'D' | 'd' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'D' || input.LA(1) == 'd') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"D\"\n", "repo_name": "BatooJPA-master/", "id": 1471, "method_signature": "void mD()"}, "JpqlLexer.mDAY": {"callee_method_names": [], "method_name": "JpqlLexer.mDAY", "method_implementation": "{\n    try {\n        int _type = DAY;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:147:5: ( D A Y )\n        // org/batoo/jpa/jpql/JpqlLexer.g:148:2: D A Y\n        {\n            mD();\n            mA();\n            mY();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DAY\"\n", "repo_name": "BatooJPA-master/", "id": 1518, "method_signature": "void mDAY()"}, "JpqlLexer.mDAYOFMONTH": {"callee_method_names": [], "method_name": "JpqlLexer.mDAYOFMONTH", "method_implementation": "{\n    try {\n        int _type = DAYOFMONTH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:150:12: ( D A Y O F M O N T H )\n        // org/batoo/jpa/jpql/JpqlLexer.g:151:2: D A Y O F M O N T H\n        {\n            mD();\n            mA();\n            mY();\n            mO();\n            mF();\n            mM();\n            mO();\n            mN();\n            mT();\n            mH();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DAYOFMONTH\"\n", "repo_name": "BatooJPA-master/", "id": 1519, "method_signature": "void mDAYOFMONTH()"}, "JpqlLexer.mDAYOFWEEK": {"callee_method_names": [], "method_name": "JpqlLexer.mDAYOFWEEK", "method_implementation": "{\n    try {\n        int _type = DAYOFWEEK;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:153:11: ( D A Y O F W E E K )\n        // org/batoo/jpa/jpql/JpqlLexer.g:154:2: D A Y O F W E E K\n        {\n            mD();\n            mA();\n            mY();\n            mO();\n            mF();\n            mW();\n            mE();\n            mE();\n            mK();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DAYOFWEEK\"\n", "repo_name": "BatooJPA-master/", "id": 1520, "method_signature": "void mDAYOFWEEK()"}, "JpqlLexer.mDAYOFYEAR": {"callee_method_names": [], "method_name": "JpqlLexer.mDAYOFYEAR", "method_implementation": "{\n    try {\n        int _type = DAYOFYEAR;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:156:11: ( D A Y O F Y E A R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:157:2: D A Y O F Y E A R\n        {\n            mD();\n            mA();\n            mY();\n            mO();\n            mF();\n            mY();\n            mE();\n            mA();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DAYOFYEAR\"\n", "repo_name": "BatooJPA-master/", "id": 1521, "method_signature": "void mDAYOFYEAR()"}, "JpqlLexer.mDELETE": {"callee_method_names": [], "method_name": "JpqlLexer.mDELETE", "method_implementation": "{\n    try {\n        int _type = DELETE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:159:8: ( D E L E T E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:160:5: D E L E T E\n        {\n            mD();\n            mE();\n            mL();\n            mE();\n            mT();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DELETE\"\n", "repo_name": "BatooJPA-master/", "id": 1522, "method_signature": "void mDELETE()"}, "JpqlLexer.mDESC": {"callee_method_names": [], "method_name": "JpqlLexer.mDESC", "method_implementation": "{\n    try {\n        int _type = DESC;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:162:6: ( D E S C )\n        // org/batoo/jpa/jpql/JpqlLexer.g:163:5: D E S C\n        {\n            mD();\n            mE();\n            mS();\n            mC();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DESC\"\n", "repo_name": "BatooJPA-master/", "id": 1523, "method_signature": "void mDESC()"}, "JpqlLexer.mDISTINCT": {"callee_method_names": [], "method_name": "JpqlLexer.mDISTINCT", "method_implementation": "{\n    try {\n        int _type = DISTINCT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:165:10: ( D I S T I N C T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:166:5: D I S T I N C T\n        {\n            mD();\n            mI();\n            mS();\n            mT();\n            mI();\n            mN();\n            mC();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DISTINCT\"\n", "repo_name": "BatooJPA-master/", "id": 1524, "method_signature": "void mDISTINCT()"}, "JpqlLexer.mDOUBLE": {"callee_method_names": [], "method_name": "JpqlLexer.mDOUBLE", "method_implementation": "{\n    try {\n        int _type = DOUBLE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:168:8: ( D O U B L E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:169:2: D O U B L E\n        {\n            mD();\n            mO();\n            mU();\n            mB();\n            mL();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"DOUBLE\"\n", "repo_name": "BatooJPA-master/", "id": 1525, "method_signature": "void mDOUBLE()"}, "JpqlLexer.mDivision_Sign": {"callee_method_names": [], "method_name": "JpqlLexer.mDivision_Sign", "method_implementation": "{\n    try {\n        int _type = Division_Sign;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:417:14: ( '/' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:418:2: '/'\n        {\n            match('/');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Division_Sign\"\n", "repo_name": "BatooJPA-master/", "id": 1608, "method_signature": "void mDivision_Sign()"}, "JpqlLexer.mE": {"callee_method_names": [], "method_name": "JpqlLexer.mE", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:31:12: ( 'E' | 'e' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'E' || input.LA(1) == 'e') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"E\"\n", "repo_name": "BatooJPA-master/", "id": 1472, "method_signature": "void mE()"}, "JpqlLexer.mELSE": {"callee_method_names": [], "method_name": "JpqlLexer.mELSE", "method_implementation": "{\n    try {\n        int _type = ELSE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:171:6: ( E L S E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:172:5: E L S E\n        {\n            mE();\n            mL();\n            mS();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ELSE\"\n", "repo_name": "BatooJPA-master/", "id": 1526, "method_signature": "void mELSE()"}, "JpqlLexer.mEMPTY": {"callee_method_names": [], "method_name": "JpqlLexer.mEMPTY", "method_implementation": "{\n    try {\n        int _type = EMPTY;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:174:7: ( E M P T Y )\n        // org/batoo/jpa/jpql/JpqlLexer.g:175:5: E M P T Y\n        {\n            mE();\n            mM();\n            mP();\n            mT();\n            mY();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"EMPTY\"\n", "repo_name": "BatooJPA-master/", "id": 1527, "method_signature": "void mEMPTY()"}, "JpqlLexer.mEND": {"callee_method_names": [], "method_name": "JpqlLexer.mEND", "method_implementation": "{\n    try {\n        int _type = END;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:177:5: ( E N D )\n        // org/batoo/jpa/jpql/JpqlLexer.g:178:5: E N D\n        {\n            mE();\n            mN();\n            mD();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"END\"\n", "repo_name": "BatooJPA-master/", "id": 1528, "method_signature": "void mEND()"}, "JpqlLexer.mENTRY": {"callee_method_names": [], "method_name": "JpqlLexer.mENTRY", "method_implementation": "{\n    try {\n        int _type = ENTRY;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:180:7: ( E N T R Y )\n        // org/batoo/jpa/jpql/JpqlLexer.g:181:5: E N T R Y\n        {\n            mE();\n            mN();\n            mT();\n            mR();\n            mY();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ENTRY\"\n", "repo_name": "BatooJPA-master/", "id": 1529, "method_signature": "void mENTRY()"}, "JpqlLexer.mESCAPE": {"callee_method_names": [], "method_name": "JpqlLexer.mESCAPE", "method_implementation": "{\n    try {\n        int _type = ESCAPE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:183:8: ( E S C A P E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:184:5: E S C A P E\n        {\n            mE();\n            mS();\n            mC();\n            mA();\n            mP();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ESCAPE\"\n", "repo_name": "BatooJPA-master/", "id": 1530, "method_signature": "void mESCAPE()"}, "JpqlLexer.mEXISTS": {"callee_method_names": [], "method_name": "JpqlLexer.mEXISTS", "method_implementation": "{\n    try {\n        int _type = EXISTS;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:186:8: ( E X I S T S )\n        // org/batoo/jpa/jpql/JpqlLexer.g:187:5: E X I S T S\n        {\n            mE();\n            mX();\n            mI();\n            mS();\n            mT();\n            mS();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"EXISTS\"\n", "repo_name": "BatooJPA-master/", "id": 1531, "method_signature": "void mEXISTS()"}, "JpqlLexer.mEnd_Comment": {"callee_method_names": [], "method_name": "JpqlLexer.mEnd_Comment", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:13:22: ( '*/' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:13:24: '*/'\n        {\n            match(\"*/\");\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"End_Comment\"\n", "repo_name": "BatooJPA-master/", "id": 1464, "method_signature": "void mEnd_Comment()"}, "JpqlLexer.mEquals_Operator": {"callee_method_names": [], "method_name": "JpqlLexer.mEquals_Operator", "method_implementation": "{\n    try {\n        int _type = Equals_Operator;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:390:17: ( '=' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:391:5: '='\n        {\n            match('=');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Equals_Operator\"\n", "repo_name": "BatooJPA-master/", "id": 1599, "method_signature": "void mEquals_Operator()"}, "JpqlLexer.mF": {"callee_method_names": [], "method_name": "JpqlLexer.mF", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:33:12: ( 'F' | 'f' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'F' || input.LA(1) == 'f') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"F\"\n", "repo_name": "BatooJPA-master/", "id": 1473, "method_signature": "void mF()"}, "JpqlLexer.mFALSE": {"callee_method_names": [], "method_name": "JpqlLexer.mFALSE", "method_implementation": "{\n    try {\n        int _type = FALSE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:189:7: ( F A L S E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:190:5: F A L S E\n        {\n            mF();\n            mA();\n            mL();\n            mS();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"FALSE\"\n", "repo_name": "BatooJPA-master/", "id": 1532, "method_signature": "void mFALSE()"}, "JpqlLexer.mFETCH": {"callee_method_names": [], "method_name": "JpqlLexer.mFETCH", "method_implementation": "{\n    try {\n        int _type = FETCH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:192:7: ( F E T C H )\n        // org/batoo/jpa/jpql/JpqlLexer.g:193:5: F E T C H\n        {\n            mF();\n            mE();\n            mT();\n            mC();\n            mH();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"FETCH\"\n", "repo_name": "BatooJPA-master/", "id": 1533, "method_signature": "void mFETCH()"}, "JpqlLexer.mFLOAT": {"callee_method_names": [], "method_name": "JpqlLexer.mFLOAT", "method_implementation": "{\n    try {\n        int _type = FLOAT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:195:7: ( F L O A T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:196:2: F L O A T\n        {\n            mF();\n            mL();\n            mO();\n            mA();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"FLOAT\"\n", "repo_name": "BatooJPA-master/", "id": 1534, "method_signature": "void mFLOAT()"}, "JpqlLexer.mFROM": {"callee_method_names": [], "method_name": "JpqlLexer.mFROM", "method_implementation": "{\n    try {\n        int _type = FROM;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:201:6: ( F R O M )\n        // org/batoo/jpa/jpql/JpqlLexer.g:202:5: F R O M\n        {\n            mF();\n            mR();\n            mO();\n            mM();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"FROM\"\n", "repo_name": "BatooJPA-master/", "id": 1536, "method_signature": "void mFROM()"}, "JpqlLexer.mFUNC": {"callee_method_names": [], "method_name": "JpqlLexer.mFUNC", "method_implementation": "{\n    try {\n        int _type = FUNC;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:198:6: ( F U N C )\n        // org/batoo/jpa/jpql/JpqlLexer.g:199:2: F U N C\n        {\n            mF();\n            mU();\n            mN();\n            mC();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"FUNC\"\n", "repo_name": "BatooJPA-master/", "id": 1535, "method_signature": "void mFUNC()"}, "JpqlLexer.mG": {"callee_method_names": [], "method_name": "JpqlLexer.mG", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:35:12: ( 'G' | 'g' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'G' || input.LA(1) == 'g') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"G\"\n", "repo_name": "BatooJPA-master/", "id": 1474, "method_signature": "void mG()"}, "JpqlLexer.mGROUP": {"callee_method_names": [], "method_name": "JpqlLexer.mGROUP", "method_implementation": "{\n    try {\n        int _type = GROUP;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:204:7: ( G R O U P )\n        // org/batoo/jpa/jpql/JpqlLexer.g:205:5: G R O U P\n        {\n            mG();\n            mR();\n            mO();\n            mU();\n            mP();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"GROUP\"\n", "repo_name": "BatooJPA-master/", "id": 1537, "method_signature": "void mGROUP()"}, "JpqlLexer.mGreater_Or_Equals_Operator": {"callee_method_names": [], "method_name": "JpqlLexer.mGreater_Or_Equals_Operator", "method_implementation": "{\n    try {\n        int _type = Greater_Or_Equals_Operator;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:384:28: ( '>=' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:385:5: '>='\n        {\n            match(\">=\");\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Greater_Or_Equals_Operator\"\n", "repo_name": "BatooJPA-master/", "id": 1597, "method_signature": "void mGreater_Or_Equals_Operator()"}, "JpqlLexer.mGreater_Than_Operator": {"callee_method_names": [], "method_name": "JpqlLexer.mGreater_Than_Operator", "method_implementation": "{\n    try {\n        int _type = Greater_Than_Operator;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:396:23: ( '>' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:397:5: '>'\n        {\n            match('>');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Greater_Than_Operator\"\n", "repo_name": "BatooJPA-master/", "id": 1601, "method_signature": "void mGreater_Than_Operator()"}, "JpqlLexer.mH": {"callee_method_names": [], "method_name": "JpqlLexer.mH", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:37:12: ( 'H' | 'h' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'H' || input.LA(1) == 'h') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"H\"\n", "repo_name": "BatooJPA-master/", "id": 1475, "method_signature": "void mH()"}, "JpqlLexer.mHAVING": {"callee_method_names": [], "method_name": "JpqlLexer.mHAVING", "method_implementation": "{\n    try {\n        int _type = HAVING;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:207:8: ( H A V I N G )\n        // org/batoo/jpa/jpql/JpqlLexer.g:208:5: H A V I N G\n        {\n            mH();\n            mA();\n            mV();\n            mI();\n            mN();\n            mG();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"HAVING\"\n", "repo_name": "BatooJPA-master/", "id": 1538, "method_signature": "void mHAVING()"}, "JpqlLexer.mHOUR": {"callee_method_names": [], "method_name": "JpqlLexer.mHOUR", "method_implementation": "{\n    try {\n        int _type = HOUR;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:210:6: ( H O U R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:211:2: H O U R\n        {\n            mH();\n            mO();\n            mU();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"HOUR\"\n", "repo_name": "BatooJPA-master/", "id": 1539, "method_signature": "void mHOUR()"}, "JpqlLexer.mI": {"callee_method_names": [], "method_name": "JpqlLexer.mI", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:39:12: ( 'I' | 'i' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'I' || input.LA(1) == 'i') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"I\"\n", "repo_name": "BatooJPA-master/", "id": 1476, "method_signature": "void mI()"}, "JpqlLexer.mID": {"callee_method_names": [], "method_name": "JpqlLexer.mID", "method_implementation": "{\n    try {\n        int _type = ID;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:441:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )\n        // org/batoo/jpa/jpql/JpqlLexer.g:442:5: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*\n        {\n            if ((input.LA(1) >= 'A' && input.LA(1) <= 'Z') || input.LA(1) == '_' || (input.LA(1) >= 'a' && input.LA(1) <= 'z')) {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n            // org/batoo/jpa/jpql/JpqlLexer.g:442:33: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*\n            loop9: do {\n                int alt9 = 2;\n                switch(input.LA(1)) {\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                    case 'A':\n                    case 'B':\n                    case 'C':\n                    case 'D':\n                    case 'E':\n                    case 'F':\n                    case 'G':\n                    case 'H':\n                    case 'I':\n                    case 'J':\n                    case 'K':\n                    case 'L':\n                    case 'M':\n                    case 'N':\n                    case 'O':\n                    case 'P':\n                    case 'Q':\n                    case 'R':\n                    case 'S':\n                    case 'T':\n                    case 'U':\n                    case 'V':\n                    case 'W':\n                    case 'X':\n                    case 'Y':\n                    case 'Z':\n                    case '_':\n                    case 'a':\n                    case 'b':\n                    case 'c':\n                    case 'd':\n                    case 'e':\n                    case 'f':\n                    case 'g':\n                    case 'h':\n                    case 'i':\n                    case 'j':\n                    case 'k':\n                    case 'l':\n                    case 'm':\n                    case 'n':\n                    case 'o':\n                    case 'p':\n                    case 'q':\n                    case 'r':\n                    case 's':\n                    case 't':\n                    case 'u':\n                    case 'v':\n                    case 'w':\n                    case 'x':\n                    case 'y':\n                    case 'z':\n                        {\n                            alt9 = 1;\n                        }\n                        break;\n                }\n                switch(alt9) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlLexer.g:\n                        {\n                            if ((input.LA(1) >= '0' && input.LA(1) <= '9') || (input.LA(1) >= 'A' && input.LA(1) <= 'Z') || input.LA(1) == '_' || (input.LA(1) >= 'a' && input.LA(1) <= 'z')) {\n                                input.consume();\n                            } else {\n                                MismatchedSetException mse = new MismatchedSetException(null, input);\n                                recover(mse);\n                                throw mse;\n                            }\n                        }\n                        break;\n                    default:\n                        break loop9;\n                }\n            } while (true);\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ID\"\n", "repo_name": "BatooJPA-master/", "id": 1616, "method_signature": "void mID()"}, "JpqlLexer.mIN": {"callee_method_names": [], "method_name": "JpqlLexer.mIN", "method_implementation": "{\n    try {\n        int _type = IN;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:213:4: ( I N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:214:5: I N\n        {\n            mI();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"IN\"\n", "repo_name": "BatooJPA-master/", "id": 1540, "method_signature": "void mIN()"}, "JpqlLexer.mINDEX": {"callee_method_names": [], "method_name": "JpqlLexer.mINDEX", "method_implementation": "{\n    try {\n        int _type = INDEX;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:216:7: ( I N D E X )\n        // org/batoo/jpa/jpql/JpqlLexer.g:217:5: I N D E X\n        {\n            mI();\n            mN();\n            mD();\n            mE();\n            mX();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"INDEX\"\n", "repo_name": "BatooJPA-master/", "id": 1541, "method_signature": "void mINDEX()"}, "JpqlLexer.mINNER": {"callee_method_names": [], "method_name": "JpqlLexer.mINNER", "method_implementation": "{\n    try {\n        int _type = INNER;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:219:7: ( I N N E R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:220:5: I N N E R\n        {\n            mI();\n            mN();\n            mN();\n            mE();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"INNER\"\n", "repo_name": "BatooJPA-master/", "id": 1542, "method_signature": "void mINNER()"}, "JpqlLexer.mINT": {"callee_method_names": [], "method_name": "JpqlLexer.mINT", "method_implementation": "{\n    try {\n        int _type = INT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:225:5: ( I N T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:226:5: I N T\n        {\n            mI();\n            mN();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"INT\"\n", "repo_name": "BatooJPA-master/", "id": 1544, "method_signature": "void mINT()"}, "JpqlLexer.mINTEGER": {"callee_method_names": [], "method_name": "JpqlLexer.mINTEGER", "method_implementation": "{\n    try {\n        int _type = INTEGER;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:228:9: ( I N T E G E R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:229:5: I N T E G E R\n        {\n            mI();\n            mN();\n            mT();\n            mE();\n            mG();\n            mE();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"INTEGER\"\n", "repo_name": "BatooJPA-master/", "id": 1545, "method_signature": "void mINTEGER()"}, "JpqlLexer.mIS": {"callee_method_names": [], "method_name": "JpqlLexer.mIS", "method_implementation": "{\n    try {\n        int _type = IS;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:222:4: ( I S )\n        // org/batoo/jpa/jpql/JpqlLexer.g:223:5: I S\n        {\n            mI();\n            mS();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"IS\"\n", "repo_name": "BatooJPA-master/", "id": 1543, "method_signature": "void mIS()"}, "JpqlLexer.mJ": {"callee_method_names": [], "method_name": "JpqlLexer.mJ", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:41:12: ( 'J' | 'j' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'J' || input.LA(1) == 'j') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"J\"\n", "repo_name": "BatooJPA-master/", "id": 1477, "method_signature": "void mJ()"}, "JpqlLexer.mJOIN": {"callee_method_names": [], "method_name": "JpqlLexer.mJOIN", "method_implementation": "{\n    try {\n        int _type = JOIN;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:231:6: ( J O I N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:232:5: J O I N\n        {\n            mJ();\n            mO();\n            mI();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"JOIN\"\n", "repo_name": "BatooJPA-master/", "id": 1546, "method_signature": "void mJOIN()"}, "JpqlLexer.mK": {"callee_method_names": [], "method_name": "JpqlLexer.mK", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:43:12: ( 'K' | 'k' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'K' || input.LA(1) == 'k') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"K\"\n", "repo_name": "BatooJPA-master/", "id": 1478, "method_signature": "void mK()"}, "JpqlLexer.mKEY": {"callee_method_names": [], "method_name": "JpqlLexer.mKEY", "method_implementation": "{\n    try {\n        int _type = KEY;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:234:5: ( K E Y )\n        // org/batoo/jpa/jpql/JpqlLexer.g:235:5: K E Y\n        {\n            mK();\n            mE();\n            mY();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"KEY\"\n", "repo_name": "BatooJPA-master/", "id": 1547, "method_signature": "void mKEY()"}, "JpqlLexer.mL": {"callee_method_names": [], "method_name": "JpqlLexer.mL", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:45:12: ( 'L' | 'l' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'L' || input.LA(1) == 'l') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"L\"\n", "repo_name": "BatooJPA-master/", "id": 1479, "method_signature": "void mL()"}, "JpqlLexer.mLEADING": {"callee_method_names": [], "method_name": "JpqlLexer.mLEADING", "method_implementation": "{\n    try {\n        int _type = LEADING;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:237:9: ( L E A D I N G )\n        // org/batoo/jpa/jpql/JpqlLexer.g:238:5: L E A D I N G\n        {\n            mL();\n            mE();\n            mA();\n            mD();\n            mI();\n            mN();\n            mG();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LEADING\"\n", "repo_name": "BatooJPA-master/", "id": 1548, "method_signature": "void mLEADING()"}, "JpqlLexer.mLEFT": {"callee_method_names": [], "method_name": "JpqlLexer.mLEFT", "method_implementation": "{\n    try {\n        int _type = LEFT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:240:6: ( L E F T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:241:5: L E F T\n        {\n            mL();\n            mE();\n            mF();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LEFT\"\n", "repo_name": "BatooJPA-master/", "id": 1549, "method_signature": "void mLEFT()"}, "JpqlLexer.mLENGTH": {"callee_method_names": [], "method_name": "JpqlLexer.mLENGTH", "method_implementation": "{\n    try {\n        int _type = LENGTH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:243:8: ( L E N G T H )\n        // org/batoo/jpa/jpql/JpqlLexer.g:244:5: L E N G T H\n        {\n            mL();\n            mE();\n            mN();\n            mG();\n            mT();\n            mH();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LENGTH\"\n", "repo_name": "BatooJPA-master/", "id": 1550, "method_signature": "void mLENGTH()"}, "JpqlLexer.mLIKE": {"callee_method_names": [], "method_name": "JpqlLexer.mLIKE", "method_implementation": "{\n    try {\n        int _type = LIKE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:246:6: ( L I K E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:247:5: L I K E\n        {\n            mL();\n            mI();\n            mK();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LIKE\"\n", "repo_name": "BatooJPA-master/", "id": 1551, "method_signature": "void mLIKE()"}, "JpqlLexer.mLINE_COMMENT": {"callee_method_names": [], "method_name": "JpqlLexer.mLINE_COMMENT", "method_implementation": "{\n    try {\n        int _type = LINE_COMMENT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:20:14: ( ( ( Line_Comment | '--' ) (~ ( '\\\\n' | '\\\\r' ) )* ( '\\\\r' )? '\\\\n' )+ )\n        // org/batoo/jpa/jpql/JpqlLexer.g:21:5: ( ( Line_Comment | '--' ) (~ ( '\\\\n' | '\\\\r' ) )* ( '\\\\r' )? '\\\\n' )+\n        {\n            // org/batoo/jpa/jpql/JpqlLexer.g:21:5: ( ( Line_Comment | '--' ) (~ ( '\\\\n' | '\\\\r' ) )* ( '\\\\r' )? '\\\\n' )+\n            int cnt6 = 0;\n            loop6: do {\n                int alt6 = 2;\n                switch(input.LA(1)) {\n                    case '-':\n                    case '/':\n                        {\n                            alt6 = 1;\n                        }\n                        break;\n                }\n                switch(alt6) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlLexer.g:21:6: ( Line_Comment | '--' ) (~ ( '\\\\n' | '\\\\r' ) )* ( '\\\\r' )? '\\\\n'\n                        {\n                            // org/batoo/jpa/jpql/JpqlLexer.g:21:6: ( Line_Comment | '--' )\n                            int alt3 = 2;\n                            switch(input.LA(1)) {\n                                case '/':\n                                    {\n                                        alt3 = 1;\n                                    }\n                                    break;\n                                case '-':\n                                    {\n                                        alt3 = 2;\n                                    }\n                                    break;\n                                default:\n                                    NoViableAltException nvae = new NoViableAltException(\"\", 3, 0, input);\n                                    throw nvae;\n                            }\n                            switch(alt3) {\n                                case 1:\n                                    // org/batoo/jpa/jpql/JpqlLexer.g:21:7: Line_Comment\n                                    {\n                                        mLine_Comment();\n                                    }\n                                    break;\n                                case 2:\n                                    // org/batoo/jpa/jpql/JpqlLexer.g:21:22: '--'\n                                    {\n                                        match(\"--\");\n                                    }\n                                    break;\n                            }\n                            // org/batoo/jpa/jpql/JpqlLexer.g:21:28: (~ ( '\\\\n' | '\\\\r' ) )*\n                            loop4: do {\n                                int alt4 = 2;\n                                int LA4_0 = input.LA(1);\n                                if (((LA4_0 >= '\\u0000' && LA4_0 <= '\\t') || (LA4_0 >= '\\u000B' && LA4_0 <= '\\f') || (LA4_0 >= '\\u000E' && LA4_0 <= '\\uFFFF'))) {\n                                    alt4 = 1;\n                                }\n                                switch(alt4) {\n                                    case 1:\n                                        // org/batoo/jpa/jpql/JpqlLexer.g:\n                                        {\n                                            if ((input.LA(1) >= '\\u0000' && input.LA(1) <= '\\t') || (input.LA(1) >= '\\u000B' && input.LA(1) <= '\\f') || (input.LA(1) >= '\\u000E' && input.LA(1) <= '\\uFFFF')) {\n                                                input.consume();\n                                            } else {\n                                                MismatchedSetException mse = new MismatchedSetException(null, input);\n                                                recover(mse);\n                                                throw mse;\n                                            }\n                                        }\n                                        break;\n                                    default:\n                                        break loop4;\n                                }\n                            } while (true);\n                            // org/batoo/jpa/jpql/JpqlLexer.g:21:44: ( '\\\\r' )?\n                            int alt5 = 2;\n                            switch(input.LA(1)) {\n                                case '\\r':\n                                    {\n                                        alt5 = 1;\n                                    }\n                                    break;\n                            }\n                            switch(alt5) {\n                                case 1:\n                                    // org/batoo/jpa/jpql/JpqlLexer.g:21:44: '\\\\r'\n                                    {\n                                        match('\\r');\n                                    }\n                                    break;\n                            }\n                            match('\\n');\n                        }\n                        break;\n                    default:\n                        if (cnt6 >= 1)\n                            break loop6;\n                        EarlyExitException eee = new EarlyExitException(6, input);\n                        throw eee;\n                }\n                cnt6++;\n            } while (true);\n            _channel = HIDDEN;\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LINE_COMMENT\"\n", "repo_name": "BatooJPA-master/", "id": 1467, "method_signature": "void mLINE_COMMENT()"}, "JpqlLexer.mLOCATE": {"callee_method_names": [], "method_name": "JpqlLexer.mLOCATE", "method_implementation": "{\n    try {\n        int _type = LOCATE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:249:8: ( L O C A T E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:250:5: L O C A T E\n        {\n            mL();\n            mO();\n            mC();\n            mA();\n            mT();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LOCATE\"\n", "repo_name": "BatooJPA-master/", "id": 1552, "method_signature": "void mLOCATE()"}, "JpqlLexer.mLONG": {"callee_method_names": [], "method_name": "JpqlLexer.mLONG", "method_implementation": "{\n    try {\n        int _type = LONG;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:252:6: ( L O N G )\n        // org/batoo/jpa/jpql/JpqlLexer.g:253:2: L O N G\n        {\n            mL();\n            mO();\n            mN();\n            mG();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LONG\"\n", "repo_name": "BatooJPA-master/", "id": 1553, "method_signature": "void mLONG()"}, "JpqlLexer.mLOWER": {"callee_method_names": [], "method_name": "JpqlLexer.mLOWER", "method_implementation": "{\n    try {\n        int _type = LOWER;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:255:7: ( L O W E R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:256:5: L O W E R\n        {\n            mL();\n            mO();\n            mW();\n            mE();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"LOWER\"\n", "repo_name": "BatooJPA-master/", "id": 1554, "method_signature": "void mLOWER()"}, "JpqlLexer.mLeft_Paren": {"callee_method_names": [], "method_name": "JpqlLexer.mLeft_Paren", "method_implementation": "{\n    try {\n        int _type = Left_Paren;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:402:12: ( '(' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:403:5: '('\n        {\n            match('(');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Left_Paren\"\n", "repo_name": "BatooJPA-master/", "id": 1603, "method_signature": "void mLeft_Paren()"}, "JpqlLexer.mLess_Or_Equals_Operator": {"callee_method_names": [], "method_name": "JpqlLexer.mLess_Or_Equals_Operator", "method_implementation": "{\n    try {\n        int _type = Less_Or_Equals_Operator;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:387:25: ( '<=' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:388:5: '<='\n        {\n            match(\"<=\");\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Less_Or_Equals_Operator\"\n", "repo_name": "BatooJPA-master/", "id": 1598, "method_signature": "void mLess_Or_Equals_Operator()"}, "JpqlLexer.mLess_Than_Operator": {"callee_method_names": [], "method_name": "JpqlLexer.mLess_Than_Operator", "method_implementation": "{\n    try {\n        int _type = Less_Than_Operator;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:393:20: ( '<' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:394:5: '<'\n        {\n            match('<');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Less_Than_Operator\"\n", "repo_name": "BatooJPA-master/", "id": 1600, "method_signature": "void mLess_Than_Operator()"}, "JpqlLexer.mLine_Comment": {"callee_method_names": [], "method_name": "JpqlLexer.mLine_Comment", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:15:23: ( '//' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:15:25: '//'\n        {\n            match(\"//\");\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Line_Comment\"\n", "repo_name": "BatooJPA-master/", "id": 1465, "method_signature": "void mLine_Comment()"}, "JpqlLexer.mM": {"callee_method_names": [], "method_name": "JpqlLexer.mM", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:47:12: ( 'M' | 'm' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'M' || input.LA(1) == 'm') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"M\"\n", "repo_name": "BatooJPA-master/", "id": 1480, "method_signature": "void mM()"}, "JpqlLexer.mMAX": {"callee_method_names": [], "method_name": "JpqlLexer.mMAX", "method_implementation": "{\n    try {\n        int _type = MAX;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:258:5: ( M A X )\n        // org/batoo/jpa/jpql/JpqlLexer.g:259:5: M A X\n        {\n            mM();\n            mA();\n            mX();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"MAX\"\n", "repo_name": "BatooJPA-master/", "id": 1555, "method_signature": "void mMAX()"}, "JpqlLexer.mMEMBER": {"callee_method_names": [], "method_name": "JpqlLexer.mMEMBER", "method_implementation": "{\n    try {\n        int _type = MEMBER;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:261:8: ( M E M B E R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:262:5: M E M B E R\n        {\n            mM();\n            mE();\n            mM();\n            mB();\n            mE();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"MEMBER\"\n", "repo_name": "BatooJPA-master/", "id": 1556, "method_signature": "void mMEMBER()"}, "JpqlLexer.mMIN": {"callee_method_names": [], "method_name": "JpqlLexer.mMIN", "method_implementation": "{\n    try {\n        int _type = MIN;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:264:5: ( M I N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:265:5: M I N\n        {\n            mM();\n            mI();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"MIN\"\n", "repo_name": "BatooJPA-master/", "id": 1557, "method_signature": "void mMIN()"}, "JpqlLexer.mMINUTE": {"callee_method_names": [], "method_name": "JpqlLexer.mMINUTE", "method_implementation": "{\n    try {\n        int _type = MINUTE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:267:8: ( M I N U T E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:268:2: M I N U T E\n        {\n            mM();\n            mI();\n            mN();\n            mU();\n            mT();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"MINUTE\"\n", "repo_name": "BatooJPA-master/", "id": 1558, "method_signature": "void mMINUTE()"}, "JpqlLexer.mMOD": {"callee_method_names": [], "method_name": "JpqlLexer.mMOD", "method_implementation": "{\n    try {\n        int _type = MOD;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:270:5: ( M O D )\n        // org/batoo/jpa/jpql/JpqlLexer.g:271:5: M O D\n        {\n            mM();\n            mO();\n            mD();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"MOD\"\n", "repo_name": "BatooJPA-master/", "id": 1559, "method_signature": "void mMOD()"}, "JpqlLexer.mMONTH": {"callee_method_names": [], "method_name": "JpqlLexer.mMONTH", "method_implementation": "{\n    try {\n        int _type = MONTH;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:273:7: ( M O N T H )\n        // org/batoo/jpa/jpql/JpqlLexer.g:274:2: M O N T H\n        {\n            mM();\n            mO();\n            mN();\n            mT();\n            mH();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"MONTH\"\n", "repo_name": "BatooJPA-master/", "id": 1560, "method_signature": "void mMONTH()"}, "JpqlLexer.mMinus_Sign": {"callee_method_names": [], "method_name": "JpqlLexer.mMinus_Sign", "method_implementation": "{\n    try {\n        int _type = Minus_Sign;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:411:12: ( '-' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:412:5: '-'\n        {\n            match('-');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Minus_Sign\"\n", "repo_name": "BatooJPA-master/", "id": 1606, "method_signature": "void mMinus_Sign()"}, "JpqlLexer.mMultiplication_Sign": {"callee_method_names": [], "method_name": "JpqlLexer.mMultiplication_Sign", "method_implementation": "{\n    try {\n        int _type = Multiplication_Sign;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:414:20: ( '*' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:415:2: '*'\n        {\n            match('*');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Multiplication_Sign\"\n", "repo_name": "BatooJPA-master/", "id": 1607, "method_signature": "void mMultiplication_Sign()"}, "JpqlLexer.mN": {"callee_method_names": [], "method_name": "JpqlLexer.mN", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:49:12: ( 'N' | 'n' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'N' || input.LA(1) == 'n') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"N\"\n", "repo_name": "BatooJPA-master/", "id": 1481, "method_signature": "void mN()"}, "JpqlLexer.mNEW": {"callee_method_names": [], "method_name": "JpqlLexer.mNEW", "method_implementation": "{\n    try {\n        int _type = NEW;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:276:5: ( N E W )\n        // org/batoo/jpa/jpql/JpqlLexer.g:277:5: N E W\n        {\n            mN();\n            mE();\n            mW();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"NEW\"\n", "repo_name": "BatooJPA-master/", "id": 1561, "method_signature": "void mNEW()"}, "JpqlLexer.mNOT": {"callee_method_names": [], "method_name": "JpqlLexer.mNOT", "method_implementation": "{\n    try {\n        int _type = NOT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:279:5: ( N O T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:280:5: N O T\n        {\n            mN();\n            mO();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"NOT\"\n", "repo_name": "BatooJPA-master/", "id": 1562, "method_signature": "void mNOT()"}, "JpqlLexer.mNULL": {"callee_method_names": [], "method_name": "JpqlLexer.mNULL", "method_implementation": "{\n    try {\n        int _type = NULL;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:285:6: ( N U L L )\n        // org/batoo/jpa/jpql/JpqlLexer.g:286:5: N U L L\n        {\n            mN();\n            mU();\n            mL();\n            mL();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"NULL\"\n", "repo_name": "BatooJPA-master/", "id": 1564, "method_signature": "void mNULL()"}, "JpqlLexer.mNULLIF": {"callee_method_names": [], "method_name": "JpqlLexer.mNULLIF", "method_implementation": "{\n    try {\n        int _type = NULLIF;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:282:8: ( N U L L I F )\n        // org/batoo/jpa/jpql/JpqlLexer.g:283:5: N U L L I F\n        {\n            mN();\n            mU();\n            mL();\n            mL();\n            mI();\n            mF();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"NULLIF\"\n", "repo_name": "BatooJPA-master/", "id": 1563, "method_signature": "void mNULLIF()"}, "JpqlLexer.mNUMERIC_LITERAL": {"callee_method_names": [], "method_name": "JpqlLexer.mNUMERIC_LITERAL", "method_implementation": "{\n    try {\n        int _type = NUMERIC_LITERAL;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:444:17: ( ( '0' .. '9' )+ ( Period ( '0' .. '9' )+ )? )\n        // org/batoo/jpa/jpql/JpqlLexer.g:445:2: ( '0' .. '9' )+ ( Period ( '0' .. '9' )+ )?\n        {\n            // org/batoo/jpa/jpql/JpqlLexer.g:445:2: ( '0' .. '9' )+\n            int cnt10 = 0;\n            loop10: do {\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlLexer.g:\n                        {\n                            if ((input.LA(1) >= '0' && input.LA(1) <= '9')) {\n                                input.consume();\n                            } else {\n                                MismatchedSetException mse = new MismatchedSetException(null, input);\n                                recover(mse);\n                                throw mse;\n                            }\n                        }\n                        break;\n                    default:\n                        if (cnt10 >= 1)\n                            break loop10;\n                        EarlyExitException eee = new EarlyExitException(10, input);\n                        throw eee;\n                }\n                cnt10++;\n            } while (true);\n            // org/batoo/jpa/jpql/JpqlLexer.g:445:14: ( Period ( '0' .. '9' )+ )?\n            int alt12 = 2;\n            switch(input.LA(1)) {\n                case '.':\n                    {\n                        alt12 = 1;\n                    }\n                    break;\n            }\n            switch(alt12) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlLexer.g:445:15: Period ( '0' .. '9' )+\n                    {\n                        mPeriod();\n                        // org/batoo/jpa/jpql/JpqlLexer.g:445:22: ( '0' .. '9' )+\n                        int cnt11 = 0;\n                        loop11: do {\n                            int alt11 = 2;\n                            switch(input.LA(1)) {\n                                case '0':\n                                case '1':\n                                case '2':\n                                case '3':\n                                case '4':\n                                case '5':\n                                case '6':\n                                case '7':\n                                case '8':\n                                case '9':\n                                    {\n                                        alt11 = 1;\n                                    }\n                                    break;\n                            }\n                            switch(alt11) {\n                                case 1:\n                                    // org/batoo/jpa/jpql/JpqlLexer.g:\n                                    {\n                                        if ((input.LA(1) >= '0' && input.LA(1) <= '9')) {\n                                            input.consume();\n                                        } else {\n                                            MismatchedSetException mse = new MismatchedSetException(null, input);\n                                            recover(mse);\n                                            throw mse;\n                                        }\n                                    }\n                                    break;\n                                default:\n                                    if (cnt11 >= 1)\n                                        break loop11;\n                                    EarlyExitException eee = new EarlyExitException(11, input);\n                                    throw eee;\n                            }\n                            cnt11++;\n                        } while (true);\n                    }\n                    break;\n            }\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"NUMERIC_LITERAL\"\n", "repo_name": "BatooJPA-master/", "id": 1617, "method_signature": "void mNUMERIC_LITERAL()"}, "JpqlLexer.mNamed_Parameter": {"callee_method_names": [], "method_name": "JpqlLexer.mNamed_Parameter", "method_implementation": "{\n    try {\n        int _type = Named_Parameter;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:438:17: ( Column ID )\n        // org/batoo/jpa/jpql/JpqlLexer.g:439:5: Column ID\n        {\n            mColumn();\n            mID();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Named_Parameter\"\n", "repo_name": "BatooJPA-master/", "id": 1615, "method_signature": "void mNamed_Parameter()"}, "JpqlLexer.mNot_Equals_Operator": {"callee_method_names": [], "method_name": "JpqlLexer.mNot_Equals_Operator", "method_implementation": "{\n    try {\n        int _type = Not_Equals_Operator;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:381:21: ( '<>' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:382:5: '<>'\n        {\n            match(\"<>\");\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Not_Equals_Operator\"\n", "repo_name": "BatooJPA-master/", "id": 1596, "method_signature": "void mNot_Equals_Operator()"}, "JpqlLexer.mO": {"callee_method_names": [], "method_name": "JpqlLexer.mO", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:51:12: ( 'O' | 'o' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'O' || input.LA(1) == 'o') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"O\"\n", "repo_name": "BatooJPA-master/", "id": 1482, "method_signature": "void mO()"}, "JpqlLexer.mOBJECT": {"callee_method_names": [], "method_name": "JpqlLexer.mOBJECT", "method_implementation": "{\n    try {\n        int _type = OBJECT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:288:8: ( O B J E C T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:289:5: O B J E C T\n        {\n            mO();\n            mB();\n            mJ();\n            mE();\n            mC();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"OBJECT\"\n", "repo_name": "BatooJPA-master/", "id": 1565, "method_signature": "void mOBJECT()"}, "JpqlLexer.mOF": {"callee_method_names": [], "method_name": "JpqlLexer.mOF", "method_implementation": "{\n    try {\n        int _type = OF;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:291:4: ( O F )\n        // org/batoo/jpa/jpql/JpqlLexer.g:292:5: O F\n        {\n            mO();\n            mF();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"OF\"\n", "repo_name": "BatooJPA-master/", "id": 1566, "method_signature": "void mOF()"}, "JpqlLexer.mOR": {"callee_method_names": [], "method_name": "JpqlLexer.mOR", "method_implementation": "{\n    try {\n        int _type = OR;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:294:4: ( O R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:295:5: O R\n        {\n            mO();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"OR\"\n", "repo_name": "BatooJPA-master/", "id": 1567, "method_signature": "void mOR()"}, "JpqlLexer.mORDER": {"callee_method_names": [], "method_name": "JpqlLexer.mORDER", "method_implementation": "{\n    try {\n        int _type = ORDER;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:297:7: ( O R D E R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:298:5: O R D E R\n        {\n            mO();\n            mR();\n            mD();\n            mE();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"ORDER\"\n", "repo_name": "BatooJPA-master/", "id": 1568, "method_signature": "void mORDER()"}, "JpqlLexer.mOUTER": {"callee_method_names": [], "method_name": "JpqlLexer.mOUTER", "method_implementation": "{\n    try {\n        int _type = OUTER;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:300:7: ( O U T E R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:301:5: O U T E R\n        {\n            mO();\n            mU();\n            mT();\n            mE();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"OUTER\"\n", "repo_name": "BatooJPA-master/", "id": 1569, "method_signature": "void mOUTER()"}, "JpqlLexer.mOrdinal_Parameter": {"callee_method_names": [], "method_name": "JpqlLexer.mOrdinal_Parameter", "method_implementation": "{\n    try {\n        int _type = Ordinal_Parameter;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:435:19: ( Question_Sign ( '0' .. '9' )+ )\n        // org/batoo/jpa/jpql/JpqlLexer.g:436:5: Question_Sign ( '0' .. '9' )+\n        {\n            mQuestion_Sign();\n            // org/batoo/jpa/jpql/JpqlLexer.g:436:19: ( '0' .. '9' )+\n            int cnt8 = 0;\n            loop8: do {\n                int alt8 = 2;\n                switch(input.LA(1)) {\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                }\n                switch(alt8) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlLexer.g:\n                        {\n                            if ((input.LA(1) >= '0' && input.LA(1) <= '9')) {\n                                input.consume();\n                            } else {\n                                MismatchedSetException mse = new MismatchedSetException(null, input);\n                                recover(mse);\n                                throw mse;\n                            }\n                        }\n                        break;\n                    default:\n                        if (cnt8 >= 1)\n                            break loop8;\n                        EarlyExitException eee = new EarlyExitException(8, input);\n                        throw eee;\n                }\n                cnt8++;\n            } while (true);\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Ordinal_Parameter\"\n", "repo_name": "BatooJPA-master/", "id": 1614, "method_signature": "void mOrdinal_Parameter()"}, "JpqlLexer.mP": {"callee_method_names": [], "method_name": "JpqlLexer.mP", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:53:12: ( 'P' | 'p' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'P' || input.LA(1) == 'p') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"P\"\n", "repo_name": "BatooJPA-master/", "id": 1483, "method_signature": "void mP()"}, "JpqlLexer.mPOSITION": {"callee_method_names": [], "method_name": "JpqlLexer.mPOSITION", "method_implementation": "{\n    try {\n        int _type = POSITION;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:303:10: ( P O S I T I O N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:304:5: P O S I T I O N\n        {\n            mP();\n            mO();\n            mS();\n            mI();\n            mT();\n            mI();\n            mO();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"POSITION\"\n", "repo_name": "BatooJPA-master/", "id": 1570, "method_signature": "void mPOSITION()"}, "JpqlLexer.mPROPERTIES": {"callee_method_names": [], "method_name": "JpqlLexer.mPROPERTIES", "method_implementation": "{\n    try {\n        int _type = PROPERTIES;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:306:12: ( P R O P E R T I E S )\n        // org/batoo/jpa/jpql/JpqlLexer.g:307:2: P R O P E R T I E S\n        {\n            mP();\n            mR();\n            mO();\n            mP();\n            mE();\n            mR();\n            mT();\n            mI();\n            mE();\n            mS();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"PROPERTIES\"\n", "repo_name": "BatooJPA-master/", "id": 1571, "method_signature": "void mPROPERTIES()"}, "JpqlLexer.mPeriod": {"callee_method_names": [], "method_name": "JpqlLexer.mPeriod", "method_implementation": "{\n    try {\n        int _type = Period;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:423:8: ( '.' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:424:5: '.'\n        {\n            match('.');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Period\"\n", "repo_name": "BatooJPA-master/", "id": 1610, "method_signature": "void mPeriod()"}, "JpqlLexer.mPlus_Sign": {"callee_method_names": [], "method_name": "JpqlLexer.mPlus_Sign", "method_implementation": "{\n    try {\n        int _type = Plus_Sign;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:408:11: ( '+' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:409:5: '+'\n        {\n            match('+');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Plus_Sign\"\n", "repo_name": "BatooJPA-master/", "id": 1605, "method_signature": "void mPlus_Sign()"}, "JpqlLexer.mQ": {"callee_method_names": [], "method_name": "JpqlLexer.mQ", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:55:12: ( 'Q' | 'q' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'Q' || input.LA(1) == 'q') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Q\"\n", "repo_name": "BatooJPA-master/", "id": 1484, "method_signature": "void mQ()"}, "JpqlLexer.mQuestion_Sign": {"callee_method_names": [], "method_name": "JpqlLexer.mQuestion_Sign", "method_implementation": "{\n    try {\n        int _type = Question_Sign;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:429:15: ( '?' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:430:5: '?'\n        {\n            match('?');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Question_Sign\"\n", "repo_name": "BatooJPA-master/", "id": 1612, "method_signature": "void mQuestion_Sign()"}, "JpqlLexer.mR": {"callee_method_names": [], "method_name": "JpqlLexer.mR", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:57:12: ( 'R' | 'r' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'R' || input.LA(1) == 'r') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"R\"\n", "repo_name": "BatooJPA-master/", "id": 1485, "method_signature": "void mR()"}, "JpqlLexer.mRight_Paren": {"callee_method_names": [], "method_name": "JpqlLexer.mRight_Paren", "method_implementation": "{\n    try {\n        int _type = Right_Paren;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:405:13: ( ')' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:406:5: ')'\n        {\n            match(')');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Right_Paren\"\n", "repo_name": "BatooJPA-master/", "id": 1604, "method_signature": "void mRight_Paren()"}, "JpqlLexer.mS": {"callee_method_names": [], "method_name": "JpqlLexer.mS", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:59:12: ( 'S' | 's' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'S' || input.LA(1) == 's') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"S\"\n", "repo_name": "BatooJPA-master/", "id": 1486, "method_signature": "void mS()"}, "JpqlLexer.mSECOND": {"callee_method_names": [], "method_name": "JpqlLexer.mSECOND", "method_implementation": "{\n    try {\n        int _type = SECOND;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:309:8: ( S E C O N D )\n        // org/batoo/jpa/jpql/JpqlLexer.g:310:2: S E C O N D\n        {\n            mS();\n            mE();\n            mC();\n            mO();\n            mN();\n            mD();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SECOND\"\n", "repo_name": "BatooJPA-master/", "id": 1572, "method_signature": "void mSECOND()"}, "JpqlLexer.mSELECT": {"callee_method_names": [], "method_name": "JpqlLexer.mSELECT", "method_implementation": "{\n    try {\n        int _type = SELECT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:312:8: ( S E L E C T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:313:5: S E L E C T\n        {\n            mS();\n            mE();\n            mL();\n            mE();\n            mC();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SELECT\"\n", "repo_name": "BatooJPA-master/", "id": 1573, "method_signature": "void mSELECT()"}, "JpqlLexer.mSET": {"callee_method_names": [], "method_name": "JpqlLexer.mSET", "method_implementation": "{\n    try {\n        int _type = SET;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:315:5: ( S E T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:316:5: S E T\n        {\n            mS();\n            mE();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SET\"\n", "repo_name": "BatooJPA-master/", "id": 1574, "method_signature": "void mSET()"}, "JpqlLexer.mSHORT": {"callee_method_names": [], "method_name": "JpqlLexer.mSHORT", "method_implementation": "{\n    try {\n        int _type = SHORT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:318:7: ( S H O R T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:319:2: S H O R T\n        {\n            mS();\n            mH();\n            mO();\n            mR();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SHORT\"\n", "repo_name": "BatooJPA-master/", "id": 1575, "method_signature": "void mSHORT()"}, "JpqlLexer.mSIZE": {"callee_method_names": [], "method_name": "JpqlLexer.mSIZE", "method_implementation": "{\n    try {\n        int _type = SIZE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:321:6: ( S I Z E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:322:5: S I Z E\n        {\n            mS();\n            mI();\n            mZ();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SIZE\"\n", "repo_name": "BatooJPA-master/", "id": 1576, "method_signature": "void mSIZE()"}, "JpqlLexer.mSOME": {"callee_method_names": [], "method_name": "JpqlLexer.mSOME", "method_implementation": "{\n    try {\n        int _type = SOME;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:324:6: ( S O M E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:325:5: S O M E\n        {\n            mS();\n            mO();\n            mM();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SOME\"\n", "repo_name": "BatooJPA-master/", "id": 1577, "method_signature": "void mSOME()"}, "JpqlLexer.mSQRT": {"callee_method_names": [], "method_name": "JpqlLexer.mSQRT", "method_implementation": "{\n    try {\n        int _type = SQRT;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:327:6: ( S Q R T )\n        // org/batoo/jpa/jpql/JpqlLexer.g:328:5: S Q R T\n        {\n            mS();\n            mQ();\n            mR();\n            mT();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SQRT\"\n", "repo_name": "BatooJPA-master/", "id": 1578, "method_signature": "void mSQRT()"}, "JpqlLexer.mSTRING": {"callee_method_names": [], "method_name": "JpqlLexer.mSTRING", "method_implementation": "{\n    try {\n        int _type = STRING;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:330:8: ( S T R I N G )\n        // org/batoo/jpa/jpql/JpqlLexer.g:331:2: S T R I N G\n        {\n            mS();\n            mT();\n            mR();\n            mI();\n            mN();\n            mG();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"STRING\"\n", "repo_name": "BatooJPA-master/", "id": 1579, "method_signature": "void mSTRING()"}, "JpqlLexer.mSTRING_LITERAL": {"callee_method_names": [], "method_name": "JpqlLexer.mSTRING_LITERAL", "method_implementation": "{\n    try {\n        int _type = STRING_LITERAL;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:447:16: ( '\\\\'' (~ ( '\\\\'' | '\\\\\\\\' | '\\\\r' | '\\\\n' ) )* '\\\\'' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:448:2: '\\\\'' (~ ( '\\\\'' | '\\\\\\\\' | '\\\\r' | '\\\\n' ) )* '\\\\''\n        {\n            match('\\'');\n            // org/batoo/jpa/jpql/JpqlLexer.g:448:7: (~ ( '\\\\'' | '\\\\\\\\' | '\\\\r' | '\\\\n' ) )*\n            loop13: do {\n                int alt13 = 2;\n                int LA13_0 = input.LA(1);\n                if (((LA13_0 >= '\\u0000' && LA13_0 <= '\\t') || (LA13_0 >= '\\u000B' && LA13_0 <= '\\f') || (LA13_0 >= '\\u000E' && LA13_0 <= '&') || (LA13_0 >= '(' && LA13_0 <= '[') || (LA13_0 >= ']' && LA13_0 <= '\\uFFFF'))) {\n                    alt13 = 1;\n                }\n                switch(alt13) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlLexer.g:\n                        {\n                            if ((input.LA(1) >= '\\u0000' && input.LA(1) <= '\\t') || (input.LA(1) >= '\\u000B' && input.LA(1) <= '\\f') || (input.LA(1) >= '\\u000E' && input.LA(1) <= '&') || (input.LA(1) >= '(' && input.LA(1) <= '[') || (input.LA(1) >= ']' && input.LA(1) <= '\\uFFFF')) {\n                                input.consume();\n                            } else {\n                                MismatchedSetException mse = new MismatchedSetException(null, input);\n                                recover(mse);\n                                throw mse;\n                            }\n                        }\n                        break;\n                    default:\n                        break loop13;\n                }\n            } while (true);\n            match('\\'');\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"STRING_LITERAL\"\n", "repo_name": "BatooJPA-master/", "id": 1618, "method_signature": "void mSTRING_LITERAL()"}, "JpqlLexer.mSUBSTRING": {"callee_method_names": [], "method_name": "JpqlLexer.mSUBSTRING", "method_implementation": "{\n    try {\n        int _type = SUBSTRING;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:333:11: ( S U B S T R I N G )\n        // org/batoo/jpa/jpql/JpqlLexer.g:334:5: S U B S T R I N G\n        {\n            mS();\n            mU();\n            mB();\n            mS();\n            mT();\n            mR();\n            mI();\n            mN();\n            mG();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SUBSTRING\"\n", "repo_name": "BatooJPA-master/", "id": 1580, "method_signature": "void mSUBSTRING()"}, "JpqlLexer.mSUM": {"callee_method_names": [], "method_name": "JpqlLexer.mSUM", "method_implementation": "{\n    try {\n        int _type = SUM;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:336:5: ( S U M )\n        // org/batoo/jpa/jpql/JpqlLexer.g:337:5: S U M\n        {\n            mS();\n            mU();\n            mM();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"SUM\"\n", "repo_name": "BatooJPA-master/", "id": 1581, "method_signature": "void mSUM()"}, "JpqlLexer.mStart_Comment": {"callee_method_names": [], "method_name": "JpqlLexer.mStart_Comment", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:11:24: ( '/*' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:11:26: '/*'\n        {\n            match(\"/*\");\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Start_Comment\"\n", "repo_name": "BatooJPA-master/", "id": 1463, "method_signature": "void mStart_Comment()"}, "JpqlLexer.mT": {"callee_method_names": [], "method_name": "JpqlLexer.mT", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:61:12: ( 'T' | 't' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'T' || input.LA(1) == 't') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"T\"\n", "repo_name": "BatooJPA-master/", "id": 1487, "method_signature": "void mT()"}, "JpqlLexer.mTHEN": {"callee_method_names": [], "method_name": "JpqlLexer.mTHEN", "method_implementation": "{\n    try {\n        int _type = THEN;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:339:6: ( T H E N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:340:5: T H E N\n        {\n            mT();\n            mH();\n            mE();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"THEN\"\n", "repo_name": "BatooJPA-master/", "id": 1582, "method_signature": "void mTHEN()"}, "JpqlLexer.mTRAILING": {"callee_method_names": [], "method_name": "JpqlLexer.mTRAILING", "method_implementation": "{\n    try {\n        int _type = TRAILING;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:342:10: ( T R A I L I N G )\n        // org/batoo/jpa/jpql/JpqlLexer.g:343:5: T R A I L I N G\n        {\n            mT();\n            mR();\n            mA();\n            mI();\n            mL();\n            mI();\n            mN();\n            mG();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"TRAILING\"\n", "repo_name": "BatooJPA-master/", "id": 1583, "method_signature": "void mTRAILING()"}, "JpqlLexer.mTRIM": {"callee_method_names": [], "method_name": "JpqlLexer.mTRIM", "method_implementation": "{\n    try {\n        int _type = TRIM;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:345:6: ( T R I M )\n        // org/batoo/jpa/jpql/JpqlLexer.g:346:5: T R I M\n        {\n            mT();\n            mR();\n            mI();\n            mM();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"TRIM\"\n", "repo_name": "BatooJPA-master/", "id": 1584, "method_signature": "void mTRIM()"}, "JpqlLexer.mTRUE": {"callee_method_names": [], "method_name": "JpqlLexer.mTRUE", "method_implementation": "{\n    try {\n        int _type = TRUE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:348:6: ( T R U E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:349:5: T R U E\n        {\n            mT();\n            mR();\n            mU();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"TRUE\"\n", "repo_name": "BatooJPA-master/", "id": 1585, "method_signature": "void mTRUE()"}, "JpqlLexer.mTYPE": {"callee_method_names": [], "method_name": "JpqlLexer.mTYPE", "method_implementation": "{\n    try {\n        int _type = TYPE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:351:6: ( T Y P E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:352:5: T Y P E\n        {\n            mT();\n            mY();\n            mP();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"TYPE\"\n", "repo_name": "BatooJPA-master/", "id": 1586, "method_signature": "void mTYPE()"}, "JpqlLexer.mU": {"callee_method_names": [], "method_name": "JpqlLexer.mU", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:63:12: ( 'U' | 'u' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'U' || input.LA(1) == 'u') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"U\"\n", "repo_name": "BatooJPA-master/", "id": 1488, "method_signature": "void mU()"}, "JpqlLexer.mUNKNOWN": {"callee_method_names": [], "method_name": "JpqlLexer.mUNKNOWN", "method_implementation": "{\n    try {\n        int _type = UNKNOWN;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:354:9: ( U N K N O W N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:355:5: U N K N O W N\n        {\n            mU();\n            mN();\n            mK();\n            mN();\n            mO();\n            mW();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"UNKNOWN\"\n", "repo_name": "BatooJPA-master/", "id": 1587, "method_signature": "void mUNKNOWN()"}, "JpqlLexer.mUPDATE": {"callee_method_names": [], "method_name": "JpqlLexer.mUPDATE", "method_implementation": "{\n    try {\n        int _type = UPDATE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:357:8: ( U P D A T E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:358:5: U P D A T E\n        {\n            mU();\n            mP();\n            mD();\n            mA();\n            mT();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"UPDATE\"\n", "repo_name": "BatooJPA-master/", "id": 1588, "method_signature": "void mUPDATE()"}, "JpqlLexer.mUPPER": {"callee_method_names": [], "method_name": "JpqlLexer.mUPPER", "method_implementation": "{\n    try {\n        int _type = UPPER;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:360:7: ( U P P E R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:361:5: U P P E R\n        {\n            mU();\n            mP();\n            mP();\n            mE();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"UPPER\"\n", "repo_name": "BatooJPA-master/", "id": 1589, "method_signature": "void mUPPER()"}, "JpqlLexer.mUnderscore": {"callee_method_names": [], "method_name": "JpqlLexer.mUnderscore", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:75:21: ( '_' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:76:5: '_'\n        {\n            match('_');\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Underscore\"\n", "repo_name": "BatooJPA-master/", "id": 1494, "method_signature": "void mUnderscore()"}, "JpqlLexer.mV": {"callee_method_names": [], "method_name": "JpqlLexer.mV", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:65:12: ( 'V' | 'v' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'V' || input.LA(1) == 'v') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"V\"\n", "repo_name": "BatooJPA-master/", "id": 1489, "method_signature": "void mV()"}, "JpqlLexer.mVALUE": {"callee_method_names": [], "method_name": "JpqlLexer.mVALUE", "method_implementation": "{\n    try {\n        int _type = VALUE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:363:7: ( V A L U E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:364:5: V A L U E\n        {\n            mV();\n            mA();\n            mL();\n            mU();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"VALUE\"\n", "repo_name": "BatooJPA-master/", "id": 1590, "method_signature": "void mVALUE()"}, "JpqlLexer.mVARCHAR": {"callee_method_names": [], "method_name": "JpqlLexer.mVARCHAR", "method_implementation": "{\n    try {\n        int _type = VARCHAR;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:366:9: ( V A R C H A R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:367:2: V A R C H A R\n        {\n            mV();\n            mA();\n            mR();\n            mC();\n            mH();\n            mA();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"VARCHAR\"\n", "repo_name": "BatooJPA-master/", "id": 1591, "method_signature": "void mVARCHAR()"}, "JpqlLexer.mW": {"callee_method_names": [], "method_name": "JpqlLexer.mW", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:67:12: ( 'W' | 'w' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'W' || input.LA(1) == 'w') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"W\"\n", "repo_name": "BatooJPA-master/", "id": 1490, "method_signature": "void mW()"}, "JpqlLexer.mWEEK": {"callee_method_names": [], "method_name": "JpqlLexer.mWEEK", "method_implementation": "{\n    try {\n        int _type = WEEK;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:369:6: ( W E E K )\n        // org/batoo/jpa/jpql/JpqlLexer.g:370:2: W E E K\n        {\n            mW();\n            mE();\n            mE();\n            mK();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"WEEK\"\n", "repo_name": "BatooJPA-master/", "id": 1592, "method_signature": "void mWEEK()"}, "JpqlLexer.mWHEN": {"callee_method_names": [], "method_name": "JpqlLexer.mWHEN", "method_implementation": "{\n    try {\n        int _type = WHEN;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:372:6: ( W H E N )\n        // org/batoo/jpa/jpql/JpqlLexer.g:373:5: W H E N\n        {\n            mW();\n            mH();\n            mE();\n            mN();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"WHEN\"\n", "repo_name": "BatooJPA-master/", "id": 1593, "method_signature": "void mWHEN()"}, "JpqlLexer.mWHERE": {"callee_method_names": [], "method_name": "JpqlLexer.mWHERE", "method_implementation": "{\n    try {\n        int _type = WHERE;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:375:7: ( W H E R E )\n        // org/batoo/jpa/jpql/JpqlLexer.g:376:5: W H E R E\n        {\n            mW();\n            mH();\n            mE();\n            mR();\n            mE();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"WHERE\"\n", "repo_name": "BatooJPA-master/", "id": 1594, "method_signature": "void mWHERE()"}, "JpqlLexer.mWS": {"callee_method_names": [], "method_name": "JpqlLexer.mWS", "method_implementation": "{\n    try {\n        int _type = WS;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:432:4: ( ( ' ' | '\\\\t' | '\\\\r' | '\\\\n' )+ )\n        // org/batoo/jpa/jpql/JpqlLexer.g:433:5: ( ' ' | '\\\\t' | '\\\\r' | '\\\\n' )+\n        {\n            // org/batoo/jpa/jpql/JpqlLexer.g:433:5: ( ' ' | '\\\\t' | '\\\\r' | '\\\\n' )+\n            int cnt7 = 0;\n            loop7: do {\n                int alt7 = 2;\n                switch(input.LA(1)) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\r':\n                    case ' ':\n                        {\n                            alt7 = 1;\n                        }\n                        break;\n                }\n                switch(alt7) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlLexer.g:\n                        {\n                            if ((input.LA(1) >= '\\t' && input.LA(1) <= '\\n') || input.LA(1) == '\\r' || input.LA(1) == ' ') {\n                                input.consume();\n                            } else {\n                                MismatchedSetException mse = new MismatchedSetException(null, input);\n                                recover(mse);\n                                throw mse;\n                            }\n                        }\n                        break;\n                    default:\n                        if (cnt7 >= 1)\n                            break loop7;\n                        EarlyExitException eee = new EarlyExitException(7, input);\n                        throw eee;\n                }\n                cnt7++;\n            } while (true);\n            _channel = HIDDEN;\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"WS\"\n", "repo_name": "BatooJPA-master/", "id": 1613, "method_signature": "void mWS()"}, "JpqlLexer.mX": {"callee_method_names": [], "method_name": "JpqlLexer.mX", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:69:12: ( 'X' | 'x' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'X' || input.LA(1) == 'x') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"X\"\n", "repo_name": "BatooJPA-master/", "id": 1491, "method_signature": "void mX()"}, "JpqlLexer.mY": {"callee_method_names": [], "method_name": "JpqlLexer.mY", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:71:12: ( 'Y' | 'y' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'Y' || input.LA(1) == 'y') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Y\"\n", "repo_name": "BatooJPA-master/", "id": 1492, "method_signature": "void mY()"}, "JpqlLexer.mYEAR": {"callee_method_names": [], "method_name": "JpqlLexer.mYEAR", "method_implementation": "{\n    try {\n        int _type = YEAR;\n        int _channel = DEFAULT_TOKEN_CHANNEL;\n        // org/batoo/jpa/jpql/JpqlLexer.g:378:6: ( Y E A R )\n        // org/batoo/jpa/jpql/JpqlLexer.g:379:2: Y E A R\n        {\n            mY();\n            mE();\n            mA();\n            mR();\n        }\n        state.type = _type;\n        state.channel = _channel;\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"YEAR\"\n", "repo_name": "BatooJPA-master/", "id": 1595, "method_signature": "void mYEAR()"}, "JpqlLexer.mZ": {"callee_method_names": [], "method_name": "JpqlLexer.mZ", "method_implementation": "{\n    try {\n        // org/batoo/jpa/jpql/JpqlLexer.g:73:12: ( 'Z' | 'z' )\n        // org/batoo/jpa/jpql/JpqlLexer.g:\n        {\n            if (input.LA(1) == 'Z' || input.LA(1) == 'z') {\n                input.consume();\n            } else {\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                recover(mse);\n                throw mse;\n            }\n        }\n    } finally {\n        // do for sure before leaving\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start \"Z\"\n", "repo_name": "BatooJPA-master/", "id": 1493, "method_signature": "void mZ()"}, "JpqlParser.aggregate_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.aggregate_expression", "method_implementation": "{\n    JpqlParser.aggregate_expression_return retval = new JpqlParser.aggregate_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token set196 = null;\n    Token Left_Paren197 = null;\n    Token DISTINCT198 = null;\n    Token Right_Paren200 = null;\n    Token COUNT201 = null;\n    Token Left_Paren202 = null;\n    Token DISTINCT203 = null;\n    Token ID204 = null;\n    Token Right_Paren206 = null;\n    JpqlParser.scalar_expression_return scalar_expression199 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression205 = null;\n    CommonTree set196_tree = null;\n    CommonTree Left_Paren197_tree = null;\n    CommonTree DISTINCT198_tree = null;\n    CommonTree Right_Paren200_tree = null;\n    CommonTree COUNT201_tree = null;\n    CommonTree Left_Paren202_tree = null;\n    CommonTree DISTINCT203_tree = null;\n    CommonTree ID204_tree = null;\n    CommonTree Right_Paren206_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:264:22: ( ( AVG | MAX | MIN | SUM ) ^ Left_Paren ! ( DISTINCT )? scalar_expression Right_Paren !| COUNT ^ Left_Paren ! ( DISTINCT )? ( ID | state_field_path_expression ) Right_Paren !)\n        int alt49 = 2;\n        switch(input.LA(1)) {\n            case AVG:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    alt49 = 1;\n                }\n                break;\n            case COUNT:\n                {\n                    alt49 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 49, 0, input);\n                throw nvae;\n        }\n        switch(alt49) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:265:2: ( AVG | MAX | MIN | SUM ) ^ Left_Paren ! ( DISTINCT )? scalar_expression Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    set196 = (Token) input.LT(1);\n                    set196 = (Token) input.LT(1);\n                    if (input.LA(1) == AVG || input.LA(1) == MAX || input.LA(1) == MIN || input.LA(1) == SUM) {\n                        input.consume();\n                        if (state.backtracking == 0)\n                            root_0 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(set196), root_0);\n                        state.errorRecovery = false;\n                        state.failed = false;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        MismatchedSetException mse = new MismatchedSetException(null, input);\n                        throw mse;\n                    }\n                    Left_Paren197 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_aggregate_expression2275);\n                    if (state.failed)\n                        return retval;\n                    // org/batoo/jpa/jpql/JpqlParser.g:265:39: ( DISTINCT )?\n                    int alt46 = 2;\n                    switch(input.LA(1)) {\n                        case DISTINCT:\n                            {\n                                alt46 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt46) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:265:40: DISTINCT\n                            {\n                                DISTINCT198 = (Token) match(input, DISTINCT, FOLLOW_DISTINCT_in_aggregate_expression2279);\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0) {\n                                    DISTINCT198_tree = (CommonTree) adaptor.create(DISTINCT198);\n                                    adaptor.addChild(root_0, DISTINCT198_tree);\n                                }\n                            }\n                            break;\n                    }\n                    pushFollow(FOLLOW_scalar_expression_in_aggregate_expression2283);\n                    scalar_expression199 = scalar_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, scalar_expression199.getTree());\n                    Right_Paren200 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_aggregate_expression2285);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:266:4: COUNT ^ Left_Paren ! ( DISTINCT )? ( ID | state_field_path_expression ) Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    COUNT201 = (Token) match(input, COUNT, FOLLOW_COUNT_in_aggregate_expression2291);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        COUNT201_tree = (CommonTree) adaptor.create(COUNT201);\n                        root_0 = (CommonTree) adaptor.becomeRoot(COUNT201_tree, root_0);\n                    }\n                    Left_Paren202 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_aggregate_expression2294);\n                    if (state.failed)\n                        return retval;\n                    // org/batoo/jpa/jpql/JpqlParser.g:266:23: ( DISTINCT )?\n                    int alt47 = 2;\n                    switch(input.LA(1)) {\n                        case DISTINCT:\n                            {\n                                alt47 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt47) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:266:24: DISTINCT\n                            {\n                                DISTINCT203 = (Token) match(input, DISTINCT, FOLLOW_DISTINCT_in_aggregate_expression2298);\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0) {\n                                    DISTINCT203_tree = (CommonTree) adaptor.create(DISTINCT203);\n                                    adaptor.addChild(root_0, DISTINCT203_tree);\n                                }\n                            }\n                            break;\n                    }\n                    // org/batoo/jpa/jpql/JpqlParser.g:266:35: ( ID | state_field_path_expression )\n                    int alt48 = 2;\n                    switch(input.LA(1)) {\n                        case ID:\n                            {\n                                switch(input.LA(2)) {\n                                    case Period:\n                                        {\n                                            alt48 = 2;\n                                        }\n                                        break;\n                                    case Right_Paren:\n                                        {\n                                            alt48 = 1;\n                                        }\n                                        break;\n                                    default:\n                                        if (state.backtracking > 0) {\n                                            state.failed = true;\n                                            return retval;\n                                        }\n                                        NoViableAltException nvae = new NoViableAltException(\"\", 48, 1, input);\n                                        throw nvae;\n                                }\n                            }\n                            break;\n                        case CAST:\n                            {\n                                alt48 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 48, 0, input);\n                            throw nvae;\n                    }\n                    switch(alt48) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:266:36: ID\n                            {\n                                ID204 = (Token) match(input, ID, FOLLOW_ID_in_aggregate_expression2303);\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0) {\n                                    ID204_tree = (CommonTree) adaptor.create(ID204);\n                                    adaptor.addChild(root_0, ID204_tree);\n                                }\n                            }\n                            break;\n                        case 2:\n                            // org/batoo/jpa/jpql/JpqlParser.g:266:41: state_field_path_expression\n                            {\n                                pushFollow(FOLLOW_state_field_path_expression_in_aggregate_expression2307);\n                                state_field_path_expression205 = state_field_path_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, state_field_path_expression205.getTree());\n                            }\n                            break;\n                    }\n                    Right_Paren206 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_aggregate_expression2310);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:264:1: aggregate_expression : ( ( AVG | MAX | MIN | SUM ) ^ Left_Paren ! ( DISTINCT )? scalar_expression Right_Paren !| COUNT ^ Left_Paren ! ( DISTINCT )? ( ID | state_field_path_expression ) Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1390, "method_signature": "JpqlParser.aggregate_expression_return aggregate_expression()"}, "JpqlParser.aliased_qid": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.qid_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.aliased_qid", "method_implementation": "{\n    JpqlParser.aliased_qid_return retval = new JpqlParser.aliased_qid_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token AS454 = null;\n    Token ID455 = null;\n    JpqlParser.qid_return qid453 = null;\n    CommonTree AS454_tree = null;\n    CommonTree ID455_tree = null;\n    RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor, \"token AS\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    RewriteRuleSubtreeStream stream_qid = new RewriteRuleSubtreeStream(adaptor, \"rule qid\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:466:13: ( qid ( ( AS )? ID )? -> ^( ST_ID_AS qid ( ID )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:467:5: qid ( ( AS )? ID )?\n        {\n            pushFollow(FOLLOW_qid_in_aliased_qid3949);\n            qid453 = qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_qid.add(qid453.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:467:9: ( ( AS )? ID )?\n            int alt96 = 2;\n            switch(input.LA(1)) {\n                case AS:\n                case ID:\n                    {\n                        alt96 = 1;\n                    }\n                    break;\n            }\n            switch(alt96) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:467:10: ( AS )? ID\n                    {\n                        // org/batoo/jpa/jpql/JpqlParser.g:467:10: ( AS )?\n                        int alt95 = 2;\n                        switch(input.LA(1)) {\n                            case AS:\n                                {\n                                    alt95 = 1;\n                                }\n                                break;\n                        }\n                        switch(alt95) {\n                            case 1:\n                                // org/batoo/jpa/jpql/JpqlParser.g:467:11: AS\n                                {\n                                    AS454 = (Token) match(input, AS, FOLLOW_AS_in_aliased_qid3953);\n                                    if (state.failed)\n                                        return retval;\n                                    if (state.backtracking == 0)\n                                        stream_AS.add(AS454);\n                                }\n                                break;\n                        }\n                        ID455 = (Token) match(input, ID, FOLLOW_ID_in_aliased_qid3957);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ID.add(ID455);\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: qid, ID\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 468:9: -> ^( ST_ID_AS qid ( ID )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:468:12: ^( ST_ID_AS qid ( ID )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ID_AS, \"ST_ID_AS\"), root_1);\n                        adaptor.addChild(root_1, stream_qid.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:468:27: ( ID )?\n                        if (stream_ID.hasNext()) {\n                            adaptor.addChild(root_1, stream_ID.nextNode());\n                        }\n                        stream_ID.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:466:1: aliased_qid : qid ( ( AS )? ID )? -> ^( ST_ID_AS qid ( ID )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1424, "method_signature": "JpqlParser.aliased_qid_return aliased_qid()"}, "JpqlParser.all_or_any_expression": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.subquery_return.getTree", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.all_or_any_expression", "method_implementation": "{\n    JpqlParser.all_or_any_expression_return retval = new JpqlParser.all_or_any_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ALL486 = null;\n    Token ANY487 = null;\n    Token SOME488 = null;\n    Token Left_Paren489 = null;\n    Token Right_Paren491 = null;\n    JpqlParser.subquery_return subquery490 = null;\n    CommonTree ALL486_tree = null;\n    CommonTree ANY487_tree = null;\n    CommonTree SOME488_tree = null;\n    CommonTree Left_Paren489_tree = null;\n    CommonTree Right_Paren491_tree = null;\n    RewriteRuleTokenStream stream_ANY = new RewriteRuleTokenStream(adaptor, \"token ANY\");\n    RewriteRuleTokenStream stream_SOME = new RewriteRuleTokenStream(adaptor, \"token SOME\");\n    RewriteRuleTokenStream stream_Right_Paren = new RewriteRuleTokenStream(adaptor, \"token Right_Paren\");\n    RewriteRuleTokenStream stream_ALL = new RewriteRuleTokenStream(adaptor, \"token ALL\");\n    RewriteRuleTokenStream stream_Left_Paren = new RewriteRuleTokenStream(adaptor, \"token Left_Paren\");\n    RewriteRuleSubtreeStream stream_subquery = new RewriteRuleSubtreeStream(adaptor, \"rule subquery\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:504:23: ( ( ALL | ANY | SOME ) Left_Paren subquery Right_Paren -> ^( ST_ALL_OR_ANY ( ALL )? ( ANY )? ( SOME )? subquery ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:505:4: ( ALL | ANY | SOME ) Left_Paren subquery Right_Paren\n        {\n            // org/batoo/jpa/jpql/JpqlParser.g:505:4: ( ALL | ANY | SOME )\n            int alt106 = 3;\n            switch(input.LA(1)) {\n                case ALL:\n                    {\n                        alt106 = 1;\n                    }\n                    break;\n                case ANY:\n                    {\n                        alt106 = 2;\n                    }\n                    break;\n                case SOME:\n                    {\n                        alt106 = 3;\n                    }\n                    break;\n                default:\n                    if (state.backtracking > 0) {\n                        state.failed = true;\n                        return retval;\n                    }\n                    NoViableAltException nvae = new NoViableAltException(\"\", 106, 0, input);\n                    throw nvae;\n            }\n            switch(alt106) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:505:5: ALL\n                    {\n                        ALL486 = (Token) match(input, ALL, FOLLOW_ALL_in_all_or_any_expression4258);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ALL.add(ALL486);\n                    }\n                    break;\n                case 2:\n                    // org/batoo/jpa/jpql/JpqlParser.g:505:11: ANY\n                    {\n                        ANY487 = (Token) match(input, ANY, FOLLOW_ANY_in_all_or_any_expression4262);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ANY.add(ANY487);\n                    }\n                    break;\n                case 3:\n                    // org/batoo/jpa/jpql/JpqlParser.g:505:17: SOME\n                    {\n                        SOME488 = (Token) match(input, SOME, FOLLOW_SOME_in_all_or_any_expression4266);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_SOME.add(SOME488);\n                    }\n                    break;\n            }\n            Left_Paren489 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_all_or_any_expression4270);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Left_Paren.add(Left_Paren489);\n            pushFollow(FOLLOW_subquery_in_all_or_any_expression4272);\n            subquery490 = subquery();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_subquery.add(subquery490.getTree());\n            Right_Paren491 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_all_or_any_expression4274);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Right_Paren.add(Right_Paren491);\n            // AST REWRITE\n            // elements: ANY, ALL, SOME, subquery\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 506:5: -> ^( ST_ALL_OR_ANY ( ALL )? ( ANY )? ( SOME )? subquery )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:506:8: ^( ST_ALL_OR_ANY ( ALL )? ( ANY )? ( SOME )? subquery )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ALL_OR_ANY, \"ST_ALL_OR_ANY\"), root_1);\n                        // org/batoo/jpa/jpql/JpqlParser.g:506:24: ( ALL )?\n                        if (stream_ALL.hasNext()) {\n                            adaptor.addChild(root_1, stream_ALL.nextNode());\n                        }\n                        stream_ALL.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:506:31: ( ANY )?\n                        if (stream_ANY.hasNext()) {\n                            adaptor.addChild(root_1, stream_ANY.nextNode());\n                        }\n                        stream_ANY.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:506:38: ( SOME )?\n                        if (stream_SOME.hasNext()) {\n                            adaptor.addChild(root_1, stream_SOME.nextNode());\n                        }\n                        stream_SOME.reset();\n                        adaptor.addChild(root_1, stream_subquery.nextTree());\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:504:1: all_or_any_expression : ( ALL | ANY | SOME ) Left_Paren subquery Right_Paren -> ^( ST_ALL_OR_ANY ( ALL )? ( ANY )? ( SOME )? subquery ) ;\n", "repo_name": "BatooJPA-master/", "id": 1432, "method_signature": "JpqlParser.all_or_any_expression_return all_or_any_expression()"}, "JpqlParser.arithmetic_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.subquery_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.arithmetic_expression", "method_implementation": "{\n    JpqlParser.arithmetic_expression_return retval = new JpqlParser.arithmetic_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Left_Paren332 = null;\n    Token Right_Paren334 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression331 = null;\n    JpqlParser.subquery_return subquery333 = null;\n    CommonTree Left_Paren332_tree = null;\n    CommonTree Right_Paren334_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:347:23: ( simple_arithmetic_expression | Left_Paren ! subquery Right_Paren !)\n        int alt73 = 2;\n        switch(input.LA(1)) {\n            case ABS:\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MOD:\n            case MONTH:\n            case Minus_Sign:\n            case NULLIF:\n            case NUMERIC_LITERAL:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Plus_Sign:\n            case Question_Sign:\n            case SECOND:\n            case SIZE:\n            case SQRT:\n            case SUM:\n            case WEEK:\n            case YEAR:\n                {\n                    alt73 = 1;\n                }\n                break;\n            case Left_Paren:\n                {\n                    switch(input.LA(2)) {\n                        case ABS:\n                        case AVG:\n                        case CASE:\n                        case CAST:\n                        case COALESCE:\n                        case COUNT:\n                        case CURRENT_DATE:\n                        case CURRENT_TIME:\n                        case CURRENT_TIMESTAMP:\n                        case DAY:\n                        case DAYOFMONTH:\n                        case DAYOFWEEK:\n                        case DAYOFYEAR:\n                        case FUNC:\n                        case HOUR:\n                        case ID:\n                        case INDEX:\n                        case LENGTH:\n                        case LOCATE:\n                        case Left_Paren:\n                        case MAX:\n                        case MIN:\n                        case MINUTE:\n                        case MOD:\n                        case MONTH:\n                        case Minus_Sign:\n                        case NULLIF:\n                        case NUMERIC_LITERAL:\n                        case Named_Parameter:\n                        case Ordinal_Parameter:\n                        case Plus_Sign:\n                        case Question_Sign:\n                        case SECOND:\n                        case SIZE:\n                        case SQRT:\n                        case SUM:\n                        case WEEK:\n                        case YEAR:\n                            {\n                                alt73 = 1;\n                            }\n                            break;\n                        case SELECT:\n                            {\n                                alt73 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 73, 2, input);\n                            throw nvae;\n                    }\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 73, 0, input);\n                throw nvae;\n        }\n        switch(alt73) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:348:3: simple_arithmetic_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_arithmetic_expression3161);\n                    simple_arithmetic_expression331 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression331.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:349:5: Left_Paren ! subquery Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Left_Paren332 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_arithmetic_expression3167);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_subquery_in_arithmetic_expression3170);\n                    subquery333 = subquery();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, subquery333.getTree());\n                    Right_Paren334 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_arithmetic_expression3172);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:347:1: arithmetic_expression : ( simple_arithmetic_expression | Left_Paren ! subquery Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1403, "method_signature": "JpqlParser.arithmetic_expression_return arithmetic_expression()"}, "JpqlParser.arithmetic_factor": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_primary_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.arithmetic_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.arithmetic_factor", "method_implementation": "{\n    JpqlParser.arithmetic_factor_return retval = new JpqlParser.arithmetic_factor_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Plus_Sign181 = null;\n    Token Minus_Sign183 = null;\n    JpqlParser.arithmetic_primary_return arithmetic_primary182 = null;\n    JpqlParser.arithmetic_primary_return arithmetic_primary184 = null;\n    CommonTree Plus_Sign181_tree = null;\n    CommonTree Minus_Sign183_tree = null;\n    RewriteRuleTokenStream stream_Minus_Sign = new RewriteRuleTokenStream(adaptor, \"token Minus_Sign\");\n    RewriteRuleSubtreeStream stream_arithmetic_primary = new RewriteRuleSubtreeStream(adaptor, \"rule arithmetic_primary\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:247:19: ( ( Plus_Sign )? arithmetic_primary | Minus_Sign arithmetic_primary -> ^( ST_NEGATION arithmetic_primary ) )\n        int alt44 = 2;\n        switch(input.LA(1)) {\n            case ABS:\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case Left_Paren:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MOD:\n            case MONTH:\n            case NULLIF:\n            case NUMERIC_LITERAL:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Plus_Sign:\n            case Question_Sign:\n            case SECOND:\n            case SIZE:\n            case SQRT:\n            case SUM:\n            case WEEK:\n            case YEAR:\n                {\n                    alt44 = 1;\n                }\n                break;\n            case Minus_Sign:\n                {\n                    alt44 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 44, 0, input);\n                throw nvae;\n        }\n        switch(alt44) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:248:2: ( Plus_Sign )? arithmetic_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    // org/batoo/jpa/jpql/JpqlParser.g:248:2: ( Plus_Sign )?\n                    int alt43 = 2;\n                    switch(input.LA(1)) {\n                        case Plus_Sign:\n                            {\n                                alt43 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt43) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:248:3: Plus_Sign\n                            {\n                                Plus_Sign181 = (Token) match(input, Plus_Sign, FOLLOW_Plus_Sign_in_arithmetic_factor2161);\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0) {\n                                    Plus_Sign181_tree = (CommonTree) adaptor.create(Plus_Sign181);\n                                    adaptor.addChild(root_0, Plus_Sign181_tree);\n                                }\n                            }\n                            break;\n                    }\n                    pushFollow(FOLLOW_arithmetic_primary_in_arithmetic_factor2165);\n                    arithmetic_primary182 = arithmetic_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, arithmetic_primary182.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:249:7: Minus_Sign arithmetic_primary\n                {\n                    Minus_Sign183 = (Token) match(input, Minus_Sign, FOLLOW_Minus_Sign_in_arithmetic_factor2173);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_Minus_Sign.add(Minus_Sign183);\n                    pushFollow(FOLLOW_arithmetic_primary_in_arithmetic_factor2175);\n                    arithmetic_primary184 = arithmetic_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_arithmetic_primary.add(arithmetic_primary184.getTree());\n                    // AST REWRITE\n                    // elements: arithmetic_primary\n                    // token labels:\n                    // rule labels: retval\n                    // token list labels:\n                    // rule list labels:\n                    // wildcard labels:\n                    if (state.backtracking == 0) {\n                        retval.tree = root_0;\n                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                        root_0 = (CommonTree) adaptor.nil();\n                        // 250:6: -> ^( ST_NEGATION arithmetic_primary )\n                        {\n                            // org/batoo/jpa/jpql/JpqlParser.g:250:9: ^( ST_NEGATION arithmetic_primary )\n                            {\n                                CommonTree root_1 = (CommonTree) adaptor.nil();\n                                root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_NEGATION, \"ST_NEGATION\"), root_1);\n                                adaptor.addChild(root_1, stream_arithmetic_primary.nextTree());\n                                adaptor.addChild(root_0, root_1);\n                            }\n                        }\n                        retval.tree = root_0;\n                    }\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:247:1: arithmetic_factor : ( ( Plus_Sign )? arithmetic_primary | Minus_Sign arithmetic_primary -> ^( ST_NEGATION arithmetic_primary ) );\n", "repo_name": "BatooJPA-master/", "id": 1388, "method_signature": "JpqlParser.arithmetic_factor_return arithmetic_factor()"}, "JpqlParser.arithmetic_primary": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.function_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.functions_returning_numerics_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.functions_returning_datetime_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.aggregate_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.case_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.arithmetic_primary", "method_implementation": "{\n    JpqlParser.arithmetic_primary_return retval = new JpqlParser.arithmetic_primary_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token NUMERIC_LITERAL187 = null;\n    Token Left_Paren188 = null;\n    Token Right_Paren190 = null;\n    JpqlParser.function_expression_return function_expression185 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression186 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression189 = null;\n    JpqlParser.input_parameter_return input_parameter191 = null;\n    JpqlParser.functions_returning_numerics_return functions_returning_numerics192 = null;\n    JpqlParser.functions_returning_datetime_return functions_returning_datetime193 = null;\n    JpqlParser.aggregate_expression_return aggregate_expression194 = null;\n    JpqlParser.case_expression_return case_expression195 = null;\n    CommonTree NUMERIC_LITERAL187_tree = null;\n    CommonTree Left_Paren188_tree = null;\n    CommonTree Right_Paren190_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:252:20: ( function_expression | state_field_path_expression | NUMERIC_LITERAL | ( Left_Paren ! simple_arithmetic_expression Right_Paren !) | input_parameter | functions_returning_numerics | functions_returning_datetime | aggregate_expression | case_expression )\n        int alt45 = 9;\n        switch(input.LA(1)) {\n            case FUNC:\n                {\n                    alt45 = 1;\n                }\n                break;\n            case CAST:\n            case ID:\n                {\n                    alt45 = 2;\n                }\n                break;\n            case NUMERIC_LITERAL:\n                {\n                    alt45 = 3;\n                }\n                break;\n            case Left_Paren:\n                {\n                    alt45 = 4;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt45 = 5;\n                }\n                break;\n            case ABS:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case MOD:\n            case SIZE:\n            case SQRT:\n                {\n                    alt45 = 6;\n                }\n                break;\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case HOUR:\n            case MINUTE:\n            case MONTH:\n            case SECOND:\n            case WEEK:\n            case YEAR:\n                {\n                    alt45 = 7;\n                }\n                break;\n            case AVG:\n            case COUNT:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    alt45 = 8;\n                }\n                break;\n            case CASE:\n            case COALESCE:\n            case NULLIF:\n                {\n                    alt45 = 9;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 45, 0, input);\n                throw nvae;\n        }\n        switch(alt45) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:253:2: function_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_function_expression_in_arithmetic_primary2199);\n                    function_expression185 = function_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, function_expression185.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:254:4: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_arithmetic_primary2204);\n                    state_field_path_expression186 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression186.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:255:4: NUMERIC_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    NUMERIC_LITERAL187 = (Token) match(input, NUMERIC_LITERAL, FOLLOW_NUMERIC_LITERAL_in_arithmetic_primary2209);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        NUMERIC_LITERAL187_tree = (CommonTree) adaptor.create(NUMERIC_LITERAL187);\n                        adaptor.addChild(root_0, NUMERIC_LITERAL187_tree);\n                    }\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:256:4: ( Left_Paren ! simple_arithmetic_expression Right_Paren !)\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    // org/batoo/jpa/jpql/JpqlParser.g:256:4: ( Left_Paren ! simple_arithmetic_expression Right_Paren !)\n                    // org/batoo/jpa/jpql/JpqlParser.g:256:5: Left_Paren ! simple_arithmetic_expression Right_Paren !\n                    {\n                        Left_Paren188 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_arithmetic_primary2215);\n                        if (state.failed)\n                            return retval;\n                        pushFollow(FOLLOW_simple_arithmetic_expression_in_arithmetic_primary2218);\n                        simple_arithmetic_expression189 = simple_arithmetic_expression();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, simple_arithmetic_expression189.getTree());\n                        Right_Paren190 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_arithmetic_primary2220);\n                        if (state.failed)\n                            return retval;\n                    }\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:257:4: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_arithmetic_primary2227);\n                    input_parameter191 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter191.getTree());\n                }\n                break;\n            case 6:\n                // org/batoo/jpa/jpql/JpqlParser.g:258:4: functions_returning_numerics\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_functions_returning_numerics_in_arithmetic_primary2232);\n                    functions_returning_numerics192 = functions_returning_numerics();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, functions_returning_numerics192.getTree());\n                }\n                break;\n            case 7:\n                // org/batoo/jpa/jpql/JpqlParser.g:259:4: functions_returning_datetime\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_functions_returning_datetime_in_arithmetic_primary2237);\n                    functions_returning_datetime193 = functions_returning_datetime();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, functions_returning_datetime193.getTree());\n                }\n                break;\n            case 8:\n                // org/batoo/jpa/jpql/JpqlParser.g:260:4: aggregate_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_aggregate_expression_in_arithmetic_primary2242);\n                    aggregate_expression194 = aggregate_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, aggregate_expression194.getTree());\n                }\n                break;\n            case 9:\n                // org/batoo/jpa/jpql/JpqlParser.g:261:4: case_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_case_expression_in_arithmetic_primary2247);\n                    case_expression195 = case_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, case_expression195.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:252:1: arithmetic_primary : ( function_expression | state_field_path_expression | NUMERIC_LITERAL | ( Left_Paren ! simple_arithmetic_expression Right_Paren !) | input_parameter | functions_returning_numerics | functions_returning_datetime | aggregate_expression | case_expression );\n", "repo_name": "BatooJPA-master/", "id": 1389, "method_signature": "JpqlParser.arithmetic_primary_return arithmetic_primary()"}, "JpqlParser.arithmetic_term": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_factor_return.getTree", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_factor_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.arithmetic_term", "method_implementation": "{\n    JpqlParser.arithmetic_term_return retval = new JpqlParser.arithmetic_term_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token set179 = null;\n    JpqlParser.arithmetic_factor_return arithmetic_factor178 = null;\n    JpqlParser.arithmetic_factor_return arithmetic_factor180 = null;\n    CommonTree set179_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:244:17: ( arithmetic_factor ( ( Multiplication_Sign | Division_Sign ) ^ arithmetic_factor )? )\n        // org/batoo/jpa/jpql/JpqlParser.g:245:5: arithmetic_factor ( ( Multiplication_Sign | Division_Sign ) ^ arithmetic_factor )?\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            pushFollow(FOLLOW_arithmetic_factor_in_arithmetic_term2137);\n            arithmetic_factor178 = arithmetic_factor();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, arithmetic_factor178.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:245:23: ( ( Multiplication_Sign | Division_Sign ) ^ arithmetic_factor )?\n            int alt42 = 2;\n            switch(input.LA(1)) {\n                case Division_Sign:\n                case Multiplication_Sign:\n                    {\n                        alt42 = 1;\n                    }\n                    break;\n            }\n            switch(alt42) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:245:24: ( Multiplication_Sign | Division_Sign ) ^ arithmetic_factor\n                    {\n                        set179 = (Token) input.LT(1);\n                        set179 = (Token) input.LT(1);\n                        if (input.LA(1) == Division_Sign || input.LA(1) == Multiplication_Sign) {\n                            input.consume();\n                            if (state.backtracking == 0)\n                                root_0 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(set179), root_0);\n                            state.errorRecovery = false;\n                            state.failed = false;\n                        } else {\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            MismatchedSetException mse = new MismatchedSetException(null, input);\n                            throw mse;\n                        }\n                        pushFollow(FOLLOW_arithmetic_factor_in_arithmetic_term2149);\n                        arithmetic_factor180 = arithmetic_factor();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, arithmetic_factor180.getTree());\n                    }\n                    break;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:244:1: arithmetic_term : arithmetic_factor ( ( Multiplication_Sign | Division_Sign ) ^ arithmetic_factor )? ;\n", "repo_name": "BatooJPA-master/", "id": 1387, "method_signature": "JpqlParser.arithmetic_term_return arithmetic_term()"}, "JpqlParser.between_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.between_expression_argument_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.between_expression_argument_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.between_expression_argument_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.between_expression", "method_implementation": "{\n    JpqlParser.between_expression_return retval = new JpqlParser.between_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token NOT293 = null;\n    Token BETWEEN294 = null;\n    Token AND296 = null;\n    JpqlParser.between_expression_argument_return between_expression_argument292 = null;\n    JpqlParser.between_expression_argument_return between_expression_argument295 = null;\n    JpqlParser.between_expression_argument_return between_expression_argument297 = null;\n    CommonTree NOT293_tree = null;\n    CommonTree BETWEEN294_tree = null;\n    CommonTree AND296_tree = null;\n    RewriteRuleTokenStream stream_NOT = new RewriteRuleTokenStream(adaptor, \"token NOT\");\n    RewriteRuleTokenStream stream_AND = new RewriteRuleTokenStream(adaptor, \"token AND\");\n    RewriteRuleTokenStream stream_BETWEEN = new RewriteRuleTokenStream(adaptor, \"token BETWEEN\");\n    RewriteRuleSubtreeStream stream_between_expression_argument = new RewriteRuleSubtreeStream(adaptor, \"rule between_expression_argument\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:315:48: ( between_expression_argument ( NOT )? BETWEEN between_expression_argument AND between_expression_argument -> ^( BETWEEN between_expression_argument between_expression_argument between_expression_argument ( NOT )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:316:5: between_expression_argument ( NOT )? BETWEEN between_expression_argument AND between_expression_argument\n        {\n            pushFollow(FOLLOW_between_expression_argument_in_between_expression2828);\n            between_expression_argument292 = between_expression_argument();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_between_expression_argument.add(between_expression_argument292.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:316:33: ( NOT )?\n            int alt63 = 2;\n            switch(input.LA(1)) {\n                case NOT:\n                    {\n                        alt63 = 1;\n                    }\n                    break;\n            }\n            switch(alt63) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:316:34: NOT\n                    {\n                        NOT293 = (Token) match(input, NOT, FOLLOW_NOT_in_between_expression2831);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_NOT.add(NOT293);\n                    }\n                    break;\n            }\n            BETWEEN294 = (Token) match(input, BETWEEN, FOLLOW_BETWEEN_in_between_expression2835);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_BETWEEN.add(BETWEEN294);\n            pushFollow(FOLLOW_between_expression_argument_in_between_expression2837);\n            between_expression_argument295 = between_expression_argument();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_between_expression_argument.add(between_expression_argument295.getTree());\n            AND296 = (Token) match(input, AND, FOLLOW_AND_in_between_expression2839);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_AND.add(AND296);\n            pushFollow(FOLLOW_between_expression_argument_in_between_expression2841);\n            between_expression_argument297 = between_expression_argument();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_between_expression_argument.add(between_expression_argument297.getTree());\n            // AST REWRITE\n            // elements: NOT, between_expression_argument, between_expression_argument, BETWEEN, between_expression_argument\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 317:9: -> ^( BETWEEN between_expression_argument between_expression_argument between_expression_argument ( NOT )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:317:12: ^( BETWEEN between_expression_argument between_expression_argument between_expression_argument ( NOT )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot(stream_BETWEEN.nextNode(), root_1);\n                        adaptor.addChild(root_1, stream_between_expression_argument.nextTree());\n                        adaptor.addChild(root_1, stream_between_expression_argument.nextTree());\n                        adaptor.addChild(root_1, stream_between_expression_argument.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:317:106: ( NOT )?\n                        if (stream_NOT.hasNext()) {\n                            adaptor.addChild(root_1, stream_NOT.nextNode());\n                        }\n                        stream_NOT.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:315:1: between_expression options {backtrack=true; } : between_expression_argument ( NOT )? BETWEEN between_expression_argument AND between_expression_argument -> ^( BETWEEN between_expression_argument between_expression_argument between_expression_argument ( NOT )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1398, "method_signature": "JpqlParser.between_expression_return between_expression()"}, "JpqlParser.between_expression_argument": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.string_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.datetime_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.between_expression_argument", "method_implementation": "{\n    JpqlParser.between_expression_argument_return retval = new JpqlParser.between_expression_argument_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.arithmetic_expression_return arithmetic_expression298 = null;\n    JpqlParser.string_expression_return string_expression299 = null;\n    JpqlParser.datetime_expression_return datetime_expression300 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:319:57: ( arithmetic_expression | string_expression | datetime_expression )\n        int alt64 = 3;\n        switch(input.LA(1)) {\n            case ABS:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case MOD:\n            case Minus_Sign:\n            case NUMERIC_LITERAL:\n            case Plus_Sign:\n            case SIZE:\n            case SQRT:\n                {\n                    alt64 = 1;\n                }\n                break;\n            case FUNC:\n                {\n                    int LA64_2 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 2, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case ID:\n                {\n                    int LA64_3 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 3, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CAST:\n                {\n                    int LA64_4 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 4, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Left_Paren:\n                {\n                    int LA64_6 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 6, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Question_Sign:\n                {\n                    int LA64_7 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 7, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Ordinal_Parameter:\n                {\n                    int LA64_8 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 8, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Named_Parameter:\n                {\n                    int LA64_9 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 9, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_DATE:\n                {\n                    int LA64_17 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 17, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIME:\n                {\n                    int LA64_18 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 18, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIMESTAMP:\n                {\n                    int LA64_19 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 19, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case SECOND:\n                {\n                    int LA64_20 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 20, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MINUTE:\n                {\n                    int LA64_21 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 21, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case HOUR:\n                {\n                    int LA64_22 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 22, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAY:\n                {\n                    int LA64_23 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 23, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFMONTH:\n                {\n                    int LA64_24 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 24, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFWEEK:\n                {\n                    int LA64_25 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 25, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFYEAR:\n                {\n                    int LA64_26 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 26, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case WEEK:\n                {\n                    int LA64_27 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 27, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MONTH:\n                {\n                    int LA64_28 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 28, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case YEAR:\n                {\n                    int LA64_29 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 29, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case AVG:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    int LA64_30 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 30, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COUNT:\n                {\n                    int LA64_31 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else if ((true)) {\n                        alt64 = 3;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 31, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CASE:\n                {\n                    int LA64_32 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 32, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COALESCE:\n                {\n                    int LA64_33 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 33, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case NULLIF:\n                {\n                    int LA64_34 = input.LA(2);\n                    if ((synpred21_JpqlParser())) {\n                        alt64 = 1;\n                    } else if ((synpred22_JpqlParser())) {\n                        alt64 = 2;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 64, 34, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CONCAT:\n            case LOWER:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case TRIM:\n            case UPPER:\n                {\n                    alt64 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 64, 0, input);\n                throw nvae;\n        }\n        switch(alt64) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:320:2: arithmetic_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_arithmetic_expression_in_between_expression_argument2884);\n                    arithmetic_expression298 = arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, arithmetic_expression298.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:321:4: string_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_string_expression_in_between_expression_argument2889);\n                    string_expression299 = string_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_expression299.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:322:4: datetime_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_datetime_expression_in_between_expression_argument2894);\n                    datetime_expression300 = datetime_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, datetime_expression300.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:319:1: between_expression_argument options {backtrack=true; } : ( arithmetic_expression | string_expression | datetime_expression );\n", "repo_name": "BatooJPA-master/", "id": 1399, "method_signature": "JpqlParser.between_expression_argument_return between_expression_argument()"}, "JpqlParser.boolean_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.boolean_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.subquery_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.boolean_expression", "method_implementation": "{\n    JpqlParser.boolean_expression_return retval = new JpqlParser.boolean_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Left_Paren399 = null;\n    Token Right_Paren401 = null;\n    JpqlParser.boolean_primary_return boolean_primary398 = null;\n    JpqlParser.subquery_return subquery400 = null;\n    CommonTree Left_Paren399_tree = null;\n    CommonTree Right_Paren401_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:396:20: ( boolean_primary | Left_Paren ! subquery Right_Paren !)\n        int alt79 = 2;\n        switch(input.LA(1)) {\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case FALSE:\n            case FUNC:\n            case ID:\n            case NULLIF:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n            case TRUE:\n                {\n                    alt79 = 1;\n                }\n                break;\n            case Left_Paren:\n                {\n                    alt79 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 79, 0, input);\n                throw nvae;\n        }\n        switch(alt79) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:397:5: boolean_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_boolean_primary_in_boolean_expression3501);\n                    boolean_primary398 = boolean_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, boolean_primary398.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:398:7: Left_Paren ! subquery Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Left_Paren399 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_boolean_expression3509);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_subquery_in_boolean_expression3512);\n                    subquery400 = subquery();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, subquery400.getTree());\n                    Right_Paren401 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_boolean_expression3514);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:396:1: boolean_expression : ( boolean_primary | Left_Paren ! subquery Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1409, "method_signature": "JpqlParser.boolean_expression_return boolean_expression()"}, "JpqlParser.boolean_literal": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.boolean_literal", "method_implementation": "{\n    JpqlParser.boolean_literal_return retval = new JpqlParser.boolean_literal_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token set407 = null;\n    CommonTree set407_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:409:17: ( TRUE | FALSE )\n        // org/batoo/jpa/jpql/JpqlParser.g:\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            set407 = (Token) input.LT(1);\n            if (input.LA(1) == FALSE || input.LA(1) == TRUE) {\n                input.consume();\n                if (state.backtracking == 0)\n                    adaptor.addChild(root_0, (CommonTree) adaptor.create(set407));\n                state.errorRecovery = false;\n                state.failed = false;\n            } else {\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                throw mse;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:409:1: boolean_literal : ( TRUE | FALSE );\n", "repo_name": "BatooJPA-master/", "id": 1411, "method_signature": "JpqlParser.boolean_literal_return boolean_literal()"}, "JpqlParser.boolean_primary": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.function_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.case_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.boolean_literal_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.boolean_primary", "method_implementation": "{\n    JpqlParser.boolean_primary_return retval = new JpqlParser.boolean_primary_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.function_expression_return function_expression402 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression403 = null;\n    JpqlParser.case_expression_return case_expression404 = null;\n    JpqlParser.boolean_literal_return boolean_literal405 = null;\n    JpqlParser.input_parameter_return input_parameter406 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:401:17: ( function_expression | state_field_path_expression | case_expression | boolean_literal | input_parameter )\n        int alt80 = 5;\n        switch(input.LA(1)) {\n            case FUNC:\n                {\n                    alt80 = 1;\n                }\n                break;\n            case CAST:\n            case ID:\n                {\n                    alt80 = 2;\n                }\n                break;\n            case CASE:\n            case COALESCE:\n            case NULLIF:\n                {\n                    alt80 = 3;\n                }\n                break;\n            case FALSE:\n            case TRUE:\n                {\n                    alt80 = 4;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt80 = 5;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 80, 0, input);\n                throw nvae;\n        }\n        switch(alt80) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:402:2: function_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_function_expression_in_boolean_primary3529);\n                    function_expression402 = function_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, function_expression402.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:403:4: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_boolean_primary3534);\n                    state_field_path_expression403 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression403.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:404:4: case_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_case_expression_in_boolean_primary3539);\n                    case_expression404 = case_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, case_expression404.getTree());\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:405:4: boolean_literal\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_boolean_literal_in_boolean_primary3544);\n                    boolean_literal405 = boolean_literal();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, boolean_literal405.getTree());\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:406:4: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_boolean_primary3549);\n                    input_parameter406 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter406.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:401:1: boolean_primary : ( function_expression | state_field_path_expression | case_expression | boolean_literal | input_parameter );\n", "repo_name": "BatooJPA-master/", "id": 1410, "method_signature": "JpqlParser.boolean_primary_return boolean_primary()"}, "JpqlParser.case_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.general_case_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_case_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.coalesce_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.nullif_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.case_expression", "method_implementation": "{\n    JpqlParser.case_expression_return retval = new JpqlParser.case_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.general_case_expression_return general_case_expression124 = null;\n    JpqlParser.simple_case_expression_return simple_case_expression125 = null;\n    JpqlParser.coalesce_expression_return coalesce_expression126 = null;\n    JpqlParser.nullif_expression_return nullif_expression127 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:197:17: ( general_case_expression | simple_case_expression | coalesce_expression | nullif_expression )\n        int alt34 = 4;\n        switch(input.LA(1)) {\n            case CASE:\n                {\n                    switch(input.LA(2)) {\n                        case WHEN:\n                            {\n                                alt34 = 1;\n                            }\n                            break;\n                        case CAST:\n                        case ID:\n                        case TYPE:\n                            {\n                                alt34 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 34, 1, input);\n                            throw nvae;\n                    }\n                }\n                break;\n            case COALESCE:\n                {\n                    alt34 = 3;\n                }\n                break;\n            case NULLIF:\n                {\n                    alt34 = 4;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 34, 0, input);\n                throw nvae;\n        }\n        switch(alt34) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:198:2: general_case_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_general_case_expression_in_case_expression1809);\n                    general_case_expression124 = general_case_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, general_case_expression124.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:199:4: simple_case_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_case_expression_in_case_expression1814);\n                    simple_case_expression125 = simple_case_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_case_expression125.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:200:4: coalesce_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_coalesce_expression_in_case_expression1819);\n                    coalesce_expression126 = coalesce_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, coalesce_expression126.getTree());\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:201:4: nullif_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_nullif_expression_in_case_expression1825);\n                    nullif_expression127 = nullif_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, nullif_expression127.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:197:1: case_expression : ( general_case_expression | simple_case_expression | coalesce_expression | nullif_expression );\n", "repo_name": "BatooJPA-master/", "id": 1376, "method_signature": "JpqlParser.case_expression_return case_expression()"}, "JpqlParser.case_operand": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.type_discriminator_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.case_operand", "method_implementation": "{\n    JpqlParser.case_operand_return retval = new JpqlParser.case_operand_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression143 = null;\n    JpqlParser.type_discriminator_return type_discriminator144 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:214:14: ( state_field_path_expression | type_discriminator )\n        int alt37 = 2;\n        switch(input.LA(1)) {\n            case CAST:\n            case ID:\n                {\n                    alt37 = 1;\n                }\n                break;\n            case TYPE:\n                {\n                    alt37 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 37, 0, input);\n                throw nvae;\n        }\n        switch(alt37) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:215:2: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_case_operand1917);\n                    state_field_path_expression143 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression143.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:215:32: type_discriminator\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_type_discriminator_in_case_operand1921);\n                    type_discriminator144 = type_discriminator();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, type_discriminator144.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:214:1: case_operand : ( state_field_path_expression | type_discriminator );\n", "repo_name": "BatooJPA-master/", "id": 1380, "method_signature": "JpqlParser.case_operand_return case_operand()"}, "JpqlParser.cast_state_field_path_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.simple_state_field_path_expression_return.getTree", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.cast_state_field_path_expression", "method_implementation": "{\n    JpqlParser.cast_state_field_path_expression_return retval = new JpqlParser.cast_state_field_path_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token CAST110 = null;\n    Token Left_Paren111 = null;\n    Token AS113 = null;\n    Token set114 = null;\n    Token Right_Paren115 = null;\n    JpqlParser.simple_state_field_path_expression_return simple_state_field_path_expression112 = null;\n    CommonTree CAST110_tree = null;\n    CommonTree Left_Paren111_tree = null;\n    CommonTree AS113_tree = null;\n    CommonTree set114_tree = null;\n    CommonTree Right_Paren115_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:186:34: ( CAST ^ Left_Paren ! simple_state_field_path_expression AS ! ( BYTE | SHORT | INT | INTEGER | LONG | FLOAT | DOUBLE | STRING | VARCHAR ) Right_Paren !)\n        // org/batoo/jpa/jpql/JpqlParser.g:187:2: CAST ^ Left_Paren ! simple_state_field_path_expression AS ! ( BYTE | SHORT | INT | INTEGER | LONG | FLOAT | DOUBLE | STRING | VARCHAR ) Right_Paren !\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            CAST110 = (Token) match(input, CAST, FOLLOW_CAST_in_cast_state_field_path_expression1664);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                CAST110_tree = (CommonTree) adaptor.create(CAST110);\n                root_0 = (CommonTree) adaptor.becomeRoot(CAST110_tree, root_0);\n            }\n            Left_Paren111 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_cast_state_field_path_expression1667);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_simple_state_field_path_expression_in_cast_state_field_path_expression1670);\n            simple_state_field_path_expression112 = simple_state_field_path_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, simple_state_field_path_expression112.getTree());\n            AS113 = (Token) match(input, AS, FOLLOW_AS_in_cast_state_field_path_expression1672);\n            if (state.failed)\n                return retval;\n            set114 = (Token) input.LT(1);\n            if (input.LA(1) == BYTE || input.LA(1) == DOUBLE || input.LA(1) == FLOAT || (input.LA(1) >= INT && input.LA(1) <= INTEGER) || input.LA(1) == LONG || input.LA(1) == SHORT || input.LA(1) == STRING || input.LA(1) == VARCHAR) {\n                input.consume();\n                if (state.backtracking == 0)\n                    adaptor.addChild(root_0, (CommonTree) adaptor.create(set114));\n                state.errorRecovery = false;\n                state.failed = false;\n            } else {\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                throw mse;\n            }\n            Right_Paren115 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_cast_state_field_path_expression1711);\n            if (state.failed)\n                return retval;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:186:1: cast_state_field_path_expression : CAST ^ Left_Paren ! simple_state_field_path_expression AS ! ( BYTE | SHORT | INT | INTEGER | LONG | FLOAT | DOUBLE | STRING | VARCHAR ) Right_Paren !;\n", "repo_name": "BatooJPA-master/", "id": 1373, "method_signature": "JpqlParser.cast_state_field_path_expression_return cast_state_field_path_expression()"}, "JpqlParser.coalesce_expression": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.scalar_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.scalar_expression_return.getTree", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.coalesce_expression", "method_implementation": "{\n    JpqlParser.coalesce_expression_return retval = new JpqlParser.coalesce_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token COALESCE149 = null;\n    Token Left_Paren150 = null;\n    Token Comma152 = null;\n    Token Right_Paren154 = null;\n    JpqlParser.scalar_expression_return scalar_expression151 = null;\n    JpqlParser.scalar_expression_return scalar_expression153 = null;\n    CommonTree COALESCE149_tree = null;\n    CommonTree Left_Paren150_tree = null;\n    CommonTree Comma152_tree = null;\n    CommonTree Right_Paren154_tree = null;\n    RewriteRuleTokenStream stream_COALESCE = new RewriteRuleTokenStream(adaptor, \"token COALESCE\");\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleTokenStream stream_Right_Paren = new RewriteRuleTokenStream(adaptor, \"token Right_Paren\");\n    RewriteRuleTokenStream stream_Left_Paren = new RewriteRuleTokenStream(adaptor, \"token Left_Paren\");\n    RewriteRuleSubtreeStream stream_scalar_expression = new RewriteRuleSubtreeStream(adaptor, \"rule scalar_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:220:21: ( COALESCE Left_Paren scalar_expression ( Comma scalar_expression )+ Right_Paren -> ^( ST_COALESCE scalar_expression ( scalar_expression )+ ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:221:2: COALESCE Left_Paren scalar_expression ( Comma scalar_expression )+ Right_Paren\n        {\n            COALESCE149 = (Token) match(input, COALESCE, FOLLOW_COALESCE_in_coalesce_expression1948);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_COALESCE.add(COALESCE149);\n            Left_Paren150 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_coalesce_expression1950);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Left_Paren.add(Left_Paren150);\n            pushFollow(FOLLOW_scalar_expression_in_coalesce_expression1952);\n            scalar_expression151 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_scalar_expression.add(scalar_expression151.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:221:40: ( Comma scalar_expression )+\n            int cnt38 = 0;\n            loop38: do {\n                int alt38 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt38 = 1;\n                        }\n                        break;\n                }\n                switch(alt38) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:221:41: Comma scalar_expression\n                        {\n                            Comma152 = (Token) match(input, Comma, FOLLOW_Comma_in_coalesce_expression1955);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma152);\n                            pushFollow(FOLLOW_scalar_expression_in_coalesce_expression1957);\n                            scalar_expression153 = scalar_expression();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_scalar_expression.add(scalar_expression153.getTree());\n                        }\n                        break;\n                    default:\n                        if (cnt38 >= 1)\n                            break loop38;\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        EarlyExitException eee = new EarlyExitException(38, input);\n                        throw eee;\n                }\n                cnt38++;\n            } while (true);\n            Right_Paren154 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_coalesce_expression1961);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Right_Paren.add(Right_Paren154);\n            // AST REWRITE\n            // elements: scalar_expression, scalar_expression\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 222:3: -> ^( ST_COALESCE scalar_expression ( scalar_expression )+ )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:222:6: ^( ST_COALESCE scalar_expression ( scalar_expression )+ )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_COALESCE, \"ST_COALESCE\"), root_1);\n                        adaptor.addChild(root_1, stream_scalar_expression.nextTree());\n                        if (!(stream_scalar_expression.hasNext())) {\n                            throw new RewriteEarlyExitException();\n                        }\n                        while (stream_scalar_expression.hasNext()) {\n                            adaptor.addChild(root_1, stream_scalar_expression.nextTree());\n                        }\n                        stream_scalar_expression.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:220:1: coalesce_expression : COALESCE Left_Paren scalar_expression ( Comma scalar_expression )+ Right_Paren -> ^( ST_COALESCE scalar_expression ( scalar_expression )+ ) ;\n", "repo_name": "BatooJPA-master/", "id": 1382, "method_signature": "JpqlParser.coalesce_expression_return coalesce_expression()"}, "JpqlParser.collection_member_declaration": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.qid_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.collection_member_declaration", "method_implementation": "{\n    JpqlParser.collection_member_declaration_return retval = new JpqlParser.collection_member_declaration_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token IN58 = null;\n    Token Left_Paren59 = null;\n    Token ID60 = null;\n    Token Period61 = null;\n    Token Right_Paren63 = null;\n    Token AS64 = null;\n    Token ID65 = null;\n    JpqlParser.qid_return qid62 = null;\n    CommonTree IN58_tree = null;\n    CommonTree Left_Paren59_tree = null;\n    CommonTree ID60_tree = null;\n    CommonTree Period61_tree = null;\n    CommonTree Right_Paren63_tree = null;\n    CommonTree AS64_tree = null;\n    CommonTree ID65_tree = null;\n    RewriteRuleTokenStream stream_Period = new RewriteRuleTokenStream(adaptor, \"token Period\");\n    RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor, \"token AS\");\n    RewriteRuleTokenStream stream_IN = new RewriteRuleTokenStream(adaptor, \"token IN\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    RewriteRuleTokenStream stream_Right_Paren = new RewriteRuleTokenStream(adaptor, \"token Right_Paren\");\n    RewriteRuleTokenStream stream_Left_Paren = new RewriteRuleTokenStream(adaptor, \"token Left_Paren\");\n    RewriteRuleSubtreeStream stream_qid = new RewriteRuleSubtreeStream(adaptor, \"rule qid\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:119:31: ( IN Left_Paren ID Period qid Right_Paren ( AS )? ( ID )? -> ^( ST_COLL ID ^( ST_ID_AS qid ID ) ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:120:5: IN Left_Paren ID Period qid Right_Paren ( AS )? ( ID )?\n        {\n            IN58 = (Token) match(input, IN, FOLLOW_IN_in_collection_member_declaration782);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_IN.add(IN58);\n            Left_Paren59 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_collection_member_declaration784);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Left_Paren.add(Left_Paren59);\n            ID60 = (Token) match(input, ID, FOLLOW_ID_in_collection_member_declaration786);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ID.add(ID60);\n            Period61 = (Token) match(input, Period, FOLLOW_Period_in_collection_member_declaration788);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Period.add(Period61);\n            pushFollow(FOLLOW_qid_in_collection_member_declaration790);\n            qid62 = qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_qid.add(qid62.getTree());\n            Right_Paren63 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_collection_member_declaration792);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Right_Paren.add(Right_Paren63);\n            // org/batoo/jpa/jpql/JpqlParser.g:120:45: ( AS )?\n            int alt20 = 2;\n            switch(input.LA(1)) {\n                case AS:\n                    {\n                        alt20 = 1;\n                    }\n                    break;\n            }\n            switch(alt20) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:120:45: AS\n                    {\n                        AS64 = (Token) match(input, AS, FOLLOW_AS_in_collection_member_declaration794);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_AS.add(AS64);\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:120:49: ( ID )?\n            int alt21 = 2;\n            switch(input.LA(1)) {\n                case ID:\n                    {\n                        alt21 = 1;\n                    }\n                    break;\n            }\n            switch(alt21) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:120:49: ID\n                    {\n                        ID65 = (Token) match(input, ID, FOLLOW_ID_in_collection_member_declaration797);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ID.add(ID65);\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: ID, qid, ID\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 121:9: -> ^( ST_COLL ID ^( ST_ID_AS qid ID ) )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:121:12: ^( ST_COLL ID ^( ST_ID_AS qid ID ) )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_COLL, \"ST_COLL\"), root_1);\n                        adaptor.addChild(root_1, stream_ID.nextNode());\n                        // org/batoo/jpa/jpql/JpqlParser.g:121:25: ^( ST_ID_AS qid ID )\n                        {\n                            CommonTree root_2 = (CommonTree) adaptor.nil();\n                            root_2 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ID_AS, \"ST_ID_AS\"), root_2);\n                            adaptor.addChild(root_2, stream_qid.nextTree());\n                            adaptor.addChild(root_2, stream_ID.nextNode());\n                            adaptor.addChild(root_1, root_2);\n                        }\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:119:1: collection_member_declaration : IN Left_Paren ID Period qid Right_Paren ( AS )? ( ID )? -> ^( ST_COLL ID ^( ST_ID_AS qid ID ) ) ;\n", "repo_name": "BatooJPA-master/", "id": 1358, "method_signature": "JpqlParser.collection_member_declaration_return collection_member_declaration()"}, "JpqlParser.collection_member_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.entity_or_value_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.collection_member_expression", "method_implementation": "{\n    JpqlParser.collection_member_expression_return retval = new JpqlParser.collection_member_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token NOT472 = null;\n    Token MEMBER473 = null;\n    Token OF474 = null;\n    JpqlParser.entity_or_value_expression_return entity_or_value_expression471 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression475 = null;\n    CommonTree NOT472_tree = null;\n    CommonTree MEMBER473_tree = null;\n    CommonTree OF474_tree = null;\n    RewriteRuleTokenStream stream_MEMBER = new RewriteRuleTokenStream(adaptor, \"token MEMBER\");\n    RewriteRuleTokenStream stream_NOT = new RewriteRuleTokenStream(adaptor, \"token NOT\");\n    RewriteRuleTokenStream stream_OF = new RewriteRuleTokenStream(adaptor, \"token OF\");\n    RewriteRuleSubtreeStream stream_state_field_path_expression = new RewriteRuleSubtreeStream(adaptor, \"rule state_field_path_expression\");\n    RewriteRuleSubtreeStream stream_entity_or_value_expression = new RewriteRuleSubtreeStream(adaptor, \"rule entity_or_value_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:485:30: ( entity_or_value_expression ( NOT )? MEMBER ( OF )? state_field_path_expression -> ^( ST_MEMBER entity_or_value_expression state_field_path_expression ( NOT )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:486:4: entity_or_value_expression ( NOT )? MEMBER ( OF )? state_field_path_expression\n        {\n            pushFollow(FOLLOW_entity_or_value_expression_in_collection_member_expression4151);\n            entity_or_value_expression471 = entity_or_value_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_entity_or_value_expression.add(entity_or_value_expression471.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:486:31: ( NOT )?\n            int alt102 = 2;\n            switch(input.LA(1)) {\n                case NOT:\n                    {\n                        alt102 = 1;\n                    }\n                    break;\n            }\n            switch(alt102) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:486:32: NOT\n                    {\n                        NOT472 = (Token) match(input, NOT, FOLLOW_NOT_in_collection_member_expression4154);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_NOT.add(NOT472);\n                    }\n                    break;\n            }\n            MEMBER473 = (Token) match(input, MEMBER, FOLLOW_MEMBER_in_collection_member_expression4158);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_MEMBER.add(MEMBER473);\n            // org/batoo/jpa/jpql/JpqlParser.g:486:45: ( OF )?\n            int alt103 = 2;\n            switch(input.LA(1)) {\n                case OF:\n                    {\n                        alt103 = 1;\n                    }\n                    break;\n            }\n            switch(alt103) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:486:46: OF\n                    {\n                        OF474 = (Token) match(input, OF, FOLLOW_OF_in_collection_member_expression4161);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_OF.add(OF474);\n                    }\n                    break;\n            }\n            pushFollow(FOLLOW_state_field_path_expression_in_collection_member_expression4165);\n            state_field_path_expression475 = state_field_path_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_state_field_path_expression.add(state_field_path_expression475.getTree());\n            // AST REWRITE\n            // elements: NOT, state_field_path_expression, entity_or_value_expression\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 487:5: -> ^( ST_MEMBER entity_or_value_expression state_field_path_expression ( NOT )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:487:8: ^( ST_MEMBER entity_or_value_expression state_field_path_expression ( NOT )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_MEMBER, \"ST_MEMBER\"), root_1);\n                        adaptor.addChild(root_1, stream_entity_or_value_expression.nextTree());\n                        adaptor.addChild(root_1, stream_state_field_path_expression.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:487:75: ( NOT )?\n                        if (stream_NOT.hasNext()) {\n                            adaptor.addChild(root_1, stream_NOT.nextNode());\n                        }\n                        stream_NOT.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:485:1: collection_member_expression : entity_or_value_expression ( NOT )? MEMBER ( OF )? state_field_path_expression -> ^( ST_MEMBER entity_or_value_expression state_field_path_expression ( NOT )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1428, "method_signature": "JpqlParser.collection_member_expression_return collection_member_expression()"}, "JpqlParser.comparison_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_expression_return.getTree", "CommonTreeAdaptor.becomeRoot", "JpqlParser.comparison_operator_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.all_or_any_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.string_expression_return.getTree", "CommonTreeAdaptor.becomeRoot", "JpqlParser.comparison_operator_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.string_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.all_or_any_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.boolean_expression_return.getTree", "CommonTreeAdaptor.becomeRoot", "JpqlParser.comparison_operator_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.boolean_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.all_or_any_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.enum_expression_return.getTree", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "JpqlParser.enum_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.all_or_any_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.datetime_expression_return.getTree", "CommonTreeAdaptor.becomeRoot", "JpqlParser.comparison_operator_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.datetime_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.all_or_any_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.entity_type_expression_return.getTree", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "JpqlParser.entity_type_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.comparison_expression", "method_implementation": "{\n    JpqlParser.comparison_expression_return retval = new JpqlParser.comparison_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token set320 = null;\n    Token set328 = null;\n    JpqlParser.arithmetic_expression_return arithmetic_expression307 = null;\n    JpqlParser.comparison_operator_return comparison_operator308 = null;\n    JpqlParser.arithmetic_expression_return arithmetic_expression309 = null;\n    JpqlParser.all_or_any_expression_return all_or_any_expression310 = null;\n    JpqlParser.string_expression_return string_expression311 = null;\n    JpqlParser.comparison_operator_return comparison_operator312 = null;\n    JpqlParser.string_expression_return string_expression313 = null;\n    JpqlParser.all_or_any_expression_return all_or_any_expression314 = null;\n    JpqlParser.boolean_expression_return boolean_expression315 = null;\n    JpqlParser.comparison_operator_return comparison_operator316 = null;\n    JpqlParser.boolean_expression_return boolean_expression317 = null;\n    JpqlParser.all_or_any_expression_return all_or_any_expression318 = null;\n    JpqlParser.enum_expression_return enum_expression319 = null;\n    JpqlParser.enum_expression_return enum_expression321 = null;\n    JpqlParser.all_or_any_expression_return all_or_any_expression322 = null;\n    JpqlParser.datetime_expression_return datetime_expression323 = null;\n    JpqlParser.comparison_operator_return comparison_operator324 = null;\n    JpqlParser.datetime_expression_return datetime_expression325 = null;\n    JpqlParser.all_or_any_expression_return all_or_any_expression326 = null;\n    JpqlParser.entity_type_expression_return entity_type_expression327 = null;\n    JpqlParser.entity_type_expression_return entity_type_expression329 = null;\n    CommonTree set320_tree = null;\n    CommonTree set328_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:329:50: ( arithmetic_expression comparison_operator ^ ( arithmetic_expression | all_or_any_expression ) | string_expression comparison_operator ^ ( string_expression | all_or_any_expression ) | boolean_expression comparison_operator ^ ( boolean_expression | all_or_any_expression ) | enum_expression ( Equals_Operator | Not_Equals_Operator ) ^ ( enum_expression | all_or_any_expression ) | datetime_expression comparison_operator ^ ( datetime_expression | all_or_any_expression ) | entity_type_expression ( Equals_Operator | Not_Equals_Operator ) ^ entity_type_expression )\n        int alt72 = 6;\n        switch(input.LA(1)) {\n            case ABS:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case MOD:\n            case Minus_Sign:\n            case NUMERIC_LITERAL:\n            case Plus_Sign:\n            case SIZE:\n            case SQRT:\n                {\n                    alt72 = 1;\n                }\n                break;\n            case FUNC:\n                {\n                    int LA72_2 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 2, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case ID:\n                {\n                    int LA72_3 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else if ((true)) {\n                        alt72 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 3, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CAST:\n                {\n                    int LA72_4 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 4, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Left_Paren:\n                {\n                    int LA72_6 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 6, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Question_Sign:\n                {\n                    int LA72_7 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else if ((true)) {\n                        alt72 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 7, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Ordinal_Parameter:\n                {\n                    int LA72_8 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else if ((true)) {\n                        alt72 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 8, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Named_Parameter:\n                {\n                    int LA72_9 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else if ((true)) {\n                        alt72 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 9, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_DATE:\n                {\n                    int LA72_17 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 17, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIME:\n                {\n                    int LA72_18 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 18, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIMESTAMP:\n                {\n                    int LA72_19 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 19, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case SECOND:\n                {\n                    int LA72_20 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 20, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MINUTE:\n                {\n                    int LA72_21 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 21, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case HOUR:\n                {\n                    int LA72_22 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 22, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAY:\n                {\n                    int LA72_23 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 23, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFMONTH:\n                {\n                    int LA72_24 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 24, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFWEEK:\n                {\n                    int LA72_25 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 25, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFYEAR:\n                {\n                    int LA72_26 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 26, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case WEEK:\n                {\n                    int LA72_27 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 27, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MONTH:\n                {\n                    int LA72_28 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 28, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case YEAR:\n                {\n                    int LA72_29 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 29, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case AVG:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    int LA72_30 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 30, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COUNT:\n                {\n                    int LA72_31 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred27_JpqlParser())) {\n                        alt72 = 5;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 31, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CASE:\n                {\n                    int LA72_32 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 32, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COALESCE:\n                {\n                    int LA72_33 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 33, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case NULLIF:\n                {\n                    int LA72_34 = input.LA(2);\n                    if ((synpred23_JpqlParser())) {\n                        alt72 = 1;\n                    } else if ((synpred24_JpqlParser())) {\n                        alt72 = 2;\n                    } else if ((synpred25_JpqlParser())) {\n                        alt72 = 3;\n                    } else if ((synpred26_JpqlParser())) {\n                        alt72 = 4;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 72, 34, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CONCAT:\n            case LOWER:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case TRIM:\n            case UPPER:\n                {\n                    alt72 = 2;\n                }\n                break;\n            case FALSE:\n            case TRUE:\n                {\n                    alt72 = 3;\n                }\n                break;\n            case TYPE:\n                {\n                    alt72 = 6;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 72, 0, input);\n                throw nvae;\n        }\n        switch(alt72) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:330:5: arithmetic_expression comparison_operator ^ ( arithmetic_expression | all_or_any_expression )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_arithmetic_expression_in_comparison_expression2976);\n                    arithmetic_expression307 = arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, arithmetic_expression307.getTree());\n                    pushFollow(FOLLOW_comparison_operator_in_comparison_expression2978);\n                    comparison_operator308 = comparison_operator();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        root_0 = (CommonTree) adaptor.becomeRoot(comparison_operator308.getTree(), root_0);\n                    // org/batoo/jpa/jpql/JpqlParser.g:330:48: ( arithmetic_expression | all_or_any_expression )\n                    int alt67 = 2;\n                    switch(input.LA(1)) {\n                        case ABS:\n                        case AVG:\n                        case CASE:\n                        case CAST:\n                        case COALESCE:\n                        case COUNT:\n                        case CURRENT_DATE:\n                        case CURRENT_TIME:\n                        case CURRENT_TIMESTAMP:\n                        case DAY:\n                        case DAYOFMONTH:\n                        case DAYOFWEEK:\n                        case DAYOFYEAR:\n                        case FUNC:\n                        case HOUR:\n                        case ID:\n                        case INDEX:\n                        case LENGTH:\n                        case LOCATE:\n                        case Left_Paren:\n                        case MAX:\n                        case MIN:\n                        case MINUTE:\n                        case MOD:\n                        case MONTH:\n                        case Minus_Sign:\n                        case NULLIF:\n                        case NUMERIC_LITERAL:\n                        case Named_Parameter:\n                        case Ordinal_Parameter:\n                        case Plus_Sign:\n                        case Question_Sign:\n                        case SECOND:\n                        case SIZE:\n                        case SQRT:\n                        case SUM:\n                        case WEEK:\n                        case YEAR:\n                            {\n                                alt67 = 1;\n                            }\n                            break;\n                        case ALL:\n                        case ANY:\n                        case SOME:\n                            {\n                                alt67 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 67, 0, input);\n                            throw nvae;\n                    }\n                    switch(alt67) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:330:49: arithmetic_expression\n                            {\n                                pushFollow(FOLLOW_arithmetic_expression_in_comparison_expression2982);\n                                arithmetic_expression309 = arithmetic_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, arithmetic_expression309.getTree());\n                            }\n                            break;\n                        case 2:\n                            // org/batoo/jpa/jpql/JpqlParser.g:330:73: all_or_any_expression\n                            {\n                                pushFollow(FOLLOW_all_or_any_expression_in_comparison_expression2986);\n                                all_or_any_expression310 = all_or_any_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, all_or_any_expression310.getTree());\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:331:7: string_expression comparison_operator ^ ( string_expression | all_or_any_expression )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_string_expression_in_comparison_expression2995);\n                    string_expression311 = string_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_expression311.getTree());\n                    pushFollow(FOLLOW_comparison_operator_in_comparison_expression2997);\n                    comparison_operator312 = comparison_operator();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        root_0 = (CommonTree) adaptor.becomeRoot(comparison_operator312.getTree(), root_0);\n                    // org/batoo/jpa/jpql/JpqlParser.g:331:46: ( string_expression | all_or_any_expression )\n                    int alt68 = 2;\n                    switch(input.LA(1)) {\n                        case AVG:\n                        case CASE:\n                        case CAST:\n                        case COALESCE:\n                        case CONCAT:\n                        case COUNT:\n                        case FUNC:\n                        case ID:\n                        case LOWER:\n                        case Left_Paren:\n                        case MAX:\n                        case MIN:\n                        case NULLIF:\n                        case Named_Parameter:\n                        case Ordinal_Parameter:\n                        case Question_Sign:\n                        case STRING_LITERAL:\n                        case SUBSTRING:\n                        case SUM:\n                        case TRIM:\n                        case UPPER:\n                            {\n                                alt68 = 1;\n                            }\n                            break;\n                        case ALL:\n                        case ANY:\n                        case SOME:\n                            {\n                                alt68 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 68, 0, input);\n                            throw nvae;\n                    }\n                    switch(alt68) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:331:47: string_expression\n                            {\n                                pushFollow(FOLLOW_string_expression_in_comparison_expression3001);\n                                string_expression313 = string_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, string_expression313.getTree());\n                            }\n                            break;\n                        case 2:\n                            // org/batoo/jpa/jpql/JpqlParser.g:331:67: all_or_any_expression\n                            {\n                                pushFollow(FOLLOW_all_or_any_expression_in_comparison_expression3005);\n                                all_or_any_expression314 = all_or_any_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, all_or_any_expression314.getTree());\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:332:7: boolean_expression comparison_operator ^ ( boolean_expression | all_or_any_expression )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_boolean_expression_in_comparison_expression3015);\n                    boolean_expression315 = boolean_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, boolean_expression315.getTree());\n                    pushFollow(FOLLOW_comparison_operator_in_comparison_expression3017);\n                    comparison_operator316 = comparison_operator();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        root_0 = (CommonTree) adaptor.becomeRoot(comparison_operator316.getTree(), root_0);\n                    // org/batoo/jpa/jpql/JpqlParser.g:332:47: ( boolean_expression | all_or_any_expression )\n                    int alt69 = 2;\n                    switch(input.LA(1)) {\n                        case CASE:\n                        case CAST:\n                        case COALESCE:\n                        case FALSE:\n                        case FUNC:\n                        case ID:\n                        case Left_Paren:\n                        case NULLIF:\n                        case Named_Parameter:\n                        case Ordinal_Parameter:\n                        case Question_Sign:\n                        case TRUE:\n                            {\n                                alt69 = 1;\n                            }\n                            break;\n                        case ALL:\n                        case ANY:\n                        case SOME:\n                            {\n                                alt69 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 69, 0, input);\n                            throw nvae;\n                    }\n                    switch(alt69) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:332:48: boolean_expression\n                            {\n                                pushFollow(FOLLOW_boolean_expression_in_comparison_expression3021);\n                                boolean_expression317 = boolean_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, boolean_expression317.getTree());\n                            }\n                            break;\n                        case 2:\n                            // org/batoo/jpa/jpql/JpqlParser.g:332:69: all_or_any_expression\n                            {\n                                pushFollow(FOLLOW_all_or_any_expression_in_comparison_expression3025);\n                                all_or_any_expression318 = all_or_any_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, all_or_any_expression318.getTree());\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:333:7: enum_expression ( Equals_Operator | Not_Equals_Operator ) ^ ( enum_expression | all_or_any_expression )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_enum_expression_in_comparison_expression3034);\n                    enum_expression319 = enum_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, enum_expression319.getTree());\n                    set320 = (Token) input.LT(1);\n                    set320 = (Token) input.LT(1);\n                    if (input.LA(1) == Equals_Operator || input.LA(1) == Not_Equals_Operator) {\n                        input.consume();\n                        if (state.backtracking == 0)\n                            root_0 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(set320), root_0);\n                        state.errorRecovery = false;\n                        state.failed = false;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        MismatchedSetException mse = new MismatchedSetException(null, input);\n                        throw mse;\n                    }\n                    // org/batoo/jpa/jpql/JpqlParser.g:333:64: ( enum_expression | all_or_any_expression )\n                    int alt70 = 2;\n                    switch(input.LA(1)) {\n                        case CASE:\n                        case CAST:\n                        case COALESCE:\n                        case FUNC:\n                        case ID:\n                        case Left_Paren:\n                        case NULLIF:\n                        case Named_Parameter:\n                        case Ordinal_Parameter:\n                        case Question_Sign:\n                            {\n                                alt70 = 1;\n                            }\n                            break;\n                        case ALL:\n                        case ANY:\n                        case SOME:\n                            {\n                                alt70 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 70, 0, input);\n                            throw nvae;\n                    }\n                    switch(alt70) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:333:65: enum_expression\n                            {\n                                pushFollow(FOLLOW_enum_expression_in_comparison_expression3046);\n                                enum_expression321 = enum_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, enum_expression321.getTree());\n                            }\n                            break;\n                        case 2:\n                            // org/batoo/jpa/jpql/JpqlParser.g:333:83: all_or_any_expression\n                            {\n                                pushFollow(FOLLOW_all_or_any_expression_in_comparison_expression3050);\n                                all_or_any_expression322 = all_or_any_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, all_or_any_expression322.getTree());\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:334:7: datetime_expression comparison_operator ^ ( datetime_expression | all_or_any_expression )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_datetime_expression_in_comparison_expression3059);\n                    datetime_expression323 = datetime_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, datetime_expression323.getTree());\n                    pushFollow(FOLLOW_comparison_operator_in_comparison_expression3061);\n                    comparison_operator324 = comparison_operator();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        root_0 = (CommonTree) adaptor.becomeRoot(comparison_operator324.getTree(), root_0);\n                    // org/batoo/jpa/jpql/JpqlParser.g:334:48: ( datetime_expression | all_or_any_expression )\n                    int alt71 = 2;\n                    switch(input.LA(1)) {\n                        case AVG:\n                        case CAST:\n                        case COUNT:\n                        case CURRENT_DATE:\n                        case CURRENT_TIME:\n                        case CURRENT_TIMESTAMP:\n                        case DAY:\n                        case DAYOFMONTH:\n                        case DAYOFWEEK:\n                        case DAYOFYEAR:\n                        case FUNC:\n                        case HOUR:\n                        case ID:\n                        case Left_Paren:\n                        case MAX:\n                        case MIN:\n                        case MINUTE:\n                        case MONTH:\n                        case Named_Parameter:\n                        case Ordinal_Parameter:\n                        case Question_Sign:\n                        case SECOND:\n                        case SUM:\n                        case WEEK:\n                        case YEAR:\n                            {\n                                alt71 = 1;\n                            }\n                            break;\n                        case ALL:\n                        case ANY:\n                        case SOME:\n                            {\n                                alt71 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 71, 0, input);\n                            throw nvae;\n                    }\n                    switch(alt71) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:334:49: datetime_expression\n                            {\n                                pushFollow(FOLLOW_datetime_expression_in_comparison_expression3065);\n                                datetime_expression325 = datetime_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, datetime_expression325.getTree());\n                            }\n                            break;\n                        case 2:\n                            // org/batoo/jpa/jpql/JpqlParser.g:334:71: all_or_any_expression\n                            {\n                                pushFollow(FOLLOW_all_or_any_expression_in_comparison_expression3069);\n                                all_or_any_expression326 = all_or_any_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, all_or_any_expression326.getTree());\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 6:\n                // org/batoo/jpa/jpql/JpqlParser.g:335:7: entity_type_expression ( Equals_Operator | Not_Equals_Operator ) ^ entity_type_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_entity_type_expression_in_comparison_expression3078);\n                    entity_type_expression327 = entity_type_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, entity_type_expression327.getTree());\n                    set328 = (Token) input.LT(1);\n                    set328 = (Token) input.LT(1);\n                    if (input.LA(1) == Equals_Operator || input.LA(1) == Not_Equals_Operator) {\n                        input.consume();\n                        if (state.backtracking == 0)\n                            root_0 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(set328), root_0);\n                        state.errorRecovery = false;\n                        state.failed = false;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        MismatchedSetException mse = new MismatchedSetException(null, input);\n                        throw mse;\n                    }\n                    pushFollow(FOLLOW_entity_type_expression_in_comparison_expression3089);\n                    entity_type_expression329 = entity_type_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, entity_type_expression329.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:329:1: comparison_expression options {backtrack=true; } : ( arithmetic_expression comparison_operator ^ ( arithmetic_expression | all_or_any_expression ) | string_expression comparison_operator ^ ( string_expression | all_or_any_expression ) | boolean_expression comparison_operator ^ ( boolean_expression | all_or_any_expression ) | enum_expression ( Equals_Operator | Not_Equals_Operator ) ^ ( enum_expression | all_or_any_expression ) | datetime_expression comparison_operator ^ ( datetime_expression | all_or_any_expression ) | entity_type_expression ( Equals_Operator | Not_Equals_Operator ) ^ entity_type_expression );\n", "repo_name": "BatooJPA-master/", "id": 1401, "method_signature": "JpqlParser.comparison_expression_return comparison_expression()"}, "JpqlParser.comparison_operator": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.comparison_operator", "method_implementation": "{\n    JpqlParser.comparison_operator_return retval = new JpqlParser.comparison_operator_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token set330 = null;\n    CommonTree set330_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:338:21: ( Equals_Operator | Greater_Than_Operator | Greater_Or_Equals_Operator | Less_Than_Operator | Less_Or_Equals_Operator | Not_Equals_Operator )\n        // org/batoo/jpa/jpql/JpqlParser.g:\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            set330 = (Token) input.LT(1);\n            if (input.LA(1) == Equals_Operator || (input.LA(1) >= Greater_Or_Equals_Operator && input.LA(1) <= Greater_Than_Operator) || (input.LA(1) >= Less_Or_Equals_Operator && input.LA(1) <= Less_Than_Operator) || input.LA(1) == Not_Equals_Operator) {\n                input.consume();\n                if (state.backtracking == 0)\n                    adaptor.addChild(root_0, (CommonTree) adaptor.create(set330));\n                state.errorRecovery = false;\n                state.failed = false;\n            } else {\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                throw mse;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:338:1: comparison_operator : ( Equals_Operator | Greater_Than_Operator | Greater_Or_Equals_Operator | Less_Than_Operator | Less_Or_Equals_Operator | Not_Equals_Operator );\n", "repo_name": "BatooJPA-master/", "id": 1402, "method_signature": "JpqlParser.comparison_operator_return comparison_operator()"}, "JpqlParser.conditional_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.conditional_term_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.conditional_term_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.conditional_expression", "method_implementation": "{\n    JpqlParser.conditional_expression_return retval = new JpqlParser.conditional_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token OR271 = null;\n    JpqlParser.conditional_term_return conditional_term270 = null;\n    JpqlParser.conditional_term_return conditional_term272 = null;\n    CommonTree OR271_tree = null;\n    RewriteRuleTokenStream stream_OR = new RewriteRuleTokenStream(adaptor, \"token OR\");\n    RewriteRuleSubtreeStream stream_conditional_term = new RewriteRuleSubtreeStream(adaptor, \"rule conditional_term\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:286:24: ( conditional_term ( OR conditional_term )* -> ^( LOR conditional_term ( conditional_term )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:287:5: conditional_term ( OR conditional_term )*\n        {\n            pushFollow(FOLLOW_conditional_term_in_conditional_expression2584);\n            conditional_term270 = conditional_term();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_conditional_term.add(conditional_term270.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:287:22: ( OR conditional_term )*\n            loop58: do {\n                int alt58 = 2;\n                switch(input.LA(1)) {\n                    case OR:\n                        {\n                            alt58 = 1;\n                        }\n                        break;\n                }\n                switch(alt58) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:287:23: OR conditional_term\n                        {\n                            OR271 = (Token) match(input, OR, FOLLOW_OR_in_conditional_expression2587);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_OR.add(OR271);\n                            pushFollow(FOLLOW_conditional_term_in_conditional_expression2589);\n                            conditional_term272 = conditional_term();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_conditional_term.add(conditional_term272.getTree());\n                        }\n                        break;\n                    default:\n                        break loop58;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: conditional_term, conditional_term\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 288:9: -> ^( LOR conditional_term ( conditional_term )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:288:12: ^( LOR conditional_term ( conditional_term )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LOR, \"LOR\"), root_1);\n                        adaptor.addChild(root_1, stream_conditional_term.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:288:35: ( conditional_term )*\n                        while (stream_conditional_term.hasNext()) {\n                            adaptor.addChild(root_1, stream_conditional_term.nextTree());\n                        }\n                        stream_conditional_term.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:286:1: conditional_expression : conditional_term ( OR conditional_term )* -> ^( LOR conditional_term ( conditional_term )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1393, "method_signature": "JpqlParser.conditional_expression_return conditional_expression()"}, "JpqlParser.conditional_factor": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.conditional_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.conditional_primary_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.conditional_factor", "method_implementation": "{\n    JpqlParser.conditional_factor_return retval = new JpqlParser.conditional_factor_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token NOT276 = null;\n    JpqlParser.conditional_primary_return conditional_primary277 = null;\n    JpqlParser.conditional_primary_return conditional_primary278 = null;\n    CommonTree NOT276_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:294:20: ( NOT ^ conditional_primary | conditional_primary )\n        int alt60 = 2;\n        switch(input.LA(1)) {\n            case NOT:\n                {\n                    alt60 = 1;\n                }\n                break;\n            case ABS:\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case CONCAT:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case ENTRY:\n            case EXISTS:\n            case FALSE:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case INDEX:\n            case KEY:\n            case LENGTH:\n            case LOCATE:\n            case LOWER:\n            case Left_Paren:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MOD:\n            case MONTH:\n            case Minus_Sign:\n            case NULLIF:\n            case NUMERIC_LITERAL:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Plus_Sign:\n            case Question_Sign:\n            case SECOND:\n            case SIZE:\n            case SQRT:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case SUM:\n            case TRIM:\n            case TRUE:\n            case TYPE:\n            case UPPER:\n            case VALUE:\n            case WEEK:\n            case YEAR:\n                {\n                    alt60 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 60, 0, input);\n                throw nvae;\n        }\n        switch(alt60) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:295:5: NOT ^ conditional_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    NOT276 = (Token) match(input, NOT, FOLLOW_NOT_in_conditional_factor2666);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        NOT276_tree = (CommonTree) adaptor.create(NOT276);\n                        root_0 = (CommonTree) adaptor.becomeRoot(NOT276_tree, root_0);\n                    }\n                    pushFollow(FOLLOW_conditional_primary_in_conditional_factor2669);\n                    conditional_primary277 = conditional_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, conditional_primary277.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:296:7: conditional_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_conditional_primary_in_conditional_factor2678);\n                    conditional_primary278 = conditional_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, conditional_primary278.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:294:1: conditional_factor : ( NOT ^ conditional_primary | conditional_primary );\n", "repo_name": "BatooJPA-master/", "id": 1395, "method_signature": "JpqlParser.conditional_factor_return conditional_factor()"}, "JpqlParser.conditional_primary": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_cond_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.conditional_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.conditional_primary", "method_implementation": "{\n    JpqlParser.conditional_primary_return retval = new JpqlParser.conditional_primary_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Left_Paren280 = null;\n    Token Right_Paren282 = null;\n    JpqlParser.simple_cond_expression_return simple_cond_expression279 = null;\n    JpqlParser.conditional_expression_return conditional_expression281 = null;\n    CommonTree Left_Paren280_tree = null;\n    CommonTree Right_Paren282_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:298:49: ( simple_cond_expression | Left_Paren ! conditional_expression Right_Paren !)\n        int alt61 = 2;\n        switch(input.LA(1)) {\n            case ABS:\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case CONCAT:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case ENTRY:\n            case EXISTS:\n            case FALSE:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case INDEX:\n            case KEY:\n            case LENGTH:\n            case LOCATE:\n            case LOWER:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MOD:\n            case MONTH:\n            case Minus_Sign:\n            case NULLIF:\n            case NUMERIC_LITERAL:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Plus_Sign:\n            case Question_Sign:\n            case SECOND:\n            case SIZE:\n            case SQRT:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case SUM:\n            case TRIM:\n            case TRUE:\n            case TYPE:\n            case UPPER:\n            case VALUE:\n            case WEEK:\n            case YEAR:\n                {\n                    alt61 = 1;\n                }\n                break;\n            case Left_Paren:\n                {\n                    int LA61_14 = input.LA(2);\n                    if ((synpred12_JpqlParser())) {\n                        alt61 = 1;\n                    } else if ((true)) {\n                        alt61 = 2;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 61, 14, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 61, 0, input);\n                throw nvae;\n        }\n        switch(alt61) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:299:5: simple_cond_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_cond_expression_in_conditional_primary2699);\n                    simple_cond_expression279 = simple_cond_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_cond_expression279.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:300:7: Left_Paren ! conditional_expression Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Left_Paren280 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_conditional_primary2707);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_conditional_expression_in_conditional_primary2710);\n                    conditional_expression281 = conditional_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, conditional_expression281.getTree());\n                    Right_Paren282 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_conditional_primary2712);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:298:1: conditional_primary options {backtrack=true; } : ( simple_cond_expression | Left_Paren ! conditional_expression Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1396, "method_signature": "JpqlParser.conditional_primary_return conditional_primary()"}, "JpqlParser.conditional_term": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.conditional_factor_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.conditional_factor_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.conditional_term", "method_implementation": "{\n    JpqlParser.conditional_term_return retval = new JpqlParser.conditional_term_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token AND274 = null;\n    JpqlParser.conditional_factor_return conditional_factor273 = null;\n    JpqlParser.conditional_factor_return conditional_factor275 = null;\n    CommonTree AND274_tree = null;\n    RewriteRuleTokenStream stream_AND = new RewriteRuleTokenStream(adaptor, \"token AND\");\n    RewriteRuleSubtreeStream stream_conditional_factor = new RewriteRuleSubtreeStream(adaptor, \"rule conditional_factor\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:290:18: ( conditional_factor ( AND conditional_factor )* -> ^( LAND conditional_factor ( conditional_factor )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:291:5: conditional_factor ( AND conditional_factor )*\n        {\n            pushFollow(FOLLOW_conditional_factor_in_conditional_term2625);\n            conditional_factor273 = conditional_factor();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_conditional_factor.add(conditional_factor273.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:291:24: ( AND conditional_factor )*\n            loop59: do {\n                int alt59 = 2;\n                switch(input.LA(1)) {\n                    case AND:\n                        {\n                            alt59 = 1;\n                        }\n                        break;\n                }\n                switch(alt59) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:291:25: AND conditional_factor\n                        {\n                            AND274 = (Token) match(input, AND, FOLLOW_AND_in_conditional_term2628);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_AND.add(AND274);\n                            pushFollow(FOLLOW_conditional_factor_in_conditional_term2630);\n                            conditional_factor275 = conditional_factor();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_conditional_factor.add(conditional_factor275.getTree());\n                        }\n                        break;\n                    default:\n                        break loop59;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: conditional_factor, conditional_factor\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 292:9: -> ^( LAND conditional_factor ( conditional_factor )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:292:12: ^( LAND conditional_factor ( conditional_factor )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LAND, \"LAND\"), root_1);\n                        adaptor.addChild(root_1, stream_conditional_factor.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:292:38: ( conditional_factor )*\n                        while (stream_conditional_factor.hasNext()) {\n                            adaptor.addChild(root_1, stream_conditional_factor.nextTree());\n                        }\n                        stream_conditional_factor.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:290:1: conditional_term : conditional_factor ( AND conditional_factor )* -> ^( LAND conditional_factor ( conditional_factor )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1394, "method_signature": "JpqlParser.conditional_term_return conditional_term()"}, "JpqlParser.constructor_expression": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.qid_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.select_expressions_return.getTree", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.constructor_expression", "method_implementation": "{\n    JpqlParser.constructor_expression_return retval = new JpqlParser.constructor_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token NEW116 = null;\n    Token Left_Paren118 = null;\n    Token Right_Paren120 = null;\n    JpqlParser.qid_return qid117 = null;\n    JpqlParser.select_expressions_return select_expressions119 = null;\n    CommonTree NEW116_tree = null;\n    CommonTree Left_Paren118_tree = null;\n    CommonTree Right_Paren120_tree = null;\n    RewriteRuleTokenStream stream_NEW = new RewriteRuleTokenStream(adaptor, \"token NEW\");\n    RewriteRuleTokenStream stream_Right_Paren = new RewriteRuleTokenStream(adaptor, \"token Right_Paren\");\n    RewriteRuleTokenStream stream_Left_Paren = new RewriteRuleTokenStream(adaptor, \"token Left_Paren\");\n    RewriteRuleSubtreeStream stream_select_expressions = new RewriteRuleSubtreeStream(adaptor, \"rule select_expressions\");\n    RewriteRuleSubtreeStream stream_qid = new RewriteRuleSubtreeStream(adaptor, \"rule qid\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:189:24: ( NEW qid Left_Paren select_expressions Right_Paren -> ^( NEW qid select_expressions ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:190:5: NEW qid Left_Paren select_expressions Right_Paren\n        {\n            NEW116 = (Token) match(input, NEW, FOLLOW_NEW_in_constructor_expression1724);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_NEW.add(NEW116);\n            pushFollow(FOLLOW_qid_in_constructor_expression1726);\n            qid117 = qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_qid.add(qid117.getTree());\n            Left_Paren118 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_constructor_expression1728);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Left_Paren.add(Left_Paren118);\n            pushFollow(FOLLOW_select_expressions_in_constructor_expression1730);\n            select_expressions119 = select_expressions();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_select_expressions.add(select_expressions119.getTree());\n            Right_Paren120 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_constructor_expression1732);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Right_Paren.add(Right_Paren120);\n            // AST REWRITE\n            // elements: NEW, select_expressions, qid\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 191:9: -> ^( NEW qid select_expressions )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:191:12: ^( NEW qid select_expressions )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot(stream_NEW.nextNode(), root_1);\n                        adaptor.addChild(root_1, stream_qid.nextTree());\n                        adaptor.addChild(root_1, stream_select_expressions.nextTree());\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:189:1: constructor_expression : NEW qid Left_Paren select_expressions Right_Paren -> ^( NEW qid select_expressions ) ;\n", "repo_name": "BatooJPA-master/", "id": 1374, "method_signature": "JpqlParser.constructor_expression_return constructor_expression()"}, "JpqlParser.datetime_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.datetime_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.subquery_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.datetime_expression", "method_implementation": "{\n    JpqlParser.datetime_expression_return retval = new JpqlParser.datetime_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Left_Paren347 = null;\n    Token Right_Paren349 = null;\n    JpqlParser.datetime_primary_return datetime_primary346 = null;\n    JpqlParser.subquery_return subquery348 = null;\n    CommonTree Left_Paren347_tree = null;\n    CommonTree Right_Paren349_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:367:21: ( datetime_primary | Left_Paren ! subquery Right_Paren !)\n        int alt76 = 2;\n        switch(input.LA(1)) {\n            case AVG:\n            case CAST:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MONTH:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n            case SECOND:\n            case SUM:\n            case WEEK:\n            case YEAR:\n                {\n                    alt76 = 1;\n                }\n                break;\n            case Left_Paren:\n                {\n                    alt76 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 76, 0, input);\n                throw nvae;\n        }\n        switch(alt76) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:368:4: datetime_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_datetime_primary_in_datetime_expression3254);\n                    datetime_primary346 = datetime_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, datetime_primary346.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:369:6: Left_Paren ! subquery Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Left_Paren347 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_datetime_expression3261);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_subquery_in_datetime_expression3264);\n                    subquery348 = subquery();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, subquery348.getTree());\n                    Right_Paren349 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_datetime_expression3266);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:367:1: datetime_expression : ( datetime_primary | Left_Paren ! subquery Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1406, "method_signature": "JpqlParser.datetime_expression_return datetime_expression()"}, "JpqlParser.datetime_primary": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.function_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.functions_returning_datetime_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.aggregate_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.datetime_primary", "method_implementation": "{\n    JpqlParser.datetime_primary_return retval = new JpqlParser.datetime_primary_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.function_expression_return function_expression350 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression351 = null;\n    JpqlParser.input_parameter_return input_parameter352 = null;\n    JpqlParser.functions_returning_datetime_return functions_returning_datetime353 = null;\n    JpqlParser.aggregate_expression_return aggregate_expression354 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:372:18: ( function_expression | state_field_path_expression | input_parameter | functions_returning_datetime | aggregate_expression )\n        int alt77 = 5;\n        switch(input.LA(1)) {\n            case FUNC:\n                {\n                    alt77 = 1;\n                }\n                break;\n            case CAST:\n            case ID:\n                {\n                    alt77 = 2;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt77 = 3;\n                }\n                break;\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case HOUR:\n            case MINUTE:\n            case MONTH:\n            case SECOND:\n            case WEEK:\n            case YEAR:\n                {\n                    alt77 = 4;\n                }\n                break;\n            case AVG:\n            case COUNT:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    alt77 = 5;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 77, 0, input);\n                throw nvae;\n        }\n        switch(alt77) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:373:2: function_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_function_expression_in_datetime_primary3278);\n                    function_expression350 = function_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, function_expression350.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:374:4: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_datetime_primary3283);\n                    state_field_path_expression351 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression351.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:375:4: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_datetime_primary3288);\n                    input_parameter352 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter352.getTree());\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:376:4: functions_returning_datetime\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_functions_returning_datetime_in_datetime_primary3293);\n                    functions_returning_datetime353 = functions_returning_datetime();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, functions_returning_datetime353.getTree());\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:377:4: aggregate_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_aggregate_expression_in_datetime_primary3298);\n                    aggregate_expression354 = aggregate_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, aggregate_expression354.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:372:1: datetime_primary : ( function_expression | state_field_path_expression | input_parameter | functions_returning_datetime | aggregate_expression );\n", "repo_name": "BatooJPA-master/", "id": 1407, "method_signature": "JpqlParser.datetime_primary_return datetime_primary()"}, "JpqlParser.delete_statement": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.aliased_qid_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.where_clause_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.delete_statement", "method_implementation": "{\n    JpqlParser.delete_statement_return retval = new JpqlParser.delete_statement_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token DELETE16 = null;\n    Token FROM17 = null;\n    JpqlParser.aliased_qid_return aliased_qid18 = null;\n    JpqlParser.where_clause_return where_clause19 = null;\n    CommonTree DELETE16_tree = null;\n    CommonTree FROM17_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:82:18: ( DELETE ^ FROM ! aliased_qid ( where_clause )? )\n        // org/batoo/jpa/jpql/JpqlParser.g:83:5: DELETE ^ FROM ! aliased_qid ( where_clause )?\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            DELETE16 = (Token) match(input, DELETE, FOLLOW_DELETE_in_delete_statement426);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                DELETE16_tree = (CommonTree) adaptor.create(DELETE16);\n                root_0 = (CommonTree) adaptor.becomeRoot(DELETE16_tree, root_0);\n            }\n            FROM17 = (Token) match(input, FROM, FOLLOW_FROM_in_delete_statement429);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_aliased_qid_in_delete_statement432);\n            aliased_qid18 = aliased_qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, aliased_qid18.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:83:31: ( where_clause )?\n            int alt4 = 2;\n            switch(input.LA(1)) {\n                case WHERE:\n                    {\n                        alt4 = 1;\n                    }\n                    break;\n            }\n            switch(alt4) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:83:32: where_clause\n                    {\n                        pushFollow(FOLLOW_where_clause_in_delete_statement435);\n                        where_clause19 = where_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, where_clause19.getTree());\n                    }\n                    break;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:82:1: delete_statement : DELETE ^ FROM ! aliased_qid ( where_clause )? ;\n", "repo_name": "BatooJPA-master/", "id": 1349, "method_signature": "JpqlParser.delete_statement_return delete_statement()"}, "JpqlParser.derived_path_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.faliased_qid_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.join_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.derived_path_expression", "method_implementation": "{\n    JpqlParser.derived_path_expression_return retval = new JpqlParser.derived_path_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.faliased_qid_return faliased_qid507 = null;\n    JpqlParser.join_return join508 = null;\n    RewriteRuleSubtreeStream stream_faliased_qid = new RewriteRuleSubtreeStream(adaptor, \"rule faliased_qid\");\n    RewriteRuleSubtreeStream stream_join = new RewriteRuleSubtreeStream(adaptor, \"rule join\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:525:25: ( faliased_qid ( join )* -> ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:526:2: faliased_qid ( join )*\n        {\n            pushFollow(FOLLOW_faliased_qid_in_derived_path_expression4455);\n            faliased_qid507 = faliased_qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_faliased_qid.add(faliased_qid507.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:526:15: ( join )*\n            loop113: do {\n                int alt113 = 2;\n                switch(input.LA(1)) {\n                    case INNER:\n                    case JOIN:\n                    case LEFT:\n                        {\n                            alt113 = 1;\n                        }\n                        break;\n                }\n                switch(alt113) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:526:16: join\n                        {\n                            pushFollow(FOLLOW_join_in_derived_path_expression4458);\n                            join508 = join();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_join.add(join508.getTree());\n                        }\n                        break;\n                    default:\n                        break loop113;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: join, faliased_qid\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 527:2: -> ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:527:5: ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_FROM, \"ST_FROM\"), root_1);\n                        adaptor.addChild(root_1, stream_faliased_qid.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:527:28: ^( LJOINS ( join )* )\n                        {\n                            CommonTree root_2 = (CommonTree) adaptor.nil();\n                            root_2 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LJOINS, \"LJOINS\"), root_2);\n                            // org/batoo/jpa/jpql/JpqlParser.g:527:37: ( join )*\n                            while (stream_join.hasNext()) {\n                                adaptor.addChild(root_2, stream_join.nextTree());\n                            }\n                            stream_join.reset();\n                            adaptor.addChild(root_1, root_2);\n                        }\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:525:1: derived_path_expression : faliased_qid ( join )* -> ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) ) ;\n", "repo_name": "BatooJPA-master/", "id": 1437, "method_signature": "JpqlParser.derived_path_expression_return derived_path_expression()"}, "JpqlParser.empty_collection_comparison_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.state_field_path_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.empty_collection_comparison_expression", "method_implementation": "{\n    JpqlParser.empty_collection_comparison_expression_return retval = new JpqlParser.empty_collection_comparison_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token IS468 = null;\n    Token NOT469 = null;\n    Token EMPTY470 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression467 = null;\n    CommonTree IS468_tree = null;\n    CommonTree NOT469_tree = null;\n    CommonTree EMPTY470_tree = null;\n    RewriteRuleTokenStream stream_NOT = new RewriteRuleTokenStream(adaptor, \"token NOT\");\n    RewriteRuleTokenStream stream_IS = new RewriteRuleTokenStream(adaptor, \"token IS\");\n    RewriteRuleTokenStream stream_EMPTY = new RewriteRuleTokenStream(adaptor, \"token EMPTY\");\n    RewriteRuleSubtreeStream stream_state_field_path_expression = new RewriteRuleSubtreeStream(adaptor, \"rule state_field_path_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:481:40: ( state_field_path_expression IS ( NOT )? EMPTY -> ^( ST_EMPTY state_field_path_expression ( NOT )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:482:4: state_field_path_expression IS ( NOT )? EMPTY\n        {\n            pushFollow(FOLLOW_state_field_path_expression_in_empty_collection_comparison_expression4114);\n            state_field_path_expression467 = state_field_path_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_state_field_path_expression.add(state_field_path_expression467.getTree());\n            IS468 = (Token) match(input, IS, FOLLOW_IS_in_empty_collection_comparison_expression4116);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_IS.add(IS468);\n            // org/batoo/jpa/jpql/JpqlParser.g:482:35: ( NOT )?\n            int alt101 = 2;\n            switch(input.LA(1)) {\n                case NOT:\n                    {\n                        alt101 = 1;\n                    }\n                    break;\n            }\n            switch(alt101) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:482:36: NOT\n                    {\n                        NOT469 = (Token) match(input, NOT, FOLLOW_NOT_in_empty_collection_comparison_expression4119);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_NOT.add(NOT469);\n                    }\n                    break;\n            }\n            EMPTY470 = (Token) match(input, EMPTY, FOLLOW_EMPTY_in_empty_collection_comparison_expression4123);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_EMPTY.add(EMPTY470);\n            // AST REWRITE\n            // elements: NOT, state_field_path_expression\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 483:5: -> ^( ST_EMPTY state_field_path_expression ( NOT )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:483:8: ^( ST_EMPTY state_field_path_expression ( NOT )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_EMPTY, \"ST_EMPTY\"), root_1);\n                        adaptor.addChild(root_1, stream_state_field_path_expression.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:483:47: ( NOT )?\n                        if (stream_NOT.hasNext()) {\n                            adaptor.addChild(root_1, stream_NOT.nextNode());\n                        }\n                        stream_NOT.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:481:1: empty_collection_comparison_expression : state_field_path_expression IS ( NOT )? EMPTY -> ^( ST_EMPTY state_field_path_expression ( NOT )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1427, "method_signature": "JpqlParser.empty_collection_comparison_expression_return empty_collection_comparison_expression()"}, "JpqlParser.entity_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_entity_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.entity_expression", "method_implementation": "{\n    JpqlParser.entity_expression_return retval = new JpqlParser.entity_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression443 = null;\n    JpqlParser.simple_entity_expression_return simple_entity_expression444 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:446:19: ( state_field_path_expression | simple_entity_expression )\n        int alt91 = 2;\n        switch(input.LA(1)) {\n            case ID:\n                {\n                    switch(input.LA(2)) {\n                        case Period:\n                            {\n                                alt91 = 1;\n                            }\n                            break;\n                        case EOF:\n                            {\n                                alt91 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 91, 1, input);\n                            throw nvae;\n                    }\n                }\n                break;\n            case CAST:\n                {\n                    alt91 = 1;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt91 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 91, 0, input);\n                throw nvae;\n        }\n        switch(alt91) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:447:4: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_entity_expression3836);\n                    state_field_path_expression443 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression443.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:448:6: simple_entity_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_entity_expression_in_entity_expression3843);\n                    simple_entity_expression444 = simple_entity_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_entity_expression444.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:446:1: entity_expression : ( state_field_path_expression | simple_entity_expression );\n", "repo_name": "BatooJPA-master/", "id": 1420, "method_signature": "JpqlParser.entity_expression_return entity_expression()"}, "JpqlParser.entity_or_value_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_entity_or_value_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.entity_or_value_expression", "method_implementation": "{\n    JpqlParser.entity_or_value_expression_return retval = new JpqlParser.entity_or_value_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.simple_entity_or_value_expression_return simple_entity_or_value_expression476 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression477 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:489:28: ( simple_entity_or_value_expression | state_field_path_expression )\n        int alt104 = 2;\n        switch(input.LA(1)) {\n            case NUMERIC_LITERAL:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n            case STRING_LITERAL:\n                {\n                    alt104 = 1;\n                }\n                break;\n            case ID:\n                {\n                    switch(input.LA(2)) {\n                        case Period:\n                            {\n                                alt104 = 2;\n                            }\n                            break;\n                        case MEMBER:\n                        case NOT:\n                            {\n                                alt104 = 1;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 104, 2, input);\n                            throw nvae;\n                    }\n                }\n                break;\n            case CAST:\n                {\n                    alt104 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 104, 0, input);\n                throw nvae;\n        }\n        switch(alt104) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:490:2: simple_entity_or_value_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_entity_or_value_expression_in_entity_or_value_expression4193);\n                    simple_entity_or_value_expression476 = simple_entity_or_value_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_entity_or_value_expression476.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:491:4: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_entity_or_value_expression4198);\n                    state_field_path_expression477 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression477.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:489:1: entity_or_value_expression : ( simple_entity_or_value_expression | state_field_path_expression );\n", "repo_name": "BatooJPA-master/", "id": 1429, "method_signature": "JpqlParser.entity_or_value_expression_return entity_or_value_expression()"}, "JpqlParser.entity_type_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.type_discriminator_return.getTree", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.entity_type_expression", "method_implementation": "{\n    JpqlParser.entity_type_expression_return retval = new JpqlParser.entity_type_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID409 = null;\n    JpqlParser.type_discriminator_return type_discriminator408 = null;\n    JpqlParser.input_parameter_return input_parameter410 = null;\n    CommonTree ID409_tree = null;\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:411:24: ( type_discriminator | ID -> ^( ST_ENTITY_TYPE ID ) | input_parameter )\n        int alt81 = 3;\n        switch(input.LA(1)) {\n            case TYPE:\n                {\n                    alt81 = 1;\n                }\n                break;\n            case ID:\n                {\n                    alt81 = 2;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt81 = 3;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 81, 0, input);\n                throw nvae;\n        }\n        switch(alt81) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:412:2: type_discriminator\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_type_discriminator_in_entity_type_expression3572);\n                    type_discriminator408 = type_discriminator();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, type_discriminator408.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:413:4: ID\n                {\n                    ID409 = (Token) match(input, ID, FOLLOW_ID_in_entity_type_expression3577);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_ID.add(ID409);\n                    // AST REWRITE\n                    // elements: ID\n                    // token labels:\n                    // rule labels: retval\n                    // token list labels:\n                    // rule list labels:\n                    // wildcard labels:\n                    if (state.backtracking == 0) {\n                        retval.tree = root_0;\n                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                        root_0 = (CommonTree) adaptor.nil();\n                        // 413:7: -> ^( ST_ENTITY_TYPE ID )\n                        {\n                            // org/batoo/jpa/jpql/JpqlParser.g:413:10: ^( ST_ENTITY_TYPE ID )\n                            {\n                                CommonTree root_1 = (CommonTree) adaptor.nil();\n                                root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ENTITY_TYPE, \"ST_ENTITY_TYPE\"), root_1);\n                                adaptor.addChild(root_1, stream_ID.nextNode());\n                                adaptor.addChild(root_0, root_1);\n                            }\n                        }\n                        retval.tree = root_0;\n                    }\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:414:4: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_entity_type_expression3590);\n                    input_parameter410 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter410.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:411:1: entity_type_expression : ( type_discriminator | ID -> ^( ST_ENTITY_TYPE ID ) | input_parameter );\n", "repo_name": "BatooJPA-master/", "id": 1412, "method_signature": "JpqlParser.entity_type_expression_return entity_type_expression()"}, "JpqlParser.enum_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.enum_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.subquery_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.enum_expression", "method_implementation": "{\n    JpqlParser.enum_expression_return retval = new JpqlParser.enum_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Left_Paren418 = null;\n    Token Right_Paren420 = null;\n    JpqlParser.enum_primary_return enum_primary417 = null;\n    JpqlParser.subquery_return subquery419 = null;\n    CommonTree Left_Paren418_tree = null;\n    CommonTree Right_Paren420_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:420:17: ( enum_primary | Left_Paren ! subquery Right_Paren !)\n        int alt83 = 2;\n        switch(input.LA(1)) {\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case FUNC:\n            case ID:\n            case NULLIF:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt83 = 1;\n                }\n                break;\n            case Left_Paren:\n                {\n                    alt83 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 83, 0, input);\n                throw nvae;\n        }\n        switch(alt83) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:421:4: enum_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_enum_primary_in_enum_expression3632);\n                    enum_primary417 = enum_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, enum_primary417.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:422:6: Left_Paren ! subquery Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Left_Paren418 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_enum_expression3639);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_subquery_in_enum_expression3642);\n                    subquery419 = subquery();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, subquery419.getTree());\n                    Right_Paren420 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_enum_expression3644);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:420:1: enum_expression : ( enum_primary | Left_Paren ! subquery Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1414, "method_signature": "JpqlParser.enum_expression_return enum_expression()"}, "JpqlParser.enum_literal": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.enum_literal", "method_implementation": "{\n    JpqlParser.enum_literal_return retval = new JpqlParser.enum_literal_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID426 = null;\n    CommonTree ID426_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:433:13: ( ID )\n        // org/batoo/jpa/jpql/JpqlParser.g:433:15: ID\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            ID426 = (Token) match(input, ID, FOLLOW_ID_in_enum_literal3699);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                ID426_tree = (CommonTree) adaptor.create(ID426);\n                adaptor.addChild(root_0, ID426_tree);\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:433:1: enum_literal : ID ;\n", "repo_name": "BatooJPA-master/", "id": 1416, "method_signature": "JpqlParser.enum_literal_return enum_literal()"}, "JpqlParser.enum_primary": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.function_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.case_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.enum_literal_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.enum_primary", "method_implementation": "{\n    JpqlParser.enum_primary_return retval = new JpqlParser.enum_primary_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.function_expression_return function_expression421 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression422 = null;\n    JpqlParser.case_expression_return case_expression423 = null;\n    JpqlParser.enum_literal_return enum_literal424 = null;\n    JpqlParser.input_parameter_return input_parameter425 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:425:14: ( function_expression | state_field_path_expression | case_expression | enum_literal | input_parameter )\n        int alt84 = 5;\n        switch(input.LA(1)) {\n            case FUNC:\n                {\n                    alt84 = 1;\n                }\n                break;\n            case ID:\n                {\n                    switch(input.LA(2)) {\n                        case Period:\n                            {\n                                alt84 = 2;\n                            }\n                            break;\n                        case EOF:\n                        case AND:\n                        case AS:\n                        case ASC:\n                        case Comma:\n                        case DESC:\n                        case ELSE:\n                        case END:\n                        case Equals_Operator:\n                        case FROM:\n                        case GROUP:\n                        case HAVING:\n                        case ID:\n                        case Not_Equals_Operator:\n                        case OR:\n                        case ORDER:\n                        case Right_Paren:\n                        case THEN:\n                        case WHEN:\n                            {\n                                alt84 = 4;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 84, 2, input);\n                            throw nvae;\n                    }\n                }\n                break;\n            case CAST:\n                {\n                    alt84 = 2;\n                }\n                break;\n            case CASE:\n            case COALESCE:\n            case NULLIF:\n                {\n                    alt84 = 3;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt84 = 5;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 84, 0, input);\n                throw nvae;\n        }\n        switch(alt84) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:426:4: function_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_function_expression_in_enum_primary3660);\n                    function_expression421 = function_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, function_expression421.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:427:6: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_enum_primary3667);\n                    state_field_path_expression422 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression422.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:428:6: case_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_case_expression_in_enum_primary3674);\n                    case_expression423 = case_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, case_expression423.getTree());\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:429:6: enum_literal\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_enum_literal_in_enum_primary3681);\n                    enum_literal424 = enum_literal();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, enum_literal424.getTree());\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:430:6: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_enum_primary3688);\n                    input_parameter425 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter425.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:425:1: enum_primary : ( function_expression | state_field_path_expression | case_expression | enum_literal | input_parameter );\n", "repo_name": "BatooJPA-master/", "id": 1415, "method_signature": "JpqlParser.enum_primary_return enum_primary()"}, "JpqlParser.exists_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.subquery_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.exists_expression", "method_implementation": "{\n    JpqlParser.exists_expression_return retval = new JpqlParser.exists_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token EXISTS482 = null;\n    Token Left_Paren483 = null;\n    Token Right_Paren485 = null;\n    JpqlParser.subquery_return subquery484 = null;\n    CommonTree EXISTS482_tree = null;\n    CommonTree Left_Paren483_tree = null;\n    CommonTree Right_Paren485_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:501:19: ( EXISTS ^ Left_Paren ! subquery Right_Paren !)\n        // org/batoo/jpa/jpql/JpqlParser.g:502:4: EXISTS ^ Left_Paren ! subquery Right_Paren !\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            EXISTS482 = (Token) match(input, EXISTS, FOLLOW_EXISTS_in_exists_expression4237);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                EXISTS482_tree = (CommonTree) adaptor.create(EXISTS482);\n                root_0 = (CommonTree) adaptor.becomeRoot(EXISTS482_tree, root_0);\n            }\n            Left_Paren483 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_exists_expression4240);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_subquery_in_exists_expression4243);\n            subquery484 = subquery();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, subquery484.getTree());\n            Right_Paren485 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_exists_expression4245);\n            if (state.failed)\n                return retval;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:501:1: exists_expression : EXISTS ^ Left_Paren ! subquery Right_Paren !;\n", "repo_name": "BatooJPA-master/", "id": 1431, "method_signature": "JpqlParser.exists_expression_return exists_expression()"}, "JpqlParser.faliased_qid": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.qid_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.faliased_qid", "method_implementation": "{\n    JpqlParser.faliased_qid_return retval = new JpqlParser.faliased_qid_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token AS451 = null;\n    Token ID452 = null;\n    JpqlParser.qid_return qid450 = null;\n    CommonTree AS451_tree = null;\n    CommonTree ID452_tree = null;\n    RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor, \"token AS\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    RewriteRuleSubtreeStream stream_qid = new RewriteRuleSubtreeStream(adaptor, \"rule qid\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:462:14: ( qid ( AS )? ID -> ^( ST_ID_AS qid ( ID )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:463:5: qid ( AS )? ID\n        {\n            pushFollow(FOLLOW_qid_in_faliased_qid3909);\n            qid450 = qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_qid.add(qid450.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:463:9: ( AS )?\n            int alt94 = 2;\n            switch(input.LA(1)) {\n                case AS:\n                    {\n                        alt94 = 1;\n                    }\n                    break;\n            }\n            switch(alt94) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:463:10: AS\n                    {\n                        AS451 = (Token) match(input, AS, FOLLOW_AS_in_faliased_qid3912);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_AS.add(AS451);\n                    }\n                    break;\n            }\n            ID452 = (Token) match(input, ID, FOLLOW_ID_in_faliased_qid3916);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ID.add(ID452);\n            // AST REWRITE\n            // elements: ID, qid\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 464:9: -> ^( ST_ID_AS qid ( ID )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:464:12: ^( ST_ID_AS qid ( ID )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ID_AS, \"ST_ID_AS\"), root_1);\n                        adaptor.addChild(root_1, stream_qid.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:464:27: ( ID )?\n                        if (stream_ID.hasNext()) {\n                            adaptor.addChild(root_1, stream_ID.nextNode());\n                        }\n                        stream_ID.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:462:1: faliased_qid : qid ( AS )? ID -> ^( ST_ID_AS qid ( ID )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1423, "method_signature": "JpqlParser.faliased_qid_return faliased_qid()"}, "JpqlParser.fetch_all_properties": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.fetch_all_properties", "method_implementation": "{\n    JpqlParser.fetch_all_properties_return retval = new JpqlParser.fetch_all_properties_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token FETCH45 = null;\n    Token ALL46 = null;\n    Token PROPERTIES47 = null;\n    CommonTree FETCH45_tree = null;\n    CommonTree ALL46_tree = null;\n    CommonTree PROPERTIES47_tree = null;\n    RewriteRuleTokenStream stream_FETCH = new RewriteRuleTokenStream(adaptor, \"token FETCH\");\n    RewriteRuleTokenStream stream_PROPERTIES = new RewriteRuleTokenStream(adaptor, \"token PROPERTIES\");\n    RewriteRuleTokenStream stream_ALL = new RewriteRuleTokenStream(adaptor, \"token ALL\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:111:21: ( FETCH ALL PROPERTIES -> LALL_PROPERTIES )\n        // org/batoo/jpa/jpql/JpqlParser.g:112:2: FETCH ALL PROPERTIES\n        {\n            FETCH45 = (Token) match(input, FETCH, FOLLOW_FETCH_in_fetch_all_properties688);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_FETCH.add(FETCH45);\n            ALL46 = (Token) match(input, ALL, FOLLOW_ALL_in_fetch_all_properties690);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ALL.add(ALL46);\n            PROPERTIES47 = (Token) match(input, PROPERTIES, FOLLOW_PROPERTIES_in_fetch_all_properties692);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_PROPERTIES.add(PROPERTIES47);\n            // AST REWRITE\n            // elements:\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 113:3: -> LALL_PROPERTIES\n                {\n                    adaptor.addChild(root_0, (CommonTree) adaptor.create(LALL_PROPERTIES, \"LALL_PROPERTIES\"));\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:111:1: fetch_all_properties : FETCH ALL PROPERTIES -> LALL_PROPERTIES ;\n", "repo_name": "BatooJPA-master/", "id": 1356, "method_signature": "JpqlParser.fetch_all_properties_return fetch_all_properties()"}, "JpqlParser.from_clause": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.from_declaration_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.from_declaration_or_collection_member_declaration_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.from_clause", "method_implementation": "{\n    JpqlParser.from_clause_return retval = new JpqlParser.from_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token FROM36 = null;\n    Token Comma38 = null;\n    JpqlParser.from_declaration_return from_declaration37 = null;\n    JpqlParser.from_declaration_or_collection_member_declaration_return from_declaration_or_collection_member_declaration39 = null;\n    CommonTree FROM36_tree = null;\n    CommonTree Comma38_tree = null;\n    RewriteRuleTokenStream stream_FROM = new RewriteRuleTokenStream(adaptor, \"token FROM\");\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_from_declaration = new RewriteRuleSubtreeStream(adaptor, \"rule from_declaration\");\n    RewriteRuleSubtreeStream stream_from_declaration_or_collection_member_declaration = new RewriteRuleSubtreeStream(adaptor, \"rule from_declaration_or_collection_member_declaration\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:99:13: ( FROM from_declaration ( Comma from_declaration_or_collection_member_declaration )* -> ^( LFROM from_declaration ( from_declaration_or_collection_member_declaration )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:100:5: FROM from_declaration ( Comma from_declaration_or_collection_member_declaration )*\n        {\n            FROM36 = (Token) match(input, FROM, FOLLOW_FROM_in_from_clause574);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_FROM.add(FROM36);\n            pushFollow(FOLLOW_from_declaration_in_from_clause576);\n            from_declaration37 = from_declaration();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_from_declaration.add(from_declaration37.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:100:27: ( Comma from_declaration_or_collection_member_declaration )*\n            loop11: do {\n                int alt11 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt11 = 1;\n                        }\n                        break;\n                }\n                switch(alt11) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:100:28: Comma from_declaration_or_collection_member_declaration\n                        {\n                            Comma38 = (Token) match(input, Comma, FOLLOW_Comma_in_from_clause579);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma38);\n                            pushFollow(FOLLOW_from_declaration_or_collection_member_declaration_in_from_clause581);\n                            from_declaration_or_collection_member_declaration39 = from_declaration_or_collection_member_declaration();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_from_declaration_or_collection_member_declaration.add(from_declaration_or_collection_member_declaration39.getTree());\n                        }\n                        break;\n                    default:\n                        break loop11;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: from_declaration, from_declaration_or_collection_member_declaration\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 101:9: -> ^( LFROM from_declaration ( from_declaration_or_collection_member_declaration )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:101:12: ^( LFROM from_declaration ( from_declaration_or_collection_member_declaration )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LFROM, \"LFROM\"), root_1);\n                        adaptor.addChild(root_1, stream_from_declaration.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:101:37: ( from_declaration_or_collection_member_declaration )*\n                        while (stream_from_declaration_or_collection_member_declaration.hasNext()) {\n                            adaptor.addChild(root_1, stream_from_declaration_or_collection_member_declaration.nextTree());\n                        }\n                        stream_from_declaration_or_collection_member_declaration.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:99:1: from_clause : FROM from_declaration ( Comma from_declaration_or_collection_member_declaration )* -> ^( LFROM from_declaration ( from_declaration_or_collection_member_declaration )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1353, "method_signature": "JpqlParser.from_clause_return from_clause()"}, "JpqlParser.from_declaration": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.faliased_qid_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.fetch_all_properties_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.join_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.from_declaration", "method_implementation": "{\n    JpqlParser.from_declaration_return retval = new JpqlParser.from_declaration_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.faliased_qid_return faliased_qid42 = null;\n    JpqlParser.fetch_all_properties_return fetch_all_properties43 = null;\n    JpqlParser.join_return join44 = null;\n    RewriteRuleSubtreeStream stream_faliased_qid = new RewriteRuleSubtreeStream(adaptor, \"rule faliased_qid\");\n    RewriteRuleSubtreeStream stream_join = new RewriteRuleSubtreeStream(adaptor, \"rule join\");\n    RewriteRuleSubtreeStream stream_fetch_all_properties = new RewriteRuleSubtreeStream(adaptor, \"rule fetch_all_properties\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:107:18: ( faliased_qid ( fetch_all_properties )? ( join )* -> ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) ( fetch_all_properties )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:108:5: faliased_qid ( fetch_all_properties )? ( join )*\n        {\n            pushFollow(FOLLOW_faliased_qid_in_from_declaration636);\n            faliased_qid42 = faliased_qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_faliased_qid.add(faliased_qid42.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:108:18: ( fetch_all_properties )?\n            int alt13 = 2;\n            switch(input.LA(1)) {\n                case FETCH:\n                    {\n                        alt13 = 1;\n                    }\n                    break;\n            }\n            switch(alt13) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:108:18: fetch_all_properties\n                    {\n                        pushFollow(FOLLOW_fetch_all_properties_in_from_declaration638);\n                        fetch_all_properties43 = fetch_all_properties();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_fetch_all_properties.add(fetch_all_properties43.getTree());\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:108:40: ( join )*\n            loop14: do {\n                int alt14 = 2;\n                switch(input.LA(1)) {\n                    case INNER:\n                    case JOIN:\n                    case LEFT:\n                        {\n                            alt14 = 1;\n                        }\n                        break;\n                }\n                switch(alt14) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:108:41: join\n                        {\n                            pushFollow(FOLLOW_join_in_from_declaration642);\n                            join44 = join();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_join.add(join44.getTree());\n                        }\n                        break;\n                    default:\n                        break loop14;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: faliased_qid, fetch_all_properties, join\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 109:9: -> ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) ( fetch_all_properties )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:109:12: ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) ( fetch_all_properties )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_FROM, \"ST_FROM\"), root_1);\n                        adaptor.addChild(root_1, stream_faliased_qid.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:109:35: ^( LJOINS ( join )* )\n                        {\n                            CommonTree root_2 = (CommonTree) adaptor.nil();\n                            root_2 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LJOINS, \"LJOINS\"), root_2);\n                            // org/batoo/jpa/jpql/JpqlParser.g:109:44: ( join )*\n                            while (stream_join.hasNext()) {\n                                adaptor.addChild(root_2, stream_join.nextTree());\n                            }\n                            stream_join.reset();\n                            adaptor.addChild(root_1, root_2);\n                        }\n                        // org/batoo/jpa/jpql/JpqlParser.g:109:53: ( fetch_all_properties )?\n                        if (stream_fetch_all_properties.hasNext()) {\n                            adaptor.addChild(root_1, stream_fetch_all_properties.nextTree());\n                        }\n                        stream_fetch_all_properties.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:107:1: from_declaration : faliased_qid ( fetch_all_properties )? ( join )* -> ^( ST_FROM faliased_qid ^( LJOINS ( join )* ) ( fetch_all_properties )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1355, "method_signature": "JpqlParser.from_declaration_return from_declaration()"}, "JpqlParser.from_declaration_or_collection_member_declaration": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.from_declaration_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.collection_member_declaration_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.from_declaration_or_collection_member_declaration", "method_implementation": "{\n    JpqlParser.from_declaration_or_collection_member_declaration_return retval = new JpqlParser.from_declaration_or_collection_member_declaration_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.from_declaration_return from_declaration40 = null;\n    JpqlParser.collection_member_declaration_return collection_member_declaration41 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:103:51: ( from_declaration | collection_member_declaration )\n        int alt12 = 2;\n        switch(input.LA(1)) {\n            case ID:\n                {\n                    alt12 = 1;\n                }\n                break;\n            case IN:\n                {\n                    alt12 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 12, 0, input);\n                throw nvae;\n        }\n        switch(alt12) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:104:5: from_declaration\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_from_declaration_in_from_declaration_or_collection_member_declaration616);\n                    from_declaration40 = from_declaration();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, from_declaration40.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:105:7: collection_member_declaration\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_collection_member_declaration_in_from_declaration_or_collection_member_declaration624);\n                    collection_member_declaration41 = collection_member_declaration();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, collection_member_declaration41.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:103:1: from_declaration_or_collection_member_declaration : ( from_declaration | collection_member_declaration );\n", "repo_name": "BatooJPA-master/", "id": 1354, "method_signature": "JpqlParser.from_declaration_or_collection_member_declaration_return from_declaration_or_collection_member_declaration()"}, "JpqlParser.function_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.function_expression", "method_implementation": "{\n    JpqlParser.function_expression_return retval = new JpqlParser.function_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token FUNC161 = null;\n    Token Left_Paren162 = null;\n    Token ID163 = null;\n    Token Comma164 = null;\n    Token Right_Paren166 = null;\n    JpqlParser.scalar_expression_return scalar_expression165 = null;\n    CommonTree FUNC161_tree = null;\n    CommonTree Left_Paren162_tree = null;\n    CommonTree ID163_tree = null;\n    CommonTree Comma164_tree = null;\n    CommonTree Right_Paren166_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:227:20: ( FUNC ^ Left_Paren ! ID ( Comma ! scalar_expression )* Right_Paren !)\n        // org/batoo/jpa/jpql/JpqlParser.g:228:2: FUNC ^ Left_Paren ! ID ( Comma ! scalar_expression )* Right_Paren !\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            FUNC161 = (Token) match(input, FUNC, FOLLOW_FUNC_in_function_expression2007);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                FUNC161_tree = (CommonTree) adaptor.create(FUNC161);\n                root_0 = (CommonTree) adaptor.becomeRoot(FUNC161_tree, root_0);\n            }\n            Left_Paren162 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_function_expression2010);\n            if (state.failed)\n                return retval;\n            ID163 = (Token) match(input, ID, FOLLOW_ID_in_function_expression2013);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                ID163_tree = (CommonTree) adaptor.create(ID163);\n                adaptor.addChild(root_0, ID163_tree);\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:228:23: ( Comma ! scalar_expression )*\n            loop39: do {\n                int alt39 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt39 = 1;\n                        }\n                        break;\n                }\n                switch(alt39) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:228:24: Comma ! scalar_expression\n                        {\n                            Comma164 = (Token) match(input, Comma, FOLLOW_Comma_in_function_expression2016);\n                            if (state.failed)\n                                return retval;\n                            pushFollow(FOLLOW_scalar_expression_in_function_expression2019);\n                            scalar_expression165 = scalar_expression();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                adaptor.addChild(root_0, scalar_expression165.getTree());\n                        }\n                        break;\n                    default:\n                        break loop39;\n                }\n            } while (true);\n            Right_Paren166 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_function_expression2023);\n            if (state.failed)\n                return retval;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:227:1: function_expression : FUNC ^ Left_Paren ! ID ( Comma ! scalar_expression )* Right_Paren !;\n", "repo_name": "BatooJPA-master/", "id": 1384, "method_signature": "JpqlParser.function_expression_return function_expression()"}, "JpqlParser.functions_returning_datetime": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.functions_returning_datetime", "method_implementation": "{\n    JpqlParser.functions_returning_datetime_return retval = new JpqlParser.functions_returning_datetime_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token CURRENT_DATE355 = null;\n    Token CURRENT_TIME356 = null;\n    Token CURRENT_TIMESTAMP357 = null;\n    Token SECOND358 = null;\n    Token Left_Paren359 = null;\n    Token Right_Paren361 = null;\n    Token MINUTE362 = null;\n    Token Left_Paren363 = null;\n    Token Right_Paren365 = null;\n    Token HOUR366 = null;\n    Token Left_Paren367 = null;\n    Token Right_Paren369 = null;\n    Token DAY370 = null;\n    Token Left_Paren371 = null;\n    Token Right_Paren373 = null;\n    Token DAYOFMONTH374 = null;\n    Token Left_Paren375 = null;\n    Token Right_Paren377 = null;\n    Token DAYOFWEEK378 = null;\n    Token Left_Paren379 = null;\n    Token Right_Paren381 = null;\n    Token DAYOFYEAR382 = null;\n    Token Left_Paren383 = null;\n    Token Right_Paren385 = null;\n    Token WEEK386 = null;\n    Token Left_Paren387 = null;\n    Token Right_Paren389 = null;\n    Token MONTH390 = null;\n    Token Left_Paren391 = null;\n    Token Right_Paren393 = null;\n    Token YEAR394 = null;\n    Token Left_Paren395 = null;\n    Token Right_Paren397 = null;\n    JpqlParser.string_primary_return string_primary360 = null;\n    JpqlParser.string_primary_return string_primary364 = null;\n    JpqlParser.string_primary_return string_primary368 = null;\n    JpqlParser.string_primary_return string_primary372 = null;\n    JpqlParser.string_primary_return string_primary376 = null;\n    JpqlParser.string_primary_return string_primary380 = null;\n    JpqlParser.string_primary_return string_primary384 = null;\n    JpqlParser.string_primary_return string_primary388 = null;\n    JpqlParser.string_primary_return string_primary392 = null;\n    JpqlParser.string_primary_return string_primary396 = null;\n    CommonTree CURRENT_DATE355_tree = null;\n    CommonTree CURRENT_TIME356_tree = null;\n    CommonTree CURRENT_TIMESTAMP357_tree = null;\n    CommonTree SECOND358_tree = null;\n    CommonTree Left_Paren359_tree = null;\n    CommonTree Right_Paren361_tree = null;\n    CommonTree MINUTE362_tree = null;\n    CommonTree Left_Paren363_tree = null;\n    CommonTree Right_Paren365_tree = null;\n    CommonTree HOUR366_tree = null;\n    CommonTree Left_Paren367_tree = null;\n    CommonTree Right_Paren369_tree = null;\n    CommonTree DAY370_tree = null;\n    CommonTree Left_Paren371_tree = null;\n    CommonTree Right_Paren373_tree = null;\n    CommonTree DAYOFMONTH374_tree = null;\n    CommonTree Left_Paren375_tree = null;\n    CommonTree Right_Paren377_tree = null;\n    CommonTree DAYOFWEEK378_tree = null;\n    CommonTree Left_Paren379_tree = null;\n    CommonTree Right_Paren381_tree = null;\n    CommonTree DAYOFYEAR382_tree = null;\n    CommonTree Left_Paren383_tree = null;\n    CommonTree Right_Paren385_tree = null;\n    CommonTree WEEK386_tree = null;\n    CommonTree Left_Paren387_tree = null;\n    CommonTree Right_Paren389_tree = null;\n    CommonTree MONTH390_tree = null;\n    CommonTree Left_Paren391_tree = null;\n    CommonTree Right_Paren393_tree = null;\n    CommonTree YEAR394_tree = null;\n    CommonTree Left_Paren395_tree = null;\n    CommonTree Right_Paren397_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:380:30: ( CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | SECOND ^ Left_Paren ! string_primary Right_Paren !| MINUTE ^ Left_Paren ! string_primary Right_Paren !| HOUR ^ Left_Paren ! string_primary Right_Paren !| DAY ^ Left_Paren ! string_primary Right_Paren !| DAYOFMONTH ^ Left_Paren ! string_primary Right_Paren !| DAYOFWEEK ^ Left_Paren ! string_primary Right_Paren !| DAYOFYEAR ^ Left_Paren ! string_primary Right_Paren !| WEEK ^ Left_Paren ! string_primary Right_Paren !| MONTH ^ Left_Paren ! string_primary Right_Paren !| YEAR ^ Left_Paren ! string_primary Right_Paren !)\n        int alt78 = 13;\n        switch(input.LA(1)) {\n            case CURRENT_DATE:\n                {\n                    alt78 = 1;\n                }\n                break;\n            case CURRENT_TIME:\n                {\n                    alt78 = 2;\n                }\n                break;\n            case CURRENT_TIMESTAMP:\n                {\n                    alt78 = 3;\n                }\n                break;\n            case SECOND:\n                {\n                    alt78 = 4;\n                }\n                break;\n            case MINUTE:\n                {\n                    alt78 = 5;\n                }\n                break;\n            case HOUR:\n                {\n                    alt78 = 6;\n                }\n                break;\n            case DAY:\n                {\n                    alt78 = 7;\n                }\n                break;\n            case DAYOFMONTH:\n                {\n                    alt78 = 8;\n                }\n                break;\n            case DAYOFWEEK:\n                {\n                    alt78 = 9;\n                }\n                break;\n            case DAYOFYEAR:\n                {\n                    alt78 = 10;\n                }\n                break;\n            case WEEK:\n                {\n                    alt78 = 11;\n                }\n                break;\n            case MONTH:\n                {\n                    alt78 = 12;\n                }\n                break;\n            case YEAR:\n                {\n                    alt78 = 13;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 78, 0, input);\n                throw nvae;\n        }\n        switch(alt78) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:381:4: CURRENT_DATE\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    CURRENT_DATE355 = (Token) match(input, CURRENT_DATE, FOLLOW_CURRENT_DATE_in_functions_returning_datetime3311);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        CURRENT_DATE355_tree = (CommonTree) adaptor.create(CURRENT_DATE355);\n                        adaptor.addChild(root_0, CURRENT_DATE355_tree);\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:382:6: CURRENT_TIME\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    CURRENT_TIME356 = (Token) match(input, CURRENT_TIME, FOLLOW_CURRENT_TIME_in_functions_returning_datetime3318);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        CURRENT_TIME356_tree = (CommonTree) adaptor.create(CURRENT_TIME356);\n                        adaptor.addChild(root_0, CURRENT_TIME356_tree);\n                    }\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:383:6: CURRENT_TIMESTAMP\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    CURRENT_TIMESTAMP357 = (Token) match(input, CURRENT_TIMESTAMP, FOLLOW_CURRENT_TIMESTAMP_in_functions_returning_datetime3325);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        CURRENT_TIMESTAMP357_tree = (CommonTree) adaptor.create(CURRENT_TIMESTAMP357);\n                        adaptor.addChild(root_0, CURRENT_TIMESTAMP357_tree);\n                    }\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:384:6: SECOND ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    SECOND358 = (Token) match(input, SECOND, FOLLOW_SECOND_in_functions_returning_datetime3332);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        SECOND358_tree = (CommonTree) adaptor.create(SECOND358);\n                        root_0 = (CommonTree) adaptor.becomeRoot(SECOND358_tree, root_0);\n                    }\n                    Left_Paren359 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3335);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3338);\n                    string_primary360 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary360.getTree());\n                    Right_Paren361 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3340);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:385:6: MINUTE ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    MINUTE362 = (Token) match(input, MINUTE, FOLLOW_MINUTE_in_functions_returning_datetime3348);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        MINUTE362_tree = (CommonTree) adaptor.create(MINUTE362);\n                        root_0 = (CommonTree) adaptor.becomeRoot(MINUTE362_tree, root_0);\n                    }\n                    Left_Paren363 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3351);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3354);\n                    string_primary364 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary364.getTree());\n                    Right_Paren365 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3356);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 6:\n                // org/batoo/jpa/jpql/JpqlParser.g:386:6: HOUR ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    HOUR366 = (Token) match(input, HOUR, FOLLOW_HOUR_in_functions_returning_datetime3364);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        HOUR366_tree = (CommonTree) adaptor.create(HOUR366);\n                        root_0 = (CommonTree) adaptor.becomeRoot(HOUR366_tree, root_0);\n                    }\n                    Left_Paren367 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3367);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3370);\n                    string_primary368 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary368.getTree());\n                    Right_Paren369 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3372);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 7:\n                // org/batoo/jpa/jpql/JpqlParser.g:387:6: DAY ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    DAY370 = (Token) match(input, DAY, FOLLOW_DAY_in_functions_returning_datetime3380);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        DAY370_tree = (CommonTree) adaptor.create(DAY370);\n                        root_0 = (CommonTree) adaptor.becomeRoot(DAY370_tree, root_0);\n                    }\n                    Left_Paren371 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3383);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3386);\n                    string_primary372 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary372.getTree());\n                    Right_Paren373 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3388);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 8:\n                // org/batoo/jpa/jpql/JpqlParser.g:388:6: DAYOFMONTH ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    DAYOFMONTH374 = (Token) match(input, DAYOFMONTH, FOLLOW_DAYOFMONTH_in_functions_returning_datetime3396);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        DAYOFMONTH374_tree = (CommonTree) adaptor.create(DAYOFMONTH374);\n                        root_0 = (CommonTree) adaptor.becomeRoot(DAYOFMONTH374_tree, root_0);\n                    }\n                    Left_Paren375 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3399);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3402);\n                    string_primary376 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary376.getTree());\n                    Right_Paren377 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3404);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 9:\n                // org/batoo/jpa/jpql/JpqlParser.g:389:6: DAYOFWEEK ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    DAYOFWEEK378 = (Token) match(input, DAYOFWEEK, FOLLOW_DAYOFWEEK_in_functions_returning_datetime3412);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        DAYOFWEEK378_tree = (CommonTree) adaptor.create(DAYOFWEEK378);\n                        root_0 = (CommonTree) adaptor.becomeRoot(DAYOFWEEK378_tree, root_0);\n                    }\n                    Left_Paren379 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3415);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3418);\n                    string_primary380 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary380.getTree());\n                    Right_Paren381 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3420);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 10:\n                // org/batoo/jpa/jpql/JpqlParser.g:390:6: DAYOFYEAR ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    DAYOFYEAR382 = (Token) match(input, DAYOFYEAR, FOLLOW_DAYOFYEAR_in_functions_returning_datetime3428);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        DAYOFYEAR382_tree = (CommonTree) adaptor.create(DAYOFYEAR382);\n                        root_0 = (CommonTree) adaptor.becomeRoot(DAYOFYEAR382_tree, root_0);\n                    }\n                    Left_Paren383 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3431);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3434);\n                    string_primary384 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary384.getTree());\n                    Right_Paren385 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3436);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 11:\n                // org/batoo/jpa/jpql/JpqlParser.g:391:6: WEEK ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    WEEK386 = (Token) match(input, WEEK, FOLLOW_WEEK_in_functions_returning_datetime3444);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        WEEK386_tree = (CommonTree) adaptor.create(WEEK386);\n                        root_0 = (CommonTree) adaptor.becomeRoot(WEEK386_tree, root_0);\n                    }\n                    Left_Paren387 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3447);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3450);\n                    string_primary388 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary388.getTree());\n                    Right_Paren389 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3452);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 12:\n                // org/batoo/jpa/jpql/JpqlParser.g:392:6: MONTH ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    MONTH390 = (Token) match(input, MONTH, FOLLOW_MONTH_in_functions_returning_datetime3460);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        MONTH390_tree = (CommonTree) adaptor.create(MONTH390);\n                        root_0 = (CommonTree) adaptor.becomeRoot(MONTH390_tree, root_0);\n                    }\n                    Left_Paren391 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3463);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3466);\n                    string_primary392 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary392.getTree());\n                    Right_Paren393 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3468);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 13:\n                // org/batoo/jpa/jpql/JpqlParser.g:393:6: YEAR ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    YEAR394 = (Token) match(input, YEAR, FOLLOW_YEAR_in_functions_returning_datetime3476);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        YEAR394_tree = (CommonTree) adaptor.create(YEAR394);\n                        root_0 = (CommonTree) adaptor.becomeRoot(YEAR394_tree, root_0);\n                    }\n                    Left_Paren395 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_datetime3479);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_datetime3482);\n                    string_primary396 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary396.getTree());\n                    Right_Paren397 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_datetime3484);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:380:1: functions_returning_datetime : ( CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | SECOND ^ Left_Paren ! string_primary Right_Paren !| MINUTE ^ Left_Paren ! string_primary Right_Paren !| HOUR ^ Left_Paren ! string_primary Right_Paren !| DAY ^ Left_Paren ! string_primary Right_Paren !| DAYOFMONTH ^ Left_Paren ! string_primary Right_Paren !| DAYOFWEEK ^ Left_Paren ! string_primary Right_Paren !| DAYOFYEAR ^ Left_Paren ! string_primary Right_Paren !| WEEK ^ Left_Paren ! string_primary Right_Paren !| MONTH ^ Left_Paren ! string_primary Right_Paren !| YEAR ^ Left_Paren ! string_primary Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1408, "method_signature": "JpqlParser.functions_returning_datetime_return functions_returning_datetime()"}, "JpqlParser.functions_returning_numerics": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.functions_returning_numerics", "method_implementation": "{\n    JpqlParser.functions_returning_numerics_return retval = new JpqlParser.functions_returning_numerics_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token LENGTH207 = null;\n    Token Left_Paren208 = null;\n    Token Right_Paren210 = null;\n    Token LOCATE211 = null;\n    Token Left_Paren212 = null;\n    Token Comma214 = null;\n    Token Comma216 = null;\n    Token Right_Paren218 = null;\n    Token ABS219 = null;\n    Token Left_Paren220 = null;\n    Token Right_Paren222 = null;\n    Token SQRT223 = null;\n    Token Left_Paren224 = null;\n    Token Right_Paren226 = null;\n    Token MOD227 = null;\n    Token Left_Paren228 = null;\n    Token Comma230 = null;\n    Token Right_Paren232 = null;\n    Token SIZE233 = null;\n    Token Left_Paren234 = null;\n    Token Right_Paren236 = null;\n    Token INDEX237 = null;\n    Token Left_Paren238 = null;\n    Token ID239 = null;\n    Token Right_Paren240 = null;\n    JpqlParser.string_primary_return string_primary209 = null;\n    JpqlParser.string_primary_return string_primary213 = null;\n    JpqlParser.string_primary_return string_primary215 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression217 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression221 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression225 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression229 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression231 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression235 = null;\n    CommonTree LENGTH207_tree = null;\n    CommonTree Left_Paren208_tree = null;\n    CommonTree Right_Paren210_tree = null;\n    CommonTree LOCATE211_tree = null;\n    CommonTree Left_Paren212_tree = null;\n    CommonTree Comma214_tree = null;\n    CommonTree Comma216_tree = null;\n    CommonTree Right_Paren218_tree = null;\n    CommonTree ABS219_tree = null;\n    CommonTree Left_Paren220_tree = null;\n    CommonTree Right_Paren222_tree = null;\n    CommonTree SQRT223_tree = null;\n    CommonTree Left_Paren224_tree = null;\n    CommonTree Right_Paren226_tree = null;\n    CommonTree MOD227_tree = null;\n    CommonTree Left_Paren228_tree = null;\n    CommonTree Comma230_tree = null;\n    CommonTree Right_Paren232_tree = null;\n    CommonTree SIZE233_tree = null;\n    CommonTree Left_Paren234_tree = null;\n    CommonTree Right_Paren236_tree = null;\n    CommonTree INDEX237_tree = null;\n    CommonTree Left_Paren238_tree = null;\n    CommonTree ID239_tree = null;\n    CommonTree Right_Paren240_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:268:30: ( LENGTH ^ Left_Paren ! string_primary Right_Paren !| LOCATE ^ Left_Paren ! string_primary Comma ! string_primary ( Comma ! simple_arithmetic_expression )? Right_Paren !| ABS ^ Left_Paren ! simple_arithmetic_expression Right_Paren !| SQRT ^ Left_Paren ! simple_arithmetic_expression Right_Paren !| MOD ^ Left_Paren ! simple_arithmetic_expression Comma ! simple_arithmetic_expression Right_Paren !| SIZE ^ Left_Paren ! state_field_path_expression Right_Paren !| INDEX ^ Left_Paren ! ID Right_Paren !)\n        int alt51 = 7;\n        switch(input.LA(1)) {\n            case LENGTH:\n                {\n                    alt51 = 1;\n                }\n                break;\n            case LOCATE:\n                {\n                    alt51 = 2;\n                }\n                break;\n            case ABS:\n                {\n                    alt51 = 3;\n                }\n                break;\n            case SQRT:\n                {\n                    alt51 = 4;\n                }\n                break;\n            case MOD:\n                {\n                    alt51 = 5;\n                }\n                break;\n            case SIZE:\n                {\n                    alt51 = 6;\n                }\n                break;\n            case INDEX:\n                {\n                    alt51 = 7;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 51, 0, input);\n                throw nvae;\n        }\n        switch(alt51) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:269:4: LENGTH ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    LENGTH207 = (Token) match(input, LENGTH, FOLLOW_LENGTH_in_functions_returning_numerics2322);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        LENGTH207_tree = (CommonTree) adaptor.create(LENGTH207);\n                        root_0 = (CommonTree) adaptor.becomeRoot(LENGTH207_tree, root_0);\n                    }\n                    Left_Paren208 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_numerics2325);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_numerics2328);\n                    string_primary209 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary209.getTree());\n                    Right_Paren210 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_numerics2330);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:270:6: LOCATE ^ Left_Paren ! string_primary Comma ! string_primary ( Comma ! simple_arithmetic_expression )? Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    LOCATE211 = (Token) match(input, LOCATE, FOLLOW_LOCATE_in_functions_returning_numerics2338);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        LOCATE211_tree = (CommonTree) adaptor.create(LOCATE211);\n                        root_0 = (CommonTree) adaptor.becomeRoot(LOCATE211_tree, root_0);\n                    }\n                    Left_Paren212 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_numerics2341);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_numerics2344);\n                    string_primary213 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary213.getTree());\n                    Comma214 = (Token) match(input, Comma, FOLLOW_Comma_in_functions_returning_numerics2346);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_numerics2349);\n                    string_primary215 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary215.getTree());\n                    // org/batoo/jpa/jpql/JpqlParser.g:270:63: ( Comma ! simple_arithmetic_expression )?\n                    int alt50 = 2;\n                    switch(input.LA(1)) {\n                        case Comma:\n                            {\n                                alt50 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt50) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:270:64: Comma ! simple_arithmetic_expression\n                            {\n                                Comma216 = (Token) match(input, Comma, FOLLOW_Comma_in_functions_returning_numerics2352);\n                                if (state.failed)\n                                    return retval;\n                                pushFollow(FOLLOW_simple_arithmetic_expression_in_functions_returning_numerics2355);\n                                simple_arithmetic_expression217 = simple_arithmetic_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, simple_arithmetic_expression217.getTree());\n                            }\n                            break;\n                    }\n                    Right_Paren218 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_numerics2359);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:271:6: ABS ^ Left_Paren ! simple_arithmetic_expression Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    ABS219 = (Token) match(input, ABS, FOLLOW_ABS_in_functions_returning_numerics2367);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        ABS219_tree = (CommonTree) adaptor.create(ABS219);\n                        root_0 = (CommonTree) adaptor.becomeRoot(ABS219_tree, root_0);\n                    }\n                    Left_Paren220 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_numerics2370);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_functions_returning_numerics2373);\n                    simple_arithmetic_expression221 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression221.getTree());\n                    Right_Paren222 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_numerics2375);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:272:6: SQRT ^ Left_Paren ! simple_arithmetic_expression Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    SQRT223 = (Token) match(input, SQRT, FOLLOW_SQRT_in_functions_returning_numerics2383);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        SQRT223_tree = (CommonTree) adaptor.create(SQRT223);\n                        root_0 = (CommonTree) adaptor.becomeRoot(SQRT223_tree, root_0);\n                    }\n                    Left_Paren224 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_numerics2386);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_functions_returning_numerics2389);\n                    simple_arithmetic_expression225 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression225.getTree());\n                    Right_Paren226 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_numerics2391);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:273:6: MOD ^ Left_Paren ! simple_arithmetic_expression Comma ! simple_arithmetic_expression Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    MOD227 = (Token) match(input, MOD, FOLLOW_MOD_in_functions_returning_numerics2399);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        MOD227_tree = (CommonTree) adaptor.create(MOD227);\n                        root_0 = (CommonTree) adaptor.becomeRoot(MOD227_tree, root_0);\n                    }\n                    Left_Paren228 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_numerics2402);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_functions_returning_numerics2405);\n                    simple_arithmetic_expression229 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression229.getTree());\n                    Comma230 = (Token) match(input, Comma, FOLLOW_Comma_in_functions_returning_numerics2407);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_functions_returning_numerics2410);\n                    simple_arithmetic_expression231 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression231.getTree());\n                    Right_Paren232 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_numerics2412);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 6:\n                // org/batoo/jpa/jpql/JpqlParser.g:274:6: SIZE ^ Left_Paren ! state_field_path_expression Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    SIZE233 = (Token) match(input, SIZE, FOLLOW_SIZE_in_functions_returning_numerics2420);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        SIZE233_tree = (CommonTree) adaptor.create(SIZE233);\n                        root_0 = (CommonTree) adaptor.becomeRoot(SIZE233_tree, root_0);\n                    }\n                    Left_Paren234 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_numerics2423);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_state_field_path_expression_in_functions_returning_numerics2426);\n                    state_field_path_expression235 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression235.getTree());\n                    Right_Paren236 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_numerics2428);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 7:\n                // org/batoo/jpa/jpql/JpqlParser.g:275:6: INDEX ^ Left_Paren ! ID Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    INDEX237 = (Token) match(input, INDEX, FOLLOW_INDEX_in_functions_returning_numerics2436);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        INDEX237_tree = (CommonTree) adaptor.create(INDEX237);\n                        root_0 = (CommonTree) adaptor.becomeRoot(INDEX237_tree, root_0);\n                    }\n                    Left_Paren238 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_numerics2439);\n                    if (state.failed)\n                        return retval;\n                    ID239 = (Token) match(input, ID, FOLLOW_ID_in_functions_returning_numerics2442);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        ID239_tree = (CommonTree) adaptor.create(ID239);\n                        adaptor.addChild(root_0, ID239_tree);\n                    }\n                    Right_Paren240 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_numerics2444);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:268:1: functions_returning_numerics : ( LENGTH ^ Left_Paren ! string_primary Right_Paren !| LOCATE ^ Left_Paren ! string_primary Comma ! string_primary ( Comma ! simple_arithmetic_expression )? Right_Paren !| ABS ^ Left_Paren ! simple_arithmetic_expression Right_Paren !| SQRT ^ Left_Paren ! simple_arithmetic_expression Right_Paren !| MOD ^ Left_Paren ! simple_arithmetic_expression Comma ! simple_arithmetic_expression Right_Paren !| SIZE ^ Left_Paren ! state_field_path_expression Right_Paren !| INDEX ^ Left_Paren ! ID Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1391, "method_signature": "JpqlParser.functions_returning_numerics_return functions_returning_numerics()"}, "JpqlParser.functions_returning_strings": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.functions_returning_strings", "method_implementation": "{\n    JpqlParser.functions_returning_strings_return retval = new JpqlParser.functions_returning_strings_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token SUBSTRING241 = null;\n    Token Left_Paren242 = null;\n    Token Comma244 = null;\n    Token Comma246 = null;\n    Token Right_Paren248 = null;\n    Token CONCAT249 = null;\n    Token Left_Paren250 = null;\n    Token Comma252 = null;\n    Token Right_Paren254 = null;\n    Token TRIM255 = null;\n    Token Left_Paren256 = null;\n    Token set257 = null;\n    Token STRING_LITERAL258 = null;\n    Token FROM259 = null;\n    Token Right_Paren261 = null;\n    Token LOWER262 = null;\n    Token Left_Paren263 = null;\n    Token Right_Paren265 = null;\n    Token UPPER266 = null;\n    Token Left_Paren267 = null;\n    Token Right_Paren269 = null;\n    JpqlParser.string_primary_return string_primary243 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression245 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression247 = null;\n    JpqlParser.string_primary_return string_primary251 = null;\n    JpqlParser.string_primary_return string_primary253 = null;\n    JpqlParser.string_primary_return string_primary260 = null;\n    JpqlParser.string_primary_return string_primary264 = null;\n    JpqlParser.string_primary_return string_primary268 = null;\n    CommonTree SUBSTRING241_tree = null;\n    CommonTree Left_Paren242_tree = null;\n    CommonTree Comma244_tree = null;\n    CommonTree Comma246_tree = null;\n    CommonTree Right_Paren248_tree = null;\n    CommonTree CONCAT249_tree = null;\n    CommonTree Left_Paren250_tree = null;\n    CommonTree Comma252_tree = null;\n    CommonTree Right_Paren254_tree = null;\n    CommonTree TRIM255_tree = null;\n    CommonTree Left_Paren256_tree = null;\n    CommonTree set257_tree = null;\n    CommonTree STRING_LITERAL258_tree = null;\n    CommonTree FROM259_tree = null;\n    CommonTree Right_Paren261_tree = null;\n    CommonTree LOWER262_tree = null;\n    CommonTree Left_Paren263_tree = null;\n    CommonTree Right_Paren265_tree = null;\n    CommonTree UPPER266_tree = null;\n    CommonTree Left_Paren267_tree = null;\n    CommonTree Right_Paren269_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:278:29: ( SUBSTRING ^ Left_Paren ! string_primary Comma ! simple_arithmetic_expression ( Comma ! simple_arithmetic_expression )? Right_Paren !| CONCAT ^ Left_Paren ! string_primary ( Comma ! string_primary )+ Right_Paren !| TRIM ^ Left_Paren ! ( ( LEADING | TRAILING | BOTH )? ( STRING_LITERAL )? FROM !)? string_primary Right_Paren !| LOWER ^ Left_Paren ! string_primary Right_Paren !| UPPER ^ Left_Paren ! string_primary Right_Paren !)\n        int alt57 = 5;\n        switch(input.LA(1)) {\n            case SUBSTRING:\n                {\n                    alt57 = 1;\n                }\n                break;\n            case CONCAT:\n                {\n                    alt57 = 2;\n                }\n                break;\n            case TRIM:\n                {\n                    alt57 = 3;\n                }\n                break;\n            case LOWER:\n                {\n                    alt57 = 4;\n                }\n                break;\n            case UPPER:\n                {\n                    alt57 = 5;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 57, 0, input);\n                throw nvae;\n        }\n        switch(alt57) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:279:2: SUBSTRING ^ Left_Paren ! string_primary Comma ! simple_arithmetic_expression ( Comma ! simple_arithmetic_expression )? Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    SUBSTRING241 = (Token) match(input, SUBSTRING, FOLLOW_SUBSTRING_in_functions_returning_strings2459);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        SUBSTRING241_tree = (CommonTree) adaptor.create(SUBSTRING241);\n                        root_0 = (CommonTree) adaptor.becomeRoot(SUBSTRING241_tree, root_0);\n                    }\n                    Left_Paren242 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_strings2462);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_strings2465);\n                    string_primary243 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary243.getTree());\n                    Comma244 = (Token) match(input, Comma, FOLLOW_Comma_in_functions_returning_strings2467);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_functions_returning_strings2470);\n                    simple_arithmetic_expression245 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression245.getTree());\n                    // org/batoo/jpa/jpql/JpqlParser.g:279:76: ( Comma ! simple_arithmetic_expression )?\n                    int alt52 = 2;\n                    switch(input.LA(1)) {\n                        case Comma:\n                            {\n                                alt52 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt52) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:279:77: Comma ! simple_arithmetic_expression\n                            {\n                                Comma246 = (Token) match(input, Comma, FOLLOW_Comma_in_functions_returning_strings2473);\n                                if (state.failed)\n                                    return retval;\n                                pushFollow(FOLLOW_simple_arithmetic_expression_in_functions_returning_strings2476);\n                                simple_arithmetic_expression247 = simple_arithmetic_expression();\n                                state._fsp--;\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    adaptor.addChild(root_0, simple_arithmetic_expression247.getTree());\n                            }\n                            break;\n                    }\n                    Right_Paren248 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_strings2480);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:280:4: CONCAT ^ Left_Paren ! string_primary ( Comma ! string_primary )+ Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    CONCAT249 = (Token) match(input, CONCAT, FOLLOW_CONCAT_in_functions_returning_strings2486);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        CONCAT249_tree = (CommonTree) adaptor.create(CONCAT249);\n                        root_0 = (CommonTree) adaptor.becomeRoot(CONCAT249_tree, root_0);\n                    }\n                    Left_Paren250 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_strings2489);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_strings2492);\n                    string_primary251 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary251.getTree());\n                    // org/batoo/jpa/jpql/JpqlParser.g:280:39: ( Comma ! string_primary )+\n                    int cnt53 = 0;\n                    loop53: do {\n                        int alt53 = 2;\n                        switch(input.LA(1)) {\n                            case Comma:\n                                {\n                                    alt53 = 1;\n                                }\n                                break;\n                        }\n                        switch(alt53) {\n                            case 1:\n                                // org/batoo/jpa/jpql/JpqlParser.g:280:40: Comma ! string_primary\n                                {\n                                    Comma252 = (Token) match(input, Comma, FOLLOW_Comma_in_functions_returning_strings2495);\n                                    if (state.failed)\n                                        return retval;\n                                    pushFollow(FOLLOW_string_primary_in_functions_returning_strings2498);\n                                    string_primary253 = string_primary();\n                                    state._fsp--;\n                                    if (state.failed)\n                                        return retval;\n                                    if (state.backtracking == 0)\n                                        adaptor.addChild(root_0, string_primary253.getTree());\n                                }\n                                break;\n                            default:\n                                if (cnt53 >= 1)\n                                    break loop53;\n                                if (state.backtracking > 0) {\n                                    state.failed = true;\n                                    return retval;\n                                }\n                                EarlyExitException eee = new EarlyExitException(53, input);\n                                throw eee;\n                        }\n                        cnt53++;\n                    } while (true);\n                    Right_Paren254 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_strings2503);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:281:4: TRIM ^ Left_Paren ! ( ( LEADING | TRAILING | BOTH )? ( STRING_LITERAL )? FROM !)? string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    TRIM255 = (Token) match(input, TRIM, FOLLOW_TRIM_in_functions_returning_strings2509);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        TRIM255_tree = (CommonTree) adaptor.create(TRIM255);\n                        root_0 = (CommonTree) adaptor.becomeRoot(TRIM255_tree, root_0);\n                    }\n                    Left_Paren256 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_strings2512);\n                    if (state.failed)\n                        return retval;\n                    // org/batoo/jpa/jpql/JpqlParser.g:281:22: ( ( LEADING | TRAILING | BOTH )? ( STRING_LITERAL )? FROM !)?\n                    int alt56 = 2;\n                    switch(input.LA(1)) {\n                        case BOTH:\n                        case FROM:\n                        case LEADING:\n                        case TRAILING:\n                            {\n                                alt56 = 1;\n                            }\n                            break;\n                        case STRING_LITERAL:\n                            {\n                                switch(input.LA(2)) {\n                                    case FROM:\n                                        {\n                                            alt56 = 1;\n                                        }\n                                        break;\n                                }\n                            }\n                            break;\n                    }\n                    switch(alt56) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:281:23: ( LEADING | TRAILING | BOTH )? ( STRING_LITERAL )? FROM !\n                            {\n                                // org/batoo/jpa/jpql/JpqlParser.g:281:23: ( LEADING | TRAILING | BOTH )?\n                                int alt54 = 2;\n                                switch(input.LA(1)) {\n                                    case BOTH:\n                                    case LEADING:\n                                    case TRAILING:\n                                        {\n                                            alt54 = 1;\n                                        }\n                                        break;\n                                }\n                                switch(alt54) {\n                                    case 1:\n                                        // org/batoo/jpa/jpql/JpqlParser.g:\n                                        {\n                                            set257 = (Token) input.LT(1);\n                                            if (input.LA(1) == BOTH || input.LA(1) == LEADING || input.LA(1) == TRAILING) {\n                                                input.consume();\n                                                if (state.backtracking == 0)\n                                                    adaptor.addChild(root_0, (CommonTree) adaptor.create(set257));\n                                                state.errorRecovery = false;\n                                                state.failed = false;\n                                            } else {\n                                                if (state.backtracking > 0) {\n                                                    state.failed = true;\n                                                    return retval;\n                                                }\n                                                MismatchedSetException mse = new MismatchedSetException(null, input);\n                                                throw mse;\n                                            }\n                                        }\n                                        break;\n                                }\n                                // org/batoo/jpa/jpql/JpqlParser.g:281:52: ( STRING_LITERAL )?\n                                int alt55 = 2;\n                                switch(input.LA(1)) {\n                                    case STRING_LITERAL:\n                                        {\n                                            alt55 = 1;\n                                        }\n                                        break;\n                                }\n                                switch(alt55) {\n                                    case 1:\n                                        // org/batoo/jpa/jpql/JpqlParser.g:281:53: STRING_LITERAL\n                                        {\n                                            STRING_LITERAL258 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_functions_returning_strings2530);\n                                            if (state.failed)\n                                                return retval;\n                                            if (state.backtracking == 0) {\n                                                STRING_LITERAL258_tree = (CommonTree) adaptor.create(STRING_LITERAL258);\n                                                adaptor.addChild(root_0, STRING_LITERAL258_tree);\n                                            }\n                                        }\n                                        break;\n                                }\n                                FROM259 = (Token) match(input, FROM, FOLLOW_FROM_in_functions_returning_strings2534);\n                                if (state.failed)\n                                    return retval;\n                            }\n                            break;\n                    }\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_strings2539);\n                    string_primary260 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary260.getTree());\n                    Right_Paren261 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_strings2541);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:282:4: LOWER ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    LOWER262 = (Token) match(input, LOWER, FOLLOW_LOWER_in_functions_returning_strings2547);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        LOWER262_tree = (CommonTree) adaptor.create(LOWER262);\n                        root_0 = (CommonTree) adaptor.becomeRoot(LOWER262_tree, root_0);\n                    }\n                    Left_Paren263 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_strings2550);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_strings2553);\n                    string_primary264 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary264.getTree());\n                    Right_Paren265 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_strings2555);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:283:4: UPPER ^ Left_Paren ! string_primary Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    UPPER266 = (Token) match(input, UPPER, FOLLOW_UPPER_in_functions_returning_strings2561);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        UPPER266_tree = (CommonTree) adaptor.create(UPPER266);\n                        root_0 = (CommonTree) adaptor.becomeRoot(UPPER266_tree, root_0);\n                    }\n                    Left_Paren267 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_functions_returning_strings2564);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_string_primary_in_functions_returning_strings2567);\n                    string_primary268 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary268.getTree());\n                    Right_Paren269 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_functions_returning_strings2569);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:278:1: functions_returning_strings : ( SUBSTRING ^ Left_Paren ! string_primary Comma ! simple_arithmetic_expression ( Comma ! simple_arithmetic_expression )? Right_Paren !| CONCAT ^ Left_Paren ! string_primary ( Comma ! string_primary )+ Right_Paren !| TRIM ^ Left_Paren ! ( ( LEADING | TRAILING | BOTH )? ( STRING_LITERAL )? FROM !)? string_primary Right_Paren !| LOWER ^ Left_Paren ! string_primary Right_Paren !| UPPER ^ Left_Paren ! string_primary Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1392, "method_signature": "JpqlParser.functions_returning_strings_return functions_returning_strings()"}, "JpqlParser.general_case_expression": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.when_clause_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.scalar_expression_return.getTree", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "RewriteRuleSubtreeStream.hasNext", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.general_case_expression", "method_implementation": "{\n    JpqlParser.general_case_expression_return retval = new JpqlParser.general_case_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token CASE128 = null;\n    Token ELSE130 = null;\n    Token END132 = null;\n    JpqlParser.when_clause_return when_clause129 = null;\n    JpqlParser.scalar_expression_return scalar_expression131 = null;\n    CommonTree CASE128_tree = null;\n    CommonTree ELSE130_tree = null;\n    CommonTree END132_tree = null;\n    RewriteRuleTokenStream stream_END = new RewriteRuleTokenStream(adaptor, \"token END\");\n    RewriteRuleTokenStream stream_ELSE = new RewriteRuleTokenStream(adaptor, \"token ELSE\");\n    RewriteRuleTokenStream stream_CASE = new RewriteRuleTokenStream(adaptor, \"token CASE\");\n    RewriteRuleSubtreeStream stream_scalar_expression = new RewriteRuleSubtreeStream(adaptor, \"rule scalar_expression\");\n    RewriteRuleSubtreeStream stream_when_clause = new RewriteRuleSubtreeStream(adaptor, \"rule when_clause\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:204:25: ( CASE ( when_clause )+ ELSE scalar_expression END -> ^( ST_GENERAL_CASE ( when_clause )+ scalar_expression ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:205:2: CASE ( when_clause )+ ELSE scalar_expression END\n        {\n            CASE128 = (Token) match(input, CASE, FOLLOW_CASE_in_general_case_expression1836);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_CASE.add(CASE128);\n            // org/batoo/jpa/jpql/JpqlParser.g:205:7: ( when_clause )+\n            int cnt35 = 0;\n            loop35: do {\n                int alt35 = 2;\n                switch(input.LA(1)) {\n                    case WHEN:\n                        {\n                            alt35 = 1;\n                        }\n                        break;\n                }\n                switch(alt35) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:205:8: when_clause\n                        {\n                            pushFollow(FOLLOW_when_clause_in_general_case_expression1839);\n                            when_clause129 = when_clause();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_when_clause.add(when_clause129.getTree());\n                        }\n                        break;\n                    default:\n                        if (cnt35 >= 1)\n                            break loop35;\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        EarlyExitException eee = new EarlyExitException(35, input);\n                        throw eee;\n                }\n                cnt35++;\n            } while (true);\n            ELSE130 = (Token) match(input, ELSE, FOLLOW_ELSE_in_general_case_expression1843);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ELSE.add(ELSE130);\n            pushFollow(FOLLOW_scalar_expression_in_general_case_expression1845);\n            scalar_expression131 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_scalar_expression.add(scalar_expression131.getTree());\n            END132 = (Token) match(input, END, FOLLOW_END_in_general_case_expression1847);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_END.add(END132);\n            // AST REWRITE\n            // elements: scalar_expression, when_clause\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 206:3: -> ^( ST_GENERAL_CASE ( when_clause )+ scalar_expression )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:206:6: ^( ST_GENERAL_CASE ( when_clause )+ scalar_expression )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_GENERAL_CASE, \"ST_GENERAL_CASE\"), root_1);\n                        if (!(stream_when_clause.hasNext())) {\n                            throw new RewriteEarlyExitException();\n                        }\n                        while (stream_when_clause.hasNext()) {\n                            adaptor.addChild(root_1, stream_when_clause.nextTree());\n                        }\n                        stream_when_clause.reset();\n                        adaptor.addChild(root_1, stream_scalar_expression.nextTree());\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:204:1: general_case_expression : CASE ( when_clause )+ ELSE scalar_expression END -> ^( ST_GENERAL_CASE ( when_clause )+ scalar_expression ) ;\n", "repo_name": "BatooJPA-master/", "id": 1377, "method_signature": "JpqlParser.general_case_expression_return general_case_expression()"}, "JpqlParser.groupby_clause": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.scalar_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.groupby_clause", "method_implementation": "{\n    JpqlParser.groupby_clause_return retval = new JpqlParser.groupby_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token GROUP71 = null;\n    Token BY72 = null;\n    Token Comma74 = null;\n    JpqlParser.scalar_expression_return scalar_expression73 = null;\n    JpqlParser.scalar_expression_return scalar_expression75 = null;\n    CommonTree GROUP71_tree = null;\n    CommonTree BY72_tree = null;\n    CommonTree Comma74_tree = null;\n    RewriteRuleTokenStream stream_GROUP = new RewriteRuleTokenStream(adaptor, \"token GROUP\");\n    RewriteRuleTokenStream stream_BY = new RewriteRuleTokenStream(adaptor, \"token BY\");\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_scalar_expression = new RewriteRuleSubtreeStream(adaptor, \"rule scalar_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:130:16: ( GROUP BY scalar_expression ( Comma scalar_expression )* -> ^( LGROUP_BY scalar_expression ( scalar_expression )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:131:4: GROUP BY scalar_expression ( Comma scalar_expression )*\n        {\n            GROUP71 = (Token) match(input, GROUP, FOLLOW_GROUP_in_groupby_clause890);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_GROUP.add(GROUP71);\n            BY72 = (Token) match(input, BY, FOLLOW_BY_in_groupby_clause892);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_BY.add(BY72);\n            pushFollow(FOLLOW_scalar_expression_in_groupby_clause894);\n            scalar_expression73 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_scalar_expression.add(scalar_expression73.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:131:31: ( Comma scalar_expression )*\n            loop23: do {\n                int alt23 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt23 = 1;\n                        }\n                        break;\n                }\n                switch(alt23) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:131:32: Comma scalar_expression\n                        {\n                            Comma74 = (Token) match(input, Comma, FOLLOW_Comma_in_groupby_clause897);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma74);\n                            pushFollow(FOLLOW_scalar_expression_in_groupby_clause899);\n                            scalar_expression75 = scalar_expression();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_scalar_expression.add(scalar_expression75.getTree());\n                        }\n                        break;\n                    default:\n                        break loop23;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: scalar_expression, scalar_expression\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 132:5: -> ^( LGROUP_BY scalar_expression ( scalar_expression )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:132:8: ^( LGROUP_BY scalar_expression ( scalar_expression )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LGROUP_BY, \"LGROUP_BY\"), root_1);\n                        adaptor.addChild(root_1, stream_scalar_expression.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:132:38: ( scalar_expression )*\n                        while (stream_scalar_expression.hasNext()) {\n                            adaptor.addChild(root_1, stream_scalar_expression.nextTree());\n                        }\n                        stream_scalar_expression.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:130:1: groupby_clause : GROUP BY scalar_expression ( Comma scalar_expression )* -> ^( LGROUP_BY scalar_expression ( scalar_expression )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1361, "method_signature": "JpqlParser.groupby_clause_return groupby_clause()"}, "JpqlParser.having_clause": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.conditional_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.having_clause", "method_implementation": "{\n    JpqlParser.having_clause_return retval = new JpqlParser.having_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token HAVING76 = null;\n    JpqlParser.conditional_expression_return conditional_expression77 = null;\n    CommonTree HAVING76_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:134:15: ( HAVING ^ conditional_expression )\n        // org/batoo/jpa/jpql/JpqlParser.g:135:4: HAVING ^ conditional_expression\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            HAVING76 = (Token) match(input, HAVING, FOLLOW_HAVING_in_having_clause931);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                HAVING76_tree = (CommonTree) adaptor.create(HAVING76);\n                root_0 = (CommonTree) adaptor.becomeRoot(HAVING76_tree, root_0);\n            }\n            pushFollow(FOLLOW_conditional_expression_in_having_clause934);\n            conditional_expression77 = conditional_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, conditional_expression77.getTree());\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:134:1: having_clause : HAVING ^ conditional_expression ;\n", "repo_name": "BatooJPA-master/", "id": 1362, "method_signature": "JpqlParser.having_clause_return having_clause()"}, "JpqlParser.id_or_reserved_word": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.id_or_reserved_word", "method_implementation": "{\n    JpqlParser.id_or_reserved_word_return retval = new JpqlParser.id_or_reserved_word_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token set109 = null;\n    CommonTree set109_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:177:21: ( ID | ABS | ALL | AND | ANY | AS | ASC | AVG | BETWEEN | BIT_LENGTH | BOTH | BY | BYTE | CASE | CAST | CHAR_LENGTH | CHARACTER_LENGTH | CLASS | COALESCE | CONCAT | COUNT | CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | DAY | DAYOFMONTH | DAYOFWEEK | DAYOFYEAR | DELETE | DESC | DISTINCT | DOUBLE | ELSE | EMPTY | END | ENTRY | ESCAPE | EXISTS | FALSE | FETCH | FLOAT | FUNC | FROM | GROUP | HAVING | HOUR | IN | INDEX | INNER | IS | INT | INTEGER | JOIN | KEY | LEADING | LEFT | LENGTH | LIKE | LOCATE | LONG | LOWER | MAX | MEMBER | MIN | MINUTE | MOD | MONTH | NEW | NOT | NULLIF | NULL | OBJECT | OF | OR | ORDER | OUTER | POSITION | PROPERTIES | SECOND | SELECT | SET | SHORT | SIZE | SOME | SQRT | STRING | SUBSTRING | SUM | THEN | TRAILING | TRIM | TRUE | TYPE | UNKNOWN | UPDATE | UPPER | VALUE | VARCHAR | WEEK | WHEN | WHERE | YEAR )\n        // org/batoo/jpa/jpql/JpqlParser.g:\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            set109 = (Token) input.LT(1);\n            if ((input.LA(1) >= ABS && input.LA(1) <= AVG) || (input.LA(1) >= BETWEEN && input.LA(1) <= BYTE) || (input.LA(1) >= CASE && input.LA(1) <= COALESCE) || (input.LA(1) >= CONCAT && input.LA(1) <= CURRENT_TIMESTAMP) || (input.LA(1) >= DAY && input.LA(1) <= DOUBLE) || (input.LA(1) >= ELSE && input.LA(1) <= EXISTS) || (input.LA(1) >= FALSE && input.LA(1) <= FUNC) || input.LA(1) == GROUP || (input.LA(1) >= HAVING && input.LA(1) <= HOUR) || (input.LA(1) >= ID && input.LA(1) <= IS) || input.LA(1) == JOIN || input.LA(1) == KEY || (input.LA(1) >= LEADING && input.LA(1) <= LIKE) || (input.LA(1) >= LOCATE && input.LA(1) <= LOWER) || (input.LA(1) >= MAX && input.LA(1) <= MONTH) || (input.LA(1) >= NEW && input.LA(1) <= NULLIF) || (input.LA(1) >= OBJECT && input.LA(1) <= OUTER) || (input.LA(1) >= POSITION && input.LA(1) <= PROPERTIES) || (input.LA(1) >= SECOND && input.LA(1) <= STRING) || (input.LA(1) >= SUBSTRING && input.LA(1) <= SUM) || (input.LA(1) >= THEN && input.LA(1) <= TYPE) || (input.LA(1) >= UNKNOWN && input.LA(1) <= UPPER) || (input.LA(1) >= VALUE && input.LA(1) <= VARCHAR) || (input.LA(1) >= WEEK && input.LA(1) <= WHERE) || input.LA(1) == YEAR) {\n                input.consume();\n                if (state.backtracking == 0)\n                    adaptor.addChild(root_0, (CommonTree) adaptor.create(set109));\n                state.errorRecovery = false;\n                state.failed = false;\n            } else {\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                MismatchedSetException mse = new MismatchedSetException(null, input);\n                throw mse;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:177:1: id_or_reserved_word : ( ID | ABS | ALL | AND | ANY | AS | ASC | AVG | BETWEEN | BIT_LENGTH | BOTH | BY | BYTE | CASE | CAST | CHAR_LENGTH | CHARACTER_LENGTH | CLASS | COALESCE | CONCAT | COUNT | CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | DAY | DAYOFMONTH | DAYOFWEEK | DAYOFYEAR | DELETE | DESC | DISTINCT | DOUBLE | ELSE | EMPTY | END | ENTRY | ESCAPE | EXISTS | FALSE | FETCH | FLOAT | FUNC | FROM | GROUP | HAVING | HOUR | IN | INDEX | INNER | IS | INT | INTEGER | JOIN | KEY | LEADING | LEFT | LENGTH | LIKE | LOCATE | LONG | LOWER | MAX | MEMBER | MIN | MINUTE | MOD | MONTH | NEW | NOT | NULLIF | NULL | OBJECT | OF | OR | ORDER | OUTER | POSITION | PROPERTIES | SECOND | SELECT | SET | SHORT | SIZE | SOME | SQRT | STRING | SUBSTRING | SUM | THEN | TRAILING | TRIM | TRUE | TYPE | UNKNOWN | UPDATE | UPPER | VALUE | VARCHAR | WEEK | WHEN | WHERE | YEAR );\n", "repo_name": "BatooJPA-master/", "id": 1372, "method_signature": "JpqlParser.id_or_reserved_word_return id_or_reserved_word()"}, "JpqlParser.in_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.state_field_path_expression_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.input_parameter_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.input_parameter_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.subquery_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.in_items_return.getTree", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.in_expression", "method_implementation": "{\n    JpqlParser.in_expression_return retval = new JpqlParser.in_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID429 = null;\n    Token NOT430 = null;\n    Token IN431 = null;\n    Token Left_Paren433 = null;\n    Token Right_Paren436 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression427 = null;\n    JpqlParser.input_parameter_return input_parameter428 = null;\n    JpqlParser.input_parameter_return input_parameter432 = null;\n    JpqlParser.subquery_return subquery434 = null;\n    JpqlParser.in_items_return in_items435 = null;\n    CommonTree ID429_tree = null;\n    CommonTree NOT430_tree = null;\n    CommonTree IN431_tree = null;\n    CommonTree Left_Paren433_tree = null;\n    CommonTree Right_Paren436_tree = null;\n    RewriteRuleTokenStream stream_IN = new RewriteRuleTokenStream(adaptor, \"token IN\");\n    RewriteRuleTokenStream stream_NOT = new RewriteRuleTokenStream(adaptor, \"token NOT\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    RewriteRuleTokenStream stream_Right_Paren = new RewriteRuleTokenStream(adaptor, \"token Right_Paren\");\n    RewriteRuleTokenStream stream_Left_Paren = new RewriteRuleTokenStream(adaptor, \"token Left_Paren\");\n    RewriteRuleSubtreeStream stream_state_field_path_expression = new RewriteRuleSubtreeStream(adaptor, \"rule state_field_path_expression\");\n    RewriteRuleSubtreeStream stream_input_parameter = new RewriteRuleSubtreeStream(adaptor, \"rule input_parameter\");\n    RewriteRuleSubtreeStream stream_in_items = new RewriteRuleSubtreeStream(adaptor, \"rule in_items\");\n    RewriteRuleSubtreeStream stream_subquery = new RewriteRuleSubtreeStream(adaptor, \"rule subquery\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:435:15: ( ( state_field_path_expression | input_parameter | ID ) ( NOT )? IN ( input_parameter | ( Left_Paren ( subquery | in_items ) Right_Paren ) ) -> ^( ST_IN ( state_field_path_expression )? ( ID )? ( input_parameter )? ( in_items )? ( subquery )? ( NOT )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:436:4: ( state_field_path_expression | input_parameter | ID ) ( NOT )? IN ( input_parameter | ( Left_Paren ( subquery | in_items ) Right_Paren ) )\n        {\n            // org/batoo/jpa/jpql/JpqlParser.g:436:4: ( state_field_path_expression | input_parameter | ID )\n            int alt85 = 3;\n            switch(input.LA(1)) {\n                case ID:\n                    {\n                        switch(input.LA(2)) {\n                            case Period:\n                                {\n                                    alt85 = 1;\n                                }\n                                break;\n                            case IN:\n                            case NOT:\n                                {\n                                    alt85 = 3;\n                                }\n                                break;\n                            default:\n                                if (state.backtracking > 0) {\n                                    state.failed = true;\n                                    return retval;\n                                }\n                                NoViableAltException nvae = new NoViableAltException(\"\", 85, 1, input);\n                                throw nvae;\n                        }\n                    }\n                    break;\n                case CAST:\n                    {\n                        alt85 = 1;\n                    }\n                    break;\n                case Named_Parameter:\n                case Ordinal_Parameter:\n                case Question_Sign:\n                    {\n                        alt85 = 2;\n                    }\n                    break;\n                default:\n                    if (state.backtracking > 0) {\n                        state.failed = true;\n                        return retval;\n                    }\n                    NoViableAltException nvae = new NoViableAltException(\"\", 85, 0, input);\n                    throw nvae;\n            }\n            switch(alt85) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:436:5: state_field_path_expression\n                    {\n                        pushFollow(FOLLOW_state_field_path_expression_in_in_expression3711);\n                        state_field_path_expression427 = state_field_path_expression();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_state_field_path_expression.add(state_field_path_expression427.getTree());\n                    }\n                    break;\n                case 2:\n                    // org/batoo/jpa/jpql/JpqlParser.g:436:35: input_parameter\n                    {\n                        pushFollow(FOLLOW_input_parameter_in_in_expression3715);\n                        input_parameter428 = input_parameter();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_input_parameter.add(input_parameter428.getTree());\n                    }\n                    break;\n                case 3:\n                    // org/batoo/jpa/jpql/JpqlParser.g:436:53: ID\n                    {\n                        ID429 = (Token) match(input, ID, FOLLOW_ID_in_in_expression3719);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ID.add(ID429);\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:436:57: ( NOT )?\n            int alt86 = 2;\n            switch(input.LA(1)) {\n                case NOT:\n                    {\n                        alt86 = 1;\n                    }\n                    break;\n            }\n            switch(alt86) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:436:58: NOT\n                    {\n                        NOT430 = (Token) match(input, NOT, FOLLOW_NOT_in_in_expression3723);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_NOT.add(NOT430);\n                    }\n                    break;\n            }\n            IN431 = (Token) match(input, IN, FOLLOW_IN_in_in_expression3727);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_IN.add(IN431);\n            // org/batoo/jpa/jpql/JpqlParser.g:436:67: ( input_parameter | ( Left_Paren ( subquery | in_items ) Right_Paren ) )\n            int alt88 = 2;\n            switch(input.LA(1)) {\n                case Named_Parameter:\n                case Ordinal_Parameter:\n                case Question_Sign:\n                    {\n                        alt88 = 1;\n                    }\n                    break;\n                case Left_Paren:\n                    {\n                        alt88 = 2;\n                    }\n                    break;\n                default:\n                    if (state.backtracking > 0) {\n                        state.failed = true;\n                        return retval;\n                    }\n                    NoViableAltException nvae = new NoViableAltException(\"\", 88, 0, input);\n                    throw nvae;\n            }\n            switch(alt88) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:436:68: input_parameter\n                    {\n                        pushFollow(FOLLOW_input_parameter_in_in_expression3730);\n                        input_parameter432 = input_parameter();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_input_parameter.add(input_parameter432.getTree());\n                    }\n                    break;\n                case 2:\n                    // org/batoo/jpa/jpql/JpqlParser.g:436:86: ( Left_Paren ( subquery | in_items ) Right_Paren )\n                    {\n                        // org/batoo/jpa/jpql/JpqlParser.g:436:86: ( Left_Paren ( subquery | in_items ) Right_Paren )\n                        // org/batoo/jpa/jpql/JpqlParser.g:436:87: Left_Paren ( subquery | in_items ) Right_Paren\n                        {\n                            Left_Paren433 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_in_expression3735);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Left_Paren.add(Left_Paren433);\n                            // org/batoo/jpa/jpql/JpqlParser.g:436:98: ( subquery | in_items )\n                            int alt87 = 2;\n                            switch(input.LA(1)) {\n                                case SELECT:\n                                    {\n                                        alt87 = 1;\n                                    }\n                                    break;\n                                case NUMERIC_LITERAL:\n                                case Named_Parameter:\n                                case Ordinal_Parameter:\n                                case Question_Sign:\n                                case STRING_LITERAL:\n                                    {\n                                        alt87 = 2;\n                                    }\n                                    break;\n                                default:\n                                    if (state.backtracking > 0) {\n                                        state.failed = true;\n                                        return retval;\n                                    }\n                                    NoViableAltException nvae = new NoViableAltException(\"\", 87, 0, input);\n                                    throw nvae;\n                            }\n                            switch(alt87) {\n                                case 1:\n                                    // org/batoo/jpa/jpql/JpqlParser.g:436:99: subquery\n                                    {\n                                        pushFollow(FOLLOW_subquery_in_in_expression3738);\n                                        subquery434 = subquery();\n                                        state._fsp--;\n                                        if (state.failed)\n                                            return retval;\n                                        if (state.backtracking == 0)\n                                            stream_subquery.add(subquery434.getTree());\n                                    }\n                                    break;\n                                case 2:\n                                    // org/batoo/jpa/jpql/JpqlParser.g:436:110: in_items\n                                    {\n                                        pushFollow(FOLLOW_in_items_in_in_expression3742);\n                                        in_items435 = in_items();\n                                        state._fsp--;\n                                        if (state.failed)\n                                            return retval;\n                                        if (state.backtracking == 0)\n                                            stream_in_items.add(in_items435.getTree());\n                                    }\n                                    break;\n                            }\n                            Right_Paren436 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_in_expression3745);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Right_Paren.add(Right_Paren436);\n                        }\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: subquery, input_parameter, NOT, state_field_path_expression, in_items, ID\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 437:5: -> ^( ST_IN ( state_field_path_expression )? ( ID )? ( input_parameter )? ( in_items )? ( subquery )? ( NOT )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:437:8: ^( ST_IN ( state_field_path_expression )? ( ID )? ( input_parameter )? ( in_items )? ( subquery )? ( NOT )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_IN, \"ST_IN\"), root_1);\n                        // org/batoo/jpa/jpql/JpqlParser.g:437:16: ( state_field_path_expression )?\n                        if (stream_state_field_path_expression.hasNext()) {\n                            adaptor.addChild(root_1, stream_state_field_path_expression.nextTree());\n                        }\n                        stream_state_field_path_expression.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:437:45: ( ID )?\n                        if (stream_ID.hasNext()) {\n                            adaptor.addChild(root_1, stream_ID.nextNode());\n                        }\n                        stream_ID.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:437:49: ( input_parameter )?\n                        if (stream_input_parameter.hasNext()) {\n                            adaptor.addChild(root_1, stream_input_parameter.nextTree());\n                        }\n                        stream_input_parameter.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:437:66: ( in_items )?\n                        if (stream_in_items.hasNext()) {\n                            adaptor.addChild(root_1, stream_in_items.nextTree());\n                        }\n                        stream_in_items.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:437:76: ( subquery )?\n                        if (stream_subquery.hasNext()) {\n                            adaptor.addChild(root_1, stream_subquery.nextTree());\n                        }\n                        stream_subquery.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:437:86: ( NOT )?\n                        if (stream_NOT.hasNext()) {\n                            adaptor.addChild(root_1, stream_NOT.nextNode());\n                        }\n                        stream_NOT.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:435:1: in_expression : ( state_field_path_expression | input_parameter | ID ) ( NOT )? IN ( input_parameter | ( Left_Paren ( subquery | in_items ) Right_Paren ) ) -> ^( ST_IN ( state_field_path_expression )? ( ID )? ( input_parameter )? ( in_items )? ( subquery )? ( NOT )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1417, "method_signature": "JpqlParser.in_expression_return in_expression()"}, "JpqlParser.in_item": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.in_item", "method_implementation": "{\n    JpqlParser.in_item_return retval = new JpqlParser.in_item_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token STRING_LITERAL440 = null;\n    Token NUMERIC_LITERAL441 = null;\n    JpqlParser.input_parameter_return input_parameter442 = null;\n    CommonTree STRING_LITERAL440_tree = null;\n    CommonTree NUMERIC_LITERAL441_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:443:9: ( STRING_LITERAL | NUMERIC_LITERAL | input_parameter )\n        int alt90 = 3;\n        switch(input.LA(1)) {\n            case STRING_LITERAL:\n                {\n                    alt90 = 1;\n                }\n                break;\n            case NUMERIC_LITERAL:\n                {\n                    alt90 = 2;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt90 = 3;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 90, 0, input);\n                throw nvae;\n        }\n        switch(alt90) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:444:2: STRING_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    STRING_LITERAL440 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_in_item3817);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        STRING_LITERAL440_tree = (CommonTree) adaptor.create(STRING_LITERAL440);\n                        adaptor.addChild(root_0, STRING_LITERAL440_tree);\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:444:19: NUMERIC_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    NUMERIC_LITERAL441 = (Token) match(input, NUMERIC_LITERAL, FOLLOW_NUMERIC_LITERAL_in_in_item3821);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        NUMERIC_LITERAL441_tree = (CommonTree) adaptor.create(NUMERIC_LITERAL441);\n                        adaptor.addChild(root_0, NUMERIC_LITERAL441_tree);\n                    }\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:444:37: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_in_item3825);\n                    input_parameter442 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter442.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:443:1: in_item : ( STRING_LITERAL | NUMERIC_LITERAL | input_parameter );\n", "repo_name": "BatooJPA-master/", "id": 1419, "method_signature": "JpqlParser.in_item_return in_item()"}, "JpqlParser.in_items": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.in_item_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.in_item_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.in_items", "method_implementation": "{\n    JpqlParser.in_items_return retval = new JpqlParser.in_items_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Comma438 = null;\n    JpqlParser.in_item_return in_item437 = null;\n    JpqlParser.in_item_return in_item439 = null;\n    CommonTree Comma438_tree = null;\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_in_item = new RewriteRuleSubtreeStream(adaptor, \"rule in_item\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:439:10: ( in_item ( Comma in_item )* -> ^( LIN in_item ( in_item )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:440:2: in_item ( Comma in_item )*\n        {\n            pushFollow(FOLLOW_in_item_in_in_items3786);\n            in_item437 = in_item();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_in_item.add(in_item437.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:440:10: ( Comma in_item )*\n            loop89: do {\n                int alt89 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt89 = 1;\n                        }\n                        break;\n                }\n                switch(alt89) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:440:11: Comma in_item\n                        {\n                            Comma438 = (Token) match(input, Comma, FOLLOW_Comma_in_in_items3789);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma438);\n                            pushFollow(FOLLOW_in_item_in_in_items3791);\n                            in_item439 = in_item();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_in_item.add(in_item439.getTree());\n                        }\n                        break;\n                    default:\n                        break loop89;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: in_item, in_item\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 441:3: -> ^( LIN in_item ( in_item )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:441:6: ^( LIN in_item ( in_item )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LIN, \"LIN\"), root_1);\n                        adaptor.addChild(root_1, stream_in_item.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:441:20: ( in_item )*\n                        while (stream_in_item.hasNext()) {\n                            adaptor.addChild(root_1, stream_in_item.nextTree());\n                        }\n                        stream_in_item.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:439:1: in_items : in_item ( Comma in_item )* -> ^( LIN in_item ( in_item )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1418, "method_signature": "JpqlParser.in_items_return in_items()"}, "JpqlParser.input_parameter": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "Token.setText", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.input_parameter", "method_implementation": "{\n    JpqlParser.input_parameter_return retval = new JpqlParser.input_parameter_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Question_Sign447 = null;\n    Token Ordinal_Parameter448 = null;\n    Token Named_Parameter449 = null;\n    CommonTree Question_Sign447_tree = null;\n    CommonTree Ordinal_Parameter448_tree = null;\n    CommonTree Named_Parameter449_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:456:17: ( ( Question_Sign ) | Ordinal_Parameter | Named_Parameter )\n        int alt93 = 3;\n        switch(input.LA(1)) {\n            case Question_Sign:\n                {\n                    alt93 = 1;\n                }\n                break;\n            case Ordinal_Parameter:\n                {\n                    alt93 = 2;\n                }\n                break;\n            case Named_Parameter:\n                {\n                    alt93 = 3;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 93, 0, input);\n                throw nvae;\n        }\n        switch(alt93) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:457:2: ( Question_Sign )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    // org/batoo/jpa/jpql/JpqlParser.g:457:2: ( Question_Sign )\n                    // org/batoo/jpa/jpql/JpqlParser.g:457:3: Question_Sign\n                    {\n                        Question_Sign447 = (Token) match(input, Question_Sign, FOLLOW_Question_Sign_in_input_parameter3875);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0) {\n                            Question_Sign447_tree = (CommonTree) adaptor.create(Question_Sign447);\n                            adaptor.addChild(root_0, Question_Sign447_tree);\n                        }\n                        if (state.backtracking == 0) {\n                            Question_Sign447.setText('?' + Integer.toString(nextParam++));\n                        }\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:458:4: Ordinal_Parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Ordinal_Parameter448 = (Token) match(input, Ordinal_Parameter, FOLLOW_Ordinal_Parameter_in_input_parameter3884);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        Ordinal_Parameter448_tree = (CommonTree) adaptor.create(Ordinal_Parameter448);\n                        adaptor.addChild(root_0, Ordinal_Parameter448_tree);\n                    }\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:459:7: Named_Parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Named_Parameter449 = (Token) match(input, Named_Parameter, FOLLOW_Named_Parameter_in_input_parameter3892);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        Named_Parameter449_tree = (CommonTree) adaptor.create(Named_Parameter449);\n                        adaptor.addChild(root_0, Named_Parameter449_tree);\n                    }\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:456:1: input_parameter : ( ( Question_Sign ) | Ordinal_Parameter | Named_Parameter );\n", "repo_name": "BatooJPA-master/", "id": 1422, "method_signature": "JpqlParser.input_parameter_return input_parameter()"}, "JpqlParser.join": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.qid_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.join", "method_implementation": "{\n    JpqlParser.join_return retval = new JpqlParser.join_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token LEFT48 = null;\n    Token OUTER49 = null;\n    Token INNER50 = null;\n    Token JOIN51 = null;\n    Token FETCH52 = null;\n    Token ID53 = null;\n    Token Period54 = null;\n    Token AS56 = null;\n    Token ID57 = null;\n    JpqlParser.qid_return qid55 = null;\n    CommonTree LEFT48_tree = null;\n    CommonTree OUTER49_tree = null;\n    CommonTree INNER50_tree = null;\n    CommonTree JOIN51_tree = null;\n    CommonTree FETCH52_tree = null;\n    CommonTree ID53_tree = null;\n    CommonTree Period54_tree = null;\n    CommonTree AS56_tree = null;\n    CommonTree ID57_tree = null;\n    RewriteRuleTokenStream stream_Period = new RewriteRuleTokenStream(adaptor, \"token Period\");\n    RewriteRuleTokenStream stream_OUTER = new RewriteRuleTokenStream(adaptor, \"token OUTER\");\n    RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor, \"token AS\");\n    RewriteRuleTokenStream stream_INNER = new RewriteRuleTokenStream(adaptor, \"token INNER\");\n    RewriteRuleTokenStream stream_FETCH = new RewriteRuleTokenStream(adaptor, \"token FETCH\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    RewriteRuleTokenStream stream_LEFT = new RewriteRuleTokenStream(adaptor, \"token LEFT\");\n    RewriteRuleTokenStream stream_JOIN = new RewriteRuleTokenStream(adaptor, \"token JOIN\");\n    RewriteRuleSubtreeStream stream_qid = new RewriteRuleSubtreeStream(adaptor, \"rule qid\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:115:6: ( ( ( LEFT ( OUTER )? ) | INNER )? JOIN ( FETCH )? ID Period qid ( ( AS )? ID )? -> ^( ST_JOIN ( LEFT )? ( INNER )? ID ^( ST_ID_AS qid ( ID )? ) ( FETCH )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:116:2: ( ( LEFT ( OUTER )? ) | INNER )? JOIN ( FETCH )? ID Period qid ( ( AS )? ID )?\n        {\n            // org/batoo/jpa/jpql/JpqlParser.g:116:2: ( ( LEFT ( OUTER )? ) | INNER )?\n            int alt16 = 3;\n            switch(input.LA(1)) {\n                case LEFT:\n                    {\n                        alt16 = 1;\n                    }\n                    break;\n                case INNER:\n                    {\n                        alt16 = 2;\n                    }\n                    break;\n            }\n            switch(alt16) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:116:3: ( LEFT ( OUTER )? )\n                    {\n                        // org/batoo/jpa/jpql/JpqlParser.g:116:3: ( LEFT ( OUTER )? )\n                        // org/batoo/jpa/jpql/JpqlParser.g:116:4: LEFT ( OUTER )?\n                        {\n                            LEFT48 = (Token) match(input, LEFT, FOLLOW_LEFT_in_join710);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_LEFT.add(LEFT48);\n                            // org/batoo/jpa/jpql/JpqlParser.g:116:9: ( OUTER )?\n                            int alt15 = 2;\n                            switch(input.LA(1)) {\n                                case OUTER:\n                                    {\n                                        alt15 = 1;\n                                    }\n                                    break;\n                            }\n                            switch(alt15) {\n                                case 1:\n                                    // org/batoo/jpa/jpql/JpqlParser.g:116:9: OUTER\n                                    {\n                                        OUTER49 = (Token) match(input, OUTER, FOLLOW_OUTER_in_join712);\n                                        if (state.failed)\n                                            return retval;\n                                        if (state.backtracking == 0)\n                                            stream_OUTER.add(OUTER49);\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                    break;\n                case 2:\n                    // org/batoo/jpa/jpql/JpqlParser.g:116:19: INNER\n                    {\n                        INNER50 = (Token) match(input, INNER, FOLLOW_INNER_in_join718);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_INNER.add(INNER50);\n                    }\n                    break;\n            }\n            JOIN51 = (Token) match(input, JOIN, FOLLOW_JOIN_in_join722);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_JOIN.add(JOIN51);\n            // org/batoo/jpa/jpql/JpqlParser.g:116:32: ( FETCH )?\n            int alt17 = 2;\n            switch(input.LA(1)) {\n                case FETCH:\n                    {\n                        alt17 = 1;\n                    }\n                    break;\n            }\n            switch(alt17) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:116:32: FETCH\n                    {\n                        FETCH52 = (Token) match(input, FETCH, FOLLOW_FETCH_in_join724);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_FETCH.add(FETCH52);\n                    }\n                    break;\n            }\n            ID53 = (Token) match(input, ID, FOLLOW_ID_in_join727);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ID.add(ID53);\n            Period54 = (Token) match(input, Period, FOLLOW_Period_in_join729);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Period.add(Period54);\n            pushFollow(FOLLOW_qid_in_join731);\n            qid55 = qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_qid.add(qid55.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:116:53: ( ( AS )? ID )?\n            int alt19 = 2;\n            switch(input.LA(1)) {\n                case AS:\n                case ID:\n                    {\n                        alt19 = 1;\n                    }\n                    break;\n            }\n            switch(alt19) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:116:54: ( AS )? ID\n                    {\n                        // org/batoo/jpa/jpql/JpqlParser.g:116:54: ( AS )?\n                        int alt18 = 2;\n                        switch(input.LA(1)) {\n                            case AS:\n                                {\n                                    alt18 = 1;\n                                }\n                                break;\n                        }\n                        switch(alt18) {\n                            case 1:\n                                // org/batoo/jpa/jpql/JpqlParser.g:116:54: AS\n                                {\n                                    AS56 = (Token) match(input, AS, FOLLOW_AS_in_join734);\n                                    if (state.failed)\n                                        return retval;\n                                    if (state.backtracking == 0)\n                                        stream_AS.add(AS56);\n                                }\n                                break;\n                        }\n                        ID57 = (Token) match(input, ID, FOLLOW_ID_in_join737);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ID.add(ID57);\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: INNER, qid, ID, ID, LEFT, FETCH\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 117:6: -> ^( ST_JOIN ( LEFT )? ( INNER )? ID ^( ST_ID_AS qid ( ID )? ) ( FETCH )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:117:9: ^( ST_JOIN ( LEFT )? ( INNER )? ID ^( ST_ID_AS qid ( ID )? ) ( FETCH )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_JOIN, \"ST_JOIN\"), root_1);\n                        // org/batoo/jpa/jpql/JpqlParser.g:117:19: ( LEFT )?\n                        if (stream_LEFT.hasNext()) {\n                            adaptor.addChild(root_1, stream_LEFT.nextNode());\n                        }\n                        stream_LEFT.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:117:25: ( INNER )?\n                        if (stream_INNER.hasNext()) {\n                            adaptor.addChild(root_1, stream_INNER.nextNode());\n                        }\n                        stream_INNER.reset();\n                        adaptor.addChild(root_1, stream_ID.nextNode());\n                        // org/batoo/jpa/jpql/JpqlParser.g:117:35: ^( ST_ID_AS qid ( ID )? )\n                        {\n                            CommonTree root_2 = (CommonTree) adaptor.nil();\n                            root_2 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ID_AS, \"ST_ID_AS\"), root_2);\n                            adaptor.addChild(root_2, stream_qid.nextTree());\n                            // org/batoo/jpa/jpql/JpqlParser.g:117:50: ( ID )?\n                            if (stream_ID.hasNext()) {\n                                adaptor.addChild(root_2, stream_ID.nextNode());\n                            }\n                            stream_ID.reset();\n                            adaptor.addChild(root_1, root_2);\n                        }\n                        // org/batoo/jpa/jpql/JpqlParser.g:117:55: ( FETCH )?\n                        if (stream_FETCH.hasNext()) {\n                            adaptor.addChild(root_1, stream_FETCH.nextNode());\n                        }\n                        stream_FETCH.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:115:1: join : ( ( LEFT ( OUTER )? ) | INNER )? JOIN ( FETCH )? ID Period qid ( ( AS )? ID )? -> ^( ST_JOIN ( LEFT )? ( INNER )? ID ^( ST_ID_AS qid ( ID )? ) ( FETCH )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1357, "method_signature": "JpqlParser.join_return join()"}, "JpqlParser.like_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.string_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.string_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.like_expression", "method_implementation": "{\n    JpqlParser.like_expression_return retval = new JpqlParser.like_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token NOT302 = null;\n    Token LIKE303 = null;\n    Token ESCAPE305 = null;\n    Token STRING_LITERAL306 = null;\n    JpqlParser.string_expression_return string_expression301 = null;\n    JpqlParser.string_expression_return string_expression304 = null;\n    CommonTree NOT302_tree = null;\n    CommonTree LIKE303_tree = null;\n    CommonTree ESCAPE305_tree = null;\n    CommonTree STRING_LITERAL306_tree = null;\n    RewriteRuleTokenStream stream_STRING_LITERAL = new RewriteRuleTokenStream(adaptor, \"token STRING_LITERAL\");\n    RewriteRuleTokenStream stream_NOT = new RewriteRuleTokenStream(adaptor, \"token NOT\");\n    RewriteRuleTokenStream stream_ESCAPE = new RewriteRuleTokenStream(adaptor, \"token ESCAPE\");\n    RewriteRuleTokenStream stream_LIKE = new RewriteRuleTokenStream(adaptor, \"token LIKE\");\n    RewriteRuleSubtreeStream stream_string_expression = new RewriteRuleSubtreeStream(adaptor, \"rule string_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:325:17: ( string_expression ( NOT )? LIKE string_expression ( ESCAPE STRING_LITERAL )? -> ^( LIKE string_expression string_expression ( STRING_LITERAL )? ( NOT )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:326:5: string_expression ( NOT )? LIKE string_expression ( ESCAPE STRING_LITERAL )?\n        {\n            pushFollow(FOLLOW_string_expression_in_like_expression2912);\n            string_expression301 = string_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_string_expression.add(string_expression301.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:326:23: ( NOT )?\n            int alt65 = 2;\n            switch(input.LA(1)) {\n                case NOT:\n                    {\n                        alt65 = 1;\n                    }\n                    break;\n            }\n            switch(alt65) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:326:24: NOT\n                    {\n                        NOT302 = (Token) match(input, NOT, FOLLOW_NOT_in_like_expression2915);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_NOT.add(NOT302);\n                    }\n                    break;\n            }\n            LIKE303 = (Token) match(input, LIKE, FOLLOW_LIKE_in_like_expression2919);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_LIKE.add(LIKE303);\n            pushFollow(FOLLOW_string_expression_in_like_expression2921);\n            string_expression304 = string_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_string_expression.add(string_expression304.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:326:53: ( ESCAPE STRING_LITERAL )?\n            int alt66 = 2;\n            switch(input.LA(1)) {\n                case ESCAPE:\n                    {\n                        alt66 = 1;\n                    }\n                    break;\n            }\n            switch(alt66) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:326:54: ESCAPE STRING_LITERAL\n                    {\n                        ESCAPE305 = (Token) match(input, ESCAPE, FOLLOW_ESCAPE_in_like_expression2924);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ESCAPE.add(ESCAPE305);\n                        STRING_LITERAL306 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_like_expression2926);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_STRING_LITERAL.add(STRING_LITERAL306);\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: STRING_LITERAL, string_expression, NOT, string_expression, LIKE\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 327:9: -> ^( LIKE string_expression string_expression ( STRING_LITERAL )? ( NOT )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:327:12: ^( LIKE string_expression string_expression ( STRING_LITERAL )? ( NOT )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot(stream_LIKE.nextNode(), root_1);\n                        adaptor.addChild(root_1, stream_string_expression.nextTree());\n                        adaptor.addChild(root_1, stream_string_expression.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:327:55: ( STRING_LITERAL )?\n                        if (stream_STRING_LITERAL.hasNext()) {\n                            adaptor.addChild(root_1, stream_STRING_LITERAL.nextNode());\n                        }\n                        stream_STRING_LITERAL.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:327:73: ( NOT )?\n                        if (stream_NOT.hasNext()) {\n                            adaptor.addChild(root_1, stream_NOT.nextNode());\n                        }\n                        stream_NOT.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:325:1: like_expression : string_expression ( NOT )? LIKE string_expression ( ESCAPE STRING_LITERAL )? -> ^( LIKE string_expression string_expression ( STRING_LITERAL )? ( NOT )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1400, "method_signature": "JpqlParser.like_expression_return like_expression()"}, "JpqlParser.new_value": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_entity_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.new_value", "method_implementation": "{\n    JpqlParser.new_value_return retval = new JpqlParser.new_value_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token STRING_LITERAL22 = null;\n    Token NUMERIC_LITERAL23 = null;\n    Token NULL24 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression20 = null;\n    JpqlParser.simple_entity_expression_return simple_entity_expression21 = null;\n    CommonTree STRING_LITERAL22_tree = null;\n    CommonTree NUMERIC_LITERAL23_tree = null;\n    CommonTree NULL24_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:85:38: ( simple_arithmetic_expression | simple_entity_expression | STRING_LITERAL | NUMERIC_LITERAL | NULL )\n        int alt5 = 5;\n        switch(input.LA(1)) {\n            case ABS:\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case FUNC:\n            case HOUR:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case Left_Paren:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MOD:\n            case MONTH:\n            case Minus_Sign:\n            case NULLIF:\n            case Plus_Sign:\n            case SECOND:\n            case SIZE:\n            case SQRT:\n            case SUM:\n            case WEEK:\n            case YEAR:\n                {\n                    alt5 = 1;\n                }\n                break;\n            case ID:\n                {\n                    switch(input.LA(2)) {\n                        case Period:\n                            {\n                                alt5 = 1;\n                            }\n                            break;\n                        case EOF:\n                        case Comma:\n                        case WHERE:\n                            {\n                                alt5 = 2;\n                            }\n                            break;\n                        default:\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            NoViableAltException nvae = new NoViableAltException(\"\", 5, 2, input);\n                            throw nvae;\n                    }\n                }\n                break;\n            case NUMERIC_LITERAL:\n                {\n                    int LA5_3 = input.LA(2);\n                    if ((synpred1_JpqlParser())) {\n                        alt5 = 1;\n                    } else if ((synpred4_JpqlParser())) {\n                        alt5 = 4;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 5, 3, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Question_Sign:\n                {\n                    int LA5_4 = input.LA(2);\n                    if ((synpred1_JpqlParser())) {\n                        alt5 = 1;\n                    } else if ((synpred2_JpqlParser())) {\n                        alt5 = 2;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 5, 4, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Ordinal_Parameter:\n                {\n                    int LA5_5 = input.LA(2);\n                    if ((synpred1_JpqlParser())) {\n                        alt5 = 1;\n                    } else if ((synpred2_JpqlParser())) {\n                        alt5 = 2;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 5, 5, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Named_Parameter:\n                {\n                    int LA5_6 = input.LA(2);\n                    if ((synpred1_JpqlParser())) {\n                        alt5 = 1;\n                    } else if ((synpred2_JpqlParser())) {\n                        alt5 = 2;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 5, 6, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case STRING_LITERAL:\n                {\n                    alt5 = 3;\n                }\n                break;\n            case NULL:\n                {\n                    alt5 = 5;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 5, 0, input);\n                throw nvae;\n        }\n        switch(alt5) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:86:5: simple_arithmetic_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_new_value457);\n                    simple_arithmetic_expression20 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression20.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:87:7: simple_entity_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_entity_expression_in_new_value465);\n                    simple_entity_expression21 = simple_entity_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_entity_expression21.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:88:7: STRING_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    STRING_LITERAL22 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_new_value473);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        STRING_LITERAL22_tree = (CommonTree) adaptor.create(STRING_LITERAL22);\n                        adaptor.addChild(root_0, STRING_LITERAL22_tree);\n                    }\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:89:7: NUMERIC_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    NUMERIC_LITERAL23 = (Token) match(input, NUMERIC_LITERAL, FOLLOW_NUMERIC_LITERAL_in_new_value481);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        NUMERIC_LITERAL23_tree = (CommonTree) adaptor.create(NUMERIC_LITERAL23);\n                        adaptor.addChild(root_0, NUMERIC_LITERAL23_tree);\n                    }\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:90:7: NULL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    NULL24 = (Token) match(input, NULL, FOLLOW_NULL_in_new_value489);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        NULL24_tree = (CommonTree) adaptor.create(NULL24);\n                        adaptor.addChild(root_0, NULL24_tree);\n                    }\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:85:1: new_value options {backtrack=true; } : ( simple_arithmetic_expression | simple_entity_expression | STRING_LITERAL | NUMERIC_LITERAL | NULL );\n", "repo_name": "BatooJPA-master/", "id": 1350, "method_signature": "JpqlParser.new_value_return new_value()"}, "JpqlParser.null_comparison_expression": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.single_valued_path_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.add", "JpqlParser.input_parameter_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.null_comparison_expression", "method_implementation": "{\n    JpqlParser.null_comparison_expression_return retval = new JpqlParser.null_comparison_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token IS460 = null;\n    Token NOT461 = null;\n    Token NULL462 = null;\n    Token IS464 = null;\n    Token NOT465 = null;\n    Token NULL466 = null;\n    JpqlParser.single_valued_path_expression_return single_valued_path_expression459 = null;\n    JpqlParser.input_parameter_return input_parameter463 = null;\n    CommonTree IS460_tree = null;\n    CommonTree NOT461_tree = null;\n    CommonTree NULL462_tree = null;\n    CommonTree IS464_tree = null;\n    CommonTree NOT465_tree = null;\n    CommonTree NULL466_tree = null;\n    RewriteRuleTokenStream stream_NOT = new RewriteRuleTokenStream(adaptor, \"token NOT\");\n    RewriteRuleTokenStream stream_IS = new RewriteRuleTokenStream(adaptor, \"token IS\");\n    RewriteRuleTokenStream stream_NULL = new RewriteRuleTokenStream(adaptor, \"token NULL\");\n    RewriteRuleSubtreeStream stream_single_valued_path_expression = new RewriteRuleSubtreeStream(adaptor, \"rule single_valued_path_expression\");\n    RewriteRuleSubtreeStream stream_input_parameter = new RewriteRuleSubtreeStream(adaptor, \"rule input_parameter\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:474:28: ( single_valued_path_expression IS ( NOT )? NULL -> ^( ST_NULL single_valued_path_expression ( NOT )? ) | input_parameter IS ( NOT )? NULL -> ^( ST_NULL input_parameter ( NOT )? ) )\n        int alt100 = 2;\n        switch(input.LA(1)) {\n            case CAST:\n            case ENTRY:\n            case ID:\n            case KEY:\n            case VALUE:\n                {\n                    alt100 = 1;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt100 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 100, 0, input);\n                throw nvae;\n        }\n        switch(alt100) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:475:4: single_valued_path_expression IS ( NOT )? NULL\n                {\n                    pushFollow(FOLLOW_single_valued_path_expression_in_null_comparison_expression4040);\n                    single_valued_path_expression459 = single_valued_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_single_valued_path_expression.add(single_valued_path_expression459.getTree());\n                    IS460 = (Token) match(input, IS, FOLLOW_IS_in_null_comparison_expression4042);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_IS.add(IS460);\n                    // org/batoo/jpa/jpql/JpqlParser.g:475:37: ( NOT )?\n                    int alt98 = 2;\n                    switch(input.LA(1)) {\n                        case NOT:\n                            {\n                                alt98 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt98) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:475:38: NOT\n                            {\n                                NOT461 = (Token) match(input, NOT, FOLLOW_NOT_in_null_comparison_expression4045);\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    stream_NOT.add(NOT461);\n                            }\n                            break;\n                    }\n                    NULL462 = (Token) match(input, NULL, FOLLOW_NULL_in_null_comparison_expression4049);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_NULL.add(NULL462);\n                    // AST REWRITE\n                    // elements: NOT, single_valued_path_expression\n                    // token labels:\n                    // rule labels: retval\n                    // token list labels:\n                    // rule list labels:\n                    // wildcard labels:\n                    if (state.backtracking == 0) {\n                        retval.tree = root_0;\n                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                        root_0 = (CommonTree) adaptor.nil();\n                        // 476:5: -> ^( ST_NULL single_valued_path_expression ( NOT )? )\n                        {\n                            // org/batoo/jpa/jpql/JpqlParser.g:476:8: ^( ST_NULL single_valued_path_expression ( NOT )? )\n                            {\n                                CommonTree root_1 = (CommonTree) adaptor.nil();\n                                root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_NULL, \"ST_NULL\"), root_1);\n                                adaptor.addChild(root_1, stream_single_valued_path_expression.nextTree());\n                                // org/batoo/jpa/jpql/JpqlParser.g:476:48: ( NOT )?\n                                if (stream_NOT.hasNext()) {\n                                    adaptor.addChild(root_1, stream_NOT.nextNode());\n                                }\n                                stream_NOT.reset();\n                                adaptor.addChild(root_0, root_1);\n                            }\n                        }\n                        retval.tree = root_0;\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:477:6: input_parameter IS ( NOT )? NULL\n                {\n                    pushFollow(FOLLOW_input_parameter_in_null_comparison_expression4073);\n                    input_parameter463 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_input_parameter.add(input_parameter463.getTree());\n                    IS464 = (Token) match(input, IS, FOLLOW_IS_in_null_comparison_expression4075);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_IS.add(IS464);\n                    // org/batoo/jpa/jpql/JpqlParser.g:477:25: ( NOT )?\n                    int alt99 = 2;\n                    switch(input.LA(1)) {\n                        case NOT:\n                            {\n                                alt99 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt99) {\n                        case 1:\n                            // org/batoo/jpa/jpql/JpqlParser.g:477:26: NOT\n                            {\n                                NOT465 = (Token) match(input, NOT, FOLLOW_NOT_in_null_comparison_expression4078);\n                                if (state.failed)\n                                    return retval;\n                                if (state.backtracking == 0)\n                                    stream_NOT.add(NOT465);\n                            }\n                            break;\n                    }\n                    NULL466 = (Token) match(input, NULL, FOLLOW_NULL_in_null_comparison_expression4082);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        stream_NULL.add(NULL466);\n                    // AST REWRITE\n                    // elements: NOT, input_parameter\n                    // token labels:\n                    // rule labels: retval\n                    // token list labels:\n                    // rule list labels:\n                    // wildcard labels:\n                    if (state.backtracking == 0) {\n                        retval.tree = root_0;\n                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                        root_0 = (CommonTree) adaptor.nil();\n                        // 478:5: -> ^( ST_NULL input_parameter ( NOT )? )\n                        {\n                            // org/batoo/jpa/jpql/JpqlParser.g:478:8: ^( ST_NULL input_parameter ( NOT )? )\n                            {\n                                CommonTree root_1 = (CommonTree) adaptor.nil();\n                                root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_NULL, \"ST_NULL\"), root_1);\n                                adaptor.addChild(root_1, stream_input_parameter.nextTree());\n                                // org/batoo/jpa/jpql/JpqlParser.g:478:34: ( NOT )?\n                                if (stream_NOT.hasNext()) {\n                                    adaptor.addChild(root_1, stream_NOT.nextNode());\n                                }\n                                stream_NOT.reset();\n                                adaptor.addChild(root_0, root_1);\n                            }\n                        }\n                        retval.tree = root_0;\n                    }\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:474:1: null_comparison_expression : ( single_valued_path_expression IS ( NOT )? NULL -> ^( ST_NULL single_valued_path_expression ( NOT )? ) | input_parameter IS ( NOT )? NULL -> ^( ST_NULL input_parameter ( NOT )? ) );\n", "repo_name": "BatooJPA-master/", "id": 1426, "method_signature": "JpqlParser.null_comparison_expression_return null_comparison_expression()"}, "JpqlParser.nullif_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.nullif_expression", "method_implementation": "{\n    JpqlParser.nullif_expression_return retval = new JpqlParser.nullif_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token NULLIF155 = null;\n    Token Left_Paren156 = null;\n    Token Comma158 = null;\n    Token Right_Paren160 = null;\n    JpqlParser.scalar_expression_return scalar_expression157 = null;\n    JpqlParser.scalar_expression_return scalar_expression159 = null;\n    CommonTree NULLIF155_tree = null;\n    CommonTree Left_Paren156_tree = null;\n    CommonTree Comma158_tree = null;\n    CommonTree Right_Paren160_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:224:19: ( NULLIF ^ Left_Paren ! scalar_expression Comma ! scalar_expression Right_Paren !)\n        // org/batoo/jpa/jpql/JpqlParser.g:225:2: NULLIF ^ Left_Paren ! scalar_expression Comma ! scalar_expression Right_Paren !\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            NULLIF155 = (Token) match(input, NULLIF, FOLLOW_NULLIF_in_nullif_expression1985);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                NULLIF155_tree = (CommonTree) adaptor.create(NULLIF155);\n                root_0 = (CommonTree) adaptor.becomeRoot(NULLIF155_tree, root_0);\n            }\n            Left_Paren156 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_nullif_expression1988);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_scalar_expression_in_nullif_expression1991);\n            scalar_expression157 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, scalar_expression157.getTree());\n            Comma158 = (Token) match(input, Comma, FOLLOW_Comma_in_nullif_expression1993);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_scalar_expression_in_nullif_expression1996);\n            scalar_expression159 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, scalar_expression159.getTree());\n            Right_Paren160 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_nullif_expression1998);\n            if (state.failed)\n                return retval;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:224:1: nullif_expression : NULLIF ^ Left_Paren ! scalar_expression Comma ! scalar_expression Right_Paren !;\n", "repo_name": "BatooJPA-master/", "id": 1383, "method_signature": "JpqlParser.nullif_expression_return nullif_expression()"}, "JpqlParser.orderby_clause": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.orderby_item_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.orderby_item_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.orderby_clause", "method_implementation": "{\n    JpqlParser.orderby_clause_return retval = new JpqlParser.orderby_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ORDER25 = null;\n    Token BY26 = null;\n    Token Comma28 = null;\n    JpqlParser.orderby_item_return orderby_item27 = null;\n    JpqlParser.orderby_item_return orderby_item29 = null;\n    CommonTree ORDER25_tree = null;\n    CommonTree BY26_tree = null;\n    CommonTree Comma28_tree = null;\n    RewriteRuleTokenStream stream_BY = new RewriteRuleTokenStream(adaptor, \"token BY\");\n    RewriteRuleTokenStream stream_ORDER = new RewriteRuleTokenStream(adaptor, \"token ORDER\");\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_orderby_item = new RewriteRuleSubtreeStream(adaptor, \"rule orderby_item\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:92:16: ( ORDER BY orderby_item ( Comma orderby_item )* -> ^( LORDER orderby_item ( orderby_item )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:93:4: ORDER BY orderby_item ( Comma orderby_item )*\n        {\n            ORDER25 = (Token) match(input, ORDER, FOLLOW_ORDER_in_orderby_clause500);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ORDER.add(ORDER25);\n            BY26 = (Token) match(input, BY, FOLLOW_BY_in_orderby_clause502);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_BY.add(BY26);\n            pushFollow(FOLLOW_orderby_item_in_orderby_clause504);\n            orderby_item27 = orderby_item();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_orderby_item.add(orderby_item27.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:93:26: ( Comma orderby_item )*\n            loop6: do {\n                int alt6 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt6 = 1;\n                        }\n                        break;\n                }\n                switch(alt6) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:93:27: Comma orderby_item\n                        {\n                            Comma28 = (Token) match(input, Comma, FOLLOW_Comma_in_orderby_clause507);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma28);\n                            pushFollow(FOLLOW_orderby_item_in_orderby_clause509);\n                            orderby_item29 = orderby_item();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_orderby_item.add(orderby_item29.getTree());\n                        }\n                        break;\n                    default:\n                        break loop6;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: orderby_item, orderby_item\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 94:5: -> ^( LORDER orderby_item ( orderby_item )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:94:8: ^( LORDER orderby_item ( orderby_item )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LORDER, \"LORDER\"), root_1);\n                        adaptor.addChild(root_1, stream_orderby_item.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:94:30: ( orderby_item )*\n                        while (stream_orderby_item.hasNext()) {\n                            adaptor.addChild(root_1, stream_orderby_item.nextTree());\n                        }\n                        stream_orderby_item.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:92:1: orderby_clause : ORDER BY orderby_item ( Comma orderby_item )* -> ^( LORDER orderby_item ( orderby_item )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1351, "method_signature": "JpqlParser.orderby_clause_return orderby_clause()"}, "JpqlParser.orderby_item": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.scalar_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.orderby_item", "method_implementation": "{\n    JpqlParser.orderby_item_return retval = new JpqlParser.orderby_item_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ASC67 = null;\n    Token DESC68 = null;\n    JpqlParser.scalar_expression_return scalar_expression66 = null;\n    CommonTree ASC67_tree = null;\n    CommonTree DESC68_tree = null;\n    RewriteRuleTokenStream stream_ASC = new RewriteRuleTokenStream(adaptor, \"token ASC\");\n    RewriteRuleTokenStream stream_DESC = new RewriteRuleTokenStream(adaptor, \"token DESC\");\n    RewriteRuleSubtreeStream stream_scalar_expression = new RewriteRuleSubtreeStream(adaptor, \"rule scalar_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:123:14: ( ( scalar_expression ) ( ASC | DESC )? -> ^( ST_ORDER ( scalar_expression )? ( DESC )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:124:4: ( scalar_expression ) ( ASC | DESC )?\n        {\n            // org/batoo/jpa/jpql/JpqlParser.g:124:4: ( scalar_expression )\n            // org/batoo/jpa/jpql/JpqlParser.g:124:5: scalar_expression\n            {\n                pushFollow(FOLLOW_scalar_expression_in_orderby_item834);\n                scalar_expression66 = scalar_expression();\n                state._fsp--;\n                if (state.failed)\n                    return retval;\n                if (state.backtracking == 0)\n                    stream_scalar_expression.add(scalar_expression66.getTree());\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:124:24: ( ASC | DESC )?\n            int alt22 = 3;\n            switch(input.LA(1)) {\n                case ASC:\n                    {\n                        alt22 = 1;\n                    }\n                    break;\n                case DESC:\n                    {\n                        alt22 = 2;\n                    }\n                    break;\n            }\n            switch(alt22) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:124:25: ASC\n                    {\n                        ASC67 = (Token) match(input, ASC, FOLLOW_ASC_in_orderby_item838);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ASC.add(ASC67);\n                    }\n                    break;\n                case 2:\n                    // org/batoo/jpa/jpql/JpqlParser.g:124:31: DESC\n                    {\n                        DESC68 = (Token) match(input, DESC, FOLLOW_DESC_in_orderby_item842);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_DESC.add(DESC68);\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: scalar_expression, DESC\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 125:5: -> ^( ST_ORDER ( scalar_expression )? ( DESC )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:125:8: ^( ST_ORDER ( scalar_expression )? ( DESC )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ORDER, \"ST_ORDER\"), root_1);\n                        // org/batoo/jpa/jpql/JpqlParser.g:125:19: ( scalar_expression )?\n                        if (stream_scalar_expression.hasNext()) {\n                            adaptor.addChild(root_1, stream_scalar_expression.nextTree());\n                        }\n                        stream_scalar_expression.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:125:40: ( DESC )?\n                        if (stream_DESC.hasNext()) {\n                            adaptor.addChild(root_1, stream_DESC.nextNode());\n                        }\n                        stream_DESC.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:123:1: orderby_item : ( scalar_expression ) ( ASC | DESC )? -> ^( ST_ORDER ( scalar_expression )? ( DESC )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1359, "method_signature": "JpqlParser.orderby_item_return orderby_item()"}, "JpqlParser.qid": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.qid", "method_implementation": "{\n    JpqlParser.qid_return retval = new JpqlParser.qid_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID456 = null;\n    Token Period457 = null;\n    Token ID458 = null;\n    CommonTree ID456_tree = null;\n    CommonTree Period457_tree = null;\n    CommonTree ID458_tree = null;\n    RewriteRuleTokenStream stream_Period = new RewriteRuleTokenStream(adaptor, \"token Period\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:470:5: ( ID ( Period ID )* -> ^( LQUALIFIED ID ( ID )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:471:5: ID ( Period ID )*\n        {\n            ID456 = (Token) match(input, ID, FOLLOW_ID_in_qid3992);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ID.add(ID456);\n            // org/batoo/jpa/jpql/JpqlParser.g:471:8: ( Period ID )*\n            loop97: do {\n                int alt97 = 2;\n                switch(input.LA(1)) {\n                    case Period:\n                        {\n                            alt97 = 1;\n                        }\n                        break;\n                }\n                switch(alt97) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:471:10: Period ID\n                        {\n                            Period457 = (Token) match(input, Period, FOLLOW_Period_in_qid3996);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Period.add(Period457);\n                            ID458 = (Token) match(input, ID, FOLLOW_ID_in_qid3998);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_ID.add(ID458);\n                        }\n                        break;\n                    default:\n                        break loop97;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: ID, ID\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 472:9: -> ^( LQUALIFIED ID ( ID )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:472:12: ^( LQUALIFIED ID ( ID )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LQUALIFIED, \"LQUALIFIED\"), root_1);\n                        adaptor.addChild(root_1, stream_ID.nextNode());\n                        // org/batoo/jpa/jpql/JpqlParser.g:472:28: ( ID )*\n                        while (stream_ID.hasNext()) {\n                            adaptor.addChild(root_1, stream_ID.nextNode());\n                        }\n                        stream_ID.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:470:1: qid : ID ( Period ID )* -> ^( LQUALIFIED ID ( ID )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1425, "method_signature": "JpqlParser.qid_return qid()"}, "JpqlParser.ql_statement": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.select_statement_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.update_statement_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.delete_statement_return.getTree", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.ql_statement", "method_implementation": "{\n    JpqlParser.ql_statement_return retval = new JpqlParser.ql_statement_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token EOF4 = null;\n    JpqlParser.select_statement_return select_statement1 = null;\n    JpqlParser.update_statement_return update_statement2 = null;\n    JpqlParser.delete_statement_return delete_statement3 = null;\n    CommonTree EOF4_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:69:14: ( ( select_statement | update_statement | delete_statement ) EOF )\n        // org/batoo/jpa/jpql/JpqlParser.g:70:5: ( select_statement | update_statement | delete_statement ) EOF\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            // org/batoo/jpa/jpql/JpqlParser.g:70:5: ( select_statement | update_statement | delete_statement )\n            int alt1 = 3;\n            switch(input.LA(1)) {\n                case SELECT:\n                    {\n                        alt1 = 1;\n                    }\n                    break;\n                case UPDATE:\n                    {\n                        alt1 = 2;\n                    }\n                    break;\n                case DELETE:\n                    {\n                        alt1 = 3;\n                    }\n                    break;\n                default:\n                    if (state.backtracking > 0) {\n                        state.failed = true;\n                        return retval;\n                    }\n                    NoViableAltException nvae = new NoViableAltException(\"\", 1, 0, input);\n                    throw nvae;\n            }\n            switch(alt1) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:70:6: select_statement\n                    {\n                        pushFollow(FOLLOW_select_statement_in_ql_statement324);\n                        select_statement1 = select_statement();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, select_statement1.getTree());\n                    }\n                    break;\n                case 2:\n                    // org/batoo/jpa/jpql/JpqlParser.g:70:25: update_statement\n                    {\n                        pushFollow(FOLLOW_update_statement_in_ql_statement328);\n                        update_statement2 = update_statement();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, update_statement2.getTree());\n                    }\n                    break;\n                case 3:\n                    // org/batoo/jpa/jpql/JpqlParser.g:70:44: delete_statement\n                    {\n                        pushFollow(FOLLOW_delete_statement_in_ql_statement332);\n                        delete_statement3 = delete_statement();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, delete_statement3.getTree());\n                    }\n                    break;\n            }\n            EOF4 = (Token) match(input, EOF, FOLLOW_EOF_in_ql_statement335);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                EOF4_tree = (CommonTree) adaptor.create(EOF4);\n                adaptor.addChild(root_0, EOF4_tree);\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:69:1: ql_statement : ( select_statement | update_statement | delete_statement ) EOF ;\n", "repo_name": "BatooJPA-master/", "id": 1345, "method_signature": "JpqlParser.ql_statement_return ql_statement()"}, "JpqlParser.qqid": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.id_or_reserved_word_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.id_or_reserved_word_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.qqid", "method_implementation": "{\n    JpqlParser.qqid_return retval = new JpqlParser.qqid_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Period107 = null;\n    JpqlParser.id_or_reserved_word_return id_or_reserved_word106 = null;\n    JpqlParser.id_or_reserved_word_return id_or_reserved_word108 = null;\n    CommonTree Period107_tree = null;\n    RewriteRuleTokenStream stream_Period = new RewriteRuleTokenStream(adaptor, \"token Period\");\n    RewriteRuleSubtreeStream stream_id_or_reserved_word = new RewriteRuleSubtreeStream(adaptor, \"rule id_or_reserved_word\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:173:6: ( id_or_reserved_word ( Period id_or_reserved_word )* -> ^( LQUALIFIED id_or_reserved_word ( id_or_reserved_word )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:174:5: id_or_reserved_word ( Period id_or_reserved_word )*\n        {\n            pushFollow(FOLLOW_id_or_reserved_word_in_qqid1193);\n            id_or_reserved_word106 = id_or_reserved_word();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_id_or_reserved_word.add(id_or_reserved_word106.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:174:25: ( Period id_or_reserved_word )*\n            loop32: do {\n                int alt32 = 2;\n                switch(input.LA(1)) {\n                    case Period:\n                        {\n                            alt32 = 1;\n                        }\n                        break;\n                }\n                switch(alt32) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:174:27: Period id_or_reserved_word\n                        {\n                            Period107 = (Token) match(input, Period, FOLLOW_Period_in_qqid1197);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Period.add(Period107);\n                            pushFollow(FOLLOW_id_or_reserved_word_in_qqid1199);\n                            id_or_reserved_word108 = id_or_reserved_word();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_id_or_reserved_word.add(id_or_reserved_word108.getTree());\n                        }\n                        break;\n                    default:\n                        break loop32;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: id_or_reserved_word, id_or_reserved_word\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 175:9: -> ^( LQUALIFIED id_or_reserved_word ( id_or_reserved_word )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:175:12: ^( LQUALIFIED id_or_reserved_word ( id_or_reserved_word )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LQUALIFIED, \"LQUALIFIED\"), root_1);\n                        adaptor.addChild(root_1, stream_id_or_reserved_word.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:175:45: ( id_or_reserved_word )*\n                        while (stream_id_or_reserved_word.hasNext()) {\n                            adaptor.addChild(root_1, stream_id_or_reserved_word.nextTree());\n                        }\n                        stream_id_or_reserved_word.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:173:1: qqid : id_or_reserved_word ( Period id_or_reserved_word )* -> ^( LQUALIFIED id_or_reserved_word ( id_or_reserved_word )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1371, "method_signature": "JpqlParser.qqid_return qqid()"}, "JpqlParser.qualified_identification_variable": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.qualified_identification_variable", "method_implementation": "{\n    JpqlParser.qualified_identification_variable_return retval = new JpqlParser.qualified_identification_variable_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token KEY95 = null;\n    Token ID96 = null;\n    Token VALUE97 = null;\n    Token ID98 = null;\n    Token ENTRY99 = null;\n    Token ID100 = null;\n    CommonTree KEY95_tree = null;\n    CommonTree ID96_tree = null;\n    CommonTree VALUE97_tree = null;\n    CommonTree ID98_tree = null;\n    CommonTree ENTRY99_tree = null;\n    CommonTree ID100_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:158:34: ( KEY ( ID ) | VALUE ( ID ) | ENTRY ( ID ) )\n        int alt30 = 3;\n        switch(input.LA(1)) {\n            case KEY:\n                {\n                    alt30 = 1;\n                }\n                break;\n            case VALUE:\n                {\n                    alt30 = 2;\n                }\n                break;\n            case ENTRY:\n                {\n                    alt30 = 3;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 30, 0, input);\n                throw nvae;\n        }\n        switch(alt30) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:159:2: KEY ( ID )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    KEY95 = (Token) match(input, KEY, FOLLOW_KEY_in_qualified_identification_variable1097);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        KEY95_tree = (CommonTree) adaptor.create(KEY95);\n                        adaptor.addChild(root_0, KEY95_tree);\n                    }\n                    // org/batoo/jpa/jpql/JpqlParser.g:159:6: ( ID )\n                    // org/batoo/jpa/jpql/JpqlParser.g:159:7: ID\n                    {\n                        ID96 = (Token) match(input, ID, FOLLOW_ID_in_qualified_identification_variable1100);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0) {\n                            ID96_tree = (CommonTree) adaptor.create(ID96);\n                            adaptor.addChild(root_0, ID96_tree);\n                        }\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:160:4: VALUE ( ID )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    VALUE97 = (Token) match(input, VALUE, FOLLOW_VALUE_in_qualified_identification_variable1106);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        VALUE97_tree = (CommonTree) adaptor.create(VALUE97);\n                        adaptor.addChild(root_0, VALUE97_tree);\n                    }\n                    // org/batoo/jpa/jpql/JpqlParser.g:160:10: ( ID )\n                    // org/batoo/jpa/jpql/JpqlParser.g:160:11: ID\n                    {\n                        ID98 = (Token) match(input, ID, FOLLOW_ID_in_qualified_identification_variable1109);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0) {\n                            ID98_tree = (CommonTree) adaptor.create(ID98);\n                            adaptor.addChild(root_0, ID98_tree);\n                        }\n                    }\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:161:4: ENTRY ( ID )\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    ENTRY99 = (Token) match(input, ENTRY, FOLLOW_ENTRY_in_qualified_identification_variable1115);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        ENTRY99_tree = (CommonTree) adaptor.create(ENTRY99);\n                        adaptor.addChild(root_0, ENTRY99_tree);\n                    }\n                    // org/batoo/jpa/jpql/JpqlParser.g:161:10: ( ID )\n                    // org/batoo/jpa/jpql/JpqlParser.g:161:11: ID\n                    {\n                        ID100 = (Token) match(input, ID, FOLLOW_ID_in_qualified_identification_variable1118);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0) {\n                            ID100_tree = (CommonTree) adaptor.create(ID100);\n                            adaptor.addChild(root_0, ID100_tree);\n                        }\n                    }\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:158:1: qualified_identification_variable : ( KEY ( ID ) | VALUE ( ID ) | ENTRY ( ID ) );\n", "repo_name": "BatooJPA-master/", "id": 1368, "method_signature": "JpqlParser.qualified_identification_variable_return qualified_identification_variable()"}, "JpqlParser.scalar_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.case_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.function_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_arithmetic_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.enum_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.datetime_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.boolean_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.entity_type_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.scalar_expression", "method_implementation": "{\n    JpqlParser.scalar_expression_return retval = new JpqlParser.scalar_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.case_expression_return case_expression167 = null;\n    JpqlParser.function_expression_return function_expression168 = null;\n    JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression169 = null;\n    JpqlParser.string_primary_return string_primary170 = null;\n    JpqlParser.enum_primary_return enum_primary171 = null;\n    JpqlParser.datetime_primary_return datetime_primary172 = null;\n    JpqlParser.boolean_primary_return boolean_primary173 = null;\n    JpqlParser.entity_type_expression_return entity_type_expression174 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:230:46: ( case_expression | function_expression | simple_arithmetic_expression | string_primary | enum_primary | datetime_primary | boolean_primary | entity_type_expression )\n        int alt40 = 8;\n        switch(input.LA(1)) {\n            case CASE:\n                {\n                    int LA40_1 = input.LA(2);\n                    if ((synpred5_JpqlParser())) {\n                        alt40 = 1;\n                    } else if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 1, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COALESCE:\n                {\n                    int LA40_2 = input.LA(2);\n                    if ((synpred5_JpqlParser())) {\n                        alt40 = 1;\n                    } else if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 2, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case NULLIF:\n                {\n                    int LA40_3 = input.LA(2);\n                    if ((synpred5_JpqlParser())) {\n                        alt40 = 1;\n                    } else if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 3, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case FUNC:\n                {\n                    int LA40_4 = input.LA(2);\n                    if ((synpred6_JpqlParser())) {\n                        alt40 = 2;\n                    } else if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 4, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case ABS:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case Left_Paren:\n            case MOD:\n            case Minus_Sign:\n            case NUMERIC_LITERAL:\n            case Plus_Sign:\n            case SIZE:\n            case SQRT:\n                {\n                    alt40 = 3;\n                }\n                break;\n            case ID:\n                {\n                    int LA40_6 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else if ((true)) {\n                        alt40 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 6, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CAST:\n                {\n                    int LA40_7 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 7, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Question_Sign:\n                {\n                    int LA40_10 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else if ((true)) {\n                        alt40 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 10, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Ordinal_Parameter:\n                {\n                    int LA40_11 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else if ((true)) {\n                        alt40 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 11, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Named_Parameter:\n                {\n                    int LA40_12 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred9_JpqlParser())) {\n                        alt40 = 5;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else if ((synpred11_JpqlParser())) {\n                        alt40 = 7;\n                    } else if ((true)) {\n                        alt40 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 12, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_DATE:\n                {\n                    int LA40_20 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 20, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIME:\n                {\n                    int LA40_21 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 21, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIMESTAMP:\n                {\n                    int LA40_22 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 22, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case SECOND:\n                {\n                    int LA40_23 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 23, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MINUTE:\n                {\n                    int LA40_24 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 24, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case HOUR:\n                {\n                    int LA40_25 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 25, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAY:\n                {\n                    int LA40_26 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 26, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFMONTH:\n                {\n                    int LA40_27 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 27, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFWEEK:\n                {\n                    int LA40_28 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 28, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFYEAR:\n                {\n                    int LA40_29 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 29, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case WEEK:\n                {\n                    int LA40_30 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 30, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MONTH:\n                {\n                    int LA40_31 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 31, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case YEAR:\n                {\n                    int LA40_32 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 32, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case AVG:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    int LA40_33 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 33, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COUNT:\n                {\n                    int LA40_34 = input.LA(2);\n                    if ((synpred7_JpqlParser())) {\n                        alt40 = 3;\n                    } else if ((synpred8_JpqlParser())) {\n                        alt40 = 4;\n                    } else if ((synpred10_JpqlParser())) {\n                        alt40 = 6;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 40, 34, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CONCAT:\n            case LOWER:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case TRIM:\n            case UPPER:\n                {\n                    alt40 = 4;\n                }\n                break;\n            case FALSE:\n            case TRUE:\n                {\n                    alt40 = 7;\n                }\n                break;\n            case TYPE:\n                {\n                    alt40 = 8;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 40, 0, input);\n                throw nvae;\n        }\n        switch(alt40) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:231:2: case_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_case_expression_in_scalar_expression2041);\n                    case_expression167 = case_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, case_expression167.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:232:4: function_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_function_expression_in_scalar_expression2046);\n                    function_expression168 = function_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, function_expression168.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:233:7: simple_arithmetic_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_arithmetic_expression_in_scalar_expression2054);\n                    simple_arithmetic_expression169 = simple_arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_arithmetic_expression169.getTree());\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:234:7: string_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_string_primary_in_scalar_expression2062);\n                    string_primary170 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary170.getTree());\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:235:7: enum_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_enum_primary_in_scalar_expression2070);\n                    enum_primary171 = enum_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, enum_primary171.getTree());\n                }\n                break;\n            case 6:\n                // org/batoo/jpa/jpql/JpqlParser.g:236:7: datetime_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_datetime_primary_in_scalar_expression2078);\n                    datetime_primary172 = datetime_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, datetime_primary172.getTree());\n                }\n                break;\n            case 7:\n                // org/batoo/jpa/jpql/JpqlParser.g:237:7: boolean_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_boolean_primary_in_scalar_expression2086);\n                    boolean_primary173 = boolean_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, boolean_primary173.getTree());\n                }\n                break;\n            case 8:\n                // org/batoo/jpa/jpql/JpqlParser.g:238:7: entity_type_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_entity_type_expression_in_scalar_expression2094);\n                    entity_type_expression174 = entity_type_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, entity_type_expression174.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:230:1: scalar_expression options {backtrack=true; } : ( case_expression | function_expression | simple_arithmetic_expression | string_primary | enum_primary | datetime_primary | boolean_primary | entity_type_expression );\n", "repo_name": "BatooJPA-master/", "id": 1385, "method_signature": "JpqlParser.scalar_expression_return scalar_expression()"}, "JpqlParser.select_clause": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.select_items_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.select_clause", "method_implementation": "{\n    JpqlParser.select_clause_return retval = new JpqlParser.select_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token SELECT78 = null;\n    Token DISTINCT79 = null;\n    JpqlParser.select_items_return select_items80 = null;\n    CommonTree SELECT78_tree = null;\n    CommonTree DISTINCT79_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:137:15: ( SELECT ^ ( DISTINCT )? select_items )\n        // org/batoo/jpa/jpql/JpqlParser.g:138:5: SELECT ^ ( DISTINCT )? select_items\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            SELECT78 = (Token) match(input, SELECT, FOLLOW_SELECT_in_select_clause946);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                SELECT78_tree = (CommonTree) adaptor.create(SELECT78);\n                root_0 = (CommonTree) adaptor.becomeRoot(SELECT78_tree, root_0);\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:138:13: ( DISTINCT )?\n            int alt24 = 2;\n            switch(input.LA(1)) {\n                case DISTINCT:\n                    {\n                        alt24 = 1;\n                    }\n                    break;\n            }\n            switch(alt24) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:138:14: DISTINCT\n                    {\n                        DISTINCT79 = (Token) match(input, DISTINCT, FOLLOW_DISTINCT_in_select_clause950);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0) {\n                            DISTINCT79_tree = (CommonTree) adaptor.create(DISTINCT79);\n                            adaptor.addChild(root_0, DISTINCT79_tree);\n                        }\n                    }\n                    break;\n            }\n            pushFollow(FOLLOW_select_items_in_select_clause954);\n            select_items80 = select_items();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, select_items80.getTree());\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:137:1: select_clause : SELECT ^ ( DISTINCT )? select_items ;\n", "repo_name": "BatooJPA-master/", "id": 1363, "method_signature": "JpqlParser.select_clause_return select_clause()"}, "JpqlParser.select_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.constructor_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.select_expression", "method_implementation": "{\n    JpqlParser.select_expression_return retval = new JpqlParser.select_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token OBJECT88 = null;\n    Token Left_Paren89 = null;\n    Token ID90 = null;\n    Token Right_Paren91 = null;\n    JpqlParser.scalar_expression_return scalar_expression87 = null;\n    JpqlParser.constructor_expression_return constructor_expression92 = null;\n    CommonTree OBJECT88_tree = null;\n    CommonTree Left_Paren89_tree = null;\n    CommonTree ID90_tree = null;\n    CommonTree Right_Paren91_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:148:19: ( scalar_expression | OBJECT ^ Left_Paren ! ID Right_Paren !| constructor_expression )\n        int alt28 = 3;\n        switch(input.LA(1)) {\n            case ABS:\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case CONCAT:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case FALSE:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case LOWER:\n            case Left_Paren:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MOD:\n            case MONTH:\n            case Minus_Sign:\n            case NULLIF:\n            case NUMERIC_LITERAL:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Plus_Sign:\n            case Question_Sign:\n            case SECOND:\n            case SIZE:\n            case SQRT:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case SUM:\n            case TRIM:\n            case TRUE:\n            case TYPE:\n            case UPPER:\n            case WEEK:\n            case YEAR:\n                {\n                    alt28 = 1;\n                }\n                break;\n            case OBJECT:\n                {\n                    alt28 = 2;\n                }\n                break;\n            case NEW:\n                {\n                    alt28 = 3;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 28, 0, input);\n                throw nvae;\n        }\n        switch(alt28) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:149:5: scalar_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_scalar_expression_in_select_expression1048);\n                    scalar_expression87 = scalar_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, scalar_expression87.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:150:7: OBJECT ^ Left_Paren ! ID Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    OBJECT88 = (Token) match(input, OBJECT, FOLLOW_OBJECT_in_select_expression1056);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        OBJECT88_tree = (CommonTree) adaptor.create(OBJECT88);\n                        root_0 = (CommonTree) adaptor.becomeRoot(OBJECT88_tree, root_0);\n                    }\n                    Left_Paren89 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_select_expression1059);\n                    if (state.failed)\n                        return retval;\n                    ID90 = (Token) match(input, ID, FOLLOW_ID_in_select_expression1062);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        ID90_tree = (CommonTree) adaptor.create(ID90);\n                        adaptor.addChild(root_0, ID90_tree);\n                    }\n                    Right_Paren91 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_select_expression1064);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:151:7: constructor_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_constructor_expression_in_select_expression1073);\n                    constructor_expression92 = constructor_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, constructor_expression92.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:148:1: select_expression : ( scalar_expression | OBJECT ^ Left_Paren ! ID Right_Paren !| constructor_expression );\n", "repo_name": "BatooJPA-master/", "id": 1366, "method_signature": "JpqlParser.select_expression_return select_expression()"}, "JpqlParser.select_expressions": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.select_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.select_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.select_expressions", "method_implementation": "{\n    JpqlParser.select_expressions_return retval = new JpqlParser.select_expressions_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Comma122 = null;\n    JpqlParser.select_expression_return select_expression121 = null;\n    JpqlParser.select_expression_return select_expression123 = null;\n    CommonTree Comma122_tree = null;\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_select_expression = new RewriteRuleSubtreeStream(adaptor, \"rule select_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:193:20: ( select_expression ( Comma select_expression )* -> ^( LSELECT select_expression ( select_expression )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:194:5: select_expression ( Comma select_expression )*\n        {\n            pushFollow(FOLLOW_select_expression_in_select_expressions1762);\n            select_expression121 = select_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_select_expression.add(select_expression121.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:194:23: ( Comma select_expression )*\n            loop33: do {\n                int alt33 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt33 = 1;\n                        }\n                        break;\n                }\n                switch(alt33) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:194:25: Comma select_expression\n                        {\n                            Comma122 = (Token) match(input, Comma, FOLLOW_Comma_in_select_expressions1766);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma122);\n                            pushFollow(FOLLOW_select_expression_in_select_expressions1768);\n                            select_expression123 = select_expression();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_select_expression.add(select_expression123.getTree());\n                        }\n                        break;\n                    default:\n                        break loop33;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: select_expression, select_expression\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 195:9: -> ^( LSELECT select_expression ( select_expression )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:195:12: ^( LSELECT select_expression ( select_expression )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LSELECT, \"LSELECT\"), root_1);\n                        adaptor.addChild(root_1, stream_select_expression.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:195:40: ( select_expression )*\n                        while (stream_select_expression.hasNext()) {\n                            adaptor.addChild(root_1, stream_select_expression.nextTree());\n                        }\n                        stream_select_expression.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:193:1: select_expressions : select_expression ( Comma select_expression )* -> ^( LSELECT select_expression ( select_expression )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1375, "method_signature": "JpqlParser.select_expressions_return select_expressions()"}, "JpqlParser.select_item": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.select_expression_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleTokenStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "RewriteRuleTokenStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.select_item", "method_implementation": "{\n    JpqlParser.select_item_return retval = new JpqlParser.select_item_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token AS85 = null;\n    Token ID86 = null;\n    JpqlParser.select_expression_return select_expression84 = null;\n    CommonTree AS85_tree = null;\n    CommonTree ID86_tree = null;\n    RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor, \"token AS\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    RewriteRuleSubtreeStream stream_select_expression = new RewriteRuleSubtreeStream(adaptor, \"rule select_expression\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:144:13: ( select_expression ( ( AS )? ID )? -> ^( ST_ID_AS select_expression ( ID )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:145:5: select_expression ( ( AS )? ID )?\n        {\n            pushFollow(FOLLOW_select_expression_in_select_item1007);\n            select_expression84 = select_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_select_expression.add(select_expression84.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:145:23: ( ( AS )? ID )?\n            int alt27 = 2;\n            switch(input.LA(1)) {\n                case AS:\n                case ID:\n                    {\n                        alt27 = 1;\n                    }\n                    break;\n            }\n            switch(alt27) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:145:24: ( AS )? ID\n                    {\n                        // org/batoo/jpa/jpql/JpqlParser.g:145:24: ( AS )?\n                        int alt26 = 2;\n                        switch(input.LA(1)) {\n                            case AS:\n                                {\n                                    alt26 = 1;\n                                }\n                                break;\n                        }\n                        switch(alt26) {\n                            case 1:\n                                // org/batoo/jpa/jpql/JpqlParser.g:145:24: AS\n                                {\n                                    AS85 = (Token) match(input, AS, FOLLOW_AS_in_select_item1010);\n                                    if (state.failed)\n                                        return retval;\n                                    if (state.backtracking == 0)\n                                        stream_AS.add(AS85);\n                                }\n                                break;\n                        }\n                        ID86 = (Token) match(input, ID, FOLLOW_ID_in_select_item1013);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_ID.add(ID86);\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: ID, select_expression\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 146:9: -> ^( ST_ID_AS select_expression ( ID )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:146:12: ^( ST_ID_AS select_expression ( ID )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_ID_AS, \"ST_ID_AS\"), root_1);\n                        adaptor.addChild(root_1, stream_select_expression.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:146:41: ( ID )?\n                        if (stream_ID.hasNext()) {\n                            adaptor.addChild(root_1, stream_ID.nextNode());\n                        }\n                        stream_ID.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:144:1: select_item : select_expression ( ( AS )? ID )? -> ^( ST_ID_AS select_expression ( ID )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1365, "method_signature": "JpqlParser.select_item_return select_item()"}, "JpqlParser.select_items": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.select_item_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.select_item_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.select_items", "method_implementation": "{\n    JpqlParser.select_items_return retval = new JpqlParser.select_items_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Comma82 = null;\n    JpqlParser.select_item_return select_item81 = null;\n    JpqlParser.select_item_return select_item83 = null;\n    CommonTree Comma82_tree = null;\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_select_item = new RewriteRuleSubtreeStream(adaptor, \"rule select_item\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:140:14: ( select_item ( Comma select_item )* -> ^( LSELECT select_item ( select_item )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:141:5: select_item ( Comma select_item )*\n        {\n            pushFollow(FOLLOW_select_item_in_select_items966);\n            select_item81 = select_item();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_select_item.add(select_item81.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:141:17: ( Comma select_item )*\n            loop25: do {\n                int alt25 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt25 = 1;\n                        }\n                        break;\n                }\n                switch(alt25) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:141:19: Comma select_item\n                        {\n                            Comma82 = (Token) match(input, Comma, FOLLOW_Comma_in_select_items970);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma82);\n                            pushFollow(FOLLOW_select_item_in_select_items972);\n                            select_item83 = select_item();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_select_item.add(select_item83.getTree());\n                        }\n                        break;\n                    default:\n                        break loop25;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: select_item, select_item\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 142:9: -> ^( LSELECT select_item ( select_item )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:142:12: ^( LSELECT select_item ( select_item )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LSELECT, \"LSELECT\"), root_1);\n                        adaptor.addChild(root_1, stream_select_item.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:142:34: ( select_item )*\n                        while (stream_select_item.hasNext()) {\n                            adaptor.addChild(root_1, stream_select_item.nextTree());\n                        }\n                        stream_select_item.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:140:1: select_items : select_item ( Comma select_item )* -> ^( LSELECT select_item ( select_item )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1364, "method_signature": "JpqlParser.select_items_return select_items()"}, "JpqlParser.select_statement": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.select_clause_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.from_clause_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.where_clause_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.groupby_clause_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.having_clause_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.orderby_clause_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.select_statement", "method_implementation": "{\n    JpqlParser.select_statement_return retval = new JpqlParser.select_statement_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.select_clause_return select_clause30 = null;\n    JpqlParser.from_clause_return from_clause31 = null;\n    JpqlParser.where_clause_return where_clause32 = null;\n    JpqlParser.groupby_clause_return groupby_clause33 = null;\n    JpqlParser.having_clause_return having_clause34 = null;\n    JpqlParser.orderby_clause_return orderby_clause35 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:96:18: ( select_clause from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? ( orderby_clause )? )\n        // org/batoo/jpa/jpql/JpqlParser.g:97:5: select_clause from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? ( orderby_clause )?\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            pushFollow(FOLLOW_select_clause_in_select_statement540);\n            select_clause30 = select_clause();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, select_clause30.getTree());\n            pushFollow(FOLLOW_from_clause_in_select_statement542);\n            from_clause31 = from_clause();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, from_clause31.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:97:31: ( where_clause )?\n            int alt7 = 2;\n            switch(input.LA(1)) {\n                case WHERE:\n                    {\n                        alt7 = 1;\n                    }\n                    break;\n            }\n            switch(alt7) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:97:32: where_clause\n                    {\n                        pushFollow(FOLLOW_where_clause_in_select_statement545);\n                        where_clause32 = where_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, where_clause32.getTree());\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:97:47: ( groupby_clause )?\n            int alt8 = 2;\n            switch(input.LA(1)) {\n                case GROUP:\n                    {\n                        alt8 = 1;\n                    }\n                    break;\n            }\n            switch(alt8) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:97:48: groupby_clause\n                    {\n                        pushFollow(FOLLOW_groupby_clause_in_select_statement550);\n                        groupby_clause33 = groupby_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, groupby_clause33.getTree());\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:97:65: ( having_clause )?\n            int alt9 = 2;\n            switch(input.LA(1)) {\n                case HAVING:\n                    {\n                        alt9 = 1;\n                    }\n                    break;\n            }\n            switch(alt9) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:97:66: having_clause\n                    {\n                        pushFollow(FOLLOW_having_clause_in_select_statement555);\n                        having_clause34 = having_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, having_clause34.getTree());\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:97:82: ( orderby_clause )?\n            int alt10 = 2;\n            switch(input.LA(1)) {\n                case ORDER:\n                    {\n                        alt10 = 1;\n                    }\n                    break;\n            }\n            switch(alt10) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:97:83: orderby_clause\n                    {\n                        pushFollow(FOLLOW_orderby_clause_in_select_statement560);\n                        orderby_clause35 = orderby_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, orderby_clause35.getTree());\n                    }\n                    break;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:96:1: select_statement : select_clause from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? ( orderby_clause )? ;\n", "repo_name": "BatooJPA-master/", "id": 1352, "method_signature": "JpqlParser.select_statement_return select_statement()"}, "JpqlParser.simple_arithmetic_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_term_return.getTree", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "JpqlParser.arithmetic_term_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_arithmetic_expression", "method_implementation": "{\n    JpqlParser.simple_arithmetic_expression_return retval = new JpqlParser.simple_arithmetic_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token set176 = null;\n    JpqlParser.arithmetic_term_return arithmetic_term175 = null;\n    JpqlParser.arithmetic_term_return arithmetic_term177 = null;\n    CommonTree set176_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:241:30: ( arithmetic_term ( ( Plus_Sign | Minus_Sign ) ^ arithmetic_term )? )\n        // org/batoo/jpa/jpql/JpqlParser.g:242:5: arithmetic_term ( ( Plus_Sign | Minus_Sign ) ^ arithmetic_term )?\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            pushFollow(FOLLOW_arithmetic_term_in_simple_arithmetic_expression2111);\n            arithmetic_term175 = arithmetic_term();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, arithmetic_term175.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:242:21: ( ( Plus_Sign | Minus_Sign ) ^ arithmetic_term )?\n            int alt41 = 2;\n            switch(input.LA(1)) {\n                case Minus_Sign:\n                case Plus_Sign:\n                    {\n                        alt41 = 1;\n                    }\n                    break;\n            }\n            switch(alt41) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:242:22: ( Plus_Sign | Minus_Sign ) ^ arithmetic_term\n                    {\n                        set176 = (Token) input.LT(1);\n                        set176 = (Token) input.LT(1);\n                        if (input.LA(1) == Minus_Sign || input.LA(1) == Plus_Sign) {\n                            input.consume();\n                            if (state.backtracking == 0)\n                                root_0 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(set176), root_0);\n                            state.errorRecovery = false;\n                            state.failed = false;\n                        } else {\n                            if (state.backtracking > 0) {\n                                state.failed = true;\n                                return retval;\n                            }\n                            MismatchedSetException mse = new MismatchedSetException(null, input);\n                            throw mse;\n                        }\n                        pushFollow(FOLLOW_arithmetic_term_in_simple_arithmetic_expression2123);\n                        arithmetic_term177 = arithmetic_term();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, arithmetic_term177.getTree());\n                    }\n                    break;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:241:1: simple_arithmetic_expression : arithmetic_term ( ( Plus_Sign | Minus_Sign ) ^ arithmetic_term )? ;\n", "repo_name": "BatooJPA-master/", "id": 1386, "method_signature": "JpqlParser.simple_arithmetic_expression_return simple_arithmetic_expression()"}, "JpqlParser.simple_case_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.case_operand_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.simple_when_clause_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_case_expression", "method_implementation": "{\n    JpqlParser.simple_case_expression_return retval = new JpqlParser.simple_case_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token CASE137 = null;\n    Token ELSE140 = null;\n    Token END142 = null;\n    JpqlParser.case_operand_return case_operand138 = null;\n    JpqlParser.simple_when_clause_return simple_when_clause139 = null;\n    JpqlParser.scalar_expression_return scalar_expression141 = null;\n    CommonTree CASE137_tree = null;\n    CommonTree ELSE140_tree = null;\n    CommonTree END142_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:211:24: ( CASE ^ case_operand ( simple_when_clause )+ ELSE ! scalar_expression END !)\n        // org/batoo/jpa/jpql/JpqlParser.g:212:2: CASE ^ case_operand ( simple_when_clause )+ ELSE ! scalar_expression END !\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            CASE137 = (Token) match(input, CASE, FOLLOW_CASE_in_simple_case_expression1891);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                CASE137_tree = (CommonTree) adaptor.create(CASE137);\n                root_0 = (CommonTree) adaptor.becomeRoot(CASE137_tree, root_0);\n            }\n            pushFollow(FOLLOW_case_operand_in_simple_case_expression1894);\n            case_operand138 = case_operand();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, case_operand138.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:212:21: ( simple_when_clause )+\n            int cnt36 = 0;\n            loop36: do {\n                int alt36 = 2;\n                switch(input.LA(1)) {\n                    case WHEN:\n                        {\n                            alt36 = 1;\n                        }\n                        break;\n                }\n                switch(alt36) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:212:22: simple_when_clause\n                        {\n                            pushFollow(FOLLOW_simple_when_clause_in_simple_case_expression1897);\n                            simple_when_clause139 = simple_when_clause();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                adaptor.addChild(root_0, simple_when_clause139.getTree());\n                        }\n                        break;\n                    default:\n                        if (cnt36 >= 1)\n                            break loop36;\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        EarlyExitException eee = new EarlyExitException(36, input);\n                        throw eee;\n                }\n                cnt36++;\n            } while (true);\n            ELSE140 = (Token) match(input, ELSE, FOLLOW_ELSE_in_simple_case_expression1901);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_scalar_expression_in_simple_case_expression1904);\n            scalar_expression141 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, scalar_expression141.getTree());\n            END142 = (Token) match(input, END, FOLLOW_END_in_simple_case_expression1906);\n            if (state.failed)\n                return retval;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:211:1: simple_case_expression : CASE ^ case_operand ( simple_when_clause )+ ELSE ! scalar_expression END !;\n", "repo_name": "BatooJPA-master/", "id": 1379, "method_signature": "JpqlParser.simple_case_expression_return simple_case_expression()"}, "JpqlParser.simple_cond_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.collection_member_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.exists_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.in_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.empty_collection_comparison_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.null_comparison_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.comparison_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.between_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.like_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.boolean_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_cond_expression", "method_implementation": "{\n    JpqlParser.simple_cond_expression_return retval = new JpqlParser.simple_cond_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.collection_member_expression_return collection_member_expression283 = null;\n    JpqlParser.exists_expression_return exists_expression284 = null;\n    JpqlParser.in_expression_return in_expression285 = null;\n    JpqlParser.empty_collection_comparison_expression_return empty_collection_comparison_expression286 = null;\n    JpqlParser.null_comparison_expression_return null_comparison_expression287 = null;\n    JpqlParser.comparison_expression_return comparison_expression288 = null;\n    JpqlParser.between_expression_return between_expression289 = null;\n    JpqlParser.like_expression_return like_expression290 = null;\n    JpqlParser.boolean_expression_return boolean_expression291 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:303:52: ( collection_member_expression | exists_expression | in_expression | empty_collection_comparison_expression | null_comparison_expression | comparison_expression | between_expression | like_expression | boolean_expression )\n        int alt62 = 9;\n        switch(input.LA(1)) {\n            case Question_Sign:\n                {\n                    int LA62_1 = input.LA(2);\n                    if ((synpred13_JpqlParser())) {\n                        alt62 = 1;\n                    } else if ((synpred15_JpqlParser())) {\n                        alt62 = 3;\n                    } else if ((synpred17_JpqlParser())) {\n                        alt62 = 5;\n                    } else if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 1, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Ordinal_Parameter:\n                {\n                    int LA62_2 = input.LA(2);\n                    if ((synpred13_JpqlParser())) {\n                        alt62 = 1;\n                    } else if ((synpred15_JpqlParser())) {\n                        alt62 = 3;\n                    } else if ((synpred17_JpqlParser())) {\n                        alt62 = 5;\n                    } else if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 2, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Named_Parameter:\n                {\n                    int LA62_3 = input.LA(2);\n                    if ((synpred13_JpqlParser())) {\n                        alt62 = 1;\n                    } else if ((synpred15_JpqlParser())) {\n                        alt62 = 3;\n                    } else if ((synpred17_JpqlParser())) {\n                        alt62 = 5;\n                    } else if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 3, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case ID:\n                {\n                    int LA62_4 = input.LA(2);\n                    if ((synpred13_JpqlParser())) {\n                        alt62 = 1;\n                    } else if ((synpred15_JpqlParser())) {\n                        alt62 = 3;\n                    } else if ((synpred16_JpqlParser())) {\n                        alt62 = 4;\n                    } else if ((synpred17_JpqlParser())) {\n                        alt62 = 5;\n                    } else if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 4, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case STRING_LITERAL:\n                {\n                    int LA62_5 = input.LA(2);\n                    if ((synpred13_JpqlParser())) {\n                        alt62 = 1;\n                    } else if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 5, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case NUMERIC_LITERAL:\n                {\n                    int LA62_6 = input.LA(2);\n                    if ((synpred13_JpqlParser())) {\n                        alt62 = 1;\n                    } else if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 6, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CAST:\n                {\n                    int LA62_7 = input.LA(2);\n                    if ((synpred13_JpqlParser())) {\n                        alt62 = 1;\n                    } else if ((synpred15_JpqlParser())) {\n                        alt62 = 3;\n                    } else if ((synpred16_JpqlParser())) {\n                        alt62 = 4;\n                    } else if ((synpred17_JpqlParser())) {\n                        alt62 = 5;\n                    } else if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 7, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case EXISTS:\n                {\n                    alt62 = 2;\n                }\n                break;\n            case ENTRY:\n            case KEY:\n            case VALUE:\n                {\n                    alt62 = 5;\n                }\n                break;\n            case Plus_Sign:\n                {\n                    int LA62_12 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 12, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case FUNC:\n                {\n                    int LA62_13 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 13, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Left_Paren:\n                {\n                    int LA62_14 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 14, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case LENGTH:\n                {\n                    int LA62_15 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 15, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case LOCATE:\n                {\n                    int LA62_16 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 16, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case ABS:\n                {\n                    int LA62_17 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 17, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case SQRT:\n                {\n                    int LA62_18 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 18, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MOD:\n                {\n                    int LA62_19 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 19, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case SIZE:\n                {\n                    int LA62_20 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 20, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case INDEX:\n                {\n                    int LA62_21 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 21, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_DATE:\n                {\n                    int LA62_22 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 22, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIME:\n                {\n                    int LA62_23 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 23, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CURRENT_TIMESTAMP:\n                {\n                    int LA62_24 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 24, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case SECOND:\n                {\n                    int LA62_25 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 25, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MINUTE:\n                {\n                    int LA62_26 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 26, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case HOUR:\n                {\n                    int LA62_27 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 27, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAY:\n                {\n                    int LA62_28 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 28, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFMONTH:\n                {\n                    int LA62_29 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 29, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFWEEK:\n                {\n                    int LA62_30 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 30, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case DAYOFYEAR:\n                {\n                    int LA62_31 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 31, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case WEEK:\n                {\n                    int LA62_32 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 32, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case MONTH:\n                {\n                    int LA62_33 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 33, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case YEAR:\n                {\n                    int LA62_34 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 34, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case AVG:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    int LA62_35 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 35, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COUNT:\n                {\n                    int LA62_36 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 36, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CASE:\n                {\n                    int LA62_37 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 37, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case COALESCE:\n                {\n                    int LA62_38 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 38, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case NULLIF:\n                {\n                    int LA62_39 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 39, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case Minus_Sign:\n                {\n                    int LA62_40 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 40, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case SUBSTRING:\n                {\n                    int LA62_41 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 41, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case CONCAT:\n                {\n                    int LA62_42 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 42, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case TRIM:\n                {\n                    int LA62_43 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 43, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case LOWER:\n                {\n                    int LA62_44 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 44, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case UPPER:\n                {\n                    int LA62_45 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((synpred19_JpqlParser())) {\n                        alt62 = 7;\n                    } else if ((synpred20_JpqlParser())) {\n                        alt62 = 8;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 45, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case FALSE:\n            case TRUE:\n                {\n                    int LA62_46 = input.LA(2);\n                    if ((synpred18_JpqlParser())) {\n                        alt62 = 6;\n                    } else if ((true)) {\n                        alt62 = 9;\n                    } else {\n                        if (state.backtracking > 0) {\n                            state.failed = true;\n                            return retval;\n                        }\n                        NoViableAltException nvae = new NoViableAltException(\"\", 62, 46, input);\n                        throw nvae;\n                    }\n                }\n                break;\n            case TYPE:\n                {\n                    alt62 = 6;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 62, 0, input);\n                throw nvae;\n        }\n        switch(alt62) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:304:5: collection_member_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_collection_member_expression_in_simple_cond_expression2739);\n                    collection_member_expression283 = collection_member_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, collection_member_expression283.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:305:6: exists_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_exists_expression_in_simple_cond_expression2746);\n                    exists_expression284 = exists_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, exists_expression284.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:306:7: in_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_in_expression_in_simple_cond_expression2754);\n                    in_expression285 = in_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, in_expression285.getTree());\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:307:7: empty_collection_comparison_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_empty_collection_comparison_expression_in_simple_cond_expression2762);\n                    empty_collection_comparison_expression286 = empty_collection_comparison_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, empty_collection_comparison_expression286.getTree());\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:308:7: null_comparison_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_null_comparison_expression_in_simple_cond_expression2770);\n                    null_comparison_expression287 = null_comparison_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, null_comparison_expression287.getTree());\n                }\n                break;\n            case 6:\n                // org/batoo/jpa/jpql/JpqlParser.g:309:7: comparison_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_comparison_expression_in_simple_cond_expression2778);\n                    comparison_expression288 = comparison_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, comparison_expression288.getTree());\n                }\n                break;\n            case 7:\n                // org/batoo/jpa/jpql/JpqlParser.g:310:7: between_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_between_expression_in_simple_cond_expression2786);\n                    between_expression289 = between_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, between_expression289.getTree());\n                }\n                break;\n            case 8:\n                // org/batoo/jpa/jpql/JpqlParser.g:311:7: like_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_like_expression_in_simple_cond_expression2794);\n                    like_expression290 = like_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, like_expression290.getTree());\n                }\n                break;\n            case 9:\n                // org/batoo/jpa/jpql/JpqlParser.g:312:7: boolean_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_boolean_expression_in_simple_cond_expression2802);\n                    boolean_expression291 = boolean_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, boolean_expression291.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:303:1: simple_cond_expression options {backtrack=true; } : ( collection_member_expression | exists_expression | in_expression | empty_collection_comparison_expression | null_comparison_expression | comparison_expression | between_expression | like_expression | boolean_expression );\n", "repo_name": "BatooJPA-master/", "id": 1397, "method_signature": "JpqlParser.simple_cond_expression_return simple_cond_expression()"}, "JpqlParser.simple_entity_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_entity_expression", "method_implementation": "{\n    JpqlParser.simple_entity_expression_return retval = new JpqlParser.simple_entity_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID445 = null;\n    JpqlParser.input_parameter_return input_parameter446 = null;\n    CommonTree ID445_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:451:26: ( ID | input_parameter )\n        int alt92 = 2;\n        switch(input.LA(1)) {\n            case ID:\n                {\n                    alt92 = 1;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt92 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 92, 0, input);\n                throw nvae;\n        }\n        switch(alt92) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:452:2: ID\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    ID445 = (Token) match(input, ID, FOLLOW_ID_in_simple_entity_expression3857);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        ID445_tree = (CommonTree) adaptor.create(ID445);\n                        adaptor.addChild(root_0, ID445_tree);\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:453:4: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_simple_entity_expression3863);\n                    input_parameter446 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter446.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:451:1: simple_entity_expression : ( ID | input_parameter );\n", "repo_name": "BatooJPA-master/", "id": 1421, "method_signature": "JpqlParser.simple_entity_expression_return simple_entity_expression()"}, "JpqlParser.simple_entity_or_value_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_entity_or_value_expression", "method_implementation": "{\n    JpqlParser.simple_entity_or_value_expression_return retval = new JpqlParser.simple_entity_or_value_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID479 = null;\n    Token STRING_LITERAL480 = null;\n    Token NUMERIC_LITERAL481 = null;\n    JpqlParser.input_parameter_return input_parameter478 = null;\n    CommonTree ID479_tree = null;\n    CommonTree STRING_LITERAL480_tree = null;\n    CommonTree NUMERIC_LITERAL481_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:494:35: ( input_parameter | ID | STRING_LITERAL | NUMERIC_LITERAL )\n        int alt105 = 4;\n        switch(input.LA(1)) {\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt105 = 1;\n                }\n                break;\n            case ID:\n                {\n                    alt105 = 2;\n                }\n                break;\n            case STRING_LITERAL:\n                {\n                    alt105 = 3;\n                }\n                break;\n            case NUMERIC_LITERAL:\n                {\n                    alt105 = 4;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 105, 0, input);\n                throw nvae;\n        }\n        switch(alt105) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:495:2: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_simple_entity_or_value_expression4209);\n                    input_parameter478 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter478.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:496:4: ID\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    ID479 = (Token) match(input, ID, FOLLOW_ID_in_simple_entity_or_value_expression4214);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        ID479_tree = (CommonTree) adaptor.create(ID479);\n                        adaptor.addChild(root_0, ID479_tree);\n                    }\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:497:4: STRING_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    STRING_LITERAL480 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_simple_entity_or_value_expression4219);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        STRING_LITERAL480_tree = (CommonTree) adaptor.create(STRING_LITERAL480);\n                        adaptor.addChild(root_0, STRING_LITERAL480_tree);\n                    }\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:498:4: NUMERIC_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    NUMERIC_LITERAL481 = (Token) match(input, NUMERIC_LITERAL, FOLLOW_NUMERIC_LITERAL_in_simple_entity_or_value_expression4224);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        NUMERIC_LITERAL481_tree = (CommonTree) adaptor.create(NUMERIC_LITERAL481);\n                        adaptor.addChild(root_0, NUMERIC_LITERAL481_tree);\n                    }\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:494:1: simple_entity_or_value_expression : ( input_parameter | ID | STRING_LITERAL | NUMERIC_LITERAL );\n", "repo_name": "BatooJPA-master/", "id": 1430, "method_signature": "JpqlParser.simple_entity_or_value_expression_return simple_entity_or_value_expression()"}, "JpqlParser.simple_select_clause": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_select_clause", "method_implementation": "{\n    JpqlParser.simple_select_clause_return retval = new JpqlParser.simple_select_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token SELECT497 = null;\n    Token DISTINCT498 = null;\n    JpqlParser.scalar_expression_return scalar_expression499 = null;\n    CommonTree SELECT497_tree = null;\n    CommonTree DISTINCT498_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:512:22: ( SELECT ^ ( DISTINCT )? scalar_expression )\n        // org/batoo/jpa/jpql/JpqlParser.g:513:4: SELECT ^ ( DISTINCT )? scalar_expression\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            SELECT497 = (Token) match(input, SELECT, FOLLOW_SELECT_in_simple_select_clause4369);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                SELECT497_tree = (CommonTree) adaptor.create(SELECT497);\n                root_0 = (CommonTree) adaptor.becomeRoot(SELECT497_tree, root_0);\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:513:12: ( DISTINCT )?\n            int alt110 = 2;\n            switch(input.LA(1)) {\n                case DISTINCT:\n                    {\n                        alt110 = 1;\n                    }\n                    break;\n            }\n            switch(alt110) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:513:13: DISTINCT\n                    {\n                        DISTINCT498 = (Token) match(input, DISTINCT, FOLLOW_DISTINCT_in_simple_select_clause4373);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0) {\n                            DISTINCT498_tree = (CommonTree) adaptor.create(DISTINCT498);\n                            adaptor.addChild(root_0, DISTINCT498_tree);\n                        }\n                    }\n                    break;\n            }\n            pushFollow(FOLLOW_scalar_expression_in_simple_select_clause4377);\n            scalar_expression499 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, scalar_expression499.getTree());\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:512:1: simple_select_clause : SELECT ^ ( DISTINCT )? scalar_expression ;\n", "repo_name": "BatooJPA-master/", "id": 1434, "method_signature": "JpqlParser.simple_select_clause_return simple_select_clause()"}, "JpqlParser.simple_state_field_path_expression": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.qqid_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleTokenStream.nextNode", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_state_field_path_expression", "method_implementation": "{\n    JpqlParser.simple_state_field_path_expression_return retval = new JpqlParser.simple_state_field_path_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID103 = null;\n    Token Period104 = null;\n    JpqlParser.qqid_return qqid105 = null;\n    CommonTree ID103_tree = null;\n    CommonTree Period104_tree = null;\n    RewriteRuleTokenStream stream_Period = new RewriteRuleTokenStream(adaptor, \"token Period\");\n    RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream(adaptor, \"token ID\");\n    RewriteRuleSubtreeStream stream_qqid = new RewriteRuleSubtreeStream(adaptor, \"rule qqid\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:169:36: ( ID Period qqid -> ^( ST_PARENTED ID qqid ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:170:5: ID Period qqid\n        {\n            ID103 = (Token) match(input, ID, FOLLOW_ID_in_simple_state_field_path_expression1159);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_ID.add(ID103);\n            Period104 = (Token) match(input, Period, FOLLOW_Period_in_simple_state_field_path_expression1161);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_Period.add(Period104);\n            pushFollow(FOLLOW_qqid_in_simple_state_field_path_expression1163);\n            qqid105 = qqid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_qqid.add(qqid105.getTree());\n            // AST REWRITE\n            // elements: qqid, ID\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 171:9: -> ^( ST_PARENTED ID qqid )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:171:12: ^( ST_PARENTED ID qqid )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_PARENTED, \"ST_PARENTED\"), root_1);\n                        adaptor.addChild(root_1, stream_ID.nextNode());\n                        adaptor.addChild(root_1, stream_qqid.nextTree());\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:169:1: simple_state_field_path_expression : ID Period qqid -> ^( ST_PARENTED ID qqid ) ;\n", "repo_name": "BatooJPA-master/", "id": 1370, "method_signature": "JpqlParser.simple_state_field_path_expression_return simple_state_field_path_expression()"}, "JpqlParser.simple_when_clause": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.simple_when_clause", "method_implementation": "{\n    JpqlParser.simple_when_clause_return retval = new JpqlParser.simple_when_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token WHEN145 = null;\n    Token THEN147 = null;\n    JpqlParser.scalar_expression_return scalar_expression146 = null;\n    JpqlParser.scalar_expression_return scalar_expression148 = null;\n    CommonTree WHEN145_tree = null;\n    CommonTree THEN147_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:217:20: ( WHEN ^ scalar_expression THEN ! scalar_expression )\n        // org/batoo/jpa/jpql/JpqlParser.g:218:2: WHEN ^ scalar_expression THEN ! scalar_expression\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            WHEN145 = (Token) match(input, WHEN, FOLLOW_WHEN_in_simple_when_clause1931);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                WHEN145_tree = (CommonTree) adaptor.create(WHEN145);\n                root_0 = (CommonTree) adaptor.becomeRoot(WHEN145_tree, root_0);\n            }\n            pushFollow(FOLLOW_scalar_expression_in_simple_when_clause1934);\n            scalar_expression146 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, scalar_expression146.getTree());\n            THEN147 = (Token) match(input, THEN, FOLLOW_THEN_in_simple_when_clause1936);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_scalar_expression_in_simple_when_clause1939);\n            scalar_expression148 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, scalar_expression148.getTree());\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:217:1: simple_when_clause : WHEN ^ scalar_expression THEN ! scalar_expression ;\n", "repo_name": "BatooJPA-master/", "id": 1381, "method_signature": "JpqlParser.simple_when_clause_return simple_when_clause()"}, "JpqlParser.single_valued_path_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.qualified_identification_variable_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.single_valued_path_expression", "method_implementation": "{\n    JpqlParser.single_valued_path_expression_return retval = new JpqlParser.single_valued_path_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.qualified_identification_variable_return qualified_identification_variable93 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression94 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:153:31: ( qualified_identification_variable | state_field_path_expression )\n        int alt29 = 2;\n        switch(input.LA(1)) {\n            case ENTRY:\n            case KEY:\n            case VALUE:\n                {\n                    alt29 = 1;\n                }\n                break;\n            case CAST:\n            case ID:\n                {\n                    alt29 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 29, 0, input);\n                throw nvae;\n        }\n        switch(alt29) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:154:2: qualified_identification_variable\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_qualified_identification_variable_in_single_valued_path_expression1082);\n                    qualified_identification_variable93 = qualified_identification_variable();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, qualified_identification_variable93.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:155:4: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_single_valued_path_expression1087);\n                    state_field_path_expression94 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression94.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:153:1: single_valued_path_expression : ( qualified_identification_variable | state_field_path_expression );\n", "repo_name": "BatooJPA-master/", "id": 1367, "method_signature": "JpqlParser.single_valued_path_expression_return single_valued_path_expression()"}, "JpqlParser.state_field_path_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.simple_state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.cast_state_field_path_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.state_field_path_expression", "method_implementation": "{\n    JpqlParser.state_field_path_expression_return retval = new JpqlParser.state_field_path_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.simple_state_field_path_expression_return simple_state_field_path_expression101 = null;\n    JpqlParser.cast_state_field_path_expression_return cast_state_field_path_expression102 = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:164:29: ( simple_state_field_path_expression | cast_state_field_path_expression )\n        int alt31 = 2;\n        switch(input.LA(1)) {\n            case ID:\n                {\n                    alt31 = 1;\n                }\n                break;\n            case CAST:\n                {\n                    alt31 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 31, 0, input);\n                throw nvae;\n        }\n        switch(alt31) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:165:5: simple_state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_simple_state_field_path_expression_in_state_field_path_expression1133);\n                    simple_state_field_path_expression101 = simple_state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, simple_state_field_path_expression101.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:166:7: cast_state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_cast_state_field_path_expression_in_state_field_path_expression1142);\n                    cast_state_field_path_expression102 = cast_state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, cast_state_field_path_expression102.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:164:1: state_field_path_expression : ( simple_state_field_path_expression | cast_state_field_path_expression );\n", "repo_name": "BatooJPA-master/", "id": 1369, "method_signature": "JpqlParser.state_field_path_expression_return state_field_path_expression()"}, "JpqlParser.string_expression": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.string_primary_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.subquery_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.string_expression", "method_implementation": "{\n    JpqlParser.string_expression_return retval = new JpqlParser.string_expression_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Left_Paren336 = null;\n    Token Right_Paren338 = null;\n    JpqlParser.string_primary_return string_primary335 = null;\n    JpqlParser.subquery_return subquery337 = null;\n    CommonTree Left_Paren336_tree = null;\n    CommonTree Right_Paren338_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:352:19: ( string_primary | Left_Paren ! subquery Right_Paren !)\n        int alt74 = 2;\n        switch(input.LA(1)) {\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case CONCAT:\n            case COUNT:\n            case FUNC:\n            case ID:\n            case LOWER:\n            case MAX:\n            case MIN:\n            case NULLIF:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case SUM:\n            case TRIM:\n            case UPPER:\n                {\n                    alt74 = 1;\n                }\n                break;\n            case Left_Paren:\n                {\n                    alt74 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 74, 0, input);\n                throw nvae;\n        }\n        switch(alt74) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:353:4: string_primary\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_string_primary_in_string_expression3186);\n                    string_primary335 = string_primary();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, string_primary335.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:354:6: Left_Paren ! subquery Right_Paren !\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    Left_Paren336 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_string_expression3193);\n                    if (state.failed)\n                        return retval;\n                    pushFollow(FOLLOW_subquery_in_string_expression3196);\n                    subquery337 = subquery();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, subquery337.getTree());\n                    Right_Paren338 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_string_expression3198);\n                    if (state.failed)\n                        return retval;\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:352:1: string_expression : ( string_primary | Left_Paren ! subquery Right_Paren !);\n", "repo_name": "BatooJPA-master/", "id": 1404, "method_signature": "JpqlParser.string_expression_return string_expression()"}, "JpqlParser.string_primary": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.function_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.functions_returning_strings_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.case_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.aggregate_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.string_primary", "method_implementation": "{\n    JpqlParser.string_primary_return retval = new JpqlParser.string_primary_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token STRING_LITERAL343 = null;\n    JpqlParser.function_expression_return function_expression339 = null;\n    JpqlParser.functions_returning_strings_return functions_returning_strings340 = null;\n    JpqlParser.case_expression_return case_expression341 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression342 = null;\n    JpqlParser.input_parameter_return input_parameter344 = null;\n    JpqlParser.aggregate_expression_return aggregate_expression345 = null;\n    CommonTree STRING_LITERAL343_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:357:16: ( function_expression | functions_returning_strings | case_expression | state_field_path_expression | STRING_LITERAL | input_parameter | aggregate_expression )\n        int alt75 = 7;\n        switch(input.LA(1)) {\n            case FUNC:\n                {\n                    alt75 = 1;\n                }\n                break;\n            case CONCAT:\n            case LOWER:\n            case SUBSTRING:\n            case TRIM:\n            case UPPER:\n                {\n                    alt75 = 2;\n                }\n                break;\n            case CASE:\n            case COALESCE:\n            case NULLIF:\n                {\n                    alt75 = 3;\n                }\n                break;\n            case CAST:\n            case ID:\n                {\n                    alt75 = 4;\n                }\n                break;\n            case STRING_LITERAL:\n                {\n                    alt75 = 5;\n                }\n                break;\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt75 = 6;\n                }\n                break;\n            case AVG:\n            case COUNT:\n            case MAX:\n            case MIN:\n            case SUM:\n                {\n                    alt75 = 7;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 75, 0, input);\n                throw nvae;\n        }\n        switch(alt75) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:358:2: function_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_function_expression_in_string_primary3210);\n                    function_expression339 = function_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, function_expression339.getTree());\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:359:4: functions_returning_strings\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_functions_returning_strings_in_string_primary3215);\n                    functions_returning_strings340 = functions_returning_strings();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, functions_returning_strings340.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:360:4: case_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_case_expression_in_string_primary3220);\n                    case_expression341 = case_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, case_expression341.getTree());\n                }\n                break;\n            case 4:\n                // org/batoo/jpa/jpql/JpqlParser.g:361:4: state_field_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_state_field_path_expression_in_string_primary3225);\n                    state_field_path_expression342 = state_field_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, state_field_path_expression342.getTree());\n                }\n                break;\n            case 5:\n                // org/batoo/jpa/jpql/JpqlParser.g:362:4: STRING_LITERAL\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    STRING_LITERAL343 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_string_primary3230);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        STRING_LITERAL343_tree = (CommonTree) adaptor.create(STRING_LITERAL343);\n                        adaptor.addChild(root_0, STRING_LITERAL343_tree);\n                    }\n                }\n                break;\n            case 6:\n                // org/batoo/jpa/jpql/JpqlParser.g:363:4: input_parameter\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_input_parameter_in_string_primary3235);\n                    input_parameter344 = input_parameter();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, input_parameter344.getTree());\n                }\n                break;\n            case 7:\n                // org/batoo/jpa/jpql/JpqlParser.g:364:4: aggregate_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_aggregate_expression_in_string_primary3240);\n                    aggregate_expression345 = aggregate_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, aggregate_expression345.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:357:1: string_primary : ( function_expression | functions_returning_strings | case_expression | state_field_path_expression | STRING_LITERAL | input_parameter | aggregate_expression );\n", "repo_name": "BatooJPA-master/", "id": 1405, "method_signature": "JpqlParser.string_primary_return string_primary()"}, "JpqlParser.subquery": {"callee_method_names": ["RewriteRuleSubtreeStream.add", "JpqlParser.simple_select_clause_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.subquery_from_clause_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.where_clause_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.groupby_clause_return.getTree", "RewriteRuleSubtreeStream.add", "JpqlParser.having_clause_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.subquery", "method_implementation": "{\n    JpqlParser.subquery_return retval = new JpqlParser.subquery_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    JpqlParser.simple_select_clause_return simple_select_clause492 = null;\n    JpqlParser.subquery_from_clause_return subquery_from_clause493 = null;\n    JpqlParser.where_clause_return where_clause494 = null;\n    JpqlParser.groupby_clause_return groupby_clause495 = null;\n    JpqlParser.having_clause_return having_clause496 = null;\n    RewriteRuleSubtreeStream stream_groupby_clause = new RewriteRuleSubtreeStream(adaptor, \"rule groupby_clause\");\n    RewriteRuleSubtreeStream stream_having_clause = new RewriteRuleSubtreeStream(adaptor, \"rule having_clause\");\n    RewriteRuleSubtreeStream stream_where_clause = new RewriteRuleSubtreeStream(adaptor, \"rule where_clause\");\n    RewriteRuleSubtreeStream stream_subquery_from_clause = new RewriteRuleSubtreeStream(adaptor, \"rule subquery_from_clause\");\n    RewriteRuleSubtreeStream stream_simple_select_clause = new RewriteRuleSubtreeStream(adaptor, \"rule simple_select_clause\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:508:10: ( simple_select_clause subquery_from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? -> ^( ST_SUBQUERY simple_select_clause subquery_from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:509:4: simple_select_clause subquery_from_clause ( where_clause )? ( groupby_clause )? ( having_clause )?\n        {\n            pushFollow(FOLLOW_simple_select_clause_in_subquery4312);\n            simple_select_clause492 = simple_select_clause();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_simple_select_clause.add(simple_select_clause492.getTree());\n            pushFollow(FOLLOW_subquery_from_clause_in_subquery4314);\n            subquery_from_clause493 = subquery_from_clause();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_subquery_from_clause.add(subquery_from_clause493.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:509:46: ( where_clause )?\n            int alt107 = 2;\n            switch(input.LA(1)) {\n                case WHERE:\n                    {\n                        alt107 = 1;\n                    }\n                    break;\n            }\n            switch(alt107) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:509:47: where_clause\n                    {\n                        pushFollow(FOLLOW_where_clause_in_subquery4317);\n                        where_clause494 = where_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_where_clause.add(where_clause494.getTree());\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:509:62: ( groupby_clause )?\n            int alt108 = 2;\n            switch(input.LA(1)) {\n                case GROUP:\n                    {\n                        alt108 = 1;\n                    }\n                    break;\n            }\n            switch(alt108) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:509:63: groupby_clause\n                    {\n                        pushFollow(FOLLOW_groupby_clause_in_subquery4322);\n                        groupby_clause495 = groupby_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_groupby_clause.add(groupby_clause495.getTree());\n                    }\n                    break;\n            }\n            // org/batoo/jpa/jpql/JpqlParser.g:509:80: ( having_clause )?\n            int alt109 = 2;\n            switch(input.LA(1)) {\n                case HAVING:\n                    {\n                        alt109 = 1;\n                    }\n                    break;\n            }\n            switch(alt109) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:509:81: having_clause\n                    {\n                        pushFollow(FOLLOW_having_clause_in_subquery4327);\n                        having_clause496 = having_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            stream_having_clause.add(having_clause496.getTree());\n                    }\n                    break;\n            }\n            // AST REWRITE\n            // elements: groupby_clause, where_clause, simple_select_clause, subquery_from_clause, having_clause\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 510:5: -> ^( ST_SUBQUERY simple_select_clause subquery_from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:510:8: ^( ST_SUBQUERY simple_select_clause subquery_from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_SUBQUERY, \"ST_SUBQUERY\"), root_1);\n                        adaptor.addChild(root_1, stream_simple_select_clause.nextTree());\n                        adaptor.addChild(root_1, stream_subquery_from_clause.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:510:64: ( where_clause )?\n                        if (stream_where_clause.hasNext()) {\n                            adaptor.addChild(root_1, stream_where_clause.nextTree());\n                        }\n                        stream_where_clause.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:510:80: ( groupby_clause )?\n                        if (stream_groupby_clause.hasNext()) {\n                            adaptor.addChild(root_1, stream_groupby_clause.nextTree());\n                        }\n                        stream_groupby_clause.reset();\n                        // org/batoo/jpa/jpql/JpqlParser.g:510:98: ( having_clause )?\n                        if (stream_having_clause.hasNext()) {\n                            adaptor.addChild(root_1, stream_having_clause.nextTree());\n                        }\n                        stream_having_clause.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:508:1: subquery : simple_select_clause subquery_from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? -> ^( ST_SUBQUERY simple_select_clause subquery_from_clause ( where_clause )? ( groupby_clause )? ( having_clause )? ) ;\n", "repo_name": "BatooJPA-master/", "id": 1433, "method_signature": "JpqlParser.subquery_return subquery()"}, "JpqlParser.subquery_from_clause": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.subselect_identification_variable_declaration_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.subselect_identification_variable_declaration_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.subquery_from_clause", "method_implementation": "{\n    JpqlParser.subquery_from_clause_return retval = new JpqlParser.subquery_from_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token FROM500 = null;\n    Token Comma502 = null;\n    JpqlParser.subselect_identification_variable_declaration_return subselect_identification_variable_declaration501 = null;\n    JpqlParser.subselect_identification_variable_declaration_return subselect_identification_variable_declaration503 = null;\n    CommonTree FROM500_tree = null;\n    CommonTree Comma502_tree = null;\n    RewriteRuleTokenStream stream_FROM = new RewriteRuleTokenStream(adaptor, \"token FROM\");\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_subselect_identification_variable_declaration = new RewriteRuleSubtreeStream(adaptor, \"rule subselect_identification_variable_declaration\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:515:22: ( FROM subselect_identification_variable_declaration ( Comma subselect_identification_variable_declaration )* -> ^( LFROM subselect_identification_variable_declaration ( subselect_identification_variable_declaration )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:516:5: FROM subselect_identification_variable_declaration ( Comma subselect_identification_variable_declaration )*\n        {\n            FROM500 = (Token) match(input, FROM, FOLLOW_FROM_in_subquery_from_clause4389);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_FROM.add(FROM500);\n            pushFollow(FOLLOW_subselect_identification_variable_declaration_in_subquery_from_clause4391);\n            subselect_identification_variable_declaration501 = subselect_identification_variable_declaration();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_subselect_identification_variable_declaration.add(subselect_identification_variable_declaration501.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:516:56: ( Comma subselect_identification_variable_declaration )*\n            loop111: do {\n                int alt111 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt111 = 1;\n                        }\n                        break;\n                }\n                switch(alt111) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:516:57: Comma subselect_identification_variable_declaration\n                        {\n                            Comma502 = (Token) match(input, Comma, FOLLOW_Comma_in_subquery_from_clause4394);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma502);\n                            pushFollow(FOLLOW_subselect_identification_variable_declaration_in_subquery_from_clause4396);\n                            subselect_identification_variable_declaration503 = subselect_identification_variable_declaration();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_subselect_identification_variable_declaration.add(subselect_identification_variable_declaration503.getTree());\n                        }\n                        break;\n                    default:\n                        break loop111;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: subselect_identification_variable_declaration, subselect_identification_variable_declaration\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 517:9: -> ^( LFROM subselect_identification_variable_declaration ( subselect_identification_variable_declaration )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:517:12: ^( LFROM subselect_identification_variable_declaration ( subselect_identification_variable_declaration )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(LFROM, \"LFROM\"), root_1);\n                        adaptor.addChild(root_1, stream_subselect_identification_variable_declaration.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:517:66: ( subselect_identification_variable_declaration )*\n                        while (stream_subselect_identification_variable_declaration.hasNext()) {\n                            adaptor.addChild(root_1, stream_subselect_identification_variable_declaration.nextTree());\n                        }\n                        stream_subselect_identification_variable_declaration.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:515:1: subquery_from_clause : FROM subselect_identification_variable_declaration ( Comma subselect_identification_variable_declaration )* -> ^( LFROM subselect_identification_variable_declaration ( subselect_identification_variable_declaration )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1435, "method_signature": "JpqlParser.subquery_from_clause_return subquery_from_clause()"}, "JpqlParser.subselect_identification_variable_declaration": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.derived_path_expression_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.collection_member_declaration_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.subselect_identification_variable_declaration", "method_implementation": "{\n    JpqlParser.subselect_identification_variable_declaration_return retval = new JpqlParser.subselect_identification_variable_declaration_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token ID_declaration504 = null;\n    JpqlParser.derived_path_expression_return derived_path_expression505 = null;\n    JpqlParser.collection_member_declaration_return collection_member_declaration506 = null;\n    CommonTree ID_declaration504_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:519:47: ( ID_declaration | derived_path_expression | collection_member_declaration )\n        int alt112 = 3;\n        switch(input.LA(1)) {\n            case ID_declaration:\n                {\n                    alt112 = 1;\n                }\n                break;\n            case ID:\n                {\n                    alt112 = 2;\n                }\n                break;\n            case IN:\n                {\n                    alt112 = 3;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return retval;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 112, 0, input);\n                throw nvae;\n        }\n        switch(alt112) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:520:3: ID_declaration\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    ID_declaration504 = (Token) match(input, ID_declaration, FOLLOW_ID_declaration_in_subselect_identification_variable_declaration4431);\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0) {\n                        ID_declaration504_tree = (CommonTree) adaptor.create(ID_declaration504);\n                        adaptor.addChild(root_0, ID_declaration504_tree);\n                    }\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:521:5: derived_path_expression\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_derived_path_expression_in_subselect_identification_variable_declaration4437);\n                    derived_path_expression505 = derived_path_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, derived_path_expression505.getTree());\n                }\n                break;\n            case 3:\n                // org/batoo/jpa/jpql/JpqlParser.g:522:5: collection_member_declaration\n                {\n                    root_0 = (CommonTree) adaptor.nil();\n                    pushFollow(FOLLOW_collection_member_declaration_in_subselect_identification_variable_declaration4443);\n                    collection_member_declaration506 = collection_member_declaration();\n                    state._fsp--;\n                    if (state.failed)\n                        return retval;\n                    if (state.backtracking == 0)\n                        adaptor.addChild(root_0, collection_member_declaration506.getTree());\n                }\n                break;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:519:1: subselect_identification_variable_declaration : ( ID_declaration | derived_path_expression | collection_member_declaration );\n", "repo_name": "BatooJPA-master/", "id": 1436, "method_signature": "JpqlParser.subselect_identification_variable_declaration_return subselect_identification_variable_declaration()"}, "JpqlParser.synpred10_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred10_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:236:7: ( datetime_primary )\n    // org/batoo/jpa/jpql/JpqlParser.g:236:7: datetime_primary\n    {\n        pushFollow(FOLLOW_datetime_primary_in_synpred10_JpqlParser2078);\n        datetime_primary();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred10_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1446, "method_signature": "void synpred10_JpqlParser_fragment()"}, "JpqlParser.synpred11_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred11_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:237:7: ( boolean_primary )\n    // org/batoo/jpa/jpql/JpqlParser.g:237:7: boolean_primary\n    {\n        pushFollow(FOLLOW_boolean_primary_in_synpred11_JpqlParser2086);\n        boolean_primary();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred11_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1447, "method_signature": "void synpred11_JpqlParser_fragment()"}, "JpqlParser.synpred12_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred12_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:299:5: ( simple_cond_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:299:5: simple_cond_expression\n    {\n        pushFollow(FOLLOW_simple_cond_expression_in_synpred12_JpqlParser2699);\n        simple_cond_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred12_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1448, "method_signature": "void synpred12_JpqlParser_fragment()"}, "JpqlParser.synpred13_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred13_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:304:5: ( collection_member_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:304:5: collection_member_expression\n    {\n        pushFollow(FOLLOW_collection_member_expression_in_synpred13_JpqlParser2739);\n        collection_member_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred13_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1449, "method_signature": "void synpred13_JpqlParser_fragment()"}, "JpqlParser.synpred15_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred15_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:306:7: ( in_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:306:7: in_expression\n    {\n        pushFollow(FOLLOW_in_expression_in_synpred15_JpqlParser2754);\n        in_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred15_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1450, "method_signature": "void synpred15_JpqlParser_fragment()"}, "JpqlParser.synpred16_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred16_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:307:7: ( empty_collection_comparison_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:307:7: empty_collection_comparison_expression\n    {\n        pushFollow(FOLLOW_empty_collection_comparison_expression_in_synpred16_JpqlParser2762);\n        empty_collection_comparison_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred16_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1451, "method_signature": "void synpred16_JpqlParser_fragment()"}, "JpqlParser.synpred17_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred17_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:308:7: ( null_comparison_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:308:7: null_comparison_expression\n    {\n        pushFollow(FOLLOW_null_comparison_expression_in_synpred17_JpqlParser2770);\n        null_comparison_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred17_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1452, "method_signature": "void synpred17_JpqlParser_fragment()"}, "JpqlParser.synpred18_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred18_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:309:7: ( comparison_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:309:7: comparison_expression\n    {\n        pushFollow(FOLLOW_comparison_expression_in_synpred18_JpqlParser2778);\n        comparison_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred18_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1453, "method_signature": "void synpred18_JpqlParser_fragment()"}, "JpqlParser.synpred19_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred19_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:310:7: ( between_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:310:7: between_expression\n    {\n        pushFollow(FOLLOW_between_expression_in_synpred19_JpqlParser2786);\n        between_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred19_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1454, "method_signature": "void synpred19_JpqlParser_fragment()"}, "JpqlParser.synpred1_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred1_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:86:5: ( simple_arithmetic_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:86:5: simple_arithmetic_expression\n    {\n        pushFollow(FOLLOW_simple_arithmetic_expression_in_synpred1_JpqlParser457);\n        simple_arithmetic_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred1_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1438, "method_signature": "void synpred1_JpqlParser_fragment()"}, "JpqlParser.synpred20_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred20_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:311:7: ( like_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:311:7: like_expression\n    {\n        pushFollow(FOLLOW_like_expression_in_synpred20_JpqlParser2794);\n        like_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred20_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1455, "method_signature": "void synpred20_JpqlParser_fragment()"}, "JpqlParser.synpred21_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred21_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:320:2: ( arithmetic_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:320:2: arithmetic_expression\n    {\n        pushFollow(FOLLOW_arithmetic_expression_in_synpred21_JpqlParser2884);\n        arithmetic_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred21_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1456, "method_signature": "void synpred21_JpqlParser_fragment()"}, "JpqlParser.synpred22_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred22_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:321:4: ( string_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:321:4: string_expression\n    {\n        pushFollow(FOLLOW_string_expression_in_synpred22_JpqlParser2889);\n        string_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred22_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1457, "method_signature": "void synpred22_JpqlParser_fragment()"}, "JpqlParser.synpred23_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred23_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:330:5: ( arithmetic_expression comparison_operator ( arithmetic_expression | all_or_any_expression ) )\n    // org/batoo/jpa/jpql/JpqlParser.g:330:5: arithmetic_expression comparison_operator ( arithmetic_expression | all_or_any_expression )\n    {\n        pushFollow(FOLLOW_arithmetic_expression_in_synpred23_JpqlParser2976);\n        arithmetic_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n        pushFollow(FOLLOW_comparison_operator_in_synpred23_JpqlParser2978);\n        comparison_operator();\n        state._fsp--;\n        if (state.failed)\n            return;\n        // org/batoo/jpa/jpql/JpqlParser.g:330:48: ( arithmetic_expression | all_or_any_expression )\n        int alt114 = 2;\n        switch(input.LA(1)) {\n            case ABS:\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case INDEX:\n            case LENGTH:\n            case LOCATE:\n            case Left_Paren:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MOD:\n            case MONTH:\n            case Minus_Sign:\n            case NULLIF:\n            case NUMERIC_LITERAL:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Plus_Sign:\n            case Question_Sign:\n            case SECOND:\n            case SIZE:\n            case SQRT:\n            case SUM:\n            case WEEK:\n            case YEAR:\n                {\n                    alt114 = 1;\n                }\n                break;\n            case ALL:\n            case ANY:\n            case SOME:\n                {\n                    alt114 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 114, 0, input);\n                throw nvae;\n        }\n        switch(alt114) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:330:49: arithmetic_expression\n                {\n                    pushFollow(FOLLOW_arithmetic_expression_in_synpred23_JpqlParser2982);\n                    arithmetic_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:330:73: all_or_any_expression\n                {\n                    pushFollow(FOLLOW_all_or_any_expression_in_synpred23_JpqlParser2986);\n                    all_or_any_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n        }\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred23_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1458, "method_signature": "void synpred23_JpqlParser_fragment()"}, "JpqlParser.synpred24_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred24_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:331:7: ( string_expression comparison_operator ( string_expression | all_or_any_expression ) )\n    // org/batoo/jpa/jpql/JpqlParser.g:331:7: string_expression comparison_operator ( string_expression | all_or_any_expression )\n    {\n        pushFollow(FOLLOW_string_expression_in_synpred24_JpqlParser2995);\n        string_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n        pushFollow(FOLLOW_comparison_operator_in_synpred24_JpqlParser2997);\n        comparison_operator();\n        state._fsp--;\n        if (state.failed)\n            return;\n        // org/batoo/jpa/jpql/JpqlParser.g:331:46: ( string_expression | all_or_any_expression )\n        int alt115 = 2;\n        switch(input.LA(1)) {\n            case AVG:\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case CONCAT:\n            case COUNT:\n            case FUNC:\n            case ID:\n            case LOWER:\n            case Left_Paren:\n            case MAX:\n            case MIN:\n            case NULLIF:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n            case STRING_LITERAL:\n            case SUBSTRING:\n            case SUM:\n            case TRIM:\n            case UPPER:\n                {\n                    alt115 = 1;\n                }\n                break;\n            case ALL:\n            case ANY:\n            case SOME:\n                {\n                    alt115 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 115, 0, input);\n                throw nvae;\n        }\n        switch(alt115) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:331:47: string_expression\n                {\n                    pushFollow(FOLLOW_string_expression_in_synpred24_JpqlParser3001);\n                    string_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:331:67: all_or_any_expression\n                {\n                    pushFollow(FOLLOW_all_or_any_expression_in_synpred24_JpqlParser3005);\n                    all_or_any_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n        }\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred24_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1459, "method_signature": "void synpred24_JpqlParser_fragment()"}, "JpqlParser.synpred25_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred25_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:332:7: ( boolean_expression comparison_operator ( boolean_expression | all_or_any_expression ) )\n    // org/batoo/jpa/jpql/JpqlParser.g:332:7: boolean_expression comparison_operator ( boolean_expression | all_or_any_expression )\n    {\n        pushFollow(FOLLOW_boolean_expression_in_synpred25_JpqlParser3015);\n        boolean_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n        pushFollow(FOLLOW_comparison_operator_in_synpred25_JpqlParser3017);\n        comparison_operator();\n        state._fsp--;\n        if (state.failed)\n            return;\n        // org/batoo/jpa/jpql/JpqlParser.g:332:47: ( boolean_expression | all_or_any_expression )\n        int alt116 = 2;\n        switch(input.LA(1)) {\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case FALSE:\n            case FUNC:\n            case ID:\n            case Left_Paren:\n            case NULLIF:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n            case TRUE:\n                {\n                    alt116 = 1;\n                }\n                break;\n            case ALL:\n            case ANY:\n            case SOME:\n                {\n                    alt116 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 116, 0, input);\n                throw nvae;\n        }\n        switch(alt116) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:332:48: boolean_expression\n                {\n                    pushFollow(FOLLOW_boolean_expression_in_synpred25_JpqlParser3021);\n                    boolean_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:332:69: all_or_any_expression\n                {\n                    pushFollow(FOLLOW_all_or_any_expression_in_synpred25_JpqlParser3025);\n                    all_or_any_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n        }\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred25_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1460, "method_signature": "void synpred25_JpqlParser_fragment()"}, "JpqlParser.synpred26_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred26_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:333:7: ( enum_expression ( Equals_Operator | Not_Equals_Operator ) ( enum_expression | all_or_any_expression ) )\n    // org/batoo/jpa/jpql/JpqlParser.g:333:7: enum_expression ( Equals_Operator | Not_Equals_Operator ) ( enum_expression | all_or_any_expression )\n    {\n        pushFollow(FOLLOW_enum_expression_in_synpred26_JpqlParser3034);\n        enum_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n        if (input.LA(1) == Equals_Operator || input.LA(1) == Not_Equals_Operator) {\n            input.consume();\n            state.errorRecovery = false;\n            state.failed = false;\n        } else {\n            if (state.backtracking > 0) {\n                state.failed = true;\n                return;\n            }\n            MismatchedSetException mse = new MismatchedSetException(null, input);\n            throw mse;\n        }\n        // org/batoo/jpa/jpql/JpqlParser.g:333:64: ( enum_expression | all_or_any_expression )\n        int alt117 = 2;\n        switch(input.LA(1)) {\n            case CASE:\n            case CAST:\n            case COALESCE:\n            case FUNC:\n            case ID:\n            case Left_Paren:\n            case NULLIF:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n                {\n                    alt117 = 1;\n                }\n                break;\n            case ALL:\n            case ANY:\n            case SOME:\n                {\n                    alt117 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 117, 0, input);\n                throw nvae;\n        }\n        switch(alt117) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:333:65: enum_expression\n                {\n                    pushFollow(FOLLOW_enum_expression_in_synpred26_JpqlParser3046);\n                    enum_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:333:83: all_or_any_expression\n                {\n                    pushFollow(FOLLOW_all_or_any_expression_in_synpred26_JpqlParser3050);\n                    all_or_any_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n        }\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred26_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1461, "method_signature": "void synpred26_JpqlParser_fragment()"}, "JpqlParser.synpred27_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred27_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:334:7: ( datetime_expression comparison_operator ( datetime_expression | all_or_any_expression ) )\n    // org/batoo/jpa/jpql/JpqlParser.g:334:7: datetime_expression comparison_operator ( datetime_expression | all_or_any_expression )\n    {\n        pushFollow(FOLLOW_datetime_expression_in_synpred27_JpqlParser3059);\n        datetime_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n        pushFollow(FOLLOW_comparison_operator_in_synpred27_JpqlParser3061);\n        comparison_operator();\n        state._fsp--;\n        if (state.failed)\n            return;\n        // org/batoo/jpa/jpql/JpqlParser.g:334:48: ( datetime_expression | all_or_any_expression )\n        int alt118 = 2;\n        switch(input.LA(1)) {\n            case AVG:\n            case CAST:\n            case COUNT:\n            case CURRENT_DATE:\n            case CURRENT_TIME:\n            case CURRENT_TIMESTAMP:\n            case DAY:\n            case DAYOFMONTH:\n            case DAYOFWEEK:\n            case DAYOFYEAR:\n            case FUNC:\n            case HOUR:\n            case ID:\n            case Left_Paren:\n            case MAX:\n            case MIN:\n            case MINUTE:\n            case MONTH:\n            case Named_Parameter:\n            case Ordinal_Parameter:\n            case Question_Sign:\n            case SECOND:\n            case SUM:\n            case WEEK:\n            case YEAR:\n                {\n                    alt118 = 1;\n                }\n                break;\n            case ALL:\n            case ANY:\n            case SOME:\n                {\n                    alt118 = 2;\n                }\n                break;\n            default:\n                if (state.backtracking > 0) {\n                    state.failed = true;\n                    return;\n                }\n                NoViableAltException nvae = new NoViableAltException(\"\", 118, 0, input);\n                throw nvae;\n        }\n        switch(alt118) {\n            case 1:\n                // org/batoo/jpa/jpql/JpqlParser.g:334:49: datetime_expression\n                {\n                    pushFollow(FOLLOW_datetime_expression_in_synpred27_JpqlParser3065);\n                    datetime_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n            case 2:\n                // org/batoo/jpa/jpql/JpqlParser.g:334:71: all_or_any_expression\n                {\n                    pushFollow(FOLLOW_all_or_any_expression_in_synpred27_JpqlParser3069);\n                    all_or_any_expression();\n                    state._fsp--;\n                    if (state.failed)\n                        return;\n                }\n                break;\n        }\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred27_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1462, "method_signature": "void synpred27_JpqlParser_fragment()"}, "JpqlParser.synpred2_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred2_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:87:7: ( simple_entity_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:87:7: simple_entity_expression\n    {\n        pushFollow(FOLLOW_simple_entity_expression_in_synpred2_JpqlParser465);\n        simple_entity_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred2_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1439, "method_signature": "void synpred2_JpqlParser_fragment()"}, "JpqlParser.synpred4_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred4_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:89:7: ( NUMERIC_LITERAL )\n    // org/batoo/jpa/jpql/JpqlParser.g:89:7: NUMERIC_LITERAL\n    {\n        match(input, NUMERIC_LITERAL, FOLLOW_NUMERIC_LITERAL_in_synpred4_JpqlParser481);\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred4_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1440, "method_signature": "void synpred4_JpqlParser_fragment()"}, "JpqlParser.synpred5_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred5_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:231:2: ( case_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:231:2: case_expression\n    {\n        pushFollow(FOLLOW_case_expression_in_synpred5_JpqlParser2041);\n        case_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred5_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1441, "method_signature": "void synpred5_JpqlParser_fragment()"}, "JpqlParser.synpred6_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred6_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:232:4: ( function_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:232:4: function_expression\n    {\n        pushFollow(FOLLOW_function_expression_in_synpred6_JpqlParser2046);\n        function_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred6_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1442, "method_signature": "void synpred6_JpqlParser_fragment()"}, "JpqlParser.synpred7_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred7_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:233:7: ( simple_arithmetic_expression )\n    // org/batoo/jpa/jpql/JpqlParser.g:233:7: simple_arithmetic_expression\n    {\n        pushFollow(FOLLOW_simple_arithmetic_expression_in_synpred7_JpqlParser2054);\n        simple_arithmetic_expression();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred7_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1443, "method_signature": "void synpred7_JpqlParser_fragment()"}, "JpqlParser.synpred8_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred8_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:234:7: ( string_primary )\n    // org/batoo/jpa/jpql/JpqlParser.g:234:7: string_primary\n    {\n        pushFollow(FOLLOW_string_primary_in_synpred8_JpqlParser2062);\n        string_primary();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred8_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1444, "method_signature": "void synpred8_JpqlParser_fragment()"}, "JpqlParser.synpred9_JpqlParser_fragment": {"callee_method_names": [], "method_name": "JpqlParser.synpred9_JpqlParser_fragment", "method_implementation": "{\n    // org/batoo/jpa/jpql/JpqlParser.g:235:7: ( enum_primary )\n    // org/batoo/jpa/jpql/JpqlParser.g:235:7: enum_primary\n    {\n        pushFollow(FOLLOW_enum_primary_in_synpred9_JpqlParser2070);\n        enum_primary();\n        state._fsp--;\n        if (state.failed)\n            return;\n    }\n}", "repo_id": "1", "comment": "// $ANTLR start synpred9_JpqlParser\n", "repo_name": "BatooJPA-master/", "id": 1445, "method_signature": "void synpred9_JpqlParser_fragment()"}, "JpqlParser.type_discriminator": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.addChild", "JpqlParser.state_field_path_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.input_parameter_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.type_discriminator", "method_implementation": "{\n    JpqlParser.type_discriminator_return retval = new JpqlParser.type_discriminator_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token TYPE411 = null;\n    Token Left_Paren412 = null;\n    Token ID413 = null;\n    Token Right_Paren416 = null;\n    JpqlParser.state_field_path_expression_return state_field_path_expression414 = null;\n    JpqlParser.input_parameter_return input_parameter415 = null;\n    CommonTree TYPE411_tree = null;\n    CommonTree Left_Paren412_tree = null;\n    CommonTree ID413_tree = null;\n    CommonTree Right_Paren416_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:417:20: ( TYPE ^ Left_Paren ! ( ID | state_field_path_expression | input_parameter ) Right_Paren !)\n        // org/batoo/jpa/jpql/JpqlParser.g:418:2: TYPE ^ Left_Paren ! ( ID | state_field_path_expression | input_parameter ) Right_Paren !\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            TYPE411 = (Token) match(input, TYPE, FOLLOW_TYPE_in_type_discriminator3601);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                TYPE411_tree = (CommonTree) adaptor.create(TYPE411);\n                root_0 = (CommonTree) adaptor.becomeRoot(TYPE411_tree, root_0);\n            }\n            Left_Paren412 = (Token) match(input, Left_Paren, FOLLOW_Left_Paren_in_type_discriminator3604);\n            if (state.failed)\n                return retval;\n            // org/batoo/jpa/jpql/JpqlParser.g:418:20: ( ID | state_field_path_expression | input_parameter )\n            int alt82 = 3;\n            switch(input.LA(1)) {\n                case ID:\n                    {\n                        switch(input.LA(2)) {\n                            case Period:\n                                {\n                                    alt82 = 2;\n                                }\n                                break;\n                            case Right_Paren:\n                                {\n                                    alt82 = 1;\n                                }\n                                break;\n                            default:\n                                if (state.backtracking > 0) {\n                                    state.failed = true;\n                                    return retval;\n                                }\n                                NoViableAltException nvae = new NoViableAltException(\"\", 82, 1, input);\n                                throw nvae;\n                        }\n                    }\n                    break;\n                case CAST:\n                    {\n                        alt82 = 2;\n                    }\n                    break;\n                case Named_Parameter:\n                case Ordinal_Parameter:\n                case Question_Sign:\n                    {\n                        alt82 = 3;\n                    }\n                    break;\n                default:\n                    if (state.backtracking > 0) {\n                        state.failed = true;\n                        return retval;\n                    }\n                    NoViableAltException nvae = new NoViableAltException(\"\", 82, 0, input);\n                    throw nvae;\n            }\n            switch(alt82) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:418:21: ID\n                    {\n                        ID413 = (Token) match(input, ID, FOLLOW_ID_in_type_discriminator3608);\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0) {\n                            ID413_tree = (CommonTree) adaptor.create(ID413);\n                            adaptor.addChild(root_0, ID413_tree);\n                        }\n                    }\n                    break;\n                case 2:\n                    // org/batoo/jpa/jpql/JpqlParser.g:418:26: state_field_path_expression\n                    {\n                        pushFollow(FOLLOW_state_field_path_expression_in_type_discriminator3612);\n                        state_field_path_expression414 = state_field_path_expression();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, state_field_path_expression414.getTree());\n                    }\n                    break;\n                case 3:\n                    // org/batoo/jpa/jpql/JpqlParser.g:418:56: input_parameter\n                    {\n                        pushFollow(FOLLOW_input_parameter_in_type_discriminator3616);\n                        input_parameter415 = input_parameter();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, input_parameter415.getTree());\n                    }\n                    break;\n            }\n            Right_Paren416 = (Token) match(input, Right_Paren, FOLLOW_Right_Paren_in_type_discriminator3620);\n            if (state.failed)\n                return retval;\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:417:1: type_discriminator : TYPE ^ Left_Paren ! ( ID | state_field_path_expression | input_parameter ) Right_Paren !;\n", "repo_name": "BatooJPA-master/", "id": 1413, "method_signature": "JpqlParser.type_discriminator_return type_discriminator()"}, "JpqlParser.update_clause": {"callee_method_names": ["RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.update_item_return.getTree", "RewriteRuleTokenStream.add", "RewriteRuleSubtreeStream.add", "JpqlParser.update_item_return.getTree", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.nil", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.create", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.hasNext", "CommonTreeAdaptor.addChild", "RewriteRuleSubtreeStream.nextTree", "RewriteRuleSubtreeStream.reset", "CommonTreeAdaptor.addChild", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.update_clause", "method_implementation": "{\n    JpqlParser.update_clause_return retval = new JpqlParser.update_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token SET9 = null;\n    Token Comma11 = null;\n    JpqlParser.update_item_return update_item10 = null;\n    JpqlParser.update_item_return update_item12 = null;\n    CommonTree SET9_tree = null;\n    CommonTree Comma11_tree = null;\n    RewriteRuleTokenStream stream_SET = new RewriteRuleTokenStream(adaptor, \"token SET\");\n    RewriteRuleTokenStream stream_Comma = new RewriteRuleTokenStream(adaptor, \"token Comma\");\n    RewriteRuleSubtreeStream stream_update_item = new RewriteRuleSubtreeStream(adaptor, \"rule update_item\");\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:75:15: ( SET update_item ( Comma update_item )* -> ^( ST_UPDATE update_item ( update_item )* ) )\n        // org/batoo/jpa/jpql/JpqlParser.g:76:5: SET update_item ( Comma update_item )*\n        {\n            SET9 = (Token) match(input, SET, FOLLOW_SET_in_update_clause369);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_SET.add(SET9);\n            pushFollow(FOLLOW_update_item_in_update_clause371);\n            update_item10 = update_item();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                stream_update_item.add(update_item10.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:76:21: ( Comma update_item )*\n            loop3: do {\n                int alt3 = 2;\n                switch(input.LA(1)) {\n                    case Comma:\n                        {\n                            alt3 = 1;\n                        }\n                        break;\n                }\n                switch(alt3) {\n                    case 1:\n                        // org/batoo/jpa/jpql/JpqlParser.g:76:22: Comma update_item\n                        {\n                            Comma11 = (Token) match(input, Comma, FOLLOW_Comma_in_update_clause374);\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_Comma.add(Comma11);\n                            pushFollow(FOLLOW_update_item_in_update_clause376);\n                            update_item12 = update_item();\n                            state._fsp--;\n                            if (state.failed)\n                                return retval;\n                            if (state.backtracking == 0)\n                                stream_update_item.add(update_item12.getTree());\n                        }\n                        break;\n                    default:\n                        break loop3;\n                }\n            } while (true);\n            // AST REWRITE\n            // elements: update_item, update_item\n            // token labels:\n            // rule labels: retval\n            // token list labels:\n            // rule list labels:\n            // wildcard labels:\n            if (state.backtracking == 0) {\n                retval.tree = root_0;\n                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval != null ? retval.tree : null);\n                root_0 = (CommonTree) adaptor.nil();\n                // 77:9: -> ^( ST_UPDATE update_item ( update_item )* )\n                {\n                    // org/batoo/jpa/jpql/JpqlParser.g:77:12: ^( ST_UPDATE update_item ( update_item )* )\n                    {\n                        CommonTree root_1 = (CommonTree) adaptor.nil();\n                        root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(ST_UPDATE, \"ST_UPDATE\"), root_1);\n                        adaptor.addChild(root_1, stream_update_item.nextTree());\n                        // org/batoo/jpa/jpql/JpqlParser.g:77:36: ( update_item )*\n                        while (stream_update_item.hasNext()) {\n                            adaptor.addChild(root_1, stream_update_item.nextTree());\n                        }\n                        stream_update_item.reset();\n                        adaptor.addChild(root_0, root_1);\n                    }\n                }\n                retval.tree = root_0;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:75:1: update_clause : SET update_item ( Comma update_item )* -> ^( ST_UPDATE update_item ( update_item )* ) ;\n", "repo_name": "BatooJPA-master/", "id": 1347, "method_signature": "JpqlParser.update_clause_return update_clause()"}, "JpqlParser.update_item": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.addChild", "JpqlParser.qid_return.getTree", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.new_value_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.update_item", "method_implementation": "{\n    JpqlParser.update_item_return retval = new JpqlParser.update_item_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token Equals_Operator14 = null;\n    JpqlParser.qid_return qid13 = null;\n    JpqlParser.new_value_return new_value15 = null;\n    CommonTree Equals_Operator14_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:79:13: ( qid Equals_Operator ^ new_value )\n        // org/batoo/jpa/jpql/JpqlParser.g:80:5: qid Equals_Operator ^ new_value\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            pushFollow(FOLLOW_qid_in_update_item409);\n            qid13 = qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, qid13.getTree());\n            Equals_Operator14 = (Token) match(input, Equals_Operator, FOLLOW_Equals_Operator_in_update_item411);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                Equals_Operator14_tree = (CommonTree) adaptor.create(Equals_Operator14);\n                root_0 = (CommonTree) adaptor.becomeRoot(Equals_Operator14_tree, root_0);\n            }\n            pushFollow(FOLLOW_new_value_in_update_item414);\n            new_value15 = new_value();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, new_value15.getTree());\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:79:1: update_item : qid Equals_Operator ^ new_value ;\n", "repo_name": "BatooJPA-master/", "id": 1348, "method_signature": "JpqlParser.update_item_return update_item()"}, "JpqlParser.update_statement": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.aliased_qid_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.update_clause_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.where_clause_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.update_statement", "method_implementation": "{\n    JpqlParser.update_statement_return retval = new JpqlParser.update_statement_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token UPDATE5 = null;\n    JpqlParser.aliased_qid_return aliased_qid6 = null;\n    JpqlParser.update_clause_return update_clause7 = null;\n    JpqlParser.where_clause_return where_clause8 = null;\n    CommonTree UPDATE5_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:72:18: ( UPDATE ^ aliased_qid update_clause ( where_clause )? )\n        // org/batoo/jpa/jpql/JpqlParser.g:73:5: UPDATE ^ aliased_qid update_clause ( where_clause )?\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            UPDATE5 = (Token) match(input, UPDATE, FOLLOW_UPDATE_in_update_statement347);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                UPDATE5_tree = (CommonTree) adaptor.create(UPDATE5);\n                root_0 = (CommonTree) adaptor.becomeRoot(UPDATE5_tree, root_0);\n            }\n            pushFollow(FOLLOW_aliased_qid_in_update_statement350);\n            aliased_qid6 = aliased_qid();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, aliased_qid6.getTree());\n            pushFollow(FOLLOW_update_clause_in_update_statement352);\n            update_clause7 = update_clause();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, update_clause7.getTree());\n            // org/batoo/jpa/jpql/JpqlParser.g:73:39: ( where_clause )?\n            int alt2 = 2;\n            switch(input.LA(1)) {\n                case WHERE:\n                    {\n                        alt2 = 1;\n                    }\n                    break;\n            }\n            switch(alt2) {\n                case 1:\n                    // org/batoo/jpa/jpql/JpqlParser.g:73:40: where_clause\n                    {\n                        pushFollow(FOLLOW_where_clause_in_update_statement355);\n                        where_clause8 = where_clause();\n                        state._fsp--;\n                        if (state.failed)\n                            return retval;\n                        if (state.backtracking == 0)\n                            adaptor.addChild(root_0, where_clause8.getTree());\n                    }\n                    break;\n            }\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:72:1: update_statement : UPDATE ^ aliased_qid update_clause ( where_clause )? ;\n", "repo_name": "BatooJPA-master/", "id": 1346, "method_signature": "JpqlParser.update_statement_return update_statement()"}, "JpqlParser.when_clause": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.conditional_expression_return.getTree", "CommonTreeAdaptor.addChild", "JpqlParser.scalar_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.when_clause", "method_implementation": "{\n    JpqlParser.when_clause_return retval = new JpqlParser.when_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token WHEN133 = null;\n    Token THEN135 = null;\n    JpqlParser.conditional_expression_return conditional_expression134 = null;\n    JpqlParser.scalar_expression_return scalar_expression136 = null;\n    CommonTree WHEN133_tree = null;\n    CommonTree THEN135_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:208:13: ( WHEN ^ conditional_expression THEN ! scalar_expression )\n        // org/batoo/jpa/jpql/JpqlParser.g:209:2: WHEN ^ conditional_expression THEN ! scalar_expression\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            WHEN133 = (Token) match(input, WHEN, FOLLOW_WHEN_in_when_clause1873);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                WHEN133_tree = (CommonTree) adaptor.create(WHEN133);\n                root_0 = (CommonTree) adaptor.becomeRoot(WHEN133_tree, root_0);\n            }\n            pushFollow(FOLLOW_conditional_expression_in_when_clause1876);\n            conditional_expression134 = conditional_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, conditional_expression134.getTree());\n            THEN135 = (Token) match(input, THEN, FOLLOW_THEN_in_when_clause1878);\n            if (state.failed)\n                return retval;\n            pushFollow(FOLLOW_scalar_expression_in_when_clause1881);\n            scalar_expression136 = scalar_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, scalar_expression136.getTree());\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:208:1: when_clause : WHEN ^ conditional_expression THEN ! scalar_expression ;\n", "repo_name": "BatooJPA-master/", "id": 1378, "method_signature": "JpqlParser.when_clause_return when_clause()"}, "JpqlParser.where_clause": {"callee_method_names": ["CommonTreeAdaptor.nil", "CommonTreeAdaptor.create", "CommonTreeAdaptor.becomeRoot", "CommonTreeAdaptor.addChild", "JpqlParser.conditional_expression_return.getTree", "CommonTreeAdaptor.rulePostProcessing", "CommonTreeAdaptor.setTokenBoundaries", "CommonTreeAdaptor.errorNode"], "method_name": "JpqlParser.where_clause", "method_implementation": "{\n    JpqlParser.where_clause_return retval = new JpqlParser.where_clause_return();\n    retval.start = input.LT(1);\n    CommonTree root_0 = null;\n    Token WHERE69 = null;\n    JpqlParser.conditional_expression_return conditional_expression70 = null;\n    CommonTree WHERE69_tree = null;\n    try {\n        // org/batoo/jpa/jpql/JpqlParser.g:127:14: ( WHERE ^ conditional_expression )\n        // org/batoo/jpa/jpql/JpqlParser.g:128:5: WHERE ^ conditional_expression\n        {\n            root_0 = (CommonTree) adaptor.nil();\n            WHERE69 = (Token) match(input, WHERE, FOLLOW_WHERE_in_where_clause876);\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0) {\n                WHERE69_tree = (CommonTree) adaptor.create(WHERE69);\n                root_0 = (CommonTree) adaptor.becomeRoot(WHERE69_tree, root_0);\n            }\n            pushFollow(FOLLOW_conditional_expression_in_where_clause879);\n            conditional_expression70 = conditional_expression();\n            state._fsp--;\n            if (state.failed)\n                return retval;\n            if (state.backtracking == 0)\n                adaptor.addChild(root_0, conditional_expression70.getTree());\n        }\n        retval.stop = input.LT(-1);\n        if (state.backtracking == 0) {\n            retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);\n            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);\n        }\n    } catch (RecognitionException re) {\n        reportError(re);\n        recover(input, re);\n        retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);\n    } finally {\n        // do for sure before leaving\n    }\n    return retval;\n}", "repo_id": "1", "comment": "// org/batoo/jpa/jpql/JpqlParser.g:127:1: where_clause : WHERE ^ conditional_expression ;\n", "repo_name": "BatooJPA-master/", "id": 1360, "method_signature": "JpqlParser.where_clause_return where_clause()"}, "JpqlQuery.construct": {"callee_method_names": ["CommonTree.getChild", "Tree.getType", "Tree.getType"], "method_name": "JpqlQuery.construct", "method_implementation": "{\n    final Tree type = tree.getChild(0);\n    if (type.getType() == JpqlParser.SELECT) {\n        return this.constructSelectQuery(cb, tree);\n    } else if (type.getType() == JpqlParser.DELETE) {\n        return this.constructDeleteQuery(cb, tree);\n    } else {\n        return this.constructUpdateQuery(cb, tree);\n    }\n}", "repo_id": "1", "comment": "/**\n * Constructs the query object.\n *\n * @param cb\n *            the criteria builder\n * @param tree\n *            the query tree\n *\n * @return the constructed criteria query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 757, "method_signature": "BaseQueryImpl<?> construct(CriteriaBuilderImpl, CommonTree)"}, "JpqlQuery.constructDeleteQuery": {"callee_method_names": ["CommonTree.getChild", "Tree.getChild", "Aliased.getQualified", "CriteriaDeleteImpl.from", "Tree.getChildCount", "CriteriaDeleteImpl.where", "Tree.getChild"], "method_name": "JpqlQuery.constructDeleteQuery", "method_implementation": "{\n    final CriteriaDeleteImpl q = new CriteriaDeleteImpl(this.metamodel, this.qlString);\n    final Tree deleteDef = tree.getChild(0);\n    final Tree aliasedDef = deleteDef.getChild(0);\n    final Aliased aliased = new Aliased(aliasedDef);\n    final EntityTypeImpl entity = this.getEntity(aliased.getQualified().toString());\n    final RootImpl<?> r = (RootImpl<?>) q.from(entity);\n    this.putAlias(q, aliasedDef, aliased, r);\n    if (deleteDef.getChildCount() == 2) {\n        q.where(this.constructJunction(cb, q, deleteDef.getChild(1)));\n    }\n    return q;\n}", "repo_id": "1", "comment": "/**\n * Constructs an update query.\n *\n * @param cb\n *            the criteria builder\n * @param tree\n *            the tree\n * @return the query constructed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 758, "method_signature": "CriteriaDeleteImpl constructDeleteQuery(CriteriaBuilderImpl, CommonTree)"}, "JpqlQuery.constructFrom": {"callee_method_names": ["Tree.getChildCount", "Tree.getChild", "Tree.getType", "Tree.getChild", "Aliased.getQualified", "AbstractQuery<?>.from", "RootImpl<Object>.alias", "Aliased.getAlias", "Tree.getChild", "Tree.getChild", "Tree.getChildCount", "EntityTypeImpl<Object>.getAssociations", "SingularAssociationMappingImpl<? super X, ?>.isEager", "SingularAssociationMappingImpl<? super X, ?>.getPath", "Iterator<String>.next", "Iterator<String>.hasNext", "RootImpl<Object>.fetch", "Iterator<String>.next", "Fetch<?, ?>.fetch", "Iterator<String>.next", "Tree.getType", "Tree.getChild", "Tree.getChild", "Aliased.getQualified", "Tree.getLine", "Tree.getCharPositionInLine", "AbstractFrom<?, ?>.join", "AbstractFrom<?, ?>.alias", "Aliased.getAlias", "Tree.getChild", "Aliased.getQualified", "AbstractQuery<?>.from", "RootImpl<Object>.alias", "Aliased.getAlias"], "method_name": "JpqlQuery.constructFrom", "method_implementation": "{\n    for (int i = 0; i < froms.getChildCount(); i++) {\n        final Tree from = froms.getChild(i);\n        // root query from\n        if (from.getType() == JpqlParser.ST_FROM) {\n            final Aliased fromDef = new Aliased(from.getChild(0));\n            final EntityTypeImpl<Object> entity = this.getEntity(fromDef.getQualified().toString());\n            final RootImpl<Object> r = (RootImpl<Object>) q.from(entity);\n            r.alias(fromDef.getAlias());\n            this.putAlias((BaseQuery<?>) q, from, fromDef, r);\n            this.constructJoins(cb, q, r, from.getChild(1));\n            if (from.getChild(from.getChildCount() - 1).getType() == JpqlParser.LALL_PROPERTIES) {\n                for (final AssociationMappingImpl<?, ?, ?> association : entity.getAssociations()) {\n                    if (!association.isEager()) {\n                        final Iterator<String> pathIterator = Splitter.on(\".\").split(association.getPath()).iterator();\n                        // Drop the root part\n                        pathIterator.next();\n                        Fetch<?, ?> fetch = null;\n                        while (pathIterator.hasNext()) {\n                            fetch = fetch == null ? r.fetch(pathIterator.next()) : fetch.fetch(pathIterator.next());\n                        }\n                    }\n                }\n            }\n        } else // in collection form\n        if (from.getType() == JpqlParser.ST_COLL) {\n            final Aliased aliased = new Aliased(from.getChild(1));\n            AbstractFrom<?, ?> parent = this.getAliased(q, from.getChild(0).getText());\n            int depth = 0;\n            for (final String segment : aliased.getQualified().getSegments()) {\n                if ((depth > 0) && (parent instanceof PluralJoin)) {\n                    throw new PersistenceException(\"Cannot qualify, only embeddable joins within the path allowed, \" + \"line \" + from.getLine() + \":\" + from.getCharPositionInLine());\n                }\n                parent = parent.join(segment, JoinType.LEFT);\n                depth++;\n            }\n            parent.alias(aliased.getAlias());\n            this.putAlias((BaseQueryImpl<?>) q, from.getChild(1), aliased, parent);\n        } else // sub query from\n        {\n            final Aliased fromDef = new Aliased(from);\n            final EntityTypeImpl<Object> entity = this.getEntity(fromDef.getQualified().toString());\n            final RootImpl<Object> r = (RootImpl<Object>) q.from(entity);\n            r.alias(fromDef.getAlias());\n            this.putAlias((BaseQuery<?>) q, from, fromDef, r);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates the from fragment of the query.\n *\n * @param cb\n *            the criteria builder\n * @param q\n *            the query\n * @param from\n *            the from metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 759, "method_signature": "void constructFrom(CriteriaBuilderImpl, AbstractQuery, Tree)"}, "JpqlQuery.constructGroupBy": {"callee_method_names": ["Tree.getChildCount", "List<Expression<?>>.add", "Tree.getChild"], "method_name": "JpqlQuery.constructGroupBy", "method_implementation": "{\n    final List<Expression<?>> groupBy = Lists.newArrayList();\n    for (int i = 0; i < groupByDef.getChildCount(); i++) {\n        groupBy.add(this.getExpression(cb, q, groupByDef.getChild(i), null));\n    }\n    return groupBy;\n}", "repo_id": "1", "comment": "/**\n * Creates the group by fragment of the query.\n *\n * @param cb\n *            the criteria builder\n * @param q\n *            the query\n * @param from\n *            the from metadata\n * @return the list of group by expressions\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 760, "method_signature": "List<Expression<?>> constructGroupBy(CriteriaBuilderImpl, AbstractQuery, Tree)"}, "JpqlQuery.constructJoins": {"callee_method_names": ["Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Qualified.getSegments", "AbstractFrom<?, ?>.fetch", "Tree.getChild", "Tree.getChild", "Aliased.getQualified", "Tree.getLine", "Tree.getCharPositionInLine", "AbstractFrom<?, ?>.join", "AbstractFrom<?, ?>.alias", "Aliased.getAlias", "Tree.getChild"], "method_name": "JpqlQuery.constructJoins", "method_implementation": "{\n    for (int i = 0; i < joins.getChildCount(); i++) {\n        final Tree join = joins.getChild(i);\n        JoinType joinType = JoinType.INNER;\n        final int joinSpecification = join.getChild(0).getType();\n        int offset = 0;\n        if (joinSpecification == JpqlParser.INNER) {\n            offset = 1;\n            joinType = JoinType.INNER;\n        } else if (joinSpecification == JpqlParser.LEFT) {\n            offset = 1;\n            joinType = JoinType.LEFT;\n        }\n        if (join.getChildCount() == (offset + 3)) {\n            FetchParent<?, ?> parent = this.getAliased(q, join.getChild(offset).getText());\n            final Qualified qualified = new Qualified(join.getChild(offset + 1).getChild(0));\n            for (final String segment : qualified.getSegments()) {\n                parent = parent.fetch(segment, joinType);\n            }\n        } else {\n            AbstractFrom<?, ?> parent = this.getAliased(q, join.getChild(offset).getText());\n            final Aliased aliased = new Aliased(join.getChild(offset + 1));\n            int depth = 0;\n            for (final String segment : aliased.getQualified().getSegments()) {\n                if ((depth > 0) && (parent instanceof PluralJoin)) {\n                    throw new PersistenceException(\"Cannot qualify, only embeddable joins within the path allowed, \" + \"line \" + join.getLine() + \":\" + join.getCharPositionInLine());\n                }\n                parent = parent.join(segment, joinType);\n                depth++;\n            }\n            parent.alias(aliased.getAlias());\n            this.putAlias((BaseQuery<?>) q, join.getChild(1), aliased, parent);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates the from fragment of the query.\n *\n * @param cb\n *            the criteria builder\n * @param q\n *            the query join\n * @param r\n *            the root\n * @param joins\n *            the joins metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 761, "method_signature": "void constructJoins(CriteriaBuilderImpl, AbstractQuery, RootImpl, Tree)"}, "JpqlQuery.constructJunction": {"callee_method_ids": [524, 506], "callee_method_names": ["Tree.getChildCount", "Tree.getChild", "Tree.getType", "Tree.getType", "List<AbstractExpression<Boolean>>.add", "List<AbstractExpression<Boolean>>.add", "List<AbstractExpression<Boolean>>.size", "List<AbstractExpression<Boolean>>.get", "Tree.getType", "CriteriaBuilderImpl.or", "List<AbstractExpression<Boolean>>.toArray", "List<AbstractExpression<Boolean>>.size", "List<AbstractExpression<Boolean>>.size", "List<AbstractExpression<Boolean>>.size", "List<AbstractExpression<Boolean>>.get", "CriteriaBuilderImpl.and"], "method_name": "JpqlQuery.constructJunction", "method_implementation": "{\n    final List<AbstractExpression<Boolean>> predictions = Lists.newArrayList();\n    for (int i = 0; i < junctionDef.getChildCount(); i++) {\n        final Tree childDef = junctionDef.getChild(i);\n        if ((childDef.getType() == JpqlParser.LOR) || (childDef.getType() == JpqlParser.LAND)) {\n            predictions.add(this.constructJunction(cb, q, childDef));\n        } else {\n            predictions.add(this.getExpression(cb, q, childDef, Boolean.class));\n        }\n    }\n    if (predictions.size() == 1) {\n        return predictions.get(0);\n    }\n    if (junctionDef.getType() == JpqlParser.LOR) {\n        return cb.or(predictions.toArray(new Predicate[predictions.size()]));\n    }\n    final Predicate[] predicates = new Predicate[predictions.size()];\n    for (int i = 0; i < predictions.size(); i++) {\n        final AbstractExpression<Boolean> expression = predictions.get(i);\n        if (expression instanceof PredicateImpl) {\n            predicates[i] = (Predicate) expression;\n        } else {\n            predicates[i] = new PredicateImpl(expression);\n        }\n    }\n    return cb.and(predicates);\n}", "repo_id": "1", "comment": "/**\n * Constructs an AND junction.\n *\n * @param cb\n *            the criteria builder\n * @param disjunctionDef\n *            the junction definition\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 762, "method_signature": "AbstractExpression<Boolean> constructJunction(CriteriaBuilderImpl, Object, Tree)"}, "JpqlQuery.constructOrder": {"callee_method_names": ["Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getType", "Tree.getText", "String.equals", "AbstractSelection<?>.getAlias", "Tree.getChildCount", "CriteriaBuilderImpl.desc", "CriteriaBuilderImpl.asc", "Tree.getChildCount", "CriteriaBuilderImpl.desc", "CriteriaBuilderImpl.asc", "Tree.getChild", "List<Order>.add", "CriteriaQueryImpl<?>.orderBy"], "method_name": "JpqlQuery.constructOrder", "method_implementation": "{\n    final List<Order> orders = Lists.newArrayList();\n    for (int i = 0; i < orderBy.getChildCount(); i++) {\n        final Tree orderByItem = orderBy.getChild(i);\n        final Tree orderItem = orderByItem.getChild(0);\n        Order order = null;\n        if (orderItem.getType() == JpqlParser.ID) {\n            final String alias = orderItem.getText();\n            for (final Selection<?> selection : selections) {\n                if (alias.equals(selection.getAlias())) {\n                    order = //\n                    orderByItem.getChildCount() == 2 ? //\n                    cb.desc((Expression<?>) selection) : cb.asc((Expression<?>) selection);\n                    break;\n                }\n            }\n            if (order == null) {\n                throw new PersistenceException(\"Alias is not bound: \" + alias);\n            }\n        } else {\n            order = //\n            orderByItem.getChildCount() == 2 ? //\n            cb.desc(this.getExpression(cb, q, orderItem, null)) : cb.asc(this.getExpression(cb, q, orderByItem.getChild(0), null));\n        }\n        orders.add(order);\n    }\n    q.orderBy(orders);\n}", "repo_id": "1", "comment": "/**\n * Constructs the order by fragment of the query.\n *\n * @param cb\n *            the criteria builder\n * @param q\n *            the query\n * @param selections\n *            the selections\n * @param orderBy\n *            the order by definitions\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 763, "method_signature": "void constructOrder(CriteriaBuilderImpl, CriteriaQueryImpl, List, Tree)"}, "JpqlQuery.constructSelect": {"callee_method_names": ["Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getChildCount", "AbstractSelection<?>.alias", "Tree.getChild", "List<Selection<?>>.add", "CriteriaQueryImpl<?>.updateResultClass"], "method_name": "JpqlQuery.constructSelect", "method_implementation": "{\n    final List<Selection<?>> selections = Lists.newArrayList();\n    for (int i = 0; i < selects.getChildCount(); i++) {\n        final Tree selectDef = selects.getChild(i);\n        final AbstractSelection<?> selection = this.constructSingleSelect(cb, q, selectDef.getChild(0));\n        if (selectDef.getChildCount() == 2) {\n            selection.alias(selectDef.getChild(1).getText());\n        }\n        selections.add(selection);\n    }\n    q.updateResultClass(selections);\n    return selections;\n}", "repo_id": "1", "comment": "/**\n * Creates the select fragment of the query.\n *\n * @param cb\n *            the criteria builder\n * @param q\n *            the query\n * @param from\n *            the from metadata\n * @return the select constructed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 764, "method_signature": "List<Selection<?>> constructSelect(CriteriaBuilderImpl, CriteriaQueryImpl, Tree)"}, "JpqlQuery.constructSelectQuery": {"callee_method_names": ["CommonTree.getChild", "CommonTree.getChild", "Tree.getChild", "Tree.getChildCount", "List<Selection<?>>.size", "CriteriaQueryImpl.select", "List<Selection<?>>.get", "CriteriaQueryImpl.multiselect", "Tree.getChild", "CriteriaQueryImpl.distinct", "CommonTree.getChild", "Tree.getType", "Tree.getType", "CriteriaQueryImpl.where", "Tree.getChild", "Tree.getType", "CriteriaQueryImpl.groupBy", "Tree.getType", "CriteriaQueryImpl.having", "Tree.getChild", "Tree.getType"], "method_name": "JpqlQuery.constructSelectQuery", "method_implementation": "{\n    final CriteriaQueryImpl q = new CriteriaQueryImpl(this.metamodel, this.qlString);\n    this.constructFrom(cb, q, tree.getChild(1));\n    final Tree select = tree.getChild(0);\n    final List<Selection<?>> selections = this.constructSelect(cb, q, select.getChild(select.getChildCount() - 1));\n    if (selections.size() == 1) {\n        q.select(selections.get(0));\n    } else {\n        q.multiselect(selections);\n    }\n    if (select.getChild(0).getType() == JpqlParser.DISTINCT) {\n        q.distinct(true);\n    }\n    int i = 2;\n    while (true) {\n        final Tree child = tree.getChild(i);\n        // end of query\n        if (child.getType() == JpqlParser.EOF) {\n            break;\n        }\n        // where fragment\n        if (child.getType() == JpqlParser.WHERE) {\n            q.where(this.constructJunction(cb, q, child.getChild(0)));\n        }\n        // group by fragment\n        if (child.getType() == JpqlParser.LGROUP_BY) {\n            q.groupBy(this.constructGroupBy(cb, q, child));\n        }\n        // having fragment\n        if (child.getType() == JpqlParser.HAVING) {\n            q.having(this.constructJunction(cb, q, child.getChild(0)));\n        }\n        // order by fragment\n        if (child.getType() == JpqlParser.LORDER) {\n            this.constructOrder(cb, q, selections, child);\n        }\n        i++;\n        continue;\n    }\n    return q;\n}", "repo_id": "1", "comment": "/**\n * Constructs an select query.\n *\n * @param cb\n *            the criteria builder\n * @param tree\n *            the tree\n * @return the constructed query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 765, "method_signature": "CriteriaQueryImpl constructSelectQuery(CriteriaBuilderImpl, CommonTree)"}, "JpqlQuery.constructSingleSelect": {"callee_method_names": ["Tree.getType", "Tree.getChild", "Tree.getChild", "Tree.getChildCount", "Tree.getChild", "List<Selection<?>>.add", "CriteriaBuilderImpl.construct", "List<Selection<?>>.toArray", "List<Selection<?>>.size", "Tree.getLine", "Tree.getCharPositionInLine", "Tree.getType", "Tree.getChild"], "method_name": "JpqlQuery.constructSingleSelect", "method_implementation": "{\n    // constructor select\n    if (selectDef.getType() == JpqlParser.NEW) {\n        final String className = new Qualified(selectDef.getChild(0)).toString();\n        final List<Selection<?>> childSelections = Lists.newArrayList();\n        final Tree arguments = selectDef.getChild(1);\n        for (int i = 0; i < arguments.getChildCount(); i++) {\n            final Tree argumentDef = arguments.getChild(i);\n            childSelections.add(this.getExpression(cb, q, argumentDef, null));\n        }\n        try {\n            final Class<?> clazz = this.metamodel.getEntityManagerFactory().getClassloader().loadClass(className);\n            return cb.construct(clazz, childSelections.toArray(new Selection[childSelections.size()]));\n        } catch (final ClassNotFoundException e) {\n            throw new PersistenceException(\"Cannot load class: \" + className + \", line \" + selectDef.getLine() + \":\" + selectDef.getCharPositionInLine());\n        }\n    }\n    // object type\n    if (selectDef.getType() == JpqlParser.OBJECT) {\n        final String alias = selectDef.getChild(0).getText();\n        return this.getAliased(q, alias);\n    }\n    return this.getExpression(cb, q, selectDef, null);\n}", "repo_id": "1", "comment": "/**\n * Creates a single select item.\n *\n * @param cb\n *            the criteria builder\n * @param q\n *            the query\n * @param selectDef\n *            the select definition\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 766, "method_signature": "AbstractSelection<?> constructSingleSelect(CriteriaBuilderImpl, CriteriaQueryImpl, Tree)"}, "JpqlQuery.constructSubquery": {"callee_method_names": ["Tree.getChild", "Tree.getType", "Tree.getChild", "Tree.getChild", "SubqueryImpl<T>.select", "Tree.getChild", "SubqueryImpl<T>.distinct", "Tree.getChild", "Tree.getType", "SubqueryImpl<T>.where", "Tree.getChild", "Tree.getType", "SubqueryImpl<T>.groupBy", "Tree.getType", "SubqueryImpl<T>.having", "Tree.getChild"], "method_name": "JpqlQuery.constructSubquery", "method_implementation": "{\n    final SubqueryImpl<T> s;\n    if (q instanceof CriteriaQueryImpl) {\n        s = ((CriteriaQueryImpl<?>) q).subquery(javaType);\n    } else if (q instanceof CriteriaUpdateImpl) {\n        s = ((CriteriaUpdateImpl<?>) q).subquery(javaType);\n    } else {\n        s = ((CriteriaDeleteImpl<?>) q).subquery(javaType);\n    }\n    final Tree type = subQueryDef.getChild(0);\n    if (type.getType() == JpqlParser.SELECT) {\n        this.constructFrom(cb, s, subQueryDef.getChild(1));\n        final Tree selectDef = subQueryDef.getChild(0).getChild(0);\n        s.select(this.getExpression(cb, s, selectDef, javaType));\n        if (subQueryDef.getChild(1).getType() == JpqlParser.DISTINCT) {\n            s.distinct(true);\n        }\n        int i = 2;\n        while (true) {\n            final Tree child = subQueryDef.getChild(i);\n            // en of sub query\n            if (child == null) {\n                break;\n            }\n            // where fragment\n            if (child.getType() == JpqlParser.WHERE) {\n                s.where(this.constructJunction(cb, s, child.getChild(0)));\n            }\n            // group by fragment\n            if (child.getType() == JpqlParser.LGROUP_BY) {\n                s.groupBy(this.constructGroupBy(cb, s, child));\n            }\n            // having fragment\n            if (child.getType() == JpqlParser.HAVING) {\n                s.having(this.constructJunction(cb, s, child.getChild(0)));\n            }\n            i++;\n            continue;\n        }\n    }\n    return s;\n}", "repo_id": "1", "comment": "/**\n * @param cb\n *            the crtieria builder\n * @param q\n *            the critieria query\n * @param subQueryDef\n *            the sub query definition\n * @return the sub query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 767, "method_signature": "SubqueryImpl<T> constructSubquery(CriteriaBuilderImpl, Object, Tree, Class)"}, "JpqlQuery.constructUpdateQuery": {"callee_method_names": ["CommonTree.getChild", "Tree.getChild", "Aliased.getQualified", "CriteriaUpdateImpl<?>.from", "Aliased.getAlias", "RootImpl<?>.alias", "Aliased.getAlias", "Tree.getChild", "Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getType", "Tree.getChildCount", "Tree.getChild", "Tree.getText", "RootImpl<?>.getAlias", "RootImpl<?>.getExpression", "Tree.getText", "Tree.getText", "Tree.getText", "Tree.getText", "AbstractExpression.getJavaType", "CriteriaUpdateImpl<?>.set", "Tree.getText", "Tree.getChildCount", "CriteriaUpdateImpl<?>.where", "Tree.getChild"], "method_name": "JpqlQuery.constructUpdateQuery", "method_implementation": "{\n    final CriteriaUpdateImpl<?> q = new CriteriaUpdateImpl(this.metamodel, this.qlString);\n    final Tree updateDef = tree.getChild(0);\n    final Tree aliasedDef = updateDef.getChild(0);\n    final Aliased aliased = new Aliased(aliasedDef);\n    final EntityTypeImpl entity = this.getEntity(aliased.getQualified().toString());\n    final RootImpl<?> r = (RootImpl<?>) q.from(entity);\n    this.putAlias(q, aliasedDef, aliased, r);\n    if (StringUtils.isNotBlank(aliased.getAlias())) {\n        r.alias(aliased.getAlias());\n    }\n    final Tree setDefs = updateDef.getChild(1);\n    for (int i = 0; i < setDefs.getChildCount(); i++) {\n        final Tree setDef = setDefs.getChild(i);\n        final Tree leftDef = setDef.getChild(0);\n        final Tree rightDef = setDef.getChild(1);\n        AbstractExpression left = null;\n        if (leftDef.getType() == JpqlParser.LQUALIFIED) {\n            for (int j = 0; j < leftDef.getChildCount(); j++) {\n                final Tree child = leftDef.getChild(j);\n                if ((left == null) && child.getText().equals(r.getAlias())) {\n                    left = r;\n                } else if (left == null) {\n                    left = r.getExpression(child.getText());\n                } else if (left instanceof SingularJoin) {\n                    left = ((SingularJoin<?, ?>) left).getExpression(child.getText());\n                } else if (left instanceof RootImpl) {\n                    left = ((RootImpl<?>) left).getExpression(child.getText());\n                } else {\n                    throw new PersistenceException(\"cannot dereference: \" + leftDef.getText());\n                }\n            }\n        }\n        if (left instanceof BasicPath) {\n            final AbstractExpression right = this.getExpression(cb, q, rightDef, left.getJavaType());\n            q.set((BasicPath<?>) left, right);\n        } else {\n            throw new PersistenceException(\"Path does not resolve to a state field: \" + leftDef.getText());\n        }\n    }\n    if (updateDef.getChildCount() == 3) {\n        q.where(this.constructJunction(cb, q, updateDef.getChild(2)));\n    }\n    return q;\n}", "repo_id": "1", "comment": "/**\n * Constructs an update query.\n *\n * @param cb\n *            the criteria builder\n * @param tree\n *            the tree\n * @return the update query constructed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 768, "method_signature": "CriteriaUpdateImpl<?> constructUpdateQuery(CriteriaBuilderImpl, CommonTree)"}, "JpqlQuery.createTypedQuery": {"callee_method_names": ["QueryImpl<T>.setLockMode", "QueryImpl<T>.setHint", "Entry.getKey", "Entry.getValue"], "method_name": "JpqlQuery.createTypedQuery", "method_implementation": "{\n    if (this.lastUsed != Long.MAX_VALUE) {\n        this.lastUsed = System.currentTimeMillis();\n    }\n    final QueryImpl<T> typedQuery = new QueryImpl<T>((BaseQuery<T>) this.q, entityManager);\n    if (this.lockMode != LockModeType.NONE) {\n        typedQuery.setLockMode(this.lockMode);\n    }\n    if (this.hints != null) {\n        for (final Entry<String, Object> entry : this.hints.entrySet()) {\n            typedQuery.setHint(entry.getKey(), entry.getValue());\n        }\n    }\n    return typedQuery;\n}", "repo_id": "1", "comment": "/**\n * Creates a typed query for the JPQL.\n *\n * @param entityManager\n *            the entity manager\n * @param <T>\n *            the result type\n * @return the typed query\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 769, "method_signature": "QueryImpl<T> createTypedQuery(EntityManagerImpl)"}, "JpqlQuery.getExpression": {"callee_method_ids": [513, 521, 514, 515, 516, 517, 507, 628, 522, 518, 522, 518, 527, 527], "callee_method_names": ["Tree.getType", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getChild", "AbstractExpression<?>.getJavaType", "Tree.getChild", "Tree.getChild", "Tree.getChild", "AbstractExpression<?>.getJavaType", "Tree.getLine", "Tree.getCharPositionInLine", "Tree.getChild", "Tree.getChild", "Tree.getType", "Tree.getType", "Tree.getType", "AbstractExpression<?>.getJavaType", "AbstractExpression<?>.getJavaType", "Tree.getType", "CriteriaBuilderImpl.equal", "CriteriaBuilderImpl.notEqual", "AbstractExpression<?>.getJavaType", "CriteriaBuilderImpl.greaterThan", "CriteriaBuilderImpl.gt", "AbstractExpression<?>.getJavaType", "CriteriaBuilderImpl.greaterThanOrEqualTo", "CriteriaBuilderImpl.ge", "AbstractExpression<?>.getJavaType", "CriteriaBuilderImpl.lessThan", "CriteriaBuilderImpl.lt", "AbstractExpression<?>.getJavaType", "CriteriaBuilderImpl.lessThanOrEqualTo", "CriteriaBuilderImpl.le", "Tree.getChild", "AbstractExpression<?>.getJavaType", "CriteriaBuilderImpl.between", "Tree.getChildCount", "PredicateImpl.not", "Tree.getType", "Tree.getChild", "Tree.getChild", "Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getChildCount", "CriteriaBuilderImpl.notLike", "CriteriaBuilderImpl.like", "Tree.getChild", "Tree.getChildCount", "CriteriaBuilderImpl.notLike", "CriteriaBuilderImpl.like", "Tree.getType", "Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getType", "Tree.getType", "Tree.getType", "AbstractExpression<?>.notIn", "AbstractExpression<?>.getJavaType", "AbstractExpression<?>.in", "AbstractExpression<?>.getJavaType", "Tree.getType", "Tree.getText", "Tree.getType", "AbstractExpression<?>.getJavaType", "AbstractExpression<?>.notIn", "AbstractExpression<?>.in", "Tree.getChildCount", "List<AbstractExpression<X>>.add", "Tree.getChild", "AbstractExpression<?>.getJavaType", "Tree.getChild", "List<AbstractExpression<X>>.get", "AbstractExpression<?>.notIn", "AbstractExpression<?>.in", "Tree.getType", "Tree.getChild", "Tree.getChildCount", "CriteriaBuilderImpl.isNotNull", "CriteriaBuilderImpl.isNull", "Tree.getType", "Tree.getText", "Tree.getType", "Tree.getChild", "Tree.getChild", "Qualified.getSegments", "int.hasNext", "int.next", "Tree.getLine", "Tree.getCharPositionInLine", "Tree.getType", "CriteriaBuilderImpl.neg", "Tree.getChild", "Tree.getType", "Tree.getText", "CriteriaBuilderImpl.parameter", "Tree.getType", "Tree.getType", "Tree.getText", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getChild", "Tree.getChild", "AbstractExpression<?>.getJavaType", "Tree.getType", "CriteriaBuilderImpl.sum", "CriteriaBuilderImpl.diff", "CriteriaBuilderImpl.prod", "CriteriaBuilderImpl.quot", "Tree.getType", "Tree.getType", "Tree.getText", "Tree.getType", "Tree.getText", "Tree.getText", "Tree.getText", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getChild", "Tree.getType", "CriteriaBuilderImpl.upper", "CriteriaBuilderImpl.lower", "Tree.getChild", "Tree.getChildCount", "Tree.getChild", "Tree.getType", "Tree.getChildCount", "List<AbstractExpression<?>>.add", "Tree.getChild", "List<AbstractExpression<?>>.toArray", "List<AbstractExpression<?>>.size", "Tree.getType", "Tree.getChild", "Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getType", "Tree.getType", "Tree.getType", "Tree.getChild", "Tree.getChild", "EntityTypeImpl<Object>.getRootType", "EntityTypeImpl<Object>.getName", "Tree.getLine", "Tree.getCharPositionInLine", "EntityTypeImpl<Object>.getDiscriminatorValue", "Tree.getType", "CriteriaBuilderImpl.currentDate", "CriteriaBuilderImpl.currentTime", "CriteriaBuilderImpl.currentTimestamp", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "CriteriaBuilderImpl.dateTimeExpression", "Tree.getChild", "Tree.getType", "CriteriaBuilderImpl.abs", "Tree.getChild", "CriteriaBuilderImpl.sqrt", "Tree.getChild", "CriteriaBuilderImpl.mod", "Tree.getChild", "Tree.getChild", "Tree.getChildCount", "CriteriaBuilderImpl.locate", "Tree.getChild", "Tree.getChild", "CriteriaBuilderImpl.locate", "Tree.getChild", "Tree.getChild", "CriteriaBuilderImpl.length", "Tree.getChild", "Tree.getType", "CriteriaBuilderImpl.avg", "Tree.getChild", "CriteriaBuilderImpl.sum", "Tree.getChild", "CriteriaBuilderImpl.max", "Tree.getChild", "CriteriaBuilderImpl.min", "Tree.getChild", "Tree.getType", "Tree.getChildCount", "Tree.getChild", "Tree.getChild", "Tree.getType", "Tree.getChild", "Tree.getChild", "Tree.getChild", "Tree.getType", "Tree.getChild", "Tree.getType", "Tree.getChild", "Tree.getType", "Tree.getType", "CriteriaBuilderImpl.selectCase", "Tree.getChildCount", "Tree.getChild", "Tree.getType", "SimpleCaseImpl<X, Object>.when", "Tree.getChild", "Tree.getChild", "SimpleCaseImpl<X, Object>.otherwise", "Tree.getType", "Tree.getChild", "CriteriaBuilderImpl.selectCase", "Tree.getChildCount", "Tree.getChild", "Tree.getType", "Tree.getChild", "Tree.getChild", "Tree.getChild", "EntityTypeImpl<Object>.getRootType", "EntityTypeImpl<Object>.getName", "Tree.getLine", "Tree.getCharPositionInLine", "EntityTypeImpl<Object>.getDiscriminatorValue", "Tree.getChild", "SimpleCaseImpl<X, Object>.when", "SimpleCaseImpl<X, Object>.otherwise", "Tree.getType", "Tree.getChild", "Tree.getChild", "Tree.getType", "CriteriaBuilderImpl.coalesce", "Tree.getChildCount", "CoalesceExpression<X>.value", "Tree.getChild", "Tree.getType", "Tree.getChild", "Tree.getChildCount", "List<AbstractExpression<?>>.add", "Tree.getChild", "List<AbstractExpression<?>>.toArray", "List<AbstractExpression<?>>.size", "Tree.getType", "Tree.getChild", "Tree.getLine", "Tree.getCharPositionInLine", "Tree.getType", "Tree.getChild", "Tree.getLine", "Tree.getCharPositionInLine", "Tree.getChildCount", "CriteriaBuilderImpl.isNotEmpty", "CriteriaBuilderImpl.isEmpty", "Tree.getType", "Tree.getChild", "Tree.getLine", "Tree.getCharPositionInLine", "CollectionExpression<C, E>.getMapping", "Tree.getChild", "PluralAttributeImpl<?, C, E>.getElementType", "Tree.getChildCount", "CriteriaBuilderImpl.isNotMember", "CriteriaBuilderImpl.isMember", "Tree.getType", "Tree.getChild", "Tree.getLine", "Tree.getCharPositionInLine", "CriteriaBuilderImpl.size", "Tree.getType", "Tree.getChild", "Tree.getChild", "CriteriaBuilderImpl.cast", "Tree.getType", "Tree.getType", "Tree.toStringTree", "Tree.getLine", "Tree.getCharPositionInLine"], "method_name": "JpqlQuery.getExpression", "method_implementation": "{\n    if (//\n    (exprDef.getType() == JpqlParser.Equals_Operator) || //\n    (exprDef.getType() == JpqlParser.Not_Equals_Operator) || //\n    (exprDef.getType() == JpqlParser.Greater_Than_Operator) || //\n    (exprDef.getType() == JpqlParser.Greater_Or_Equals_Operator) || //\n    (exprDef.getType() == JpqlParser.Less_Than_Operator) || //\n    (exprDef.getType() == JpqlParser.Less_Or_Equals_Operator) || (exprDef.getType() == JpqlParser.BETWEEN)) {\n        final AbstractExpression<X> left;\n        final AbstractExpression<X> right;\n        if ((exprDef.getChild(0).getType() == JpqlParser.ST_SUBQUERY) || (exprDef.getChild(1).getType() == JpqlParser.ST_SUBQUERY)) {\n            // left side is sub query\n            if (exprDef.getChild(0).getType() == JpqlParser.ST_SUBQUERY) {\n                right = this.getExpression(cb, q, exprDef.getChild(1), null);\n                left = (AbstractExpression<X>) this.constructSubquery(cb, q, exprDef.getChild(0), right.getJavaType());\n                // right side is sub query\n            } else if (exprDef.getChild(1).getType() == JpqlParser.ST_SUBQUERY) {\n                left = this.getExpression(cb, q, exprDef.getChild(0), null);\n                right = (AbstractExpression<X>) this.constructSubquery(cb, q, exprDef.getChild(1), left.getJavaType());\n            } else {\n                throw new PersistenceException(\"Both sides of the comparison cannot be sub query, line \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n            }\n        } else {\n            final Tree leftExpr = exprDef.getChild(0);\n            final Tree rightExpr = exprDef.getChild(1);\n            if (//\n            (leftExpr.getType() == JpqlParser.Named_Parameter) || //\n            (leftExpr.getType() == JpqlParser.Ordinal_Parameter) || (leftExpr.getType() == JpqlParser.Question_Sign)) {\n                left = (AbstractExpression<X>) this.getExpression(cb, q, rightExpr, null);\n                right = (AbstractExpression<X>) this.getExpression(cb, q, leftExpr, left.getJavaType());\n            } else {\n                left = this.getExpression(cb, q, leftExpr, null);\n                right = (AbstractExpression<X>) this.getExpression(cb, q, rightExpr, left.getJavaType());\n            }\n        }\n        switch(exprDef.getType()) {\n            case JpqlParser.Equals_Operator:\n                return (AbstractExpression<X>) cb.equal(left, right);\n            case JpqlParser.Not_Equals_Operator:\n                return (AbstractExpression<X>) cb.notEqual(left, right);\n            case JpqlParser.Greater_Than_Operator:\n                if (Comparable.class.isAssignableFrom(left.getJavaType())) {\n                    return (AbstractExpression<X>) cb.greaterThan((Expression<Comparable>) left, (Expression<Comparable>) right);\n                } else {\n                    return (AbstractExpression<X>) cb.gt((Expression<? extends Number>) left, (Expression<? extends Number>) right);\n                }\n            case JpqlParser.Greater_Or_Equals_Operator:\n                if (Comparable.class.isAssignableFrom(left.getJavaType())) {\n                    return (AbstractExpression<X>) cb.greaterThanOrEqualTo((Expression<Comparable>) left, (Expression<Comparable>) right);\n                } else {\n                    return (AbstractExpression<X>) cb.ge((Expression<? extends Number>) left, (Expression<? extends Number>) right);\n                }\n            case JpqlParser.Less_Than_Operator:\n                if (Comparable.class.isAssignableFrom(left.getJavaType())) {\n                    return (AbstractExpression<X>) cb.lessThan((Expression<Comparable>) left, (Expression<Comparable>) right);\n                } else {\n                    return (AbstractExpression<X>) cb.lt((Expression<? extends Number>) left, (Expression<? extends Number>) right);\n                }\n            case JpqlParser.Less_Or_Equals_Operator:\n                if (Comparable.class.isAssignableFrom(left.getJavaType())) {\n                    return (AbstractExpression<X>) cb.lessThanOrEqualTo((Expression<Comparable>) left, (Expression<Comparable>) right);\n                } else {\n                    return (AbstractExpression<X>) cb.le((Expression<? extends Number>) left, (Expression<? extends Number>) right);\n                }\n            case JpqlParser.BETWEEN:\n                final AbstractExpression<?> right2 = this.getExpression(cb, q, exprDef.getChild(2), left.getJavaType());\n                final PredicateImpl between = cb.between((AbstractExpression) left, (AbstractExpression) right, (AbstractExpression) right2);\n                if (exprDef.getChildCount() == 4) {\n                    return (AbstractExpression<X>) between.not();\n                }\n                return (AbstractExpression<X>) between;\n        }\n    }\n    if (exprDef.getType() == JpqlParser.LIKE) {\n        final AbstractExpression<String> inner = this.getExpression(cb, q, exprDef.getChild(0), String.class);\n        final AbstractExpression<String> pattern = this.getExpression(cb, q, exprDef.getChild(1), String.class);\n        if ((exprDef.getChildCount() > 2) && (exprDef.getChild(2).getType() == JpqlParser.STRING_LITERAL)) {\n            final Expression<Character> escape = this.getExpression(cb, q, exprDef.getChild(2), Character.class);\n            if (exprDef.getChild(exprDef.getChildCount() - 1).getType() == JpqlParser.NOT) {\n                return (AbstractExpression<X>) cb.notLike(inner, pattern, escape);\n            } else {\n                return (AbstractExpression<X>) cb.like(inner, pattern, escape);\n            }\n        } else {\n            if (exprDef.getChild(exprDef.getChildCount() - 1).getType() == JpqlParser.NOT) {\n                return (AbstractExpression<X>) cb.notLike(inner, pattern);\n            } else {\n                return (AbstractExpression<X>) cb.like(inner, pattern);\n            }\n        }\n    }\n    if (exprDef.getType() == JpqlParser.ST_IN) {\n        final boolean notIn = (exprDef.getChildCount() > 2) && (exprDef.getChild(2).getType() == JpqlParser.NOT);\n        AbstractExpression<X> left = null;\n        if (//\n        (exprDef.getChild(0).getType() != JpqlParser.Named_Parameter) && //\n        (exprDef.getChild(0).getType() != JpqlParser.Ordinal_Parameter) && (exprDef.getChild(0).getType() != JpqlParser.Question_Sign)) {\n            left = this.getExpression(cb, q, exprDef.getChild(0), null);\n        }\n        final List<AbstractExpression<X>> expressions = Lists.newArrayList();\n        final Tree inDefs = exprDef.getChild(1);\n        if (//\n        (inDefs.getType() == JpqlParser.Named_Parameter) || //\n        (inDefs.getType() == JpqlParser.Ordinal_Parameter) || (inDefs.getType() == JpqlParser.Question_Sign)) {\n            return //\n            notIn ? //\n            (AbstractExpression<X>) left.notIn(this.getExpression(cb, q, inDefs, left.getJavaType())) : (AbstractExpression<X>) left.in(this.getExpression(cb, q, inDefs, left.getJavaType()));\n        }\n        if (inDefs.getType() == JpqlParser.ID) {\n            this.getAliased(q, inDefs.getText());\n        }\n        if (inDefs.getType() == JpqlParser.ST_SUBQUERY) {\n            final SubqueryImpl<? extends X> subquery = this.constructSubquery(cb, q, inDefs, left.getJavaType());\n            return //\n            notIn ? //\n            (AbstractExpression<X>) left.notIn(subquery) : (AbstractExpression<X>) left.in(subquery);\n        } else {\n            for (int i = 0; i < inDefs.getChildCount(); i++) {\n                expressions.add((AbstractExpression<X>) this.getExpression(cb, q, inDefs.getChild(i), left != null ? left.getJavaType() : null));\n            }\n        }\n        if (left == null) {\n            left = (AbstractExpression<X>) this.getExpression(cb, q, exprDef.getChild(0), expressions.get(0).getJavaType());\n        }\n        return //\n        notIn ? //\n        (AbstractExpression<X>) left.notIn(expressions) : (AbstractExpression<X>) left.in(expressions);\n    }\n    if (exprDef.getType() == JpqlParser.ST_NULL) {\n        final AbstractExpression<Object> expr = this.getExpression(cb, q, exprDef.getChild(0), null);\n        if (exprDef.getChildCount() == 2) {\n            return (AbstractExpression<X>) cb.isNotNull(expr);\n        }\n        return (AbstractExpression<X>) cb.isNull(expr);\n    }\n    // identification variable\n    if (exprDef.getType() == JpqlParser.ID) {\n        return (AbstractExpression<X>) this.getAliased(q, exprDef.getText());\n    }\n    // single valued state field expression\n    if (exprDef.getType() == JpqlParser.ST_PARENTED) {\n        AbstractSelection<?> expression = this.getAliased(q, exprDef.getChild(0).getText());\n        final Qualified qualified = new Qualified(exprDef.getChild(1));\n        final Iterator<String> i = qualified.getSegments().iterator();\n        while (i.hasNext()) {\n            final String segment = i.next();\n            if (expression instanceof ParentPath) {\n                expression = ((ParentPath<?, ?>) expression).getExpression(segment);\n            } else {\n                throw new PersistenceException(\"Cannot dereference: \" + segment + \", line \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n            }\n        }\n        return (AbstractExpression<X>) expression;\n    }\n    // negation\n    if (exprDef.getType() == JpqlParser.ST_NEGATION) {\n        return (AbstractExpression<X>) cb.neg(this.<Number, Collection<Object>, Object>getExpression(cb, q, exprDef.getChild(0), null));\n    }\n    if (exprDef.getType() == JpqlParser.Named_Parameter) {\n        final String paramName = exprDef.getText().substring(1);\n        ParameterExpressionImpl<?> expr = this.namedParamMap.get(paramName);\n        if (expr != null) {\n            return (AbstractExpression<X>) expr;\n        }\n        expr = cb.parameter(javaType, paramName);\n        this.namedParamMap.put(paramName, expr);\n        return (AbstractExpression<X>) expr;\n    }\n    if (//\n    (exprDef.getType() == JpqlParser.Ordinal_Parameter) || (exprDef.getType() == JpqlParser.Question_Sign)) {\n        final String strPos = exprDef.getText().substring(1);\n        try {\n            final int position = Integer.parseInt(strPos);\n            AbstractParameterExpressionImpl<X> parameter = null;\n            Object q2 = q;\n            while (q2 instanceof SubqueryImpl) {\n                q2 = ((SubqueryImpl<?>) q2).getParent();\n            }\n            if (q2 instanceof CriteriaQueryImpl) {\n                parameter = (AbstractParameterExpressionImpl<X>) ((CriteriaQueryImpl<?>) q2).getParameter(position);\n            } else if (q2 instanceof CriteriaDeleteImpl) {\n                parameter = (AbstractParameterExpressionImpl<X>) ((CriteriaDeleteImpl<?>) q2).getParameter(position);\n            } else {\n                parameter = (AbstractParameterExpressionImpl<X>) ((CriteriaUpdateImpl<?>) q2).getParameter(position);\n            }\n            if (parameter == null) {\n                parameter = new ParameterExpressionImpl<X>((BaseQueryImpl<?>) q2, this.metamodel.type(javaType), javaType, position);\n            }\n            return parameter;\n        } catch (final NumberFormatException e) {\n            throw new PersistenceException(\"Invalid ordinal query parameter declaration: \" + strPos);\n        }\n    }\n    // arithmetic operation\n    if (//\n    (exprDef.getType() == JpqlParser.Plus_Sign) || //\n    (exprDef.getType() == JpqlParser.Minus_Sign) || //\n    (exprDef.getType() == JpqlParser.Multiplication_Sign) || (exprDef.getType() == JpqlParser.Division_Sign)) {\n        final AbstractExpression<Number> left = this.getExpression(cb, q, exprDef.getChild(0), Number.class);\n        final AbstractExpression<? extends Number> right = this.getExpression(cb, q, exprDef.getChild(1), left.getJavaType());\n        switch(exprDef.getType()) {\n            case JpqlParser.Plus_Sign:\n                return (AbstractExpression<X>) cb.sum(left, right);\n            case JpqlParser.Minus_Sign:\n                return (AbstractExpression<X>) cb.diff(left, right);\n            case JpqlParser.Multiplication_Sign:\n                return (AbstractExpression<X>) cb.prod(left, right);\n            case JpqlParser.Division_Sign:\n                return (AbstractExpression<X>) cb.quot(left, right);\n        }\n    }\n    if (exprDef.getType() == JpqlParser.ST_BOOLEAN) {\n        return (AbstractExpression<X>) this.getExpression(cb, q, exprDef, Boolean.class);\n    }\n    if (exprDef.getType() == JpqlParser.NUMERIC_LITERAL) {\n        return (AbstractExpression<X>) new SimpleConstantExpression<Long>(this.metamodel.createBasicType(Long.class), Long.valueOf(exprDef.getText()));\n    }\n    // string literal\n    if (exprDef.getType() == JpqlParser.STRING_LITERAL) {\n        if (javaType == Character.class) {\n            return (AbstractExpression<X>) new //\n            SimpleConstantExpression<Character>(//\n            this.metamodel.type(Character.class), exprDef.getText().substring(1, 2).toCharArray()[0]);\n        }\n        return (AbstractExpression<X>) new //\n        SimpleConstantExpression<String>(//\n        this.metamodel.type(String.class), exprDef.getText().substring(1, exprDef.getText().length() - 1));\n    }\n    // functions returning string\n    if (//\n    (exprDef.getType() == JpqlParser.UPPER) || //\n    (exprDef.getType() == JpqlParser.LOWER) || (exprDef.getType() == JpqlParser.SUBSTRING)) {\n        final AbstractExpression<String> argument = this.getExpression(cb, q, exprDef.getChild(0), null);\n        switch(exprDef.getType()) {\n            case JpqlParser.UPPER:\n                return (AbstractExpression<X>) cb.upper(argument);\n            case JpqlParser.LOWER:\n                return (AbstractExpression<X>) cb.lower(argument);\n            case JpqlParser.SUBSTRING:\n                final AbstractExpression<Integer> start = this.getExpression(cb, q, exprDef.getChild(1), Integer.class);\n                final AbstractExpression<Integer> end = //\n                exprDef.getChildCount() == 3 ? this.getExpression(cb, q, exprDef.getChild(2), Integer.class) : null;\n                return (AbstractExpression<X>) new SubstringExpression(argument, start, end);\n        }\n    }\n    // concat function\n    if (exprDef.getType() == JpqlParser.CONCAT) {\n        final List<Expression<String>> arguments = Lists.newArrayList();\n        for (int i = 0; i < exprDef.getChildCount(); i++) {\n            arguments.add(this.getExpression(cb, q, exprDef.getChild(i), String.class));\n        }\n        return (AbstractExpression<X>) new ConcatExpression(arguments.toArray(new Expression[arguments.size()]));\n    }\n    // trim function\n    if (exprDef.getType() == JpqlParser.TRIM) {\n        Trimspec trimspec = null;\n        Expression<Character> trimChar = null;\n        Expression<String> inner = null;\n        int i = 0;\n        final int type = exprDef.getChild(i).getType();\n        // trim spec\n        if (type == JpqlParser.BOTH) {\n            trimspec = Trimspec.BOTH;\n            i++;\n        } else if (type == JpqlParser.LEADING) {\n            trimspec = Trimspec.LEADING;\n            i++;\n        } else if (type == JpqlParser.TRAILING) {\n            trimspec = Trimspec.TRAILING;\n            i++;\n        }\n        if (exprDef.getChildCount() > (i + 1)) {\n            trimChar = this.getExpression(cb, q, exprDef.getChild(i), Character.class);\n            inner = this.getExpression(cb, q, exprDef.getChild(i + 1), String.class);\n        } else {\n            inner = this.getExpression(cb, q, exprDef.getChild(i), String.class);\n        }\n        return (AbstractExpression<X>) new TrimExpression(trimspec, trimChar, inner);\n    }\n    // type functions\n    if ((exprDef.getType() == JpqlParser.TYPE) || (exprDef.getType() == JpqlParser.ST_ENTITY_TYPE)) {\n        switch(exprDef.getType()) {\n            case JpqlParser.TYPE:\n                final AbstractExpression<?> inner = this.getExpression(cb, q, exprDef.getChild(0), null);\n                return (AbstractExpression<X>) ((AbstractPath<?>) inner).type();\n            case JpqlParser.ST_ENTITY_TYPE:\n                final EntityTypeImpl<?> entity = this.getEntity(exprDef.getChild(0).getText());\n                if (entity.getRootType().getInheritanceType() == null) {\n                    throw new PersistenceException(\"Entity does not have inheritence: \" + entity.getName() + \", line \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n                }\n                return (AbstractExpression<X>) new SimpleConstantExpression<String>(null, entity.getDiscriminatorValue());\n        }\n    }\n    // date time functions\n    switch(exprDef.getType()) {\n        case JpqlParser.CURRENT_DATE:\n            return (AbstractExpression<X>) cb.currentDate();\n        case JpqlParser.CURRENT_TIME:\n            return (AbstractExpression<X>) cb.currentTime();\n        case JpqlParser.CURRENT_TIMESTAMP:\n            return (AbstractExpression<X>) cb.currentTimestamp();\n        case JpqlParser.SECOND:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.SECOND, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.MINUTE:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.MINUTE, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.HOUR:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.HOUR, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.DAY:\n        case JpqlParser.DAYOFMONTH:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.DAYOFMONTH, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.DAYOFWEEK:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.DAYOFWEEK, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.DAYOFYEAR:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.DAYOFYEAR, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.MONTH:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.MONTH, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.WEEK:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.WEEK, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n        case JpqlParser.YEAR:\n            return (AbstractExpression<X>) cb.dateTimeExpression(DateTimeFunctionType.YEAR, this.getExpression(cb, q, exprDef.getChild(0), Date.class));\n    }\n    // arithmetic functions\n    switch(exprDef.getType()) {\n        case JpqlParser.ABS:\n            return (AbstractExpression<X>) cb.abs(this.getExpression(cb, q, exprDef.getChild(0), Number.class));\n        case JpqlParser.SQRT:\n            return (AbstractExpression<X>) cb.sqrt(this.getExpression(cb, q, exprDef.getChild(0), Number.class));\n        case JpqlParser.MOD:\n            return (AbstractExpression<X>) //\n            cb.//\n            mod(//\n            this.getExpression(cb, q, exprDef.getChild(0), Integer.class), this.getExpression(cb, q, exprDef.getChild(1), Integer.class));\n        case JpqlParser.LOCATE:\n            if (exprDef.getChildCount() == 3) {\n                return (AbstractExpression<X>) //\n                cb.//\n                locate(//\n                this.getExpression(cb, q, exprDef.getChild(0), String.class), //\n                this.getExpression(cb, q, exprDef.getChild(1), String.class), this.getExpression(cb, q, exprDef, Integer.class));\n            }\n            return (AbstractExpression<X>) //\n            cb.//\n            locate(//\n            this.getExpression(cb, q, exprDef.getChild(0), String.class), this.getExpression(cb, q, exprDef.getChild(1), String.class));\n        case JpqlParser.LENGTH:\n            return (AbstractExpression<X>) cb.length(this.getExpression(cb, q, exprDef.getChild(0), String.class));\n    }\n    // aggregate functions\n    switch(exprDef.getType()) {\n        case JpqlParser.AVG:\n            return (AbstractExpression<X>) cb.avg(this.getExpression(cb, q, exprDef.getChild(0), Number.class));\n        case JpqlParser.SUM:\n            return (AbstractExpression<X>) cb.sum(this.getExpression(cb, q, exprDef.getChild(0), Long.class));\n        case JpqlParser.MAX:\n            return (AbstractExpression<X>) cb.max(this.getExpression(cb, q, exprDef.getChild(0), Number.class));\n        case JpqlParser.MIN:\n            return (AbstractExpression<X>) cb.min(this.getExpression(cb, q, exprDef.getChild(0), Number.class));\n    }\n    // count function\n    if (exprDef.getType() == JpqlParser.COUNT) {\n        if (exprDef.getChildCount() == 2) {\n            return (AbstractExpression<X>) new CountExpression(this.getExpression(cb, q, exprDef.getChild(1), null), true);\n        }\n        return (AbstractExpression<X>) new CountExpression(this.getExpression(cb, q, exprDef.getChild(0), null), false);\n    }\n    // all or any operator\n    if (exprDef.getType() == JpqlParser.ST_ALL_OR_ANY) {\n        // all, any, some expressions\n        switch(exprDef.getChild(0).getType()) {\n            case JpqlParser.ALL:\n                return new AllAnyExpression<X>(true, this.constructSubquery(cb, q, exprDef.getChild(1), javaType));\n            case JpqlParser.ANY:\n            case JpqlParser.SOME:\n                return new AllAnyExpression<X>(false, this.constructSubquery(cb, q, exprDef.getChild(1), javaType));\n        }\n    }\n    // exists operator\n    if (exprDef.getType() == JpqlParser.EXISTS) {\n        return (AbstractExpression<X>) new ExistsExpression(this.constructSubquery(cb, q, exprDef.getChild(0), javaType));\n    }\n    // not operator\n    if (exprDef.getType() == JpqlParser.NOT) {\n        final Tree innerExpression = exprDef.getChild(0);\n        final AbstractExpression<Boolean> expression = innerExpression.getType() == JpqlParser.LOR ? this.constructJunction(cb, q, innerExpression) : this.getExpression(cb, q, innerExpression, Boolean.class);\n        return (AbstractExpression<X>) new PredicateImpl(true, BooleanOperator.AND, expression);\n    }\n    // general case\n    if (exprDef.getType() == JpqlParser.ST_GENERAL_CASE) {\n        final CaseImpl<Object> caseExpr = cb.selectCase();\n        for (int i = 0; i < exprDef.getChildCount(); i++) {\n            final Tree caseDef = exprDef.getChild(i);\n            if (caseDef.getType() == JpqlParser.WHEN) {\n                caseExpr.when(this.constructJunction(cb, q, caseDef.getChild(0)), this.getExpression(cb, q, caseDef.getChild(1), null));\n            } else {\n                caseExpr.otherwise(this.getExpression(cb, q, caseDef, null));\n            }\n        }\n        return (AbstractExpression<X>) caseExpr;\n    }\n    // simple case\n    if (exprDef.getType() == JpqlParser.CASE) {\n        final AbstractExpression<X> expression = this.getExpression(cb, q, exprDef.getChild(0), null);\n        final SimpleCaseImpl<X, Object> caseExpr = cb.selectCase(expression);\n        for (int i = 1; i < exprDef.getChildCount(); i++) {\n            final Tree caseDef = exprDef.getChild(i);\n            if (caseDef.getType() == JpqlParser.WHEN) {\n                final AbstractExpression<Object> result = this.getExpression(cb, q, caseDef.getChild(1), null);\n                final AbstractExpression<X> condition;\n                if (exprDef.getChild(0).getType() == JpqlParser.TYPE) {\n                    final EntityTypeImpl<Object> entity = this.getEntity(caseDef.getChild(0).getText());\n                    if (entity.getRootType().getInheritanceType() == null) {\n                        throw new PersistenceException(\"Entity does not have inheritence: \" + entity.getName() + \", line \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n                    }\n                    condition = (AbstractExpression<X>) new SimpleConstantExpression<String>(null, entity.getDiscriminatorValue());\n                } else {\n                    condition = this.getExpression(cb, q, caseDef.getChild(0), null);\n                }\n                caseExpr.when(condition, result);\n            } else {\n                caseExpr.otherwise(this.getExpression(cb, q, caseDef, null));\n            }\n        }\n        return (AbstractExpression<X>) caseExpr;\n    }\n    // nullif function\n    if (exprDef.getType() == JpqlParser.NULLIF) {\n        final AbstractExpression<X> left = this.getExpression(cb, q, exprDef.getChild(0), null);\n        final AbstractExpression<?> right = this.getExpression(cb, q, exprDef.getChild(1), null);\n        return new NullIfExpression<X>(left, right);\n    }\n    // coalesce function\n    if (exprDef.getType() == JpqlParser.ST_COALESCE) {\n        final CoalesceExpression<X> coalesce = cb.coalesce();\n        for (int i = 0; i < exprDef.getChildCount(); i++) {\n            coalesce.value(this.getExpression(cb, q, exprDef.getChild(i), javaType));\n        }\n        return coalesce;\n    }\n    // db func\n    if (exprDef.getType() == JpqlParser.FUNC) {\n        final List<AbstractExpression<?>> arguments = Lists.newArrayList();\n        final String function = exprDef.getChild(0).getText();\n        for (int i = 1; i < exprDef.getChildCount(); i++) {\n            arguments.add(this.getExpression(cb, q, exprDef.getChild(i), null));\n        }\n        return new //\n        FunctionExpression<X>(//\n        (Class<X>) (javaType != null ? javaType : Object.class), function, arguments.toArray(new Expression<?>[arguments.size()]));\n    }\n    // index expression\n    if (exprDef.getType() == JpqlParser.INDEX) {\n        final AbstractExpression<Object> expression = this.getExpression(cb, q, exprDef.getChild(0), null);\n        if (expression instanceof ListJoinImpl) {\n            return (AbstractExpression<X>) ((ListJoinImpl<?, ?>) expression).index();\n        }\n        throw new PersistenceException(\"Reference is not a list join, line \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n    }\n    // empty operation\n    if (exprDef.getType() == JpqlParser.ST_EMPTY) {\n        AbstractExpression<?> expression = this.getExpression(cb, q, exprDef.getChild(0), null);\n        if (expression instanceof MapExpression) {\n            expression = ((MapExpression<Map<?, ?>, ?, ?>) expression).values();\n        }\n        if (!(expression instanceof CollectionExpression<?, ?>)) {\n            throw new PersistenceException(\"Reference is not a collection, line \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n        }\n        if (exprDef.getChildCount() == 2) {\n            return (AbstractExpression<X>) cb.isNotEmpty((Expression<Collection<?>>) expression);\n        } else {\n            return (AbstractExpression<X>) cb.isEmpty((Expression<Collection<?>>) expression);\n        }\n    }\n    // member of operation\n    if (exprDef.getType() == JpqlParser.ST_MEMBER) {\n        final AbstractExpression<?> expression = this.getExpression(cb, q, exprDef.getChild(1), null);\n        if (!(expression instanceof CollectionExpression)) {\n            throw new PersistenceException(\"Member of expression must evaluate to a collection expression, \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n        }\n        final CollectionExpression<C, E> collection = (CollectionExpression<C, E>) expression;\n        final PluralAttributeImpl<?, C, E> attribute = (PluralAttributeImpl<?, C, E>) collection.getMapping().getAttribute();\n        final AbstractExpression<E> elem = this.getExpression(cb, q, exprDef.getChild(0), attribute.getElementType().getJavaType());\n        if (exprDef.getChildCount() == 3) {\n            return (AbstractExpression<X>) cb.isNotMember(elem, collection);\n        } else {\n            return (AbstractExpression<X>) cb.isMember(elem, collection);\n        }\n    }\n    // size operation\n    if (exprDef.getType() == JpqlParser.SIZE) {\n        final AbstractExpression<?> expression = this.getExpression(cb, q, exprDef.getChild(0), null);\n        if (!(expression instanceof CollectionExpression)) {\n            throw new PersistenceException(\"Member of expression must evaluate to a collection expression, \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n        }\n        final CollectionExpression<C, E> collection = (CollectionExpression<C, E>) expression;\n        return (AbstractExpression<X>) cb.size(collection);\n    }\n    if (exprDef.getType() == JpqlParser.CAST) {\n        final AbstractExpression<?> left = this.getExpression(cb, q, exprDef.getChild(0), null);\n        Class<?> clazz = null;\n        switch(exprDef.getChild(1).getType()) {\n            case JpqlParser.BYTE:\n                clazz = Byte.class;\n                break;\n            case JpqlParser.SHORT:\n                clazz = Short.class;\n                break;\n            case JpqlParser.INT:\n            case JpqlParser.INTEGER:\n                clazz = Integer.class;\n                break;\n            case JpqlParser.LONG:\n                clazz = Long.class;\n                break;\n            case JpqlParser.FLOAT:\n                clazz = Float.class;\n                break;\n            case JpqlParser.DOUBLE:\n                clazz = Double.class;\n                break;\n            default:\n                clazz = String.class;\n        }\n        return (AbstractExpression<X>) cb.cast(left, clazz);\n    }\n    if (exprDef.getType() == JpqlParser.TRUE) {\n        return (AbstractExpression<X>) new SimpleConstantExpression<Boolean>(null, Boolean.TRUE);\n    }\n    if (exprDef.getType() == JpqlParser.FALSE) {\n        return (AbstractExpression<X>) new SimpleConstantExpression<Boolean>(null, Boolean.FALSE);\n    }\n    throw new PersistenceException(\"Unhandled expression: \" + exprDef.toStringTree() + \", line \" + exprDef.getLine() + \":\" + exprDef.getCharPositionInLine());\n}", "repo_id": "1", "comment": "/**\n * Constructs and returns the expression.\n *\n * @param cb\n *            the criteria builder\n * @param exprDef\n *            the definition of the expression\n * @return the expression\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 770, "method_signature": "AbstractExpression<X> getExpression(CriteriaBuilderImpl, Object, Tree, Class)"}, "JpqlQuery.parse": {"callee_method_names": ["CommonTree.toStringTree"], "method_name": "JpqlQuery.parse", "method_implementation": "{\n    final CommonTree tree = this.parse(this.qlString);\n    //\n    JpqlQuery.LOG.//\n    debug(//\n    \"Parsed query successfully {0}\", JpqlQuery.LOG.lazyBoxed(this.qlString, new Object[] { tree.toStringTree() }));\n    return this.construct(cb, tree);\n}", "repo_id": "1", "comment": "/**\n * Parses the JPQL.\n *\n * @param cb\n *            the criteria builder\n * @return the criteria constructed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 771, "method_signature": "BaseQueryImpl<?> parse(CriteriaBuilderImpl)"}, "JtaEntityManagerFactoryImpl.createEntityManager": {"callee_method_names": [], "method_name": "JtaEntityManagerFactoryImpl.createEntityManager", "method_implementation": "{\n    this.assertOpen();\n    return new JtaEntityManagerImpl(this, this.getMetamodel(), this.getDatasource(), Collections.<String, Object>emptyMap(), this.getJdbcAdaptor());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 427, "method_signature": "EntityManager createEntityManager(Map)"}, "JtaEntityManagerImpl.assertTransaction": {"callee_method_names": [], "method_name": "JtaEntityManagerImpl.assertTransaction", "method_implementation": "{\n    this.assertOpen();\n    this.joinTransaction();\n    if (this.jtaTransaction == null) {\n        throw new TransactionRequiredException(\"No active transaction\");\n    }\n    return;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 468, "method_signature": "void assertTransaction()"}, "JtaEntityManagerImpl.closeConnection": {"callee_method_names": [], "method_name": "JtaEntityManagerImpl.closeConnection", "method_implementation": "{\n    super.closeConnection();\n    this.jtaTransaction = null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 469, "method_signature": "void closeConnection()"}, "JtaEntityManagerImpl.closeConnectionIfNecessary": {"callee_method_names": [], "method_name": "JtaEntityManagerImpl.closeConnectionIfNecessary", "method_implementation": "{\n    if (this.jtaTransaction == null) {\n        this.closeConnection();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 470, "method_signature": "void closeConnectionIfNecessary()"}, "JtaEntityManagerImpl.joinTransaction": {"callee_method_names": [], "method_name": "JtaEntityManagerImpl.joinTransaction", "method_implementation": "{\n    if ((this.jtaTransaction != null) || !this.isOpen()) {\n        return;\n    }\n    try {\n        this.jtaTransaction = this.emf.getTransactionManager().getTransaction();\n        if (this.jtaTransaction != null) {\n            this.jtaTransaction.registerSynchronization(new Synchronization() {\n\n                @Override\n                public void afterCompletion(int status) {\n                    JtaEntityManagerImpl.this.closeConnection();\n                }\n\n                @Override\n                public void beforeCompletion() {\n                    JtaEntityManagerImpl.this.flush();\n                }\n            });\n        }\n    } catch (final Exception e) {\n        throw new PersistenceException(\"Unable to join JTA\");\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 471, "method_signature": "void joinTransaction()"}, "JtaEntityManagerImpl.setRollbackOnly": {"callee_method_names": [], "method_name": "JtaEntityManagerImpl.setRollbackOnly", "method_implementation": "{\n    super.setRollbackOnly();\n    if (this.jtaTransaction != null) {\n        try {\n            this.jtaTransaction.setRollbackOnly();\n        } catch (final IllegalStateException e) {\n        } catch (final SystemException e) {\n            JtaEntityManagerImpl.LOG.error(\"Cannot mark the JTA Transaction as rollback only!\", e);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 472, "method_signature": "void setRollbackOnly()"}, "LazyTest.prepareCountries": {"callee_method_names": [], "method_name": "LazyTest.prepareCountries", "method_implementation": "{\n    this.persist(LazyTest.TR);\n    this.persist(LazyTest.USA);\n    this.persist(LazyTest.UK);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2310, "method_signature": "void prepareCountries()"}, "LazyTest.testFind": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses", "Person.getAddresses"], "method_name": "LazyTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n    for (final Address address : person2.getAddresses()) {\n        if (LazyTest.CITY_ISTANBUL.equals(address.getCity())) {\n            Assert.assertEquals(LazyTest.TR.getId(), address.getCountry().getId());\n            Assert.assertEquals(LazyTest.COUNTRY_TURKEY, address.getCountry().getName());\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2311, "method_signature": "void testFind()"}, "LazyTest.testFindAddress": {"callee_method_names": ["Person.getAddresses", "Address.getPerson"], "method_name": "LazyTest.testFindAddress", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Address address = this.find(Address.class, person.getAddresses().get(0).getId());\n    Assert.assertEquals(\"Ceylan\", address.getPerson().getName());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} load address then person as lazy.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2312, "method_signature": "void testFindAddress()"}, "LazyTest.testFindInSession": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses", "Person.getAddresses", "Address.getCity", "Address.getCountry", "Address.getCountry"], "method_name": "LazyTest.testFindInSession", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n    for (final Address address : person2.getAddresses()) {\n        if (LazyTest.CITY_ISTANBUL.equals(address.getCity())) {\n            Assert.assertEquals(address.getCountry().getId(), LazyTest.TR.getId());\n            Assert.assertEquals(address.getCountry().getName(), LazyTest.COUNTRY_TURKEY);\n            break;\n        }\n    }\n    this.close();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2313, "method_signature": "void testFindInSession()"}, "LazyTest.testFindMany": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getWorkPhones"], "method_name": "LazyTest.testFindMany", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(2, person2.getWorkPhones().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person with phones as lazy many type association.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2314, "method_signature": "void testFindMany()"}, "LazyTest.testFindOneToMany": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getWorkPhones", "Person.getWorkPhones", "Person.getWorkPhones"], "method_name": "LazyTest.testFindOneToMany", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getWorkPhones().size(), person2.getWorkPhones().size());\n    for (final Phone phone : person2.getWorkPhones()) {\n        if (\"333 3333333\".equals(phone.getPhoneNo())) {\n            return;\n        }\n    }\n    Assert.fail(\"Phone 333 3333333 not found\");\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person with lazy OneToMany association.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2315, "method_signature": "void testFindOneToMany()"}, "LazyTest.testLazyCollection": {"callee_method_ids": [2454, 2455, 2455, 2454], "callee_method_names": ["Person.getId", "Person.getPhones", "Person.getPhones", "Person.getId", "Person.getWorkPhones"], "method_name": "LazyTest.testLazyCollection", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    Person person2 = this.find(Person.class, person.getId());\n    this.em().close();\n    Assert.assertEquals(person.getPhones().size(), person2.getPhones().size());\n    this.close();\n    person2 = this.find(Person.class, person.getId());\n    person2 = this.serializePerson(person2);\n    person2.getWorkPhones().size();\n}", "repo_id": "1", "comment": "/**\n * Tests no lazy exception when lazy collection is initialized\n *\n * @throws Exception\n *             in case of an error\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2316, "method_signature": "void testLazyCollection()"}, "LazyTest.testPersistAddress": {"callee_method_names": [], "method_name": "LazyTest.testPersistAddress", "method_implementation": "{\n    this.persist(this.person().getAddresses().get(0));\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} address which does not cascade to Parent. PersistenceException expected.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2317, "method_signature": "void testPersistAddress()"}, "LazyTest.testPersistPerson": {"callee_method_names": [], "method_name": "LazyTest.testPersistPerson", "method_implementation": "{\n    Assert.assertEquals(5, this.em().getMetamodel().getEntities().size());\n    this.persist(this.person());\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} Parent which cascades to Child1.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2318, "method_signature": "void testPersistPerson()"}, "LazyTest.testSerializePerson": {"callee_method_ids": [2454, 2454, 2454], "callee_method_names": ["Person.getId", "Person.getId", "Person.getId", "Person.getAddresses", "Person.getAddresses"], "method_name": "LazyTest.testSerializePerson", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final Person person2 = this.serializePerson(person);\n    Assert.assertEquals(person.getId(), person2.getId());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n    Assert.assertTrue(this.emf().getPersistenceUnitUtil().isLoaded(person2, \"addresses\"));\n    Assert.assertFalse(this.emf().getPersistenceUnitUtil().isLoaded(person2, \"phones\"));\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} Parent which cascades to Child1.\n *\n * @throws Exception\n *             in case of an error\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2319, "method_signature": "void testSerializePerson()"}, "LikeExpression.generateJpqlRestriction": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "LikeExpression.generateJpqlRestriction", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.inner.generateJpqlRestriction(query));\n    if (this.not) {\n        builder.append(\" not\");\n    }\n    builder.append(\" like \");\n    builder.append(this.pattern.generateJpqlRestriction(query));\n    if (this.escape != null) {\n        builder.append(\" escape \");\n        builder.append(this.escape.generateJpqlRestriction(query));\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 595, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "LikeExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "LikeExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 596, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "LikeExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "LikeExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 597, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "LikeExpression.getSqlRestrictionFragments": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "BaseQueryImpl<?>.getJdbcAdaptor", "StringBuilder.toString"], "method_name": "LikeExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    builder.append(this.inner.getSqlRestrictionFragments(query)[0]);\n    if (this.not) {\n        builder.append(\" NOT\");\n    }\n    builder.append(\" LIKE \");\n    builder.append(this.pattern.getSqlRestrictionFragments(query)[0]);\n    if (this.escape != null) {\n        builder.append(query.getJdbcAdaptor().applyLikeEscape(this.escape.getSqlRestrictionFragments(query)[0]));\n    }\n    return new String[] { builder.toString() };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 598, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "LinkManager.perform": {"callee_method_names": ["EntityTypeImpl<?>.getAssociations", "EntityTypeImpl<?>.getMappingsPlural", "EntityTypeImpl<?>.prepareDependenciesFor"], "method_name": "LinkManager.perform", "method_implementation": "{\n    switch(this.phase) {\n        case LINK_ASSOCIATIONS:\n            for (final AssociationMappingImpl<?, ?, ?> mapping : entity.getAssociations()) {\n                if (mapping.getRoot().getType() == entity) {\n                    mapping.link();\n                }\n            }\n            break;\n        case LINK_ELEMENT_COLLECTIONS:\n            for (final PluralMappingEx<?, ?, ?> mapping : entity.getMappingsPlural()) {\n                if (mapping.getRoot().getType() == entity) {\n                    if (mapping instanceof ElementCollectionMappingImpl) {\n                        ((ElementCollectionMappingImpl<?, ?, ?>) mapping).link();\n                    }\n                }\n            }\n            break;\n        case LINK_DEPENDENCIES:\n            for (final EntityType<?> type : this.getMetamodel().getEntities()) {\n                entity.prepareDependenciesFor((EntityTypeImpl<?>) type);\n            }\n            break;\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 183, "method_signature": "Void perform(EntityTypeImpl)"}, "ListAttributeImpl.newCollection": {"callee_method_names": [], "method_name": "ListAttributeImpl.newCollection", "method_implementation": "{\n    return new ManagedList<X, E>(mapping, managedInstance, (Collection<? extends E>) values);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 289, "method_signature": "List<E> newCollection(PluralMappingEx, ManagedInstance, Object)"}, "ListComparator.compare": {"callee_method_names": ["ComparableMapping.getMapping", "ComparableMapping.getMapping", "ComparableMapping.isAscending"], "method_name": "ListComparator.compare", "method_implementation": "{\n    int result = 0;\n    try {\n        for (int i = 0; i < this.comparables.size(); i++) {\n            final ComparableMapping mapping = this.comparables.get(i);\n            final Object v1 = mapping.getMapping().get(o1);\n            final Object v2 = mapping.getMapping().get(o2);\n            result = ObjectUtils.compare((Comparable<?>) v1, (Comparable<?>) v2);\n            if (result == 0) {\n                continue;\n            }\n            if (!mapping.isAscending()) {\n                result = -result;\n            }\n            break;\n        }\n        return result;\n    } finally {\n        if (ListComparator.LOG.isDebugEnabled()) {\n            ListComparator.LOG.debug(\"{0} {1} {2}\", result < 0 ? o1 : o2, result == 0 ? \"=\" : \"<\", result < 0 ? o2 : o1);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 339, "method_signature": "int compare(E, E)"}, "ListComparator.createComparables": {"callee_method_names": ["EntityTypeImpl<E>.hasSingleIdAttribute", "EntityTypeImpl<E>.getIdMapping", "EntityTypeImpl<E>.getIdMappings", "Iterator<String>.hasNext", "Iterator<String>.next", "Iterator<String>.hasNext", "Iterator<String>.next", "Iterator<String>.next"], "method_name": "ListComparator.createComparables", "method_implementation": "{\n    // order on id\n    if (this.mapping.getOrderBy().trim().length() == 0) {\n        if (this.mapping.isAssociation()) {\n            final EntityTypeImpl<E> type = ((PluralAssociationMappingImpl<?, ?, E>) this.mapping).getType();\n            if (type.hasSingleIdAttribute()) {\n                this.createComparable(type.getIdMapping());\n            } else {\n                for (final Pair<SingularMapping<?, ?>, AbstractAccessor> pair : type.getIdMappings()) {\n                    this.createComparable(pair.getFirst());\n                }\n            }\n        } else if (this.mapping.getType().getPersistenceType() == PersistenceType.EMBEDDABLE) {\n            throw new MappingException(\"Embeddable element collections requires OrderBy value\", this.mapping.getAttribute().getLocator());\n        } else {\n            this.comparables.add(new ComparableMapping(true, null));\n        }\n    } else {\n        final Iterator<String> i = Splitter.on(\",\").trimResults().split(this.mapping.getOrderBy()).iterator();\n        while (i.hasNext()) {\n            final Iterator<String> j = Splitter.on(\" \").trimResults().split(i.next()).iterator();\n            int index = 0;\n            String path = null;\n            boolean order = true;\n            while (j.hasNext()) {\n                if (index == 0) {\n                    path = j.next();\n                } else if (index == 1) {\n                    order = \"ASC\".equals(j.next().toUpperCase());\n                } else {\n                    throw new MappingException(\"Invalid order by statement: \" + this.mapping.getOrderBy() + \".\", this.mapping.getAttribute().getLocator());\n                }\n                index++;\n            }\n            if (this.mapping.getType().getPersistenceType() == PersistenceType.BASIC) {\n                throw new MappingException(\"Basic element collection must not have OrderBy value\", this.mapping.getAttribute().getLocator());\n            }\n            final AbstractMapping<?, ?, ?> mapping = this.mapping.getMapping(path);\n            if (mapping == null) {\n                throw new MappingException(\"Sort property cannot be found: \" + path, this.mapping.getAttribute().getLocator());\n            }\n            this.comparables.add(new ComparableMapping(order, mapping));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates the list of comparables\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 340, "method_signature": "void createComparables()"}, "ListJoinImpl.getModel": {"callee_method_names": [], "method_name": "ListJoinImpl.getModel", "method_implementation": "{\n    return (ListAttribute<? super Z, E>) this.getAttribute();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 828, "method_signature": "ListAttribute<? super Z,E> getModel()"}, "ListJoinImpl.index": {"callee_method_names": [], "method_name": "ListJoinImpl.index", "method_implementation": "{\n    final OrderColumn orderColumn = this.mapping.getOrderColumn();\n    if (orderColumn == null) {\n        throw new IllegalArgumentException(\"List join does not have an order column\");\n    }\n    return new IndexExpression(this, orderColumn);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 829, "method_signature": "Expression<Integer> index()"}, "ListenerTest.testListener": {"callee_method_names": ["Foo1.getValue", "Foo1.getParentValue", "Foo1.getId", "Foo1.getValue", "Foo1.getParentValue", "Foo1.getValue", "Foo1.getParentValue"], "method_name": "ListenerTest.testListener", "method_implementation": "{\n    Foo1 foo = new Foo1();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    Assert.assertEquals(\"prePersistpostPersist\", foo.getValue());\n    Assert.assertEquals(\"masterPrePersistmasterPostPersist\", foo.getParentValue());\n    foo = this.find(Foo1.class, foo.getId());\n    Assert.assertEquals(\"\", foo.getValue());\n    Assert.assertEquals(\"masterPostLoad\", foo.getParentValue());\n    this.remove(foo);\n    this.commit();\n    Assert.assertEquals(\"\", foo.getValue());\n    Assert.assertEquals(\"masterPostLoadmasterPreRemovemasterPostRemove\", foo.getParentValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2424, "method_signature": "void testListener()"}, "ListenerTest.testListener2": {"callee_method_names": ["Foo2.getValue", "Foo2.getParentValue", "Foo2.getId", "Foo2.getValue", "Foo2.getParentValue", "Foo2.getValue", "Foo2.getParentValue"], "method_name": "ListenerTest.testListener2", "method_implementation": "{\n    Foo2 foo = new Foo2();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    Assert.assertEquals(\"postPersist\", foo.getValue());\n    Assert.assertEquals(\"\", foo.getParentValue());\n    foo = this.find(Foo2.class, foo.getId());\n    Assert.assertEquals(\"postLoad\", foo.getValue());\n    Assert.assertEquals(\"\", foo.getParentValue());\n    this.remove(foo);\n    this.commit();\n    Assert.assertEquals(\"postLoad\", foo.getValue());\n    Assert.assertEquals(\"\", foo.getParentValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2425, "method_signature": "void testListener2()"}, "ListenerTest.testListener3": {"callee_method_names": ["Foo3.getValue", "Foo3.getParentValue", "Foo3.getId", "Foo3.getValue", "Foo3.getParentValue", "Foo3.setFooValue", "Foo3.getValue", "Foo3.getParentValue", "Foo3.getValue", "Foo3.getParentValue"], "method_name": "ListenerTest.testListener3", "method_implementation": "{\n    Foo3 foo = new Foo3();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    Assert.assertEquals(\"listener1PrePersistlistener1PostPersistpostPersist\", foo.getValue());\n    Assert.assertEquals(\"masterPrePersistmasterPostPersist\", foo.getParentValue());\n    foo = this.find(Foo3.class, foo.getId());\n    Assert.assertEquals(\"listener1PostLoad\", foo.getValue());\n    Assert.assertEquals(\"masterPostLoad\", foo.getParentValue());\n    this.begin();\n    foo.setFooValue(\"FooValue\");\n    this.commit();\n    Assert.assertEquals(\"listener1PostLoadlistener1PreUpdatelistener1PostUpdate\", foo.getValue());\n    Assert.assertEquals(\"masterPostLoadmasterPreUpdatemasterPostUpdate\", foo.getParentValue());\n    this.begin();\n    foo = this.merge(foo);\n    this.remove(foo);\n    this.commit();\n    Assert.assertEquals(\"listener1PostLoadlistener1PreUpdatelistener1PostUpdatelistener1PreRemovelistener1PostRemove\", foo.getValue());\n    Assert.assertEquals(\"masterPostLoadmasterPreUpdatemasterPostUpdatemasterPreRemovemasterPostRemove\", foo.getParentValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2426, "method_signature": "void testListener3()"}, "LobTest.testLob": {"callee_method_names": ["Foo.getValues", "Foo.getValues", "Foo.setClob", "Foo.setBlob", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getValues", "Foo.getBlob", "Foo.getClob"], "method_name": "LobTest.testLob", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.getValues().add(LobTest.VALUE1);\n    foo.getValues().add(LobTest.VALUE2);\n    foo.setClob(LobTest.CLOB_DATA);\n    foo.setBlob(LobTest.BLOB_DATA.getBytes());\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(Sets.newHashSet(LobTest.VALUE1, LobTest.VALUE2), foo2.getValues());\n    Assert.assertEquals(Arrays.toString(LobTest.BLOB_DATA.getBytes()), Arrays.toString(foo2.getBlob()));\n    Assert.assertEquals(LobTest.CLOB_DATA, foo2.getClob());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with lob values\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2064, "method_signature": "void testLob()"}, "LocateExpression.generateJpqlRestriction": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "LocateExpression.generateJpqlRestriction", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"locate(\");\n    builder.append(this.find.generateJpqlRestriction(query));\n    builder.append(\", \").append(this.in.generateJpqlRestriction(query));\n    if (this.start != null) {\n        builder.append(\", \").append(this.start.generateJpqlRestriction(query));\n    }\n    return builder.append(\")\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 547, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "LocateExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "LocateExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 548, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "LocateExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "LocateExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 549, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "LocateExpression.getSqlRestrictionFragments": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "LocateExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"LOCATE(\");\n    builder.append(this.find.getSqlRestrictionFragments(query)[0]);\n    builder.append(\", \").append(this.in.getSqlRestrictionFragments(query)[0]);\n    if (this.start != null) {\n        builder.append(\", \").append(this.start.getSqlRestrictionFragments(query)[0]);\n    }\n    return new String[] { builder.append(\")\").toString() };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 550, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "LongToStringStyle.appendDetail": {"callee_method_names": ["StringBuffer.append", "Map.entrySet", "int.hasNext", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "int.next", "StringBuffer.append", "Entry.getKey", "StringBuffer.append", "StringBuffer.append", "Entry.getValue", "int.hasNext", "StringBuffer.append", "StringBuffer.append"], "method_name": "LongToStringStyle.appendDetail", "method_implementation": "{\n    final String indent = this.indent();\n    buffer.append(\"{\");\n    try {\n        for (final Iterator i = map.entrySet().iterator(); i.hasNext(); ) {\n            buffer.append(SystemUtils.LINE_SEPARATOR);\n            buffer.append(indent);\n            buffer.append(\"  \");\n            final Entry entry = (Entry) i.next();\n            buffer.append(entry.getKey());\n            buffer.append(\"=\");\n            buffer.append(entry.getValue());\n            if (i.hasNext()) {\n                buffer.append(\",\");\n            }\n        }\n    } finally {\n        ToStringBuilder.indent.set(ToStringBuilder.indent.get().substring(2));\n    }\n    buffer.append(\"}\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 65, "method_signature": "void appendDetail(StringBuffer, String, Map)"}, "LongToStringStyle.appendEnd": {"callee_method_names": ["String.length", "String.substring"], "method_name": "LongToStringStyle.appendEnd", "method_implementation": "{\n    final String indent = ToStringBuilder.indent.get();\n    ToStringBuilder.indent.set(indent.length() == 0 ? null : indent.substring(2));\n    super.appendEnd(buffer, object);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 66, "method_signature": "void appendEnd(StringBuffer, Object)"}, "LongToStringStyle.appendFieldStart": {"callee_method_names": ["StringBuffer.append"], "method_name": "LongToStringStyle.appendFieldStart", "method_implementation": "{\n    buffer.append(ToStringBuilder.indent.get());\n    super.appendFieldStart(buffer, fieldName);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 67, "method_signature": "void appendFieldStart(StringBuffer, String)"}, "LongToStringStyle.appendStart": {"callee_method_names": [], "method_name": "LongToStringStyle.appendStart", "method_implementation": "{\n    this.indent();\n    super.appendStart(buffer, object);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 68, "method_signature": "void appendStart(StringBuffer, Object)"}, "ManageTest.testAdditionsCommitted": {"callee_method_ids": [2454, 2454], "callee_method_names": ["Person.getId", "Person.setName", "Person.getId", "Person.getName"], "method_name": "ManageTest.testAdditionsCommitted", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.begin();\n    person = this.find(Person.class, person.getId());\n    person.setName(\"Hasan\");\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    Assert.assertEquals(\"Hasan\", person.getName());\n}", "repo_id": "1", "comment": "/**\n * Tests that a basic type changed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2492, "method_signature": "void testAdditionsCommitted()"}, "ManageTest.testAssociationsCommitted": {"callee_method_ids": [2454, 2454, 2495, 2454, 2454], "callee_method_names": ["Person.getId", "Person.getId", "Person.setName", "Person.getAddresses", "Address.setPerson", "Person.getId", "Person.getId", "Person.getName", "Person.getAddresses", "Person.getAddresses"], "method_name": "ManageTest.testAssociationsCommitted", "method_implementation": "{\n    Person person1 = this.person();\n    Person person2 = this.person();\n    this.persist(person1);\n    this.persist(person2);\n    this.commit();\n    this.begin();\n    person1 = this.find(Person.class, person1.getId());\n    person2 = this.find(Person.class, person2.getId());\n    person1.setName(\"Hasan\");\n    final Address address = person1.getAddresses().remove(0);\n    address.setPerson(person2);\n    this.commit();\n    this.close();\n    person1 = this.find(Person.class, person1.getId());\n    person2 = this.find(Person.class, person2.getId());\n    Assert.assertEquals(\"Hasan\", person1.getName());\n    Assert.assertEquals(2, person1.getAddresses().size());\n    Assert.assertEquals(4, person2.getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * Tests that a basic type changed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2493, "method_signature": "void testAssociationsCommitted()"}, "ManageTest.testLazyInitialize": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.setName"], "method_name": "ManageTest.testLazyInitialize", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    this.begin();\n    person.getName();\n    person.setName(\"Hasan\");\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests that a basic type changed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2494, "method_signature": "void testLazyInitialize()"}, "ManagedCollection.changed": {"callee_method_names": [], "method_name": "ManagedCollection.changed", "method_implementation": "{\n    if (!this.changed && (this.managedInstance != null)) {\n        this.changed = true;\n        this.managedInstance.setChanged(this.mapping);\n    }\n}", "repo_id": "1", "comment": "/**\n * Marks the collection as changed.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 855, "method_signature": "void changed()"}, "ManagedCollection.mergeWith": {"callee_method_ids": [449, 487, 487], "callee_method_names": ["ArrayList<E>.add", "EntityManagerImpl.mergeImpl", "EntityManagerImpl.getSession", "ArrayList<E>.size", "ArrayList<E>.get", "Collection<E>.contains", "PluralAssociationMappingImpl<?, ?, ?>.get", "Collection.contains", "Collection.add", "SessionImpl.get", "ArrayList<E>.size", "ArrayList<E>.get", "ArrayList<E>.contains", "PluralAssociationMappingImpl<?, ?, ?>.get", "Collection.remove", "SessionImpl.get"], "method_name": "ManagedCollection.mergeWith", "method_implementation": "{\n    final ArrayList<E> mergedChildren = Lists.newArrayList();\n    final Object children = this.mapping.get(instance);\n    // if it is a managed collection and not initialized then skip the merge\n    if ((children instanceof ManagedCollection) && !((ManagedCollection<E>) children).isInitialized()) {\n        return;\n    }\n    final Collection<E> collection;\n    if (children instanceof Collection) {\n        collection = (Collection<E>) children;\n    } else {\n        collection = ((Map<?, E>) children).values();\n    }\n    // merge all the new children\n    for (final E child : collection) {\n        mergedChildren.add(entityManager.mergeImpl(child, requiresFlush, processed, instances, this.mapping.cascadesMerge()));\n    }\n    // make a snapshot\n    this.snapshot();\n    final Collection<E> delegate = this.getDelegate();\n    boolean changed = false;\n    final SessionImpl session = entityManager.getSession();\n    final PluralAssociationMappingImpl<?, ?, ?> inversePluralMapping = (this.inverse != null) && //\n    (this.inverse.getAttribute() instanceof PluralAttributeImpl) ? (PluralAssociationMappingImpl<?, ?, ?>) this.inverse : null;\n    // TODO needs to be overridden by ManagedMap\n    // add the new children\n    for (int i = 0; i < mergedChildren.size(); i++) {\n        final E child = mergedChildren.get(i);\n        if (!delegate.contains(child)) {\n            this.getDelegate().add(child);\n            if (this.inverse != null) {\n                if (inversePluralMapping != null) {\n                    final Collection inverseCollection = (Collection<?>) inversePluralMapping.get(child);\n                    if (!inverseCollection.contains(this.managedInstance.getInstance())) {\n                        inverseCollection.add(this.managedInstance.getInstance());\n                    }\n                } else {\n                    this.inverse.set(session.get(child).getInstance(), this.managedInstance.getInstance());\n                }\n            }\n            changed = true;\n        }\n    }\n    // remove the non existent children\n    final ArrayList<E> delegateList = Lists.newArrayList(delegate);\n    for (int i = 0; i < delegateList.size(); i++) {\n        final E child = delegateList.get(i);\n        if (!mergedChildren.contains(child)) {\n            this.removeChild(child);\n            if (this.inverse != null) {\n                if (inversePluralMapping != null) {\n                    final Collection inverseCollection = (Collection<?>) inversePluralMapping.get(child);\n                    inverseCollection.remove(this.managedInstance.getInstance());\n                } else {\n                    this.inverse.set(session.get(child).getInstance(), null);\n                }\n            }\n            changed = true;\n        }\n    }\n    if (changed) {\n        this.changed();\n    }\n}", "repo_id": "1", "comment": "/**\n * Merges the collection with the entity\n *\n * @param entityManager\n *            the entity manager\n * @param instance\n *            the new entity\n * @param requiresFlush\n *            if an implicit flush is required\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the persisted instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 856, "method_signature": "void mergeWith(EntityManagerImpl, Object, MutableBoolean, IdentityHashMap, LinkedList)"}, "ManagedCollection.persistAdditions": {"callee_method_ids": [450], "callee_method_names": ["EntityManagerImpl.persist"], "method_name": "ManagedCollection.persistAdditions", "method_implementation": "{\n    final Collection<E> added = BatooUtils.subtract(this.getDelegate(), this.getSnapshot());\n    for (final E e : added) {\n        entityManager.persist(e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Persists the entities that have been added to the collection.\n *\n * @param entityManager\n *            the entity manager\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 857, "method_signature": "void persistAdditions(EntityManagerImpl)"}, "ManagedCollection.removeOrphans": {"callee_method_ids": [454], "callee_method_names": ["List<E>.size", "EntityManagerImpl.remove", "List<E>.get"], "method_name": "ManagedCollection.removeOrphans", "method_implementation": "{\n    final List<E> removed = BatooUtils.subtract(this.getSnapshot(), this.getDelegate());\n    for (int i = 0; i < removed.size(); i++) {\n        entityManager.remove(removed.get(i));\n    }\n}", "repo_id": "1", "comment": "/**\n * Removes the entities that have been orphaned by removal from the collection.\n *\n * @param entityManager\n *            the entity manager\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 859, "method_signature": "void removeOrphans(EntityManagerImpl)"}, "ManagedCollection.removed": {"callee_method_names": [], "method_name": "ManagedCollection.removed", "method_implementation": "{\n    // if the instance removed remove all the relations\n    if (removals && (this.managedInstance.getStatus() == Status.REMOVED)) {\n        this.mapping.detachAll(connection, this.managedInstance);\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * @param connection\n *            the connection\n * @param removals\n *            true if the removals should be flushed and false for the additions\n * @return returns true if the instance has been removed\n * @throws SQLException\n *             thrown in case of an SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 858, "method_signature": "boolean removed(Connection, boolean)"}, "ManagedCollectionTest.testAdditionsCommitted": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "ManagedCollectionTest.testAdditionsCommitted", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    person = this.find(Person.class, person.getId());\n    this.begin();\n    new Address(person, \"Paris\");\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests that additions to managed collection that are committed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2137, "method_signature": "void testAdditionsCommitted()"}, "ManagedCollectionTest.testAdditionsExisting": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "ManagedCollectionTest.testAdditionsExisting", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    this.begin();\n    new Address(person, \"Paris\");\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests that additions to existing managed collection\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2138, "method_signature": "void testAdditionsExisting()"}, "ManagedCollectionTest.testAdditionsPersist": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "ManagedCollectionTest.testAdditionsPersist", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    person = this.find(Person.class, person.getId());\n    new Address(person, \"Paris\");\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests that additions to managed collection that are committed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2139, "method_signature": "void testAdditionsPersist()"}, "ManagedCollectionTest.testNoDuplicates": {"callee_method_names": ["Person.getAddresses", "Person.getAddresses"], "method_name": "ManagedCollectionTest.testNoDuplicates", "method_implementation": "{\n    final Person person = this.person();\n    person.getAddresses().add(person.getAddresses().get(0));\n    this.persist(person);\n}", "repo_id": "1", "comment": "/**\n * Tests that managed collection does not allow duplicates.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2140, "method_signature": "void testNoDuplicates()"}, "ManagedCollectionTest.testNoDuplicatesAfterPersist": {"callee_method_names": ["Person.getAddresses", "Person.getAddresses"], "method_name": "ManagedCollectionTest.testNoDuplicatesAfterPersist", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    person.getAddresses().add(person.getAddresses().get(0));\n}", "repo_id": "1", "comment": "/**\n * Tests that managed collection does not allow duplicates.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2141, "method_signature": "void testNoDuplicatesAfterPersist()"}, "ManagedId.equals": {"callee_method_names": ["ManagedId<?>.getRootType"], "method_name": "ManagedId.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (this.getId() == null) {\n        return false;\n    }\n    final ManagedId<?> other = (ManagedId<?>) obj;\n    if ((other == null) || (other.id == null)) {\n        return false;\n    }\n    if (this.type.getRootType() != other.type.getRootType()) {\n        return false;\n    }\n    return this.id.equals(other.id);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 938, "method_signature": "boolean equals(Object)"}, "ManagedId.hashCode": {"callee_method_names": [], "method_name": "ManagedId.hashCode", "method_implementation": "{\n    if (this.h != 0) {\n        return this.h;\n    }\n    if (this.getId() == null) {\n        return 1;\n    }\n    final int prime = 31;\n    this.h = 1;\n    this.h = (prime * this.h) + this.id.hashCode();\n    return this.h = (prime * this.h) + this.type.getName().hashCode();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 939, "method_signature": "int hashCode()"}, "ManagedInstance.cascadeDetach": {"callee_method_ids": [437, 437, 437], "callee_method_names": ["SingularAssociationMappingImpl<?, ?>.getAttribute", "SingularAssociationMappingImpl<?, ?>.get", "SingularAssociationMappingImpl<?, ?>.get", "List<?>.size", "EntityManagerImpl.detach", "List<?>.get", "EntityManagerImpl.detach", "SingularAssociationMappingImpl<?, ?>.get", "EntityManagerImpl.detach"], "method_name": "ManagedInstance.cascadeDetach", "method_implementation": "{\n    this.status = Status.DETACHED;\n    ManagedInstance.LOG.debug(\"Cascading detach on {0}\", this);\n    for (final AssociationMappingImpl<?, ?, ?> association : this.type.getAssociationsDetachable()) {\n        // if the association a collection attribute then we will cascade to each element\n        if (association instanceof PluralAssociationMappingImpl) {\n            final PluralAssociationMappingImpl<?, ?, ?> mapping = (PluralAssociationMappingImpl<?, ?, ?>) association;\n            final Collection<?> collection;\n            if (mapping.getAttribute().getCollectionType() == CollectionType.MAP) {\n                collection = ((Map<?, ?>) mapping.get(this.instance)).values();\n            } else {\n                // extract the collection\n                collection = (Collection<?>) mapping.get(this.instance);\n            }\n            // cascade to each element in the collection\n            if (collection instanceof List) {\n                final List<?> list = (List<?>) collection;\n                for (int i = 0; i < list.size(); i++) {\n                    entityManager.detach(list.get(i));\n                }\n            } else if (collection != null) {\n                for (final Object element : collection) {\n                    entityManager.detach(element);\n                }\n            }\n        } else {\n            final SingularAssociationMappingImpl<?, ?> mapping = (SingularAssociationMappingImpl<?, ?>) association;\n            final Object associate = mapping.get(this.instance);\n            entityManager.detach(associate);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Cascades the detach operation.\n *\n * @param entityManager\n *            the entity manager\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 940, "method_signature": "void cascadeDetach(EntityManagerImpl)"}, "ManagedInstance.cascadePersist": {"callee_method_ids": [451, 451, 451, 451, 451], "callee_method_names": ["SingularAssociationMappingImpl<?, ?>.getAttribute", "SingularAssociationMappingImpl<?, ?>.get", "Map<?, ?>.values", "EntityManagerImpl.persistImpl", "SingularAssociationMappingImpl<?, ?>.get", "List<?>.size", "EntityManagerImpl.persistImpl", "List<?>.get", "SingularAssociationMappingImpl<?, ?>.get", "List<?>.size", "EntityManagerImpl.persistImpl", "List<?>.get", "EntityManagerImpl.persistImpl", "SingularAssociationMappingImpl<?, ?>.get", "EntityManagerImpl.persistImpl"], "method_name": "ManagedInstance.cascadePersist", "method_implementation": "{\n    ManagedInstance.LOG.debug(\"Cascading persist on {0}\", this);\n    boolean requiresFlush = false;\n    for (final AssociationMappingImpl<?, ?, ?> association : this.type.getAssociationsPersistable()) {\n        // if the association a collection attribute then we will cascade to each element\n        if (association instanceof PluralAssociationMappingImpl) {\n            final PluralAssociationMappingImpl<?, ?, ?> mapping = (PluralAssociationMappingImpl<?, ?, ?>) association;\n            switch(mapping.getAttribute().getCollectionType()) {\n                case MAP:\n                    // extract the map\n                    final Map<?, ?> map = (Map<?, ?>) mapping.get(this.instance);\n                    // cascade to each element in the map\n                    for (final Object element : map.values()) {\n                        requiresFlush |= entityManager.persistImpl(element, processed, instances);\n                    }\n                    break;\n                case LIST:\n                    // extract the list\n                    final List<?> list = (List<?>) mapping.get(this.instance);\n                    // cascade to each element in the list\n                    for (int i = 0; i < list.size(); i++) {\n                        requiresFlush |= entityManager.persistImpl(list.get(i), processed, instances);\n                    }\n                    break;\n                default:\n                    // extract the collection\n                    final Collection<?> collection = (Collection<?>) mapping.get(this.instance);\n                    // cascade to each element in the collection\n                    if (collection instanceof List) {\n                        final List<?> castedList = (List<?>) collection;\n                        for (int i = 0; i < castedList.size(); i++) {\n                            requiresFlush |= entityManager.persistImpl(castedList.get(i), processed, instances);\n                        }\n                    } else if (collection != null) {\n                        for (final Object element : collection) {\n                            requiresFlush |= entityManager.persistImpl(element, processed, instances);\n                        }\n                    }\n                    break;\n            }\n        } else {\n            final SingularAssociationMappingImpl<?, ?> mapping = (SingularAssociationMappingImpl<?, ?>) association;\n            final Object associate = mapping.get(this.instance);\n            if (associate != null) {\n                requiresFlush |= entityManager.persistImpl(associate, processed, instances);\n            }\n        }\n    }\n    return requiresFlush;\n}", "repo_id": "1", "comment": "/**\n * Cascades the persist operation.\n *\n * @param entityManager\n *            the entity manager\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the managed instances\n * @return true if an implicit flush is required, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 941, "method_signature": "boolean cascadePersist(EntityManagerImpl, ArrayList, LinkedList)"}, "ManagedInstance.cascadeRemove": {"callee_method_ids": [455, 455, 455], "callee_method_names": ["SingularAssociationMappingImpl<?, ?>.getAttribute", "SingularAssociationMappingImpl<?, ?>.get", "SingularAssociationMappingImpl<?, ?>.get", "List<?>.size", "EntityManagerImpl.removeImpl", "List<?>.get", "EntityManagerImpl.removeImpl", "SingularAssociationMappingImpl<?, ?>.get", "EntityManagerImpl.removeImpl"], "method_name": "ManagedInstance.cascadeRemove", "method_implementation": "{\n    ManagedInstance.LOG.debug(\"Cascading remove on {0}\", this);\n    for (final AssociationMappingImpl<?, ?, ?> association : this.type.getAssociationsRemovable()) {\n        // if the association a collection attribute then we will cascade to each element\n        if (association instanceof PluralAssociationMappingImpl) {\n            final PluralAssociationMappingImpl<?, ?, ?> mapping = (PluralAssociationMappingImpl<?, ?, ?>) association;\n            // extract the collection\n            final Collection<?> collection;\n            if (mapping.getAttribute().getCollectionType() == CollectionType.MAP) {\n                collection = ((Map<?, ?>) mapping.get(this.instance)).values();\n            } else {\n                collection = (Collection<?>) mapping.get(this.instance);\n            }\n            // cascade to each element in the collection\n            if (collection instanceof List) {\n                final List<?> list = (List<?>) collection;\n                for (int i = 0; i < list.size(); i++) {\n                    entityManager.removeImpl(list.get(i), processed, instances);\n                }\n            } else if (collection != null) {\n                for (final Object element : collection) {\n                    entityManager.removeImpl(element, processed, instances);\n                }\n            }\n        } else {\n            final SingularAssociationMappingImpl<?, ?> mapping = (SingularAssociationMappingImpl<?, ?>) association;\n            final Object associate = mapping.get(this.instance);\n            if (associate != null) {\n                entityManager.removeImpl(associate, processed, instances);\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Cascades the remove operation\n *\n * @param entityManager\n *            the entity manager\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the managed instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 942, "method_signature": "void cascadeRemove(EntityManagerImpl, ArrayList, LinkedList)"}, "ManagedInstance.changed": {"callee_method_names": [], "method_name": "ManagedInstance.changed", "method_implementation": "{\n    if (!this.changed && (this.collectionsChanged.size() == 0)) {\n        this.session.setChanged(this);\n    }\n    if (!this.changed) {\n        this.snapshot();\n        this.changed = true;\n    }\n}", "repo_id": "1", "comment": "/**\n * Marks the instance as may have changed.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 943, "method_signature": "void changed()"}, "ManagedInstance.checkTransients": {"callee_method_names": ["SingularAssociationMappingImpl<? super X, ?>.checkTransient"], "method_name": "ManagedInstance.checkTransients", "method_implementation": "{\n    for (final AssociationMappingImpl<?, ?, ?> association : this.type.getAssociationsNotPersistable()) {\n        association.checkTransient(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Checks that no association of the instance is transient\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 944, "method_signature": "void checkTransients()"}, "ManagedInstance.checkUpdated": {"callee_method_names": [], "method_name": "ManagedInstance.checkUpdated", "method_implementation": "{\n    // no snapshot, nothing to check\n    if ((this.snapshot.size() == 0) || this.changed) {\n        return;\n    }\n    if (this.checkUpdatedImpl()) {\n        this.changed();\n    }\n}", "repo_id": "1", "comment": "/**\n * Checks if the instance updated.\n * <p>\n * Only meaningful for external entities as their instances' are not enhanced.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 945, "method_signature": "void checkUpdated()"}, "ManagedInstance.enhanceCollections": {"callee_method_names": ["Collection<?>.enhance"], "method_name": "ManagedInstance.enhanceCollections", "method_implementation": "{\n    for (final PluralMappingEx<?, ?, ?> collection : this.type.getMappingsPlural()) {\n        collection.enhance(this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Enhances the collections of the managed instance.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 946, "method_signature": "void enhanceCollections()"}, "ManagedInstance.equals": {"callee_method_names": ["ManagedId<? super X>.equals", "ManagedInstance<?>.getId"], "method_name": "ManagedInstance.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    final ManagedId<? super X> thisId = this.getId();\n    final ManagedInstance<?> other = (ManagedInstance<?>) obj;\n    return (thisId != null) && thisId.equals(other.getId());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 947, "method_signature": "boolean equals(Object)"}, "ManagedInstance.fillIdValues": {"callee_method_names": [], "method_name": "ManagedInstance.fillIdValues", "method_implementation": "{\n    ManagedInstance.LOG.debug(\"Auto generating id values for {0}\", this);\n    return this.hasInitialId = this.fillValuesImpl();\n}", "repo_id": "1", "comment": "/**\n * Fills the sequence / table generated values. The operation returns false if at least one entity needs to obtain identity from the\n * database.\n *\n * @return false if all OK, true if if at least one entity needs to obtain identity from the database\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 948, "method_signature": "boolean fillIdValues()"}, "ManagedInstance.fireCallbacks": {"callee_method_names": [], "method_name": "ManagedInstance.fireCallbacks", "method_implementation": "{\n    EntityListenerType typeToFire = type;\n    if ((type == EntityListenerType.PRE_UPDATE) && (this.status == Status.NEW)) {\n        typeToFire = EntityListenerType.PRE_PERSIST;\n    }\n    if ((type == EntityListenerType.POST_UPDATE) && (this.oldStatus == Status.NEW)) {\n        typeToFire = EntityListenerType.POST_PERSIST;\n    }\n    // safeguard single invocation for PrePersists\n    if (typeToFire == EntityListenerType.PRE_PERSIST) {\n        if (!this.prePersistCalled) {\n            this.prePersistCalled = true;\n            this.type.fireCallbacks(this.instance, typeToFire);\n        }\n    } else if (typeToFire == EntityListenerType.PRE_REMOVE) {\n        if (!this.preRemoveCalled) {\n            this.preRemoveCalled = true;\n            this.type.fireCallbacks(this.instance, typeToFire);\n        }\n    } else {\n        this.type.fireCallbacks(this.instance, typeToFire);\n    }\n}", "repo_id": "1", "comment": "/**\n * Fires the callbacks.\n *\n * @param type\n *            the type of the callbacks\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 949, "method_signature": "void fireCallbacks(EntityListenerType)"}, "ManagedInstance.flushAssociations": {"callee_method_names": ["Collection<?>.flush"], "method_name": "ManagedInstance.flushAssociations", "method_implementation": "{\n    if (!removals || (this.status != Status.NEW)) {\n        ManagedInstance.LOG.debug(\"Flushing associations for instance {0}\", this);\n        for (final JoinedMapping<?, ?, ?> collection : this.type.getMappingsJoined()) {\n            collection.flush(connection, this, removals, force);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Flushes the associations.\n *\n * @param connection\n *            the connection\n * @param removals\n *            true if the removals should be flushed and false for the additions\n * @param force\n *            true to force, effective only for insertions and for new entities.\n * @throws SQLException\n *             thrown if there is an underlying SQL Exception\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 950, "method_signature": "void flushAssociations(Connection, boolean, boolean)"}, "ManagedInstance.getId": {"callee_method_names": [], "method_name": "ManagedInstance.getId", "method_implementation": "{\n    if (this.id != null) {\n        return this.id;\n    }\n    return this.id = this.type.getId(this.instance);\n}", "repo_id": "1", "comment": "/**\n * Returns the id of the instance.\n *\n * @return the id of the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 951, "method_signature": "ManagedId<? super X> getId()"}, "ManagedInstance.handleAdditions": {"callee_method_names": [], "method_name": "ManagedInstance.handleAdditions", "method_implementation": "{\n    ManagedInstance.LOG.debug(\"Inspecting additions for instance {0}\", this);\n    for (int i = 0; i < this.collectionsChanged.size(); i++) {\n        final PluralMappingEx<?, ?, ?> collection = this.collectionsChanged.get(i);\n        if (collection instanceof PluralAssociationMappingImpl) {\n            ((PluralAssociationMappingImpl<?, ?, ?>) collection).persistAdditions(entityManager, this);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the entities that have been added.\n *\n * @param entityManager\n *            the entity manager\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 952, "method_signature": "void handleAdditions(EntityManagerImpl)"}, "ManagedInstance.handleOrphans": {"callee_method_names": ["PluralMappingEx<?, ?, ?>.isAssociation"], "method_name": "ManagedInstance.handleOrphans", "method_implementation": "{\n    ManagedInstance.LOG.debug(\"Inspecting orphans for instance {0}\", this);\n    for (int i = 0; i < this.collectionsChanged.size(); i++) {\n        final PluralMappingEx<?, ?, ?> collection = this.collectionsChanged.get(i);\n        if (collection.isAssociation()) {\n            ((PluralAssociationMappingImpl<?, ?, ?>) collection).removeOrphans(entityManager, this);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the entities that have been orphaned.\n *\n * @param entityManager\n *            the entity manager\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 953, "method_signature": "void handleOrphans(EntityManagerImpl)"}, "ManagedInstance.hasSelfUpdate": {"callee_method_names": [], "method_name": "ManagedInstance.hasSelfUpdate", "method_implementation": "{\n    if (!this.changed && (this.snapshot.size() == 0)) {\n        return false;\n    }\n    if (this.collectionsChanged.size() > 0) {\n        return true;\n    }\n    return this.checkUpdatedImpl();\n}", "repo_id": "1", "comment": "/**\n * Returns if the instance has self update.\n *\n * @return true if the instance has self update, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 955, "method_signature": "boolean hasSelfUpdate()"}, "ManagedInstance.hashCode": {"callee_method_names": ["ManagedId<? super X>.hashCode"], "method_name": "ManagedInstance.hashCode", "method_implementation": "{\n    if (this.h != 0) {\n        return this.h;\n    }\n    final ManagedId<? super X> _id = this.getId();\n    final int prime = 31;\n    int result = 1;\n    ;\n    result = (prime * result) + this.type.getRootType().getName().hashCode();\n    result = prime * result + ((_id == null) ? 0 : _id.hashCode());\n    return this.h = result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 954, "method_signature": "int hashCode()"}, "ManagedInstance.incrementVersion": {"callee_method_names": ["EntityTypeImpl<? super X>.getVersionAttribute", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.set", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.set", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.set", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.set", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.set", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.set", "BasicAttribute<? super X, ?>.get", "BasicAttribute<? super X, ?>.set", "BasicAttribute<? super X, ?>.get", "EntityTypeImpl<? super X>.performVersionUpdate"], "method_name": "ManagedInstance.incrementVersion", "method_implementation": "{\n    if (!this.type.getRootType().hasVersionAttribute()) {\n        return;\n    }\n    final EntityTypeImpl<? super X> rootType = this.type.getRootType();\n    final BasicAttribute<? super X, ?> version = rootType.getVersionAttribute();\n    if (this.oldVersion == null) {\n        switch(this.type.getVersionType()) {\n            case SHORT:\n                final short shortValue = (((Number) version.get(this.instance)).shortValue());\n                this.oldVersion = shortValue;\n                version.set(this.instance, shortValue + 1);\n                ManagedInstance.LOG.debug(\"Version upgraded instance: {0} - {1}\", this, shortValue);\n                break;\n            case SHORT_OBJECT:\n                final Short shortObjValue = //\n                version.get(this.instance) == null ? //\n                0 : Short.valueOf((((Number) version.get(this.instance)).shortValue()));\n                this.oldVersion = shortObjValue;\n                version.set(this.instance, shortObjValue + 1);\n                ManagedInstance.LOG.debug(\"Version upgraded instance: {0} - {1}\", this, shortObjValue);\n                break;\n            case INT:\n                final int intValue = (((Number) version.get(this.instance)).intValue());\n                this.oldVersion = intValue;\n                version.set(this.instance, intValue + 1);\n                ManagedInstance.LOG.debug(\"Version upgraded instance: {0} - {1}\", this, intValue);\n                break;\n            case INT_OBJECT:\n                final Integer intObjValue = //\n                version.get(this.instance) == null ? //\n                0 : Integer.valueOf(((Number) version.get(this.instance)).intValue());\n                this.oldVersion = intObjValue;\n                version.set(this.instance, intObjValue + 1);\n                ManagedInstance.LOG.debug(\"Version upgraded instance: {0} - {1}\", this, intObjValue);\n                break;\n            case LONG:\n                final long longValue = (((Number) version.get(this.instance)).longValue());\n                this.oldVersion = longValue;\n                version.set(this.instance, longValue + 1);\n                ManagedInstance.LOG.debug(\"Version upgraded instance: {0} - {1}\", this, longValue);\n                break;\n            case LONG_OBJECT:\n                final Long longObjValue = //\n                version.get(this.instance) == null ? //\n                0l : Long.valueOf((((Number) version.get(this.instance)).longValue()));\n                this.oldVersion = longObjValue;\n                version.set(this.instance, longObjValue + 1);\n                ManagedInstance.LOG.debug(\"Version upgraded instance: {0} - {1}\", this, longObjValue);\n                break;\n            case TIMESTAMP:\n                final Timestamp value = new Timestamp(System.currentTimeMillis());\n                this.oldVersion = version.get(this.instance);\n                version.set(this.instance, value);\n                ManagedInstance.LOG.debug(\"Version upgraded instance: {0} - {1}\", this, value);\n        }\n    }\n    if (commit) {\n        final Object newVersion = version.get(this.instance);\n        rootType.performVersionUpdate(connection, this, this.oldVersion, newVersion);\n        ManagedInstance.LOG.debug(\"Version committed instance: {0} - {1} -> {2}\", this, this.oldVersion, newVersion);\n        this.oldVersion = null;\n    } else {\n        this.changed();\n    }\n}", "repo_id": "1", "comment": "/**\n * Increments the version of the instance.\n *\n * @param connection\n *            the connection\n * @param commit\n *            true if version update should be committed immediately\n * @throws SQLException\n *             thrown in case of an underlying SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 956, "method_signature": "void incrementVersion(Connection, boolean)"}, "ManagedInstance.isJoinLoaded": {"callee_method_names": ["AbstractMapping<?, ?, ?>.getPath"], "method_name": "ManagedInstance.isJoinLoaded", "method_implementation": "{\n    final AbstractMapping<?, ?, ?> mapping = this.type.getRootMapping().getMapping(attributeName);\n    if ((mapping instanceof BasicMappingImpl) || (mapping instanceof EmbeddedMappingImpl)) {\n        return true;\n    }\n    if (((AssociationMappingImpl<?, ?, ?>) mapping).isEager()) {\n        return true;\n    }\n    return this.joinsLoaded.contains(mapping.getPath());\n}", "repo_id": "1", "comment": "/**\n * Returns if attribute name <code>attributeNa\u00f6e</code> has been loaded.\n *\n * @param attributeName\n *            the name of the attribute\n * @return true if join is loaded, false otherwise\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 957, "method_signature": "boolean isJoinLoaded(String)"}, "ManagedInstance.mergeWith": {"callee_method_names": ["AbstractMapping<?, ?, ?>.set", "AbstractMapping<?, ?, ?>.get", "SingularAssociationMappingImpl<? super X, ?>.mergeWith"], "method_name": "ManagedInstance.mergeWith", "method_implementation": "{\n    this.snapshot();\n    for (final BasicMappingImpl<?, ?> mapping : this.type.getBasicMappings()) {\n        mapping.set(this.instance, mapping.get(entity));\n    }\n    for (final AssociationMappingImpl<?, ?, ?> association : this.type.getAssociations()) {\n        association.mergeWith(entityManager, this, entity, requiresFlush, processed, instances);\n    }\n    this.checkUpdated();\n}", "repo_id": "1", "comment": "/**\n * Merges the instance state with the <code>entity</code>.\n *\n * @param entityManager\n *            the entity manager\n * @param entity\n *            the entity to merge\n * @param requiresFlush\n *            if an implicit flush is required\n * @param processed\n *            registry of processed entities\n * @param instances\n *            the persisted instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 958, "method_signature": "void mergeWith(EntityManagerImpl, X, MutableBoolean, IdentityHashMap, LinkedList)"}, "ManagedInstance.processJoinedMappings": {"callee_method_ids": [438], "callee_method_names": ["HashSet<String>.contains", "AbstractMapping<?, ?, ?>.getPath", "AbstractMapping<?, ?, ?>.isEager", "AbstractMapping<?, ?, ?>.load", "AbstractMapping<?, ?, ?>.setLazy", "AbstractMapping<?, ?, ?>.isEager", "HashSet<String>.contains", "AbstractMapping<?, ?, ?>.getPath", "AbstractMapping<?, ?, ?>.initialize", "AbstractMapping<?, ?, ?>.get", "EnhancedInstance.__enhanced__$$__isInitialized", "EnhancedInstance.__enhanced__$$__getManagedInstance", "EntityManagerImpl.find", "ManagedInstance<?>.getType", "ManagedInstance<?>.getId"], "method_name": "ManagedInstance.processJoinedMappings", "method_implementation": "{\n    ManagedInstance.LOG.debug(\"Post processing associations for instance {0}\", this);\n    final HashSet<String> _joinsLoaded = this.joinsLoaded;\n    for (final PluralMappingEx<?, ?, ?> mapping : this.type.getMappingsPlural()) {\n        final HashSet<String> joinsLoaded2 = _joinsLoaded;\n        if (!joinsLoaded2.contains(mapping.getPath())) {\n            if (mapping.isEager()) {\n                mapping.load(this);\n            } else {\n                mapping.setLazy(this);\n            }\n        }\n    }\n    final X _instance = this.instance;\n    final EntityManagerImpl entityManager = this.session.getEntityManager();\n    for (final SingularAssociationMappingImpl<?, ?> mapping : this.type.getAssociationsSingular()) {\n        if (mapping.isEager()) {\n            if (!_joinsLoaded.contains(mapping.getPath())) {\n                mapping.initialize(this);\n            } else {\n                final Object associate = mapping.get(_instance);\n                if (associate instanceof EnhancedInstance) {\n                    final EnhancedInstance enhancedInstance = (EnhancedInstance) associate;\n                    if (!enhancedInstance.__enhanced__$$__isInitialized()) {\n                        final ManagedInstance<?> associateManagedInstance = enhancedInstance.__enhanced__$$__getManagedInstance();\n                        entityManager.find(associateManagedInstance.getType().getJavaType(), associateManagedInstance.getId().getId());\n                    }\n                }\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Processes the associations.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 959, "method_signature": "void processJoinedMappings()"}, "ManagedInstance.refresh": {"callee_method_names": ["SingularAssociationMappingImpl<? super X, ?>.refresh"], "method_name": "ManagedInstance.refresh", "method_implementation": "{\n    ManagedInstance.LOG.debug(\"Refeshing instance {0}\", this);\n    this.type.performRefresh(connection, this, lockMode, processed);\n    for (final AssociationMappingImpl<?, ?, ?> association : this.type.getAssociations()) {\n        association.refresh(this, processed);\n    }\n}", "repo_id": "1", "comment": "/**\n * Refreshes the instance from the database.\n *\n * @param entityManager\n *            the entity manager\n * @param connection\n *            the connection\n * @param lockMode\n *            the lock mode\n * @param processed\n *            the set of processed instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 960, "method_signature": "void refresh(EntityManagerImpl, Connection, LockModeType, Set)"}, "ManagedInstance.reset": {"callee_method_names": [], "method_name": "ManagedInstance.reset", "method_implementation": "{\n    ManagedInstance.LOG.trace(\"Reset instance {0}\", this);\n    this.collectionsChanged.clear();\n    this.changed = false;\n    this.snapshot.clear();\n    this.snapshot();\n}", "repo_id": "1", "comment": "/**\n * Resets the change status of the instance.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 961, "method_signature": "void reset()"}, "ManagedInstance.setChanged": {"callee_method_names": [], "method_name": "ManagedInstance.setChanged", "method_implementation": "{\n    if ((this.collectionsChanged.size() == 0) && !this.changed) {\n        this.session.setChanged(this);\n    }\n    this.collectionsChanged.add(association);\n}", "repo_id": "1", "comment": "/**\n * Marks the plural association as changed.\n *\n * @param association\n *            the association that has changed\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 962, "method_signature": "void setChanged(PluralMappingEx)"}, "ManagedInstance.setStatus": {"callee_method_names": [], "method_name": "ManagedInstance.setStatus", "method_implementation": "{\n    this.oldStatus = this.status;\n    if (status != this.status) {\n        ManagedInstance.LOG.debug(\"Instance status changing for {0}: {1} -> {2}\", this, this.status, status);\n        this.status = status;\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the status.\n *\n * @param status\n *            the status to set\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 963, "method_signature": "void setStatus(Status)"}, "ManagedInstance.snapshot": {"callee_method_names": ["AbstractMapping<?, ?, ?>.get"], "method_name": "ManagedInstance.snapshot", "method_implementation": "{\n    ManagedInstance.LOG.trace(\"Snapshot generated for instance {0}\", this);\n    if (this.snapshot.size() == 0) {\n        for (final AbstractMapping<?, ?, ?> mapping : this.type.getMappingsSingular()) {\n            this.snapshot.put(mapping, mapping.get(this.instance));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates a snapshot of the entity.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 964, "method_signature": "void snapshot()"}, "ManagedInstance.sortLists": {"callee_method_names": ["AbstractMapping<?, ?, ?>.sortList"], "method_name": "ManagedInstance.sortLists", "method_implementation": "{\n    for (final PluralMappingEx<?, ?, ?> mapping : this.type.getMappingsPluralSorted()) {\n        mapping.sortList(this.instance);\n    }\n}", "repo_id": "1", "comment": "/**\n * Sorts the list associations.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 965, "method_signature": "void sortLists()"}, "ManagedInstance.toString": {"callee_method_names": [], "method_name": "ManagedInstance.toString", "method_implementation": "{\n    return //\n    \"ManagedInstance [session=\" + this.session + \", type=\" + //\n    this.type.getName() + \", status=\" + //\n    this.status + \", id=\" + (this.id != null ? this.id.getId() : null) + \"]\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 966, "method_signature": "String toString()"}, "ManagedList.add": {"callee_method_names": [], "method_name": "ManagedList.add", "method_implementation": "{\n    this.snapshot();\n    if (element == null) {\n        throw new NullPointerException();\n    }\n    if (this.contains(element)) {\n        throw this.noDuplicates();\n    }\n    this.delegate.add(index, element);\n    this.changed();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 905, "method_signature": "void add(int, E)"}, "ManagedList.addAll": {"callee_method_names": ["List<? extends E>.size", "List<? extends E>.get"], "method_name": "ManagedList.addAll", "method_implementation": "{\n    this.snapshot();\n    if (c instanceof List) {\n        final List<? extends E> list = (List<? extends E>) c;\n        for (int i = 0; i < list.size(); i++) {\n            if (this.delegate.contains(list.get(i))) {\n                throw this.noDuplicates();\n            }\n        }\n    } else {\n        for (final E e : c) {\n            if (this.delegate.contains(e)) {\n                throw this.noDuplicates();\n            }\n        }\n    }\n    if (this.delegate.addAll(index, c)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 907, "method_signature": "boolean addAll(int, Collection)"}, "ManagedList.addChild": {"callee_method_names": ["EntryImpl<Object,ManagedInstance<?>>.getValue"], "method_name": "ManagedList.addChild", "method_implementation": "{\n    final E e = (E) child.getValue().getInstance();\n    if (!this.delegate.contains(e)) {\n        return this.delegate.add(e);\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 908, "method_signature": "boolean addChild(EntryImpl)"}, "ManagedList.addElement": {"callee_method_names": ["EntryImpl<Object,?>.getValue"], "method_name": "ManagedList.addElement", "method_implementation": "{\n    final E e = (E) child.getValue();\n    if (!this.delegate.contains(e)) {\n        return this.delegate.add(e);\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 909, "method_signature": "boolean addElement(EntryImpl)"}, "ManagedList.clear": {"callee_method_names": [], "method_name": "ManagedList.clear", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.size() > 0) {\n        this.changed();\n    }\n    this.delegate.clear();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 910, "method_signature": "void clear()"}, "ManagedList.contains": {"callee_method_names": [], "method_name": "ManagedList.contains", "method_implementation": "{\n    this.initialize();\n    return this.delegate.contains(o);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 911, "method_signature": "boolean contains(Object)"}, "ManagedList.containsAll": {"callee_method_names": [], "method_name": "ManagedList.containsAll", "method_implementation": "{\n    this.initialize();\n    return this.delegate.containsAll(c);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 912, "method_signature": "boolean containsAll(Collection)"}, "ManagedList.equals": {"callee_method_names": [], "method_name": "ManagedList.equals", "method_implementation": "{\n    this.initialize();\n    return this.delegate.equals(obj);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 913, "method_signature": "boolean equals(Object)"}, "ManagedList.flush": {"callee_method_names": ["PluralMappingEx<?, ?, E>.detachAll"], "method_name": "ManagedList.flush", "method_implementation": "{\n    if (this.removed(connection, removals)) {\n        return;\n    }\n    // for lists the index is maintained in the database\n    final ManagedInstance<?> instance = this.getManagedInstance();\n    final PluralMappingEx<?, ?, E> mapping = this.getMapping();\n    // forced creation of relations for the new entities\n    if (force) {\n        this.attachChildren(connection, instance, mapping);\n        return;\n    }\n    if (this.snapshot == null) {\n        return;\n    }\n    if (removals) {\n        mapping.detachAll(connection, instance);\n    } else {\n        this.attachChildren(connection, instance, mapping);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 914, "method_signature": "void flush(Connection, boolean, boolean)"}, "ManagedList.get": {"callee_method_names": [], "method_name": "ManagedList.get", "method_implementation": "{\n    this.initialize();\n    return this.delegate.get(index);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 915, "method_signature": "E get(int)"}, "ManagedList.hashCode": {"callee_method_names": [], "method_name": "ManagedList.hashCode", "method_implementation": "{\n    this.initialize();\n    return this.delegate.hashCode();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 916, "method_signature": "int hashCode()"}, "ManagedList.indexOf": {"callee_method_names": [], "method_name": "ManagedList.indexOf", "method_implementation": "{\n    this.initialize();\n    return this.delegate.indexOf(o);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 917, "method_signature": "int indexOf(Object)"}, "ManagedList.initialize": {"callee_method_names": ["PluralMappingEx<?, ?, E>.loadCollection", "PluralMappingEx<?, ?, E>.sortList", "ManagedInstance<?>.getInstance"], "method_name": "ManagedList.initialize", "method_implementation": "{\n    if (!this.initialized) {\n        final ManagedInstance<?> managedInstance = this.getManagedInstance();\n        if (managedInstance == null) {\n            throw new PersistenceException(\"No session to initialize the collection\");\n        }\n        final PluralMappingEx<?, ?, E> mapping = this.getMapping();\n        BatooUtils.addAll(mapping.loadCollection(managedInstance), this.delegate);\n        this.initialized = true;\n        if (this.getMapping().getOrderBy() != null) {\n            mapping.sortList(managedInstance.getInstance());\n        }\n        this.initialized = true;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 918, "method_signature": "void initialize()"}, "ManagedList.isEmpty": {"callee_method_names": [], "method_name": "ManagedList.isEmpty", "method_implementation": "{\n    this.initialize();\n    return this.delegate.isEmpty();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 919, "method_signature": "boolean isEmpty()"}, "ManagedList.iterator": {"callee_method_names": [], "method_name": "ManagedList.iterator", "method_implementation": "{\n    this.initialize();\n    return new WrappedIterator<E>(this.delegate.iterator()) {\n\n        @Override\n        public void remove() {\n            ManagedList.this.snapshot();\n            ManagedList.this.changed();\n            super.remove();\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 920, "method_signature": "Iterator<E> iterator()"}, "ManagedList.lastIndexOf": {"callee_method_names": [], "method_name": "ManagedList.lastIndexOf", "method_implementation": "{\n    this.initialize();\n    return this.delegate.lastIndexOf(o);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 921, "method_signature": "int lastIndexOf(Object)"}, "ManagedList.listIterator": {"callee_method_names": [], "method_name": "ManagedList.listIterator", "method_implementation": "{\n    this.initialize();\n    return new ManagedListIterator(this.delegate.listIterator(index));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 923, "method_signature": "ListIterator<E> listIterator(int)"}, "ManagedList.refreshChildren": {"callee_method_names": [], "method_name": "ManagedList.refreshChildren", "method_implementation": "{\n    if (this.initialized) {\n        super.reset();\n        this.snapshot = null;\n        this.delegate.clear();\n        this.delegate.addAll(this.getMapping().loadCollection(this.getManagedInstance()));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 924, "method_signature": "void refreshChildren()"}, "ManagedList.remove": {"callee_method_names": [], "method_name": "ManagedList.remove", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.remove(o)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 926, "method_signature": "boolean remove(Object)"}, "ManagedList.removeAll": {"callee_method_names": [], "method_name": "ManagedList.removeAll", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.retainAll(c)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 927, "method_signature": "boolean removeAll(Collection)"}, "ManagedList.retainAll": {"callee_method_names": [], "method_name": "ManagedList.retainAll", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.retainAll(c)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 928, "method_signature": "boolean retainAll(Collection)"}, "ManagedList.set": {"callee_method_names": [], "method_name": "ManagedList.set", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.contains(element) && ObjectUtils.notEqual(element, this.delegate.get(index))) {\n        throw this.noDuplicates();\n    }\n    this.changed();\n    return this.delegate.set(index, element);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 929, "method_signature": "E set(int, E)"}, "ManagedList.size": {"callee_method_names": [], "method_name": "ManagedList.size", "method_implementation": "{\n    this.initialize();\n    return this.delegate.size();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 930, "method_signature": "int size()"}, "ManagedList.snapshot": {"callee_method_names": [], "method_name": "ManagedList.snapshot", "method_implementation": "{\n    this.initialize();\n    if ((this.getManagedInstance() != null) && (this.snapshot == null)) {\n        this.snapshot = Lists.newArrayList(this.delegate);\n        this.reset();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 931, "method_signature": "void snapshot()"}, "ManagedList.subList": {"callee_method_names": [], "method_name": "ManagedList.subList", "method_implementation": "{\n    this.initialize();\n    return this.delegate.subList(fromIndex, toIndex);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 932, "method_signature": "List<E> subList(int, int)"}, "ManagedList.toArray": {"callee_method_names": [], "method_name": "ManagedList.toArray", "method_implementation": "{\n    this.initialize();\n    return this.delegate.toArray(a);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 934, "method_signature": "T[] toArray(T[])"}, "ManagedList.toString": {"callee_method_names": [], "method_name": "ManagedList.toString", "method_implementation": "{\n    final String instance = this.getManagedInstance().getType().getName() + \"@\" + this.getManagedInstance().getId().getId();\n    return \"ManagedList [initialized=\" + this.initialized + \", managedInstance=\" + instance + \", delegate=\" + this.delegate + \", snapshot=\" + this.snapshot + \", mapping=\" + this.getMapping() + \"]\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 935, "method_signature": "String toString()"}, "ManagedListIterator.remove": {"callee_method_names": [], "method_name": "ManagedListIterator.remove", "method_implementation": "{\n    ManagedList.this.snapshot();\n    ManagedList.this.changed();\n    super.remove();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 936, "method_signature": "void remove()"}, "ManagedMap.addChild": {"callee_method_names": ["EntryImpl<Object,ManagedInstance<?>>.getKey", "EntryImpl<Object,ManagedInstance<?>>.getValue"], "method_name": "ManagedMap.addChild", "method_implementation": "{\n    final K k = (K) child.getKey();\n    final V v = (V) child.getValue().getInstance();\n    if (!this.delegate.keySet().contains(k) && !this.delegate.values().contains(v)) {\n        this.delegate.put(k, v);\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 883, "method_signature": "boolean addChild(EntryImpl)"}, "ManagedMap.addElement": {"callee_method_names": ["EntryImpl<Object,?>.getKey", "EntryImpl<Object,?>.getValue"], "method_name": "ManagedMap.addElement", "method_implementation": "{\n    final K k = (K) child.getKey();\n    final V v = (V) child.getValue();\n    if (!this.delegate.keySet().contains(k) && !this.delegate.values().contains(v)) {\n        this.delegate.put(k, v);\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 884, "method_signature": "boolean addElement(EntryImpl)"}, "ManagedMap.clear": {"callee_method_names": [], "method_name": "ManagedMap.clear", "method_implementation": "{\n    this.snapshot();\n    this.delegate.clear();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 885, "method_signature": "void clear()"}, "ManagedMap.containsKey": {"callee_method_names": [], "method_name": "ManagedMap.containsKey", "method_implementation": "{\n    this.initialize();\n    return this.delegate.containsKey(key);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 886, "method_signature": "boolean containsKey(Object)"}, "ManagedMap.containsValue": {"callee_method_names": [], "method_name": "ManagedMap.containsValue", "method_implementation": "{\n    this.initialize();\n    return this.delegate.containsValue(value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 887, "method_signature": "boolean containsValue(Object)"}, "ManagedMap.entrySet": {"callee_method_names": [], "method_name": "ManagedMap.entrySet", "method_implementation": "{\n    this.initialize();\n    return Collections.unmodifiableSet(this.delegate.entrySet());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 888, "method_signature": "Set<Entry<K,V>> entrySet()"}, "ManagedMap.flush": {"callee_method_names": ["Map<K, V>.keySet", "PluralMappingEx<?, ?, V>.detach", "Map<K, V>.keySet"], "method_name": "ManagedMap.flush", "method_implementation": "{\n    if (this.removed(connection, removals)) {\n        return;\n    }\n    final ManagedInstance<?> instance = this.getManagedInstance();\n    final PluralMappingEx<?, ?, V> mapping = this.getMapping();\n    // forced creation of relations for the new entities\n    if (force) {\n        this.attachChildren(connection, instance, mapping, this.delegate.keySet());\n        return;\n    }\n    if (this.snapshot == null) {\n        return;\n    }\n    if (removals) {\n        // delete the removals\n        final Map<K, V> childrenRemoved = BatooUtils.subtract(this.snapshot, this.delegate);\n        for (final K key : childrenRemoved.keySet()) {\n            mapping.detach(connection, instance, key, this.snapshot.get(key));\n        }\n    } else {\n        // create the additions\n        final Map<K, V> childrenAdded = BatooUtils.subtract(this.delegate, this.snapshot);\n        this.attachChildren(connection, instance, mapping, childrenAdded.keySet());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 889, "method_signature": "void flush(Connection, boolean, boolean)"}, "ManagedMap.get": {"callee_method_names": [], "method_name": "ManagedMap.get", "method_implementation": "{\n    this.initialize();\n    return this.delegate.get(key);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 890, "method_signature": "V get(Object)"}, "ManagedMap.initialize": {"callee_method_names": [], "method_name": "ManagedMap.initialize", "method_implementation": "{\n    if (!this.initialized) {\n        if (this.getManagedInstance() == null) {\n            throw new PersistenceException(\"No session to initialize the collection\");\n        }\n        this.delegate.putAll(this.getMapping().<K>loadMap(this.getManagedInstance()));\n        this.initialized = true;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 891, "method_signature": "void initialize()"}, "ManagedMap.isEmpty": {"callee_method_names": [], "method_name": "ManagedMap.isEmpty", "method_implementation": "{\n    this.initialize();\n    return this.delegate.isEmpty();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 892, "method_signature": "boolean isEmpty()"}, "ManagedMap.keySet": {"callee_method_names": [], "method_name": "ManagedMap.keySet", "method_implementation": "{\n    this.initialize();\n    return Collections.unmodifiableSet(this.delegate.keySet());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 893, "method_signature": "Set<K> keySet()"}, "ManagedMap.put": {"callee_method_names": [], "method_name": "ManagedMap.put", "method_implementation": "{\n    this.snapshot();\n    if ((key == null) || (value == null)) {\n        throw new NullPointerException();\n    }\n    if (this.delegate.values().contains(value)) {\n        throw this.noDuplicates();\n    }\n    if (this.delegate.values().contains(key)) {\n        throw this.noDuplicates();\n    }\n    final V v = this.delegate.put(key, value);\n    this.changed();\n    return v;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 894, "method_signature": "V put(K, V)"}, "ManagedMap.putAll": {"callee_method_names": ["Map<? extends K,? extends V>.entrySet", "Entry.getKey", "Entry.getValue"], "method_name": "ManagedMap.putAll", "method_implementation": "{\n    this.snapshot();\n    for (final java.util.Map.Entry<? extends K, ? extends V> entry : m.entrySet()) {\n        this.put(entry.getKey(), entry.getValue());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 895, "method_signature": "void putAll(Map)"}, "ManagedMap.refreshChildren": {"callee_method_names": [], "method_name": "ManagedMap.refreshChildren", "method_implementation": "{\n    if (this.initialized) {\n        super.reset();\n        this.snapshot = null;\n        this.delegate.clear();\n        this.delegate.putAll(this.getMapping().<K>loadMap(this.getManagedInstance()));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 896, "method_signature": "void refreshChildren()"}, "ManagedMap.remove": {"callee_method_names": [], "method_name": "ManagedMap.remove", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.containsKey(key)) {\n        this.changed();\n    }\n    return this.delegate.remove(key);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 897, "method_signature": "V remove(Object)"}, "ManagedMap.removeChild": {"callee_method_names": ["Entry.getValue", "Entry.getKey"], "method_name": "ManagedMap.removeChild", "method_implementation": "{\n    for (final Entry<K, V> entry : this.delegate.entrySet()) {\n        if (entry.getValue().equals(child)) {\n            this.delegate.remove(entry.getKey());\n            break;\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 898, "method_signature": "void removeChild(V)"}, "ManagedMap.size": {"callee_method_names": [], "method_name": "ManagedMap.size", "method_implementation": "{\n    this.initialize();\n    return this.delegate.size();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 899, "method_signature": "int size()"}, "ManagedMap.snapshot": {"callee_method_names": [], "method_name": "ManagedMap.snapshot", "method_implementation": "{\n    this.initialize();\n    if ((this.getManagedInstance() != null) && (this.snapshot == null)) {\n        this.snapshot = Maps.newHashMap(this.delegate);\n        this.reset();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 900, "method_signature": "void snapshot()"}, "ManagedMap.toString": {"callee_method_names": [], "method_name": "ManagedMap.toString", "method_implementation": "{\n    final String instance = this.getManagedInstance().getType().getName() + \"@\" + this.getManagedInstance().getId().getId();\n    return \"ManagedMap [initialized=\" + this.initialized + \", managedInstance=\" + instance + \", delegate=\" + this.delegate + \", snapshot=\" + this.snapshot + \", mapping=\" + this.getMapping() + \"]\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 901, "method_signature": "String toString()"}, "ManagedMap.values": {"callee_method_names": [], "method_name": "ManagedMap.values", "method_implementation": "{\n    this.initialize();\n    return Collections.unmodifiableCollection(this.delegate.values());\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 902, "method_signature": "Collection<V> values()"}, "ManagedSet.add": {"callee_method_names": [], "method_name": "ManagedSet.add", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.add(e)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 860, "method_signature": "boolean add(E)"}, "ManagedSet.addAll": {"callee_method_names": [], "method_name": "ManagedSet.addAll", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.addAll(c)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 861, "method_signature": "boolean addAll(Collection)"}, "ManagedSet.addChild": {"callee_method_names": ["EntryImpl<Object,ManagedInstance<?>>.getValue"], "method_name": "ManagedSet.addChild", "method_implementation": "{\n    final E e = (E) child.getValue().getInstance();\n    if (!this.delegate.contains(e)) {\n        return this.delegate.add(e);\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 862, "method_signature": "boolean addChild(EntryImpl)"}, "ManagedSet.addElement": {"callee_method_names": ["EntryImpl<Object,?>.getValue"], "method_name": "ManagedSet.addElement", "method_implementation": "{\n    final E e = (E) child.getValue();\n    if (!this.delegate.contains(e)) {\n        return this.delegate.add(e);\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 863, "method_signature": "boolean addElement(EntryImpl)"}, "ManagedSet.clear": {"callee_method_names": [], "method_name": "ManagedSet.clear", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.size() > 0) {\n        this.changed();\n    }\n    this.delegate.clear();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 864, "method_signature": "void clear()"}, "ManagedSet.contains": {"callee_method_names": [], "method_name": "ManagedSet.contains", "method_implementation": "{\n    this.initialize();\n    return this.delegate.contains(o);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 865, "method_signature": "boolean contains(Object)"}, "ManagedSet.containsAll": {"callee_method_names": [], "method_name": "ManagedSet.containsAll", "method_implementation": "{\n    this.initialize();\n    return this.delegate.containsAll(c);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 866, "method_signature": "boolean containsAll(Collection)"}, "ManagedSet.equals": {"callee_method_names": [], "method_name": "ManagedSet.equals", "method_implementation": "{\n    this.initialize();\n    return this.delegate.equals(obj);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 867, "method_signature": "boolean equals(Object)"}, "ManagedSet.flush": {"callee_method_names": ["List<E>.size", "PluralMappingEx<?, ?, E>.detach", "List<E>.get"], "method_name": "ManagedSet.flush", "method_implementation": "{\n    if (this.removed(connection, removals)) {\n        return;\n    }\n    final ManagedInstance<?> managedInstance = this.getManagedInstance();\n    final PluralMappingEx<?, ?, E> mapping = this.getMapping();\n    // forced creation of relations for the new entities\n    if (force) {\n        this.attachChildren(connection, managedInstance, mapping, this.delegate);\n        return;\n    }\n    if (this.snapshot == null) {\n        return;\n    }\n    if (removals) {\n        // delete the removals\n        final List<E> childrenRemoved = BatooUtils.subtract(this.snapshot, this.delegate);\n        for (int i = 0; i < childrenRemoved.size(); i++) {\n            mapping.detach(connection, managedInstance, null, childrenRemoved.get(i));\n        }\n    } else {\n        // create the additions\n        final Collection<E> childrenAdded = BatooUtils.subtract(this.delegate, this.snapshot);\n        this.attachChildren(connection, managedInstance, mapping, childrenAdded);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 868, "method_signature": "void flush(Connection, boolean, boolean)"}, "ManagedSet.hashCode": {"callee_method_names": [], "method_name": "ManagedSet.hashCode", "method_implementation": "{\n    this.initialize();\n    return this.delegate.hashCode();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 869, "method_signature": "int hashCode()"}, "ManagedSet.initialize": {"callee_method_names": [], "method_name": "ManagedSet.initialize", "method_implementation": "{\n    if (!this.initialized) {\n        if (this.getManagedInstance() == null) {\n            throw new PersistenceException(\"No session to initialize the collection\");\n        }\n        this.delegate.addAll(this.getMapping().loadCollection(this.getManagedInstance()));\n        this.initialized = true;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 870, "method_signature": "void initialize()"}, "ManagedSet.isEmpty": {"callee_method_names": [], "method_name": "ManagedSet.isEmpty", "method_implementation": "{\n    this.initialize();\n    return this.delegate.isEmpty();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 871, "method_signature": "boolean isEmpty()"}, "ManagedSet.iterator": {"callee_method_names": [], "method_name": "ManagedSet.iterator", "method_implementation": "{\n    this.initialize();\n    return new WrappedIterator<E>(this.delegate.iterator()) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void remove() {\n            ManagedSet.this.snapshot();\n            ManagedSet.this.changed();\n            super.remove();\n        }\n    };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 872, "method_signature": "Iterator<E> iterator()"}, "ManagedSet.refreshChildren": {"callee_method_names": [], "method_name": "ManagedSet.refreshChildren", "method_implementation": "{\n    if (this.initialized) {\n        this.reset();\n        this.snapshot = null;\n        this.delegate.clear();\n        this.delegate.addAll(this.getMapping().loadCollection(this.getManagedInstance()));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 874, "method_signature": "void refreshChildren()"}, "ManagedSet.remove": {"callee_method_names": [], "method_name": "ManagedSet.remove", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.remove(o)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 875, "method_signature": "boolean remove(Object)"}, "ManagedSet.removeAll": {"callee_method_names": [], "method_name": "ManagedSet.removeAll", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.removeAll(c)) {\n        this.changed();\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 876, "method_signature": "boolean removeAll(Collection)"}, "ManagedSet.retainAll": {"callee_method_names": [], "method_name": "ManagedSet.retainAll", "method_implementation": "{\n    this.snapshot();\n    if (this.delegate.retainAll(c)) {\n        this.changed();\n        return true;\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 877, "method_signature": "boolean retainAll(Collection)"}, "ManagedSet.size": {"callee_method_names": [], "method_name": "ManagedSet.size", "method_implementation": "{\n    this.initialize();\n    return this.delegate.size();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 878, "method_signature": "int size()"}, "ManagedSet.snapshot": {"callee_method_names": [], "method_name": "ManagedSet.snapshot", "method_implementation": "{\n    this.initialize();\n    if ((this.getManagedInstance() != null) && (this.snapshot == null)) {\n        this.snapshot = Sets.newHashSet(this.delegate);\n        this.reset();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 879, "method_signature": "void snapshot()"}, "ManagedSet.toArray": {"callee_method_names": [], "method_name": "ManagedSet.toArray", "method_implementation": "{\n    this.initialize();\n    return this.delegate.toArray(a);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 881, "method_signature": "T[] toArray(T[])"}, "ManagedSet.toString": {"callee_method_names": [], "method_name": "ManagedSet.toString", "method_implementation": "{\n    final String instance = this.getManagedInstance().getType().getName() + \"@\" + this.getManagedInstance().getId().getId();\n    return \"ManagedSet [initialized=\" + this.initialized + \", managedInstance=\" + instance + \", delegate=\" + this.delegate + \", snapshot=\" + this.snapshot + \", mapping=\" + this.getMapping() + \"]\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 882, "method_signature": "String toString()"}, "ManagedTypeImpl.addAttribute": {"callee_method_names": ["AttributeImpl<? super X,?>.getDeclaringType", "AttributeImpl<? super X,?>.getName", "AttributeImpl<? super X,?>.getName", "AttributeImpl<? super X,?>.getDeclaringType", "AttributeImpl<? super X,?>.getName", "AttributeImpl<? super X,?>.getName", "AttributeImpl<? super X,?>.getDeclaringType", "AttributeImpl<? super X,?>.getName", "AttributeImpl<? super X,?>.getName"], "method_name": "ManagedTypeImpl.addAttribute", "method_implementation": "{\n    if (attribute.getDeclaringType() == this) {\n        this.declaredAttributes.put(attribute.getName(), (AttributeImpl<X, ?>) attribute);\n    }\n    this.attributes.put(attribute.getName(), attribute);\n    if (attribute instanceof SingularAttribute) {\n        if (attribute.getDeclaringType() == this) {\n            this.declaredSingularAttributes.put(attribute.getName(), (SingularAttributeImpl<X, ?>) attribute);\n        }\n        this.singularAttributes.put(attribute.getName(), (SingularAttributeImpl<X, ?>) attribute);\n    } else {\n        if (attribute.getDeclaringType() == this) {\n            this.declaredPluralAttributes.put(attribute.getName(), (PluralAttributeImpl<X, ?, ?>) attribute);\n        }\n        this.pluralAttributes.put(attribute.getName(), (PluralAttributeImpl<? super X, ?, ?>) attribute);\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the attribute into attributes.\n *\n * @param attribute\n *            the declared attribute\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 201, "method_signature": "void addAttribute(AttributeImpl)"}, "ManagedTypeImpl.addAttributes": {"callee_method_names": ["ManagedTypeMetadata.getAttributes", "AttributesMetadata.getBasics", "AttributesMetadata.getElementCollections", "AttributesMetadata.getManyToOnes", "AttributesMetadata.getOneToOnes", "AttributesMetadata.getOneToManies", "AttributesMetadata.getManyToManies", "AttributesMetadata.getEmbeddeds"], "method_name": "ManagedTypeImpl.addAttributes", "method_implementation": "{\n    final AttributesMetadata attributesMetadata = typeMetadata.getAttributes();\n    // basic attributes\n    for (final BasicAttributeMetadata metadata : attributesMetadata.getBasics()) {\n        this.addAttribute(new BasicAttribute(this, metadata));\n    }\n    // element collection attributes\n    for (final ElementCollectionAttributeMetadata metadata : attributesMetadata.getElementCollections()) {\n        this.addAttribute(PluralAttributeImpl.create(this, metadata, PersistentAttributeType.ELEMENT_COLLECTION));\n    }\n    // many to one attributes\n    for (final ManyToOneAttributeMetadata metadata : attributesMetadata.getManyToOnes()) {\n        this.addAttribute(new AssociatedSingularAttribute(this, PersistentAttributeType.MANY_TO_ONE, metadata));\n    }\n    // one to one attributes\n    for (final OneToOneAttributeMetadata metadata : attributesMetadata.getOneToOnes()) {\n        this.addAttribute(new AssociatedSingularAttribute(this, PersistentAttributeType.ONE_TO_ONE, metadata));\n    }\n    // one to many attributes\n    for (final OneToManyAttributeMetadata metadata : attributesMetadata.getOneToManies()) {\n        this.addAttribute(PluralAttributeImpl.create(this, metadata, PersistentAttributeType.ONE_TO_MANY));\n    }\n    // many to many attributes\n    for (final ManyToManyAttributeMetadata metadata : attributesMetadata.getManyToManies()) {\n        this.addAttribute(PluralAttributeImpl.create(this, metadata, PersistentAttributeType.MANY_TO_MANY));\n    }\n    // embedded attributes\n    for (final EmbeddedAttributeMetadata metadata : attributesMetadata.getEmbeddeds()) {\n        this.addAttribute(new EmbeddedAttribute(this, metadata));\n    }\n}", "repo_id": "1", "comment": "/**\n * Creates and adds the attributes of the managed type from the metadata.\n *\n * @param typeMetadata\n *            the metadata\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 202, "method_signature": "void addAttributes(ManagedTypeMetadata)"}, "ManagedTypeImpl.getAttributes": {"callee_method_names": ["Set<Attribute<? super X, ?>>.addAll"], "method_name": "ManagedTypeImpl.getAttributes", "method_implementation": "{\n    final Set<Attribute<? super X, ?>> attributes = Sets.newHashSet();\n    attributes.addAll(this.attributes.values());\n    return attributes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 203, "method_signature": "Set<Attribute<? super X,?>> getAttributes()"}, "ManagedTypeImpl.getCollection": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getCollection", "method_implementation": "{\n    return (CollectionAttributeImpl<? super X, E>) this.getAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 205, "method_signature": "CollectionAttributeImpl<? super X,E> getCollection(String, Class)"}, "ManagedTypeImpl.getDeclaredAttributes": {"callee_method_names": ["Set<Attribute<X, ?>>.addAll"], "method_name": "ManagedTypeImpl.getDeclaredAttributes", "method_implementation": "{\n    final Set<Attribute<X, ?>> attributes = Sets.newHashSet();\n    attributes.addAll(this.declaredAttributes.values());\n    return attributes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 206, "method_signature": "Set<Attribute<X,?>> getDeclaredAttributes()"}, "ManagedTypeImpl.getDeclaredCollection": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getDeclaredCollection", "method_implementation": "{\n    return (CollectionAttributeImpl<X, E>) this.getDeclaredAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 208, "method_signature": "CollectionAttributeImpl<X,E> getDeclaredCollection(String, Class)"}, "ManagedTypeImpl.getDeclaredList": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getDeclaredList", "method_implementation": "{\n    return (ListAttributeImpl<X, E>) this.getDeclaredAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 210, "method_signature": "ListAttributeImpl<X,E> getDeclaredList(String, Class)"}, "ManagedTypeImpl.getDeclaredMap": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getDeclaredMap", "method_implementation": "{\n    return (MapAttribute<X, K, V>) this.getDeclaredAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 212, "method_signature": "MapAttribute<X,K,V> getDeclaredMap(String, Class, Class)"}, "ManagedTypeImpl.getDeclaredPluralAttributes": {"callee_method_names": ["Set<PluralAttribute<X, ?, ?>>.addAll"], "method_name": "ManagedTypeImpl.getDeclaredPluralAttributes", "method_implementation": "{\n    final Set<PluralAttribute<X, ?, ?>> attributes = Sets.newHashSet();\n    attributes.addAll(this.declaredPluralAttributes.values());\n    return attributes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 213, "method_signature": "Set<PluralAttribute<X,?,?>> getDeclaredPluralAttributes()"}, "ManagedTypeImpl.getDeclaredSet": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getDeclaredSet", "method_implementation": "{\n    return (SetAttributeImpl<X, E>) this.getDeclaredAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 215, "method_signature": "SetAttributeImpl<X,E> getDeclaredSet(String, Class)"}, "ManagedTypeImpl.getDeclaredSingularAttribute": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getDeclaredSingularAttribute", "method_implementation": "{\n    return (SingularAttributeImpl<X, Y>) this.getDeclaredAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 216, "method_signature": "SingularAttributeImpl<X,Y> getDeclaredSingularAttribute(String, Class)"}, "ManagedTypeImpl.getDeclaredSingularAttributes": {"callee_method_names": ["Set<SingularAttribute<X, ?>>.addAll"], "method_name": "ManagedTypeImpl.getDeclaredSingularAttributes", "method_implementation": "{\n    final Set<SingularAttribute<X, ?>> attributes = Sets.newHashSet();\n    attributes.addAll(this.declaredSingularAttributes.values());\n    return attributes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 217, "method_signature": "Set<SingularAttribute<X,?>> getDeclaredSingularAttributes()"}, "ManagedTypeImpl.getList": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getList", "method_implementation": "{\n    return (ListAttributeImpl<? super X, E>) this.getAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 219, "method_signature": "ListAttributeImpl<? super X,E> getList(String, Class)"}, "ManagedTypeImpl.getMap": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getMap", "method_implementation": "{\n    return (MapAttribute<? super X, K, V>) this.getMap(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 221, "method_signature": "MapAttribute<? super X,K,V> getMap(String, Class, Class)"}, "ManagedTypeImpl.getPluralAttributes": {"callee_method_names": ["Set<PluralAttribute<? super X, ?, ?>>.addAll"], "method_name": "ManagedTypeImpl.getPluralAttributes", "method_implementation": "{\n    final Set<PluralAttribute<? super X, ?, ?>> attributes = Sets.newHashSet();\n    attributes.addAll(this.pluralAttributes.values());\n    return attributes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 222, "method_signature": "Set<PluralAttribute<? super X,?,?>> getPluralAttributes()"}, "ManagedTypeImpl.getSet": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getSet", "method_implementation": "{\n    return (SetAttributeImpl<? super X, E>) this.getAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 224, "method_signature": "SetAttributeImpl<? super X,E> getSet(String, Class)"}, "ManagedTypeImpl.getSingularAttribute": {"callee_method_names": [], "method_name": "ManagedTypeImpl.getSingularAttribute", "method_implementation": "{\n    return (SingularAttributeImpl<? super X, Y>) this.getAttribute(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 225, "method_signature": "SingularAttributeImpl<? super X,Y> getSingularAttribute(String, Class)"}, "ManagedTypeImpl.getSingularAttributes": {"callee_method_names": ["Set<SingularAttribute<? super X, ?>>.addAll"], "method_name": "ManagedTypeImpl.getSingularAttributes", "method_implementation": "{\n    final Set<SingularAttribute<? super X, ?>> attributes = Sets.newHashSet();\n    attributes.addAll(this.singularAttributes.values());\n    return attributes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 226, "method_signature": "Set<SingularAttribute<? super X,?>> getSingularAttributes()"}, "ManagedTypeMetadatImpl.getAccessType": {"callee_method_names": ["ManagedTypeMetadata.getAccessType", "ManagedTypeMetadata.getAccessType", "Access.value", "Access.value"], "method_name": "ManagedTypeMetadatImpl.getAccessType", "method_implementation": "{\n    if ((metadata != null) && (metadata.getAccessType() != null)) {\n        return metadata.getAccessType();\n    }\n    final Access access = this.clazz.getAnnotation(Access.class);\n    if ((access != null) && (access.value() != null)) {\n        return access.value();\n    }\n    return this.inferAccessType(parentAccessType);\n}", "repo_id": "1", "comment": "/**\n * Returns the access type.\n * <p>\n * if metadata exists and it specifies the access type then it is returned.\n * <p>\n * then is class has {@link Access} annotation then it is returned.\n * <p>\n * finally default {@link AccessType#FIELD} is returned.\n *\n * @param metadata\n *            the metadata\n * @param parentAccessType\n *            the parent access type\n * @return the access type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 988, "method_signature": "AccessType getAccessType(ManagedTypeMetadata, AccessType)"}, "ManagedTypeMetadatImpl.inferAccessType": {"callee_method_names": ["Map<? extends K,? extends V>.getModifiers", "Map<? extends K,? extends V>.isBridge", "Map<? extends K,? extends V>.isSynthetic", "Map<? extends K,? extends V>.getParameterTypes", "Map<? extends K,? extends V>.getReturnType", "Map<? extends K,? extends V>.getAnnotation", "Map<? extends K,? extends V>.getName", "Map<? extends K,? extends V>.getReturnType", "String.startsWith", "List<String>.add", "String.substring", "String.startsWith", "List<String>.add", "String.substring", "FastLinkedListNode<E>.getAnnotation", "List<String>.add", "FastLinkedListNode<E>.getName", "Map<? extends K,? extends V>.getAnnotations", "Map<? extends K,? extends V>.getReturnType", "Map<? extends K,? extends V>.getParameterTypes", "T[].annotationType", "String.startsWith", "String.startsWith", "String.startsWith", "String.startsWith", "Map<? extends K,? extends V>.getName", "Map<? extends K,? extends V>.getReturnType", "String.startsWith", "String.substring", "String.startsWith", "String.substring", "List<String>.contains", "FastLinkedListNode<E>.getAnnotations", "T[].annotationType", "String.startsWith", "String.startsWith", "List<String>.contains", "FastLinkedListNode<E>.getName"], "method_name": "ManagedTypeMetadatImpl.inferAccessType", "method_implementation": "{\n    boolean methodsHasAnnotations = false;\n    boolean fieldsHasAnnotations = false;\n    final List<String> alternated = Lists.newArrayList();\n    final Field[] fields = this.clazz.getDeclaredFields();\n    final Method[] methods = this.clazz.getDeclaredMethods();\n    // find the alternated ones with @Access\n    for (final Method m : methods) {\n        // skip static and private methods.\n        final int mods = m.getModifiers();\n        if (Modifier.isStatic(mods) || !Modifier.isPublic(mods) || m.isBridge() || m.isSynthetic()) {\n            continue;\n        }\n        if ((m.getParameterTypes().length != 0) || (m.getReturnType() == null)) {\n            continue;\n        }\n        final Access access = m.getAnnotation(Access.class);\n        if (access != null) {\n            final String name = m.getName();\n            if ((m.getReturnType() == boolean.class) && name.startsWith(\"is\")) {\n                alternated.add(StringUtils.capitalize(name.substring(2)));\n            } else if (name.startsWith(\"get\")) {\n                alternated.add(StringUtils.capitalize(name.substring(3)));\n            }\n        }\n    }\n    for (final Field f : fields) {\n        final Access access = f.getAnnotation(Access.class);\n        if (access != null) {\n            alternated.add(StringUtils.capitalize(f.getName()));\n        }\n    }\n    // check methods\n    for (final Method m : methods) {\n        for (final Annotation a : m.getAnnotations()) {\n            // ignore @Access(PROPERTY)\n            if (a instanceof Access) {\n                if (((Access) a).value() != AccessType.PROPERTY) {\n                    continue;\n                }\n            }\n            // ignore @Transient\n            if (a instanceof Transient) {\n                continue;\n            }\n            if ((m.getReturnType() == null) || (m.getParameterTypes().length > 0)) {\n                continue;\n            }\n            String name = a.annotationType().getName();\n            // ignore the listener annotations\n            if (name.startsWith(\"javax.persistence.Post\") || name.startsWith(\"javax.persistence.Pre\")) {\n                continue;\n            }\n            if (name.startsWith(\"javax.persistence\") || name.startsWith(\"org.batoo.jpa.annotation\")) {\n                name = m.getName();\n                if ((boolean.class == m.getReturnType()) || name.startsWith(\"is\")) {\n                    name = name.substring(2);\n                } else if (name.startsWith(\"get\")) {\n                    name = name.substring(3);\n                }\n                if (alternated.contains(StringUtils.capitalize(name))) {\n                    continue;\n                }\n                methodsHasAnnotations = true;\n                break;\n            }\n        }\n    }\n    // check fields\n    for (final Field f : fields) {\n        for (final Annotation a : f.getAnnotations()) {\n            // ignore @Access(FIELD)\n            if (a instanceof Access) {\n                if (((Access) a).value() != AccessType.FIELD) {\n                    continue;\n                }\n            }\n            // ignore @Transient\n            if (a instanceof Transient) {\n                continue;\n            }\n            final String name = a.annotationType().getName();\n            if (name.startsWith(\"javax.persistence\") || name.startsWith(\"org.batoo.jpa.annotation\")) {\n                if (alternated.contains(StringUtils.capitalize(f.getName()))) {\n                    continue;\n                }\n                fieldsHasAnnotations = true;\n                break;\n            }\n        }\n    }\n    if (fieldsHasAnnotations && methodsHasAnnotations) {\n        throw new PersistenceException(\"At least one field and one method has persistence annotations: \" + this.clazz.getName());\n    }\n    if (methodsHasAnnotations) {\n        return AccessType.PROPERTY;\n    }\n    if (fieldsHasAnnotations) {\n        return AccessType.FIELD;\n    }\n    if (parentAccessType != null) {\n        return parentAccessType;\n    }\n    return AccessType.FIELD;\n}", "repo_id": "1", "comment": "/**\n * Infers and returns the access type based on all persistence annotations being on fields or methods and parent parent access type.\n *\n * @param parentAccessType\n *            the parent access type\n * @return the inferred access type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 989, "method_signature": "AccessType inferAccessType(AccessType)"}, "ManualIdTest.testIdentiy": {"callee_method_names": ["Foo.setKey", "Foo.setValue", "Foo.setKey", "Foo.setValue", "Foo.getKey", "Foo.getKey", "Foo.getKey"], "method_name": "ManualIdTest.testIdentiy", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.setKey(1);\n    foo.setValue(\"Foo2\");\n    final Foo foo2 = new Foo();\n    foo2.setKey(2);\n    foo2.setValue(\"Foo2\");\n    this.persist(foo);\n    this.persist(foo2);\n    this.commit();\n    this.close();\n    final Foo foo3 = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo3.getKey());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with identity value\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2148, "method_signature": "void testIdentiy()"}, "ManyToManyAttributeElement.generate": {"callee_method_names": [], "method_name": "ManyToManyAttributeElement.generate", "method_implementation": "{\n    super.generate();\n    this.mappedBy = this.getAttribute(ElementConstants.ATTR_MAPPED_BY, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1111, "method_signature": "void generate()"}, "ManyToManyAttributeElement.handleChild": {"callee_method_names": [], "method_name": "ManyToManyAttributeElement.handleChild", "method_implementation": "{\n    super.handleChild(child);\n    if (child instanceof PrimaryKeyJoinColumnElement) {\n        this.primaryKeyJoinColumns.add((PrimaryKeyJoinColumnMetadata) child);\n    }\n    if (child instanceof MapKeyElement) {\n        this.mapKey = ((MapKeyElement) child).getName();\n    }\n    if (child instanceof MapKeyAttributeOverrideElement) {\n        this.mapKeyAttributeOverrides.add((AttributeOverrideElement) child);\n    }\n    if (child instanceof MapKeyClassElement) {\n        this.mapKeyClassName = ((MapKeyClassElement) child).getClazz();\n    }\n    if (child instanceof MapKeyColumnElement) {\n        this.mapKeyColumn = (ColumnMetadata) child;\n    }\n    if (child instanceof MapKeyEnumeratedElement) {\n        this.mapKeyEnumType = ((MapKeyEnumeratedElement) child).getEnumType();\n    }\n    if (child instanceof MapKeyTemporalElement) {\n        this.mapKeyTemporalType = ((MapKeyTemporalElement) child).getTemporalType();\n    }\n    if (child instanceof OrderByElement) {\n        this.orderBy = ((OrderByElement) child).getOrderBy();\n    }\n    if (child instanceof OrderColumnElement) {\n        this.orderColumn = ((OrderColumnElement) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1112, "method_signature": "void handleChild(Element)"}, "ManyToManyTest.testPersist": {"callee_method_names": ["Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getId", "Customer.getId", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers"], "method_name": "ManyToManyTest.testPersist", "method_implementation": "{\n    final Customer customer1 = new Customer(\"Ceylan\");\n    final Customer customer2 = new Customer(\"Ceylanson\");\n    final PhoneNumber number1 = new PhoneNumber(\"111 111-1111\");\n    final PhoneNumber number2 = new PhoneNumber(\"222 222-2222\");\n    customer1.getPhoneNumbers().add(number1);\n    customer1.getPhoneNumbers().add(number2);\n    customer2.getPhoneNumbers().add(number1);\n    customer2.getPhoneNumbers().add(number2);\n    this.persist(customer1);\n    this.persist(customer2);\n    this.commit();\n    this.close();\n    final Customer customer1_2 = this.find(Customer.class, customer1.getId());\n    final Customer customer2_2 = this.find(Customer.class, customer2.getId());\n    Assert.assertTrue(customer2_2.getPhoneNumbers().size() == 2);\n    Assert.assertTrue(customer2_2.getPhoneNumbers().size() == 2);\n    Assert.assertEquals(customer1_2.getPhoneNumbers(), customer2_2.getPhoneNumbers());\n}", "repo_id": "1", "comment": "/**\n * Tests to persist {@link ManyToMany} relations.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2286, "method_signature": "void testPersist()"}, "ManyToManyToManyTest.testPersist": {"callee_method_names": ["Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getId", "Customer.getId", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers"], "method_name": "ManyToManyToManyTest.testPersist", "method_implementation": "{\n    final Customer customer1 = new Customer(\"Ceylan\");\n    final Customer customer2 = new Customer(\"Ceylanson\");\n    final PhoneNumber number1 = new PhoneNumber(\"111 111-1111\");\n    final PhoneNumber number2 = new PhoneNumber(\"222 222-2222\");\n    customer1.getPhoneNumbers().add(number1);\n    customer1.getPhoneNumbers().add(number2);\n    customer2.getPhoneNumbers().add(number1);\n    customer2.getPhoneNumbers().add(number2);\n    this.persist(customer1);\n    this.persist(customer2);\n    this.commit();\n    this.close();\n    final Customer customer1_2 = this.find(Customer.class, customer1.getId());\n    final Customer customer2_2 = this.find(Customer.class, customer2.getId());\n    Assert.assertEquals(2, customer2_2.getPhoneNumbers().size());\n    Assert.assertEquals(2, customer2_2.getPhoneNumbers().size());\n    Assert.assertEquals(customer1_2.getPhoneNumbers(), customer2_2.getPhoneNumbers());\n}", "repo_id": "1", "comment": "/**\n * Tests to persist {@link ManyToMany} relations.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2248, "method_signature": "void testPersist()"}, "ManyToManyToManyTest.testPersistInverse": {"callee_method_names": ["Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "Customer.getPhoneNumbers", "PhoneNumber.getCustomers"], "method_name": "ManyToManyToManyTest.testPersistInverse", "method_implementation": "{\n    final Customer customer1 = new Customer(\"Ceylan\");\n    final Customer customer2 = new Customer(\"Ceylanson\");\n    final PhoneNumber number1 = new PhoneNumber(\"111 111-1111\");\n    final PhoneNumber number2 = new PhoneNumber(\"222 222-2222\");\n    customer1.getPhoneNumbers().add(number1);\n    customer1.getPhoneNumbers().add(number2);\n    customer2.getPhoneNumbers().add(number1);\n    customer2.getPhoneNumbers().add(number2);\n    this.persist(customer1);\n    this.persist(customer2);\n    this.commit();\n    this.close();\n    final PhoneNumber phoneNumber = this.find(PhoneNumber.class, 2);\n    Assert.assertTrue(phoneNumber.getCustomers().size() == 2);\n}", "repo_id": "1", "comment": "/**\n * Tests to persist {@link ManyToMany} relations and find with inverse.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2249, "method_signature": "void testPersistInverse()"}, "ManyToOneAttributeElement.generate": {"callee_method_names": [], "method_name": "ManyToOneAttributeElement.generate", "method_implementation": "{\n    super.generate();\n    this.optional = this.getAttribute(ElementConstants.ATTR_OPTIONAL, Boolean.TRUE);\n    this.mapsId = this.getAttribute(ElementConstants.ATTR_MAPS_ID);\n    this.id = this.getAttribute(ElementConstants.ATTR_ID, Boolean.FALSE);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1104, "method_signature": "void generate()"}, "ManyToOneTest.testCascade": {"callee_method_ids": [2454, 2454], "callee_method_names": ["Person.getId", "Address.setId", "Person.setWorkAddress", "Person.getId", "Person.getHomeAddress", "Person.getWorkAddress"], "method_name": "ManyToOneTest.testCascade", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    this.begin();\n    final Person person2 = this.find(Person.class, person.getId());\n    final Address a2 = new Address(\"ankara\");\n    a2.setId(2);\n    person2.setWorkAddress(a2);\n    this.persist(person2);\n    this.commit();\n    this.close();\n    final Person person3 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getHomeAddress().getCity(), person3.getWorkAddress().getCity());\n}", "repo_id": "1", "comment": "/**\n * tests for cascade operation PERSIST\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2189, "method_signature": "void testCascade()"}, "ManyToOneTest.testCascade2": {"callee_method_ids": [2460, 2454], "callee_method_names": ["Address.setId", "Address.getId", "Person.setWorkAddress", "Person.getId", "Address.getCity", "Person.getWorkAddress"], "method_name": "ManyToOneTest.testCascade2", "method_implementation": "{\n    final Address address = new Address(\"Istanbul\");\n    this.persist(address);\n    this.commit();\n    this.close();\n    final Person person = new Person(\"Ceylan\");\n    final Address address2 = new Address(\"Ankara\");\n    address2.setId(address.getId());\n    person.setWorkAddress(address2);\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(address.getCity(), person2.getWorkAddress().getCity());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2190, "method_signature": "void testCascade2()"}, "ManyToOneTest.testFind": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName"], "method_name": "ManyToOneTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2191, "method_signature": "void testFind()"}, "ManyToOneTest.testFindInSession": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "ManyToOneTest.testFindInSession", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.flush();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2192, "method_signature": "void testFindInSession()"}, "ManyToOneTest.testJoinColumn": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName"], "method_name": "ManyToOneTest.testJoinColumn", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2193, "method_signature": "void testJoinColumn()"}, "ManyToOneTest.testJoinColumnName": {"callee_method_names": [], "method_name": "ManyToOneTest.testJoinColumnName", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    Assert.assertNotNull(new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT address_id FROM Person\", new SingleValueHandler<Number>()));\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} Parent which cascades to Child1.\n *\n * @throws SQLException\n *             ins case of an underlying SQL Exception\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2194, "method_signature": "void testJoinColumnName()"}, "ManyToOneToManyTest.testFind": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses"], "method_name": "ManyToOneToManyTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2175, "method_signature": "void testFind()"}, "ManyToOneToManyTest.testFind2": {"callee_method_ids": [2455], "callee_method_names": ["Person.getPhones", "Phone.getPerson", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses"], "method_name": "ManyToOneToManyTest.testFind2", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Phone phone = this.find(Phone.class, person.getPhones().get(0).getId());\n    final Person person2 = phone.getPerson();\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2176, "method_signature": "void testFind2()"}, "ManyToOneToManyTest.testFind3": {"callee_method_names": ["Person.getAddresses", "Address.getPerson", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses"], "method_name": "ManyToOneToManyTest.testFind3", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Address address = this.find(Address.class, person.getAddresses().get(0).getId());\n    final Person person2 = address.getPerson();\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2177, "method_signature": "void testFind3()"}, "ManyToOneToManyTest.testFindInSession": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "ManyToOneToManyTest.testFindInSession", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2178, "method_signature": "void testFindInSession()"}, "ManyToOneToManyTest.testPersistAddress": {"callee_method_names": [], "method_name": "ManyToOneToManyTest.testPersistAddress", "method_implementation": "{\n    this.persist(this.person().getAddresses().get(0));\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} address which does not cascade to Parent. PersistenceException expected.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2179, "method_signature": "void testPersistAddress()"}, "ManyToOneToManyTest.testPersistPerson": {"callee_method_names": [], "method_name": "ManyToOneToManyTest.testPersistPerson", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Person\", new SingleValueHandler<Number>()).intValue());\n    Assert.assertEquals(3, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Address\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} Parent which cascades to Child1.\n *\n * @throws SQLException\n *             ins case of an underlying SQL Exception\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2180, "method_signature": "void testPersistPerson()"}, "MapAttributeImpl.getKeyType": {"callee_method_ids": [299, 299, 297], "callee_method_names": ["MetamodelImpl.embeddable", "MetamodelImpl.embeddable", "MetamodelImpl.createBasicType"], "method_name": "MapAttributeImpl.getKeyType", "method_implementation": "{\n    if (this.keyType != null) {\n        return this.keyType;\n    }\n    final MetamodelImpl metamodel = this.getDeclaringType().getMetamodel();\n    return this.keyType = metamodel.embeddable(this.keyJavaType) != null ? metamodel.embeddable(this.keyJavaType) : metamodel.createBasicType(this.keyJavaType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 285, "method_signature": "Type<K> getKeyType()"}, "MapAttributeImpl.newCollection": {"callee_method_names": [], "method_name": "MapAttributeImpl.newCollection", "method_implementation": "{\n    return new ManagedMap<X, K, V>(mapping, managedInstance, (Map<? extends K, ? extends V>) values);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 286, "method_signature": "Map<K,V> newCollection(PluralMappingEx, ManagedInstance, Object)"}, "MapEntryExpression.handle": {"callee_method_names": [], "method_name": "MapEntryExpression.handle", "method_implementation": "{\n    return (EntryImpl<K, V>) this.mapJoin.handle(session, row, MapSelectType.ENTRY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 657, "method_signature": "EntryImpl<K,V> handle(QueryImpl, SessionImpl, ResultSet)"}, "MapExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "MapExpression.generateJpqlRestriction", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 629, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "MapExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "MapExpression.generateJpqlSelect", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 630, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "MapExpression.generateSqlSelect": {"callee_method_names": [], "method_name": "MapExpression.generateSqlSelect", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 631, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "MapExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "MapExpression.getSqlRestrictionFragments", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 632, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "MapExpression.handle": {"callee_method_names": [], "method_name": "MapExpression.handle", "method_implementation": "{\n    // TODO Auto-generated method stub\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 633, "method_signature": "M handle(QueryImpl, SessionImpl, ResultSet)"}, "MapJoinImpl.entry": {"callee_method_names": [], "method_name": "MapJoinImpl.entry", "method_implementation": "{\n    return new MapEntryExpression(this, Entry.class);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 800, "method_signature": "Expression<Entry<K,V>> entry()"}, "MapJoinImpl.generateSqlSelect": {"callee_method_names": [], "method_name": "MapJoinImpl.generateSqlSelect", "method_implementation": "{\n    this.select(selected);\n    return this.getFetchRoot().generateSqlSelect(query, selected, this.getParentPath() == null, selectType);\n}", "repo_id": "1", "comment": "/**\n * Returns the SQL select fragment.\n *\n * @param query\n *            the query\n * @param selected\n *            id the join is selected\n * @param selectType\n *            the select type\n * @return the SQL select fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 801, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean, MapSelectType)"}, "MapJoinImpl.getModel": {"callee_method_names": [], "method_name": "MapJoinImpl.getModel", "method_implementation": "{\n    return (MapAttributeImpl<? super Z, K, V>) this.getAttribute();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 802, "method_signature": "MapAttributeImpl<? super Z,K,V> getModel()"}, "MapJoinImpl.handle": {"callee_method_names": ["EntryImpl<Object, V>.getKey", "EntryImpl<Object, V>.getValue", "EntryImpl<Object, V>.getKey", "EntryImpl<Object, V>.getValue", "EntryImpl<Object, V>.getKey", "EntryImpl<Object, V>.getValue"], "method_name": "MapJoinImpl.handle", "method_implementation": "{\n    if (this.getEntity() != null) {\n        final EntryImpl<Object, ManagedInstance<?>> result = this.getFetchRoot().handle(session, row, selectType);\n        switch(selectType) {\n            case KEY:\n                return result.getKey();\n            case VALUE:\n                return result.getValue().getInstance();\n            default:\n                return new Pair<K, V>((K) result.getKey(), (V) result.getValue().getInstance());\n        }\n    }\n    final EntryImpl<Object, V> result = this.getFetchRoot().handleElementFetch(row, selectType);\n    switch(selectType) {\n        case KEY:\n            return result.getKey();\n        case VALUE:\n            return result.getValue();\n        default:\n            return result;\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the row.\n *\n * @param session\n *            the session\n * @param row\n *            the row\n * @param selectType\n *            the map select type\n * @return the managed instance\n * @throws SQLException\n *             thrown in case of an underlying SQL Error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 804, "method_signature": "Object handle(SessionImpl, ResultSet, MapSelectType)"}, "MapKeyClassElement.generate": {"callee_method_names": [], "method_name": "MapKeyClassElement.generate", "method_implementation": "{\n    super.generate();\n    this.clazz = this.getAttribute(ElementConstants.ATTR_CLASS);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1082, "method_signature": "void generate()"}, "MapKeyPath.generateJpqlSelect": {"callee_method_names": [], "method_name": "MapKeyPath.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 781, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "MapKeyPath.getMapping": {"callee_method_names": [], "method_name": "MapKeyPath.getMapping", "method_implementation": "{\n    if (this.mapJoin.getModel().getKeyType() instanceof EmbeddableTypeImpl) {\n        final AbstractMapping<? super X, ?, ?> child = this.elementMappingImpl.getChild(name);\n        if (child != null) {\n            return (AbstractMapping<? super X, C, Y>) child;\n        }\n    }\n    throw this.cannotDereference(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 782, "method_signature": "AbstractMapping<? super X,C,Y> getMapping(String)"}, "MapKeyPath.getModel": {"callee_method_names": [], "method_name": "MapKeyPath.getModel", "method_implementation": "{\n    return (MapAttributeImpl<?, ?, X>) this.mapJoin.getModel();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 783, "method_signature": "MapAttributeImpl<?,?,X> getModel()"}, "MapKeyPath.handle": {"callee_method_names": [], "method_name": "MapKeyPath.handle", "method_implementation": "{\n    final X value = (X) this.mapJoin.handle(session, row, MapSelectType.KEY);\n    return (X) (this.getConverter() != null ? this.getConverter().convert(value) : value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 784, "method_signature": "X handle(QueryImpl, SessionImpl, ResultSet)"}, "MapTest.testMap": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses1", "Person.getAddresses1", "Person.getAddresses1"], "method_name": "MapTest.testMap", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses1().size(), person2.getAddresses1().size());\n    Assert.assertEquals(new Integer(1), person.getAddresses1().get(1).getId());\n}", "repo_id": "1", "comment": "/**\n * Tests Maps with id attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2129, "method_signature": "void testMap()"}, "MapTest.testMap2": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses1", "Person.getAddresses1", "Person.getAddresses2"], "method_name": "MapTest.testMap2", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses1().size(), person2.getAddresses1().size());\n    Assert.assertEquals(\"Istanbul\", person.getAddresses2().get(\"Istanbul\").getCity());\n}", "repo_id": "1", "comment": "/**\n * Tests Maps with attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2130, "method_signature": "void testMap2()"}, "MapTest.testMap3": {"callee_method_ids": [2454, 2455, 2455, 2455], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getPhones", "Person.getPhones", "Person.getPhones"], "method_name": "MapTest.testMap3", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getPhones().size(), person2.getPhones().size());\n    Assert.assertEquals(\"111-1111\", person.getPhones().get(new PhoneId(\"111\", \"111-1111\")).getPhoneNumber());\n}", "repo_id": "1", "comment": "/**\n * Tests Maps with attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2131, "method_signature": "void testMap3()"}, "MapTest.testMap4": {"callee_method_ids": [2454, 2455, 2454, 2455, 2455, 2455], "callee_method_names": ["Person.getId", "Person.getPhones", "Person.getId", "Person.getName", "Person.getName", "Person.getPhones", "Person.getPhones", "Person.getPhones"], "method_name": "MapTest.testMap4", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    Person person2 = this.find(Person.class, person.getId());\n    this.begin();\n    person2.getPhones().remove(new PhoneId(\"111\", \"111-1111\"));\n    this.commit();\n    person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getPhones().size() - 1, person2.getPhones().size());\n    Assert.assertEquals(\"222-2222\", person.getPhones().get(new PhoneId(\"222\", \"222-2222\")).getPhoneNumber());\n}", "repo_id": "1", "comment": "/**\n * Tests Maps with attributes.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2132, "method_signature": "void testMap4()"}, "MapTest.testMap5": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses2", "Person.getAddresses2"], "method_name": "MapTest.testMap5", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(3, person2.getAddresses2().size());\n    Assert.assertEquals(\"Istanbul\", person2.getAddresses2().get(\"Istanbul\").getCity());\n}", "repo_id": "1", "comment": "/**\n * Tests Maps with attributes.\n *\n * TODO https://github.com/BatooOrg/BatooJPA/issues/110\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2133, "method_signature": "void testMap5()"}, "MapTest.testMapQuery": {"callee_method_names": ["Query.getSingleResult", "Person.getName", "Person.getName", "Person.getAddresses1", "Person.getAddresses1", "Person.getAddresses1"], "method_name": "MapTest.testMapQuery", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Query cq = this.cq(\"select p from Person p\");\n    final Person person2 = (Person) cq.getSingleResult();\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses1().size(), person2.getAddresses1().size());\n    Assert.assertEquals(new Integer(1), person.getAddresses1().get(1).getId());\n}", "repo_id": "1", "comment": "/**\n * Tests Maps with query.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2134, "method_signature": "void testMapQuery()"}, "MappedSuperClassTest.newFoo": {"callee_method_names": ["Foo.setFooValue", "Foo.setBarValue", "Quux.setFoo", "Quux.setQuuxValue", "Foo.getFooQuuxes", "Quux.setFoo", "Quux.setQuuxValue", "Foo.getFooQuuxes", "Quux.setFoo", "Quux.setQuuxValue", "Foo.getQuuxes", "Quux.setFoo", "Quux.setQuuxValue", "Foo.getQuuxes"], "method_name": "MappedSuperClassTest.newFoo", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.setFooValue(\"FooValue\");\n    foo.setBarValue(\"BarValue\");\n    Quux quux;\n    quux = new Quux();\n    quux.setFoo(foo);\n    quux.setQuuxValue(1);\n    foo.getFooQuuxes().add(quux);\n    quux = new Quux();\n    quux.setFoo(foo);\n    quux.setQuuxValue(2);\n    foo.getFooQuuxes().add(quux);\n    quux = new Quux();\n    quux.setFoo(foo);\n    quux.setQuuxValue(3);\n    foo.getQuuxes().add(quux);\n    quux = new Quux();\n    quux.setFoo(foo);\n    quux.setQuuxValue(4);\n    foo.getQuuxes().add(quux);\n    return foo;\n}", "repo_id": "1", "comment": "/**\n * @return new Foo\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2445, "method_signature": "Foo newFoo()"}, "MappedSuperClassTest.testContains": {"callee_method_names": [], "method_name": "MappedSuperClassTest.testContains", "method_implementation": "{\n    final Foo Foo = this.newFoo();\n    final Foo Foo2 = this.newFoo();\n    this.persist(Foo);\n    Assert.assertTrue(this.contains(Foo));\n    Assert.assertFalse(this.contains(Foo2));\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#contains(Object)}.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2446, "method_signature": "void testContains()"}, "MappedSuperClassTest.testCreateTable": {"callee_method_names": ["Set<EntityType<?>>.size"], "method_name": "MappedSuperClassTest.testCreateTable", "method_implementation": "{\n    final Set<EntityType<?>> entities = this.em().getMetamodel().getEntities();\n    Assert.assertEquals(2, entities.size());\n    final DataSource dataSource = this.em().unwrap(DataSource.class);\n    new QueryRunner(dataSource).query(\"SELECT * FROM Foo\", new NullResultSetHandler());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManagerFactory#createEntityManager()}\n *\n * @throws SQLException\n *             thrown if test fails.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2447, "method_signature": "void testCreateTable()"}, "MappedSuperClassTest.testDetach": {"callee_method_names": [], "method_name": "MappedSuperClassTest.testDetach", "method_implementation": "{\n    final Foo Foo = this.newFoo();\n    this.persist(Foo);\n    Assert.assertTrue(this.em().contains(Foo));\n    this.detach(Foo);\n    Assert.assertFalse(this.em().contains(Foo));\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#detach(Object)}.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2448, "method_signature": "void testDetach()"}, "MappedSuperClassTest.testDetachThenCommit": {"callee_method_names": [], "method_name": "MappedSuperClassTest.testDetachThenCommit", "method_implementation": "{\n    final Foo Foo = this.newFoo();\n    this.persist(Foo);\n    this.detach(Foo);\n    this.commit();\n    Assert.assertEquals(0, (Number) new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#detach(Object)} then {@link EntityTransaction#commit()}.\n *\n * @throws SQLException\n *             thrown if test fails.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2449, "method_signature": "void testDetachThenCommit()"}, "MappedSuperClassTest.testFind": {"callee_method_names": ["Foo.getKey", "Foo.getKey", "Foo.getKey"], "method_name": "MappedSuperClassTest.testFind", "method_implementation": "{\n    final Foo Foo = this.newFoo();\n    this.persist(Foo);\n    this.commit();\n    this.close();\n    final Foo Foo2 = this.find(Foo.class, Foo.getKey());\n    Assert.assertEquals(Foo.getKey(), Foo2.getKey());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2450, "method_signature": "void testFind()"}, "MappedSuperClassTest.testFlushThenDetach": {"callee_method_names": [], "method_name": "MappedSuperClassTest.testFlushThenDetach", "method_implementation": "{\n    final Foo foo = this.newFoo();\n    this.persist(foo);\n    this.flush();\n    this.detach(foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#flush()} then {@link EntityManager#detach(Object)}\n *\n * @throws SQLException\n *             thrown if test fails.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2451, "method_signature": "void testFlushThenDetach()"}, "MappedSuperClassTest.testPersist": {"callee_method_names": [], "method_name": "MappedSuperClassTest.testPersist", "method_implementation": "{\n    final Foo Foo = this.newFoo();\n    this.persist(Foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if test fails.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2452, "method_signature": "void testPersist()"}, "MappedSuperclassElementFactory.generate": {"callee_method_names": [], "method_name": "MappedSuperclassElementFactory.generate", "method_implementation": "{\n    this.className = this.getAttribute(ElementConstants.ATTR_CLASS, ElementConstants.EMPTY);\n    this.metadataComplete = this.getAttribute(ElementConstants.ATTR_METADATA_COMPLETE, false);\n    this.accessType = this.getAttribute(ElementConstants.ATTR_ACCESS) != null ? AccessType.valueOf(this.getAttribute(ElementConstants.ATTR_ACCESS)) : null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1067, "method_signature": "void generate()"}, "MappedSuperclassElementFactory.handleChild": {"callee_method_names": [], "method_name": "MappedSuperclassElementFactory.handleChild", "method_implementation": "{\n    if (child instanceof AttributesElement) {\n        this.attrs = (AttributesElement) child;\n    }\n    if (child instanceof IdClassElement) {\n        this.idClass = ((IdClassElement) child).getIdClass();\n    }\n    if (child instanceof EntityListenersElement) {\n        this.listeners.addAll(((EntityListenersElement) child).getListeners());\n    }\n    if (child instanceof CallbackMetadata) {\n        this.callbacks.add((CallbackMetadata) this.callbacks);\n    }\n    if (child instanceof ExcludeDefaultListenersElement) {\n        this.excludeDefaultListeners = true;\n    }\n    if (child instanceof ExcludeSuperclassListenersElement) {\n        this.excludeSuperclassListeners = true;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1068, "method_signature": "void handleChild(Element)"}, "MapsIdTest.testFind": {"callee_method_ids": [2454, 2455, 2455], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getPhones", "Person.getPhones"], "method_name": "MapsIdTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getPhones().size(), person2.getPhones().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2292, "method_signature": "void testFind()"}, "MapsIdTest.testFindInSession": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "MapsIdTest.testFindInSession", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2293, "method_signature": "void testFindInSession()"}, "MapsIdTest.testRemove": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "MapsIdTest.testRemove", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    this.begin();\n    person = this.find(Person.class, person.getId());\n    this.remove(person);\n    this.commit();\n    this.close();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2294, "method_signature": "void testRemove()"}, "MemberOfExpression.getSqlRestrictionFragments": {"callee_method_ids": [513], "callee_method_names": ["BaseQueryImpl<?>.getMetamodel", "BaseQueryImpl<?>.subquery", "SubqueryImpl<Object>.from", "Joinable.getEntity", "Root<?>.join", "PluralAttributeImpl<?, C, E>.getName", "PluralAttributeImpl<?, C, E>.getElementType", "PluralAttributeImpl<?, C, E>.getElementType", "EntityTypeImpl<E>.getIdMapping", "SubqueryImpl<Object>.select", "AbstractPluralJoin<?, C, E>.get", "SubqueryImpl<Object>.select", "SubqueryImpl<Object>.where", "CriteriaBuilderImpl.equal", "SubqueryImpl<Object>.getSqlRestrictionFragments"], "method_name": "MemberOfExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final CriteriaBuilderImpl cb = query.getMetamodel().getEntityManagerFactory().getCriteriaBuilder();\n    final Joinable rp = this.values.getParentPath().getRootPath();\n    final SubqueryImpl<Object> s = query.subquery(Object.class);\n    final Root<?> r = s.from(rp.getEntity());\n    final PluralAttributeImpl<?, C, E> attribute = (PluralAttributeImpl<?, C, E>) this.values.getMapping().getAttribute();\n    final AbstractPluralJoin<?, C, E> j = (AbstractPluralJoin<?, C, E>) r.join(attribute.getName());\n    if (attribute.getElementType() instanceof EntityTypeImpl) {\n        final EntityTypeImpl<E> entity = (EntityTypeImpl<E>) attribute.getElementType();\n        final String idName = entity.getIdMapping().getAttribute().getName();\n        s.select(j.get(idName));\n    } else {\n        s.select((Expression<Object>) j);\n    }\n    s.where(cb.equal(r, (AbstractExpression<?>) rp));\n    return new String[] { this.value.getSqlRestrictionFragments(query)[0] + \" IN \" + s.getSqlRestrictionFragments(query)[0] };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 546, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "MergeTest.createFoo": {"callee_method_names": [], "method_name": "MergeTest.createFoo", "method_implementation": "{\n    final Foo1 foo1 = new Foo1(baseId, MergeTest.VALUE);\n    new Foo2(baseId + 1, MergeTest.VALUE, foo1);\n    return foo1;\n}", "repo_id": "1", "comment": "/**\n * Returns a newly created foo.\n *\n * @param baseId\n * @return\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2159, "method_signature": "Foo1 createFoo(int)"}, "MergeTest.createParent": {"callee_method_names": [], "method_name": "MergeTest.createParent", "method_implementation": "{\n    final Parent parent = new Parent(baseId, MergeTest.VALUE);\n    new Child1(baseId + 1, parent, MergeTest.VALUE);\n    new Child1(baseId + 2, parent, MergeTest.VALUE);\n    new Child2(baseId + 3, parent, MergeTest.VALUE);\n    new Child2(baseId + 4, parent, MergeTest.VALUE);\n    new Child3(baseId + 5, parent, MergeTest.VALUE);\n    new Child3(baseId + 6, parent, MergeTest.VALUE);\n    new Child4(baseId + 7, parent, MergeTest.VALUE);\n    new Child4(baseId + 8, parent, MergeTest.VALUE);\n    return parent;\n}", "repo_id": "1", "comment": "/**\n * Returns a newly created parent.\n *\n * @param baseId\n *            the base id\n * @return\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2160, "method_signature": "Parent createParent(int)"}, "MergeTest.getCounts1": {"callee_method_names": [], "method_name": "MergeTest.getCounts1", "method_implementation": "{\n    final int[] counts = new int[2];\n    try {\n        for (int i = 0; i < 2; i++) {\n            counts[i] = //\n            new QueryRunner(this.em().unwrap(DataSource.class)).//\n            query(//\n            \"SELECT COUNT(*) FROM Foo\" + (i + 1), new SingleValueHandler<Number>()).intValue();\n        }\n        MergeTest.LOG.debug(\"Foos are: {0}, {1}\", counts[0], counts[1]);\n    } catch (final SQLException e) {\n        throw new RuntimeException(e);\n    }\n    return counts;\n}", "repo_id": "1", "comment": "/**\n * Returns the counts\n *\n * @return counts\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2161, "method_signature": "int[] getCounts1()"}, "MergeTest.getCounts2": {"callee_method_names": [], "method_name": "MergeTest.getCounts2", "method_implementation": "{\n    final int[] counts = new int[4];\n    try {\n        for (int i = 0; i < 4; i++) {\n            counts[i] = //\n            new QueryRunner(this.em().unwrap(DataSource.class)).//\n            query(//\n            \"SELECT COUNT(*) FROM Child\" + (i + 1), new SingleValueHandler<Number>()).intValue();\n        }\n        MergeTest.LOG.debug(\"Remaining children are: {0}, {1}, {2}, {3}\", counts[0], counts[1], counts[2], counts[3]);\n    } catch (final SQLException e) {\n        throw new RuntimeException(e);\n    }\n    return counts;\n}", "repo_id": "1", "comment": "/**\n * Returns the counts\n *\n * @return counts\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2162, "method_signature": "int[] getCounts2()"}, "MergeTest.testMerge": {"callee_method_names": [], "method_name": "MergeTest.testMerge", "method_implementation": "{\n    this.merge(this.createParent(Integer.MIN_VALUE));\n    this.commit();\n    Assert.assertTrue(Arrays.equals(new int[] { 2, 2, 2, 2 }, this.getCounts2()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2163, "method_signature": "void testMerge()"}, "MergeTest.testMergeOneToOne": {"callee_method_names": [], "method_name": "MergeTest.testMergeOneToOne", "method_implementation": "{\n    this.merge(this.createFoo(Integer.MIN_VALUE));\n    this.commit();\n    Assert.assertTrue(Arrays.equals(new int[] { 1, 1 }, this.getCounts1()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2164, "method_signature": "void testMergeOneToOne()"}, "MergeTest.testMergeOneToOne1": {"callee_method_names": [], "method_name": "MergeTest.testMergeOneToOne1", "method_implementation": "{\n    final Foo1 foo = this.createFoo(1);\n    this.persist(foo);\n    this.commit();\n    this.merge(foo);\n    this.commit();\n    Assert.assertTrue(Arrays.equals(new int[] { 1, 1 }, this.getCounts1()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2165, "method_signature": "void testMergeOneToOne1()"}, "MergeTest.testMergeOneToOne2": {"callee_method_ids": [2158], "callee_method_names": ["Foo1.setFoo2"], "method_name": "MergeTest.testMergeOneToOne2", "method_implementation": "{\n    Foo1 foo = this.createFoo(1);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    foo = this.createFoo(1);\n    foo.setFoo2(null);\n    this.merge(foo);\n    this.commit();\n    Assert.assertTrue(Arrays.equals(new int[] { 1, 0 }, this.getCounts1()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2166, "method_signature": "void testMergeOneToOne2()"}, "MergeTest.testMergeOneToOne3": {"callee_method_names": ["Foo2.getFoo1"], "method_name": "MergeTest.testMergeOneToOne3", "method_implementation": "{\n    final Foo1 foo = this.createFoo(1);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    Foo2 foo2 = new Foo2(2, MergeTest.VALUE + \"2\", null);\n    this.merge(foo2);\n    this.commit();\n    this.close();\n    foo2 = this.find(Foo2.class, 2);\n    Assert.assertNull(foo2.getFoo1());\n    Assert.assertTrue(Arrays.equals(new int[] { 1, 1 }, this.getCounts1()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2167, "method_signature": "void testMergeOneToOne3()"}, "MergeTest.testMergeOneToOne4": {"callee_method_names": ["Foo1.getFoo2"], "method_name": "MergeTest.testMergeOneToOne4", "method_implementation": "{\n    Foo1 foo = this.createFoo(1);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    foo = new Foo1(1, MergeTest.VALUE + \"2\");\n    this.merge(foo);\n    this.commit();\n    this.close();\n    foo = this.find(Foo1.class, 1);\n    Assert.assertNull(foo.getFoo2());\n    Assert.assertTrue(Arrays.equals(new int[] { 1, 0 }, this.getCounts1()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2168, "method_signature": "void testMergeOneToOne4()"}, "MergeTest.testPersistDifferentMerge1": {"callee_method_names": ["Parent.getChildren1"], "method_name": "MergeTest.testPersistDifferentMerge1", "method_implementation": "{\n    this.persist(this.createParent(1));\n    this.commit();\n    Parent parent = this.createParent(1);\n    parent.getChildren1().clear();\n    parent = this.merge(parent);\n    this.commit();\n    Assert.assertEquals(Arrays.toString(new int[] { 0, 2, 2, 2 }), Arrays.toString(this.getCounts2()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2169, "method_signature": "void testPersistDifferentMerge1()"}, "MergeTest.testPersistDifferentMerge2": {"callee_method_names": ["Parent.getChildren2", "Parent.getChildren2", "Child2.getId", "Child2.setParent", "Child2.getParent"], "method_name": "MergeTest.testPersistDifferentMerge2", "method_implementation": "{\n    this.persist(this.createParent(1));\n    this.commit();\n    Parent parent = this.createParent(1);\n    Child2 child = parent.getChildren2().get(0);\n    parent.getChildren2().clear();\n    child = this.merge(child);\n    parent = this.merge(parent);\n    this.commit();\n    this.close();\n    child = this.find(Child2.class, child.getId());\n    child.setParent(null);\n    Assert.assertNull(child.getParent());\n    Assert.assertTrue(Arrays.equals(new int[] { 2, 2, 2, 2 }, this.getCounts2()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2170, "method_signature": "void testPersistDifferentMerge2()"}, "MergeTest.testPersistDifferentMerge3": {"callee_method_names": ["Parent.getChildren3", "Parent.getChildren3", "Child3.getId"], "method_name": "MergeTest.testPersistDifferentMerge3", "method_implementation": "{\n    this.persist(this.createParent(1));\n    this.commit();\n    Parent parent = this.createParent(1);\n    Child3 child = parent.getChildren3().get(0);\n    parent.getChildren3().clear();\n    parent = this.merge(parent);\n    this.commit();\n    this.close();\n    child = this.find(Child3.class, child.getId());\n    Assert.assertNotNull(child);\n    Assert.assertTrue(Arrays.equals(new int[] { 2, 2, 2, 2 }, this.getCounts2()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2171, "method_signature": "void testPersistDifferentMerge3()"}, "MergeTest.testPersistDifferentMerge4": {"callee_method_names": ["Parent.getChildren4"], "method_name": "MergeTest.testPersistDifferentMerge4", "method_implementation": "{\n    this.persist(this.createParent(1));\n    this.commit();\n    Parent parent = this.createParent(1);\n    parent.getChildren4().clear();\n    parent = this.merge(parent);\n    this.commit();\n    this.close();\n    Assert.assertTrue(Arrays.equals(new int[] { 2, 2, 2, 0 }, this.getCounts2()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2172, "method_signature": "void testPersistDifferentMerge4()"}, "MergeTest.testPersistMerge": {"callee_method_names": [], "method_name": "MergeTest.testPersistMerge", "method_implementation": "{\n    this.persist(this.createParent(1));\n    this.commit();\n    Parent parent = this.createParent(1);\n    parent = this.merge(parent);\n    Assert.assertTrue(Arrays.equals(new int[] { 2, 2, 2, 2 }, this.getCounts2()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2173, "method_signature": "void testPersistMerge()"}, "MergeTest.testPersistOneToOne": {"callee_method_names": [], "method_name": "MergeTest.testPersistOneToOne", "method_implementation": "{\n    this.persist(this.createFoo(Integer.MIN_VALUE));\n    this.merge(this.createFoo(Integer.MIN_VALUE));\n    this.commit();\n    Assert.assertTrue(Arrays.equals(new int[] { 2, 2 }, this.getCounts1()));\n}", "repo_id": "1", "comment": "/**\n * Tests the simple merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2174, "method_signature": "void testPersistOneToOne()"}, "MetadataImpl.checkParentClasses": {"callee_method_names": ["ClassLoader.loadClass", "Class<?>.getSuperclass", "Class<?>.getAnnotation", "Class<?>.getAnnotation", "ArrayList<String>.contains", "Class<?>.getName", "ArrayList<String>.add", "Class<?>.getName"], "method_name": "MetadataImpl.checkParentClasses", "method_implementation": "{\n    final ArrayList<String> managedClasses = Lists.newArrayList(entities);\n    for (final String className : entities) {\n        try {\n            Class<?> clazz = classloader.loadClass(className);\n            while (true) {\n                clazz = clazz.getSuperclass();\n                if ((clazz.getAnnotation(Entity.class) != null) || (clazz.getAnnotation(MappedSuperclass.class) != null)) {\n                    if (!managedClasses.contains(clazz.getName())) {\n                        managedClasses.add(clazz.getName());\n                    }\n                } else {\n                    break;\n                }\n            }\n        } catch (final ClassNotFoundException e) {\n            throw new PersistenceException(\"Cannot load persistence class \" + className + \" referenced by orm mapping files\");\n        }\n    }\n    return managedClasses;\n}", "repo_id": "1", "comment": "/**\n * Walks up the hierarchy to add the mapped super classes.\n *\n * @param classloader\n * @param entities\n * @return\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 984, "method_signature": "ArrayList<String> checkParentClasses(ClassLoader, Set)"}, "MetadataImpl.merge": {"callee_method_names": ["Metadata.getAccessType", "Metadata.getCatalog", "Metadata.getSchema", "Metadata.isXmlMappingMetadataComplete", "Metadata.cascadePersists", "Metadata.getSequenceGenerators", "Metadata.getTableGenerators", "Metadata.getEntityListeners", "Metadata.getNamedQueries", "Metadata.getNamedNativeQueries", "Metadata.getSqlResultSetMapping", "Metadata.getEntityMappings", "ManagedTypeImpl<X>.getClassName", "ManagedTypeImpl<X>.getClassName", "ManagedTypeImpl<X>.getLocator", "ManagedTypeMetadata.getLocator"], "method_name": "MetadataImpl.merge", "method_implementation": "{\n    this.accessType = metadata.getAccessType();\n    this.catalog = metadata.getCatalog();\n    this.schema = metadata.getSchema();\n    this.xmlMappingMetadataComplete = metadata.isXmlMappingMetadataComplete();\n    this.cascadePersist = metadata.cascadePersists();\n    this.sequenceGenerators.addAll(metadata.getSequenceGenerators());\n    this.tableGenerators.addAll(metadata.getTableGenerators());\n    this.entityListeners.addAll(metadata.getEntityListeners());\n    this.namedQueries.addAll(metadata.getNamedQueries());\n    this.namedNativeQueries.addAll(metadata.getNamedNativeQueries());\n    this.sqlResultSetMappings.addAll(metadata.getSqlResultSetMapping());\n    for (final ManagedTypeMetadata managedType : metadata.getEntityMappings()) {\n        final ManagedTypeMetadata existing = this.entityMap.put(managedType.getClassName(), managedType);\n        if (existing != null) {\n            throw new MappingException(\"Duplicate definitions for \" + managedType.getClassName(), managedType.getLocator(), existing.getLocator());\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Merges the ORM XML based metadata.\n *\n * @param metadata\n *            the metadata to merge\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 985, "method_signature": "void merge(Metadata)"}, "MetadataImpl.parse": {"callee_method_names": ["PersistenceUnitInfo.getClassLoader", "Class<?>.getName", "Class<?>.getSimpleName", "Class<?>.getName"], "method_name": "MetadataImpl.parse", "method_implementation": "{\n    final ClassLoader classloader = puInfo.getClassLoader();\n    final Set<Class<?>> classes = BaseAnnotatedClassLocator.locatePersistentClasses(puInfo);\n    for (final Class<?> clazz : classes) {\n        if (!this.entityMap.containsKey(clazz.getName()) && !this.entityMap.containsKey(clazz.getSimpleName())) {\n            this.entityMap.put(clazz.getName(), null);\n        }\n    }\n    this.parse(classloader);\n}", "repo_id": "1", "comment": "/**\n * Parses the types in the metamodel and in the jar files.\n *\n * @param puInfo\n *            the persistence unit info\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 987, "method_signature": "void parse(PersistenceUnitInfo)"}, "MetamodelImpl.addNamedNativeQueries": {"callee_method_names": [], "method_name": "MetamodelImpl.addNamedNativeQueries", "method_implementation": "{\n    for (final NamedNativeQueryMetadata namedNativeQuery : namedNativeQueries) {\n        if (this.namedQueries.containsKey(namedNativeQuery.getName()) || this.namedNativeQueries.containsKey(namedNativeQuery.getName())) {\n            throw new MappingException(\"Duplicate named native query with the name: \" + namedNativeQuery.getName(), namedNativeQuery.getLocator());\n        }\n        this.namedNativeQueries.put(namedNativeQuery.getName(), namedNativeQuery);\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the named native queries to the metamodel\n *\n * @param namedNativeQueries\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 291, "method_signature": "void addNamedNativeQueries(List)"}, "MetamodelImpl.addNamedQueries": {"callee_method_names": ["NamedQueryMetadata.getName", "NamedQueryMetadata.getName", "NamedQueryMetadata.getName", "NamedQueryMetadata.getLocator", "NamedQueryMetadata.getName"], "method_name": "MetamodelImpl.addNamedQueries", "method_implementation": "{\n    for (final NamedQueryMetadata namedQuery : namedQueries) {\n        if (this.namedQueries.containsKey(namedQuery.getName()) || this.namedNativeQueries.containsKey(namedQuery.getName())) {\n            throw new MappingException(\"Duplicate named query with the name: \" + namedQuery.getName(), namedQuery.getLocator());\n        }\n        this.namedQueries.put(namedQuery.getName(), namedQuery);\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the named queries to the metamodel.\n *\n * @param namedQueries\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 292, "method_signature": "void addNamedQueries(List)"}, "MetamodelImpl.addSequenceGenerators": {"callee_method_names": [], "method_name": "MetamodelImpl.addSequenceGenerators", "method_implementation": "{\n    for (final SequenceGeneratorMetadata sequenceGeneratorMetadata : sequenceGeneratorMetadatas) {\n        this.addSequenceGenerator(sequenceGeneratorMetadata);\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the sequence generators to the metamodel\n *\n * @param sequenceGeneratorMetadatas\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 293, "method_signature": "void addSequenceGenerators(List)"}, "MetamodelImpl.addSqlResultSetMappings": {"callee_method_names": ["SqlResultSetMappingMetadata.getLocator"], "method_name": "MetamodelImpl.addSqlResultSetMappings", "method_implementation": "{\n    for (final SqlResultSetMappingMetadata sqlResultSetMappingMetadata : sqlResultSetMappings) {\n        final SqlResultSetMappingMetadata existing = this.sqlResultSetMappings.put(sqlResultSetMappingMetadata.getName(), sqlResultSetMappingMetadata);\n        if (existing != null) {\n            throw new MappingException(\"Duplicate sqlResultSetMapping with the name: \" + sqlResultSetMappingMetadata.getName(), existing.getLocator(), sqlResultSetMappingMetadata.getLocator());\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * @param sqlResultSetMappings\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 294, "method_signature": "void addSqlResultSetMappings(List)"}, "MetamodelImpl.addTableGenerators": {"callee_method_names": [], "method_name": "MetamodelImpl.addTableGenerators", "method_implementation": "{\n    for (final TableGeneratorMetadata tableGeneratorMetadata : metadatas) {\n        this.addTableGenerator(tableGeneratorMetadata);\n    }\n}", "repo_id": "1", "comment": "/**\n * Adds the table generators to the metamodel\n *\n * @param metadatas\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 295, "method_signature": "void addTableGenerators(List)"}, "MetamodelImpl.checkTables": {"callee_method_names": ["Map<String, AbstractTable>.put", "EntityTable.getName", "Map<String, AbstractTable>.put", "EntityTable.getName"], "method_name": "MetamodelImpl.checkTables", "method_implementation": "{\n    final Map<String, AbstractTable> entityTableNames = Maps.newHashMap();\n    final Map<String, AbstractTable> joinTableNames = Maps.newHashMap();\n    for (final AbstractTable table : this.getAllTables()) {\n        final AbstractTable existing;\n        if (table instanceof EntityTable) {\n            existing = entityTableNames.put(table.getName(), table);\n        } else {\n            existing = joinTableNames.put(table.getName(), table);\n        }\n        if (existing != null) {\n            throw new MappingException(\"Duplicate table names \" + this.getTableDesc(existing) + \", \" + this.getTableDesc(table));\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Check that the tables have unique names.\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 296, "method_signature": "void checkTables()"}, "MetamodelImpl.createBasicType": {"callee_method_names": [], "method_name": "MetamodelImpl.createBasicType", "method_implementation": "{\n    final BasicTypeImpl<T> basicType = (BasicTypeImpl<T>) this.basics.get(clazz);\n    if (basicType != null) {\n        return basicType;\n    }\n    return this.lazyCreateBasicType(clazz);\n}", "repo_id": "1", "comment": "/**\n * Creates of returns an existing {@link BasicTypeImpl} of <code>clazz</code>\n *\n * @param clazz\n *            the class\n * @return the basic type\n *\n * @param <T>\n *            the java type of the basic type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 297, "method_signature": "BasicTypeImpl<T> createBasicType(Class)"}, "MetamodelImpl.dropAllTables": {"callee_method_names": [], "method_name": "MetamodelImpl.dropAllTables", "method_implementation": "{\n    final Set<AbstractTable> tableSet = this.getAllTables();\n    try {\n        this.jdbcAdaptor.dropAllForeignKeys(datasource, tableSet);\n        this.jdbcAdaptor.dropAllTables(datasource, tableSet);\n        this.jdbcAdaptor.dropAllSequences(datasource, this.sequenceGenerators.values());\n    } catch (final SQLException e) {\n        throw new PersistenceException(\"Cannot drop tables\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Drops all the tables in the database.\n *\n * @param datasource\n *            the datasource\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 298, "method_signature": "void dropAllTables(DataSource)"}, "MetamodelImpl.embeddable": {"callee_method_names": [], "method_name": "MetamodelImpl.embeddable", "method_implementation": "{\n    return (EmbeddableTypeImpl<X>) this.embeddables.get(clazz);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 299, "method_signature": "EmbeddableTypeImpl<X> embeddable(Class)"}, "MetamodelImpl.entity": {"callee_method_names": [], "method_name": "MetamodelImpl.entity", "method_implementation": "{\n    return (EntityTypeImpl<X>) this.entities.get(clazz);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 300, "method_signature": "EntityTypeImpl<X> entity(Class)"}, "MetamodelImpl.getEmbeddables": {"callee_method_names": ["Set<EmbeddableType<?>>.addAll"], "method_name": "MetamodelImpl.getEmbeddables", "method_implementation": "{\n    final Set<EmbeddableType<?>> set = Sets.newHashSet();\n    set.addAll(this.embeddables.values());\n    return set;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 301, "method_signature": "Set<EmbeddableType<?>> getEmbeddables()"}, "MetamodelImpl.getEntities": {"callee_method_names": ["Set<EntityType<?>>.add"], "method_name": "MetamodelImpl.getEntities", "method_implementation": "{\n    final Set<EntityType<?>> entities = Sets.newHashSet();\n    for (final EntityType<?> entity : this.entities.values()) {\n        entities.add(entity);\n    }\n    return entities;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 302, "method_signature": "Set<EntityType<?>> getEntities()"}, "MetamodelImpl.getEntity": {"callee_method_names": ["Class<?>.getSuperclass"], "method_name": "MetamodelImpl.getEntity", "method_implementation": "{\n    EntityTypeImpl<?> entity = null;\n    while ((entity == null) && (clazz != Object.class)) {\n        entity = this.entity(clazz);\n        if (entity != null) {\n            break;\n        }\n        clazz = clazz.getSuperclass();\n    }\n    return entity;\n}", "repo_id": "1", "comment": "/**\n * Returns the entity that corresponds to clazz's parant chain.\n *\n * @param clazz\n *            the class\n * @return the entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 303, "method_signature": "EntityTypeImpl<?> getEntity(Class)"}, "MetamodelImpl.getIdentifiables": {"callee_method_names": ["Set<IdentifiableType<?>>.addAll", "Set<IdentifiableType<?>>.addAll"], "method_name": "MetamodelImpl.getIdentifiables", "method_implementation": "{\n    final Set<IdentifiableType<?>> identifiables = Sets.newHashSet();\n    identifiables.addAll(this.mappedSuperclasses.values());\n    identifiables.addAll(this.entities.values());\n    return identifiables;\n}", "repo_id": "1", "comment": "/**\n * Returns the identifiable types.\n *\n * @return the identifiable types\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 304, "method_signature": "Set<IdentifiableType<?>> getIdentifiables()"}, "MetamodelImpl.getManagedTypes": {"callee_method_names": ["Set<ManagedType<?>>.addAll", "Set<ManagedType<?>>.addAll", "Set<ManagedType<?>>.addAll"], "method_name": "MetamodelImpl.getManagedTypes", "method_implementation": "{\n    final Set<ManagedType<?>> managedTypes = Sets.newHashSet();\n    managedTypes.addAll(this.embeddables.values());\n    managedTypes.addAll(this.mappedSuperclasses.values());\n    managedTypes.addAll(this.entities.values());\n    return managedTypes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 305, "method_signature": "Set<ManagedType<?>> getManagedTypes()"}, "MetamodelImpl.getNextSequence": {"callee_method_names": [], "method_name": "MetamodelImpl.getNextSequence", "method_implementation": "{\n    try {\n        return this.sequenceQueues.get(generator).poll(MetamodelImpl.POLL_TIMEOUT, TimeUnit.SECONDS);\n    } catch (final InterruptedException e) {\n        throw new PersistenceException(\"Unable to retrieve next sequence \" + generator + \" in allowed \" + MetamodelImpl.POLL_TIMEOUT + \" seconds\");\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the next sequence for the generator.\n *\n * @param generator\n *            the generator\n * @return the next sequence for the generator\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 306, "method_signature": "Long getNextSequence(String)"}, "MetamodelImpl.getNextTableValue": {"callee_method_names": [], "method_name": "MetamodelImpl.getNextTableValue", "method_implementation": "{\n    try {\n        return this.tableIdQueues.get(generator).poll(MetamodelImpl.POLL_TIMEOUT, TimeUnit.SECONDS);\n    } catch (final InterruptedException e) {\n        throw new PersistenceException(\"Unable to retrieve next sequence \" + generator + \" in allowed \" + MetamodelImpl.POLL_TIMEOUT + \" seconds\");\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the next table value for the generator.\n *\n * @param generator\n *            the generator\n * @return the next table value for the generator\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 307, "method_signature": "Long getNextTableValue(String)"}, "MetamodelImpl.initStaticMetamodel": {"callee_method_names": ["ManagedTypeImpl<?>.getAttributes", "Class<?>.getDeclaredField", "AssociatedSingularAttribute<? super X, ?>.getName", "Field.set", "BLogger.debug", "AssociatedSingularAttribute<? super X, ?>.getName", "BLogger.debug", "E.getMessage", "BLogger.debug", "E.getMessage", "BLogger.debug", "E.getMessage"], "method_name": "MetamodelImpl.initStaticMetamodel", "method_implementation": "{\n    for (final Attribute<?, ?> attribute : type.getAttributes()) {\n        // if (attribute instanceof SingularAttribute<?, ?>) {\n        try {\n            final Field declaredField = clazz.getDeclaredField(attribute.getName());\n            declaredField.set(null, attribute);\n        } catch (final NoSuchFieldException e) {\n            LOG.debug(\"StaticMetamodel class has a missing field : {0}\", attribute.getName());\n        } catch (final SecurityException e) {\n            LOG.debug(e.getMessage());\n        } catch (final IllegalArgumentException e) {\n            LOG.debug(e.getMessage());\n        } catch (final IllegalAccessException e) {\n            LOG.debug(e.getMessage());\n        }\n        // }\n    }\n}", "repo_id": "1", "comment": "/**\n * @param type\n * @param clazz\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 308, "method_signature": "void initStaticMetamodel(ManagedTypeImpl, Class)"}, "MetamodelImpl.initStaticMetamodels": {"callee_method_names": ["ManagedTypeImpl<?>.getJavaType", "Class<?>.getName", "Class<?>.isAnnotationPresent", "BLogger.debug"], "method_name": "MetamodelImpl.initStaticMetamodels", "method_implementation": "{\n    for (final ManagedType<?> type : this.getManagedTypes()) {\n        final Class<?> entityClass = type.getJavaType();\n        final String staticMetamodelClassName = entityClass.getName() + \"_\";\n        try {\n            final Class<?> clazz = this.emf.getClassloader().loadClass(staticMetamodelClassName);\n            if (clazz.isAnnotationPresent(StaticMetamodel.class)) {\n                initStaticMetamodel((ManagedTypeImpl<?>) type, clazz);\n            }\n        } catch (final ClassNotFoundException e) {\n            LOG.debug(\"StaticMetamodel not present for {0}\", staticMetamodelClassName);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * initialize static metamodel classes\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 309, "method_signature": "void initStaticMetamodels()"}, "MetamodelImpl.managedType": {"callee_method_names": [], "method_name": "MetamodelImpl.managedType", "method_implementation": "{\n    ManagedTypeImpl<X> managedType = (ManagedTypeImpl<X>) this.embeddables.get(clazz);\n    if (managedType != null) {\n        return managedType;\n    }\n    managedType = (ManagedTypeImpl<X>) this.mappedSuperclasses.get(clazz);\n    if (managedType != null) {\n        return managedType;\n    }\n    return (ManagedTypeImpl<X>) this.entities.get(clazz);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 310, "method_signature": "ManagedTypeImpl<X> managedType(Class)"}, "MetamodelImpl.newThread": {"callee_method_names": ["Thread.setPriority"], "method_name": "MetamodelImpl.newThread", "method_implementation": "{\n    final Thread thread = new Thread(r, \"Id Generator - \" + GeneratorThreadFactory.nextThreadNo++);\n    thread.setPriority(Thread.MAX_PRIORITY);\n    return thread;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 290, "method_signature": "Thread newThread(Runnable)"}, "MetamodelImpl.performForeignKeysDdl": {"callee_method_names": ["EntityTypeImpl<?>.getName", "EntityTypeImpl<?>.getTables", "AbstractTable.getEntity", "AbstractTable.getQName", "AbstractTable.getForeignKeys", "EntityTypeImpl<?>.getAssociations", "PluralMappingEx<?,List<E>,E>.getJoinTable", "AbstractTable.getEntity", "AbstractTable.getQName", "AbstractTable.getForeignKeys", "EntityTypeImpl<?>.getMappingsPlural", "PluralMappingEx<?,List<E>,E>.isAssociation", "PluralMappingEx<?,List<E>,E>.getJoinTable", "AbstractTable.getQName", "AbstractTable.getForeignKeys"], "method_name": "MetamodelImpl.performForeignKeysDdl", "method_implementation": "{\n    if ((ddlMode == DDLMode.NONE)) {\n        return;\n    }\n    MetamodelImpl.LOG.info(\"Performing foreign key DDL operations for entiy {0}, mode {1}\", entity.getName(), ddlMode);\n    for (final EntityTable table : entity.getTables()) {\n        // skip parent tables\n        if (table.getEntity() != entity) {\n            continue;\n        }\n        MetamodelImpl.LOG.info(\"Performing foreign key DDL operations for table {0}, mode {1}\", table.getQName(), ddlMode);\n        for (final ForeignKey foreignKey : table.getForeignKeys()) {\n            this.jdbcAdaptor.createForeignKey(datasource, foreignKey);\n        }\n    }\n    for (final AssociationMappingImpl<?, ?, ?> mapping : entity.getAssociations()) {\n        final JoinTable table = mapping.getJoinTable();\n        // skip not applicable join tables\n        if ((table == null) || (table.getEntity() != entity)) {\n            continue;\n        }\n        MetamodelImpl.LOG.info(\"Performing foreign key DDL operations for join table {0}, mode {1}\", table.getQName(), ddlMode);\n        for (final ForeignKey foreignKey : table.getForeignKeys()) {\n            this.jdbcAdaptor.createForeignKey(datasource, foreignKey);\n        }\n    }\n    for (final PluralMappingEx<?, ?, ?> mapping : entity.getMappingsPlural()) {\n        if (!mapping.isAssociation()) {\n            final AbstractTable table = (AbstractTable) mapping.getJoinTable();\n            MetamodelImpl.LOG.info(\"Performing foreign key DDL operations for join table {0}, mode {1}\", table.getQName(), ddlMode);\n            for (final ForeignKey foreignKey : table.getForeignKeys()) {\n                this.jdbcAdaptor.createForeignKey(datasource, foreignKey);\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs the foreign key DDL operations.\n *\n * @param datasource\n *            the datasource\n * @param ddlMode\n *            the DDL Mode\n * @param entity\n *            the entity to perform DDL against\n * @throws BatooException\n *             thrown in case of an underlying exception\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 311, "method_signature": "void performForeignKeysDdl(DataSource, DDLMode, EntityTypeImpl)"}, "MetamodelImpl.performSequencesDdl": {"callee_method_names": [], "method_name": "MetamodelImpl.performSequencesDdl", "method_implementation": "{\n    if ((ddlMode == DDLMode.NONE)) {\n        return;\n    }\n    for (final SequenceGenerator sequenceGenerator : this.sequenceGenerators.values()) {\n        MetamodelImpl.LOG.info(\"Performing DDL operations for sequence generators for {0}, mode {1}\", sequenceGenerator.getName(), ddlMode);\n        this.jdbcAdaptor.createSequenceIfNecessary(datasource, sequenceGenerator);\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs the sequence generators DDL operations.\n *\n * @param datasource\n *            the datasource\n * @param ddlMode\n *            the DDL Mode\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 312, "method_signature": "void performSequencesDdl(DataSource, DDLMode)"}, "MetamodelImpl.performTableGeneratorsDdl": {"callee_method_names": [], "method_name": "MetamodelImpl.performTableGeneratorsDdl", "method_implementation": "{\n    if ((ddlMode == DDLMode.NONE)) {\n        return;\n    }\n    for (final TableGenerator tableGenerator : this.tableGenerators.values()) {\n        MetamodelImpl.LOG.info(\"Performing DDL operations for sequence generators for mode table {1}, mode {0}\", tableGenerator.getName(), ddlMode);\n        this.jdbcAdaptor.createTableGeneratorIfNecessary(datasource, tableGenerator);\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs the table generator DDL operations.\n *\n * @param datasource\n *            the datasource\n * @param ddlMode\n *            the DDL Mode\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 313, "method_signature": "void performTableGeneratorsDdl(DataSource, DDLMode)"}, "MetamodelImpl.performTablesDdl": {"callee_method_names": ["EntityTypeImpl<?>.getName", "EntityTypeImpl<?>.getTables", "AbstractTable.getEntity", "AbstractTable.getQName", "EntityTypeImpl<?>.getAssociations", "PluralMappingEx<?,List<E>,E>.getJoinTable", "AbstractTable.getEntity", "PluralMappingEx<?,List<E>,E>.getJoinTable", "EntityTypeImpl<?>.getMappingsPlural", "PluralMappingEx<?,List<E>,E>.isAssociation", "PluralMappingEx<?,List<E>,E>.getJoinTable"], "method_name": "MetamodelImpl.performTablesDdl", "method_implementation": "{\n    MetamodelImpl.LOG.info(\"Performing DDL operations for entity {0}, mode {1}\", entity.getName(), ddlMode);\n    // create the entity tables\n    for (final EntityTable table : entity.getTables()) {\n        // if table belongs to parent then skip\n        if (table.getEntity() != entity) {\n            continue;\n        }\n        MetamodelImpl.LOG.info(\"Performing DDL operations for {0}, mode {1}\", table.getQName(), ddlMode);\n        this.jdbcAdaptor.createOrUpdateTable(table, datasource, ddlMode);\n    }\n    // create the join tables\n    for (final AssociationMappingImpl<?, ?, ?> mapping : entity.getAssociations()) {\n        final JoinTable table = mapping.getJoinTable();\n        // skip not applicable tables\n        if ((table == null) || (table.getEntity() != entity)) {\n            continue;\n        }\n        this.jdbcAdaptor.createOrUpdateTable(mapping.getJoinTable(), datasource, ddlMode);\n    }\n    // create the join tables\n    for (final PluralMappingEx<?, ?, ?> mapping : entity.getMappingsPlural()) {\n        if (!mapping.isAssociation()) {\n            final AbstractTable table = (AbstractTable) mapping.getJoinTable();\n            this.jdbcAdaptor.createOrUpdateTable(table, datasource, ddlMode);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs the table DDL operations.\n *\n * @param datasource\n *            the datasource\n * @param ddlMode\n *            the DDL Mode\n * @param entity\n *            the entity to perform DDL against\n * @throws BatooException\n *             thrown in case of an underlying exception\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 314, "method_signature": "void performTablesDdl(DataSource, DDLMode, EntityTypeImpl)"}, "MetamodelImpl.preFillGenerators": {"callee_method_names": ["String.getName", "String.getSequenceName", "String.getAllocationSize", "String.getName"], "method_name": "MetamodelImpl.preFillGenerators", "method_implementation": "{\n    final int nThreads = Runtime.getRuntime().availableProcessors();\n    this.idGeneratorExecuter = new //\n    ThreadPoolExecutor(//\n    1, //\n    nThreads, //\n    30, //\n    TimeUnit.SECONDS, //\n    new LinkedBlockingQueue<Runnable>(), new GeneratorThreadFactory());\n    for (final SequenceGenerator generator : this.sequenceGenerators.values()) {\n        this.sequenceQueues.put(generator.getName(), new SequenceQueue(this.jdbcAdaptor, datasource, this.idGeneratorExecuter, generator.getSequenceName(), generator.getAllocationSize()));\n    }\n    for (final TableGenerator generator : this.tableGenerators.values()) {\n        this.tableIdQueues.put(generator.getName(), new TableIdQueue(this.jdbcAdaptor, datasource, this.idGeneratorExecuter, generator));\n    }\n}", "repo_id": "1", "comment": "/**\n * Prefills the id generators.\n *\n * @param datasource\n *            the datasource to use\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 315, "method_signature": "void preFillGenerators(DataSource)"}, "MetamodelImpl.stopIdGenerators": {"callee_method_names": [], "method_name": "MetamodelImpl.stopIdGenerators", "method_implementation": "{\n    this.idGeneratorExecuter.shutdownNow();\n    try {\n        this.idGeneratorExecuter.awaitTermination(5, TimeUnit.SECONDS);\n    } catch (final Exception e) {\n    }\n}", "repo_id": "1", "comment": "/**\n * Stops the id generators.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 316, "method_signature": "void stopIdGenerators()"}, "MetamodelImpl.type": {"callee_method_names": [], "method_name": "MetamodelImpl.type", "method_implementation": "{\n    final BasicTypeImpl<?> basic = this.basics.get(clazz);\n    if (basic != null) {\n        return (TypeImpl<X>) basic;\n    }\n    return this.managedType(clazz);\n}", "repo_id": "1", "comment": "/**\n * Returns the type corresponding to the <code>clazz</code>.\n *\n * @param clazz\n *            the class of the type\n * @param <X>\n *            the expected type of the type\n * @return the type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 317, "method_signature": "TypeImpl<X> type(Class)"}, "MetamodelTest.testStaticMetamodel": {"callee_method_names": [], "method_name": "MetamodelTest.testStaticMetamodel", "method_implementation": "{\n    assertNotNull(Foo_.id);\n    assertNotNull(Foo_.timeStamp);\n    assertNotNull(Foo_.fooName);\n    assertNotNull(Foo_.bar);\n    assertNotNull(Bar_.id);\n    assertNotNull(Bar_.name);\n    assertNotNull(Bar_.foos);\n}", "repo_id": "1", "comment": "/**\n * Tests tStaticMetamodel.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2501, "method_signature": "void testStaticMetamodel()"}, "MsSqlAdaptor.applyLock": {"callee_method_names": [], "method_name": "MsSqlAdaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1265, "method_signature": "String applyLock(String, LockModeType)"}, "MsSqlAdaptor.applyPagination": {"callee_method_names": ["String.indexOf", "String.replaceFirst", "String.replaceFirst", "StringBuffer.indexOf", "StringBuffer.subSequence", "StringBuffer.length", "StringBuffer.delete", "StringBuffer.length", "StringBuffer.indexOf", "StringBuffer.insert"], "method_name": "MsSqlAdaptor.applyPagination", "method_implementation": "{\n    if (startPosition == 0) {\n        if (sql.indexOf(\"SELECT DISTINCT\") > -1) {\n            return sql.replaceFirst(\"SELECT DISTINCT\", \"SELECT DISTINCT TOP \" + maxResult);\n        }\n        return sql.replaceFirst(\"SELECT\", \"SELECT TOP \" + maxResult);\n    }\n    sql = BatooUtils.indent(sql);\n    final StringBuffer sqlStr = new StringBuffer(sql);\n    final int orderIndex = sqlStr.indexOf(\"ORDER BY\");\n    final CharSequence orderby = orderIndex > -1 ? sqlStr.subSequence(orderIndex, sqlStr.length()) : \"ORDER BY CURRENT_TIMESTAMP\";\n    if (orderIndex > -1) {\n        sqlStr.delete(orderIndex, sqlStr.length());\n    }\n    final int fromIndex = sqlStr.indexOf(\"FROM\");\n    sqlStr.insert(fromIndex, \"\\t, ROW_NUMBER() OVER (\" + orderby + \") AS ROW_NUM__INTERNAL \");\n    if (maxResult == Integer.MAX_VALUE) {\n        return \"SELECT * FROM (\\n\" + sqlStr + \"\\n) AS PAGINATED_RESULT WHERE ROW_NUM__INTERNAL > \" + startPosition + \" ORDER BY ROW_NUM__INTERNAL\";\n    }\n    return \"SELECT * FROM (\\n\" + sqlStr + \")\\nAS PAGINATED_RESULT WHERE ROW_NUM__INTERNAL > \" + startPosition + \" AND ROW_NUM__INTERNAL < \" + (startPosition + maxResult) + \" ORDER BY ROW_NUM__INTERNAL\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1266, "method_signature": "String applyPagination(String, int, int)"}, "MsSqlAdaptor.applySubStr": {"callee_method_names": [], "method_name": "MsSqlAdaptor.applySubStr", "method_implementation": "{\n    if (endFragment != null) {\n        return \"SUBSTRING(\" + Joiner.on(\", \").skipNulls().join(new Object[] { innerFragment, startFragment, endFragment }) + \")\";\n    }\n    return \"SUBSTRING(\" + Joiner.on(\", \").skipNulls().join(new Object[] { innerFragment, startFragment, Integer.toString(Integer.MAX_VALUE) }) + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1267, "method_signature": "String applySubStr(String, String, String)"}, "MsSqlAdaptor.applyTrim": {"callee_method_names": [], "method_name": "MsSqlAdaptor.applyTrim", "method_implementation": "{\n    if (trimChar != null) {\n        throw new PersistenceException(\"MSSQL Server does not support trim character\");\n    }\n    if (trimspec == null) {\n        trimspec = Trimspec.BOTH;\n    }\n    switch(trimspec) {\n        case LEADING:\n            return \"LTRIM(\" + argument + \")\";\n        case TRAILING:\n            return \"RTRIM(\" + argument + \")\";\n        default:\n            return \"RTRIM(LTRIM(\" + argument + \"))\";\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1268, "method_signature": "String applyTrim(Trimspec, String, String)"}, "MsSqlAdaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getIdType", "AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable", "AbstractColumn.isUnique"], "method_name": "MsSqlAdaptor.createColumnDDL", "method_implementation": "{\n    final boolean identity = column.getIdType() == IdType.IDENTITY;\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // not null part\n    (column.isUnique() ? \" UNIQUE\" : \"\") + // auto increment part\n    (identity ? \" IDENTITY(1,1)\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1269, "method_signature": "String createColumnDDL(AbstractColumn)"}, "MsSqlAdaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "MsSqlAdaptor.getColumnType", "method_implementation": "{\n    switch(sqlType) {\n        case Types.BLOB:\n            return \"VARBINARY(\" + cd.getLength() + \")\";\n        case Types.CLOB:\n            return \"NVARCHAR(\" + cd.getLength() + \")\";\n        case Types.VARCHAR:\n            return \"NVARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n        case Types.DATE:\n        case Types.TIMESTAMP:\n            return \"DATE\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"BIT\";\n        case Types.TINYINT:\n            return \"TINYINT\";\n        case Types.SMALLINT:\n            return \"SMALLINT\";\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"BIGINT\";\n        case Types.FLOAT:\n        case Types.DOUBLE:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"DECIMAL\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1270, "method_signature": "String getColumnType(AbstractColumn, int)"}, "MsSqlAdaptor.getDropForeignKeySql": {"callee_method_names": [], "method_name": "MsSqlAdaptor.getDropForeignKeySql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(schema, table);\n    return \"ALTER TABLE \" + qualifiedName + \" DROP CONSTRAINT \" + foreignKey;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1271, "method_signature": "String getDropForeignKeySql(String, String, String)"}, "MsSqlAdaptor.getNumericFunctionTemplate": {"callee_method_names": [], "method_name": "MsSqlAdaptor.getNumericFunctionTemplate", "method_implementation": "{\n    if (type == NumericFunctionType.MOD) {\n        return \"{0} % {1}\";\n    }\n    if (type == NumericFunctionType.LENGTH) {\n        return \"LEN({0})\";\n    }\n    return super.getNumericFunctionTemplate(type);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1272, "method_signature": "String getNumericFunctionTemplate(NumericFunctionType)"}, "MsSqlAdaptor.supports": {"callee_method_names": [], "method_name": "MsSqlAdaptor.supports", "method_implementation": "{\n    if (type == GenerationType.IDENTITY) {\n        return IdType.IDENTITY;\n    }\n    return IdType.TABLE;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1273, "method_signature": "IdType supports(GenerationType)"}, "MyEntity.equals": {"callee_method_names": [], "method_name": "MyEntity.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof MyEntity)) {\n        return false;\n    }\n    final MyEntity other = (MyEntity) obj;\n    if (this.id == null) {\n        if (other.id != null) {\n            return false;\n        }\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    if (this.someDate == null) {\n        if (other.someDate != null) {\n            return false;\n        }\n    } else if (!this.someDate.equals(other.someDate)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2538, "method_signature": "boolean equals(Object)"}, "MyEntity.hashCode": {"callee_method_names": [], "method_name": "MyEntity.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    result = (prime * result) + ((this.someDate == null) ? 0 : this.someDate.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2539, "method_signature": "int hashCode()"}, "MySqlAdaptor.applyLock": {"callee_method_names": [], "method_name": "MySqlAdaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1304, "method_signature": "String applyLock(String, LockModeType)"}, "MySqlAdaptor.applyPagination": {"callee_method_names": [], "method_name": "MySqlAdaptor.applyPagination", "method_implementation": "{\n    if ((startPosition != 0) || (maxResult != Integer.MAX_VALUE)) {\n        sql = sql + \"\\nLIMIT ?\";\n        if (maxResult != Integer.MAX_VALUE) {\n            sql = sql + \", ?\";\n        }\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1305, "method_signature": "String applyPagination(String, int, int)"}, "MySqlAdaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getIdType", "AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable", "AbstractColumn.isUnique"], "method_name": "MySqlAdaptor.createColumnDDL", "method_implementation": "{\n    final boolean identity = column.getIdType() == IdType.IDENTITY;\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // not null part\n    (column.isUnique() ? \" UNIQUE\" : \"\") + // auto increment part\n    (identity ? \" AUTO_INCREMENT\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1306, "method_signature": "String createColumnDDL(AbstractColumn)"}, "MySqlAdaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "MySqlAdaptor.getColumnType", "method_implementation": "{\n    switch(sqlType) {\n        case Types.BLOB:\n        case Types.CLOB:\n            return \"BLOB(\" + cd.getLength() + \")\";\n        case Types.VARCHAR:\n            return \"VARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n            return \"TIME\";\n        case Types.DATE:\n            return \"DATE\";\n        case Types.TIMESTAMP:\n            return \"TIMESTAMP\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"BOOLEAN\";\n        case Types.TINYINT:\n        case Types.SMALLINT:\n            return \"SMALLINT\";\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"BIGINT\";\n        case Types.FLOAT:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DOUBLE:\n            return \"DOUBLE\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"DECIMAL\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1307, "method_signature": "String getColumnType(AbstractColumn, int)"}, "MySqlAdaptor.supports": {"callee_method_names": [], "method_name": "MySqlAdaptor.supports", "method_implementation": "{\n    if (type == GenerationType.IDENTITY) {\n        return IdType.IDENTITY;\n    }\n    return IdType.TABLE;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1308, "method_signature": "IdType supports(GenerationType)"}, "NamedNativeQueryElement.generate": {"callee_method_names": [], "method_name": "NamedNativeQueryElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n    this.resultClass = this.getAttribute(ElementConstants.ATTR_RESULT_CLASS, ElementConstants.EMPTY);\n    this.resultSetMapping = this.getAttribute(ElementConstants.ATTR_RESULT_SET_MAPPING, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1118, "method_signature": "void generate()"}, "NamedNativeQueryElement.handleChild": {"callee_method_names": [], "method_name": "NamedNativeQueryElement.handleChild", "method_implementation": "{\n    if (child instanceof HintElement) {\n        this.hints.put(((HintElement) child).getName(), ((HintElement) child).getValue());\n    }\n    if (child instanceof QueryElement) {\n        this.query = ((QueryElement) child).getQuery();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1119, "method_signature": "void handleChild(Element)"}, "NamedQueriesManager.perform": {"callee_method_names": ["NamedQueryMetadata.getName", "NamedQueryMetadata.getName"], "method_name": "NamedQueriesManager.perform", "method_implementation": "{\n    NamedQueriesManager.LOG.debug(\"Compiling named query {0}...\", namedQuery.getName());\n    new JpqlQuery(this.getMetamodel().getEntityManagerFactory(), this.criteriaBuilder, namedQuery);\n    NamedQueriesManager.LOG.debug(\"Successfully compiled named query {0}.\", namedQuery.getName());\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 197, "method_signature": "Void perform(NamedQueryMetadata)"}, "NamedQueryElement.handleChild": {"callee_method_names": [], "method_name": "NamedQueryElement.handleChild", "method_implementation": "{\n    if (child instanceof HintElement) {\n        this.hints.put(((HintElement) child).getName(), ((HintElement) child).getValue());\n    }\n    if (child instanceof QueryElement) {\n        this.query = ((QueryElement) child).getQuery();\n    }\n    if (child instanceof LockModeElement) {\n        this.lockMode = ((LockModeElement) child).getLockMode();\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1083, "method_signature": "void handleChild(Element)"}, "NativeParameter.getName": {"callee_method_names": [], "method_name": "NativeParameter.getName", "method_implementation": "{\n    // JSR-317 3.8.15 >> The use of named parameters is not defined for native queries.\n    throw new NotImplementedException(\"Native queries do not support named parameters.\");\n}", "repo_id": "1", "comment": "/**\n * Returns the name of the parameter.\n *\n * @return the name number of the parameter\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 418, "method_signature": "String getName()"}, "NativeQuery.executeUpdate": {"callee_method_names": [], "method_name": "NativeQuery.executeUpdate", "method_implementation": "{\n    this.em.assertTransaction();\n    // flush if specified\n    if ((this.flushMode == FlushModeType.AUTO) || (this.em.getFlushMode() == FlushModeType.AUTO)) {\n        this.em.flush();\n    }\n    try {\n        if (!this.parameters.isEmpty()) {\n            final Object[] parameters = new Object[this.parameters.size()];\n            for (int i = 0; i < this.parameters.size(); i++) {\n                parameters[i] = this.getParameterValue(i);\n            }\n            return new QueryRunner(this.em.getJdbcAdaptor(), false).update(this.query, parameters);\n        }\n        return new QueryRunner(this.em.getJdbcAdaptor(), false).update(this.query);\n    } catch (final SQLException e) {\n        throw new PersistenceException(\"Native query execution has failed!\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 391, "method_signature": "int executeUpdate()"}, "NativeQuery.getAssociatedId": {"callee_method_names": ["SingularAssociationMappingImpl<?,?>.getForeignKey", "HashMap<String,Object>.get", "Object.toString", "HashMap<AbstractColumn, String>.put"], "method_name": "NativeQuery.getAssociatedId", "method_implementation": "{\n    final HashMap<AbstractColumn, String> translatedIdFields = Maps.newHashMap();\n    for (final JoinColumn joinColumn : mapping.getForeignKey().getJoinColumns()) {\n        final String name = joinColumn.getReferencedColumn().getMapping().getName();\n        final Object colnameTemp = (_parentFieldMap != null) ? _parentFieldMap.get(name) : null;\n        final String colname = colnameTemp == null ? joinColumn.getName() : colnameTemp.toString();\n        translatedIdFields.put(joinColumn.getReferencedColumn(), colname);\n    }\n    return translatedIdFields;\n}", "repo_id": "1", "comment": "/**\n * @param session\n * @param row\n * @param mapping\n * @param session\n * @param row\n * @return\n * @throws SQLException\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 392, "method_signature": "HashMap<AbstractColumn,String> getAssociatedId(SingularAssociationMappingImpl, HashMap)"}, "NativeQuery.getIdFieldTransformed": {"callee_method_names": ["HashMap<AbstractColumn,String>.values", "BiMap<String, AbstractColumn>.get", "AbstractColumn.getMapping", "HashMap<String,Object>.get", "Object.toString", "HashMap<AbstractColumn, String>.put", "Object.toString", "HashMap<AbstractColumn, String>.put"], "method_name": "NativeQuery.getIdFieldTransformed", "method_implementation": "{\n    if (fieldIdMap == null) {\n        return idFields;\n    }\n    final HashMap<AbstractColumn, String> idFieldsMod = Maps.newHashMap();\n    final BiMap<String, AbstractColumn> inverse = HashBiMap.create(idFields).inverse();\n    for (final String field : idFields.values()) {\n        final AbstractColumn column = inverse.get(field);\n        final String _field = column.getMapping().getName();\n        final Object colmVal = fieldIdMap.get(_field);\n        if (colmVal != null && colmVal.toString() != null) {\n            idFieldsMod.put(column, colmVal.toString());\n        } else {\n            idFieldsMod.put(column, _field);\n        }\n    }\n    return idFieldsMod;\n}", "repo_id": "1", "comment": "/**\n * Transforms the column names for idField Map using a field,column-name map\n *\n * @return\n * @param idFields\n * @param _fieldMap\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 393, "method_signature": "HashMap<AbstractColumn,String> getIdFieldTransformed(HashMap, HashMap)"}, "NativeQuery.getParameter": {"callee_method_names": [], "method_name": "NativeQuery.getParameter", "method_implementation": "{\n    // JSR-317 3.8.15 >> The use of named parameters is not defined for native queries.\n    throw new NotImplementedException(\"Native queries do not support named parameters.\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 395, "method_signature": "Parameter<T> getParameter(String, Class)"}, "NativeQuery.getParameterValue": {"callee_method_names": [], "method_name": "NativeQuery.getParameterValue", "method_implementation": "{\n    // JSR-317 3.8.15 >> The use of named parameters is not defined for native queries.\n    throw new NotImplementedException(\"Native queries do not support named parameters.\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 398, "method_signature": "Object getParameterValue(String)"}, "NativeQuery.getParameters": {"callee_method_names": ["Set<Parameter<?>>.add"], "method_name": "NativeQuery.getParameters", "method_implementation": "{\n    final Set<Parameter<?>> parameters = Sets.newHashSet();\n    for (final NativeParameter<?> parameter : this.parameters.values()) {\n        parameters.add(parameter);\n    }\n    return parameters;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 396, "method_signature": "Set<Parameter<?>> getParameters()"}, "NativeQuery.getResultList": {"callee_method_names": [], "method_name": "NativeQuery.getResultList", "method_implementation": "{\n    if (this.results != null) {\n        return this.results;\n    }\n    return this.getResultListImpl();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 399, "method_signature": "List<?> getResultList()"}, "NativeQuery.getSingleResult": {"callee_method_names": ["List<?>.size", "List<?>.size", "List<?>.get"], "method_name": "NativeQuery.getSingleResult", "method_implementation": "{\n    final List<?> resultList = this.getResultList();\n    if (resultList.size() > 1) {\n        throw new NonUniqueResultException();\n    }\n    if (resultList.size() == 0) {\n        throw new NoResultException();\n    }\n    return resultList.get(0);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 400, "method_signature": "Object getSingleResult()"}, "NativeQuery.handle": {"callee_method_names": [], "method_name": "NativeQuery.handle", "method_implementation": "{\n    if (this.sqlResultSetMapping != null) {\n        return this.handleWithSqlResultSetMapping(resultSet);\n    }\n    if (this.resultClass != null) {\n        // designated return type\n        return this.handleWithResultClass(resultSet);\n    }\n    // last option return query as scalar\n    return handleAsScalar(resultSet);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 401, "method_signature": "List<Object> handle(ResultSet)"}, "NativeQuery.handleWithResultClass": {"callee_method_names": ["ResultSet.next", "ArrayList<Object>.add", "ManagedInstance<?>.getInstance", "ArrayList<Object>.add"], "method_name": "NativeQuery.handleWithResultClass", "method_implementation": "{\n    final ArrayList<Object> result = Lists.newArrayList();\n    final EntityTypeImpl<?> entityType = this.em.getMetamodel().entity(this.resultClass);\n    if (entityType == null) {\n        throw new PersistenceException(\"Entity Class is not managed :\" + this.resultClass);\n    }\n    while (resultSet.next()) {\n        // for each row\n        final ManagedInstance<?> managedInstance = this.handleInstance(resultSet, entityType, null, null);\n        if (managedInstance != null) {\n            result.add(managedInstance.getInstance());\n        } else {\n            result.add(null);\n        }\n    }\n    return result;\n}", "repo_id": "1", "comment": "/**\n * result set handler for a given resultClass\n *\n * @return result\n * @param resultSet\n * @throws SQLException\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 402, "method_signature": "List<Object> handleWithResultClass(ResultSet)"}, "NativeQuery.handleWithSqlResultSetMapping": {"callee_method_names": ["ResultSet.next", "List<EntityResultMetadata>.size", "List<EntityResultMetadata>.get", "EntityResultMetadata.getEntityClass", "EntityResultMetadata.getEntityClass", "EntityResultMetadata.getDiscriminatorColumn", "ArrayList<Object>.add", "ManagedInstance<?>.getInstance", "ArrayList<Object>.add", "ArrayList<Object>.add", "ResultSet.getObject", "ArrayList<Object>.size", "ArrayList<Object>.add", "ArrayList<Object>.toArray", "ArrayList<Object>.add", "ArrayList<Object>.get"], "method_name": "NativeQuery.handleWithSqlResultSetMapping", "method_implementation": "{\n    final ArrayList<Object> result = Lists.newArrayList();\n    final List<EntityResultMetadata> entities = this.sqlResultSetMapping.getEntities();\n    while (resultSet.next()) {\n        // for each row\n        final ArrayList<Object> resultRow = Lists.newArrayList();\n        for (int i = 0; i < entities.size(); i++) {\n            final EntityResultMetadata entityResultMetadata = entities.get(i);\n            final EntityTypeImpl<?> entityType = this.em.getMetamodel().entity(entityResultMetadata.getEntityClass());\n            if (entityType == null) {\n                throw new PersistenceException(\"Entity Class is not managed :\" + entityResultMetadata.getEntityClass());\n            }\n            final HashMap<String, Object> _fieldMap = this.fieldMap.get(i);\n            final ManagedInstance<?> managedInstance = this.handleInstance(resultSet, entityType, entityResultMetadata.getDiscriminatorColumn(), _fieldMap);\n            if (managedInstance != null) {\n                resultRow.add(managedInstance.getInstance());\n            } else {\n                resultRow.add(null);\n            }\n        }\n        for (final ColumnResultMetadata columnResultMetadata : this.sqlResultSetMapping.getColumns()) {\n            resultRow.add(resultSet.getObject(columnResultMetadata.getName()));\n        }\n        if (resultRow.size() > 1) {\n            result.add(resultRow.toArray());\n        } else {\n            result.add(resultRow.get(0));\n        }\n    }\n    return result;\n}", "repo_id": "1", "comment": "/**\n * result set handler for SqlResultSetMapping annotation data\n *\n * @return result\n * @param resultSet\n * @throws SQLException\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 403, "method_signature": "List<Object> handleWithSqlResultSetMapping(ResultSet)"}, "NativeQuery.initializeInstance": {"callee_method_names": ["ManagedInstance<?>.setLoading", "ManagedInstance<?>.getInstance", "EntityTypeImpl<?>.getMappingsSingular", "BasicMappingImpl<?, ?>.getColumn", "HashMap<String,Object>.get", "BasicMappingImpl<?, ?>.getName", "HashMap<String,Object>.get", "BasicMappingImpl<?, ?>.getName", "BasicColumn.getName", "BasicColumn.setValue", "ResultSet.getObject", "HashMap<String,Object>.get", "SingularAssociationMappingImpl<?, ?>.getName", "HashMap<String,Object>.get", "SingularAssociationMappingImpl<?, ?>.getName", "IdModel.getIdMap", "IdModel.getIdMap", "SingularAssociationMappingImpl<?, ?>.getForeignKey", "HashMap<String, Object>.get", "Object.toString", "ResultSet.getObject", "BLogger.debug", "SingularAssociationMappingImpl<?, ?>.getType", "SingularAssociationMappingImpl<?, ?>.getType", "ManagedId<?>.getId", "SessionImpl.getEntityManager", "EntityTypeImpl<?>.getJavaType", "ManagedId<?>.getId", "SingularAssociationMappingImpl<?, ?>.set", "ManagedInstance<?>.setJoinLoaded"], "method_name": "NativeQuery.initializeInstance", "method_implementation": "{\n    managedInstance.setLoading(true);\n    final Object instance = managedInstance.getInstance();\n    // initialize all singular mappings\n    for (final AbstractMapping<?, ?, ?> mapping : entityType.getMappingsSingular()) {\n        if (mapping instanceof BasicMappingImpl) {\n            final BasicMappingImpl<?, ?> basicMapping = (BasicMappingImpl<?, ?>) mapping;\n            final BasicColumn column = basicMapping.getColumn();\n            final String colName = //\n            (fieldMap != null && fieldMap.get(basicMapping.getName()) != null) ? fieldMap.get(basicMapping.getName()).toString() : column.getName();\n            column.setValue(instance, row.getObject(colName));\n        }\n        if (mapping instanceof SingularAssociationMappingImpl) {\n            final SingularAssociationMappingImpl<?, ?> saMapping = (SingularAssociationMappingImpl<?, ?>) mapping;\n            HashMap<String, Object> _parentFieldMap = fieldMap;\n            if (fieldMap != null && fieldMap.get(saMapping.getName()) instanceof IdModel) {\n                final IdModel idModel = (IdModel) fieldMap.get(saMapping.getName());\n                if (idModel.getIdMap().size() > 1) {\n                    _parentFieldMap = idModel.getIdMap();\n                }\n            }\n            // loop on join column and set their value using the result set, but we are mapping correct column name from fieldResult\n            for (final JoinColumn joinColumn : saMapping.getForeignKey().getJoinColumns()) {\n                final String name = joinColumn.getReferencedColumn().getMapping().getName();\n                final Object colnameTemp = (_parentFieldMap != null) ? _parentFieldMap.get(name) : null;\n                final String colname = colnameTemp == null ? joinColumn.getName() : colnameTemp.toString();\n                try {\n                    final Object _id = row.getObject(colname);\n                    if (_id != null) {\n                        joinColumn.setValue(instance, _id);\n                    }\n                } catch (final SQLException e) {\n                    LOG.debug(\"column not found with name: {0}\", colname);\n                }\n            }\n            final EntityTypeImpl<?> _childType = saMapping.getType();\n            final HashMap<AbstractColumn, String> translatedIdFields = getAssociatedId(saMapping, _parentFieldMap);\n            final ManagedId<?> managedId = saMapping.getType().getId(session, row, translatedIdFields);\n            if (managedId != null && managedId.getId() != null) {\n                final Object reference = session.getEntityManager().getReference(_childType.getJavaType(), managedId.getId());\n                if (reference != null) {\n                    saMapping.set(instance, reference);\n                    managedInstance.setJoinLoaded(saMapping);\n                }\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * initialize the managedInstance with sql row data and fieldResult Mapping\n *\n * @param session\n * @param row\n *            Sql data row\n * @param managedInstance\n * @param entityType\n * @param fieldMap\n *            fieldResult Mapping data\n * @throws SQLException\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 404, "method_signature": "void initializeInstance(SessionImpl, ResultSet, ManagedInstance, EntityTypeImpl, HashMap)"}, "NativeQuery.setFirstResult": {"callee_method_names": [], "method_name": "NativeQuery.setFirstResult", "method_implementation": "{\n    this.firstResult = startPosition;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 405, "method_signature": "NativeQuery setFirstResult(int)"}, "NativeQuery.setFlushMode": {"callee_method_names": [], "method_name": "NativeQuery.setFlushMode", "method_implementation": "{\n    this.flushMode = flushMode;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 406, "method_signature": "NativeQuery setFlushMode(FlushModeType)"}, "NativeQuery.setHint": {"callee_method_names": [], "method_name": "NativeQuery.setHint", "method_implementation": "{\n    this.hints.put(hintName, value);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 407, "method_signature": "NativeQuery setHint(String, Object)"}, "NativeQuery.setMaxResults": {"callee_method_names": [], "method_name": "NativeQuery.setMaxResults", "method_implementation": "{\n    this.maxResults = maxResults;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 408, "method_signature": "NativeQuery setMaxResults(int)"}, "NativeQuery.setParameter": {"callee_method_names": [], "method_name": "NativeQuery.setParameter", "method_implementation": "{\n    // JSR-317 3.8.15 >> The use of named parameters is not defined for native queries.\n    throw new NotImplementedException(\"Native queries do not support named parameters.\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 417, "method_signature": "NativeQuery setParameter(String, Object)"}, "NativeQueryTest.testColumnMappingNativeQuery": {"callee_method_names": ["Query.getResultList", "List<?>.size", "Order.getQuantity", "Order.getItem", "Order.getItem"], "method_name": "NativeQueryTest.testColumnMappingNativeQuery", "method_implementation": "{\n    final Item i1 = new Item(\"item1\", \"the item 1.\");\n    final Order o1 = new Order(30, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = this.em().createNativeQuery(//\n    \"SELECT o.id AS order_id, \" + //\n    \"o.quantity AS order_quantity, \" + //\n    \"o.item_id AS order_item, \" + //\n    \"i.name AS item_name \" + //\n    \"FROM ORDER_T o, Item i \" + \"WHERE (o.quantity > 25) AND (o.item_id = i.id)\", \"OrderResults3\");\n    final List<?> resultList = q.getResultList();\n    Assert.assertEquals(1, resultList.size());\n    for (final Object oArr : resultList) {\n        final Object[] row = (Object[]) oArr;\n        Assert.assertTrue(row[0] instanceof Order);\n        final Order order = (Order) row[0];\n        Assert.assertTrue(this.em().contains(order));\n        Assert.assertEquals(30, order.getQuantity().intValue());\n        Assert.assertEquals(\"item1\", order.getItem().getName());\n        Assert.assertEquals(\"the item 1.\", order.getItem().getDescription());\n        Assert.assertTrue(row[1] instanceof String);\n        final String item = (String) row[1];\n        Assert.assertEquals(\"item1\", item);\n    }\n}", "repo_id": "1", "comment": "/**\n * test for column mapping\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2323, "method_signature": "void testColumnMappingNativeQuery()"}, "NativeQueryTest.testDiscriminatorValue": {"callee_method_names": ["Query.getResultList", "Query.getResultList", "Item4.getOrders", "Order4.getItem"], "method_name": "NativeQueryTest.testDiscriminatorValue", "method_implementation": "{\n    final Item4 i4 = new Item4(\"item4\", \"the item 4.\");\n    final Order4 o1 = new Order4(20, i4);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = this.em().createNativeQuery(//\n    \"SELECT o.id AS order_id, \" + //\n    \"o.quantity AS order_quantity, \" + //\n    \"o.item_id AS order_item, \" + //\n    \"o.DISC as discol,\" + //\n    \"i.id, i.name, i.description \" + //\n    \"FROM ORDER4 o, Item4 i \" + \"WHERE (o.quantity > 5) AND (o.item_id = i.id)\", \"OrderItemResultsDisc4\");\n    final List<?> resultList = q.getResultList();\n    Assert.assertEquals(1, q.getResultList().size());\n    for (final Object oArr : resultList) {\n        final Object[] row = (Object[]) oArr;\n        Assert.assertTrue(row[0] instanceof Order4);\n        final Order4 order = (Order4) row[0];\n        Assert.assertTrue(this.em().contains(order));\n        Assert.assertTrue(row[1] instanceof Item4);\n        final Item4 item = (Item4) row[1];\n        Assert.assertTrue(this.em().contains(item));\n        Assert.assertEquals(1, item.getOrders().size());\n        Assert.assertEquals(item, order.getItem());\n    }\n}", "repo_id": "1", "comment": "/**\n * Test for DiscriminatorValue\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2324, "method_signature": "void testDiscriminatorValue()"}, "NativeQueryTest.testEmbeddedIdNativeQuery": {"callee_method_names": ["Query.getResultList", "List<?>.size", "Order3.getQuantity", "Order3.getItem", "Order3.getItem", "Order3.getItem", "Item3.getItemPk", "Item3.getDescription", "Item3.getOrders"], "method_name": "NativeQueryTest.testEmbeddedIdNativeQuery", "method_implementation": "{\n    final Item3 i1 = new Item3(new Item3Pk(1l, \"item1\"), \"the item 1.\");\n    final Order3 o1 = new Order3(30, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = //\n    this.em().//\n    createNativeQuery(//\n    \"SELECT o.id AS order_id, \" + //\n    \"o.quantity AS order_quantity, \" + //\n    \"o.item_id AS order_item_id, \" + //\n    \"o.item_name AS order_item_name, \" + //\n    \"i.id, i.name, i.description \" + //\n    \"FROM ORDER3 o, Item3 i \" + \"WHERE (o.quantity > 25) AND (o.item_id = i.id) AND (o.item_name = i.name)\", \"OrderItemEmbeddedIdResults\");\n    final List<?> resultList = q.getResultList();\n    Assert.assertEquals(1, resultList.size());\n    for (final Object oArr : resultList) {\n        final Object[] row = (Object[]) oArr;\n        Assert.assertTrue(row[0] instanceof Order3);\n        final Order3 order = (Order3) row[0];\n        Assert.assertTrue(this.em().contains(order));\n        Assert.assertEquals(30, order.getQuantity().intValue());\n        Assert.assertEquals(\"item1\", order.getItem().getItemPk().getName());\n        Assert.assertEquals(\"the item 1.\", order.getItem().getDescription());\n        Assert.assertEquals(1, order.getItem().getOrders().size());\n        Assert.assertTrue(row[1] instanceof Item3);\n        final Item3 item = (Item3) row[1];\n        Assert.assertTrue(this.em().contains(item));\n        Assert.assertEquals(\"item1\", item.getItemPk().getName());\n        Assert.assertEquals(\"the item 1.\", item.getDescription());\n        //\n        Assert.assertEquals(1, item.getOrders().size());\n        //\n    }\n}", "repo_id": "1", "comment": "/**\n * test for embeddedId attribute in native query\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2325, "method_signature": "void testEmbeddedIdNativeQuery()"}, "NativeQueryTest.testIdClassNativeQuery": {"callee_method_names": ["Query.getResultList", "List<?>.size", "Order2.getQuantity", "Order2.getItem", "Order2.getItem", "Order2.getItem", "Item2.getName", "Item2.getDescription", "Item2.getOrders"], "method_name": "NativeQueryTest.testIdClassNativeQuery", "method_implementation": "{\n    final Item2 i1 = new Item2(1l, \"item1\", \"the item 1.\");\n    final Order2 o1 = new Order2(30, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = //\n    this.em().//\n    createNativeQuery(//\n    \"SELECT o.id AS order_id, \" + //\n    \"o.quantity AS order_quantity, \" + //\n    \"o.item_id AS order_item_id, \" + //\n    \"o.item_name AS order_item_name, \" + //\n    \"i.id, i.name, i.description \" + //\n    \"FROM ORDER2 o, Item2 i \" + \"WHERE (o.quantity > 25) AND (o.item_id = i.id) AND (o.item_name = i.name)\", \"OrderItemResultsIdClass\");\n    final List<?> resultList = q.getResultList();\n    Assert.assertEquals(1, resultList.size());\n    for (final Object oArr : resultList) {\n        final Object[] row = (Object[]) oArr;\n        Assert.assertTrue(row[0] instanceof Order2);\n        final Order2 order = (Order2) row[0];\n        Assert.assertTrue(this.em().contains(order));\n        Assert.assertEquals(30, order.getQuantity().intValue());\n        Assert.assertEquals(\"item1\", order.getItem().getName());\n        Assert.assertEquals(\"the item 1.\", order.getItem().getDescription());\n        Assert.assertEquals(1, order.getItem().getOrders().size());\n        Assert.assertTrue(row[1] instanceof Item2);\n        final Item2 item = (Item2) row[1];\n        Assert.assertTrue(this.em().contains(item));\n        Assert.assertEquals(\"item1\", item.getName());\n        Assert.assertEquals(\"the item 1.\", item.getDescription());\n        //\n        Assert.assertEquals(1, item.getOrders().size());\n        //\n    }\n}", "repo_id": "1", "comment": "/**\n * test for attribute with IdClass in native query\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2326, "method_signature": "void testIdClassNativeQuery()"}, "NativeQueryTest.testNamedNativeQuery": {"callee_method_names": ["Query.getResultList"], "method_name": "NativeQueryTest.testNamedNativeQuery", "method_implementation": "{\n    final Item i1 = new Item(\"item1\", \"the item 1.\");\n    final Order o1 = new Order(30, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = this.em().createNamedQuery(\"namedNativeQuery1\").setParameter(1, 5);\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * test Simple named native query\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2327, "method_signature": "void testNamedNativeQuery()"}, "NativeQueryTest.testNamedNativeQuery2": {"callee_method_names": ["Query.getResultList"], "method_name": "NativeQueryTest.testNamedNativeQuery2", "method_implementation": "{\n    final Item i1 = new Item(\"item1\", \"the item 1.\");\n    final Order o1 = new Order(20, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = this.em().createNamedQuery(\"namedNativeQuery2\").setParameter(1, 5);\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * Simple single entity named native query test\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2328, "method_signature": "void testNamedNativeQuery2()"}, "NativeQueryTest.testNamedNativeQuery3": {"callee_method_names": ["Query.getResultList"], "method_name": "NativeQueryTest.testNamedNativeQuery3", "method_implementation": "{\n    final Item i1 = new Item(\"item1\", \"the item 1.\");\n    final Order o1 = new Order(30, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = this.em().createNamedQuery(\"namedNativeQuery3\").setParameter(1, 5);\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * test Simple named native query in orm.xml\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2329, "method_signature": "void testNamedNativeQuery3()"}, "NativeQueryTest.testSimpleMultiSelectWithParameters": {"callee_method_names": ["Query.getResultList", "Query.getResultList", "Order.getQuantity", "Order.getItem", "Order.getItem", "Order.getItem", "Item.getName", "Item.getDescription", "Item.getOrders"], "method_name": "NativeQueryTest.testSimpleMultiSelectWithParameters", "method_implementation": "{\n    final Item i1 = new Item(\"item1\", \"the item 1.\");\n    final Order o1 = new Order(30, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = //\n    this.em().//\n    createNativeQuery(//\n    \"SELECT o.id, \" + //\n    \"o.quantity, \" + //\n    \"o.item_id, \" + //\n    \"i.id, 'itemX' as name, i.description \" + //\n    \"FROM ORDER_T o, Item i \" + \"WHERE (o.quantity > ?) AND (o.item_id = i.id)\", \"OrderItemResults\").setParameter(1, 5);\n    final List<?> resultList = q.getResultList();\n    Assert.assertEquals(1, q.getResultList().size());\n    for (final Object oArr : resultList) {\n        final Object[] row = (Object[]) oArr;\n        Assert.assertTrue(row[0] instanceof Order);\n        final Order order = (Order) row[0];\n        Assert.assertTrue(this.em().contains(order));\n        Assert.assertEquals(30, order.getQuantity().intValue());\n        Assert.assertEquals(\"itemX\", order.getItem().getName());\n        Assert.assertEquals(\"the item 1.\", order.getItem().getDescription());\n        Assert.assertEquals(1, order.getItem().getOrders().size());\n        Assert.assertTrue(row[1] instanceof Item);\n        final Item item = (Item) row[1];\n        Assert.assertTrue(this.em().contains(item));\n        Assert.assertEquals(\"itemX\", item.getName());\n        Assert.assertEquals(\"the item 1.\", item.getDescription());\n        Assert.assertEquals(1, item.getOrders().size());\n    }\n}", "repo_id": "1", "comment": "/**\n * test Simple Multi entity native query\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2331, "method_signature": "void testSimpleMultiSelectWithParameters()"}, "NativeQueryTest.testSimpleMultipleSelect": {"callee_method_names": ["Query.getResultList", "Query.getResultList", "Order.getQuantity", "Order.getItem", "Order.getItem", "Order.getItem", "Item.getName", "Item.getDescription", "Item.getOrders"], "method_name": "NativeQueryTest.testSimpleMultipleSelect", "method_implementation": "{\n    final Item _item = new Item(\"item1\", \"the item 1.\");\n    final Order _order = new Order(30, _item);\n    this.persist(_order);\n    this.commit();\n    this.close();\n    final Query q = this.em().createNativeQuery(//\n    \"SELECT o.id AS order_id, \" + //\n    \"49 AS order_quantity, \" + //\n    \"o.item_id AS order_item, \" + //\n    \"i.id, 'itemX' as name, i.description \" + //\n    \"FROM ORDER_T o, Item i \" + \"WHERE (o.quantity > 5) AND (o.item_id = i.id)\", \"OrderItemResults2\");\n    final List<?> resultList = q.getResultList();\n    Assert.assertEquals(1, q.getResultList().size());\n    for (final Object oArr : resultList) {\n        final Object[] row = (Object[]) oArr;\n        Assert.assertTrue(row[0] instanceof Order);\n        final Order order = (Order) row[0];\n        Assert.assertTrue(this.em().contains(order));\n        Assert.assertEquals(49, order.getQuantity().intValue());\n        Assert.assertEquals(\"itemX\", order.getItem().getName());\n        Assert.assertEquals(\"the item 1.\", order.getItem().getDescription());\n        Assert.assertEquals(1, order.getItem().getOrders().size());\n        Assert.assertTrue(row[1] instanceof Item);\n        final Item item = (Item) row[1];\n        Assert.assertTrue(this.em().contains(item));\n        Assert.assertEquals(\"itemX\", item.getName());\n        Assert.assertEquals(\"the item 1.\", item.getDescription());\n        Assert.assertEquals(1, item.getOrders().size());\n    }\n}", "repo_id": "1", "comment": "/**\n * Simple Multi entity native query test\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2330, "method_signature": "void testSimpleMultipleSelect()"}, "NativeQueryTest.testSingleEntityWithParameters": {"callee_method_names": ["Query.getResultList", "Query.getResultList", "Order.getQuantity", "Order.getItem", "Order.getItem"], "method_name": "NativeQueryTest.testSingleEntityWithParameters", "method_implementation": "{\n    final Item i1 = new Item(\"item1\", \"the item 1.\");\n    final Order o1 = new Order(20, i1);\n    this.persist(o1);\n    this.commit();\n    this.close();\n    final Query q = //\n    this.em().//\n    createNativeQuery(//\n    \"SELECT o.id, \" + //\n    \"49 as quantity, \" + //\n    \"o.item_id, \" + //\n    \"i.id, 'itemX' as name, i.description \" + //\n    \"FROM ORDER_T o, Item i \" + \"WHERE (o.quantity > ? OR o.quantity > ?) AND (o.item_id = i.id)\", //\n    Order.class).// .setParameter(1, 5)//\n    setParameter(2, 5);\n    final List<?> resultList = q.getResultList();\n    Assert.assertEquals(1, q.getResultList().size());\n    for (final Object row : resultList) {\n        Assert.assertTrue(row instanceof Order);\n        final Order order = (Order) row;\n        Assert.assertTrue(this.em().contains(order));\n        Assert.assertEquals(49, order.getQuantity().intValue());\n        Assert.assertEquals(\"item1\", order.getItem().getName());\n        Assert.assertEquals(\"the item 1.\", order.getItem().getDescription());\n    }\n}", "repo_id": "1", "comment": "/**\n * Simple single entity native query test\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2332, "method_signature": "void testSingleEntityWithParameters()"}, "NegationExpression.generateJpqlSelect": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "NegationExpression.generateJpqlSelect", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"-\");\n    if (!(this.inner instanceof BasicPath)) {\n        builder.append(\"(\").append(this.inner.generateJpqlRestriction(query)).append(\")\");\n    } else {\n        builder.append(this.inner.generateJpqlRestriction(query));\n    }\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        builder.append(\" as \").append(this.getAlias());\n    }\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 667, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "NegationExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "NegationExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (this.inner instanceof BasicPath) {\n        if (selected) {\n            return \"-\" + this.inner.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n        }\n        return \"-\" + this.inner.getSqlRestrictionFragments(query)[0];\n    }\n    if (selected) {\n        return \"-\" + this.inner.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return \"-\" + this.inner.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 668, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "NegationExpression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "NegationExpression.handle", "method_implementation": "{\n    final N value = (N) row.getObject(this.alias);\n    return (N) (this.getConverter() != null ? this.getConverter().convert(value) : value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 669, "method_signature": "N handle(QueryImpl, SessionImpl, ResultSet)"}, "NullIfExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "NullIfExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 582, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "NullIfExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "NullIfExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 583, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "NullIfExpression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "NullIfExpression.handle", "method_implementation": "{\n    return (T) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 584, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "NumericFunctionExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "NumericFunctionExpression.generateJpqlRestriction", "method_implementation": "{\n    final String xExpr = this.x.generateJpqlRestriction(query);\n    final String yExpr = this.y != null ? this.y.generateJpqlRestriction(query) : null;\n    return MessageFormat.format(this.type.getJpqlFragment(), xExpr, yExpr);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 618, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "NumericFunctionExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "NumericFunctionExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 619, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "NumericFunctionExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "NumericFunctionExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 620, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "NumericFunctionExpression.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.getJdbcAdaptor"], "method_name": "NumericFunctionExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final String xExpr = this.x.getSqlRestrictionFragments(query)[0];\n    final String yExpr = this.y != null ? this.y.getSqlRestrictionFragments(query)[0] : null;\n    return new String[] { MessageFormat.format(query.getJdbcAdaptor().getNumericFunctionTemplate(this.type), xExpr, yExpr) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 621, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "NumericFunctionExpression.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "NumericFunctionExpression.handle", "method_implementation": "{\n    return (N) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 622, "method_signature": "N handle(QueryImpl, SessionImpl, ResultSet)"}, "ObjectUtils.addObjectToArray": {"callee_method_names": ["A[].getClass", "O.getClass"], "method_name": "ObjectUtils.addObjectToArray", "method_implementation": "{\n    Class<?> compType = Object.class;\n    if (array != null) {\n        compType = array.getClass().getComponentType();\n    } else if (obj != null) {\n        compType = obj.getClass();\n    }\n    final int newArrLength = (array != null ? array.length + 1 : 1);\n    @SuppressWarnings(\"unchecked\")\n    final A[] newArr = (A[]) Array.newInstance(compType, newArrLength);\n    if (array != null) {\n        System.arraycopy(array, 0, newArr, 0, array.length);\n    }\n    newArr[newArr.length - 1] = obj;\n    return newArr;\n}", "repo_id": "1", "comment": "/**\n * Append the given object to the given array, returning a new array consisting of the input array contents plus the given object.\n *\n * @param array\n *            the array to append to (can be <code>null</code>)\n * @param obj\n *            the object to append\n * @return the new array (of the same component type; never <code>null</code>)\n * @param <A>\n *            the type of the array\n * @param <O>\n *            the type of the object\n */\n", "repo_name": "BatooJPA-master/", "id": 76, "method_signature": "A[] addObjectToArray(A[], O)"}, "ObjectUtils.caseInsensitiveValueOf": {"callee_method_names": ["E[].getClass"], "method_name": "ObjectUtils.caseInsensitiveValueOf", "method_implementation": "{\n    for (final E candidate : enumValues) {\n        if (candidate.toString().equalsIgnoreCase(constant)) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"constant [%s] does not exist in enum type %s\", constant, enumValues.getClass().getComponentType().getName()));\n}", "repo_id": "1", "comment": "/**\n * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.\n *\n * @param <E>\n *            the concrete Enum type\n * @param enumValues\n *            the array of all Enum constants in question, usually per Enum.values()\n * @param constant\n *            the constant to get the enum value of\n * @return the type of the array\n * @throws IllegalArgumentException\n *             if the given constant is not found in the given array of enum values. Use {@link #containsConstant(Enum[], String)} as a\n *             guard to avoid this exception.\n */\n", "repo_name": "BatooJPA-master/", "id": 77, "method_signature": "E caseInsensitiveValueOf(E[], String)"}, "ObjectUtils.containsConstant": {"callee_method_names": [], "method_name": "ObjectUtils.containsConstant", "method_implementation": "{\n    for (final Enum<?> candidate : enumValues) {\n        if (caseSensitive ? candidate.toString().equals(constant) : candidate.toString().equalsIgnoreCase(constant)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Check whether the given array of enum constants contains a constant with the given name.\n *\n * @param enumValues\n *            the enum values to check, typically the product of a call to MyEnum.values()\n * @param constant\n *            the constant name to find (must not be null or empty string)\n * @param caseSensitive\n *            whether case is significant in determining a match\n * @return whether the constant has been found in the given array\n */\n", "repo_name": "BatooJPA-master/", "id": 78, "method_signature": "boolean containsConstant(Enum<?>[], String, boolean)"}, "ObjectUtils.containsElement": {"callee_method_names": [], "method_name": "ObjectUtils.containsElement", "method_implementation": "{\n    if (array == null) {\n        return false;\n    }\n    for (final Object arrayEle : array) {\n        if (ObjectUtils.nullSafeEquals(arrayEle, element)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Check whether the given array contains the given element.\n *\n * @param array\n *            the array to check (may be <code>null</code>, in which case the return value will always be <code>false</code>)\n * @param element\n *            the element to check for\n * @return whether the element has been found in the given array\n */\n", "repo_name": "BatooJPA-master/", "id": 79, "method_signature": "boolean containsElement(Object[], Object)"}, "ObjectUtils.getDisplayString": {"callee_method_names": [], "method_name": "ObjectUtils.getDisplayString", "method_implementation": "{\n    if (obj == null) {\n        return ObjectUtils.EMPTY_STRING;\n    }\n    return ObjectUtils.nullSafeToString(obj);\n}", "repo_id": "1", "comment": "/**\n * Return a content-based String representation if <code>obj</code> is not <code>null</code>; otherwise returns an empty String.\n * <p>\n * Differs from {@link #nullSafeToString(Object)} in that it returns an empty String rather than \"null\" for a <code>null</code> value.\n *\n * @param obj\n *            the object to build a display String for\n * @return a display String representation of <code>obj</code>\n * @see #nullSafeToString(Object)\n */\n", "repo_name": "BatooJPA-master/", "id": 80, "method_signature": "String getDisplayString(Object)"}, "ObjectUtils.identityToString": {"callee_method_names": ["Object.getClass"], "method_name": "ObjectUtils.identityToString", "method_implementation": "{\n    if (obj == null) {\n        return ObjectUtils.EMPTY_STRING;\n    }\n    return obj.getClass().getName() + \"@\" + ObjectUtils.getIdentityHexString(obj);\n}", "repo_id": "1", "comment": "/**\n * Return a String representation of an object's overall identity.\n *\n * @param obj\n *            the object (may be <code>null</code>)\n * @return the object's identity as String representation, or an empty String if the object was <code>null</code>\n */\n", "repo_name": "BatooJPA-master/", "id": 81, "method_signature": "String identityToString(Object)"}, "ObjectUtils.isCompatibleWithThrowsClause": {"callee_method_names": ["Class<?>[].isAssignableFrom", "Throwable.getClass"], "method_name": "ObjectUtils.isCompatibleWithThrowsClause", "method_implementation": "{\n    if (!ObjectUtils.isCheckedException(ex)) {\n        return true;\n    }\n    if (declaredExceptions != null) {\n        int i = 0;\n        while (i < declaredExceptions.length) {\n            if (declaredExceptions[i].isAssignableFrom(ex.getClass())) {\n                return true;\n            }\n            i++;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Check whether the given exception is compatible with the exceptions declared in a throws clause.\n *\n * @param ex\n *            the exception to checked\n * @param declaredExceptions\n *            the exceptions declared in the throws clause\n * @return whether the given exception is compatible\n */\n", "repo_name": "BatooJPA-master/", "id": 82, "method_signature": "boolean isCompatibleWithThrowsClause(Throwable, Class<?>[])"}, "ObjectUtils.nullSafeEquals": {"callee_method_names": ["Object.equals", "Object.getClass", "Object.getClass"], "method_name": "ObjectUtils.nullSafeEquals", "method_implementation": "{\n    if (o1 == o2) {\n        return true;\n    }\n    if ((o1 == null) || (o2 == null)) {\n        return false;\n    }\n    if (o1.equals(o2)) {\n        return true;\n    }\n    if (o1.getClass().isArray() && o2.getClass().isArray()) {\n        if ((o1 instanceof Object[]) && (o2 instanceof Object[])) {\n            return Arrays.equals((Object[]) o1, (Object[]) o2);\n        }\n        if ((o1 instanceof boolean[]) && (o2 instanceof boolean[])) {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if ((o1 instanceof byte[]) && (o2 instanceof byte[])) {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if ((o1 instanceof char[]) && (o2 instanceof char[])) {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if ((o1 instanceof double[]) && (o2 instanceof double[])) {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if ((o1 instanceof float[]) && (o2 instanceof float[])) {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if ((o1 instanceof int[]) && (o2 instanceof int[])) {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if ((o1 instanceof long[]) && (o2 instanceof long[])) {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if ((o1 instanceof short[]) && (o2 instanceof short[])) {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Determine if the given objects are equal, returning <code>true</code> if both are <code>null</code> or <code>false</code> if only one\n * is <code>null</code>.\n * <p>\n * Compares arrays with <code>Arrays.equals</code>, performing an equality check based on the array elements rather than the array\n * reference.\n *\n * @param o1\n *            first Object to compare\n * @param o2\n *            second Object to compare\n * @return whether the given objects are equal\n * @see java.util.Arrays#equals\n */\n", "repo_name": "BatooJPA-master/", "id": 83, "method_signature": "boolean nullSafeEquals(Object, Object)"}, "ObjectUtils.nullSafeHashCode": {"callee_method_names": [], "method_name": "ObjectUtils.nullSafeHashCode", "method_implementation": "{\n    if (array == null) {\n        return 0;\n    }\n    int hash = ObjectUtils.INITIAL_HASH;\n    final int arraySize = array.length;\n    for (int i = 0; i < arraySize; i++) {\n        hash = (ObjectUtils.MULTIPLIER * hash) + array[i];\n    }\n    return hash;\n}", "repo_id": "1", "comment": "/**\n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n *\n * @param array\n *            the array value\n * @return the hash code\n */\n", "repo_name": "BatooJPA-master/", "id": 93, "method_signature": "int nullSafeHashCode(short[])"}, "ObjectUtils.nullSafeToString": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ObjectUtils.nullSafeToString", "method_implementation": "{\n    if (array == null) {\n        return ObjectUtils.NULL_STRING;\n    }\n    final int length = array.length;\n    if (length == 0) {\n        return ObjectUtils.EMPTY_ARRAY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < length; i++) {\n        if (i == 0) {\n            sb.append(ObjectUtils.ARRAY_START);\n        } else {\n            sb.append(ObjectUtils.ARRAY_ELEMENT_SEPARATOR);\n        }\n        sb.append(array[i]);\n    }\n    sb.append(ObjectUtils.ARRAY_END);\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Return a String representation of the contents of the specified array.\n * <p>\n * The String representation consists of a list of the array's elements, enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements\n * are separated by the characters <code>\", \"</code> (a comma followed by a space). Returns <code>\"null\"</code> if <code>array</code> is\n * <code>null</code>.\n *\n * @param array\n *            the array to build a String representation for\n * @return a String representation of <code>array</code>\n */\n", "repo_name": "BatooJPA-master/", "id": 103, "method_signature": "String nullSafeToString(short[])"}, "ObjectUtils.toObjectArray": {"callee_method_names": ["Object.getClass"], "method_name": "ObjectUtils.toObjectArray", "method_implementation": "{\n    if (source instanceof Object[]) {\n        return (Object[]) source;\n    }\n    if (source == null) {\n        return new Object[0];\n    }\n    if (!source.getClass().isArray()) {\n        throw new IllegalArgumentException(\"Source is not an array: \" + source);\n    }\n    final int length = Array.getLength(source);\n    if (length == 0) {\n        return new Object[0];\n    }\n    final Class<?> wrapperType = Array.get(source, 0).getClass();\n    final Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);\n    for (int i = 0; i < length; i++) {\n        newArray[i] = Array.get(source, i);\n    }\n    return newArray;\n}", "repo_id": "1", "comment": "/**\n * Convert the given array (which may be a primitive array) to an object array (if necessary of primitive wrapper objects).\n * <p>\n * A <code>null</code> source value will be converted to an empty Object array.\n *\n * @param source\n *            the (potentially primitive) array\n * @return the corresponding object array (never <code>null</code>)\n * @throws IllegalArgumentException\n *             if the parameter is not an array\n */\n", "repo_name": "BatooJPA-master/", "id": 104, "method_signature": "Object[] toObjectArray(Object)"}, "OneToManyAttributeElement.generate": {"callee_method_names": [], "method_name": "OneToManyAttributeElement.generate", "method_implementation": "{\n    super.generate();\n    this.orphanRemoval = this.getAttribute(ElementConstants.ATTR_ORPHAN_REMOVAL, Boolean.FALSE);\n    this.mappedBy = this.getAttribute(ElementConstants.ATTR_MAPPED_BY, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1097, "method_signature": "void generate()"}, "OneToManyAttributeElement.handleChild": {"callee_method_names": [], "method_name": "OneToManyAttributeElement.handleChild", "method_implementation": "{\n    super.handleChild(child);\n    if (child instanceof PrimaryKeyJoinColumnElement) {\n        this.primaryKeyJoinColumns.add((PrimaryKeyJoinColumnMetadata) child);\n    }\n    if (child instanceof MapKeyElement) {\n        this.mapKey = ((MapKeyElement) child).getName();\n    }\n    if (child instanceof MapKeyAttributeOverrideElement) {\n        this.mapKeyAttributeOverrides.add((AttributeOverrideElement) child);\n    }\n    if (child instanceof MapKeyClassElement) {\n        this.mapKeyClassName = ((MapKeyClassElement) child).getClazz();\n    }\n    if (child instanceof MapKeyColumnElement) {\n        this.mapKeyColumn = (ColumnMetadata) child;\n    }\n    if (child instanceof MapKeyEnumeratedElement) {\n        this.mapKeyEnumType = ((MapKeyEnumeratedElement) child).getEnumType();\n    }\n    if (child instanceof MapKeyTemporalElement) {\n        this.mapKeyTemporalType = ((MapKeyTemporalElement) child).getTemporalType();\n    }\n    if (child instanceof OrderByElement) {\n        this.orderBy = ((OrderByElement) child).getOrderBy();\n    }\n    if (child instanceof OrderColumnElement) {\n        this.orderColumn = ((OrderColumnElement) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1098, "method_signature": "void handleChild(Element)"}, "OneToManyMethodTest.testFind": {"callee_method_ids": [2454, 2455, 2455], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses", "Person.getPhones", "Person.getPhones"], "method_name": "OneToManyMethodTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n    Assert.assertEquals(person.getPhones().size(), person2.getPhones().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2457, "method_signature": "void testFind()"}, "OneToManyMethodTest.testFindInSession": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "OneToManyMethodTest.testFindInSession", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2458, "method_signature": "void testFindInSession()"}, "OneToManyMethodTest.testRemove": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "OneToManyMethodTest.testRemove", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    this.remove(person);\n    this.commit();\n    this.close();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2459, "method_signature": "void testRemove()"}, "OneToManyTest.testFind": {"callee_method_ids": [2454, 2455, 2455], "callee_method_names": ["Person.getId", "Person.getName", "Person.getName", "Person.getAddresses", "Person.getAddresses", "Person.getPhones", "Person.getPhones"], "method_name": "OneToManyTest.testFind", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getName(), person2.getName());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n    Assert.assertEquals(person.getPhones().size(), person2.getPhones().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2145, "method_signature": "void testFind()"}, "OneToManyTest.testFindInSession": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "OneToManyTest.testFindInSession", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2146, "method_signature": "void testFindInSession()"}, "OneToManyTest.testRemove": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId"], "method_name": "OneToManyTest.testRemove", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    this.remove(person);\n    this.commit();\n    this.close();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2147, "method_signature": "void testRemove()"}, "OneToOneAttributeElement.generate": {"callee_method_names": [], "method_name": "OneToOneAttributeElement.generate", "method_implementation": "{\n    super.generate();\n    this.orphanRemoval = this.getAttribute(ElementConstants.ATTR_ORPHAN_REMOVAL, Boolean.FALSE);\n    this.optional = this.getAttribute(ElementConstants.ATTR_OPTIONAL, Boolean.TRUE);\n    this.mappedBy = this.getAttribute(ElementConstants.ATTR_MAPPED_BY, ElementConstants.EMPTY);\n    this.mapsId = this.getAttribute(ElementConstants.ATTR_MAPS_ID);\n    this.id = this.getAttribute(ElementConstants.ATTR_ID, Boolean.FALSE);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1099, "method_signature": "void generate()"}, "OneToOneAttributeElement.handleChild": {"callee_method_names": [], "method_name": "OneToOneAttributeElement.handleChild", "method_implementation": "{\n    super.handleChild(child);\n    if (child instanceof PrimaryKeyJoinColumnElement) {\n        this.primaryKeyJoinColumns.add((PrimaryKeyJoinColumnMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1100, "method_signature": "void handleChild(Element)"}, "OneToOneTest.testFind": {"callee_method_names": ["Employee.getId", "Employee.getId", "Employee.getId"], "method_name": "OneToOneTest.testFind", "method_implementation": "{\n    final Employee employee = new Employee(\"Ceylan\");\n    this.persist(employee);\n    this.commit();\n    this.close();\n    final Employee employee2 = this.find(Employee.class, employee.getId());\n    Assert.assertEquals(employee.getId(), employee2.getId());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2441, "method_signature": "void testFind()"}, "OneToOneTest.testFindInSession": {"callee_method_names": ["Employee.getId"], "method_name": "OneToOneTest.testFindInSession", "method_implementation": "{\n    final Employee person = new Employee(\"Ceylan\");\n    this.persist(person);\n    this.commit();\n    final Employee person2 = this.find(Employee.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2442, "method_signature": "void testFindInSession()"}, "OneToOneTest.testPersist": {"callee_method_names": ["Employee.setAssignedCubicle"], "method_name": "OneToOneTest.testPersist", "method_implementation": "{\n    Assert.assertEquals(2, this.em().getMetamodel().getEntities().size());\n    final Cubicle cubicle = new Cubicle();\n    this.persist(cubicle);\n    final Employee employee = new Employee(\"Ceylan\");\n    employee.setAssignedCubicle(cubicle);\n    this.persist(employee);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} Parent which cascades to Cubicle.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2443, "method_signature": "void testPersist()"}, "OneToOneToOneTest.testFind": {"callee_method_names": ["Employee.getId", "Employee.getId", "Employee.getId"], "method_name": "OneToOneToOneTest.testFind", "method_implementation": "{\n    final Employee employee = new Employee(\"Ceylan\");\n    this.persist(employee);\n    this.commit();\n    this.close();\n    final Employee employee2 = this.find(Employee.class, employee.getId());\n    Assert.assertEquals(employee.getId(), employee2.getId());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2256, "method_signature": "void testFind()"}, "OneToOneToOneTest.testFindInSession": {"callee_method_names": ["Employee.getId"], "method_name": "OneToOneToOneTest.testFindInSession", "method_implementation": "{\n    final Employee person = new Employee(\"Ceylan\");\n    this.persist(person);\n    this.commit();\n    final Employee person2 = this.find(Employee.class, person.getId());\n    Assert.assertSame(person, person2);\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person that is in the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2257, "method_signature": "void testFindInSession()"}, "OneToOneToOneTest.testPersist": {"callee_method_names": ["Employee.setAssignedCubicle"], "method_name": "OneToOneToOneTest.testPersist", "method_implementation": "{\n    Assert.assertEquals(2, this.em().getMetamodel().getEntities().size());\n    final Cubicle cubicle = new Cubicle();\n    this.persist(cubicle);\n    final Employee employee = new Employee(\"Ceylan\");\n    employee.setAssignedCubicle(cubicle);\n    this.persist(employee);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} Parent which cascades to Child1.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2258, "method_signature": "void testPersist()"}, "OptimisticLockIncrementTest.testOptimisticLockRemove": {"callee_method_names": ["EntityManager.getTransaction", "EntityTransaction.begin", "EntityManager.find", "Foo.getId", "EntityManager.remove", "EntityTransaction.commit", "Foo.setValue", "EntityManager.close"], "method_name": "OptimisticLockIncrementTest.testOptimisticLockRemove", "method_implementation": "{\n    Foo foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    foo = this.merge(foo);\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        em2.remove(foo2);\n        tx2.commit();\n        foo.setValue(\"test3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2240, "method_signature": "void testOptimisticLockRemove()"}, "OptimisticLockIncrementTest.testOptimisticLockUpdate": {"callee_method_names": ["EntityManager.getTransaction", "EntityTransaction.begin", "EntityManager.find", "Foo.getId", "Foo.setValue", "EntityTransaction.commit", "Foo.setValue", "EntityManager.close"], "method_name": "OptimisticLockIncrementTest.testOptimisticLockUpdate", "method_implementation": "{\n    Foo foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    foo = this.merge(foo);\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        foo2.setValue(\"test2\");\n        tx2.commit();\n        foo.setValue(\"test3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2241, "method_signature": "void testOptimisticLockUpdate()"}, "OptimisticLockIncrementTest.testOptimisticLockUpdateChild": {"callee_method_names": ["EntityManager.getTransaction", "EntityTransaction.begin", "EntityManager.find", "Foo.getId", "Foo.getBars", "EntityTransaction.commit", "Foo.getBars", "EntityManager.close"], "method_name": "OptimisticLockIncrementTest.testOptimisticLockUpdateChild", "method_implementation": "{\n    Foo foo = this.newFoo(true);\n    this.persist(foo);\n    this.commit();\n    foo = this.merge(foo);\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        foo2.getBars().get(0).setValue(\"barChangedValue\");\n        tx2.commit();\n        foo.getBars().get(0).setValue(\"barChangedValue2\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "// @Test(expected = PersistenceException.class)\n", "repo_name": "BatooJPA-master/", "id": 2242, "method_signature": "void testOptimisticLockUpdateChild()"}, "OptimisticLockIncrementTest.testOptimisticLockUpdateChildren": {"callee_method_names": ["EntityManager.getTransaction", "EntityTransaction.begin", "EntityManager.find", "Foo.getId", "EntityTransaction.commit", "EntityManager.close"], "method_name": "OptimisticLockIncrementTest.testOptimisticLockUpdateChildren", "method_implementation": "{\n    final Foo foo = this.newFoo(true);\n    this.persist(foo);\n    this.commit();\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        new Bar(foo2, \"barValue3\");\n        tx2.commit();\n        this.begin();\n        new Bar(foo, \"barValue3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2243, "method_signature": "void testOptimisticLockUpdateChildren()"}, "OptimisticLockTest.testOptimisticLockRemove": {"callee_method_names": ["EntityManager.find", "Foo.getId", "EntityManager.getTransaction", "EntityTransaction.begin", "EntityManager.remove", "EntityTransaction.commit", "Foo.setValue", "EntityManager.close"], "method_name": "OptimisticLockTest.testOptimisticLockRemove", "method_implementation": "{\n    Foo foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    foo = this.merge(foo);\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        em2.remove(foo2);\n        tx2.commit();\n        foo.setValue(\"test3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2235, "method_signature": "void testOptimisticLockRemove()"}, "OptimisticLockTest.testOptimisticLockRollback": {"callee_method_names": ["Foo.getId", "Foo.setValue", "EntityManager.getTransaction", "EntityManager.unwrap", "EntityTransaction.begin", "EntityManager.find", "Foo.getId", "Foo.setValue", "EntityTransaction.commit", "EntityManager.close"], "method_name": "OptimisticLockTest.testOptimisticLockRollback", "method_implementation": "{\n    Foo foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    foo.setValue(\"NewValue1\");\n    this.flush();\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        try {\n            final EntityTransaction tx2 = em2.getTransaction();\n            em2.unwrap(Connection.class).setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            tx2.begin();\n            final Foo foo2 = em2.find(Foo.class, foo.getId());\n            foo2.setValue(\"NewValue2\");\n            this.rollback();\n            tx2.commit();\n        } catch (final SQLException e) {\n            throw new RuntimeException(e);\n        }\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2236, "method_signature": "void testOptimisticLockRollback()"}, "OptimisticLockTest.testOptimisticLockUpdate": {"callee_method_names": ["EntityManager.find", "Foo.getId", "EntityManager.getTransaction", "EntityTransaction.begin", "Foo.setValue", "EntityTransaction.commit", "Foo.setValue", "EntityManager.close"], "method_name": "OptimisticLockTest.testOptimisticLockUpdate", "method_implementation": "{\n    Foo foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    foo = this.merge(foo);\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        foo2.setValue(\"test2\");\n        tx2.commit();\n        foo.setValue(\"test3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2237, "method_signature": "void testOptimisticLockUpdate()"}, "OptimisticLockTest.testOptimisticLockUpdateChild": {"callee_method_names": ["EntityManager.find", "Foo.getId", "EntityManager.getTransaction", "EntityTransaction.begin", "Foo.getBars", "EntityTransaction.commit", "Foo.getBars", "EntityManager.close"], "method_name": "OptimisticLockTest.testOptimisticLockUpdateChild", "method_implementation": "{\n    Foo foo = this.newFoo(true);\n    this.persist(foo);\n    this.commit();\n    foo = this.merge(foo);\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        foo2.getBars().get(0).setValue(\"barChangedValue\");\n        tx2.commit();\n        foo.getBars().get(0).setValue(\"barChangedValue2\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "// @Test(expected = PersistenceException.class)\n", "repo_name": "BatooJPA-master/", "id": 2238, "method_signature": "void testOptimisticLockUpdateChild()"}, "OptimisticLockTest.testOptimisticLockUpdateChildren": {"callee_method_names": ["EntityManager.getTransaction", "EntityTransaction.begin", "EntityManager.find", "Foo.getId", "EntityTransaction.commit", "EntityManager.close"], "method_name": "OptimisticLockTest.testOptimisticLockUpdateChildren", "method_implementation": "{\n    final Foo foo = this.newFoo(true);\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        final Foo foo2 = em2.find(Foo.class, foo.getId());\n        new Bar(foo2, \"barValue3\");\n        tx2.commit();\n        this.begin();\n        new Bar(foo, \"barValue3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2239, "method_signature": "void testOptimisticLockUpdateChildren()"}, "OracleAdaptor.applyLikeEscape": {"callee_method_names": [], "method_name": "OracleAdaptor.applyLikeEscape", "method_implementation": "{\n    return \" ESCAPE \" + escapePattern;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1315, "method_signature": "String applyLikeEscape(String)"}, "OracleAdaptor.applyLock": {"callee_method_names": [], "method_name": "OracleAdaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1316, "method_signature": "String applyLock(String, LockModeType)"}, "OracleAdaptor.applyPagination": {"callee_method_names": [], "method_name": "OracleAdaptor.applyPagination", "method_implementation": "{\n    sql = BatooUtils.indent(sql);\n    sql = \"SELECT PAGING_RESULT_1.*, rownum ROW_NUM__INTERNAL FROM (\\n\" + sql + \"\\n) PAGING_RESULT_1 WHERE rownum <= ?\";\n    sql = BatooUtils.indent(sql);\n    sql = \"SELECT * FROM (\\n\" + sql + \"\\n) WHERE ROW_NUM__INTERNAL > ?\";\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1317, "method_signature": "String applyPagination(String, int, int)"}, "OracleAdaptor.applyTrim": {"callee_method_names": ["StringBuilder.append", "Trimspec.toString", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "OracleAdaptor.applyTrim", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"TRIM(\");\n    if ((trimspec != null) || (trimChar != null)) {\n        if (trimspec == null) {\n            trimspec = Trimspec.BOTH;\n        }\n        builder.append(trimspec.toString()).append(\" \");\n    }\n    if (trimChar != null) {\n        builder.append(trimChar).append(\" \");\n    }\n    if ((trimspec != null) || (trimChar != null)) {\n        builder.append(\"FROM \");\n    }\n    return builder.append(argument).append(\")\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1318, "method_signature": "String applyTrim(Trimspec, String, String)"}, "OracleAdaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable", "AbstractColumn.isUnique"], "method_name": "OracleAdaptor.createColumnDDL", "method_implementation": "{\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // not null part\n    (column.isUnique() ? \" UNIQUE\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1319, "method_signature": "String createColumnDDL(AbstractColumn)"}, "OracleAdaptor.createSequenceIfNecessary": {"callee_method_names": ["SequenceGenerator.getQName", "SequenceGenerator.getInitialValue", "SequenceGenerator.getAllocationSize", "SequenceGenerator.getName"], "method_name": "OracleAdaptor.createSequenceIfNecessary", "method_implementation": "{\n    final String sql = // ;\n    \"CREATE SEQUENCE \" + sequence.getQName() + \" START WITH \" + //\n    sequence.getInitialValue() + \" INCREMENT BY \" + sequence.getAllocationSize();\n    try {\n        new QueryRunner(datasource).update(sql);\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot create sequence \" + sequence.getName());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1320, "method_signature": "void createSequenceIfNecessary(DataSource, SequenceGenerator)"}, "OracleAdaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "OracleAdaptor.getColumnType", "method_implementation": "{\n    switch(sqlType) {\n        case Types.BLOB:\n            return \"BLOB\";\n        case Types.CLOB:\n            return \"NCLOB\";\n        case Types.VARCHAR:\n            return \"VARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n        case Types.DATE:\n            return \"DATE\";\n        case Types.TIMESTAMP:\n            return \"TIMESTAMP\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"NUMBER(1)\";\n        case Types.TINYINT:\n        case Types.SMALLINT:\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"NUMBER(19,0)\";\n        case Types.FLOAT:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DOUBLE:\n            return \"DOUBLE PRECISION\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"NUMBER\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1321, "method_signature": "String getColumnType(AbstractColumn, int)"}, "OracleAdaptor.getDropForeignKeySql": {"callee_method_names": [], "method_name": "OracleAdaptor.getDropForeignKeySql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(schema, table);\n    return \"ALTER TABLE \" + qualifiedName + \" DROP CONSTRAINT \" + foreignKey;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1322, "method_signature": "String getDropForeignKeySql(String, String, String)"}, "OracleAdaptor.getNextSequence": {"callee_method_names": [], "method_name": "OracleAdaptor.getNextSequence", "method_implementation": "{\n    return //\n    new QueryRunner(datasource).query(\"SELECT \" + sequenceName + \".NEXTVAL FROM DUAL\", new SingleValueHandler<Number>()).longValue();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1323, "method_signature": "long getNextSequence(DataSource, String)"}, "OracleAdaptor.supports": {"callee_method_names": [], "method_name": "OracleAdaptor.supports", "method_implementation": "{\n    if (type == null) {\n        return IdType.SEQUENCE;\n    }\n    switch(type) {\n        case IDENTITY:\n            return IdType.SEQUENCE;\n        case SEQUENCE:\n            return IdType.SEQUENCE;\n        case TABLE:\n            return IdType.TABLE;\n        default:\n            return IdType.SEQUENCE;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1324, "method_signature": "IdType supports(GenerationType)"}, "OrderByTest.testOrderBy1": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getAddresses", "Person.getAddresses", "Address[].getId", "Address[].getId", "Person.getAddresses2"], "method_name": "OrderByTest.testOrderBy1", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final Address[] addresses = person.getAddresses().toArray(new Address[person.getAddresses().size()]);\n    for (int i = 1; i < addresses.length; i++) {\n        Assert.assertTrue(addresses[i].getId().intValue() > addresses[i - 1].getId().intValue());\n    }\n    final String addresses2 = Arrays.toString(person.getAddresses2().toArray());\n    Assert.assertEquals(\"[Address2 [city=paris, street=Street1], Address2 [city=paris, street=Street2], Address2 [city=paris, street=Street3], Address2 [city=new york, street=Broadway], Address2 [city=london, street=Street4], Address2 [city=london, street=Street5]]\", addresses2);\n}", "repo_id": "1", "comment": "/**\n * Tests list is sorted\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2202, "method_signature": "void testOrderBy1()"}, "OrderByTest.testOrderBy2": {"callee_method_ids": [2454, 2454], "callee_method_names": ["Person.getId", "Person.getId", "Person.getAddresses", "Person.getAddresses", "Address[].getId", "Address[].getId", "Person.getAddresses2"], "method_name": "OrderByTest.testOrderBy2", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    person = this.find(Person.class, person.getId());\n    this.begin();\n    new Address(person, \"Paris\");\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final Address[] addresses = person.getAddresses().toArray(new Address[person.getAddresses().size()]);\n    for (int i = 1; i < addresses.length; i++) {\n        Assert.assertTrue(addresses[i].getId().intValue() > addresses[i - 1].getId().intValue());\n    }\n    final String addresses2 = Arrays.toString(person.getAddresses2().toArray());\n    Assert.assertEquals(\"[Address2 [city=paris, street=Street1], Address2 [city=paris, street=Street2], Address2 [city=paris, street=Street3], Address2 [city=new york, street=Broadway], Address2 [city=london, street=Street4], Address2 [city=london, street=Street5]]\", addresses2);\n}", "repo_id": "1", "comment": "/**\n * Tests list is sorted\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2203, "method_signature": "void testOrderBy2()"}, "OrderColumnElement.generate": {"callee_method_names": [], "method_name": "OrderColumnElement.generate", "method_implementation": "{\n    super.generate();\n    this.length = this.getAttribute(ElementConstants.ATTR_LENGTH, 255);\n    this.precision = this.getAttribute(ElementConstants.ATTR_PRECISION, 0);\n    this.scale = this.getAttribute(ElementConstants.ATTR_SCALE, 0);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1081, "method_signature": "void generate()"}, "OrderColumnTest.testOrder1": {"callee_method_ids": [2454], "callee_method_names": ["Person.getAddresses", "Person.getId", "Person.getAddresses"], "method_name": "OrderColumnTest.testOrder1", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    final Object[] addresses1 = person.getAddresses().toArray();\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final Object[] addresses2 = person.getAddresses().toArray();\n    Assert.assertEquals(Arrays.toString(addresses1), Arrays.toString(addresses2));\n}", "repo_id": "1", "comment": "/**\n * Tests list order is maintained.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2183, "method_signature": "void testOrder1()"}, "OrderColumnTest.testOrder2": {"callee_method_ids": [2454, 2454], "callee_method_names": ["Person.getId", "Person.getAddresses", "Person.getAddresses", "Person.getAddresses", "Person.getId", "Person.getAddresses"], "method_name": "OrderColumnTest.testOrder2", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    this.begin();\n    final Address address = person.getAddresses().remove(0);\n    person.getAddresses().add(address);\n    new Address(person, \"Paris\");\n    final Object[] addresses1 = person.getAddresses().toArray();\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final Object[] addresses2 = person.getAddresses().toArray();\n    Assert.assertEquals(Arrays.toString(addresses1), Arrays.toString(addresses2));\n}", "repo_id": "1", "comment": "/**\n * Tests list is sorted\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2184, "method_signature": "void testOrder2()"}, "OrderTest.testOrder1": {"callee_method_ids": [2454], "callee_method_names": ["Person.getAddresses", "Person.getId", "Person.getAddresses"], "method_name": "OrderTest.testOrder1", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    final Object[] addresses1 = person.getAddresses().toArray();\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final Object[] addresses2 = person.getAddresses().toArray();\n    Assert.assertEquals(Arrays.toString(addresses1), Arrays.toString(addresses2));\n}", "repo_id": "1", "comment": "/**\n * Tests list order is maintained.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2204, "method_signature": "void testOrder1()"}, "OrderTest.testOrder2": {"callee_method_ids": [2454, 2454], "callee_method_names": ["Person.getId", "Person.getAddresses", "Person.getAddresses", "Person.getAddresses", "Person.getId", "Person.getAddresses"], "method_name": "OrderTest.testOrder2", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    this.begin();\n    final Address address = person.getAddresses().remove(0);\n    person.getAddresses().add(address);\n    new Address(person, \"Paris\");\n    final Object[] addresses1 = person.getAddresses().toArray();\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final Object[] addresses2 = person.getAddresses().toArray();\n    Arrays.sort(addresses1, new Comparator<Object>() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            return ((Address) o1).getId().compareTo(((Address) o2).getId());\n        }\n    });\n    Arrays.sort(addresses2, new Comparator<Object>() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            return ((Address) o1).getId().compareTo(((Address) o2).getId());\n        }\n    });\n    Assert.assertEquals(Arrays.toString(addresses1), Arrays.toString(addresses2));\n}", "repo_id": "1", "comment": "/**\n * Tests list is sorted\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2205, "method_signature": "void testOrder2()"}, "OrmContentHandler.characters": {"callee_method_names": ["String.startsWith", "String.substring", "String.length"], "method_name": "OrmContentHandler.characters", "method_implementation": "{\n    String cdata = new String(ch, start, length);\n    if (cdata.startsWith(\"![CDATA[\")) {\n        cdata = cdata.substring(8, cdata.length() - 2);\n    }\n    if (StringUtils.isNotBlank(cdata)) {\n        OrmContentHandler.LOG.trace(\"Element body {0}\", cdata);\n        this.elementStack.peek().cdata(cdata);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1089, "method_signature": "void characters(char[], int, int)"}, "OrmContentHandler.endElement": {"callee_method_ids": [1076], "callee_method_names": ["Element.end"], "method_name": "OrmContentHandler.endElement", "method_implementation": "{\n    OrmContentHandler.LOG.trace(\"End of element url: {0}, localName: {1}, qName: {2}\", uri, localName, qName);\n    final Element element = this.elementStack.pop();\n    element.end();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1090, "method_signature": "void endElement(String, String, String)"}, "OrmContentHandler.startElement": {"callee_method_names": ["Attributes.getLength", "Attributes.getLocalName", "Attributes.getValue", "Map<String, String>.put"], "method_name": "OrmContentHandler.startElement", "method_implementation": "{\n    final Map<String, String> attributes = Maps.newHashMap();\n    for (int i = 0; i < atts.getLength(); i++) {\n        final String name = atts.getLocalName(i);\n        final String value = atts.getValue(i);\n        attributes.put(name, value);\n    }\n    OrmContentHandler.LOG.trace(\"Start of element url: {0}, localName: {1}, qName: {2}, attributes: {3}\", uri, localName, qName, attributes);\n    // if stack is empty we are at the root of the document\n    if (this.elementStack.size() == 0) {\n        if (!ElementConstants.ELEMENT_ENTITY_MAPPINGS.equals(localName)) {\n            throw new MappingException(\"Unexpected element '\" + ElementConstants.ELEMENT_ENTITY_MAPPINGS + \"' encountered.\", new XmlLocator(this.fileName, localName, this.locator));\n        }\n        this.entityMappings = new EntityMappings(attributes);\n        this.elementStack.push(this.entityMappings);\n    } else // check if the element is expected\n    {\n        this.elementStack.peek().expected(localName, this.locator);\n        // push the new Element to the stack\n        final XmlLocator xmlLocator = new XmlLocator(this.fileName, localName, this.locator);\n        this.elementStack.push(Element.forElement(this.elementStack.peek(), attributes, xmlLocator));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1091, "method_signature": "void startElement(String, String, String, Attributes)"}, "OrmParser.consume": {"callee_method_names": [], "method_name": "OrmParser.consume", "method_implementation": "{\n    try {\n        this.reader.parse(new InputSource(is));\n    } catch (final Exception e) {\n        throw new BatooException(\"Unable to parse ORM XML File \" + this.fileName, e);\n    }\n}", "repo_id": "1", "comment": "/**\n * Consumes the ORM file with the given input stream.\n *\n * @param is\n *            the input stream\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1058, "method_signature": "void consume(InputStream)"}, "OrmXmlTest.testFind": {"callee_method_names": [], "method_name": "OrmXmlTest.testFind", "method_implementation": "{\n    this.persist(new E4(\"test-E1\"));\n    this.persist(new E4(\"test-E2\"));\n    this.commit();\n    this.close();\n    Assert.assertEquals(2, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM E4\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}\n *\n * @throws SQLException\n *             thrown in case of an error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2297, "method_signature": "void testFind()"}, "OrmXmlTest.testOrmXmlProcessed": {"callee_method_names": [], "method_name": "OrmXmlTest.testOrmXmlProcessed", "method_implementation": "{\n    Assert.assertEquals(0, new QueryRunner().query(this.em().getConnection(), \"SELECT COUNT(*) FROM cachedpdf\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests that the orm.xml is processed.\n *\n * @throws SQLException\n *             thrown in case of an error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2298, "method_signature": "void testOrmXmlProcessed()"}, "Pair.equals": {"callee_method_names": ["Object.getClass"], "method_name": "Pair.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final Pair<?, ?> other = (Pair<?, ?>) obj;\n    if (this.first == null) {\n        if (other.first != null) {\n            return false;\n        }\n    } else if (!this.first.equals(other.first)) {\n        return false;\n    }\n    if (this.second == null) {\n        if (other.second != null) {\n            return false;\n        }\n    } else if (!this.second.equals(other.second)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 118, "method_signature": "boolean equals(Object)"}, "Pair.hashCode": {"callee_method_names": [], "method_name": "Pair.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.first == null) ? 0 : this.first.hashCode());\n    result = (prime * result) + ((this.second == null) ? 0 : this.second.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 119, "method_signature": "int hashCode()"}, "ParameterExpressionImpl.ensureAlias": {"callee_method_names": ["BaseQueryImpl<?>.getAlias"], "method_name": "ParameterExpressionImpl.ensureAlias", "method_implementation": "{\n    if ((this.position == null) && !StringUtils.isBlank(this.getAlias())) {\n        this.named = true;\n    }\n    if ((this.position == null)) {\n        this.position = query.getAlias(this);\n        if (StringUtils.isBlank(this.getAlias())) {\n            this.alias(\"param\" + this.position);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 634, "method_signature": "void ensureAlias(BaseQueryImpl)"}, "ParameterExpressionImpl.generateJpqlRestriction": {"callee_method_names": [], "method_name": "ParameterExpressionImpl.generateJpqlRestriction", "method_implementation": "{\n    this.ensureAlias(query);\n    try {\n        final int positionNo = Integer.parseInt(this.getAlias());\n        return \"?\" + positionNo;\n    } catch (final Exception e) {\n    }\n    return \":\" + this.getAlias();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 635, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "ParameterExpressionImpl.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "ParameterExpressionImpl.generateSqlSelect", "method_implementation": "{\n    this.ensureAlias(query);\n    this.alias = query.getAlias((AbstractExpression<T>) this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 636, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "ParameterExpressionImpl.getParameterType": {"callee_method_names": [], "method_name": "ParameterExpressionImpl.getParameterType", "method_implementation": "{\n    return (Class<T>) this.getJavaType();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 637, "method_signature": "Class<T> getParameterType()"}, "ParameterExpressionImpl.handle": {"callee_method_names": ["QueryImpl<?>.getParameterValue"], "method_name": "ParameterExpressionImpl.handle", "method_implementation": "{\n    final T value = query.getParameterValue(this);\n    return (T) (this.getConverter() != null ? this.getConverter().convert(value) : value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 638, "method_signature": "T handle(QueryImpl, SessionImpl, ResultSet)"}, "ParentElement.join": {"callee_method_names": [], "method_name": "ParentElement.join", "method_implementation": "{\n    if ((elements1 == null) || (elements1.length == 0)) {\n        return elements2;\n    }\n    if ((elements2 == null) || (elements2.length == 0)) {\n        return elements1;\n    }\n    final String[] joined = new String[elements1.length + elements2.length];\n    for (int i = 0; i < elements1.length; i++) {\n        joined[i] = elements1[i];\n    }\n    for (int i = 0; i < elements2.length; i++) {\n        joined[i + elements1.length] = elements2[i];\n    }\n    return joined;\n}", "repo_id": "1", "comment": "/**\n * Returns the joint array of <code>elements1</code> and <code>elements2</code>.\n *\n * @param elements1\n *            the first array of elements\n * @param elements2\n *            the second array of elements\n * @return the joint array of <code>elements1</code> and <code>elements2</code>\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1121, "method_signature": "String[] join(String[], String[])"}, "ParentElement.toString": {"callee_method_names": [], "method_name": "ParentElement.toString", "method_implementation": "{\n    return //\n    new ToStringBuilder(this).excludeFieldNames(\"parent\", \"attributes\", //\n    \"expectedChildElements\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1122, "method_signature": "String toString()"}, "ParentPath.get": {"callee_method_names": ["AbstractMapping<? super X, ?, Y>.getAttribute", "AttributeImpl<? super X, Y>.isCollection"], "method_name": "ParentPath.get", "method_implementation": "{\n    // try to resolve from existing children\n    final AbstractExpression<Y> path = (AbstractExpression<Y>) this.children.get(name);\n    if (path != null) {\n        return (AbstractPath<Y>) path;\n    }\n    final AbstractMapping<? super X, ?, Y> mapping = this.getMapping(name);\n    final AttributeImpl<? super X, Y> attribute = (AttributeImpl<? super X, Y>) mapping.getAttribute();\n    if (attribute.isCollection()) {\n        throw new IllegalArgumentException(\"Cannot deference a plural attribute as path: \" + name);\n    }\n    return this.get((SingularAttribute<? super X, Y>) attribute);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 791, "method_signature": "AbstractPath<Y> get(String)"}, "ParentPath.getExpression": {"callee_method_names": ["AttributeImpl<? super X, Y>.isCollection"], "method_name": "ParentPath.getExpression", "method_implementation": "{\n    final AttributeImpl<? super X, Y> attribute = (AttributeImpl<? super X, Y>) this.getMapping(attributeName).getAttribute();\n    if (!attribute.isCollection()) {\n        return this.get((SingularAttributeImpl<? super X, Y>) attribute);\n    }\n    if (((PluralAttributeImpl<? super X, Y, ?>) attribute).getCollectionType() == CollectionType.MAP) {\n        return (AbstractExpression<Y>) this.get((MapAttributeImpl<? super X, Y, ?>) attribute);\n    }\n    return (AbstractExpression<Y>) this.get((PluralAttribute<? super X, C, Y>) attribute);\n}", "repo_id": "1", "comment": "/**\n * Returns the expression corresponding to the attribute name.\n *\n * @param attributeName\n *            the name of the attribute\n * @return the expression\n * @param <Y>\n *            the type of the path\n * @param <C>\n *            the element type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 792, "method_signature": "AbstractExpression<Y> getExpression(String)"}, "Persistence.createEntityManagerFactory": {"callee_method_names": ["PersistenceProviderResolver.getPersistenceProviders"], "method_name": "Persistence.createEntityManagerFactory", "method_implementation": "{\n    EntityManagerFactory emf = null;\n    final PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver();\n    final List<PersistenceProvider> providers = resolver.getPersistenceProviders();\n    for (final PersistenceProvider provider : providers) {\n        emf = provider.createEntityManagerFactory(persistenceUnitName, properties);\n        if (emf != null) {\n            break;\n        }\n    }\n    if (emf == null) {\n        throw new PersistenceException(\"No Persistence provider for EntityManager named \" + persistenceUnitName);\n    }\n    return emf;\n}", "repo_id": "1", "comment": "/**\n * Create and return an EntityManagerFactory for the named persistence unit using the given properties.\n *\n * @param persistenceUnitName\n *            the name of the persistence unit\n * @param properties\n *            Additional properties to use when creating the factory. The values of these properties override any values that may have\n *            been configured elsewhere.\n * @return the factory that creates EntityManagers configured according to the specified persistence unit.\n */\n", "repo_name": "BatooJPA-master/", "id": 2566, "method_signature": "EntityManagerFactory createEntityManagerFactory(String, Map)"}, "Persistence.getClazzs": {"callee_method_names": [], "method_name": "Persistence.getClazzs", "method_implementation": "{\n    if (clazzs == null) {\n        clazzs = new ArrayList<String>();\n    }\n    return this.clazzs;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the clazzs property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the clazzs property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getClazzs().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link String }\n */\n", "repo_name": "BatooJPA-master/", "id": 977, "method_signature": "List<String> getClazzs()"}, "Persistence.getJarFiles": {"callee_method_names": [], "method_name": "Persistence.getJarFiles", "method_implementation": "{\n    if (jarFiles == null) {\n        jarFiles = new ArrayList<String>();\n    }\n    return this.jarFiles;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the jarFiles property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the jarFiles property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getJarFiles().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link String }\n */\n", "repo_name": "BatooJPA-master/", "id": 976, "method_signature": "List<String> getJarFiles()"}, "Persistence.getMappingFiles": {"callee_method_names": [], "method_name": "Persistence.getMappingFiles", "method_implementation": "{\n    if (mappingFiles == null) {\n        mappingFiles = new ArrayList<String>();\n    }\n    return this.mappingFiles;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the mappingFiles property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the mappingFiles property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getMappingFiles().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link String }\n */\n", "repo_name": "BatooJPA-master/", "id": 975, "method_signature": "List<String> getMappingFiles()"}, "Persistence.getPersistenceUnits": {"callee_method_names": [], "method_name": "Persistence.getPersistenceUnits", "method_implementation": "{\n    if (persistenceUnits == null) {\n        persistenceUnits = new ArrayList<Persistence.PersistenceUnit>();\n    }\n    return this.persistenceUnits;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the persistenceUnits property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the persistenceUnits property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getPersistenceUnits().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link Persistence.PersistenceUnit }\n */\n", "repo_name": "BatooJPA-master/", "id": 973, "method_signature": "List<Persistence.PersistenceUnit> getPersistenceUnits()"}, "Persistence.getProperties": {"callee_method_names": [], "method_name": "Persistence.getProperties", "method_implementation": "{\n    if (properties == null) {\n        properties = new ArrayList<Persistence.PersistenceUnit.Properties.Property>();\n    }\n    return this.properties;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the properties property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the properties property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getProperties().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link Persistence.PersistenceUnit.Properties.Property }\n */\n", "repo_name": "BatooJPA-master/", "id": 978, "method_signature": "List<Persistence.PersistenceUnit.Properties.Property> getProperties()"}, "Persistence.getVersion": {"callee_method_names": [], "method_name": "Persistence.getVersion", "method_implementation": "{\n    if (version == null) {\n        return \"2.0\";\n    } else {\n        return version;\n    }\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the version property.\n *\n * @return\n *     possible object is\n *     {@link String }\n */\n", "repo_name": "BatooJPA-master/", "id": 974, "method_signature": "String getVersion()"}, "PersistenceActivator.start": {"callee_method_names": ["Hashtable<String, String>.put", "Hashtable<String, String>.put", "Hashtable<String, String>.put", "BundleContext.registerService"], "method_name": "PersistenceActivator.start", "method_implementation": "{\n    final Hashtable<String, String> props = new Hashtable<String, String>();\n    props.put(\"javax.persistence.provider\", org.batoo.jpa.core.BatooPersistenceProvider.class.getName());\n    props.put(\"javax.persistence.spi.PersistenceProvider\", org.batoo.jpa.core.BatooPersistenceProvider.class.getName());\n    props.put(\"javax.persistence.PersistenceProvider\", org.batoo.jpa.core.BatooPersistenceProvider.class.getName());\n    serviceReg = context.registerService(\"javax.persistence.spi.PersistenceProvider\", new org.batoo.jpa.core.BatooPersistenceProvider(), props);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 177, "method_signature": "void start(BundleContext)"}, "PersistenceActivator.stop": {"callee_method_names": ["ServiceRegistration.unregister"], "method_name": "PersistenceActivator.stop", "method_implementation": "{\n    if (null != serviceReg) {\n        serviceReg.unregister();\n        serviceReg = null;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 178, "method_signature": "void stop(BundleContext)"}, "PersistenceParserImpl.parseOrmXml": {"callee_method_ids": [1058], "callee_method_names": ["OrmParser.consume", "OrmParser.getMetadata"], "method_name": "PersistenceParserImpl.parseOrmXml", "method_implementation": "{\n    final InputStream is = this.puInfo.getClassLoader().getResourceAsStream(mappingFile);\n    if (is != null) {\n        final OrmParser ormParser = new OrmParser(mappingFile);\n        ormParser.consume(is);\n        this.metadata.merge(ormParser.getMetadata());\n        PersistenceParserImpl.LOG.debug(\"Merged ORM Metamodel {0}\", this.metadata);\n    } else if (!optional) {\n        PersistenceParserImpl.LOG.error(\"ORM Mapping file {0} could not be found!\", mappingFile);\n    }\n}", "repo_id": "1", "comment": "/**\n * Parses a single ORM XML File.\n *\n * @param mappingFile\n *            the name of the mapping file\n * @param optional\n *            if the file is optional\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 971, "method_signature": "void parseOrmXml(String, boolean)"}, "PersistenceParserImpl.parseOrmXmls": {"callee_method_names": [], "method_name": "PersistenceParserImpl.parseOrmXmls", "method_implementation": "{\n    if (this.ormMappingFiles.size() > 0) {\n        for (final String mappingFile : this.ormMappingFiles) {\n            this.parseOrmXml(mappingFile, false);\n        }\n    } else {\n        this.parseOrmXml(PersistenceParserImpl.ORM_XML, true);\n    }\n}", "repo_id": "1", "comment": "/**\n * Parses the ORM XML Files.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 972, "method_signature": "void parseOrmXmls()"}, "PersistenceProviderResolverHolder.addProviderNames": {"callee_method_names": ["URL.openStream", "BufferedReader.readLine", "String.trim", "Matcher.find", "Collection<ProviderName>.add", "Matcher.group", "InputStream.close"], "method_name": "PersistenceProviderResolverHolder.addProviderNames", "method_implementation": "{\n    InputStream in = null;\n    try {\n        in = url.openStream();\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            line = line.trim();\n            final Matcher m = DefaultPersistenceProviderResolver.nonCommentPattern.matcher(line);\n            if (m.find()) {\n                providerNames.add(new ProviderName(m.group().trim(), url));\n            }\n        }\n    } catch (final IOException ioe) {\n        throw new PersistenceException(\"IOException caught reading: \" + url, ioe);\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (final IOException e) {\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * For each services file look for uncommented provider names on each line.\n */\n", "repo_name": "BatooJPA-master/", "id": 2561, "method_signature": "void addProviderNames(URL, Collection)"}, "PersistenceProviderResolverHolder.getProviderNames": {"callee_method_names": ["ClassLoader.getResources", "Enumeration<URL>.hasMoreElements", "Enumeration<URL>.nextElement"], "method_name": "PersistenceProviderResolverHolder.getProviderNames", "method_implementation": "{\n    Enumeration<URL> resources = null;\n    try {\n        resources = loader.getResources(DefaultPersistenceProviderResolver.SERVICE_PROVIDER_FILE);\n    } catch (final IOException ioe) {\n        throw new PersistenceException(\"IOException caught: \" + loader + \".getResources(\" + DefaultPersistenceProviderResolver.SERVICE_PROVIDER_FILE + \")\", ioe);\n    }\n    final Collection<ProviderName> providerNames = new ArrayList<ProviderName>();\n    while (resources.hasMoreElements()) {\n        final URL url = resources.nextElement();\n        this.addProviderNames(url, providerNames);\n    }\n    return providerNames;\n}", "repo_id": "1", "comment": "/**\n * Locate all JPA provider services files and collect all of the provider names available.\n */\n", "repo_name": "BatooJPA-master/", "id": 2562, "method_signature": "Collection<ProviderName> getProviderNames(ClassLoader)"}, "PersistenceProviderResolverHolder.setPersistenceProviderResolver": {"callee_method_names": [], "method_name": "PersistenceProviderResolverHolder.setPersistenceProviderResolver", "method_implementation": "{\n    if (resolver == null) {\n        PersistenceProviderResolverHolder.singleton = new DefaultPersistenceProviderResolver();\n    } else {\n        PersistenceProviderResolverHolder.singleton = resolver;\n    }\n}", "repo_id": "1", "comment": "/**\n * Defines the persistence provider resolver used.\n *\n * @param resolver\n *            persistence provider resolver to be used.\n */\n", "repo_name": "BatooJPA-master/", "id": 2563, "method_signature": "void setPersistenceProviderResolver(PersistenceProviderResolver)"}, "PersistenceUnit.getClazzs": {"callee_method_names": [], "method_name": "PersistenceUnit.getClazzs", "method_implementation": "{\n    if (clazzs == null) {\n        clazzs = new ArrayList<String>();\n    }\n    return this.clazzs;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the clazzs property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the clazzs property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getClazzs().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link String }\n */\n", "repo_name": "BatooJPA-master/", "id": 981, "method_signature": "List<String> getClazzs()"}, "PersistenceUnit.getJarFiles": {"callee_method_names": [], "method_name": "PersistenceUnit.getJarFiles", "method_implementation": "{\n    if (jarFiles == null) {\n        jarFiles = new ArrayList<String>();\n    }\n    return this.jarFiles;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the jarFiles property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the jarFiles property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getJarFiles().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link String }\n */\n", "repo_name": "BatooJPA-master/", "id": 980, "method_signature": "List<String> getJarFiles()"}, "PersistenceUnit.getMappingFiles": {"callee_method_names": [], "method_name": "PersistenceUnit.getMappingFiles", "method_implementation": "{\n    if (mappingFiles == null) {\n        mappingFiles = new ArrayList<String>();\n    }\n    return this.mappingFiles;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the mappingFiles property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the mappingFiles property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getMappingFiles().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link String }\n */\n", "repo_name": "BatooJPA-master/", "id": 979, "method_signature": "List<String> getMappingFiles()"}, "PersistenceUnit.getProperties": {"callee_method_names": [], "method_name": "PersistenceUnit.getProperties", "method_implementation": "{\n    if (properties == null) {\n        properties = new ArrayList<Persistence.PersistenceUnit.Properties.Property>();\n    }\n    return this.properties;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the properties property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the properties property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getProperties().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link Persistence.PersistenceUnit.Properties.Property }\n */\n", "repo_name": "BatooJPA-master/", "id": 982, "method_signature": "List<Persistence.PersistenceUnit.Properties.Property> getProperties()"}, "PersistenceUnitDefaults.handleChild": {"callee_method_names": [], "method_name": "PersistenceUnitDefaults.handleChild", "method_implementation": "{\n    if (child instanceof AccessElement) {\n        this.accessType = ((AccessElement) child).getAccessType();\n    }\n    if (child instanceof CatalogElement) {\n        this.catalog = ((CatalogElement) child).getCatalog();\n    }\n    if (child instanceof SchemaElement) {\n        this.schema = ((SchemaElement) child).getSchema();\n    }\n    if (child instanceof CascadePersistElement) {\n        this.cascadePersist = true;\n    }\n    if (child instanceof EntityListenersElement) {\n        this.listeners.addAll(((EntityListenersElement) child).getListeners());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1092, "method_signature": "void handleChild(Element)"}, "PersistenceUnitInfoImpl.findPersistence": {"callee_method_ids": [973], "callee_method_names": ["URL.openStream", "javax.xml.bind.JAXBContext.createUnmarshaller", "javax.xml.bind.Unmarshaller.unmarshal", "Persistence.getPersistenceUnits", "String.equals", "PersistenceUnit.getName"], "method_name": "PersistenceUnitInfoImpl.findPersistence", "method_implementation": "{\n    InputStream is;\n    try {\n        is = url.openStream();\n        final javax.xml.bind.JAXBContext context = javax.xml.bind.JAXBContext.newInstance(Persistence.class);\n        final javax.xml.bind.Unmarshaller unmarshaller = context.createUnmarshaller();\n        final Persistence persistence = (Persistence) unmarshaller.unmarshal(is);\n        for (final PersistenceUnit persistenceUnit : persistence.getPersistenceUnits()) {\n            if (puName.equals(persistenceUnit.getName())) {\n                return persistenceUnit;\n            }\n        }\n        return null;\n    } catch (final Exception e) {\n        PersistenceUnitInfoImpl.LOG.error(e, \"Cannot read persistence.xml at location {0}\", url);\n        return null;\n    }\n}", "repo_id": "1", "comment": "/**\n * Finds and returns the persistence unit.\n *\n * @param puName\n * @param url the URL pointing persistence.xml\n * @return the persistence unit\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1131, "method_signature": "PersistenceUnit findPersistence(String, URL)"}, "PersistenceUnitInfoImpl.getProperties": {"callee_method_names": ["Properties.putAll"], "method_name": "PersistenceUnitInfoImpl.getProperties", "method_implementation": "{\n    final Properties properties = new Properties();\n    properties.putAll(this.properties);\n    return properties;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1132, "method_signature": "Properties getProperties()"}, "PersistenceUnitMetadataElement.handleChild": {"callee_method_names": [], "method_name": "PersistenceUnitMetadataElement.handleChild", "method_implementation": "{\n    if (child instanceof XmlMappingMetadataCompleteElement) {\n        this.xmlMappingMetadataComplete = true;\n    }\n    if (child instanceof PersistenceUnitDefaults) {\n        this.persistenceUnitDefaults = (PersistenceUnitDefaults) child;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1060, "method_signature": "void handleChild(Element)"}, "PersistenceUnitUtilImpl.getIdentifier": {"callee_method_names": ["Object.getClass", "EntityTypeImpl.getInstanceId"], "method_name": "PersistenceUnitUtilImpl.getIdentifier", "method_implementation": "{\n    final EntityTypeImpl type = this.emf.getMetamodel().getEntity(entity.getClass());\n    return type.getInstanceId(entity);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 475, "method_signature": "Object getIdentifier(Object)"}, "PersistenceUnitUtilImpl.isLoaded": {"callee_method_names": ["EnhancedInstance.__enhanced__$$__getManagedInstance", "EnhancedInstance.__enhanced__$$__getManagedInstance", "Object.getClass"], "method_name": "PersistenceUnitUtilImpl.isLoaded", "method_implementation": "{\n    if ((entity == null) || StringUtils.isBlank(attributeName)) {\n        throw new NullPointerException();\n    }\n    if (entity instanceof EnhancedInstance) {\n        final EnhancedInstance instance = (EnhancedInstance) entity;\n        if (instance.__enhanced__$$__getManagedInstance() != null) {\n            return instance.__enhanced__$$__getManagedInstance().isJoinLoaded(attributeName);\n        }\n        try {\n            final Object value = entity.getClass().getMethod(\"get\" + StringUtils.capitalize(attributeName)).invoke(entity);\n            if (value instanceof EnhancedInstance) {\n                return this.isLoaded(value);\n            }\n            if (value instanceof ManagedCollection) {\n                return ((ManagedCollection<?>) value).isInitialized();\n            }\n        } catch (final Exception e) {\n            throw new IllegalArgumentException(\"Unable to get attribute \" + attributeName);\n        }\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 477, "method_signature": "boolean isLoaded(Object, String)"}, "PersistenceUtilImpl.isLoaded": {"callee_method_names": ["EnhancedInstance.__enhanced__$$__isInitialized"], "method_name": "PersistenceUtilImpl.isLoaded", "method_implementation": "{\n    if (entity instanceof EnhancedInstance) {\n        final EnhancedInstance instance = (EnhancedInstance) entity;\n        return instance.__enhanced__$$__isInitialized() ? LoadState.LOADED : LoadState.NOT_LOADED;\n    }\n    return LoadState.LOADED;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 421, "method_signature": "LoadState isLoaded(Object)"}, "PersistenceUtilImpl.isLoadedWithReference": {"callee_method_names": ["EnhancedInstance.__enhanced__$$__getManagedInstance"], "method_name": "PersistenceUtilImpl.isLoadedWithReference", "method_implementation": "{\n    if (entity instanceof EnhancedInstance) {\n        final EnhancedInstance instance = (EnhancedInstance) entity;\n        return instance.__enhanced__$$__getManagedInstance().isJoinLoaded(attributeName) ? LoadState.LOADED : LoadState.NOT_LOADED;\n    }\n    return LoadState.LOADED;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 423, "method_signature": "LoadState isLoadedWithReference(Object, String)"}, "PersistenceUtilImpl.isLoadedWithoutReference": {"callee_method_names": ["EnhancedInstance.__enhanced__$$__getManagedInstance"], "method_name": "PersistenceUtilImpl.isLoadedWithoutReference", "method_implementation": "{\n    if (entity instanceof EnhancedInstance) {\n        final EnhancedInstance instance = (EnhancedInstance) entity;\n        return instance.__enhanced__$$__getManagedInstance().isJoinLoaded(attributeName) ? LoadState.LOADED : LoadState.NOT_LOADED;\n    }\n    return LoadState.LOADED;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 422, "method_signature": "LoadState isLoadedWithoutReference(Object, String)"}, "Person.equals": {"callee_method_names": [], "method_name": "Person.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof Person)) {\n        return false;\n    }\n    final Person other = (Person) obj;\n    if (this.id == null) {\n        if (other.id != null) {\n            return false;\n        }\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2453, "method_signature": "boolean equals(Object)"}, "Person.getId": {"callee_method_names": [], "method_name": "Person.getId", "method_implementation": "{\n    return this.id;\n}", "repo_id": "1", "comment": "/**\n * Returns the id.\n *\n * @return the id\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2454, "method_signature": "Integer getId()"}, "Person.getPhones": {"callee_method_names": [], "method_name": "Person.getPhones", "method_implementation": "{\n    return this.phones;\n}", "repo_id": "1", "comment": "/**\n * Returns the phones of the Person.\n *\n * @return the phones of the Person\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2455, "method_signature": "List<Phone> getPhones()"}, "Person.hashCode": {"callee_method_names": [], "method_name": "Person.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2456, "method_signature": "int hashCode()"}, "Person.setHomeAddress": {"callee_method_ids": [2460], "callee_method_names": ["Address.getId"], "method_name": "Person.setHomeAddress", "method_implementation": "{\n    this.homeAddress = homeAddress;\n    this.addressId = homeAddress.getId();\n}", "repo_id": "1", "comment": "/**\n * Set the homeAddress without adding this Account instance on the passed homeAddress If you want to preserve referential integrity we\n * recommend to use instead the corresponding adder method provided by {@link Address}\n *\n * @param homeAddress\n *            the home address to set\n */\n", "repo_name": "BatooJPA-master/", "id": 2198, "method_signature": "void setHomeAddress(Address)"}, "PessimisticLockTest.testPessimisticLockRemove": {"callee_method_names": ["Foo2.getId", "EntityManager.find", "Foo2.getId", "EntityManager.getTransaction", "EntityTransaction.begin", "EntityManager.remove", "Foo2.setValue", "EntityTransaction.commit", "EntityManager.close"], "method_name": "PessimisticLockTest.testPessimisticLockRemove", "method_implementation": "{\n    Foo2 foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    foo = this.find(Foo2.class, foo.getId(), LockModeType.PESSIMISTIC_WRITE);\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final Foo2 foo2 = em2.find(Foo2.class, foo.getId(), LockModeType.PESSIMISTIC_WRITE);\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        em2.remove(foo2);\n        this.begin();\n        foo.setValue(\"test3\");\n        tx2.commit();\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the pessimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2244, "method_signature": "void testPessimisticLockRemove()"}, "PessimisticLockTest.testPessimisticLockUpdate": {"callee_method_names": ["EntityManager.find", "Foo2.getId", "EntityManager.getTransaction", "EntityTransaction.begin", "Foo2.setValue", "EntityTransaction.commit", "Foo2.setValue", "EntityManager.close"], "method_name": "PessimisticLockTest.testPessimisticLockUpdate", "method_implementation": "{\n    final Foo2 foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final Foo2 foo2 = em2.find(Foo2.class, foo.getId());\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        foo2.setValue(\"test2\");\n        tx2.commit();\n        this.begin();\n        foo.setValue(\"test3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2245, "method_signature": "void testPessimisticLockUpdate()"}, "PessimisticLockTest.testPessimisticLockUpdateChild": {"callee_method_names": ["EntityManager.find", "Foo2.getId", "EntityManager.getTransaction", "EntityTransaction.begin", "Foo2.getBars", "EntityTransaction.commit", "Foo2.getBars", "EntityManager.close"], "method_name": "PessimisticLockTest.testPessimisticLockUpdateChild", "method_implementation": "{\n    final Foo2 foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final Foo2 foo2 = em2.find(Foo2.class, foo.getId());\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        foo2.getBars().get(0).setValue(\"barChangedValue\");\n        tx2.commit();\n        this.begin();\n        foo.getBars().get(0).setValue(\"barChangedValue2\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2246, "method_signature": "void testPessimisticLockUpdateChild()"}, "PessimisticLockTest.testPessimisticLockUpdateChildren": {"callee_method_names": ["EntityManager.find", "Foo2.getId", "EntityManager.getTransaction", "EntityTransaction.begin", "EntityTransaction.commit", "EntityManager.close"], "method_name": "PessimisticLockTest.testPessimisticLockUpdateChildren", "method_implementation": "{\n    final Foo2 foo = this.newFoo(false);\n    this.persist(foo);\n    this.commit();\n    final EntityManager em2 = this.emf().createEntityManager();\n    try {\n        final Foo2 foo2 = em2.find(Foo2.class, foo.getId());\n        final EntityTransaction tx2 = em2.getTransaction();\n        tx2.begin();\n        new Bar2(foo2, \"barValue3\");\n        tx2.commit();\n        this.begin();\n        new Bar2(foo, \"barValue3\");\n        this.commit();\n    } finally {\n        em2.close();\n    }\n}", "repo_id": "1", "comment": "/**\n * Tests the optimistic lock.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2247, "method_signature": "void testPessimisticLockUpdateChildren()"}, "Phone.getId": {"callee_method_names": [], "method_name": "Phone.getId", "method_implementation": "{\n    return this.id;\n}", "repo_id": "1", "comment": "/**\n * Returns the id of the Phone.\n *\n * @return the id of the Phone\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2461, "method_signature": "Integer getId()"}, "PhoneId.equals": {"callee_method_names": ["Object.getClass"], "method_name": "PhoneId.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final PhoneId other = (PhoneId) obj;\n    if (this.areaCode == null) {\n        if (other.areaCode != null) {\n            return false;\n        }\n    } else if (!this.areaCode.equals(other.areaCode)) {\n        return false;\n    }\n    if (this.phoneNumber == null) {\n        if (other.phoneNumber != null) {\n            return false;\n        }\n    } else if (!this.phoneNumber.equals(other.phoneNumber)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2135, "method_signature": "boolean equals(Object)"}, "PhoneId.hashCode": {"callee_method_names": [], "method_name": "PhoneId.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.areaCode == null) ? 0 : this.areaCode.hashCode());\n    result = (prime * result) + ((this.phoneNumber == null) ? 0 : this.phoneNumber.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2136, "method_signature": "int hashCode()"}, "PhoneNumber.equals": {"callee_method_names": [], "method_name": "PhoneNumber.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof PhoneNumber)) {\n        return false;\n    }\n    final PhoneNumber other = (PhoneNumber) obj;\n    if ((this.id == null) && (other.id == null)) {\n        return false;\n    }\n    if (this.id == null) {\n        if (other.id != null) {\n            return false;\n        }\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2282, "method_signature": "boolean equals(Object)"}, "PhoneNumber.hashCode": {"callee_method_names": [], "method_name": "PhoneNumber.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2283, "method_signature": "int hashCode()"}, "PhonePk.equals": {"callee_method_names": ["Object.getClass"], "method_name": "PhonePk.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final PhonePk other = (PhonePk) obj;\n    if (this.id == null) {\n        return false;\n    } else if (!this.id.equals(other.id)) {\n        return false;\n    }\n    if (this.personId == null) {\n        return false;\n    } else if (!this.personId.equals(other.personId)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2295, "method_signature": "boolean equals(Object)"}, "PhonePk.hashCode": {"callee_method_names": [], "method_name": "PhonePk.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.id == null) ? 0 : this.id.hashCode());\n    result = (prime * result) + ((this.personId == null) ? 0 : this.personId.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2296, "method_signature": "int hashCode()"}, "PhysicalAttributeElement.handleChild": {"callee_method_names": [], "method_name": "PhysicalAttributeElement.handleChild", "method_implementation": "{\n    if (child instanceof TemporalElement) {\n        this.temporalType = ((TemporalElement) child).getTemporalType();\n    }\n    if (child instanceof ColumnElement) {\n        this.column = (ColumnElement) child;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1116, "method_signature": "void handleChild(Element)"}, "PluralAssociationMappingImpl.attach": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedInstance<?>.getInstance"], "method_name": "PluralAssociationMappingImpl.attach", "method_implementation": "{\n    if (this.joinTable != null) {\n        this.joinTable.performInsert(connection, instance.getInstance(), batch, batchSize);\n    } else if (this.foreignKey != null) {\n        this.foreignKey.performAttachChild(connection, instance.getInstance(), batch, batchSize);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 356, "method_signature": "void attach(Connection, ManagedInstance, Joinable[], int)"}, "PluralAssociationMappingImpl.checkTransient": {"callee_method_ids": [479, 479, 479], "callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedInstance<?>.getSession", "List<E>.size", "SessionImpl.checkTransient", "List<E>.get", "SessionImpl.checkTransient", "SessionImpl.checkTransient"], "method_name": "PluralAssociationMappingImpl.checkTransient", "method_implementation": "{\n    final Object values = this.get(managedInstance.getInstance());\n    final SessionImpl session = managedInstance.getSession();\n    if (values instanceof List) {\n        final List<E> list = (List<E>) values;\n        for (int i = 0; i < list.size(); i++) {\n            session.checkTransient(list.get(i));\n        }\n    } else if (values instanceof Collection) {\n        for (final Object entity : ((Collection<E>) values).toArray()) {\n            session.checkTransient(entity);\n        }\n    } else if (values instanceof Map) {\n        for (final E entity : ((Map<?, E>) values).values()) {\n            session.checkTransient(entity);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 357, "method_signature": "void checkTransient(ManagedInstance)"}, "PluralAssociationMappingImpl.detach": {"callee_method_names": ["ManagedInstance<?>.getInstance"], "method_name": "PluralAssociationMappingImpl.detach", "method_implementation": "{\n    if (this.joinTable != null) {\n        this.joinTable.performRemove(connection, instance.getInstance(), key, child);\n    } else if (this.foreignKey != null) {\n        this.foreignKey.performDetachChild(connection, key, child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 358, "method_signature": "void detach(Connection, ManagedInstance, Object, Object)"}, "PluralAssociationMappingImpl.detachAll": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedInstance<?>.getInstance"], "method_name": "PluralAssociationMappingImpl.detachAll", "method_implementation": "{\n    if (this.joinTable != null) {\n        this.joinTable.performRemoveAll(connection, instance.getInstance());\n    } else if (this.foreignKey != null) {\n        this.foreignKey.performDetachAll(connection, instance.getInstance());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 359, "method_signature": "void detachAll(Connection, ManagedInstance)"}, "PluralAssociationMappingImpl.enhance": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedInstance<?>.getInstance", "ManagedInstance<?>.getInstance"], "method_name": "PluralAssociationMappingImpl.enhance", "method_implementation": "{\n    final C c = this.get(instance.getInstance());\n    if (c == null) {\n        this.set(instance.getInstance(), this.attribute.newCollection(this, instance, false));\n    } else {\n        this.set(instance.getInstance(), this.attribute.newCollection(this, instance, c));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 360, "method_signature": "void enhance(ManagedInstance)"}, "PluralAssociationMappingImpl.extractKey": {"callee_method_names": [], "method_name": "PluralAssociationMappingImpl.extractKey", "method_implementation": "{\n    if (this.mapKeyMapping != null) {\n        return this.mapKeyMapping.get(value);\n    }\n    try {\n        final Object key = this.type.newCompositeId();\n        for (final Pair<SingularMapping<?, ?>, AbstractAccessor> pair : this.mapKeyMappings) {\n            pair.getSecond().set(key, pair.getFirst().get(value));\n        }\n        return key;\n    }// cannot happen\n     catch (final Exception e) {\n    }\n    // inaccessible\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 361, "method_signature": "Object extractKey(Object)"}, "PluralAssociationMappingImpl.flush": {"callee_method_names": ["ManagedInstance<?>.getInstance"], "method_name": "PluralAssociationMappingImpl.flush", "method_implementation": "{\n    final Object collection = this.get(managedInstance.getInstance());\n    if (collection != null) {\n        ((ManagedCollection<E>) collection).flush(connection, removals, force);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 362, "method_signature": "void flush(Connection, ManagedInstance, boolean, boolean)"}, "PluralAssociationMappingImpl.getOrderColumn": {"callee_method_names": [], "method_name": "PluralAssociationMappingImpl.getOrderColumn", "method_implementation": "{\n    if (this.joinTable != null) {\n        return this.joinTable.getOrderColumn();\n    }\n    if (this.foreignKey != null) {\n        return this.foreignKey.getOrderColumn();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 363, "method_signature": "OrderColumn getOrderColumn()"}, "PluralAssociationMappingImpl.link": {"callee_method_names": ["MapAttributeImpl<? super Z, Map<?, E>, E>.getKeyJavaType"], "method_name": "PluralAssociationMappingImpl.link", "method_implementation": "{\n    final EntityTypeImpl<?> entity = (EntityTypeImpl<?>) this.getRoot().getType();\n    this.type = (EntityTypeImpl<E>) this.attribute.getElementType();\n    if (!this.isOwner()) {\n        this.inverse = (AssociationMappingImpl<?, ?, ?>) this.type.getRootMapping().getMapping(this.getMappedBy());\n        if (this.inverse == null) {\n            throw new MappingException(\"Cannot find the mappedBy attribute \" + this.getMappedBy() + \" specified on \" + this.attribute.getJavaMember());\n        }\n        this.inverse.setInverse(this);\n    } else {\n        // initialize the join table\n        if (this.joinTable != null) {\n            this.joinTable.link(entity, this.type);\n            if (this.attribute.getCollectionType() == CollectionType.LIST) {\n                final String name = //\n                (this.orderColumn != null) && StringUtils.isNotBlank(this.orderColumn.getName()) ? this.orderColumn.getName() : this.attribute.getName() + \"_ORDER\";\n                this.joinTable.setOrderColumn(this.orderColumn, name, this.attribute.getLocator());\n            }\n        }\n        if (this.foreignKey != null) {\n            this.foreignKey.link(null, (EntityTypeImpl<?>) this.getRoot().getType());\n            this.foreignKey.setTable(this.type.getPrimaryTable());\n            if (this.orderColumn != null) {\n                throw new MappingException(\"Order column is only allowed for join tables\", this.orderColumn.getLocator());\n            }\n        }\n    }\n    if (this.attribute.getCollectionType() == CollectionType.MAP) {\n        if (this.mapKeyColumn != null) {\n            final MapAttributeImpl<? super Z, Map<?, E>, E> mapAttribute = (MapAttributeImpl<? super Z, Map<?, E>, E>) this.attribute;\n            final String name = StringUtils.isNotBlank(this.mapKeyColumn.getName()) ? this.mapKeyColumn.getName() : this.attribute.getName() + \"_KEY\";\n            this.joinTable.setKeyColumn(this.mapKeyColumn, name, this.mapKeyTemporalType, this.mapKeyEnumType, mapAttribute.getKeyJavaType());\n        } else {\n            if (StringUtils.isBlank(this.mapKey)) {\n                if (this.type.hasSingleIdAttribute()) {\n                    this.mapKeyMapping = this.type.getIdMapping();\n                } else {\n                    this.mapKeyMappings = this.type.getIdMappings();\n                }\n            } else {\n                this.mapKeyMapping = (SingularMappingEx<? super E, ?>) this.type.getRootMapping().getMapping(this.mapKey);\n                if (this.mapKeyMapping == null) {\n                    throw new MappingException(\"Cannot locate the MapKey: \" + this.mapKey, this.attribute.getLocator());\n                }\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 364, "method_signature": "void link()"}, "PluralAssociationMappingImpl.load": {"callee_method_names": ["ManagedCollection<E>.initialize", "ManagedInstance<?>.getInstance"], "method_name": "PluralAssociationMappingImpl.load", "method_implementation": "{\n    final ManagedCollection<E> collection = (ManagedCollection<E>) this.attribute.newCollection(this, instance, true);\n    collection.initialize();\n    this.set(instance.getInstance(), collection);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 365, "method_signature": "void load(ManagedInstance)"}, "PluralAssociationMappingImpl.loadCollection": {"callee_method_names": ["ManagedInstance<?>.getSession", "ManagedInstance<?>.getInstance", "EntityManagerImpl.createQuery", "QueryImpl<E>.setParameter", "QueryImpl<E>.getResultList", "List<E>.toArray", "List<E>.size", "ManagedInstance<?>.getInstance", "List<E>.remove"], "method_name": "PluralAssociationMappingImpl.loadCollection", "method_implementation": "{\n    final EntityManagerImpl em = managedInstance.getSession().getEntityManager();\n    List<E> children = null;\n    final Object instance = managedInstance.getInstance();\n    // load from the database\n    if (children == null) {\n        final QueryImpl<E> q = em.createQuery(this.getSelectCriteria());\n        q.setParameter(1, instance);\n        children = q.getResultList();\n    }\n    if ((this.getInverse() != null) && (this.getAttribute().getPersistentAttributeType() == PersistentAttributeType.ONE_TO_MANY)) {\n        final Object[] childrenToProcess = children.toArray(new Object[children.size()]);\n        for (final Object child : childrenToProcess) {\n            final Object newParent = this.getInverse().get(child);\n            if ((newParent != null) && (newParent != managedInstance.getInstance())) {\n                children.remove(child);\n            } else {\n                this.getInverse().set(child, instance);\n            }\n        }\n    }\n    return children;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 366, "method_signature": "Collection<? extends E> loadCollection(ManagedInstance)"}, "PluralAssociationMappingImpl.loadMap": {"callee_method_names": ["Map<K, E>.put"], "method_name": "PluralAssociationMappingImpl.loadMap", "method_implementation": "{\n    final Collection<? extends E> children = this.loadCollection(managedInstance);\n    final Map<K, E> childrenMap = Maps.newHashMap();\n    for (final E child : children) {\n        childrenMap.put((K) this.extractKey(child), child);\n    }\n    return childrenMap;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 367, "method_signature": "Map<? extends K,? extends E> loadMap(ManagedInstance)"}, "PluralAssociationMappingImpl.mergeWith": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedCollection<E>.isInitialized", "ManagedCollection<E>.initialize", "ManagedCollection<E>.mergeWith"], "method_name": "PluralAssociationMappingImpl.mergeWith", "method_implementation": "{\n    // get the managed collection\n    final ManagedCollection<E> collection = (ManagedCollection<E>) this.get(instance.getInstance());\n    // if the entity we are merging has an un initialized managed collection then no need to merge\n    final Object newCollection = this.get(entity);\n    if ((newCollection instanceof ManagedCollection) && !((ManagedCollection<E>) newCollection).isInitialized()) {\n        return;\n    }\n    // if initialized then merge with the new entities\n    if ((collection != null) && !collection.isInitialized()) {\n        collection.initialize();\n    }\n    collection.mergeWith(entityManager, entity, requiresFlush, processed, instances);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 368, "method_signature": "void mergeWith(EntityManagerImpl, ManagedInstance, Object, MutableBoolean, IdentityHashMap, LinkedList)"}, "PluralAssociationMappingImpl.persistAdditions": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedCollection<E>.persistAdditions"], "method_name": "PluralAssociationMappingImpl.persistAdditions", "method_implementation": "{\n    if (this.cascadesPersist()) {\n        final ManagedCollection<E> collection = (ManagedCollection<E>) this.get(instance.getInstance());\n        collection.persistAdditions(entityManager);\n    }\n}", "repo_id": "1", "comment": "/**\n * Persists the children that have been added to the managed collection\n *\n * @param entityManager\n *            the entity manager\n * @param instance\n *            the managed instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 369, "method_signature": "void persistAdditions(EntityManagerImpl, ManagedInstance)"}, "PluralAssociationMappingImpl.references": {"callee_method_names": [], "method_name": "PluralAssociationMappingImpl.references", "method_implementation": "{\n    final Object values = this.get(instance);\n    if (values == null) {\n        return false;\n    }\n    if (values instanceof Collection) {\n        return ((Collection<?>) values).contains(reference);\n    }\n    return ((Map<?, ?>) values).containsValue(reference);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 370, "method_signature": "boolean references(Object, Object)"}, "PluralAssociationMappingImpl.refresh": {"callee_method_ids": [453, 453], "callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedCollection<E>.refreshChildren", "ManagedInstance<?>.getSession", "ManagedCollection<E>.getDelegate", "ManagedCollection<E>.getDelegate", "List<E>.size", "EntityManagerImpl.refreshImpl", "List<E>.get", "ManagedCollection<E>.getDelegate", "EntityManagerImpl.refreshImpl"], "method_name": "PluralAssociationMappingImpl.refresh", "method_implementation": "{\n    if (this.isEager()) {\n        this.initialize(instance);\n        final ManagedCollection<E> collection = (ManagedCollection<E>) this.get(instance.getInstance());\n        collection.refreshChildren();\n        if (this.cascadesRefresh()) {\n            final EntityManagerImpl entityManager = instance.getSession().getEntityManager();\n            if (collection.getDelegate() instanceof List) {\n                final List<E> list = (List<E>) collection.getDelegate();\n                for (int i = 0; i < list.size(); i++) {\n                    entityManager.refreshImpl(list.get(i), null, processed);\n                }\n            } else {\n                for (final E child : collection.getDelegate()) {\n                    entityManager.refreshImpl(child, null, processed);\n                }\n            }\n        }\n        if (this.orderBy != null) {\n            this.sortList(instance);\n        }\n    } else {\n        this.setLazy(instance);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 371, "method_signature": "void refresh(ManagedInstance, Set)"}, "PluralAssociationMappingImpl.removeOrphans": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedCollection<E>.removeOrphans"], "method_name": "PluralAssociationMappingImpl.removeOrphans", "method_implementation": "{\n    if (this.removesOrphans()) {\n        final ManagedCollection<E> collection = (ManagedCollection<E>) this.get(instance.getInstance());\n        collection.removeOrphans(entityManager);\n    }\n}", "repo_id": "1", "comment": "/**\n * Removes the children that have been orphaned due to removal from the managed collection\n *\n * @param entityManager\n *            the entity manager\n * @param instance\n *            the managed instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 372, "method_signature": "void removeOrphans(EntityManagerImpl, ManagedInstance)"}, "PluralAssociationMappingImpl.sortList": {"callee_method_names": ["ManagedList<Z, E>.isInitialized", "ManagedList<Z, E>.getDelegate"], "method_name": "PluralAssociationMappingImpl.sortList", "method_implementation": "{\n    final ManagedList<Z, E> list = (ManagedList<Z, E>) this.get(instance);\n    if (list.isInitialized()) {\n        Collections.sort(list.getDelegate(), this.getComparator());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 373, "method_signature": "void sortList(Object)"}, "PluralAttributeImpl.create": {"callee_method_names": ["AttributeMetadata.getLocator"], "method_name": "PluralAttributeImpl.create", "method_implementation": "{\n    final Member member = ((AttributeMetadataImpl) metadata).getMember();\n    Class<?> type;\n    if (member instanceof Field) {\n        type = ((Field) member).getType();\n    } else {\n        type = ((Method) member).getReturnType();\n    }\n    if (List.class == type) {\n        return new ListAttributeImpl(declaringType, metadata, attributeType);\n    } else if (Set.class == type) {\n        return new SetAttributeImpl(declaringType, metadata, attributeType);\n    } else if (Collection.class == type) {\n        return new CollectionAttributeImpl(declaringType, metadata, attributeType);\n    } else if (Map.class == type) {\n        return new MapAttributeImpl(declaringType, metadata, attributeType);\n    }\n    throw new MappingException(\"Cannot determine collection type for \" + type, metadata.getLocator());\n}", "repo_id": "1", "comment": "/**\n * Creates an associated plural attribute corresponding to member type\n *\n * @param declaringType\n *            the declaring type\n * @param metadata\n *            the metadata\n * @param attributeType\n *            the attribute type\n * @param <X>\n *            the type of the managed type\n * @return the attribute created\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 274, "method_signature": "PluralAttributeImpl<X,?,?> create(ManagedTypeImpl, AttributeMetadata, PersistentAttributeType)"}, "PluralAttributeImpl.getElementType": {"callee_method_ids": [300, 299, 299, 297], "callee_method_names": ["MetamodelImpl.entity", "MetamodelImpl.embeddable", "MetamodelImpl.embeddable", "MetamodelImpl.createBasicType"], "method_name": "PluralAttributeImpl.getElementType", "method_implementation": "{\n    if (this.type != null) {\n        return this.type;\n    }\n    final MetamodelImpl metamodel = this.getDeclaringType().getMetamodel();\n    switch(this.attributeType) {\n        case ONE_TO_MANY:\n        case MANY_TO_MANY:\n            return this.type = metamodel.entity(this.bindableJavaType);\n        default:\n            // ELEMENT_COLLECTION:\n            return this.type = metamodel.embeddable(this.bindableJavaType) != null ? metamodel.embeddable(this.bindableJavaType) : metamodel.createBasicType(this.bindableJavaType);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 275, "method_signature": "TypeImpl<E> getElementType()"}, "PluralAttributeImpl.toString": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "PluralAttributeImpl.toString", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    if (this.getPersistentAttributeType() == PersistentAttributeType.ELEMENT_COLLECTION) {\n        builder.append(\"element-collection\");\n    } else {\n        builder.append(\"association \");\n        switch(this.getCollectionType()) {\n            case COLLECTION:\n                builder.append(\"collection\");\n                break;\n            case LIST:\n                builder.append(\"list\");\n                break;\n            case MAP:\n                builder.append(\"map\");\n                break;\n            case SET:\n                builder.append(\"set\");\n                break;\n        }\n    }\n    final String declaringType = this.getDeclaringType().getJavaType().getSimpleName();\n    final String type = this.getBindableJavaType().getSimpleName();\n    builder.append(\" \").append(declaringType).append(\".\").append(this.getName()).append(\"(\").append(type).append(\")\");\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 276, "method_signature": "String toString()"}, "PostgreSqlAdaptor.applyLikeEscape": {"callee_method_names": [], "method_name": "PostgreSqlAdaptor.applyLikeEscape", "method_implementation": "{\n    return \" {ESCAPE \" + escapePattern + \"}\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1295, "method_signature": "String applyLikeEscape(String)"}, "PostgreSqlAdaptor.applyLock": {"callee_method_names": [], "method_name": "PostgreSqlAdaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1296, "method_signature": "String applyLock(String, LockModeType)"}, "PostgreSqlAdaptor.applyPagination": {"callee_method_names": [], "method_name": "PostgreSqlAdaptor.applyPagination", "method_implementation": "{\n    if (startPosition != 0) {\n        sql = sql + \"\\nOFFSET \" + startPosition + \" ROWS\";\n    }\n    if (maxResult != Integer.MAX_VALUE) {\n        sql = sql + \"\\nFETCH FIRST \" + maxResult + \" ROWS ONLY\";\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1297, "method_signature": "String applyPagination(String, int, int)"}, "PostgreSqlAdaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable", "AbstractColumn.isUnique"], "method_name": "PostgreSqlAdaptor.createColumnDDL", "method_implementation": "{\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // not null part\n    (column.isUnique() ? \" UNIQUE\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1298, "method_signature": "String createColumnDDL(AbstractColumn)"}, "PostgreSqlAdaptor.createSequenceIfNecessary": {"callee_method_names": ["SequenceGenerator.getSequenceName", "SequenceGenerator.getInitialValue", "SequenceGenerator.getAllocationSize", "SequenceGenerator.getName"], "method_name": "PostgreSqlAdaptor.createSequenceIfNecessary", "method_implementation": "{\n    final String sql = //\n    \"CREATE SEQUENCE \" + // ;\n    sequence.getSequenceName() + \" START WITH \" + //\n    sequence.getInitialValue() + \" INCREMENT BY \" + sequence.getAllocationSize();\n    try {\n        new QueryRunner(datasource).update(sql);\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot create sequence \" + sequence.getName());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1299, "method_signature": "void createSequenceIfNecessary(DataSource, SequenceGenerator)"}, "PostgreSqlAdaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getIdType", "AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "PostgreSqlAdaptor.getColumnType", "method_implementation": "{\n    if (cd.getIdType() == IdType.IDENTITY) {\n        return \"SERIAL\";\n    }\n    switch(sqlType) {\n        case Types.BLOB:\n        case Types.CLOB:\n            return \"BYTEA\";\n        case Types.VARCHAR:\n            return \"VARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n            return \"TIME\";\n        case Types.DATE:\n            return \"DATE\";\n        case Types.TIMESTAMP:\n            return \"TIMESTAMP\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"BOOLEAN\";\n        case Types.TINYINT:\n        case Types.SMALLINT:\n            return \"SMALLINT\";\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"BIGINT\";\n        case Types.FLOAT:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DOUBLE:\n            return \"DOUBLE PRECISION\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"DECIMAL\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * Returns the data type of the column.\n *\n * @param cd\n *            the column definition\n * @param sqlType\n *            the sql type\n * @return the data type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1300, "method_signature": "String getColumnType(AbstractColumn, int)"}, "PostgreSqlAdaptor.getDropForeignKeySql": {"callee_method_names": [], "method_name": "PostgreSqlAdaptor.getDropForeignKeySql", "method_implementation": "{\n    final String qualifiedName = Joiner.on(\".\").skipNulls().join(schema, table);\n    return \"ALTER TABLE \" + qualifiedName + \" DROP CONSTRAINT \" + foreignKey;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1301, "method_signature": "String getDropForeignKeySql(String, String, String)"}, "PostgreSqlAdaptor.getNextSequence": {"callee_method_names": [], "method_name": "PostgreSqlAdaptor.getNextSequence", "method_implementation": "{\n    return //\n    new QueryRunner(datasource).query(\"SELECT NEXTVAL('\" + sequenceName + \"')\", new SingleValueHandler<Number>()).longValue();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1302, "method_signature": "long getNextSequence(DataSource, String)"}, "PostgreSqlAdaptor.supports": {"callee_method_names": [], "method_name": "PostgreSqlAdaptor.supports", "method_implementation": "{\n    if (type == null) {\n        return IdType.SEQUENCE;\n    }\n    switch(type) {\n        case IDENTITY:\n            return IdType.IDENTITY;\n        case SEQUENCE:\n            return IdType.SEQUENCE;\n        case TABLE:\n            return IdType.TABLE;\n        default:\n            return IdType.SEQUENCE;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1303, "method_signature": "IdType supports(GenerationType)"}, "PredicateImpl.generateJpqlRestriction": {"callee_method_names": [], "method_name": "PredicateImpl.generateJpqlRestriction", "method_implementation": "{\n    String predicates = Joiner.on(\" \" + this.operator.name() + \" \").join(Lists.transform(this.expressions, new Function<AbstractExpression<Boolean>, String>() {\n\n        @Override\n        public String apply(AbstractExpression<Boolean> input) {\n            return input.generateJpqlRestriction(query);\n        }\n    }));\n    if (StringUtils.isBlank(predicates)) {\n        predicates = \"true\";\n    }\n    if (this.negated) {\n        return \"not (\" + predicates + \")\";\n    }\n    return predicates;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 623, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "PredicateImpl.generateJpqlSelect": {"callee_method_names": [], "method_name": "PredicateImpl.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.alias;\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 624, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "PredicateImpl.generateSqlRestriction": {"callee_method_names": [], "method_name": "PredicateImpl.generateSqlRestriction", "method_implementation": "{\n    String predicates = Joiner.on(\" \" + this.operator.name() + \" \").join(Lists.transform(this.expressions, new Function<BooleanExpression, String>() {\n\n        @Override\n        public String apply(BooleanExpression input) {\n            return input.generateSqlRestriction(query);\n        }\n    }));\n    if (StringUtils.isBlank(predicates)) {\n        predicates = \"TRUE\";\n    }\n    if (this.negated) {\n        return \"NOT (\" + predicates + \")\";\n    }\n    return \"(\" + predicates + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 625, "method_signature": "String generateSqlRestriction(BaseQueryImpl)"}, "PredicateImpl.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "PredicateImpl.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.generateSqlRestriction(query) + \" AS \" + this.alias;\n    }\n    return this.generateSqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 626, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "PredicateImpl.getExpressions": {"callee_method_names": ["List<Expression<Boolean>>.addAll"], "method_name": "PredicateImpl.getExpressions", "method_implementation": "{\n    final List<Expression<Boolean>> expressions = Lists.newArrayList();\n    expressions.addAll(this.expressions);\n    return expressions;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 627, "method_signature": "List<Expression<Boolean>> getExpressions()"}, "PredicateImpl.not": {"callee_method_names": [], "method_name": "PredicateImpl.not", "method_implementation": "{\n    return new PredicateImpl(true, this.operator, this.expressions.toArray(new Expression[this.expressions.size()]));\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 628, "method_signature": "PredicateImpl not()"}, "PreparedStatementProxy.executeQuery": {"callee_method_names": [], "method_name": "PreparedStatementProxy.executeQuery", "method_implementation": "{\n    this.throwNotImplemented();\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1169, "method_signature": "ResultSet executeQuery(String)"}, "PreparedStatementProxy.executeUpdate": {"callee_method_names": [], "method_name": "PreparedStatementProxy.executeUpdate", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1174, "method_signature": "int executeUpdate(String, String[])"}, "PreparedStatementProxy.getConnection": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getConnection", "method_implementation": "{\n    this.throwNotImplemented();\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1175, "method_signature": "Connection getConnection()"}, "PreparedStatementProxy.getFetchDirection": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getFetchDirection", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1176, "method_signature": "int getFetchDirection()"}, "PreparedStatementProxy.getFetchSize": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getFetchSize", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1177, "method_signature": "int getFetchSize()"}, "PreparedStatementProxy.getGeneratedKeys": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getGeneratedKeys", "method_implementation": "{\n    this.throwNotImplemented();\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1178, "method_signature": "ResultSet getGeneratedKeys()"}, "PreparedStatementProxy.getMaxFieldSize": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getMaxFieldSize", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1179, "method_signature": "int getMaxFieldSize()"}, "PreparedStatementProxy.getMaxRows": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getMaxRows", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1180, "method_signature": "int getMaxRows()"}, "PreparedStatementProxy.getMetaData": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getMetaData", "method_implementation": "{\n    this.throwNotImplemented();\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1181, "method_signature": "ResultSetMetaData getMetaData()"}, "PreparedStatementProxy.getMoreResults": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getMoreResults", "method_implementation": "{\n    this.throwNotImplemented();\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1183, "method_signature": "boolean getMoreResults(int)"}, "PreparedStatementProxy.getParameterMetaData": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getParameterMetaData", "method_implementation": "{\n    if (this.parameterMetaData != null) {\n        return this.parameterMetaData;\n    }\n    this.parameterMetaData = this.statement.getParameterMetaData();\n    if (this.parameters == null) {\n        this.parameters = new Object[this.parameterMetaData.getParameterCount()];\n    }\n    return this.parameterMetaData;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1184, "method_signature": "ParameterMetaData getParameterMetaData()"}, "PreparedStatementProxy.getQueryTimeout": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getQueryTimeout", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1185, "method_signature": "int getQueryTimeout()"}, "PreparedStatementProxy.getResultSet": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getResultSet", "method_implementation": "{\n    this.throwNotImplemented();\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1186, "method_signature": "ResultSet getResultSet()"}, "PreparedStatementProxy.getResultSetConcurrency": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getResultSetConcurrency", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1187, "method_signature": "int getResultSetConcurrency()"}, "PreparedStatementProxy.getResultSetHoldability": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getResultSetHoldability", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1188, "method_signature": "int getResultSetHoldability()"}, "PreparedStatementProxy.getResultSetType": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getResultSetType", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1189, "method_signature": "int getResultSetType()"}, "PreparedStatementProxy.getUpdateCount": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getUpdateCount", "method_implementation": "{\n    this.throwNotImplemented();\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1190, "method_signature": "int getUpdateCount()"}, "PreparedStatementProxy.getWarnings": {"callee_method_names": [], "method_name": "PreparedStatementProxy.getWarnings", "method_implementation": "{\n    this.throwNotImplemented();\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1191, "method_signature": "SQLWarning getWarnings()"}, "PreparedStatementProxy.isCloseOnCompletion": {"callee_method_names": [], "method_name": "PreparedStatementProxy.isCloseOnCompletion", "method_implementation": "{\n    this.throwNotImplemented();\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1193, "method_signature": "boolean isCloseOnCompletion()"}, "PreparedStatementProxy.isClosed": {"callee_method_names": [], "method_name": "PreparedStatementProxy.isClosed", "method_implementation": "{\n    this.throwNotImplemented();\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1192, "method_signature": "boolean isClosed()"}, "PreparedStatementProxy.isPoolable": {"callee_method_names": [], "method_name": "PreparedStatementProxy.isPoolable", "method_implementation": "{\n    this.throwNotImplemented();\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1194, "method_signature": "boolean isPoolable()"}, "PreparedStatementProxy.isWrapperFor": {"callee_method_names": [], "method_name": "PreparedStatementProxy.isWrapperFor", "method_implementation": "{\n    this.throwNotImplemented();\n    return false;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1195, "method_signature": "boolean isWrapperFor(Class)"}, "PreparedStatementProxy.reset": {"callee_method_names": [], "method_name": "PreparedStatementProxy.reset", "method_implementation": "{\n    this.debug = PreparedStatementProxy.LOG.isDebugEnabled();\n    return this;\n}", "repo_id": "1", "comment": "/**\n * Resets the prepared statement and returns itself\n *\n * @return self\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1196, "method_signature": "PreparedStatement reset()"}, "PreparedStatementProxy.setBinaryStream": {"callee_method_names": [], "method_name": "PreparedStatementProxy.setBinaryStream", "method_implementation": "{\n    if ((this.debug || (this.sqlStream != null)) && (this.parameters != null)) {\n        this.parameters[parameterIndex - 1] = \"[BLOB]\";\n    }\n    this.statement.setBinaryStream(parameterIndex, x);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1197, "method_signature": "void setBinaryStream(int, InputStream)"}, "PreparedStatementProxy.setBlob": {"callee_method_names": [], "method_name": "PreparedStatementProxy.setBlob", "method_implementation": "{\n    if ((this.debug || (this.sqlStream != null)) && (this.parameters != null)) {\n        this.parameters[parameterIndex - 1] = \"[BLOB]\";\n    }\n    this.statement.setBlob(parameterIndex, x);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1198, "method_signature": "void setBlob(int, Blob)"}, "PreparedStatementProxy.setCharacterStream": {"callee_method_names": [], "method_name": "PreparedStatementProxy.setCharacterStream", "method_implementation": "{\n    if ((this.debug || (this.sqlStream != null)) && (this.parameters != null)) {\n        this.parameters[parameterIndex - 1] = \"[BLOB]\";\n    }\n    this.statement.setCharacterStream(parameterIndex, reader);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1199, "method_signature": "void setCharacterStream(int, Reader)"}, "PreparedStatementProxy.setClob": {"callee_method_names": [], "method_name": "PreparedStatementProxy.setClob", "method_implementation": "{\n    if ((this.debug || (this.sqlStream != null)) && (this.parameters != null)) {\n        this.parameters[parameterIndex - 1] = \"[CLOB]\";\n    }\n    this.statement.setClob(parameterIndex, x);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1200, "method_signature": "void setClob(int, Clob)"}, "PreparedStatementProxy.setNull": {"callee_method_names": [], "method_name": "PreparedStatementProxy.setNull", "method_implementation": "{\n    if ((this.debug || (this.sqlStream != null)) && (this.parameters != null)) {\n        this.parameters[parameterIndex - 1] = null;\n    }\n    this.statement.setNull(parameterIndex, sqlType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1201, "method_signature": "void setNull(int, int)"}, "PreparedStatementProxy.setObject": {"callee_method_names": [], "method_name": "PreparedStatementProxy.setObject", "method_implementation": "{\n    if ((this.debug || (this.sqlStream != null)) && (this.parameters != null)) {\n        this.parameters[parameterIndex - 1] = x;\n    }\n    this.statement.setObject(parameterIndex, x);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1202, "method_signature": "void setObject(int, Object)"}, "PreparedStatementProxy.setParamCount": {"callee_method_names": [], "method_name": "PreparedStatementProxy.setParamCount", "method_implementation": "{\n    if (count >= 0) {\n        this.parameters = new Object[count];\n    } else if (PreparedStatementProxy.LOG.isDebugEnabled()) {\n        this.getParameterMetaData();\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the parameter count for the statement.\n *\n * @param count\n *            the number of the parameters\n * @throws SQLException\n *             in case of an sql error\n */\n", "repo_name": "BatooJPA-master/", "id": 1203, "method_signature": "void setParamCount(int)"}, "PreparedStatementProxy.unwrap": {"callee_method_names": [], "method_name": "PreparedStatementProxy.unwrap", "method_implementation": "{\n    this.throwNotImplemented();\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1204, "method_signature": "T unwrap(Class)"}, "PrimaryKeyJoinColumnElement.generate": {"callee_method_names": [], "method_name": "PrimaryKeyJoinColumnElement.generate", "method_implementation": "{\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n    this.columnDefinition = this.getAttribute(ElementConstants.ATTR_COLUMN_DEFINITION, ElementConstants.EMPTY);\n    this.referencedColumnName = this.getAttribute(ElementConstants.ATTR_REFERENCED_COLUMN_NAME, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1086, "method_signature": "void generate()"}, "Prioritizer.sort": {"callee_method_names": [], "method_name": "Prioritizer.sort", "method_implementation": "{\n    Prioritizer.sort(updates, sortedUpdates, true, callbackAvailability);\n    Prioritizer.sort(removals, sortedRemovals, false, callbackAvailability);\n}", "repo_id": "1", "comment": "/**\n * Sorts the managed instances based on their dependencies.\n * <p>\n * Below is the array of callbacks:\n * <ul>\n * <li>Element 0, has PreRemove callback\n * <li>Element 1, has PrePersist or PreUpdate\n * <li>Element 2, has PostRemove\n * <li>Element 3, has PostPersist, PostRemove\n * </ul>\n *\n * @param updates\n *            the list of instances to be updated\n * @param removals\n *            the list of instances to be removed\n * @param sortedRemovals\n *            the sorted array of instances to be removed\n * @param sortedUpdates\n *            the sorted array of instances to be updated\n * @param callbackAvailability\n *            array of callbacks\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 937, "method_signature": "void sort(ArrayList, ArrayList, ManagedInstance<?>[], ManagedInstance<?>[], CallbackAvailability)"}, "PriotizerTest.testPersist": {"callee_method_names": [], "method_name": "PriotizerTest.testPersist", "method_implementation": "{\n    final Parent parent = this.parent();\n    this.persist(parent);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2271, "method_signature": "void testPersist()"}, "PriotizerTest.testPersistAndRemove": {"callee_method_names": [], "method_name": "PriotizerTest.testPersistAndRemove", "method_implementation": "{\n    final Parent parent = this.parent();\n    this.persist(parent);\n    this.commit();\n    this.persist(this.parent());\n    this.remove(parent);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2272, "method_signature": "void testPersistAndRemove()"}, "Properties.getProperties": {"callee_method_names": [], "method_name": "Properties.getProperties", "method_implementation": "{\n    if (properties == null) {\n        properties = new ArrayList<Persistence.PersistenceUnit.Properties.Property>();\n    }\n    return this.properties;\n}", "repo_id": "1", "comment": "/**\n * Gets the value of the properties property.\n *\n * <p>\n * This accessor method returns a reference to the live list,\n * not a snapshot. Therefore any modification you make to the\n * returned list will be present inside the JAXB object.\n * This is why there is not a <CODE>set</CODE> method for the properties property.\n *\n * <p>\n * For example, to add a new item, do as follows:\n * <pre>\n *    getProperties().add(newItem);\n * </pre>\n *\n * <p>\n * Objects of the following type(s) are allowed in the list\n * {@link Persistence.PersistenceUnit.Properties.Property }\n */\n", "repo_name": "BatooJPA-master/", "id": 983, "method_signature": "List<Persistence.PersistenceUnit.Properties.Property> getProperties()"}, "PropertyAccessor.get": {"callee_method_names": ["InternalInstance.__enhanced__$$__setInternalCall", "InternalInstance.__enhanced__$$__setInternalCall"], "method_name": "PropertyAccessor.get", "method_implementation": "{\n    try {\n        if (instance instanceof InternalInstance) {\n            final InternalInstance enhancedInstance = (InternalInstance) instance;\n            enhancedInstance.__enhanced__$$__setInternalCall(true);\n            try {\n                return this.reader.invoke(instance);\n            } finally {\n                enhancedInstance.__enhanced__$$__setInternalCall(true);\n            }\n        } else {\n            return this.reader.invoke(instance);\n        }\n    } catch (final Exception e) {\n        throw new BatooException(\"Cannot get field value: \" + this.name, e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 16, "method_signature": "Object get(Object)"}, "PropertyAccessor.set": {"callee_method_names": ["InternalInstance.__enhanced__$$__setInternalCall", "InternalInstance.__enhanced__$$__setInternalCall"], "method_name": "PropertyAccessor.set", "method_implementation": "{\n    try {\n        if (instance instanceof InternalInstance) {\n            final InternalInstance enhancedInstance = (InternalInstance) instance;\n            enhancedInstance.__enhanced__$$__setInternalCall(true);\n            try {\n                this.writer.invoke(instance, value);\n            } finally {\n                enhancedInstance.__enhanced__$$__setInternalCall(true);\n            }\n        } else {\n            this.writer.invoke(instance, value);\n        }\n    } catch (final Exception e) {\n        throw new BatooException(\"Cannot set field value: \" + this.name, e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 17, "method_signature": "void set(Object, Object)"}, "QueryDSLTest.testQueryDSL": {"callee_method_names": [], "method_name": "QueryDSLTest.testQueryDSL", "method_implementation": "{\n    // this.cq(\"select employee\\n\" + //\n    // \"from Employee employee\\n\" + //\n    // \"where exists (select employee34b11\\n\" + //\n    // \"from Employee employee34b11\\n\" + //\n    // \"  inner join employee34b11.jobFunctions as employee_jobFunctionse0181\\n\" + //\n    // \"where employee34b11 = employee and employee_jobFunctionse0181 in ?1)\");\n    // this.cq(\"select cat\\n\" + //\n    // \"from Cat cat\\n\" + //\n    // \"inner join fetch cat.mate as mate\");\n    //\n    // this.cq(\"select count(cat)\\n\" + \"from Cat cat\\n\" + \"where cat.id in ?1\");\n    //\n    // this.cq(\"select cat.name, otherCat.name\\n\" + //\n    // \"from Cat cat, Cat otherCat\\n\" + //\n    // \"where length(cat.name) > ?1 and length(otherCat.name) > ?1 and not (cat.name is null) and not otherCat.kittens is empty\");\n    //\n    // this.cq(\"select count(cat)\\n\" + //\n    // \"from Cat cat, Cat otherCat\\n\" + //\n    // \"where length(cat.name) > ?1 and length(otherCat.name) > ?1 and (cat.name is null or otherCat.kittens is empty)\") //\n    // .setParameter(1, 1).getResultList();\n    // this.cq(\"select count(cat)\\n\" + //\n    // \"from Cat cat, Cat otherCat\\n\" + //\n    // \"  left join cat.kittens as cat_kittens_0\\n\" + //\n    // \"where index(cat_kittens_0) = ?1 and length(cat.name) > ?1 and length(otherCat.name) > ?1 and cat_kittens_0 = ?2\") //\n    // .setParameter(1, 0).setParameter(2, new Cat()).getResultList();\n    // this.cq(\"select count(show)\\n\" + //\n    // \"from Show show\\n\" + //\n    // \"where containsKey(show.acts,?1)\");\n    // this.cq(\"select c from Cat c where c.id in (?1)\")//\n    // .setParameter(1, 0)//\n    // .setParameter(1, Arrays.asList(1, 2))//\n    // .setParameter(3, 10)//\n    // .getResultList();\n    // this.cq(\"select cat\\n\" + //\n    // \"from Cat cat\\n\" + //\n    // \"where cat.name in (select other.name\\n\" + //\n    // \"from Cat other\\n\" + //\n    // \"group by other.name)\");\n    // this.cq(\"select count(employee)\\n\" + //\n    // \"from Employee employee\\n\" + //\n    // \"where employee.lastName = ?1 and ?2 member of employee.jobFunctions\").getResultList();\n    // this.cq(\"select employee\\n\" + //\n    // \"from Employee employee\\n\" + //\n    // \"where exists (select employeecb36b\\n\" + //\n    // \"from Employee employeecb36b\\n\" + //\n    // \"  inner join employeecb36b.jobFunctions as employee_jobFunctions35bef\\n\" + //\n    // \"where employeecb36b = employee and employee_jobFunctions35bef in ?1)\");\n    this.cq(//\n    \"select count(company)\\n\" + //\n    \"from Company company\\n\" + \"where company.ratingOrdinal in ?1\").setParameter(1, new Object[] { Company.Rating.A, Company.Rating.AA });\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2540, "method_signature": "void testQueryDSL()"}, "QueryImpl.buildResultSetImpl": {"callee_method_names": ["Map<Integer, Integer>.put", "Map<Integer, Integer>.put", "Map<Integer, Integer>.size", "Connection.prepareStatement", "Connection.prepareStatement", "PreparedStatement.executeQuery"], "method_name": "QueryImpl.buildResultSetImpl", "method_implementation": "{\n    PreparedStatement statement = null;\n    ResultSet resultSet = null;\n    try {\n        final String _sql = this.sql;\n        final Map<Integer, Integer> repeat = Maps.newHashMap();\n        int sqlParamNo = 0;\n        for (final Object parameter : parameters) {\n            if (parameter != null) {\n                if (parameter instanceof Collection) {\n                    repeat.put(sqlParamNo, ((Collection<?>) parameter).size());\n                } else if (parameter.getClass().isArray()) {\n                    repeat.put(sqlParamNo, ((Object[]) parameter).length);\n                }\n            }\n            sqlParamNo++;\n        }\n        if (repeat.size() > 0) {\n            statement = connection.prepareStatement(this.expandParams(_sql, repeat));\n        } else {\n            statement = connection.prepareStatement(_sql);\n        }\n        this.fillStatement(statement, parameters, repeat);\n        resultSet = statement.executeQuery();\n        this.handle(resultSet);\n    } finally {\n        try {\n            DbUtils.close(resultSet);\n        } finally {\n            DbUtils.close(statement);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * The implementation of the result set build. Manages the statement, parameters and result set.\n *\n * @param connection\n *            the connection\n * @param parameters\n *            the parameters\n * @throws SQLException\n *             thrown by the underlying database in case of an error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 698, "method_signature": "void buildResultSetImpl(Connection, Object[])"}, "QueryImpl.executeUpdate": {"callee_method_names": [], "method_name": "QueryImpl.executeUpdate", "method_implementation": "{\n    // flush if specified\n    if (!this.q.isInternal() && this.em.hasActiveTransaction() && ((this.flushMode == FlushModeType.AUTO) || (this.em.getFlushMode() == FlushModeType.AUTO))) {\n        this.em.flush();\n    }\n    final Connection connection = this.em.getConnection();\n    final Object[] parameters = this.applyParameters(connection);\n    try {\n        this.em.assertTransaction();\n        return new QueryRunner(this.em.getJdbcAdaptor(), false).update(connection, this.sql, parameters);\n    } catch (final SQLException e) {\n        QueryImpl.LOG.error(e, \"Query failed\" + QueryImpl.LOG.lazyBoxed(this.sql, parameters));\n        this.em.setRollbackOnly();\n        throw new PersistenceException(\"Query failed\", e);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 699, "method_signature": "int executeUpdate()"}, "QueryImpl.expandParams": {"callee_method_names": ["String.length", "String.charAt", "StringBuffer.append", "Map<Integer,Integer>.get", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString"], "method_name": "QueryImpl.expandParams", "method_implementation": "{\n    final StringBuffer outSql = new StringBuffer();\n    int sqlIndex = 0;\n    int i = 0;\n    boolean inQuot = false;\n    while (i < _sql.length()) {\n        final char current = _sql.charAt(i);\n        if (current == '\\'') {\n            if (inQuot) {\n                inQuot = !inQuot;\n            }\n            outSql.append('\\'');\n        } else if (!inQuot && (current == '?')) {\n            final Integer repeatCount = repeat.get(sqlIndex);\n            if (repeatCount != null) {\n                int left = repeatCount;\n                outSql.append('?');\n                left--;\n                while (left > 0) {\n                    outSql.append(\", ?\");\n                    left--;\n                }\n                sqlIndex += repeatCount;\n            } else {\n                sqlIndex++;\n                outSql.append('?');\n            }\n        } else {\n            outSql.append(current);\n        }\n        i++;\n    }\n    return outSql.toString();\n}", "repo_id": "1", "comment": "/**\n * Expands the repeated parameters.\n *\n * @param _sql\n *            the original SQL\n * @param repeat\n *            the repeat map\n * @return the expanded SQL\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 700, "method_signature": "String expandParams(String, Map)"}, "QueryImpl.fillStatement": {"callee_method_names": ["PreparedStatement.getParameterMetaData", "Map<Integer,Integer>.size", "Map<Integer,Integer>.size", "Map<Integer,Integer>.values", "Map<Integer,Integer>.containsKey", "PreparedStatement.setObject", "PreparedStatement.setObject", "PreparedStatement.setObject", "ParameterMetaData.getParameterType", "PreparedStatement.setNull"], "method_name": "QueryImpl.fillStatement", "method_implementation": "{\n    // the following code has been adopted from Apache Commons DBUtils.\n    // no paramaters nothing to do\n    if ((parameters == null) || (parameters.length == 0)) {\n        return;\n    }\n    final ParameterMetaData pmd = this.pmdBroken ? null : statement.getParameterMetaData();\n    if (this.pmdBroken) {\n        int total = parameters.length - repeat.size();\n        if (repeat.size() > 0) {\n            for (final Integer repeatSize : repeat.values()) {\n                if (repeatSize != null) {\n                    total += repeatSize;\n                }\n            }\n        }\n        ((PreparedStatementProxy) statement).setParamCount(total);\n    }\n    int index = 1;\n    for (int i = 0; i < parameters.length; i++) {\n        if (parameters[i] != null) {\n            if (repeat.containsKey(i)) {\n                final Object paramValue = parameters[i];\n                if (paramValue instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) paramValue;\n                    for (final Object subParamValue : collection) {\n                        statement.setObject(index++, subParamValue);\n                    }\n                } else {\n                    final Object[] array = (Object[]) paramValue;\n                    for (final Object subParamValue : array) {\n                        statement.setObject(index++, subParamValue);\n                    }\n                }\n            } else {\n                statement.setObject(index++, parameters[i]);\n            }\n        } else {\n            // VARCHAR works with many drivers regardless\n            // of the actual column type. Oddly, NULL and\n            // OTHER don't work with Oracle's drivers.\n            int sqlType = Types.VARCHAR;\n            if (!this.pmdBroken) {\n                try {\n                    sqlType = pmd.getParameterType(index + 1);\n                } catch (final SQLException e) {\n                    this.pmdBroken = true;\n                }\n            }\n            statement.setNull(index++, sqlType);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Fills the statement with the parameters supplied.\n *\n * @param statement\n *            the statement\n * @param parameters\n *            the parameters\n * @param repeat\n *            the parameter repeat map\n * @throws SQLException\n *             thrown in case of an underlying SQL Exception\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 701, "method_signature": "void fillStatement(PreparedStatement, Object[], Map)"}, "QueryImpl.getParameter": {"callee_method_names": [], "method_name": "QueryImpl.getParameter", "method_implementation": "{\n    return (Parameter<T>) this.getParameter(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 705, "method_signature": "Parameter<T> getParameter(String, Class)"}, "QueryImpl.getParameterValue": {"callee_method_names": [], "method_name": "QueryImpl.getParameterValue", "method_implementation": "{\n    return (T) this.parameters.get(param);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 707, "method_signature": "T getParameterValue(Parameter)"}, "QueryImpl.getParameters": {"callee_method_names": ["Set<Parameter<?>>.addAll"], "method_name": "QueryImpl.getParameters", "method_implementation": "{\n    final Set<Parameter<?>> parameters = Sets.newHashSet();\n    parameters.addAll(this.q.getParameters());\n    return parameters;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 706, "method_signature": "Set<Parameter<?>> getParameters()"}, "QueryImpl.getResultList": {"callee_method_names": [], "method_name": "QueryImpl.getResultList", "method_implementation": "{\n    // flush if specified\n    if (!this.q.isInternal() && this.em.hasActiveTransaction() && ((this.flushMode == FlushModeType.AUTO) || (this.em.getFlushMode() == FlushModeType.AUTO))) {\n        this.em.flush();\n    }\n    ManagedInstance.LOCK_CONTEXT.set(this.getLockMode());\n    try {\n        return this.getResultListImpl();\n    } finally {\n        ManagedInstance.LOCK_CONTEXT.set(null);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 708, "method_signature": "List<X> getResultList()"}, "QueryImpl.getSingleResult": {"callee_method_names": ["List<X>.size", "List<X>.size", "List<X>.get"], "method_name": "QueryImpl.getSingleResult", "method_implementation": "{\n    final List<X> resultList = this.getResultList();\n    if (resultList.size() > 1) {\n        throw new NonUniqueResultException();\n    }\n    if (resultList.size() == 0) {\n        throw new NoResultException();\n    }\n    return resultList.get(0);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 709, "method_signature": "X getSingleResult()"}, "QueryImpl.handle": {"callee_method_ids": [487], "callee_method_names": ["ResultSet.getMetaData", "CriteriaQueryImpl<X>.getSelection", "ResultSet.next", "AbstractSelection<X>.handle", "CriteriaQueryImpl<X>.isDistinct", "SessionImpl.get"], "method_name": "QueryImpl.handle", "method_implementation": "{\n    this.md = rs.getMetaData();\n    final CriteriaQueryImpl<X> cq = (CriteriaQueryImpl<X>) this.q;\n    final AbstractSelection<X> selection = cq.getSelection();\n    final boolean debug = QueryImpl.LOG.isDebugEnabled();\n    if (debug) {\n        this.prepareLabels(this.md);\n    }\n    this.results = Lists.newArrayList();\n    final SessionImpl session = this.em.getSession();\n    // process the resultset\n    while (rs.next()) {\n        final X instance = selection.handle(this, session, rs);\n        if (!cq.isDistinct() || !this.results.contains(instance)) {\n            this.results.add(instance);\n        }\n        if (debug) {\n            this.storeData(rs);\n        }\n    }\n    final LockModeType lockMode = this.getLockMode();\n    if (lockMode != null) {\n        for (int i = 0; i < this.results.size(); i++) {\n            this.em.lock(session.get(this.results.get(i)), lockMode, null);\n        }\n    }\n    if (debug) {\n        this.dumpResultSet();\n    }\n    return this.results;\n}", "repo_id": "1", "comment": "/**\n * Handles and returns the value created from the result set.\n *\n * @param rs\n *            the result set\n * @return the value created from the result set\n * @throws SQLException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 710, "method_signature": "List<X> handle(ResultSet)"}, "QueryImpl.setFirstResult": {"callee_method_names": [], "method_name": "QueryImpl.setFirstResult", "method_implementation": "{\n    this.startPosition = startPosition;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 711, "method_signature": "TypedQuery<X> setFirstResult(int)"}, "QueryImpl.setFlushMode": {"callee_method_names": [], "method_name": "QueryImpl.setFlushMode", "method_implementation": "{\n    this.flushMode = flushMode;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 712, "method_signature": "QueryImpl<X> setFlushMode(FlushModeType)"}, "QueryImpl.setHint": {"callee_method_names": [], "method_name": "QueryImpl.setHint", "method_implementation": "{\n    this.hints.put(hintName, value);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 713, "method_signature": "TypedQuery<X> setHint(String, Object)"}, "QueryImpl.setLockMode": {"callee_method_names": [], "method_name": "QueryImpl.setLockMode", "method_implementation": "{\n    this.lockMode = lockMode;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 714, "method_signature": "TypedQuery<X> setLockMode(LockModeType)"}, "QueryImpl.setMaxResults": {"callee_method_names": [], "method_name": "QueryImpl.setMaxResults", "method_implementation": "{\n    this.maxResult = maxResult;\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 715, "method_signature": "TypedQuery<X> setMaxResults(int)"}, "QueryImpl.setParameter": {"callee_method_names": [], "method_name": "QueryImpl.setParameter", "method_implementation": "{\n    if (value instanceof Date) {\n        return this.setParameter(name, (Date) value, TemporalType.TIMESTAMP);\n    }\n    if (value instanceof Calendar) {\n        return this.setParameter(name, (Calendar) value, TemporalType.TIMESTAMP);\n    }\n    return this.putParam(this.getParameter(name), value);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 717, "method_signature": "TypedQuery<X> setParameter(String, Object)"}, "QueryImpl.storeData": {"callee_method_names": ["ResultSet.getObject"], "method_name": "QueryImpl.storeData", "method_implementation": "{\n    final Object[] data = new Object[this.md.getColumnCount()];\n    final int columnCount = this.md.getColumnCount();\n    for (int i = 0; i < columnCount; i++) {\n        try {\n            data[i] = rs.getObject(i + 1);\n        } catch (final Exception e) {\n            data[i] = \"[N/A]\";\n        }\n    }\n    this.data.add(data);\n}", "repo_id": "1", "comment": "/**\n * Stores the row to report the result set.\n *\n * @param rs\n *            the resultset\n * @throws SQLException\n *             thrown in case of an underlying SQL Exception\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 718, "method_signature": "void storeData(ResultSet)"}, "QueryImpl.unwrap": {"callee_method_names": [], "method_name": "QueryImpl.unwrap", "method_implementation": "{\n    return (T) this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 719, "method_signature": "T unwrap(Class)"}, "QueryRunner.convertSqlException": {"callee_method_names": ["SQLException.getMessage", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString", "SQLException.getSQLState", "SQLException.getErrorCode", "SQLException.setNextException"], "method_name": "QueryRunner.convertSqlException", "method_implementation": "{\n    String causeMessage = cause.getMessage();\n    if (causeMessage == null) {\n        causeMessage = \"\";\n    }\n    final StringBuffer msg = new StringBuffer(causeMessage);\n    msg.append(\" Query: \");\n    msg.append(sql);\n    msg.append(\" Parameters: \");\n    if (params == null) {\n        msg.append(\"[]\");\n    } else {\n        msg.append(Arrays.deepToString(params));\n    }\n    final SQLException e = new SQLException(msg.toString(), cause.getSQLState(), cause.getErrorCode());\n    e.setNextException(cause);\n    return e;\n}", "repo_id": "1", "comment": "/**\n * Throws a new exception with a more informative error message.\n *\n * @param cause\n *            The original exception that will be chained to the new exception when it's rethrown.\n *\n * @param sql\n *            The query that was executing when the exception happened.\n *\n * @param params\n *            The query replacement parameters; <code>null</code> is a valid value to pass in.\n * @return SQLException if a database access error occurs\n */\n", "repo_name": "BatooJPA-master/", "id": 1154, "method_signature": "SQLException convertSqlException(SQLException, String, Object[])"}, "QueryRunner.fillStatement": {"callee_method_names": ["JdbcAdaptor.modifiesParameters", "PreparedStatement.getParameterMetaData", "JdbcAdaptor.modifyParameters", "PreparedStatement.setCharacterStream", "PreparedStatement.setClob", "PreparedStatement.setBinaryStream", "PreparedStatement.setBlob", "PreparedStatement.setObject", "PreparedStatement.getParameterMetaData", "ParameterMetaData.getParameterType", "PreparedStatement.setNull"], "method_name": "QueryRunner.fillStatement", "method_implementation": "{\n    // use local variable for performance\n    boolean pmdKnownBroken = this.pmdKnownBroken;\n    ParameterMetaData pmd = this.pmd;\n    final boolean hasLob = this.hasLob;\n    if (pmdKnownBroken) {\n        ((PreparedStatementProxy) statement).setParamCount(params.length);\n    } else {\n        ((PreparedStatementProxy) statement).setParamCount(-1);\n    }\n    // if the jdbc adaptor wants to modify the parameters we let it do it its own way\n    final JdbcAdaptor jdbcAdaptor = this.jdbcAdaptor;\n    if ((jdbcAdaptor != null) && jdbcAdaptor.modifiesParameters()) {\n        pmd = this.pmd = statement.getParameterMetaData();\n        jdbcAdaptor.modifyParameters(pmd, params);\n    }\n    for (int i = 0; i < params.length; i++) {\n        final Object param = params[i];\n        if ((param != null) && (param != Void.TYPE)) {\n            if (hasLob && (param instanceof Clob)) {\n                if (this.jdbcAdaptor instanceof OracleAdaptor) {\n                    statement.setCharacterStream(i + 1, ((Clob) param).getCharacterStream());\n                } else {\n                    statement.setClob(i + 1, (Clob) param);\n                }\n            } else if (hasLob && (param instanceof Blob)) {\n                if (this.jdbcAdaptor instanceof OracleAdaptor) {\n                    statement.setBinaryStream(i + 1, ((Blob) param).getBinaryStream());\n                } else {\n                    statement.setBlob(i + 1, (Blob) param);\n                }\n            } else {\n                statement.setObject(i + 1, param);\n            }\n        } else {\n            if (!pmdKnownBroken && (pmd == null)) {\n                pmd = this.pmd = statement.getParameterMetaData();\n            }\n            // VARCHAR works with many drivers regardless of the actual column type.\n            // Oddly, NULL and OTHER don't work with Oracle's drivers.\n            int sqlType = Types.VARCHAR;\n            if (!pmdKnownBroken) {\n                try {\n                    sqlType = pmd.getParameterType(i + 1);\n                } catch (final SQLException e) {\n                    pmdKnownBroken = this.pmdKnownBroken = true;\n                }\n            }\n            if (param != Void.TYPE) {\n                statement.setNull(i + 1, sqlType);\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Fill the <code>PreparedStatement</code> replacement parameters with the given objects.\n *\n * @param statement\n *            PreparedStatement to fill\n * @param params\n *            Query replacement parameters; <code>null</code> is a valid value to pass in.\n * @throws SQLException\n *             if a database access error occurs\n */\n", "repo_name": "BatooJPA-master/", "id": 1155, "method_signature": "void fillStatement(PreparedStatement, Object[])"}, "QueryRunner.query": {"callee_method_names": ["Connection.prepareStatement", "PreparedStatement.executeQuery", "ResultSetHandler<T>.handle"], "method_name": "QueryRunner.query", "method_implementation": "{\n    PreparedStatement statement = null;\n    ResultSet resultSet = null;\n    try {\n        statement = conn.prepareStatement(sql);\n        if (params != null) {\n            this.fillStatement(statement, params);\n        }\n        resultSet = statement.executeQuery();\n        return rsh.handle(resultSet);\n    } catch (final SQLException e) {\n        throw this.convertSqlException(e, sql, params);\n    } finally {\n        try {\n            DbUtils.close(resultSet);\n        } finally {\n            DbUtils.close(statement);\n            if (closeConn) {\n                DbUtils.close(conn);\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Calls query after checking the parameters to ensure nothing is null.\n *\n * @param conn\n *            The connection to use for the query call.\n * @param closeConn\n *            True if the connection should be closed, false otherwise.\n * @param sql\n *            The SQL statement to execute.\n * @param params\n *            An array of query replacement parameters. Each row in this array is one set of batch replacement values.\n * @return The results of the query.\n * @throws SQLException\n *             If there are database or parameter errors.\n */\n", "repo_name": "BatooJPA-master/", "id": 1156, "method_signature": "T query(Connection, boolean, String, ResultSetHandler, Object[])"}, "QueryRunner.update": {"callee_method_names": ["Connection.prepareStatement", "PreparedStatement.executeUpdate"], "method_name": "QueryRunner.update", "method_implementation": "{\n    if (connection == null) {\n        throw new SQLException(\"Null connection\");\n    }\n    if (sql == null) {\n        if (closeConn) {\n            DbUtils.close(connection);\n        }\n        throw new SQLException(\"Null SQL statement\");\n    }\n    PreparedStatement statement = null;\n    try {\n        statement = connection.prepareStatement(sql);\n        if (params != null) {\n            this.fillStatement(statement, params);\n        }\n        return statement.executeUpdate();\n    } catch (final SQLException e) {\n        throw this.convertSqlException(e, sql, params);\n    } finally {\n        DbUtils.close(statement);\n        if (closeConn) {\n            DbUtils.close(connection);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Calls update after checking the parameters to ensure nothing is null.\n *\n * @param connection\n *            The connection to use for the update call.\n * @param closeConn\n *            True if the connection should be closed, false otherwise.\n * @param sql\n *            The SQL statement to execute.\n * @param params\n *            An array of update replacement parameters. Each row in this array is one set of update replacement values.\n * @return The number of rows updated.\n * @throws SQLException\n *             If there are database or parameter errors.\n */\n", "repo_name": "BatooJPA-master/", "id": 1157, "method_signature": "int update(Connection, boolean, String, Object[])"}, "ReadOnlyColumnTest.testColumnNames": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getHomeAddress", "Person.getHomeAddress", "Person.getHomeAddress"], "method_name": "ReadOnlyColumnTest.testColumnNames", "method_implementation": "{\n    Person person = new Person(1, \"Ceylan\", new Address(1, \"Istanbul\"));\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    Assert.assertFalse(this.emf().getPersistenceUnitUtil().isLoaded(person.getHomeAddress()));\n    person.getHomeAddress().getId();\n    Assert.assertTrue(this.emf().getPersistenceUnitUtil().isLoaded(person.getHomeAddress()));\n    Assert.assertEquals(\"[address_id, id, name]\", new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT * FROM Person\", new ColumnNameListHandler()));\n}", "repo_id": "1", "comment": "/**\n * Tests generated DDL column names\n *\n * @throws SQLException\n *             thrown in case of an error\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2199, "method_signature": "void testColumnNames()"}, "ReflectHelper.convertNumber": {"callee_method_names": ["Class<?>.isAssignableFrom", "Number.getClass", "Number.intValue", "Number.longValue", "Number.shortValue", "Number.byteValue", "Number.floatValue", "Number.doubleValue", "Number.doubleValue", "Number.longValue"], "method_name": "ReflectHelper.convertNumber", "method_implementation": "{\n    if (value == null) {\n        return null;\n    }\n    if (numberType.isAssignableFrom(value.getClass())) {\n        return value;\n    }\n    if ((numberType == Integer.class) || (numberType == Integer.TYPE)) {\n        return value.intValue();\n    }\n    if ((numberType == Long.class) || (numberType == Long.TYPE)) {\n        return value.longValue();\n    }\n    if ((numberType == Short.class) || (numberType == Short.TYPE)) {\n        return value.shortValue();\n    }\n    if ((numberType == Byte.class) || (numberType == Byte.TYPE)) {\n        return value.byteValue();\n    }\n    if ((numberType == Float.class) || (numberType == Float.TYPE)) {\n        return value.floatValue();\n    }\n    if ((numberType == Double.class) || (numberType == Double.TYPE)) {\n        return value.doubleValue();\n    }\n    if (numberType == BigDecimal.class) {\n        return BigDecimal.valueOf(value.doubleValue());\n    }\n    if (numberType == BigInteger.class) {\n        return BigInteger.valueOf(value.longValue());\n    }\n    throw new IllegalArgumentException(numberType + \" not supported\");\n}", "repo_id": "1", "comment": "/**\n * Converts the number into number Type\n *\n * @param value\n *            the number value\n * @param numberType\n *            the number type\n * @return the converted number value\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 6, "method_signature": "Number convertNumber(Number, Class)"}, "ReflectHelper.createConstructor": {"callee_method_names": [], "method_name": "ReflectHelper.createConstructor", "method_implementation": "{\n    try {\n        Class.forName(\"sun.reflect.ConstructorAccessor\");\n    } catch (final ClassNotFoundException e) {\n        return new SimpleConstructorAccessor(constructor);\n    }\n    return ReflectHelper.createConstructorImpl(constructor);\n}", "repo_id": "1", "comment": "/**\n * Creates and returns a fast constructor accessor.\n *\n * @param constructor\n *            the original constructor\n * @return the constructor accessor\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 7, "method_signature": "ConstructorAccessor createConstructor(Constructor)"}, "ReflectHelper.getAccessor": {"callee_method_names": ["Member.getName", "Member.getName", "Member.getName", "Member.getDeclaringClass", "Member.getDeclaringClass", "Member.getDeclaringClass"], "method_name": "ReflectHelper.getAccessor", "method_implementation": "{\n    if (javaMember instanceof Field) {\n        return ReflectHelper.unsafe != null ? new UnsafeFieldAccessor((Field) javaMember) : new FieldAccessor((Field) javaMember);\n    } else {\n        String name = javaMember.getName().startsWith(ReflectHelper.IS_PREFIX) ? javaMember.getName().substring(2) : javaMember.getName().substring(3);\n        name = StringUtils.uncapitalize(name);\n        final Class<?> declaringClass = javaMember.getDeclaringClass();\n        final PropertyDescriptor[] properties = ReflectHelper.getProperties(declaringClass);\n        for (final PropertyDescriptor descriptor : properties) {\n            if (descriptor.getName().equals(name)) {\n                return new PropertyAccessor(descriptor);\n            }\n        }\n        Field field;\n        try {\n            field = javaMember.getDeclaringClass().getDeclaredField(StringUtils.uncapitalize(name));\n            return new FieldAccessor(field);\n        } catch (final Exception e) {\n            throw new BatooException(\"Cannot find instance variable field \" + javaMember.getDeclaringClass().getName() + \".\" + name);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Returns the accessor for the member\n *\n * @param javaMember\n *            the java member\n * @return the accessor\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 8, "method_signature": "AbstractAccessor getAccessor(Member)"}, "ReflectHelper.getActualType": {"callee_method_names": ["Class<?>.isPrimitive"], "method_name": "ReflectHelper.getActualType", "method_implementation": "{\n    if (originalType.isPrimitive()) {\n        return (Class<T>) originalType;\n    }\n    final String methodName = \"get\" + StringUtils.capitalize(attributeName);\n    final Class<T> actualType = (Class<T>) ReflectHelper.getTypeImpl(clazz, originalType, methodName, Lists.<Type>newArrayList());\n    return actualType;\n}", "repo_id": "1", "comment": "/**\n * Returns the actual type of the attribute, resolving generic types if necessary.\n *\n * @param clazz\n *            the actual class\n * @param attributeName\n *            the name of the attribute\n * @param originalType\n *            th original type of the attribute\n * @return the actual type of the attribute\n * @param <T>\n *            the xpected type\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 9, "method_signature": "Class<T> getActualType(Class, String, Class)"}, "ReflectHelper.getAnnotation": {"callee_method_names": [], "method_name": "ReflectHelper.getAnnotation", "method_implementation": "{\n    if (member instanceof Field) {\n        return ((Field) member).getAnnotation(annotation);\n    }\n    if (member instanceof Method) {\n        return ((Method) member).getAnnotation(annotation);\n    }\n    throw new IllegalArgumentException(\"Member is neither field nor method: \" + member);\n}", "repo_id": "1", "comment": "/**\n * Returns the annotation instance if the <code>member</code> has the <code>annotation</code>.\n *\n * @param member\n *            the member\n * @param annotation\n *            the type of the annotation instance to return\n * @return the <code>annotation</code> instance if the <code>member</code> has the annotation or null\n *\n * @param <A>\n *            the class of annotation\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 10, "method_signature": "A getAnnotation(Member, Class)"}, "ReflectHelper.getGenericType": {"callee_method_names": ["Field.getGenericType", "Method.getGenericReturnType", "ParameterizedType.getActualTypeArguments"], "method_name": "ReflectHelper.getGenericType", "method_implementation": "{\n    Type type;\n    if (member instanceof Field) {\n        final Field field = (Field) member;\n        type = field.getGenericType();\n    } else {\n        final Method method = (Method) member;\n        type = method.getGenericReturnType();\n    }\n    // if not a parameterized type return null\n    if (!(type instanceof ParameterizedType)) {\n        return null;\n    }\n    final ParameterizedType parameterizedType = (ParameterizedType) type;\n    final Type[] types = parameterizedType.getActualTypeArguments();\n    return (Class<X>) ((types != null) && (index < types.length) ? types[index] : null);\n}", "repo_id": "1", "comment": "/**\n * Returns the actual generic type of a class's type parameter of the <code>member</code>.\n * <p>\n * if the <code>member</code> is a field then field's generic types are checked. Otherwise the <code>member</code> is treated a a method\n * and its return type's is checked.\n * <p>\n *\n * @param member\n *            the member\n * @param index\n *            the index number of the generic parameter\n * @return the class of generic type\n *\n * @param <X>\n *            the type of the class\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 11, "method_signature": "Class<X> getGenericType(Member, int)"}, "ReflectHelper.getMemberType": {"callee_method_names": [], "method_name": "ReflectHelper.getMemberType", "method_implementation": "{\n    if (member instanceof Field) {\n        return ((Field) member).getType();\n    }\n    return ((Method) member).getReturnType();\n}", "repo_id": "1", "comment": "/**\n * Returns the type class of the <code>member</code>.\n *\n * @param member\n *            the member\n * @return the <code>member</code>'s type as java class\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 12, "method_signature": "Class<?> getMemberType(Member)"}, "ReflectHelper.getProperties": {"callee_method_names": ["Class<?>.getDeclaredMethods", "Method.getModifiers", "Method.isBridge", "Method.isSynthetic", "Method.getName", "Method.getParameterTypes", "String.startsWith", "List<PropertyDescriptor>.add", "String.substring", "Method.getReturnType", "String.startsWith", "List<PropertyDescriptor>.add", "String.substring", "List<PropertyDescriptor>.toArray", "List<PropertyDescriptor>.size"], "method_name": "ReflectHelper.getProperties", "method_implementation": "{\n    final List<PropertyDescriptor> properties = Lists.newArrayList();\n    final Method[] methodList = clazz.getDeclaredMethods();\n    // check each method.\n    for (final Method method : methodList) {\n        if (method == null) {\n            continue;\n        }\n        // skip static and private methods.\n        final int mods = method.getModifiers();\n        if (Modifier.isStatic(mods) || !Modifier.isPublic(mods) || method.isBridge() || method.isSynthetic()) {\n            continue;\n        }\n        final String name = method.getName();\n        if (method.getParameterTypes().length == 0) {\n            if (name.startsWith(ReflectHelper.GET_PREFIX)) {\n                properties.add(new PropertyDescriptor(clazz, name.substring(3), method));\n            } else if ((method.getReturnType() == boolean.class) && name.startsWith(ReflectHelper.IS_PREFIX)) {\n                properties.add(new PropertyDescriptor(clazz, name.substring(2), method));\n            }\n        }\n    }\n    return properties.toArray(new PropertyDescriptor[properties.size()]);\n}", "repo_id": "1", "comment": "/**\n * Returns the property descriptors for the class.\n *\n * @param clazz\n *            the class\n * @return the property descriptors\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 13, "method_signature": "PropertyDescriptor[] getProperties(Class)"}, "ReflectHelper.setAccessible": {"callee_method_names": [], "method_name": "ReflectHelper.setAccessible", "method_implementation": "{\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n\n        @Override\n        public Void run() {\n            if (member instanceof Field) {\n                ((Field) member).setAccessible(accessible);\n            } else if (member instanceof Method) {\n                ((Method) member).setAccessible(accessible);\n            } else {\n                ((Constructor<?>) member).setAccessible(accessible);\n            }\n            return null;\n        }\n    });\n}", "repo_id": "1", "comment": "/**\n * Sets the member's accessibility status.\n *\n * @param member\n *            the member of which to set accessibility status\n * @param accessible\n *            true to set accessible, false to make it not accessible\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 14, "method_signature": "void setAccessible(Member, boolean)"}, "ReflectHelper.warnAnnotations": {"callee_method_names": ["Set<Class<? extends Annotation>>.contains", "Class<A>.annotationType", "Set<Annotation>.size", "BLogger.warn"], "method_name": "ReflectHelper.warnAnnotations", "method_implementation": "{\n    final Set<Annotation> existing;\n    if (member instanceof Field) {\n        existing = Sets.newHashSet(((Field) member).getAnnotations());\n    } else {\n        existing = Sets.newHashSet(((Method) member).getAnnotations());\n    }\n    final Set<Annotation> filtered = Sets.filter(existing, new Predicate<Annotation>() {\n\n        @Override\n        public boolean apply(Annotation input) {\n            for (final Annotation annotation : existing) {\n                if (annotations.contains(annotation.annotationType())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    });\n    if (filtered.size() > 0) {\n        logger.warn(\"Following annotations on {0} were ignored: {1}\", ReflectHelper.createMemberName(member), Joiner.on(\", \").join(filtered));\n    }\n}", "repo_id": "1", "comment": "/**\n * Logs warnings for annotations that were ignored.\n *\n * @param logger\n *            the logger to log the warnings.\n * @param member\n *            the member\n * @param annotations\n *            the set of annotations allowed\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 15, "method_signature": "void warnAnnotations(BLogger, Member, Set)"}, "RefreshTest.prepareCountries": {"callee_method_names": [], "method_name": "RefreshTest.prepareCountries", "method_implementation": "{\n    this.persist(RefreshTest.TR);\n    this.persist(RefreshTest.USA);\n    this.persist(RefreshTest.UK);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2181, "method_signature": "void prepareCountries()"}, "RefreshTest.testRefresh": {"callee_method_ids": [2454], "callee_method_names": ["Person.getId", "Person.getAddresses", "int.hasNext", "int.next", "Address.getCity", "Address.setCity", "Address.getCountry", "Country.setName", "Address.setCountry", "int.remove", "Person.setName", "Person.getName", "Address.getCity", "Address.getCountry", "Country.getName", "Person.getAddresses"], "method_name": "RefreshTest.testRefresh", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    Address address = null;\n    Country country = null;\n    for (final Iterator<Address> i = person.getAddresses().iterator(); i.hasNext(); ) {\n        address = i.next();\n        if (RefreshTest.CITY_ISTANBUL.equals(address.getCity())) {\n            address.setCity(\"SomeCity\");\n            country = address.getCountry();\n            country.setName(RefreshTest.COUNTRY_GERMANY);\n            address.setCountry(null);\n            i.remove();\n            break;\n        }\n    }\n    person.setName(\"Ceylan2\");\n    this.refresh(person);\n    Assert.assertEquals(\"Ceylan\", person.getName());\n    Assert.assertEquals(RefreshTest.CITY_ISTANBUL, address.getCity());\n    Assert.assertEquals(country, address.getCountry());\n    Assert.assertEquals(RefreshTest.COUNTRY_GERMANY, country.getName());\n    Assert.assertEquals(3, person.getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} person.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2182, "method_signature": "void testRefresh()"}, "RemoveTest.createParent": {"callee_method_names": [], "method_name": "RemoveTest.createParent", "method_implementation": "{\n    final Parent parent = new Parent(RemoveTest.VALUE);\n    new Child1(parent, RemoveTest.VALUE);\n    new Child1(parent, RemoveTest.VALUE);\n    new Child2(parent, RemoveTest.VALUE);\n    new Child2(parent, RemoveTest.VALUE);\n    new Child3(parent, RemoveTest.VALUE);\n    new Child3(parent, RemoveTest.VALUE);\n    new Child4(parent, RemoveTest.VALUE);\n    new Child4(parent, RemoveTest.VALUE);\n    return parent;\n}", "repo_id": "1", "comment": "/**\n * Returns a newly created parent.\n *\n * @return\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2273, "method_signature": "Parent createParent()"}, "RemoveTest.getCounts": {"callee_method_names": [], "method_name": "RemoveTest.getCounts", "method_implementation": "{\n    final int[] counts = new int[4];\n    try {\n        for (int i = 0; i < 4; i++) {\n            counts[i] = //\n            new QueryRunner(this.em().unwrap(DataSource.class)).//\n            query(//\n            \"SELECT COUNT(*) FROM Child\" + (i + 1), new SingleValueHandler<Number>()).intValue();\n        }\n        RemoveTest.LOG.debug(\"Remaining children are: {0}, {1}, {2}, {3}\", counts[0], counts[1], counts[2], counts[3]);\n    } catch (final SQLException e) {\n        throw new RuntimeException(e);\n    }\n    return counts;\n}", "repo_id": "1", "comment": "/**\n * Returns the counts\n *\n * @return counts\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2274, "method_signature": "int[] getCounts()"}, "RemoveTest.testFlushRemoval": {"callee_method_names": [], "method_name": "RemoveTest.testFlushRemoval", "method_implementation": "{\n    final Parent parent = this.createParent();\n    this.persist(parent);\n    this.flush();\n    this.remove(parent);\n    this.commit();\n    Assert.assertTrue(Arrays.equals(new int[] { 0, 0, 2, 0 }, this.getCounts()));\n}", "repo_id": "1", "comment": "/**\n * Tests the orphans removed correctly.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2275, "method_signature": "void testFlushRemoval()"}, "RemoveTest.testOrphanPersistCommitThenRemove": {"callee_method_names": [], "method_name": "RemoveTest.testOrphanPersistCommitThenRemove", "method_implementation": "{\n    this.persist(this.createParent());\n    Parent parent = this.createParent();\n    this.persist(parent);\n    this.commit();\n    parent = this.merge(parent);\n    this.remove(parent);\n    this.commit();\n    Assert.assertEquals(Arrays.toString(new int[] { 2, 2, 4, 2 }), Arrays.toString(this.getCounts()));\n}", "repo_id": "1", "comment": "/**\n * Tests the orphans removed correctly.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2276, "method_signature": "void testOrphanPersistCommitThenRemove()"}, "RemoveTest.testOrphanPersistThenRemove": {"callee_method_names": [], "method_name": "RemoveTest.testOrphanPersistThenRemove", "method_implementation": "{\n    this.persist(this.createParent());\n    final Parent parent = this.createParent();\n    this.persist(parent);\n    this.remove(parent);\n    this.commit();\n    Assert.assertEquals(Arrays.toString(new int[] { 2, 2, 4, 2 }), Arrays.toString(this.getCounts()));\n}", "repo_id": "1", "comment": "/**\n * Tests the orphans removed correctly.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2277, "method_signature": "void testOrphanPersistThenRemove()"}, "RemoveTest.testOrphanRemoval": {"callee_method_names": ["Parent.getChildren1", "Parent.getChildren2", "Parent.getChildren3", "Parent.getChildren4"], "method_name": "RemoveTest.testOrphanRemoval", "method_implementation": "{\n    final Parent parent = this.createParent();\n    this.persist(parent);\n    parent.getChildren1().clear();\n    parent.getChildren2().clear();\n    parent.getChildren3().clear();\n    parent.getChildren4().clear();\n    this.commit();\n    Assert.assertEquals(Arrays.toString(new int[] { 0, 2, 2, 0 }), Arrays.toString(this.getCounts()));\n}", "repo_id": "1", "comment": "/**\n * Tests the orphans removed correctly.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2278, "method_signature": "void testOrphanRemoval()"}, "RemoveTest.testOrphanRemovalPersist": {"callee_method_names": ["Parent.getChildren1", "Parent.getChildren2", "Parent.getChildren3", "Parent.getChildren4"], "method_name": "RemoveTest.testOrphanRemovalPersist", "method_implementation": "{\n    Parent parent = this.createParent();\n    this.persist(parent);\n    this.commit();\n    parent = this.merge(parent);\n    parent.getChildren1().clear();\n    parent.getChildren2().clear();\n    parent.getChildren3().clear();\n    parent.getChildren4().clear();\n    this.commit();\n    Assert.assertEquals(Arrays.toString(new int[] { 0, 2, 2, 0 }), Arrays.toString(this.getCounts()));\n}", "repo_id": "1", "comment": "/**\n * Tests the orphans removed correctly.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2279, "method_signature": "void testOrphanRemovalPersist()"}, "RemoveTest.testRemoval": {"callee_method_names": [], "method_name": "RemoveTest.testRemoval", "method_implementation": "{\n    final Parent parent = this.createParent();\n    this.persist(parent);\n    this.remove(parent);\n    this.commit();\n    Assert.assertEquals(Arrays.toString(new int[] { 0, 0, 2, 0 }), Arrays.toString(this.getCounts()));\n}", "repo_id": "1", "comment": "/**\n * Tests the orphans removed correctly.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2280, "method_signature": "void testRemoval()"}, "RootImpl.generateJpqlSelect": {"callee_method_names": [], "method_name": "RootImpl.generateJpqlSelect", "method_implementation": "{\n    super.generateJpqlSelect(query, selected);\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.getAlias();\n    }\n    return this.getModel().getName();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 503, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "RootImpl.generateSqlFrom": {"callee_method_names": ["BaseQueryImpl<?>.isQuery", "EntityTable.getQName", "EntityTable.getQName"], "method_name": "RootImpl.generateSqlFrom", "method_implementation": "{\n    final EntityTable primaryTable = this.entity.getRootType().getPrimaryTable();\n    if (query.isQuery()) {\n        return primaryTable.getQName() + \" \" + this.getFetchRoot().getTableAlias(query, primaryTable);\n    }\n    return primaryTable.getQName();\n}", "repo_id": "1", "comment": "/**\n * Returns the generated from SQL fragment.\n *\n * @param query\n *            the query\n * @return the generated from SQL fragment\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 504, "method_signature": "String generateSqlFrom(BaseQueryImpl)"}, "RootImpl.getMapping": {"callee_method_names": [], "method_name": "RootImpl.getMapping", "method_implementation": "{\n    final AbstractMapping<? super X, ?, ?> child = this.entity.getRootMapping().getChild(name);\n    if (child == null) {\n        throw this.cannotDereference(name);\n    }\n    return (AbstractMapping<? super X, C, Y>) child;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 505, "method_signature": "AbstractMapping<? super X,C,Y> getMapping(String)"}, "SawSqlAdaptor.applyLock": {"callee_method_names": [], "method_name": "SawSqlAdaptor.applyLock", "method_implementation": "{\n    switch(lockMode) {\n        case PESSIMISTIC_FORCE_INCREMENT:\n        case PESSIMISTIC_READ:\n            return sql + \"\\nFOR READ ONLY\";\n        case PESSIMISTIC_WRITE:\n            return sql + \"\\nFOR UPDATE\";\n        default:\n            break;\n    }\n    return sql;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1244, "method_signature": "String applyLock(String, LockModeType)"}, "SawSqlAdaptor.applyPagination": {"callee_method_names": ["String.replaceFirst", "StringBuffer.indexOf", "StringBuffer.subSequence", "StringBuffer.length", "StringBuffer.delete", "StringBuffer.length", "StringBuffer.indexOf", "StringBuffer.insert"], "method_name": "SawSqlAdaptor.applyPagination", "method_implementation": "{\n    if (startPosition == 0) {\n        return sql.replaceFirst(\"SELECT\", \"SELECT TOP \" + maxResult);\n    }\n    sql = BatooUtils.indent(sql);\n    final StringBuffer sqlStr = new StringBuffer(sql);\n    final int orderIndex = sqlStr.indexOf(\"ORDER BY\");\n    final CharSequence orderby = orderIndex > -1 ? sqlStr.subSequence(orderIndex, sqlStr.length()) : \"ORDER BY CURRENT_TIMESTAMP\";\n    if (orderIndex > -1) {\n        sqlStr.delete(orderIndex, sqlStr.length());\n    }\n    final int fromIndex = sqlStr.indexOf(\"FROM\");\n    sqlStr.insert(fromIndex, \"\\t, ROW_NUMBER() OVER (\" + orderby + \") AS ROW_NUM__INTERNAL \");\n    if (maxResult == Integer.MAX_VALUE) {\n        return \"SELECT * FROM (\\n\" + sqlStr + \"\\n) AS PAGINATED_RESULT WHERE ROW_NUM__INTERNAL > ? ORDER BY ROW_NUM__INTERNAL\";\n    }\n    return \"SELECT * FROM (\\n\" + sqlStr + \")\\nAS PAGINATED_RESULT WHERE ROW_NUM__INTERNAL > ? AND ROW_NUM__INTERNAL < ? ORDER BY ROW_NUM__INTERNAL\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1245, "method_signature": "String applyPagination(String, int, int)"}, "SawSqlAdaptor.applySubStr": {"callee_method_names": [], "method_name": "SawSqlAdaptor.applySubStr", "method_implementation": "{\n    if (endFragment != null) {\n        return \"SUBSTRING(\" + Joiner.on(\", \").skipNulls().join(new Object[] { innerFragment, startFragment, endFragment }) + \")\";\n    }\n    return \"SUBSTRING(\" + Joiner.on(\", \").skipNulls().join(new Object[] { innerFragment, startFragment, Integer.toString(Integer.MAX_VALUE) }) + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1246, "method_signature": "String applySubStr(String, String, String)"}, "SawSqlAdaptor.applyTrim": {"callee_method_names": [], "method_name": "SawSqlAdaptor.applyTrim", "method_implementation": "{\n    if (trimChar != null) {\n        throw new PersistenceException(\"MSSQL Server does not support trim character\");\n    }\n    if (trimspec == null) {\n        trimspec = Trimspec.BOTH;\n    }\n    switch(trimspec) {\n        case LEADING:\n            return \"LTRIM(\" + argument + \")\";\n        case TRAILING:\n            return \"RTRIM(\" + argument + \")\";\n        default:\n            return \"RTRIM(LTRIM(\" + argument + \"))\";\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1247, "method_signature": "String applyTrim(Trimspec, String, String)"}, "SawSqlAdaptor.createColumnDDL": {"callee_method_names": ["AbstractColumn.getIdType", "AbstractColumn.getName", "AbstractColumn.getSqlType", "AbstractColumn.isNullable", "AbstractColumn.isUnique"], "method_name": "SawSqlAdaptor.createColumnDDL", "method_implementation": "{\n    final boolean identity = column.getIdType() == IdType.IDENTITY;\n    return // name part\n    column.getName() + \" \" + // data type part\n    this.getColumnType(column, column.getSqlType()) + // not null part\n    (!column.isNullable() ? \" NOT NULL\" : \"\") + // not null part\n    (column.isUnique() ? \" UNIQUE\" : \"\") + // auto increment part\n    (identity ? \" IDENTITY(1,1)\" : \"\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1248, "method_signature": "String createColumnDDL(AbstractColumn)"}, "SawSqlAdaptor.createSequenceIfNecessary": {"callee_method_names": ["SequenceGenerator.getSequenceName", "SequenceGenerator.getInitialValue", "SequenceGenerator.getAllocationSize", "SequenceGenerator.getName"], "method_name": "SawSqlAdaptor.createSequenceIfNecessary", "method_implementation": "{\n    final String sql = //\n    \"CREATE SEQUENCE \" + // ;\n    sequence.getSequenceName() + \" START WITH \" + //\n    sequence.getInitialValue() + \" INCREMENT BY \" + sequence.getAllocationSize();\n    try {\n        new QueryRunner(datasource).update(sql);\n    } catch (final SQLException e) {\n        this.logRelaxed(e, \"Cannot create sequence \" + sequence.getName());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1249, "method_signature": "void createSequenceIfNecessary(DataSource, SequenceGenerator)"}, "SawSqlAdaptor.getColumnType": {"callee_method_names": ["AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getLength", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getPrecision", "AbstractColumn.getScale", "AbstractColumn.getScale"], "method_name": "SawSqlAdaptor.getColumnType", "method_implementation": "{\n    switch(sqlType) {\n        case Types.BLOB:\n            return \"VARBINARY(\" + cd.getLength() + \")\";\n        case Types.CLOB:\n            return \"NVARCHAR(\" + cd.getLength() + \")\";\n        case Types.VARCHAR:\n            return \"NVARCHAR(\" + cd.getLength() + \")\";\n        case Types.TIME:\n        case Types.DATE:\n        case Types.TIMESTAMP:\n            return \"DATE\";\n        case Types.CHAR:\n            return \"CHAR\";\n        case Types.BOOLEAN:\n            return \"BIT\";\n        case Types.TINYINT:\n            return \"TINYINT\";\n        case Types.SMALLINT:\n            return \"SMALLINT\";\n        case Types.INTEGER:\n            return \"INTEGER\";\n        case Types.BIGINT:\n            return \"BIGINT\";\n        case Types.FLOAT:\n        case Types.DOUBLE:\n            return \"FLOAT\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + \")\" : \"\");\n        case Types.DECIMAL:\n            return \"DECIMAL\" + (cd.getPrecision() > 0 ? \"(\" + cd.getPrecision() + (cd.getScale() > 0 ? \",\" + cd.getScale() : \"\") + \")\" : \"\");\n    }\n    throw new IllegalArgumentException(\"Unhandled sql type: \" + sqlType);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1250, "method_signature": "String getColumnType(AbstractColumn, int)"}, "SawSqlAdaptor.getNextSequence": {"callee_method_names": [], "method_name": "SawSqlAdaptor.getNextSequence", "method_implementation": "{\n    return //\n    new QueryRunner(datasource).query(\"SELECT \" + sequenceName + \".NEXTVAL\", new SingleValueHandler<Number>()).longValue();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1251, "method_signature": "long getNextSequence(DataSource, String)"}, "SawSqlAdaptor.getNumericFunctionTemplate": {"callee_method_names": [], "method_name": "SawSqlAdaptor.getNumericFunctionTemplate", "method_implementation": "{\n    if (type == NumericFunctionType.MOD) {\n        return \"{0} % {1}\";\n    }\n    if (type == NumericFunctionType.LENGTH) {\n        return \"LEN({0})\";\n    }\n    return super.getNumericFunctionTemplate(type);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1252, "method_signature": "String getNumericFunctionTemplate(NumericFunctionType)"}, "SawSqlAdaptor.supports": {"callee_method_names": [], "method_name": "SawSqlAdaptor.supports", "method_implementation": "{\n    if (type == null) {\n        return IdType.SEQUENCE;\n    }\n    switch(type) {\n        case IDENTITY:\n            return IdType.SEQUENCE;\n        case SEQUENCE:\n            return IdType.SEQUENCE;\n        case TABLE:\n            return IdType.TABLE;\n        default:\n            return IdType.SEQUENCE;\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1253, "method_signature": "IdType supports(GenerationType)"}, "SecondaryTable.link": {"callee_method_names": [], "method_name": "SecondaryTable.link", "method_implementation": "{\n    if (this.foreignKey == null) {\n        this.foreignKey = new ForeignKey(this.getJdbcAdaptor(), this, this.getEntity(), this.metadata);\n    }\n}", "repo_id": "1", "comment": "/**\n * Links the secondary table to the primary table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1133, "method_signature": "void link()"}, "SecondaryTableElement.generate": {"callee_method_names": [], "method_name": "SecondaryTableElement.generate", "method_implementation": "{\n    this.catalog = this.getAttribute(ElementConstants.ATTR_CATALOG, ElementConstants.EMPTY);\n    this.schema = this.getAttribute(ElementConstants.ATTR_SCHEMA, ElementConstants.EMPTY);\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1063, "method_signature": "void generate()"}, "SecondaryTableElement.handleChild": {"callee_method_names": [], "method_name": "SecondaryTableElement.handleChild", "method_implementation": "{\n    if (child instanceof UniqueConstraintsElement) {\n        this.uniqueConstraints.add((UniqueConstraintMetadata) child);\n    }\n    if (child instanceof PrimaryKeyJoinColumnElement) {\n        this.primaryKeyJoinColumns.add((PrimaryKeyJoinColumnMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1064, "method_signature": "void handleChild(Element)"}, "SecondaryTableTest.testCreateTable": {"callee_method_names": ["Set<EntityType<?>>.size"], "method_name": "SecondaryTableTest.testCreateTable", "method_implementation": "{\n    final Set<EntityType<?>> entities = this.em().getMetamodel().getEntities();\n    Assert.assertEquals(4, entities.size());\n    final DataSource dataSource = this.em().unwrap(DataSource.class);\n    new QueryRunner(dataSource).query(\"SELECT * FROM Foo\", new NullResultSetHandler());\n    new QueryRunner(dataSource).query(\"SELECT * FROM FooExtra\", new NullResultSetHandler());\n    new QueryRunner(dataSource).query(\"SELECT * FROM Person\", new NullResultSetHandler());\n    new QueryRunner(dataSource).query(\"SELECT * FROM PersonExtra\", new NullResultSetHandler());\n    new QueryRunner(dataSource).query(\"SELECT * FROM Address\", new NullResultSetHandler());\n    new QueryRunner(dataSource).query(\"SELECT * FROM AddressExtra\", new NullResultSetHandler());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManagerFactory#createEntityManager()}\n *\n * @throws SQLException\n *             thrown if underlying SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2427, "method_signature": "void testCreateTable()"}, "SecondaryTableTest.testFind": {"callee_method_names": ["Foo.setValue1", "Foo.setValue2", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getValue1", "Foo.getValue1", "Foo.getValue2", "Foo.getValue2"], "method_name": "SecondaryTableTest.testFind", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.setValue1(\"Value1\");\n    foo.setValue2(\"Value2\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue1(), foo2.getValue1());\n    Assert.assertEquals(foo.getValue2(), foo2.getValue2());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2428, "method_signature": "void testFind()"}, "SecondaryTableTest.testFind2": {"callee_method_names": ["Foo2.setValue1", "Foo2.setValue2", "Foo2.getKey", "Foo2.getKey", "Foo2.getKey", "Foo2.getValue1", "Foo2.getValue1", "Foo2.getValue2", "Foo2.getValue2"], "method_name": "SecondaryTableTest.testFind2", "method_implementation": "{\n    final Foo2 foo = new Foo2();\n    foo.setValue1(\"Value1\");\n    foo.setValue2(\"Value2\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo2 foo2 = this.find(Foo2.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue1(), foo2.getValue1());\n    Assert.assertEquals(foo.getValue2(), foo2.getValue2());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} with {@link SecondaryTables}\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2429, "method_signature": "void testFind2()"}, "SecondaryTableTest.testFindOneToManyToOne": {"callee_method_ids": [2454, 2454, 2454], "callee_method_names": ["Person.getId", "Person.getId", "Person.getId", "Person.getAddresses", "Person.getAddresses"], "method_name": "SecondaryTableTest.testFindOneToManyToOne", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    final Person person2 = this.find(Person.class, person.getId());\n    Assert.assertEquals(person.getId(), person2.getId());\n    Assert.assertEquals(person.getAddresses().size(), person2.getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)} with one-many-one.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2430, "method_signature": "void testFindOneToManyToOne()"}, "SecondaryTableTest.testPersist": {"callee_method_names": [], "method_name": "SecondaryTableTest.testPersist", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM FooExtra\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if underlying SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2431, "method_signature": "void testPersist()"}, "SecondaryTableTest.testPersistOneToManyToOne": {"callee_method_names": [], "method_name": "SecondaryTableTest.testPersistOneToManyToOne", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Person\", new SingleValueHandler<Number>()).intValue());\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM PersonExtra\", new SingleValueHandler<Number>()).intValue());\n    Assert.assertEquals(3, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Address\", new SingleValueHandler<Number>()).intValue());\n    Assert.assertEquals(3, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM AddressExtra\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} with one-many-one.\n *\n * @throws SQLException\n *             thrown if underlying SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2432, "method_signature": "void testPersistOneToManyToOne()"}, "SecondaryTableTest.testRemove": {"callee_method_names": ["Foo.getKey"], "method_name": "SecondaryTableTest.testRemove", "method_implementation": "{\n    Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo = this.find(Foo.class, foo.getKey());\n    this.remove(foo);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to update\n *\n * @throws SQLException\n *             thrown if underlying SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2433, "method_signature": "void testRemove()"}, "SecondaryTableTest.testUpdate": {"callee_method_names": ["Foo.getKey", "Foo.setValue1"], "method_name": "SecondaryTableTest.testUpdate", "method_implementation": "{\n    Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    this.begin();\n    foo = this.find(Foo.class, foo.getKey());\n    foo.setValue1(\"111\");\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests to update\n *\n * @throws SQLException\n *             thrown if underlying SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2434, "method_signature": "void testUpdate()"}, "SequenceGeneratorElement.generate": {"callee_method_names": [], "method_name": "SequenceGeneratorElement.generate", "method_implementation": "{\n    super.generate();\n    this.sequenceName = this.getAttribute(ElementConstants.ATTR_SEQUENCE_NAME, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1096, "method_signature": "void generate()"}, "SerializationTest.testSerialization": {"callee_method_names": ["CompositeEntity.getId", "ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ObjectInputStream.readObject", "ObjectInputStream.close", "CompositeEntity.getId", "CompositeEntity.getId", "CompositeEntity.getTimeStamp", "CompositeEntity.getTimeStamp", "CompositeEntity.getNextComposite", "CompositeEntity.getNextComposite", "CompositeEntity.getNextComposite", "CompositeEntity.getNextComposite", "CompositeEntity.getContreteEntity"], "method_name": "SerializationTest.testSerialization", "method_implementation": "{\n    final CompositeEntity data = data();\n    this.persist(data);\n    this.commit();\n    this.close();\n    final CompositeEntity entity = this.find(CompositeEntity.class, data.getId());\n    //\n    final PipedOutputStream pos = new PipedOutputStream();\n    final PipedInputStream pis = new PipedInputStream(pos);\n    final ObjectOutputStream oos = new ObjectOutputStream(pos);\n    final ObjectInputStream ois = new ObjectInputStream(pis);\n    oos.writeObject(entity);\n    oos.close();\n    final CompositeEntity transportedEntity = (CompositeEntity) ois.readObject();\n    ois.close();\n    Assert.assertEquals(entity.getId(), transportedEntity.getId());\n    Assert.assertEquals(entity.getTimeStamp(), transportedEntity.getTimeStamp());\n    Assert.assertEquals(entity.getNextComposite(), transportedEntity.getNextComposite());\n    Assert.assertEquals(entity.getNextComposite(), transportedEntity.getNextComposite());\n    Assert.assertNull(transportedEntity.getContreteEntity());\n}", "repo_id": "1", "comment": "/**\n * Test for entity serialization\n *\n * @throws IOException\n * @throws ClassNotFoundException\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2502, "method_signature": "void testSerialization()"}, "SessionImpl.cascadeRemovals": {"callee_method_names": ["EnhancedInstance.getStatus", "EnhancedInstance.cascadeRemove"], "method_name": "SessionImpl.cascadeRemovals", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Cascading removals on session {0}\", this);\n    for (final ManagedInstance<?> instance : instances) {\n        if (instance.getStatus() == Status.REMOVED) {\n            instance.cascadeRemove(this.em, null, null);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Cascades the removals.\n *\n * @param instances\n *            array of changed instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 478, "method_signature": "void cascadeRemovals(ManagedInstance<?>[])"}, "SessionImpl.checkTransient": {"callee_method_names": ["ManagedInstance<?>.getStatus", "ManagedInstance<?>.getSession", "ManagedInstance<?>.getStatus"], "method_name": "SessionImpl.checkTransient", "method_implementation": "{\n    if (instance instanceof EnhancedInstance) {\n        final ManagedInstance<?> associate = ((EnhancedInstance) instance).__enhanced__$$__getManagedInstance();\n        if ((associate.getStatus() != Status.MANAGED) && (associate.getSession() == this)) {\n            throw new PersistenceException(\"Instance \" + instance + \" is not managed\");\n        }\n    } else {\n        final ManagedInstance<?> associate = this.get(instance);\n        if ((associate == null) || (associate.getStatus() != Status.MANAGED)) {\n            throw new PersistenceException(\"Instance \" + instance + \" is not managed\");\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Checks if the instance is managed in this session\n *\n * @param instance\n *            the instance to check\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 479, "method_signature": "void checkTransient(Object)"}, "SessionImpl.clear": {"callee_method_names": ["Object.setStatus"], "method_name": "SessionImpl.clear", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Session clearing {0}\", this);\n    for (final ManagedInstance<?> instance : this.repository.values()) {\n        instance.setStatus(Status.DETACHED);\n    }\n    this.repository.clear();\n    this.externalEntities.clear();\n    this.changedEntities.clear();\n}", "repo_id": "1", "comment": "/**\n * Clears the session.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 480, "method_signature": "void clear()"}, "SessionImpl.doRemoves": {"callee_method_names": ["ManagedInstance<?>[].getType", "ManagedInstance<?>[].getType", "EntityTypeImpl<?>.canBatchRemoves", "EntityTypeImpl<?>.getName", "EntityTypeImpl<?>.performRemove"], "method_name": "SessionImpl.doRemoves", "method_implementation": "{\n    final ManagedInstance<?>[] batch = new ManagedInstance[this.removeBatchSize];\n    int i = 0;\n    while (i < removes.length) {\n        int batchSize = 0;\n        EntityTypeImpl<?> lastEntity = null;\n        int removeBatchSize = this.removeBatchSize;\n        // group upto INSERT_BATCH_SIZE and same type entities into a single batch\n        while (//\n        (i < removes.length) && //\n        (batchSize < removeBatchSize) && ((lastEntity == null) || (lastEntity == removes[i].getType()))) {\n            lastEntity = removes[i].getType();\n            if (!lastEntity.canBatchRemoves()) {\n                removeBatchSize = 1;\n            }\n            batch[batchSize] = removes[i];\n            batchSize++;\n            i++;\n        }\n        SessionImpl.LOG.debug(\"Batch remove is being performed for {0} with the size {1}\", lastEntity.getName(), batchSize);\n        lastEntity.performRemove(connection, batch, batchSize);\n        batchSize = 0;\n        lastEntity = null;\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs the remove operations. Batches together the removes on the same tables.\n *\n * @param connection\n *            the connection\n * @param removes\n *            the array of removes\n * @throws SQLException\n *             thrown in case of an underlying SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 481, "method_signature": "void doRemoves(Connection, ManagedInstance<?>[])"}, "SessionImpl.doUpdates": {"callee_method_names": ["ManagedInstance<?>[].getStatus", "ManagedInstance<?>[].getType", "ManagedInstance<?>[].getType", "ManagedInstance<?>[].getType", "EntityTypeImpl<?>.getName", "EntityTypeImpl<?>.performInsert", "ManagedInstance<?>.getStatus", "ManagedInstance<?>.getType", "ManagedInstance<?>.getType"], "method_name": "SessionImpl.doUpdates", "method_implementation": "{\n    final ManagedInstance<?>[] managedInstances = new ManagedInstance[this.insertBatchSize];\n    int i = 0;\n    while (i < updates.length) {\n        EntityTypeImpl<?> lastEntity = null;\n        int batchSize = 0;\n        // group upto MAX_INSERTS and same type entities that are new into a single batch\n        while (//\n        (i < updates.length) && //\n        (batchSize < this.insertBatchSize) && //\n        (updates[i].getStatus() == Status.NEW) && ((lastEntity == null) || (lastEntity == updates[i].getType()))) {\n            // batch inserts only possible for non identity-type entities.\n            if (lastEntity == null) {\n                if (!updates[i].getType().isSuitableForBatchInsert()) {\n                    break;\n                }\n                lastEntity = updates[i].getType();\n            }\n            managedInstances[batchSize] = updates[i];\n            batchSize++;\n            i++;\n            continue;\n        }\n        if (batchSize > 0) {\n            SessionImpl.LOG.debug(\"Batch insert is being performed for {0} with the size {1}\", lastEntity.getName(), batchSize);\n            lastEntity.performInsert(connection, managedInstances, batchSize);\n        } else {\n            final ManagedInstance<?> instance = updates[i];\n            if (instance.getStatus() == Status.NEW) {\n                managedInstances[0] = instance;\n                instance.getType().performInsert(connection, managedInstances, 1);\n            } else {\n                instance.getType().performUpdate(connection, instance);\n            }\n            i++;\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Performs the insert / update operations. Batches together the inserts on the same tables.\n *\n * @param connection\n *            the connection\n * @param updates\n *            the array of updates\n * @throws SQLException\n *             thrown in case of an underlying SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 482, "method_signature": "void doUpdates(Connection, ManagedInstance<?>[])"}, "SessionImpl.doVersionUpgrades": {"callee_method_names": ["ManagedInstance<?>.incrementVersion"], "method_name": "SessionImpl.doVersionUpgrades", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Performing version upgrades on session {0}\", this);\n    for (final ManagedInstance<?> instance : updates) {\n        instance.incrementVersion(connection, false);\n    }\n}", "repo_id": "1", "comment": "/**\n * Increments the versions.\n *\n * @param connection\n *            the connection\n * @param updates\n *            the updates\n * @throws SQLException\n *             thrown in case of an SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 483, "method_signature": "void doVersionUpgrades(Connection, ManagedInstance<?>[])"}, "SessionImpl.firePostCallbacks": {"callee_method_names": ["CallbackAvailability.postRemove", "ManagedInstance<?>.fireCallbacks", "CallbackAvailability.postWrite", "ManagedInstance<?>.fireCallbacks"], "method_name": "SessionImpl.firePostCallbacks", "method_implementation": "{\n    if (callbackAvailability.postRemove()) {\n        for (final ManagedInstance<?> instance : removals) {\n            instance.fireCallbacks(EntityListenerType.POST_REMOVE);\n        }\n    }\n    if (callbackAvailability.postWrite()) {\n        for (final ManagedInstance<?> instance : updates) {\n            instance.fireCallbacks(EntityListenerType.POST_UPDATE);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Fires the post callbacks.\n *\n * @param updates\n *            the list of updates\n * @param removals\n *            the list of removals\n * @param callbackAvailability\n *            the callback availability\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 484, "method_signature": "void firePostCallbacks(ManagedInstance<?>[], ManagedInstance<?>[], CallbackAvailability)"}, "SessionImpl.firePreCallbacks": {"callee_method_names": ["CallbackAvailability.preRemove", "ManagedInstance<?>.fireCallbacks", "CallbackAvailability.preWrite", "ManagedInstance<?>.fireCallbacks"], "method_name": "SessionImpl.firePreCallbacks", "method_implementation": "{\n    if (callbackAvailability.preRemove()) {\n        for (final ManagedInstance<?> instance : sortedRemovals) {\n            instance.fireCallbacks(EntityListenerType.PRE_REMOVE);\n        }\n    }\n    if (callbackAvailability.preWrite()) {\n        for (final ManagedInstance<?> instance : sortedUpdates) {\n            instance.fireCallbacks(EntityListenerType.PRE_UPDATE);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Fires the pre callbacks.\n *\n * @param sortedUpdates\n *            the list of updates\n * @param sortedRemovals\n *            the list of removals\n * @param callbackAvailability\n *            the callback availability\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 485, "method_signature": "void firePreCallbacks(ManagedInstance<?>[], ManagedInstance<?>[], CallbackAvailability)"}, "SessionImpl.flush": {"callee_method_names": ["ManagedInstance<?>.getStatus", "ManagedInstance<?>.getStatus", "ArrayList<ManagedInstance<?>>.add", "ManagedInstance<?>.hasSelfUpdate", "ArrayList<ManagedInstance<?>>.add", "ArrayList<ManagedInstance<?>>.size", "ArrayList<ManagedInstance<?>>.size", "ArrayList<ManagedInstance<?>>.size", "ArrayList<ManagedInstance<?>>.size", "EntityManagerFactoryImpl.hasValidators", "Set<ConstraintViolation<?>>.addAll", "ManagedInstance<?>.getType", "Set<ConstraintViolation<?>>.addAll", "ManagedInstance<?>.getType", "Set<ConstraintViolation<?>>.size", "ManagedInstance<?>.flushAssociations", "ManagedInstance<?>.flushAssociations", "ManagedInstance<?>.checkTransients", "ManagedInstance<?>.flushAssociations", "ManagedInstance<?>.sortLists", "ManagedInstance<?>.reset", "ManagedInstance<?>.hasInitialId", "ManagedInstance<?>.getId"], "method_name": "SessionImpl.flush", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Flushing session {0}\", this);\n    final ArrayList<ManagedInstance<?>> updates = Lists.newArrayList(this.newEntities);\n    final ArrayList<ManagedInstance<?>> removals = Lists.newArrayListWithCapacity(this.changedEntities.size());\n    for (final ManagedInstance<?> instance : this.changedEntities) {\n        if (instance.getStatus() == Status.NEW) {\n            // should be already in the list the instance is a new instance\n            continue;\n        } else if (instance.getStatus() == Status.REMOVED) {\n            removals.add(instance);\n        } else if (instance.hasSelfUpdate()) {\n            updates.add(instance);\n        }\n    }\n    if ((updates.size() == 0) && (removals.size() == 0)) {\n        return;\n    }\n    final ManagedInstance<?>[] sortedUpdates = new ManagedInstance[updates.size()];\n    final ManagedInstance<?>[] sortedRemovals = new ManagedInstance[removals.size()];\n    final CallbackAvailability callbackAvailability = new CallbackAvailability();\n    Prioritizer.sort(updates, removals, sortedUpdates, sortedRemovals, callbackAvailability);\n    SessionImpl.LOG.debug(\"Flushing session {0}: updates {1}, removals {2}\", this, sortedUpdates.length, sortedRemovals.length);\n    // validations\n    final EntityManagerFactoryImpl entityManagerFactory = this.em.getEntityManagerFactory();\n    if (entityManagerFactory.hasValidators()) {\n        final Set<ConstraintViolation<?>> violations = Sets.newHashSet();\n        for (final ManagedInstance<?> instance : sortedUpdates) {\n            violations.addAll(instance.getType().runValidators(entityManagerFactory, instance));\n        }\n        for (final ManagedInstance<?> instance : sortedRemovals) {\n            violations.addAll(instance.getType().runValidators(entityManagerFactory, instance));\n        }\n        if (violations.size() > 0) {\n            throw new ConstraintViolationException(\"Cannot flush due to validation errors.\", violations);\n        }\n    }\n    // fire callbacks\n    this.firePreCallbacks(sortedUpdates, sortedRemovals, callbackAvailability);\n    this.doVersionUpgrades(connection, sortedUpdates);\n    for (final ManagedInstance<?> instance : sortedRemovals) {\n        instance.flushAssociations(connection, true, false);\n    }\n    for (final ManagedInstance<?> instance : sortedUpdates) {\n        instance.flushAssociations(connection, true, false);\n    }\n    this.doUpdates(connection, sortedUpdates);\n    this.doRemoves(connection, sortedRemovals);\n    for (final ManagedInstance<?> instance : sortedUpdates) {\n        instance.checkTransients();\n    }\n    for (final ManagedInstance<?> instance : sortedUpdates) {\n        instance.flushAssociations(connection, false, this.newEntities.contains(instance));\n        instance.sortLists();\n        instance.reset();\n    }\n    // fire callbacks\n    this.firePostCallbacks(sortedUpdates, sortedRemovals, callbackAvailability);\n    SessionImpl.LOG.debug(\"Flush successful for session {0}\", this);\n    // move new entities to external entities\n    this.externalEntities.addAll(this.newEntities);\n    for (int i = 0; i < this.newEntities.size(); i++) {\n        final ManagedInstance<?> instance = this.newEntities.get(i);\n        if (!instance.hasInitialId()) {\n            this.repository.put(instance.getId(), instance);\n        }\n    }\n    this.changedEntities.clear();\n    this.newEntities.clear();\n}", "repo_id": "1", "comment": "/**\n * Flushes the session persisting changes to the database.\n *\n * @param connection\n *            the connection to use\n * @throws SQLException\n *             thrown in case of an SQL error\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 486, "method_signature": "void flush(Connection)"}, "SessionImpl.get": {"callee_method_names": ["ManagedInstance<?>.getSession", "X.getClass", "X.getClass", "X.getClass", "EntityTypeImpl<X>.getId"], "method_name": "SessionImpl.get", "method_implementation": "{\n    Class<? extends Object> clazz = null;\n    if (entity instanceof EnhancedInstance) {\n        final ManagedInstance<?> instance = ((EnhancedInstance) entity).__enhanced__$$__getManagedInstance();\n        if ((instance != null) && (instance.getSession() == this)) {\n            return (ManagedInstance<X>) instance;\n        }\n        clazz = entity.getClass().getSuperclass();\n    }\n    if (clazz == null) {\n        clazz = entity.getClass();\n    }\n    final EntityTypeImpl<X> type = (EntityTypeImpl<X>) this.metamodel.entity(clazz);\n    if (type == null) {\n        throw new PersistenceException(entity.getClass().getName() + \" is not a persistence class\");\n    }\n    final ManagedId<X> id = type.getId(entity);\n    return (ManagedInstance<X>) this.repository.get(id);\n}", "repo_id": "1", "comment": "/**\n * Returns the managed instance instance in the session\n *\n * @param entity\n *            the entity\n * @param <X>\n *            the type of the instance\n * @return the managed instance or null\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 487, "method_signature": "ManagedInstance<X> get(X)"}, "SessionImpl.handleAdditions": {"callee_method_names": ["ManagedInstance<?>.handleAdditions"], "method_name": "SessionImpl.handleAdditions", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Processing additions to the session {0}\", this);\n    final ManagedInstance<?>[] instances = this.changedEntities.toArray(new ManagedInstance[this.changedEntities.size()]);\n    for (final ManagedInstance<?> instance : instances) {\n        instance.handleAdditions(this.em);\n    }\n    return instances;\n}", "repo_id": "1", "comment": "/**\n * Handles the additions to the collections.\n *\n * @return the array of changed instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 488, "method_signature": "ManagedInstance<?>[] handleAdditions()"}, "SessionImpl.handleExternals": {"callee_method_names": [], "method_name": "SessionImpl.handleExternals", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Inspecting updated external entities on session {0}\", this);\n    for (int i = 0; i < this.externalEntities.size(); i++) {\n        this.externalEntities.get(i).checkUpdated();\n    }\n}", "repo_id": "1", "comment": "/**\n * Handles the external entities that are updated\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 489, "method_signature": "void handleExternals()"}, "SessionImpl.handleOrphans": {"callee_method_names": ["ManagedInstance<?>.getStatus", "ManagedInstance<?>.handleOrphans"], "method_name": "SessionImpl.handleOrphans", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Inspecting orphan on session {0}\", this);\n    for (final ManagedInstance<?> instance : instances) {\n        if (instance.getStatus() != Status.REMOVED) {\n            instance.handleOrphans(this.em);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Removes entities that have been orphaned\n *\n * @param instances\n *            the array of changed instances\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 490, "method_signature": "void handleOrphans(ManagedInstance<?>[])"}, "SessionImpl.lazyInstanceLoading": {"callee_method_names": [], "method_name": "SessionImpl.lazyInstanceLoading", "method_implementation": "{\n    SessionImpl.LOG.debug(\"Lazy instance is being loaded {0}\", instance);\n    this.entitiesLoading.add(instance);\n}", "repo_id": "1", "comment": "/**\n * Notifies the session that the lazy instance is loading\n *\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 491, "method_signature": "void lazyInstanceLoading(ManagedInstance)"}, "SessionImpl.put": {"callee_method_names": ["ManagedInstance<X>.getId", "ManagedInstance<X>.isLoading"], "method_name": "SessionImpl.put", "method_implementation": "{\n    this.repository.put(instance.getId(), instance);\n    if ((this.loadTracker > 0) && instance.isLoading()) {\n        this.entitiesLoading.add(instance);\n    }\n}", "repo_id": "1", "comment": "/**\n * Puts the instance into the session.\n *\n * @param <X>\n *            the type of the instance\n * @param instance\n *            the instance to put into the session\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 492, "method_signature": "void put(ManagedInstance)"}, "SessionImpl.putExternal": {"callee_method_names": ["ManagedInstance<X>.hasInitialId", "ManagedInstance<X>.getId"], "method_name": "SessionImpl.putExternal", "method_implementation": "{\n    if (instance.hasInitialId()) {\n        this.repository.put(instance.getId(), instance);\n    }\n    this.newEntities.add(instance);\n}", "repo_id": "1", "comment": "/**\n * Puts the new instance into the session.\n * <p>\n * Additionally stores object in a safe repository that it knows the changes are not traced by enhancement.\n *\n * @param <X>\n *            the type of the instance\n * @param instance\n *            the instance to put into the session\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 493, "method_signature": "void putExternal(ManagedInstance)"}, "SessionImpl.releaseLoadTracker": {"callee_method_names": ["ManagedInstance<X>.setLoading", "ManagedInstance<X>.processJoinedMappings", "ManagedInstance<X>.sortLists", "ManagedInstance<X>.setLoadingFromCache", "ManagedInstance<X>.fireCallbacks"], "method_name": "SessionImpl.releaseLoadTracker", "method_implementation": "{\n    this.loadTracker--;\n    if (this.loadTracker == 0) {\n        SessionImpl.LOG.debug(\"Load tracker is released on session {0}\", this);\n        // swap the set\n        final ManagedInstance<?>[] entitiesLoaded = this.entitiesLoading.toArray(new ManagedInstance[this.entitiesLoading.size()]);\n        this.entitiesLoading = Lists.newArrayList();\n        for (final ManagedInstance<?> instance : entitiesLoaded) {\n            // check if the transaction is marked as rollback\n            if (this.em.hasTransactionMarkedForRollback()) {\n                return;\n            }\n            // mark as loaded\n            instance.setLoading(false);\n            // process the associations\n            instance.processJoinedMappings();\n            instance.sortLists();\n            // mark as loaded\n            instance.setLoadingFromCache(false);\n        }\n        for (final ManagedInstance<?> instance : entitiesLoaded) {\n            instance.fireCallbacks(EntityListenerType.POST_LOAD);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * Releases the load tracker, so that the entities loaded are processed for associations and <code>PostLoad</code> listeners are\n * invoked.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 494, "method_signature": "void releaseLoadTracker()"}, "SessionImpl.remove": {"callee_method_names": ["Object.getClass", "Object.getClass", "EntityTypeImpl<?>.getId"], "method_name": "SessionImpl.remove", "method_implementation": "{\n    Class<? extends Object> clazz = (entity instanceof EnhancedInstance) ? clazz = entity.getClass().getSuperclass() : entity.getClass();\n    final EntityTypeImpl<?> type = this.metamodel.entity(clazz);\n    final ManagedId<?> instanceId = type.getId(entity);\n    final ManagedInstance<?> instance = this.repository.get(instanceId);\n    if (instance != null) {\n        this.repository.remove(instanceId);\n        this.changedEntities.remove(instance);\n        this.externalEntities.remove(instance);\n        this.newEntities.remove(instance);\n    }\n    return instance;\n}", "repo_id": "1", "comment": "/**\n * Removes the instance from the session.\n *\n * @param entity\n *            the entity to remove\n * @return returns the entity\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 495, "method_signature": "ManagedInstance<?> remove(Object)"}, "SessionImpl.setChanged": {"callee_method_names": ["ManagedInstance<?>.getStatus"], "method_name": "SessionImpl.setChanged", "method_implementation": "{\n    this.changedEntities.add(instance);\n    if (instance.getStatus() == Status.REMOVED) {\n        this.externalEntities.remove(instance);\n    }\n}", "repo_id": "1", "comment": "/**\n * Marks the instance as changed.\n *\n * @param instance\n *            the instance\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 496, "method_signature": "void setChanged(ManagedInstance)"}, "SessionImpl.setLoadTracker": {"callee_method_names": [], "method_name": "SessionImpl.setLoadTracker", "method_implementation": "{\n    this.loadTracker++;\n    if (this.loadTracker == 1) {\n        SessionImpl.LOG.debug(\"Load tracker is triggered on session {0}\", this);\n    }\n}", "repo_id": "1", "comment": "/**\n * Sets the load tracker so that the insertions into session is tracked.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 497, "method_signature": "void setLoadTracker()"}, "SetAttributeImpl.newCollection": {"callee_method_names": [], "method_name": "SetAttributeImpl.newCollection", "method_implementation": "{\n    return new ManagedSet<X, E>(mapping, managedInstance, (Collection<? extends E>) values);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 277, "method_signature": "Set<E> newCollection(PluralMappingEx, ManagedInstance, Object)"}, "SetJoinImpl.getModel": {"callee_method_names": [], "method_name": "SetJoinImpl.getModel", "method_implementation": "{\n    return (SetAttribute<? super Z, E>) this.getAttribute();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 805, "method_signature": "SetAttribute<? super Z,E> getModel()"}, "SimpleCaseImpl.generateJpqlRestriction": {"callee_method_names": ["AbstractExpression<C>.generateJpqlRestriction", "AbstractExpression<? extends R>.generateJpqlRestriction"], "method_name": "SimpleCaseImpl.generateJpqlRestriction", "method_implementation": "{\n    final String whens = Joiner.on(\"\\n\\t\").join(//\n    Lists.//\n    transform(//\n    this.conditions, new Function<Pair<Expression<C>, Expression<? extends R>>, String>() {\n\n        @Override\n        public String apply(Pair<Expression<C>, Expression<? extends R>> input) {\n            final AbstractExpression<C> when = (AbstractExpression<C>) input.getFirst();\n            final AbstractExpression<? extends R> then = (AbstractExpression<? extends R>) input.getSecond();\n            return \"when \" + when.generateJpqlRestriction(query) + \" then \" + then.generateJpqlRestriction(query);\n        }\n    }));\n    final String otherwise = \"\\n\\telse \" + ((AbstractExpression<? extends R>) this.otherwise).generateJpqlRestriction(query);\n    return \"case \" + ((AbstractExpression<? extends C>) this.inner).generateJpqlRestriction(query) + \"\\n\\t\" + whens + otherwise + \"\\nend\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 565, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "SimpleCaseImpl.generateJpqlSelect": {"callee_method_names": [], "method_name": "SimpleCaseImpl.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 566, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "SimpleCaseImpl.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "SimpleCaseImpl.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 567, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "SimpleCaseImpl.getExpression": {"callee_method_names": [], "method_name": "SimpleCaseImpl.getExpression", "method_implementation": "{\n    return (Expression<C>) this.inner;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 568, "method_signature": "Expression<C> getExpression()"}, "SimpleCaseImpl.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "SimpleCaseImpl.getSqlRestrictionFragments", "method_implementation": "{\n    final String innerFragment = ((AbstractExpression<? extends C>) this.inner).getSqlRestrictionFragments(query)[0];\n    final String whens = Joiner.on(\"\\n\\t\").join(//\n    Lists.//\n    transform(//\n    this.conditions, new Function<Pair<Expression<C>, Expression<? extends R>>, String>() {\n\n        @Override\n        public String apply(Pair<Expression<C>, Expression<? extends R>> input) {\n            final String conditionFragment = ((AbstractExpression<C>) input.getFirst()).getSqlRestrictionFragments(query)[0];\n            final String resultFragment = ((AbstractExpression<? extends R>) input.getSecond()).getSqlRestrictionFragments(query)[0];\n            return \"WHEN \" + innerFragment + \" = \" + conditionFragment + \" THEN \" + resultFragment;\n        }\n    }));\n    final String otherwise = \"\\n\\tELSE \" + ((AbstractExpression<? extends R>) this.otherwise).getSqlRestrictionFragments(query)[0];\n    return new String[] { \"CASE\\n\\t\" + whens + otherwise + \"\\nEND\" };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 569, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "SimpleCaseImpl.handle": {"callee_method_names": ["ResultSet.getObject"], "method_name": "SimpleCaseImpl.handle", "method_implementation": "{\n    return (R) row.getObject(this.alias);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 570, "method_signature": "R handle(QueryImpl, SessionImpl, ResultSet)"}, "SimpleCaseImpl.otherwise": {"callee_method_names": [], "method_name": "SimpleCaseImpl.otherwise", "method_implementation": "{\n    this.otherwise(new EntityConstantExpression<R>(null, result));\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 572, "method_signature": "Expression<R> otherwise(R)"}, "SimpleCaseImpl.when": {"callee_method_names": [], "method_name": "SimpleCaseImpl.when", "method_implementation": "{\n    this.conditions.add(new Pair<Expression<C>, Expression<? extends R>>(new EntityConstantExpression<C>(null, condition), result));\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 574, "method_signature": "SimpleCase<C,R> when(C, Expression)"}, "SimpleCity.compareTo": {"callee_method_names": [], "method_name": "SimpleCity.compareTo", "method_implementation": "{\n    if (this.country.compareTo(o.country) != 0) {\n        return this.country.compareTo(o.country);\n    }\n    if (this.city.compareTo(o.city) != 0) {\n        return this.city.compareTo(o.city);\n    }\n    return 0;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2320, "method_signature": "int compareTo(SimpleCity)"}, "SimpleCity.equals": {"callee_method_names": ["Object.getClass"], "method_name": "SimpleCity.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (this.getClass() != obj.getClass()) {\n        return false;\n    }\n    final SimpleCity other = (SimpleCity) obj;\n    if (this.city == null) {\n        if (other.city != null) {\n            return false;\n        }\n    } else if (!this.city.equals(other.city)) {\n        return false;\n    }\n    if (this.country == null) {\n        if (other.country != null) {\n            return false;\n        }\n    } else if (!this.country.equals(other.country)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2321, "method_signature": "boolean equals(Object)"}, "SimpleCity.hashCode": {"callee_method_names": [], "method_name": "SimpleCity.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.city == null) ? 0 : this.city.hashCode());\n    result = (prime * result) + ((this.country == null) ? 0 : this.country.hashCode());\n    return result;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2322, "method_signature": "int hashCode()"}, "SimpleConstantExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "SimpleConstantExpression.generateJpqlRestriction", "method_implementation": "{\n    if (Number.class.isAssignableFrom(this.getJavaType())) {\n        return this.value.toString();\n    } else {\n        return \"'\" + this.value.toString() + \"'\";\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 658, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "SimpleConstantExpression.getSqlRestrictionFragments": {"callee_method_names": [], "method_name": "SimpleConstantExpression.getSqlRestrictionFragments", "method_implementation": "{\n    if (Number.class.isAssignableFrom(this.getJavaType())) {\n        return new String[] { this.value.toString() };\n    } else if (Boolean.class == this.getJavaType()) {\n        return new String[] { this.value.toString() };\n    } else {\n        return new String[] { \"'\" + this.value.toString() + \"'\" };\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 659, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "SimpleCriteriaTest.prepareCountries": {"callee_method_names": [], "method_name": "SimpleCriteriaTest.prepareCountries", "method_implementation": "{\n    this.begin();\n    this.persist(SimpleCriteriaTest.TR);\n    this.persist(SimpleCriteriaTest.USA);\n    this.persist(SimpleCriteriaTest.UK);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2365, "method_signature": "void prepareCountries()"}, "SimpleCriteriaTest.testArithmeticExpression1": {"callee_method_names": ["CriteriaBuilderImpl.createTupleQuery", "CriteriaQueryImpl<Tuple>.from", "RootImpl<Person>.get", "RootImpl<Person>.get", "RootImpl<Person>.get", "CriteriaQueryImpl<Tuple>.multiselect", "QueryImpl<Tuple>.getSingleResult", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get", "Tuple.get"], "method_name": "SimpleCriteriaTest.testArithmeticExpression1", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Tuple> cq = cb.createTupleQuery();\n    final RootImpl<Person> r = cq.from(Person.class);\n    final AbstractPath<Integer> age = (AbstractPath<Integer>) r.<Integer>get(\"age\").alias(\"age\");\n    final AbstractPath<String> name = (AbstractPath<String>) r.<String>get(\"name\").alias(\"name\");\n    final AbstractPath<Date> date = (AbstractPath<Date>) r.<Date>get(\"startDate\").alias(\"date\");\n    cq.multiselect(name, age, date);\n    final QueryImpl<Tuple> q = this.em().createQuery(cq);\n    final Tuple tuple = q.getSingleResult();\n    Assert.assertEquals(tuple.get(0), tuple.get(\"name\"));\n    Assert.assertEquals(tuple.get(1), tuple.get(\"age\"));\n    Assert.assertEquals(tuple.get(2), tuple.get(\"date\"));\n    Assert.assertEquals(tuple.get(0), tuple.get(name));\n    Assert.assertEquals(tuple.get(1), tuple.get(age));\n    Assert.assertEquals(tuple.get(2), tuple.get(date));\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2366, "method_signature": "void testArithmeticExpression1()"}, "SimpleCriteriaTest.testArithmeticExpression2": {"callee_method_ids": [514], "callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Person>.from", "RootImpl<Person>.get", "CriteriaBuilderImpl.parameter", "CriteriaQueryImpl<Person>.where", "CriteriaBuilderImpl.greaterThan", "QueryImpl<Person>.setParameter", "QueryImpl<Person>.getResultList"], "method_name": "SimpleCriteriaTest.testArithmeticExpression2", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Person> cq = cb.createQuery(Person.class);\n    final RootImpl<Person> r = cq.from(Person.class);\n    final AbstractPath<Integer> age = r.<Integer>get(\"age\");\n    final ParameterExpressionImpl<Integer> p = cb.parameter(Integer.class);\n    cq.where(cb.greaterThan(age, p));\n    final QueryImpl<Person> q = this.em().createQuery(cq);\n    q.setParameter(p, 40);\n    Assert.assertEquals(0, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2335, "method_signature": "void testArithmeticExpression2()"}, "SimpleCriteriaTest.testAssociation": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Address>.from", "CriteriaQueryImpl<Address>.select", "RootImpl<Person>.join", "List<Address>.size"], "method_name": "SimpleCriteriaTest.testAssociation", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Address> q = cb.createQuery(Address.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    q.select(r.<Address>join(\"addresses\"));\n    final List<Address> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(6, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2336, "method_signature": "void testAssociation()"}, "SimpleCriteriaTest.testAssociationJoin": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Address>.from", "RootImpl<Person>.join", "Join<Person, Address>.fetch", "Join<Person, Address>.fetch", "CriteriaQueryImpl<Address>.select", "List<Address>.size"], "method_name": "SimpleCriteriaTest.testAssociationJoin", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Address> q = cb.createQuery(Address.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    final Join<Person, Address> a = r.join(\"addresses\");\n    a.fetch(\"person\");\n    a.fetch(\"country\");\n    q.select(a);\n    final List<Address> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(6, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2337, "method_signature": "void testAssociationJoin()"}, "SimpleCriteriaTest.testBooleanExpression": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Address>.from", "RootImpl<Person>.join", "CriteriaQueryImpl<Address>.select", "AbstractJoin<Person, Address>.get", "CriteriaQueryImpl<Address>.where", "List<Address>.size"], "method_name": "SimpleCriteriaTest.testBooleanExpression", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Address> q = cb.createQuery(Address.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    final AbstractJoin<Person, Address> a = r.join(\"addresses\");\n    q.select(a);\n    final AbstractPath<Boolean> p = a.<Boolean>get(\"primary\");\n    q.where(p);\n    final List<Address> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(2, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2338, "method_signature": "void testBooleanExpression()"}, "SimpleCriteriaTest.testConstructor": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<SimpleCity>.from", "RootImpl<Address>.get", "RootImpl<Address>.get", "CriteriaQueryImpl<SimpleCity>.select", "CriteriaBuilderImpl.construct", "List<SimpleCity>.toString"], "method_name": "SimpleCriteriaTest.testConstructor", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<SimpleCity> q = cb.createQuery(SimpleCity.class);\n    final RootImpl<Address> r = q.from(Address.class);\n    final Selection<String> city = r.<String>get(\"city\");\n    final Selection<String> country = r.<String>get(\"country\").get(\"name\");\n    q.select(cb.construct(SimpleCity.class, city, country));\n    final List<SimpleCity> resultList = this.em().createQuery(q).getResultList();\n    Collections.sort(resultList);\n    Assert.assertEquals(\"[SimpleCity [city=Istanbul, country=Turkey], SimpleCity [city=London, country=United Kingdom], SimpleCity [city=New York, country=United States of America]]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2339, "method_signature": "void testConstructor()"}, "SimpleCriteriaTest.testDateExpression": {"callee_method_ids": [513], "callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Person>.from", "CriteriaQueryImpl<Person>.where", "CriteriaBuilderImpl.equal", "RootImpl<Person>.get", "CriteriaQueryImpl<Person>.select", "List<Person>.size"], "method_name": "SimpleCriteriaTest.testDateExpression", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Person> cq = cb.createQuery(Person.class);\n    final RootImpl<Person> r = cq.from(Person.class);\n    cq.where(cb.equal(r.<Date>get(\"startDate\"), getStartDate().getTime()));\n    cq.select(r);\n    final List<Person> resultList = this.em().createQuery(cq).getResultList();\n    Assert.assertEquals(1, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since $version\n */\n", "repo_name": "BatooJPA-master/", "id": 2340, "method_signature": "void testDateExpression()"}, "SimpleCriteriaTest.testRestriction": {"callee_method_ids": [513, 2454], "callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Person>.from", "CriteriaQueryImpl<Person>.select", "RootImpl<Person>.join", "RootImpl<Person>.alias", "RootImpl<Person>.fetch", "RootImpl<Person>.fetch", "RootImpl<Person>.get", "CriteriaBuilderImpl.parameter", "CriteriaQueryImpl<Person>.where", "CriteriaBuilderImpl.equal", "TypedQuery<Person>.setParameter", "Person.getId", "TypedQuery<Person>.getResultList", "List<Person>.size", "List<Person>.get"], "method_name": "SimpleCriteriaTest.testRestriction", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Person> q = cb.createQuery(Person.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    q.select(r);\n    r.join(\"addresses\");\n    r.alias(\"p\");\n    r.fetch(\"addresses\").fetch(\"country\");\n    r.fetch(\"phones\");\n    final AbstractPath<Object> id = r.get(\"id\");\n    final ParameterExpressionImpl<Integer> p = cb.parameter(Integer.class);\n    q.where(cb.equal(id, p));\n    final TypedQuery<Person> tq = this.em().createQuery(q);\n    tq.setParameter(1, person.getId());\n    final List<Person> resultList = tq.getResultList();\n    Assert.assertEquals(18, resultList.size());\n    Assert.assertEquals(3, resultList.get(0).getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2341, "method_signature": "void testRestriction()"}, "SimpleCriteriaTest.testRootCount": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Long>.from", "CriteriaQueryImpl<Long>.select", "CriteriaBuilderImpl.count", "Long.longValue"], "method_name": "SimpleCriteriaTest.testRootCount", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    //\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Long> q = cb.createQuery(Long.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    final Long count = this.em().createQuery(q.select(cb.count(r))).getSingleResult();\n    Assert.assertEquals(2, count.longValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n * @author asimarslan\n */\n", "repo_name": "BatooJPA-master/", "id": 2342, "method_signature": "void testRootCount()"}, "SimpleCriteriaTest.testRootDistinct": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Person>.from", "CriteriaQueryImpl<Person>.select", "RootImpl<Person>.alias", "RootImpl<Person>.fetch", "CriteriaQueryImpl<Person>.distinct", "List<Person>.size", "List<Person>.get"], "method_name": "SimpleCriteriaTest.testRootDistinct", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Person> q = cb.createQuery(Person.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    q.select(r);\n    r.alias(\"p\");\n    r.fetch(\"addresses\").fetch(\"country\");\n    q.distinct(true);\n    final List<Person> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(2, resultList.size());\n    Assert.assertEquals(3, resultList.get(0).getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2343, "method_signature": "void testRootDistinct()"}, "SimpleCriteriaTest.testRootFetch": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Person>.from", "CriteriaQueryImpl<Person>.select", "RootImpl<Person>.alias", "RootImpl<Person>.fetch", "RootImpl<Person>.fetch", "List<Person>.size", "List<Person>.get"], "method_name": "SimpleCriteriaTest.testRootFetch", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Person> q = cb.createQuery(Person.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    q.select(r);\n    r.alias(\"p\");\n    r.fetch(\"addresses\").fetch(\"country\");\n    r.fetch(\"phones\");\n    final List<Person> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(12, resultList.size());\n    Assert.assertEquals(3, resultList.get(0).getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2344, "method_signature": "void testRootFetch()"}, "SimpleCriteriaTest.testRootJoin": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Person>.from", "CriteriaQueryImpl<Person>.select", "RootImpl<Person>.alias", "RootImpl<Person>.fetch", "RootImpl<Person>.join", "List<Person>.size", "List<Person>.get"], "method_name": "SimpleCriteriaTest.testRootJoin", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Person> q = cb.createQuery(Person.class);\n    final RootImpl<Person> r = q.from(Person.class);\n    q.select(r);\n    r.alias(\"p\");\n    r.fetch(\"addresses\").fetch(\"country\");\n    r.join(\"addresses\");\n    final List<Person> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(18, resultList.size());\n    Assert.assertEquals(3, resultList.get(0).getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2345, "method_signature": "void testRootJoin()"}, "SimpleCriteriaTest.testSimple": {"callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Country>.from", "CriteriaQueryImpl<Country>.select", "List<Country>.size"], "method_name": "SimpleCriteriaTest.testSimple", "method_implementation": "{\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Country> q = cb.createQuery(Country.class);\n    final RootImpl<Country> r = q.from(Country.class);\n    q.select(r);\n    final List<Country> resultList = this.em().createQuery(q).getResultList();\n    Assert.assertEquals(3, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2346, "method_signature": "void testSimple()"}, "SimpleCriteriaTest.testSimple2": {"callee_method_ids": [513], "callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Country>.from", "CriteriaQueryImpl<Country>.select", "CriteriaBuilderImpl.parameter", "CriteriaQueryImpl<Country>.where", "CriteriaBuilderImpl.equal", "QueryImpl<Country>.setParameter", "QueryImpl<Country>.getResultList", "List<Country>.size"], "method_name": "SimpleCriteriaTest.testSimple2", "method_implementation": "{\n    final CriteriaBuilderImpl cb = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Country> q = cb.createQuery(Country.class);\n    final RootImpl<Country> r = q.from(Country.class);\n    q.select(r);\n    final ParameterExpressionImpl<Country> p = cb.parameter(Country.class);\n    q.where(cb.equal(r, p));\n    final QueryImpl<Country> tq = this.em().createQuery(q);\n    tq.setParameter(p, SimpleCriteriaTest.TR);\n    final List<Country> resultList = tq.getResultList();\n    Assert.assertEquals(1, resultList.size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2347, "method_signature": "void testSimple2()"}, "SimpleCriteriaTest.testSimple3": {"callee_method_ids": [2454, 513, 506], "callee_method_names": ["Person.getId", "CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Address>.from", "List<PredicateImpl>.add", "CriteriaBuilderImpl.equal", "RootImpl<Address>.get", "CriteriaQueryImpl<Address>.select", "CriteriaQueryImpl<Address>.where", "CriteriaBuilderImpl.and", "List<PredicateImpl>.toArray", "List<PredicateImpl>.size", "TypedQuery<Address>.getResultList"], "method_name": "SimpleCriteriaTest.testSimple3", "method_implementation": "{\n    Person person = this.person();\n    this.persist(person);\n    this.commit();\n    this.close();\n    person = this.find(Person.class, person.getId());\n    final CriteriaBuilderImpl criteriaBuilder = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Address> criteriaQuery = criteriaBuilder.createQuery(Address.class);\n    final RootImpl<Address> from = criteriaQuery.from(Address.class);\n    final List<PredicateImpl> predicates = new ArrayList<PredicateImpl>();\n    predicates.add(criteriaBuilder.equal(from.get(\"person\"), person));\n    criteriaQuery.select(from);\n    criteriaQuery.where(criteriaBuilder.and(predicates.toArray(new Predicate[predicates.size()])));\n    final TypedQuery<Address> query = this.em().createQuery(criteriaQuery);\n    query.getResultList();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2348, "method_signature": "void testSimple3()"}, "SimpleCriteriaTest.testSimple4": {"callee_method_ids": [506], "callee_method_names": ["CriteriaBuilderImpl.createQuery", "CriteriaQueryImpl<Address>.from", "CriteriaQueryImpl<Address>.select", "CriteriaQueryImpl<Address>.where", "CriteriaBuilderImpl.and", "List<PredicateImpl>.toArray", "List<PredicateImpl>.size", "TypedQuery<Address>.getResultList"], "method_name": "SimpleCriteriaTest.testSimple4", "method_implementation": "{\n    final CriteriaBuilderImpl criteriaBuilder = this.em().getCriteriaBuilder();\n    final CriteriaQueryImpl<Address> criteriaQuery = criteriaBuilder.createQuery(Address.class);\n    final RootImpl<Address> from = criteriaQuery.from(Address.class);\n    final List<PredicateImpl> predicates = new ArrayList<PredicateImpl>();\n    criteriaQuery.select(from);\n    criteriaQuery.where(criteriaBuilder.and(predicates.toArray(new Predicate[predicates.size()])));\n    final TypedQuery<Address> query = this.em().createQuery(criteriaQuery);\n    query.getResultList();\n}", "repo_id": "1", "comment": "/**\n * Test the empty predicates.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2349, "method_signature": "void testSimple4()"}, "SimpleInheritanceTest.testSimpleInheritance0": {"callee_method_names": ["Foo.setValue", "Foo.getKey", "Foo.getKey", "Foo.getKey", "Foo.getValue", "Foo.getValue"], "method_name": "SimpleInheritanceTest.testSimpleInheritance0", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.setValue(\"Value\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with root type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2226, "method_signature": "void testSimpleInheritance0()"}, "SimpleInheritanceTest.testSimpleInheritance1": {"callee_method_names": ["FooExt1.setValue", "FooExt1.setValueExt1", "FooExt1.getKey", "FooExt1.getKey", "FooExt1.getKey", "FooExt1.getValue", "FooExt1.getValue", "FooExt1.getValueExt1", "FooExt1.getValueExt1"], "method_name": "SimpleInheritanceTest.testSimpleInheritance1", "method_implementation": "{\n    final FooExt1 foo = new FooExt1();\n    foo.setValue(\"Value\");\n    foo.setValueExt1(\"ValueExt1\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt1 foo2 = this.find(FooExt1.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo2.getValueExt1());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with extending type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2227, "method_signature": "void testSimpleInheritance1()"}, "SimpleInheritanceTest.testSimpleInheritance11": {"callee_method_names": ["FooExt11.setValue", "FooExt11.setValueExt1", "FooExt11.setValueExt11", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getValue", "FooExt11.getValue", "FooExt11.getValueExt1", "FooExt11.getValueExt1", "FooExt11.getValueExt11", "FooExt11.getValueExt11"], "method_name": "SimpleInheritanceTest.testSimpleInheritance11", "method_implementation": "{\n    final FooExt11 foo = new FooExt11();\n    foo.setValue(\"Value\");\n    foo.setValueExt1(\"ValueExt1\");\n    foo.setValueExt11(\"ValueExt11\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt11 foo2 = this.find(FooExt11.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo2.getValueExt1());\n    Assert.assertEquals(foo.getValueExt11(), foo2.getValueExt11());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with further extending type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2228, "method_signature": "void testSimpleInheritance11()"}, "SimpleInheritanceTest.testSimpleInheritance3": {"callee_method_names": ["FooExt11.setValue", "FooExt11.setValueExt1", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getKey", "FooExt11.getValue", "FooExt11.getValue", "FooExt11.getValueExt1", "FooExt11.getValueExt1", "FooExt11.getValueExt11", "FooExt11.getValueExt11"], "method_name": "SimpleInheritanceTest.testSimpleInheritance3", "method_implementation": "{\n    final FooExt11 foo = new FooExt11();\n    foo.setValue(\"Value\");\n    foo.setValueExt1(\"ValueExt1\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final FooExt11 foo2 = (FooExt11) this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n    Assert.assertEquals(foo.getValue(), foo2.getValue());\n    Assert.assertEquals(foo.getValueExt1(), foo2.getValueExt1());\n    Assert.assertEquals(foo.getValueExt11(), foo2.getValueExt11());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)} then {@link EntityManager#find(Class, Object)} with root type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2229, "method_signature": "void testSimpleInheritance3()"}, "SimpleInheritanceTest.testSimpleInheritance4": {"callee_method_names": ["FooExt11.setValue", "FooExt11.setValueExt1", "Bar.getId", "Bar.getFoo", "Bar.getFoo", "Bar.getFoo"], "method_name": "SimpleInheritanceTest.testSimpleInheritance4", "method_implementation": "{\n    final FooExt11 foo = new FooExt11();\n    foo.setValue(\"FooExt11 Value\");\n    foo.setValueExt1(\"ValueExt1\");\n    final Bar bar = new Bar(1, foo);\n    this.persist(bar);\n    this.commit();\n    this.close();\n    final Bar bar2 = this.find(Bar.class, 1l);\n    Assert.assertEquals(1, bar2.getId());\n    Assert.assertEquals(1, bar2.getFoo().getKey().intValue());\n    Assert.assertEquals(\"FooExt11 Value\", bar2.getFoo().getValue());\n    Assert.assertEquals(FooExt11.class, bar2.getFoo().getClass().getSuperclass());\n}", "repo_id": "1", "comment": "/**\n * Test inheritance of mappedSuperClass\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2230, "method_signature": "void testSimpleInheritance4()"}, "SimpleJpqlTest.prepareCountries": {"callee_method_names": [], "method_name": "SimpleJpqlTest.prepareCountries", "method_implementation": "{\n    this.begin();\n    this.persist(SimpleJpqlTest.TR);\n    this.persist(SimpleJpqlTest.USA);\n    this.persist(SimpleJpqlTest.UK);\n    this.persist(SimpleJpqlTest.BROKEN);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2368, "method_signature": "void prepareCountries()"}, "SimpleJpqlTest.testAliasNotBound": {"callee_method_names": ["TypedQuery<Country>.getResultList"], "method_name": "SimpleJpqlTest.testAliasNotBound", "method_implementation": "{\n    final TypedQuery<Country> q = this.cq(\"select d from Country c\", Country.class);\n    q.getResultList();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2369, "method_signature": "void testAliasNotBound()"}, "SimpleJpqlTest.testArtimeticOperands": {"callee_method_names": ["TypedQuery<Number>.getResultList", "TypedQuery<Number>.getResultList", "TypedQuery<Number>.getResultList", "TypedQuery<Number>.getResultList", "TypedQuery<Number>.getResultList"], "method_name": "SimpleJpqlTest.testArtimeticOperands", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    TypedQuery<Number> q1;\n    int total;\n    q1 = this.cq(\"select -p.age from Person p\", Number.class);\n    total = 0;\n    for (final Number i : q1.getResultList()) {\n        total += i.intValue();\n    }\n    Assert.assertEquals(-75, total);\n    q1 = this.cq(\"select p.age + p.age from Person p\", Number.class);\n    total = 0;\n    for (final Number i : q1.getResultList()) {\n        total += i.intValue();\n    }\n    Assert.assertEquals(150, total);\n    q1 = this.cq(\"select -p.age + -p.age from Person p\", Number.class);\n    total = 0;\n    for (final Number i : q1.getResultList()) {\n        total += i.intValue();\n    }\n    Assert.assertEquals(-150, total);\n    q1 = this.cq(\"select 22 + p.age from Person p\", Number.class);\n    total = 0;\n    for (final Number i : q1.getResultList()) {\n        total += i.intValue();\n    }\n    Assert.assertEquals(119, total);\n    q1 = this.cq(\"select p.age * 2 from Person p\", Number.class);\n    total = 0;\n    for (final Number i : q1.getResultList()) {\n        total += i.intValue();\n    }\n    Assert.assertEquals(150, total);\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2370, "method_signature": "void testArtimeticOperands()"}, "SimpleJpqlTest.testAssociation": {"callee_method_names": [], "method_name": "SimpleJpqlTest.testAssociation", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    Assert.assertEquals(6, this.cq(\"select a from Person p inner join p.addresses a\", Address.class).getResultList().size());\n    Assert.assertEquals(6, this.cq(\"select a from Person p, IN(p.addresses) a\", Address.class).getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2371, "method_signature": "void testAssociation()"}, "SimpleJpqlTest.testAssociationJoin": {"callee_method_names": ["TypedQuery<Address>.setParameter", "TypedQuery<Address>.getResultList"], "method_name": "SimpleJpqlTest.testAssociationJoin", "method_implementation": "{\n    final Person person = this.person();\n    this.persist(person);\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final TypedQuery<Address> q = //\n    this.//\n    cq(//\n    \"select a from Person p\\n\" + //\n    \"left join p.addresses as a \\n\" + //\n    \"left join fetch a.country \\n\" + //\n    \"left join fetch a.person \\n\" + \"where p = :person\", Address.class);\n    q.setParameter(\"person\", person);\n    Assert.assertEquals(3, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2372, "method_signature": "void testAssociationJoin()"}, "SimpleJpqlTest.testBooleanExpression": {"callee_method_names": ["TypedQuery<Address>.getResultList"], "method_name": "SimpleJpqlTest.testBooleanExpression", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final TypedQuery<Address> q = //\n    this.//\n    cq(//\n    \"select a as a1 from Person p\\n\" + //\n    \"    left join p.addresses a\\n\" + //\n    \"    where a.primary\", Address.class);\n    Assert.assertEquals(2, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2373, "method_signature": "void testBooleanExpression()"}, "SimpleJpqlTest.testComparisonOperands": {"callee_method_names": ["TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList"], "method_name": "SimpleJpqlTest.testComparisonOperands", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    TypedQuery<Person> q;\n    q = this.cq(\"select p from Person p where p.age > :age\", Person.class).setParameter(\"age\", 40);\n    Assert.assertEquals(0, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age < :age\", Person.class).setParameter(\"age\", 40);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age >= :age\", Person.class).setParameter(\"age\", 40);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age >= :age1 or p.age < :age2\", Person.class).setParameter(\"age1\", 40).setParameter(\"age2\", 50);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age <= :age\", Person.class).setParameter(\"age\", 40);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age between :age1 and :age2\", Person.class).setParameter(\"age1\", 38).setParameter(\"age2\", 41);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age between :age1 and :age2\", Person.class).setParameter(\"age1\", 30).setParameter(\"age2\", 50);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age between :age1 and :age2\", Person.class).setParameter(\"age1\", 10).setParameter(\"age2\", 20);\n    Assert.assertEquals(0, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age not between :age1 and :age2\", Person.class).setParameter(\"age1\", 10).setParameter(\"age2\", 20);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age in (:age1, :age2)\", Person.class).setParameter(\"age1\", 35).setParameter(\"age2\", 40);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.age in (:p1, :p2)\", Person.class).setParameter(\"p1\", 35).setParameter(\"p2\", 45);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where (p.age < 10 or p.age > :age1) and (p.age > 100 or p.age < :age2)\", Person.class).setParameter(\"age1\", 36).setParameter(\"age2\", 50);\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2374, "method_signature": "void testComparisonOperands()"}, "SimpleJpqlTest.testConstructor": {"callee_method_names": ["TypedQuery<SimpleCity>.getResultList", "List<SimpleCity>.toString"], "method_name": "SimpleJpqlTest.testConstructor", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final TypedQuery<SimpleCity> q = this.cq(\"select new org.batoo.jpa.core.test.q.SimpleCity(a.city, a.country.name) from Address a\", SimpleCity.class);\n    final List<SimpleCity> resultList = q.getResultList();\n    Collections.sort(resultList);\n    Assert.assertEquals(\"[SimpleCity [city=Istanbul, country=Turkey], SimpleCity [city=London, country=United Kingdom], SimpleCity [city=New York, country=United States of America]]\", resultList.toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2375, "method_signature": "void testConstructor()"}, "SimpleJpqlTest.testDateExpression": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.getTime", "GregorianCalendar.getTime", "GregorianCalendar.getTime", "TypedQuery<Person>.getResultList", "GregorianCalendar.getTime", "TypedQuery<Person>.getResultList", "GregorianCalendar.getTime", "TypedQuery<Person>.getResultList", "GregorianCalendar.getTime", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<java.sql.Date>.getResultList", "TypedQuery<Time>.getResultList", "TypedQuery<Timestamp>.getResultList"], "method_name": "SimpleJpqlTest.testDateExpression", "method_implementation": "{\n    final GregorianCalendar start1 = new GregorianCalendar();\n    start1.set(Calendar.YEAR, 2000);\n    start1.set(Calendar.MONTH, 12);\n    start1.set(Calendar.DAY_OF_MONTH, 31);\n    final GregorianCalendar start2 = new GregorianCalendar();\n    start2.set(Calendar.YEAR, 2001);\n    start2.set(Calendar.MONTH, 12);\n    start2.set(Calendar.DAY_OF_MONTH, 31);\n    this.persist(this.person(40, start1.getTime()));\n    this.persist(this.person(35, start2.getTime()));\n    this.commit();\n    this.close();\n    TypedQuery<Person> q;\n    q = this.cq(\"select p from Person p where p.startDate = :start\", Person.class).setParameter(\"start\", start1.getTime(), TemporalType.DATE);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.startDate < :start\", Person.class).setParameter(\"start\", start2.getTime(), TemporalType.DATE);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.startDate >= :start\", Person.class).setParameter(\"start\", start1.getTime(), TemporalType.DATE);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.startDate <= :start\", Person.class).setParameter(\"start\", start1.getTime(), TemporalType.DATE);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.startDate <= current_date\", Person.class);\n    Assert.assertEquals(2, q.getResultList().size());\n    final TypedQuery<java.sql.Date> q2 = this.cq(\"select current_date from Person p\", java.sql.Date.class);\n    Assert.assertEquals(2, q2.getResultList().size());\n    final TypedQuery<Time> q3 = this.cq(\"select current_time from Person p\", Time.class);\n    Assert.assertEquals(2, q3.getResultList().size());\n    final TypedQuery<Timestamp> q4 = this.cq(\"select current_timestamp from Person p\", Timestamp.class);\n    Assert.assertEquals(2, q4.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2376, "method_signature": "void testDateExpression()"}, "SimpleJpqlTest.testEmpty": {"callee_method_names": ["TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList"], "method_name": "SimpleJpqlTest.testEmpty", "method_implementation": "{\n    this.persist(this.person(35, new Date()));\n    this.persist(new Person(\"ali\", 35, new Date()));\n    this.persist(new Person(\"osman\", 35, new Date()));\n    this.commit();\n    this.close();\n    TypedQuery<Person> q;\n    q = this.cq(\"select p from Person p where p.addresses IS EMPTY\", Person.class);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.addresses IS NOT EMPTY\", Person.class);\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * Tests for is empty and is not\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2377, "method_signature": "void testEmpty()"}, "SimpleJpqlTest.testFunction": {"callee_method_names": [], "method_name": "SimpleJpqlTest.testFunction", "method_implementation": "{\n    final String testMode = System.getProperty(\"testMode\");\n    // oracle doesn't have pi function\n    if (\"oracle\".equals(testMode)) {\n        return;\n    }\n    this.persist(this.person(100));\n    this.commit();\n    double expected = 314.159265;\n    if (\"hsql\".equals(testMode) || \"derby\".equals(testMode) || \"h2\".equals(testMode) || \"mssql\".equals(testMode) || \"saw\".equals(testMode) || \"pgsql\".equals(testMode)) {\n        expected = 314.1592653589793;\n    }\n    Assert.assertEquals(expected, this.cq(\"select pp.age * func(pi, '()') from Person pp\", Double.class).getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2378, "method_signature": "void testFunction()"}, "SimpleJpqlTest.testIn": {"callee_method_names": ["TypedQuery<Country>.getResultList", "TypedQuery<Country>.getResultList", "TypedQuery<Country>.getResultList", "TypedQuery<Country>.getResultList", "TypedQuery<Country>.getResultList", "TypedQuery<Country>.getResultList"], "method_name": "SimpleJpqlTest.testIn", "method_implementation": "{\n    final List<String> codeList = Lists.newArrayList(SimpleJpqlTest.TR.getCode(), SimpleJpqlTest.UK.getCode());\n    final Set<String> codeSet = Sets.newHashSet(SimpleJpqlTest.TR.getCode(), SimpleJpqlTest.UK.getCode());\n    final String[] codeArr = { SimpleJpqlTest.TR.getCode(), SimpleJpqlTest.UK.getCode() };\n    TypedQuery<Country> q = this.cq(\"select c from Country c where c.code in ('TR', 'UK')\", Country.class);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select c from Country c where c.code not in (:codeList)\", Country.class).setParameter(\"codeList\", codeList);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select c from Country c where c.code not in ('TR')\", Country.class);\n    Assert.assertEquals(3, q.getResultList().size());\n    q = this.cq(\"select c from Country c where c.code in (:codeList)\", Country.class).setParameter(\"codeList\", codeList);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select c from Country c where c.code in (:codeSet)\", Country.class).setParameter(\"codeSet\", codeSet);\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select c from Country c where c.code in (:codeArr)\", Country.class).setParameter(\"codeArr\", codeArr);\n    Assert.assertEquals(2, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2379, "method_signature": "void testIn()"}, "SimpleJpqlTest.testIndex": {"callee_method_names": ["TypedQuery<Number>.getResultList"], "method_name": "SimpleJpqlTest.testIndex", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final TypedQuery<Number> q = //\n    this.//\n    cq(//\n    \"select index(wp) from Person p\\n\" + //\n    \"    left join p.workPhones wp\\n\" + \"    order by wp.id\", Number.class);\n    Assert.assertEquals(\"[0, 1]\", q.getResultList().toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2380, "method_signature": "void testIndex()"}, "SimpleJpqlTest.testLike": {"callee_method_names": ["Person.setName", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList"], "method_name": "SimpleJpqlTest.testLike", "method_implementation": "{\n    final Person person = this.person(40);\n    person.setName(\"%Ceylan\");\n    this.persist(person);\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    TypedQuery<Person> q;\n    q = this.cq(\"select p from Person p where p.name like :name\", Person.class).setParameter(\"name\", \"Ce%\");\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.name like :name\", Person.class).setParameter(\"name\", \"De%\");\n    Assert.assertEquals(0, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.name not like :name escape '^'\", Person.class).setParameter(\"name\", \"^%Ce%\");\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2381, "method_signature": "void testLike()"}, "SimpleJpqlTest.testNamedQuery": {"callee_method_names": [], "method_name": "SimpleJpqlTest.testNamedQuery", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.commit();\n    Assert.assertEquals(40, this.em().createNamedQuery(\"theOldestGuys\", Person.class).setMaxResults(1).getSingleResult().getAge());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2382, "method_signature": "void testNamedQuery()"}, "SimpleJpqlTest.testNumericFunctions": {"callee_method_names": ["TypedQuery<Number>.getSingleResult", "TypedQuery<Number>.getSingleResult", "TypedQuery<Number>.getSingleResult", "TypedQuery<Number>.getSingleResult"], "method_name": "SimpleJpqlTest.testNumericFunctions", "method_implementation": "{\n    this.persist(this.person(-49));\n    this.commit();\n    this.close();\n    TypedQuery<Number> q;\n    q = this.cq(\"select abs(p.age) from Person p where p.id = 1\", Number.class);\n    Assert.assertEquals(49, q.getSingleResult().intValue());\n    q = this.cq(\"select sqrt(abs(p.age)) from Person p where p.id = 1\", Number.class);\n    Assert.assertEquals(7.0, q.getSingleResult().doubleValue());\n    q = this.cq(\"select mod(abs(p.age), 10) from Person p where p.id = 1\", Number.class);\n    Assert.assertEquals(9, q.getSingleResult().intValue());\n    q = this.cq(\"select length(p.name) from Person p where p.id = 1\", Number.class);\n    Assert.assertEquals(6, q.getSingleResult().intValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2383, "method_signature": "void testNumericFunctions()"}, "SimpleJpqlTest.testOrderBy": {"callee_method_names": [], "method_name": "SimpleJpqlTest.testOrderBy", "method_implementation": "{\n    final String testMode = System.getProperty(\"testMode\");\n    String expected = null;\n    if (\"mysql\".equals(testMode) || \"hsql\".equals(testMode) || \"h2\".equals(testMode) || \"mssql\".equals(testMode) || \"saw\".equals(testMode)) {\n        expected = SimpleJpqlTest.COUNTRY_USA;\n    }\n    Assert.assertEquals(expected, this.cq(\"select c.name from Country c order by c.name desc\", String.class).setMaxResults(1).getSingleResult());\n    expected = SimpleJpqlTest.COUNTRY_TR;\n    if (\"mysql\".equals(testMode) || \"hsql\".equals(testMode) || \"h2\".equals(testMode) || \"mssql\".equals(testMode) || \"saw\".equals(testMode)) {\n        expected = null;\n    }\n    Assert.assertEquals(expected, this.cq(\"select c.name from Country c order by c.name asc\", String.class).setMaxResults(1).getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2384, "method_signature": "void testOrderBy()"}, "SimpleJpqlTest.testOrderedParameters": {"callee_method_names": ["TypedQuery<Person>.getSingleResult", "TypedQuery<Person>.getSingleResult"], "method_name": "SimpleJpqlTest.testOrderedParameters", "method_implementation": "{\n    this.persist(this.person(15));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    TypedQuery<Person> q = this.cq(\"select p from Person p where p.age = ?\", Person.class).setParameter(1, 15);\n    Assert.assertEquals(15, q.getSingleResult().getAge());\n    q = this.cq(\"select p from Person p where p.age = ?1 or p.age = ?2\", Person.class).setParameter(2, 15);\n    Assert.assertEquals(15, q.getSingleResult().getAge());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2385, "method_signature": "void testOrderedParameters()"}, "SimpleJpqlTest.testPagination": {"callee_method_names": [], "method_name": "SimpleJpqlTest.testPagination", "method_implementation": "{\n    Assert.assertEquals(2l, this.cq(\"select c from Country c\", Country.class).setFirstResult(2).getResultList().size());\n    Assert.assertEquals(2l, this.cq(\"select c from Country c\", Country.class).setMaxResults(2).getResultList().size());\n    Assert.assertEquals(1l, this.cq(\"select c from Country c\", Country.class).setFirstResult(3).setMaxResults(2).getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2386, "method_signature": "void testPagination()"}, "SimpleJpqlTest.testQuery": {"callee_method_names": [], "method_name": "SimpleJpqlTest.testQuery", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    Assert.assertEquals(75, ((Number) this.cq(\"select sum(p.age) from Person p\").getSingleResult()).intValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2387, "method_signature": "void testQuery()"}, "SimpleJpqlTest.testReusedParams": {"callee_method_names": ["GregorianCalendar.getTime", "Person.setValidTo", "GregorianCalendar.getTime", "GregorianCalendar.add", "GregorianCalendar.getTime", "Person.setValidTo", "GregorianCalendar.getTime", "GregorianCalendar.add", "GregorianCalendar.getTime", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getParameter", "GregorianCalendar.getTime", "TypedQuery<Person>.getResultList", "TypedQuery<Person>.getParameter", "GregorianCalendar.getTime", "GregorianCalendar.getTime", "TypedQuery<Person>.getResultList"], "method_name": "SimpleJpqlTest.testReusedParams", "method_implementation": "{\n    final GregorianCalendar day1 = new GregorianCalendar();\n    final Person person1 = new Person(\"person1\", 35, day1.getTime());\n    person1.setValidTo(day1.getTime());\n    day1.add(Calendar.DAY_OF_YEAR, 10);\n    final Person person2 = new Person(\"person2\", 45, day1.getTime());\n    person2.setValidTo(day1.getTime());\n    final GregorianCalendar day2 = new GregorianCalendar();\n    day2.add(Calendar.DAY_OF_YEAR, 1);\n    this.persist(person1);\n    this.persist(person2);\n    this.commit();\n    this.close();\n    TypedQuery<Person> q = this.cq(//\n    \"SELECT p FROM Person p \" + \"where (p.validFrom is null or p.validFrom <= :now) and (p.validTo is null or p.validTo >= :now)\", //\n    Person.class).setParameter(\"now\", day2.getTime(), TemporalType.DATE);\n    Assert.assertEquals(1, q.getResultList().size());\n    Assert.assertNull(q.getParameter(\"now\").getPosition());\n    q = this.cq(//\n    \"SELECT p FROM Person p \" + \"where (p.validFrom is null or p.validFrom <= ?1) and (p.validTo is null or p.validTo >= ?1)\", //\n    Person.class).setParameter(1, day2.getTime(), TemporalType.DATE);\n    Assert.assertEquals(1, q.getResultList().size());\n    Assert.assertNull(q.getParameter(1).getName());\n    q = this.cq(//\n    \"SELECT p FROM Person p \" + \"where (p.validFrom is null or p.validFrom <= ?1) and (p.validTo is null or p.validTo >= ?2)\", //\n    Person.class).setParameter(1, day2.getTime(), //\n    TemporalType.DATE).setParameter(2, day1.getTime(), TemporalType.DATE);\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2388, "method_signature": "void testReusedParams()"}, "SimpleJpqlTest.testRootJoin": {"callee_method_names": ["TypedQuery<Person>.getResultList", "List<Person>.size", "List<Person>.get"], "method_name": "SimpleJpqlTest.testRootJoin", "method_implementation": "{\n    this.persist(this.person());\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    final TypedQuery<Person> q = //\n    this.//\n    cq(//\n    \"select p from Person p\\n\" + //\n    \"    left join fetch p.addresses\\n\" + //\n    \"    left join fetch p.addresses.country\\n\" + //\n    \"    left join p.addresses a\", Person.class);\n    final List<Person> resultList = q.getResultList();\n    Assert.assertEquals(18, resultList.size());\n    Assert.assertEquals(3, resultList.get(0).getAddresses().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2389, "method_signature": "void testRootJoin()"}, "SimpleJpqlTest.testSimple": {"callee_method_names": ["TypedQuery<Country>.getResultList", "TypedQuery<Country>.getResultList", "Order.getName", "List<Country>.toString", "TypedQuery<Country>.getResultList"], "method_name": "SimpleJpqlTest.testSimple", "method_implementation": "{\n    TypedQuery<Country> q = this.cq(\"select c from Country c where c = :country\", Country.class).setParameter(\"country\", SimpleJpqlTest.TR);\n    Assert.assertEquals(1, q.getResultList().size());\n    q = this.cq(\"select c from Country c where c.name is not null\", Country.class);\n    final List<Country> rs = q.getResultList();\n    Collections.sort(rs, new Comparator<Country>() {\n\n        @Override\n        public int compare(Country o1, Country o2) {\n            return o1.getName().compareTo(o2.getName());\n        }\n    });\n    Assert.assertEquals(\"[Country [name=Turkey], Country [name=United Kingdom], Country [name=United States of America]]\", rs.toString());\n    q = this.cq(\"select c from Country as c where c.name is null\", Country.class);\n    Assert.assertEquals(1, q.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2390, "method_signature": "void testSimple()"}, "SimpleJpqlTest.testStringExpression": {"callee_method_names": ["TypedQuery<Person>.getResultList", "TypedQuery<Person>.getResultList", "TypedQuery<String>.getResultList", "TypedQuery<String>.getResultList", "String.equals", "TypedQuery<String>.getResultList", "TypedQuery<String>.getResultList", "TypedQuery<String>.getResultList", "TypedQuery<String>.getSingleResult", "TypedQuery<String>.getSingleResult", "TypedQuery<String>.getSingleResult", "TypedQuery<String>.getSingleResult", "TypedQuery<String>.getSingleResult"], "method_name": "SimpleJpqlTest.testStringExpression", "method_implementation": "{\n    this.persist(this.person(40));\n    this.persist(this.person(35));\n    this.commit();\n    this.close();\n    TypedQuery<Person> q;\n    TypedQuery<String> q2;\n    final String testMode = System.getProperty(\"testMode\");\n    q = this.cq(\"select p.name from Person p where p.name <= :name\", Person.class).setParameter(\"name\", \"Ceylan\");\n    Assert.assertEquals(2, q.getResultList().size());\n    q = this.cq(\"select p from Person p where p.name > :name\", Person.class).setParameter(\"name\", \"Ceylan\");\n    Assert.assertEquals(0, q.getResultList().size());\n    q2 = this.cq(\"select lower(c.name) from Country c where upper(c.name) = :name\", String.class).setParameter(\"name\", SimpleJpqlTest.COUNTRY_TR.toUpperCase());\n    Assert.assertEquals(\"turkey\", q2.getResultList().get(0));\n    q2 = this.cq(\"select upper(c.name) from Country c where lower(c.name) = :name\", String.class).setParameter(\"name\", SimpleJpqlTest.COUNTRY_TR.toLowerCase());\n    Assert.assertEquals(\"TURKEY\", q2.getResultList().get(0));\n    q2 = this.cq(\"select concat(c.code, '_', c.name) from Country c order by c.code\", String.class);\n    String expected = \"[null, TR_Turkey, UK_United Kingdom, USA_United States of America]\";\n    if (testMode.equals(\"oracle\") || \"saw\".equals(testMode)) {\n        expected = \"[BR_, TR_Turkey, UK_United Kingdom, USA_United States of America]\";\n    }\n    Assert.assertEquals(expected, q2.getResultList().toString());\n    q2 = this.cq(\"select substring(c.name, 2) from Country c order by c.code\", String.class);\n    Assert.assertEquals(\"[null, urkey, nited Kingdom, nited States of America]\", q2.getResultList().toString());\n    q2 = this.cq(\"select substring(c.name, 2, 3) from Country c order by c.code\", String.class);\n    Assert.assertEquals(\"[null, urk, nit, nit]\", q2.getResultList().toString());\n    q2 = this.cq(\"select trim(' a ') from Country c where c = :country\", String.class).setParameter(\"country\", SimpleJpqlTest.TR);\n    Assert.assertEquals(\"a\", q2.getSingleResult());\n    q2 = this.cq(\"select trim(leading from ' a ') from Country c where c = :country\", String.class).setParameter(\"country\", SimpleJpqlTest.TR);\n    Assert.assertEquals(\"a \", q2.getSingleResult());\n    q2 = this.cq(\"select trim(trailing from ' a ') from Country c where c = :country\", String.class).setParameter(\"country\", SimpleJpqlTest.TR);\n    Assert.assertEquals(\" a\", q2.getSingleResult());\n    q2 = this.cq(\"select trim(both from ' a ') from Country c where c = :country\", String.class).setParameter(\"country\", SimpleJpqlTest.TR);\n    Assert.assertEquals(\"a\", q2.getSingleResult());\n    if (!\"mssql\".equals(testMode) && !\"saw\".equals(testMode)) {\n        q2 = this.cq(\"select trim(both 'c' from 'cac') from Country c where c = :country\", String.class).setParameter(\"country\", SimpleJpqlTest.TR);\n        Assert.assertEquals(\"a\", q2.getSingleResult());\n    }\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2391, "method_signature": "void testStringExpression()"}, "SimpleJpqlTest.testTrueInJpql": {"callee_method_names": [], "method_name": "SimpleJpqlTest.testTrueInJpql", "method_implementation": "{\n    this.persist(this.person());\n    this.commit();\n    this.close();\n    Assert.assertEquals(1, this.cq(\"select p from Person p where p.manager = false\", Person.class).getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2392, "method_signature": "void testTrueInJpql()"}, "SimpleTest.testContains": {"callee_method_names": [], "method_name": "SimpleTest.testContains", "method_implementation": "{\n    final Foo foo = new Foo();\n    final Foo foo2 = new Foo();\n    this.persist(foo);\n    Assert.assertTrue(this.contains(foo));\n    Assert.assertFalse(this.contains(foo2));\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#contains(Object)}.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2485, "method_signature": "void testContains()"}, "SimpleTest.testCreateTable": {"callee_method_names": ["Set<EntityType<?>>.size"], "method_name": "SimpleTest.testCreateTable", "method_implementation": "{\n    final Set<EntityType<?>> entities = this.em().getMetamodel().getEntities();\n    Assert.assertEquals(1, entities.size());\n    final DataSource dataSource = this.em().unwrap(DataSource.class);\n    new QueryRunner(dataSource).query(\"SELECT * FROM Foo\", new NullResultSetHandler());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManagerFactory#createEntityManager()}\n *\n * @throws SQLException\n *             thrown if fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2486, "method_signature": "void testCreateTable()"}, "SimpleTest.testDetach": {"callee_method_names": [], "method_name": "SimpleTest.testDetach", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    Assert.assertTrue(this.em().contains(foo));\n    this.detach(foo);\n    this.close();\n    Assert.assertFalse(this.em().contains(foo));\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#detach(Object)}.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2487, "method_signature": "void testDetach()"}, "SimpleTest.testDetachAfterFind": {"callee_method_names": ["Foo.getId", "Foo.getId", "Foo.getId"], "method_name": "SimpleTest.testDetachAfterFind", "method_implementation": "{\n    final Foo foo = this.newFoo();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    final Foo foo2 = this.find(Foo.class, foo.getId());\n    Assert.assertEquals(foo.getId(), foo2.getId());\n    this.detach(foo2);\n    this.close();\n    Assert.assertFalse(this.em().contains(foo2));\n}", "repo_id": "1", "comment": "/**\n * Test for find entity then detach it\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2124, "method_signature": "void testDetachAfterFind()"}, "SimpleTest.testDetachThenCommit": {"callee_method_names": [], "method_name": "SimpleTest.testDetachThenCommit", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.detach(foo);\n    this.commit();\n    Assert.assertEquals(0, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#detach(Object)} then {@link EntityTransaction#commit()}.\n *\n * @throws SQLException\n *             thrown if fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2488, "method_signature": "void testDetachThenCommit()"}, "SimpleTest.testFind": {"callee_method_names": ["Foo.getKey", "Foo.getKey", "Foo.getKey"], "method_name": "SimpleTest.testFind", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getKey());\n    Assert.assertEquals(foo.getKey(), foo2.getKey());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2489, "method_signature": "void testFind()"}, "SimpleTest.testFlushThenDetach": {"callee_method_names": [], "method_name": "SimpleTest.testFlushThenDetach", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.flush();\n    this.detach(foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#flush()} then {@link EntityManager#detach(Object)}\n *\n * @throws SQLException\n *             thrown if fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2490, "method_signature": "void testFlushThenDetach()"}, "SimpleTest.testPersist": {"callee_method_names": [], "method_name": "SimpleTest.testPersist", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if fails\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2491, "method_signature": "void testPersist()"}, "SimpleTest.testTestSimpleSelect": {"callee_method_names": [], "method_name": "SimpleTest.testTestSimpleSelect", "method_implementation": "{\n    SimpleTest.LOG.debug(CommonTreePrinter.toString(this.parse(\"first.jpql\")));\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2507, "method_signature": "void testTestSimpleSelect()"}, "SingleValueHandler.handle": {"callee_method_names": ["ResultSet.next", "ResultSet.getObject"], "method_name": "SingleValueHandler.handle", "method_implementation": "{\n    if (rs.next()) {\n        return (T) rs.getObject(1);\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1158, "method_signature": "T handle(ResultSet)"}, "SingularAssociationMappingImpl.checkTransient": {"callee_method_names": ["ManagedInstance<?>.getInstance"], "method_name": "SingularAssociationMappingImpl.checkTransient", "method_implementation": "{\n    final X instance = this.get(managedInstance.getInstance());\n    if (instance != null) {\n        final Object instanceId = this.type.getInstanceId(instance);\n        if (instanceId == null) {\n            throw new PersistenceException(\"Instance \" + instance + \" is not managed\");\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 341, "method_signature": "void checkTransient(ManagedInstance)"}, "SingularAssociationMappingImpl.flush": {"callee_method_names": ["ManagedInstance<?>.getInstance", "ManagedInstance<?>.getInstance"], "method_name": "SingularAssociationMappingImpl.flush", "method_implementation": "{\n    if (this.getJoinTable() != null) {\n        if (!removals) {\n            final X entity = this.get(managedInstance.getInstance());\n            if (entity != null) {\n                final Joinable[] batch = new Joinable[] { new Joinable(null, entity, 0) };\n                this.joinTable.performInsert(connection, managedInstance.getInstance(), batch, 1);\n            }\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 342, "method_signature": "void flush(Connection, ManagedInstance, boolean, boolean)"}, "SingularAssociationMappingImpl.getIdType": {"callee_method_names": [], "method_name": "SingularAssociationMappingImpl.getIdType", "method_implementation": "{\n    if (this.attribute.isId()) {\n        return IdType.MANUAL;\n    }\n    final AbstractParentMapping<?, Z> parent = this.getParent();\n    if (parent instanceof EmbeddedMappingImpl) {\n        return ((EmbeddedMappingImpl<?, Z>) parent).getIdType();\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 343, "method_signature": "IdType getIdType()"}, "SingularAssociationMappingImpl.initialize": {"callee_method_names": ["ManagedInstance<?>.getSession", "EntityManagerImpl.createQuery", "QueryImpl<X>.setParameter", "ManagedInstance<?>.getInstance", "QueryImpl<X>.getSingleResult", "ManagedInstance<?>.getInstance"], "method_name": "SingularAssociationMappingImpl.initialize", "method_implementation": "{\n    final EntityManagerImpl em = managedInstance.getSession().getEntityManager();\n    final QueryImpl<X> q = em.createQuery(this.getSelectCriteria());\n    q.setParameter(1, managedInstance.getInstance());\n    try {\n        final X child = q.getSingleResult();\n        final Object instance = managedInstance.getInstance();\n        this.set(instance, child);\n        if (this.getInverse() != null) {\n            final Object newParent = this.getInverse().get(child);\n            if ((newParent == null) && (newParent != this)) {\n                this.getInverse().set(child, instance);\n            }\n        }\n    } catch (final NoResultException e) {\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 344, "method_signature": "void initialize(ManagedInstance)"}, "SingularAssociationMappingImpl.link": {"callee_method_ids": [300], "callee_method_names": ["MetamodelImpl.entity"], "method_name": "SingularAssociationMappingImpl.link", "method_implementation": "{\n    final MetamodelImpl metamodel = this.getAttribute().getMetamodel();\n    this.type = metamodel.entity(this.attribute.getBindableJavaType());\n    if (!this.isOwner()) {\n        this.inverse = (AssociationMappingImpl<?, ?, ?>) this.type.getRootMapping().getMapping(this.getMappedBy());\n        if (this.inverse == null) {\n            throw new MappingException(\"Cannot find the mappedBy attribute \" + this.getMappedBy() + \" specified on \" + this.attribute.getJavaMember());\n        }\n        this.inverse.setInverse(this);\n    } else {\n        final EntityTypeImpl<?> entity = (EntityTypeImpl<?>) this.getRoot().getType();\n        // initialize the join table\n        if (this.joinTable != null) {\n            this.joinTable.link(entity, this.type);\n        } else // initialize the foreign key\n        {\n            this.foreignKey.link(this, this.type);\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 345, "method_signature": "void link()"}, "SingularAssociationMappingImpl.mergeWith": {"callee_method_ids": [449, 454], "callee_method_names": ["EntityManagerImpl.mergeImpl", "ManagedInstance<?>.getInstance", "EntityManagerImpl.remove", "ManagedInstance<?>.getSession", "ManagedInstance<X>.getInstance", "ManagedInstance<?>.getInstance"], "method_name": "SingularAssociationMappingImpl.mergeWith", "method_implementation": "{\n    // get the new value as merged\n    final X newEntity = entityManager.mergeImpl(this.get(entity), requiresFlush, processed, instances, this.cascadesMerge());\n    // get the old value\n    final X oldEntity = this.get(instance.getInstance());\n    // if no change nothing to do here\n    if (oldEntity == newEntity) {\n        return;\n    }\n    // handle the remove orphans and inverse\n    if ((oldEntity != null) && (this.removesOrphans() || (this.inverse != null))) {\n        // handle orphan removal\n        if (this.removesOrphans()) {\n            entityManager.remove(oldEntity);\n        }\n        // update the other side of the relation\n        if ((this.inverse != null) && (this.inverse.getAttribute().getPersistentAttributeType() == PersistentAttributeType.ONE_TO_ONE)) {\n            final ManagedInstance<X> oldInstance = instance.getSession().get(oldEntity);\n            this.inverse.set(oldInstance.getInstance(), null);\n        }\n    }\n    // set the new value\n    this.set(instance.getInstance(), newEntity);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 346, "method_signature": "void mergeWith(EntityManagerImpl, ManagedInstance, Object, MutableBoolean, IdentityHashMap, LinkedList)"}, "SingularAssociationMappingImpl.refresh": {"callee_method_names": ["ManagedInstance<?>.getSession", "ManagedInstance<?>.getInstance"], "method_name": "SingularAssociationMappingImpl.refresh", "method_implementation": "{\n    this.initialize(instance);\n    if (this.cascadesRefresh()) {\n        instance.getSession().getEntityManager().refreshImpl(instance.getInstance(), null, processed);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 347, "method_signature": "void refresh(ManagedInstance, Set)"}, "SingularAttributeImpl.toString": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "SingularAttributeImpl.toString", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder();\n    if (this.isId()) {\n        builder.append(\"id\");\n    } else if (this.isVersion()) {\n        builder.append(\"version\");\n    } else if (this.getPersistentAttributeType() == PersistentAttributeType.EMBEDDED) {\n        builder.append(\"embedded\");\n    } else {\n        builder.append(\"basic\");\n    }\n    final String declaringType = this.getDeclaringType().getJavaType().getSimpleName();\n    final String type = this.getBindableJavaType().getSimpleName();\n    builder.append(\" \").append(declaringType).append(\".\").append(this.getName()).append(\"(\").append(type).append(\")\");\n    return builder.toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 273, "method_signature": "String toString()"}, "SingularJoin.getMapping": {"callee_method_names": [], "method_name": "SingularJoin.getMapping", "method_implementation": "{\n    AbstractMapping<? super X, ?, ?> child = null;\n    if (this.getMapping().getMappingType() == MappingType.EMBEDDABLE) {\n        child = ((EmbeddedMappingImpl<? super Z, X>) this.getMapping()).getChild(name);\n    } else {\n        child = ((SingularAssociationMappingImpl<? super Z, X>) this.getMapping()).getType().getRootMapping().getChild(name);\n    }\n    if (child == null) {\n        throw this.cannotDereference(name);\n    }\n    return (AbstractMapping<? super X, C, Y>) child;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 830, "method_signature": "AbstractMapping<? super X,C,Y> getMapping(String)"}, "SingularJoin.getModel": {"callee_method_names": [], "method_name": "SingularJoin.getModel", "method_implementation": "{\n    return (SingularAttributeImpl<? super Z, X>) super.getAttribute();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 831, "method_signature": "SingularAttribute<? super Z,X> getModel()"}, "SizeExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "SizeExpression.generateJpqlSelect", "method_implementation": "{\n    if (StringUtils.isNotBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 589, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "SizeExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "SizeExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 590, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "SizeExpression.getSqlRestrictionFragments": {"callee_method_ids": [513, 519], "callee_method_names": ["BaseQueryImpl<?>.getMetamodel", "LinkedList<AbstractMapping<?, ?, ?>>.addFirst", "AbstractMapping<?, ?, ?>.getParent", "BaseQueryImpl<?>.subquery", "SubqueryImpl<Long>.from", "Joinable.getEntity", "AbstractFrom<?, ?>.join", "SubqueryImpl<Long>.where", "CriteriaBuilderImpl.equal", "SubqueryImpl<Long>.select", "CriteriaBuilderImpl.count", "CriteriaBuilderImpl.literal", "SubqueryImpl<Long>.getSqlRestrictionFragments"], "method_name": "SizeExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final CriteriaBuilderImpl cb = query.getMetamodel().getEntityManagerFactory().getCriteriaBuilder();\n    final Joinable rp = this.collection.getParentPath().getRootPath();\n    final LinkedList<AbstractMapping<?, ?, ?>> chain = Lists.newLinkedList();\n    AbstractMapping<?, ?, ?> mapping = this.collection.getMapping();\n    while (!(mapping instanceof EntityMapping)) {\n        chain.addFirst(mapping);\n        mapping = mapping.getParent();\n    }\n    final SubqueryImpl<Long> s = query.subquery(Long.class);\n    final RootImpl<?> r = s.from(rp.getEntity());\n    AbstractFrom<?, ?> from = r;\n    for (final AbstractMapping<?, ?, ?> chainMember : chain) {\n        from = from.join(chainMember.getName());\n    }\n    s.where(cb.equal(r, (AbstractExpression<?>) rp));\n    s.select(cb.count(cb.literal(1)));\n    return s.getSqlRestrictionFragments(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 591, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "SqlReader.fill": {"callee_method_names": [], "method_name": "SqlReader.fill", "method_implementation": "{\n    int dst;\n    if (this.markedChar <= SqlReader.UNMARKED) {\n        // No mark\n        dst = 0;\n    } else {\n        // Marked\n        final int delta = this.nextChar - this.markedChar;\n        if (delta >= this.readAheadLimit) {\n            // Gone past read-ahead limit: Invalidate mark\n            this.markedChar = SqlReader.INVALIDATED;\n            this.readAheadLimit = 0;\n            dst = 0;\n        } else {\n            if (this.readAheadLimit <= this.cb.length) {\n                // Shuffle in the current buffer\n                System.arraycopy(this.cb, this.markedChar, this.cb, 0, delta);\n                this.markedChar = 0;\n                dst = delta;\n            } else {\n                // Reallocate buffer to accommodate read-ahead limit\n                final char[] ncb = new char[this.readAheadLimit];\n                System.arraycopy(this.cb, this.markedChar, ncb, 0, delta);\n                this.cb = ncb;\n                this.markedChar = 0;\n                dst = delta;\n            }\n            this.nextChar = this.nChars = delta;\n        }\n    }\n    int n;\n    do {\n        n = this.in.read(this.cb, dst, this.cb.length - dst);\n    } while (n == 0);\n    if (n > 0) {\n        this.nChars = dst + n;\n        this.nextChar = dst;\n    }\n}", "repo_id": "1", "comment": "/**\n * Fills the input buffer, taking the mark into account if it is valid.\n *\n * @throws IOException\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 419, "method_signature": "void fill()"}, "SqlReader.readLine": {"callee_method_names": ["StringBuilder.length", "StringBuilder.toString", "StringBuilder.append", "StringBuilder.toString", "StringBuilder.append"], "method_name": "SqlReader.readLine", "method_implementation": "{\n    StringBuilder s = null;\n    int startChar;\n    boolean omitLF = this.skipLF;\n    for (; ; ) {\n        if (this.nextChar >= this.nChars) {\n            this.fill();\n        }\n        if (this.nextChar >= this.nChars) {\n            /* EOF */\n            if ((s != null) && (s.length() > 0)) {\n                return s.toString();\n            } else {\n                return null;\n            }\n        }\n        boolean eol = false;\n        char c = 0;\n        int i;\n        /* Skip a leftover '\\n', if necessary */\n        if (omitLF && (this.cb[this.nextChar] == '\\n')) {\n            this.nextChar++;\n        }\n        this.skipLF = false;\n        omitLF = false;\n        charLoop: for (i = this.nextChar; i < this.nChars; i++) {\n            c = this.cb[i];\n            if ((c == '\\n') || (c == '\\r')) {\n                eol = true;\n                break charLoop;\n            }\n        }\n        startChar = this.nextChar;\n        this.nextChar = i;\n        if (eol) {\n            String str;\n            if (s == null) {\n                str = new String(this.cb, startChar, i - startChar);\n            } else {\n                s.append(this.cb, startChar, i - startChar);\n                str = s.toString();\n            }\n            this.nextChar++;\n            if (c == '\\r') {\n                this.skipLF = true;\n            }\n            return str;\n        }\n        if (s == null) {\n            s = new StringBuilder(SqlReader.defaultExpectedLineLength);\n        }\n        s.append(this.cb, startChar, i - startChar);\n    }\n}", "repo_id": "1", "comment": "/**\n * Reads a line of text. A line is considered to be terminated by any one of a line feed ('\\n'), a carriage return ('\\r'), or a carriage\n * return followed immediately by a linefeed.\n *\n * @return A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream\n *         has been reached\n *\n * @exception IOException\n *                If an I/O error occurs\n *\n * @see java.nio.file.Files#readAllLines\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 420, "method_signature": "String readLine()"}, "SqlResultSetMappingElement.handleChild": {"callee_method_names": [], "method_name": "SqlResultSetMappingElement.handleChild", "method_implementation": "{\n    if (child instanceof ColumnResultElement) {\n        this.columns.add((ColumnResultMetadata) child);\n    }\n    if (child instanceof EntityResultElement) {\n        this.entities.add((EntityResultMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1087, "method_signature": "void handleChild(Element)"}, "StandaloneAnnotatedClassLocator.locateClasses": {"callee_method_names": ["PersistenceUnitInfo.getClassLoader", "PersistenceUnitInfo.getJarFileUrls", "PersistenceUnitInfo.getManagedClassNames", "PersistenceUnitInfo.excludeUnlistedClasses", "List<URL>.isEmpty", "Set<Class<?>>.addAll", "Set<Class<?>>.add", "ClassLoader.loadClass", "Set<Class<?>>.addAll"], "method_name": "StandaloneAnnotatedClassLocator.locateClasses", "method_implementation": "{\n    final ClassLoader classLoader = puInfo.getClassLoader();\n    final List<URL> jarFiles = puInfo.getJarFileUrls();\n    final List<String> managedClassNames = puInfo.getManagedClassNames();\n    final boolean excludeUnlistedClasses = puInfo.excludeUnlistedClasses();\n    final Set<Class<?>> classes = Sets.newHashSet();\n    if ((jarFiles != null) && !jarFiles.isEmpty()) {\n        for (final URL jarUrl : jarFiles) {\n            classes.addAll(JarAnnotatedClassLocator.getInstance().locateClasses(puInfo, jarUrl));\n        }\n    }\n    for (final String className : managedClassNames) {\n        try {\n            classes.add(classLoader.loadClass(className));\n        } catch (final ClassNotFoundException e) {\n            throw new PersistenceException(\"Unable to load listed persistent class \" + className, e);\n        }\n    }\n    if (!excludeUnlistedClasses) {\n        classes.addAll(ClassloaderAnnotatedClassLocator.getInstance().locateClasses(puInfo, null));\n    }\n    return classes;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1057, "method_signature": "Set<Class<?>> locateClasses(PersistenceUnitInfo, URL)"}, "StringUtils.addStringToArray": {"callee_method_names": [], "method_name": "StringUtils.addStringToArray", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array)) {\n        return new String[] { str };\n    }\n    final String[] newArr = new String[array.length + 1];\n    System.arraycopy(array, 0, newArr, 0, array.length);\n    newArr[array.length] = str;\n    return newArr;\n}", "repo_id": "1", "comment": "/**\n * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given\n * String.\n *\n * @param array\n *            the array to append to (can be <code>null</code>)\n * @param str\n *            the String to append\n * @return the new array (never <code>null</code>)\n */\n", "repo_name": "BatooJPA-master/", "id": 120, "method_signature": "String[] addStringToArray(String[], String)"}, "StringUtils.applyRelativePath": {"callee_method_names": ["String.lastIndexOf", "String.substring", "String.startsWith"], "method_name": "StringUtils.applyRelativePath", "method_implementation": "{\n    final int separatorIndex = path.lastIndexOf(StringUtils.FOLDER_SEPARATOR);\n    if (separatorIndex != -1) {\n        String newPath = path.substring(0, separatorIndex);\n        if (!relativePath.startsWith(StringUtils.FOLDER_SEPARATOR)) {\n            newPath += StringUtils.FOLDER_SEPARATOR;\n        }\n        return newPath + relativePath;\n    } else {\n        return relativePath;\n    }\n}", "repo_id": "1", "comment": "/**\n * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. \"/\" separators).\n *\n * @param path\n *            the path to start from (usually a full file path)\n * @param relativePath\n *            the relative path to apply (relative to the full file path above)\n * @return the full file path that results from applying the relative path\n */\n", "repo_name": "BatooJPA-master/", "id": 121, "method_signature": "String applyRelativePath(String, String)"}, "StringUtils.arrayToDelimitedString": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StringUtils.arrayToDelimitedString", "method_implementation": "{\n    if (ObjectUtils.isEmpty(arr)) {\n        return \"\";\n    }\n    if (arr.length == 1) {\n        return ObjectUtils.nullSafeToString(arr[0]);\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < arr.length; i++) {\n        if (i > 0) {\n            sb.append(delim);\n        }\n        sb.append(arr[i]);\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Convenience method to return a String array as a delimited (e.g. CSV) String. E.g. useful for <code>toString()</code>\n * implementations.\n *\n * @param arr\n *            the array to display\n * @param delim\n *            the delimiter to use (probably a \",\")\n * @return the delimited String\n */\n", "repo_name": "BatooJPA-master/", "id": 122, "method_signature": "String arrayToDelimitedString(Object[], String)"}, "StringUtils.cleanPath": {"callee_method_names": ["String.indexOf", "String.substring", "String.substring", "String.startsWith", "String.substring", "List<String>.add", "List<String>.add"], "method_name": "StringUtils.cleanPath", "method_implementation": "{\n    if (path == null) {\n        return null;\n    }\n    String pathToUse = StringUtils.replace(path, StringUtils.WINDOWS_FOLDER_SEPARATOR, StringUtils.FOLDER_SEPARATOR);\n    // Strip prefix from path to analyze, to not treat it as part of the\n    // first path element. This is necessary to correctly parse paths like\n    // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n    // strip the first \"core\" directory while keeping the \"file:\" prefix.\n    final int prefixIndex = pathToUse.indexOf(\":\");\n    String prefix = \"\";\n    if (prefixIndex != -1) {\n        prefix = pathToUse.substring(0, prefixIndex + 1);\n        pathToUse = pathToUse.substring(prefixIndex + 1);\n    }\n    if (pathToUse.startsWith(StringUtils.FOLDER_SEPARATOR)) {\n        prefix = prefix + StringUtils.FOLDER_SEPARATOR;\n        pathToUse = pathToUse.substring(1);\n    }\n    final String[] pathArray = StringUtils.delimitedListToStringArray(pathToUse, StringUtils.FOLDER_SEPARATOR);\n    final List<String> pathElements = new LinkedList<String>();\n    int tops = 0;\n    for (int i = pathArray.length - 1; i >= 0; i--) {\n        final String element = pathArray[i];\n        if (StringUtils.CURRENT_PATH.equals(element)) {\n            // Points to current directory - drop it.\n        } else if (StringUtils.TOP_PATH.equals(element)) {\n            // Registering top path found.\n            tops++;\n        } else {\n            if (tops > 0) {\n                // Merging path element with element corresponding to top path.\n                tops--;\n            } else {\n                // Normal path element found.\n                pathElements.add(0, element);\n            }\n        }\n    }\n    // Remaining top paths need to be retained.\n    for (int i = 0; i < tops; i++) {\n        pathElements.add(0, StringUtils.TOP_PATH);\n    }\n    return prefix + StringUtils.collectionToDelimitedString(pathElements, StringUtils.FOLDER_SEPARATOR);\n}", "repo_id": "1", "comment": "/**\n * Normalize the path by suppressing sequences like \"path/..\" and inner simple dots.\n * <p>\n * The result is convenient for path comparison. For other uses, notice that Windows separators (\"\\\") are replaced by simple slashes.\n *\n * @param path\n *            the original path\n * @return the normalized path\n */\n", "repo_name": "BatooJPA-master/", "id": 123, "method_signature": "String cleanPath(String)"}, "StringUtils.collectionToDelimitedString": {"callee_method_names": ["Collection<?>.iterator", "Iterator<?>.hasNext", "StringBuilder.append", "Iterator<?>.next", "Iterator<?>.hasNext", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StringUtils.collectionToDelimitedString", "method_implementation": "{\n    if (CollectionUtils.isEmpty(coll)) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder();\n    final Iterator<?> it = coll.iterator();\n    while (it.hasNext()) {\n        sb.append(prefix).append(it.next()).append(suffix);\n        if (it.hasNext()) {\n            sb.append(delim);\n        }\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Convenience method to return a Collection as a delimited (e.g. CSV) String. E.g. useful for <code>toString()</code> implementations.\n *\n * @param coll\n *            the Collection to display\n * @param delim\n *            the delimiter to use (probably a \",\")\n * @param prefix\n *            the String to start each element with\n * @param suffix\n *            the String to end each element with\n * @return the delimited String\n */\n", "repo_name": "BatooJPA-master/", "id": 124, "method_signature": "String collectionToDelimitedString(Collection, String, String, String)"}, "StringUtils.commaDelimitedListToSet": {"callee_method_names": ["Set<String>.add"], "method_name": "StringUtils.commaDelimitedListToSet", "method_implementation": "{\n    final Set<String> set = new TreeSet<String>();\n    final String[] tokens = StringUtils.commaDelimitedListToStringArray(str);\n    for (final String token : tokens) {\n        set.add(token);\n    }\n    return set;\n}", "repo_id": "1", "comment": "/**\n * Convenience method to convert a CSV string list to a set. Note that this will suppress duplicates.\n *\n * @param str\n *            the input String\n * @return a Set of String entries in the list\n */\n", "repo_name": "BatooJPA-master/", "id": 125, "method_signature": "Set<String> commaDelimitedListToSet(String)"}, "StringUtils.concatenateStringArrays": {"callee_method_names": [], "method_name": "StringUtils.concatenateStringArrays", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array1)) {\n        return array2;\n    }\n    if (ObjectUtils.isEmpty(array2)) {\n        return array1;\n    }\n    final String[] newArr = new String[array1.length + array2.length];\n    System.arraycopy(array1, 0, newArr, 0, array1.length);\n    System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n    return newArr;\n}", "repo_id": "1", "comment": "/**\n * Concatenate the given String arrays into one, with overlapping array elements included twice.\n * <p>\n * The order of elements in the original arrays is preserved.\n *\n * @param array1\n *            the first array (can be <code>null</code>)\n * @param array2\n *            the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n", "repo_name": "BatooJPA-master/", "id": 126, "method_signature": "String[] concatenateStringArrays(String[], String[])"}, "StringUtils.containsWhitespace": {"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.containsWhitespace", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return false;\n    }\n    final int strLen = str.length();\n    for (int i = 0; i < strLen; i++) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Check whether the given CharSequence contains any whitespace characters.\n *\n * @param str\n *            the CharSequence to check (may be <code>null</code>)\n * @return <code>true</code> if the CharSequence is not empty and contains at least 1 whitespace character\n * @see java.lang.Character#isWhitespace\n */\n", "repo_name": "BatooJPA-master/", "id": 127, "method_signature": "boolean containsWhitespace(CharSequence)"}, "StringUtils.countOccurrencesOf": {"callee_method_names": ["String.length", "String.length", "String.indexOf", "String.length"], "method_name": "StringUtils.countOccurrencesOf", "method_implementation": "{\n    if ((str == null) || (sub == null) || (str.length() == 0) || (sub.length() == 0)) {\n        return 0;\n    }\n    int count = 0;\n    int pos = 0;\n    int idx;\n    while ((idx = str.indexOf(sub, pos)) != -1) {\n        ++count;\n        pos = idx + sub.length();\n    }\n    return count;\n}", "repo_id": "1", "comment": "/**\n * Count the occurrences of the substring in string s.\n *\n * @param str\n *            string to search in. Return 0 if this is null.\n * @param sub\n *            string to search for. Return 0 if this is null.\n * @return the count\n */\n", "repo_name": "BatooJPA-master/", "id": 128, "method_signature": "int countOccurrencesOf(String, String)"}, "StringUtils.deleteAny": {"callee_method_names": ["String.length", "String.charAt", "String.indexOf", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StringUtils.deleteAny", "method_implementation": "{\n    if (!StringUtils.hasLength(inString) || !StringUtils.hasLength(charsToDelete)) {\n        return inString;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < inString.length(); i++) {\n        final char c = inString.charAt(i);\n        if (charsToDelete.indexOf(c) == -1) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Delete any character in a given String.\n *\n * @param inString\n *            the original String\n * @param charsToDelete\n *            a set of characters to delete. E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n * @return the resulting String\n */\n", "repo_name": "BatooJPA-master/", "id": 129, "method_signature": "String deleteAny(String, String)"}, "StringUtils.delimitedListToStringArray": {"callee_method_names": ["String.length", "List<String>.add", "String.substring", "String.indexOf", "List<String>.add", "String.substring", "String.length", "String.length", "String.length", "List<String>.add", "String.substring"], "method_name": "StringUtils.delimitedListToStringArray", "method_implementation": "{\n    if (str == null) {\n        return new String[0];\n    }\n    if (delimiter == null) {\n        return new String[] { str };\n    }\n    final List<String> result = new ArrayList<String>();\n    if (\"\".equals(delimiter)) {\n        for (int i = 0; i < str.length(); i++) {\n            result.add(StringUtils.deleteAny(str.substring(i, i + 1), charsToDelete));\n        }\n    } else {\n        int pos = 0;\n        int delPos;\n        while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n            result.add(StringUtils.deleteAny(str.substring(pos, delPos), charsToDelete));\n            pos = delPos + delimiter.length();\n        }\n        if ((str.length() > 0) && (pos <= str.length())) {\n            // Add rest of String, but not in case of empty input.\n            result.add(StringUtils.deleteAny(str.substring(pos), charsToDelete));\n        }\n    }\n    return StringUtils.toStringArray(result);\n}", "repo_id": "1", "comment": "/**\n * Take a String which is a delimited list and convert it to a String array.\n * <p>\n * A single delimiter can consists of more than one character: It will still be considered as single delimiter string, rather than as\n * bunch of potential delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n *\n * @param str\n *            the input String\n * @param delimiter\n *            the delimiter between elements (this is a single delimiter, rather than a bunch individual delimiter characters)\n * @param charsToDelete\n *            a set of characters to delete. Useful for deleting unwanted line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line\n *            feeds in a String.\n * @return an array of the tokens in the list\n * @see #tokenizeToStringArray\n */\n", "repo_name": "BatooJPA-master/", "id": 130, "method_signature": "String[] delimitedListToStringArray(String, String, String)"}, "StringUtils.endsWithIgnoreCase": {"callee_method_names": ["String.endsWith", "String.length", "String.length", "String.substring", "String.length", "String.length", "String.toLowerCase", "String.equals"], "method_name": "StringUtils.endsWithIgnoreCase", "method_implementation": "{\n    if ((str == null) || (suffix == null)) {\n        return false;\n    }\n    if (str.endsWith(suffix)) {\n        return true;\n    }\n    if (str.length() < suffix.length()) {\n        return false;\n    }\n    final String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n    final String lcSuffix = suffix.toLowerCase();\n    return lcStr.equals(lcSuffix);\n}", "repo_id": "1", "comment": "/**\n * Test if the given String ends with the specified suffix, ignoring upper/lower case.\n *\n * @param str\n *            the String to check\n * @param suffix\n *            the suffix to look for\n * @return <code>true</code> if given String ends with the specified suffix, <code>false</code> otherwise\n * @see java.lang.String#endsWith\n */\n", "repo_name": "BatooJPA-master/", "id": 131, "method_signature": "boolean endsWithIgnoreCase(String, String)"}, "StringUtils.getFilename": {"callee_method_names": ["String.lastIndexOf", "String.substring"], "method_name": "StringUtils.getFilename", "method_implementation": "{\n    if (path == null) {\n        return null;\n    }\n    final int separatorIndex = path.lastIndexOf(StringUtils.FOLDER_SEPARATOR);\n    return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n}", "repo_id": "1", "comment": "/**\n * Extract the filename from the given path, e.g. \"mypath/myfile.txt\" -> \"myfile.txt\".\n *\n * @param path\n *            the file path (may be <code>null</code>)\n * @return the extracted filename, or <code>null</code> if none\n */\n", "repo_name": "BatooJPA-master/", "id": 132, "method_signature": "String getFilename(String)"}, "StringUtils.getFilenameExtension": {"callee_method_names": ["String.lastIndexOf", "String.lastIndexOf", "String.substring"], "method_name": "StringUtils.getFilenameExtension", "method_implementation": "{\n    if (path == null) {\n        return null;\n    }\n    final int extIndex = path.lastIndexOf(StringUtils.EXTENSION_SEPARATOR);\n    if (extIndex == -1) {\n        return null;\n    }\n    final int folderIndex = path.lastIndexOf(StringUtils.FOLDER_SEPARATOR);\n    if (folderIndex > extIndex) {\n        return null;\n    }\n    return path.substring(extIndex + 1);\n}", "repo_id": "1", "comment": "/**\n * Extract the filename extension from the given path, e.g. \"mypath/myfile.txt\" -> \"txt\".\n *\n * @param path\n *            the file path (may be <code>null</code>)\n * @return the extracted filename extension, or <code>null</code> if none\n */\n", "repo_name": "BatooJPA-master/", "id": 133, "method_signature": "String getFilenameExtension(String)"}, "StringUtils.hasText": {"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "StringUtils.hasText", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return false;\n    }\n    final int strLen = str.length();\n    for (int i = 0; i < strLen; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "1", "comment": "/**\n * Check whether the given CharSequence has actual text. More specifically, returns <code>true</code> if the string not\n * <code>null</code>, its length is greater than 0, and it contains at least one non-whitespace character.\n * <p>\n *\n * <pre>\n * StringUtils.hasText(null) = false\n * StringUtils.hasText(\"\") = false\n * StringUtils.hasText(\" \") = false\n * StringUtils.hasText(\"12345\") = true\n * StringUtils.hasText(\" 12345 \") = true\n * </pre>\n *\n * @param str\n *            the CharSequence to check (may be <code>null</code>)\n * @return <code>true</code> if the CharSequence is not <code>null</code>, its length is greater than 0, and it does not contain\n *         whitespace only\n * @see java.lang.Character#isWhitespace\n */\n", "repo_name": "BatooJPA-master/", "id": 134, "method_signature": "boolean hasText(CharSequence)"}, "StringUtils.isBlank": {"callee_method_names": ["String.length", "String.charAt"], "method_name": "StringUtils.isBlank", "method_implementation": "{\n    int strLen;\n    if ((str == null) || ((strLen = str.length()) == 0)) {\n        return true;\n    }\n    for (int i = 0; i < strLen; i++) {\n        if ((Character.isWhitespace(str.charAt(i)) == false)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * <p>\n * Checks if a String is whitespace, empty (\"\") or null.\n * </p>\n *\n * <pre>\n * StringUtils.isBlank(null)      = true\n * StringUtils.isBlank(\"\")        = true\n * StringUtils.isBlank(\" \")       = true\n * StringUtils.isBlank(\"bob\")     = false\n * StringUtils.isBlank(\"  bob  \") = false\n * </pre>\n *\n * @param str\n *            the String to check, may be null\n * @return <code>true</code> if the String is null, empty or whitespace\n * @since 2.0\n */\n", "repo_name": "BatooJPA-master/", "id": 135, "method_signature": "boolean isBlank(String)"}, "StringUtils.mergeStringArrays": {"callee_method_names": ["List<String>.addAll", "List<String>.contains", "List<String>.add"], "method_name": "StringUtils.mergeStringArrays", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array1)) {\n        return array2;\n    }\n    if (ObjectUtils.isEmpty(array2)) {\n        return array1;\n    }\n    final List<String> result = new ArrayList<String>();\n    result.addAll(Arrays.asList(array1));\n    for (final String str : array2) {\n        if (!result.contains(str)) {\n            result.add(str);\n        }\n    }\n    return StringUtils.toStringArray(result);\n}", "repo_id": "1", "comment": "/**\n * Merge the given String arrays into one, with overlapping array elements only included once.\n * <p>\n * The order of elements in the original arrays is preserved (with the exception of overlapping elements, which are only included on\n * their first occurrence).\n *\n * @param array1\n *            the first array (can be <code>null</code>)\n * @param array2\n *            the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n", "repo_name": "BatooJPA-master/", "id": 136, "method_signature": "String[] mergeStringArrays(String[], String[])"}, "StringUtils.parseLocaleString": {"callee_method_names": ["String.lastIndexOf", "String.length", "String.substring", "String.startsWith", "String.length"], "method_name": "StringUtils.parseLocaleString", "method_implementation": "{\n    final String[] parts = StringUtils.tokenizeToStringArray(localeString, \"_ \", false, false);\n    final String language = (parts.length > 0 ? parts[0] : \"\");\n    final String country = (parts.length > 1 ? parts[1] : \"\");\n    StringUtils.validateLocalePart(language);\n    StringUtils.validateLocalePart(country);\n    String variant = \"\";\n    if (parts.length >= 2) {\n        // There is definitely a variant, and it is everything after the country\n        // code sans the separator between the country code and the variant.\n        final int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length();\n        // Strip off any leading '_' and whitespace, what's left is the variant.\n        variant = StringUtils.trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n        if (variant.startsWith(\"_\")) {\n            variant = StringUtils.trimLeadingCharacter(variant, '_');\n        }\n    }\n    return (language.length() > 0 ? new Locale(language, country, variant) : null);\n}", "repo_id": "1", "comment": "/**\n * Parse the given <code>localeString</code> value into a {@link Locale}.\n * <p>\n * This is the inverse operation of {@link Locale#toString Locale's toString}.\n *\n * @param localeString\n *            the locale string, following <code>Locale's</code> <code>toString()</code> format (\"en\", \"en_UK\", etc); also accepts\n *            spaces as separators, as an alternative to underscores\n * @return a corresponding <code>Locale</code> instance\n */\n", "repo_name": "BatooJPA-master/", "id": 137, "method_signature": "Locale parseLocaleString(String)"}, "StringUtils.removeDuplicateStrings": {"callee_method_names": ["Set<String>.add"], "method_name": "StringUtils.removeDuplicateStrings", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array)) {\n        return array;\n    }\n    final Set<String> set = new TreeSet<String>();\n    for (final String element : array) {\n        set.add(element);\n    }\n    return StringUtils.toStringArray(set);\n}", "repo_id": "1", "comment": "/**\n * Remove duplicate Strings from the given array. Also sorts the array, as it uses a TreeSet.\n *\n * @param array\n *            the String array\n * @return an array without duplicates, in natural sort order\n */\n", "repo_name": "BatooJPA-master/", "id": 138, "method_signature": "String[] removeDuplicateStrings(String[])"}, "StringUtils.replace": {"callee_method_names": ["String.indexOf", "String.length", "StringBuilder.append", "String.substring", "StringBuilder.append", "String.indexOf", "StringBuilder.append", "String.substring", "StringBuilder.toString"], "method_name": "StringUtils.replace", "method_implementation": "{\n    if (!StringUtils.hasLength(inString) || !StringUtils.hasLength(oldPattern) || (newPattern == null)) {\n        return inString;\n    }\n    final StringBuilder sb = new StringBuilder();\n    // our position in the old string\n    int pos = 0;\n    int index = inString.indexOf(oldPattern);\n    // the index of an occurrence we've found, or -1\n    final int patLen = oldPattern.length();\n    while (index >= 0) {\n        sb.append(inString.substring(pos, index));\n        sb.append(newPattern);\n        pos = index + patLen;\n        index = inString.indexOf(oldPattern, pos);\n    }\n    sb.append(inString.substring(pos));\n    // remember to append any characters to the right of a match\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Replace all occurences of a substring within a string with another string.\n *\n * @param inString\n *            String to examine\n * @param oldPattern\n *            String to replace\n * @param newPattern\n *            String to insert\n * @return a String with the replacements\n */\n", "repo_name": "BatooJPA-master/", "id": 139, "method_signature": "String replace(String, String, String)"}, "StringUtils.sortStringArray": {"callee_method_names": [], "method_name": "StringUtils.sortStringArray", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array)) {\n        return new String[0];\n    }\n    Arrays.sort(array);\n    return array;\n}", "repo_id": "1", "comment": "/**\n * Turn given source String array into sorted array.\n *\n * @param array\n *            the source array\n * @return the sorted array (never <code>null</code>)\n */\n", "repo_name": "BatooJPA-master/", "id": 140, "method_signature": "String[] sortStringArray(String[])"}, "StringUtils.split": {"callee_method_names": ["String.indexOf", "String.substring", "String.substring", "String.length"], "method_name": "StringUtils.split", "method_implementation": "{\n    if (!StringUtils.hasLength(toSplit) || !StringUtils.hasLength(delimiter)) {\n        return null;\n    }\n    final int offset = toSplit.indexOf(delimiter);\n    if (offset < 0) {\n        return null;\n    }\n    final String beforeDelimiter = toSplit.substring(0, offset);\n    final String afterDelimiter = toSplit.substring(offset + delimiter.length());\n    return new String[] { beforeDelimiter, afterDelimiter };\n}", "repo_id": "1", "comment": "/**\n * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.\n *\n * @param toSplit\n *            the string to split\n * @param delimiter\n *            to split the string up with\n * @return a two element array with index 0 being before the delimiter, and index 1 being after the delimiter (neither element includes\n *         the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String\n */\n", "repo_name": "BatooJPA-master/", "id": 141, "method_signature": "String[] split(String, String)"}, "StringUtils.splitArrayElementsIntoProperties": {"callee_method_names": ["Properties.setProperty", "String[].trim", "String[].trim"], "method_name": "StringUtils.splitArrayElementsIntoProperties", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array)) {\n        return null;\n    }\n    final Properties result = new Properties();\n    for (String element : array) {\n        if (charsToDelete != null) {\n            element = StringUtils.deleteAny(element, charsToDelete);\n        }\n        final String[] splittedElement = StringUtils.split(element, delimiter);\n        if (splittedElement == null) {\n            continue;\n        }\n        result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n    }\n    return result;\n}", "repo_id": "1", "comment": "/**\n * Take an array Strings and split each element based on the given delimiter. A <code>Properties</code> instance is then generated, with\n * the left of the delimiter providing the key, and the right of the delimiter providing the value.\n * <p>\n * Will trim both the key and value before adding them to the <code>Properties</code> instance.\n *\n * @param array\n *            the array to process\n * @param delimiter\n *            to split each element using (typically the equals symbol)\n * @param charsToDelete\n *            one or more characters to remove from each element prior to attempting the split operation (typically the quotation mark\n *            symbol), or <code>null</code> if no removal should occur\n * @return a <code>Properties</code> instance representing the array contents, or <code>null</code> if the array to process was\n *         <code>null</code> or empty\n */\n", "repo_name": "BatooJPA-master/", "id": 142, "method_signature": "Properties splitArrayElementsIntoProperties(String[], String, String)"}, "StringUtils.startsWithIgnoreCase": {"callee_method_names": ["String.startsWith", "String.length", "String.length", "String.substring", "String.length", "String.toLowerCase", "String.equals"], "method_name": "StringUtils.startsWithIgnoreCase", "method_implementation": "{\n    if ((str == null) || (prefix == null)) {\n        return false;\n    }\n    if (str.startsWith(prefix)) {\n        return true;\n    }\n    if (str.length() < prefix.length()) {\n        return false;\n    }\n    final String lcStr = str.substring(0, prefix.length()).toLowerCase();\n    final String lcPrefix = prefix.toLowerCase();\n    return lcStr.equals(lcPrefix);\n}", "repo_id": "1", "comment": "/**\n * Test if the given String starts with the specified prefix, ignoring upper/lower case.\n *\n * @param str\n *            the String to check\n * @param prefix\n *            the prefix to look for\n * @return <code>true</code> if given String starts with the specified suffix, <code>false</code> otherwise\n * @see java.lang.String#startsWith\n */\n", "repo_name": "BatooJPA-master/", "id": 143, "method_signature": "boolean startsWithIgnoreCase(String, String)"}, "StringUtils.stripFilenameExtension": {"callee_method_names": ["String.lastIndexOf", "String.lastIndexOf", "String.substring"], "method_name": "StringUtils.stripFilenameExtension", "method_implementation": "{\n    if (path == null) {\n        return null;\n    }\n    final int extIndex = path.lastIndexOf(StringUtils.EXTENSION_SEPARATOR);\n    if (extIndex == -1) {\n        return path;\n    }\n    final int folderIndex = path.lastIndexOf(StringUtils.FOLDER_SEPARATOR);\n    if (folderIndex > extIndex) {\n        return path;\n    }\n    return path.substring(0, extIndex);\n}", "repo_id": "1", "comment": "/**\n * Strip the filename extension from the given path, e.g. \"mypath/myfile.txt\" -> \"mypath/myfile\".\n *\n * @param path\n *            the file path (may be <code>null</code>)\n * @return the path with stripped filename extension, or <code>null</code> if none\n */\n", "repo_name": "BatooJPA-master/", "id": 144, "method_signature": "String stripFilenameExtension(String)"}, "StringUtils.substringMatch": {"callee_method_names": ["CharSequence.length", "CharSequence.length", "CharSequence.charAt", "CharSequence.charAt"], "method_name": "StringUtils.substringMatch", "method_implementation": "{\n    for (int j = 0; j < substring.length(); j++) {\n        final int i = index + j;\n        if ((i >= str.length()) || (str.charAt(i) != substring.charAt(j))) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "1", "comment": "/**\n * Test whether the given string matches the given substring at the given index.\n *\n * @param str\n *            the original string (or StringBuilder)\n * @param index\n *            the index in the original string to start matching against\n * @param substring\n *            the substring to match at the given index\n * @return <code>true</code> if the given string matches the given substring at the given index, <code>false</code> otherwise\n */\n", "repo_name": "BatooJPA-master/", "id": 145, "method_signature": "boolean substringMatch(CharSequence, int, CharSequence)"}, "StringUtils.toStringArray": {"callee_method_names": ["List<String>.toArray", "List<String>.size"], "method_name": "StringUtils.toStringArray", "method_implementation": "{\n    if (enumeration == null) {\n        return null;\n    }\n    final List<String> list = Collections.list(enumeration);\n    return list.toArray(new String[list.size()]);\n}", "repo_id": "1", "comment": "/**\n * Copy the given Enumeration into a String array. The Enumeration must contain String elements only.\n *\n * @param enumeration\n *            the Enumeration to copy\n * @return the String array (<code>null</code> if the passed-in Enumeration was <code>null</code>)\n */\n", "repo_name": "BatooJPA-master/", "id": 148, "method_signature": "String[] toStringArray(Enumeration)"}, "StringUtils.tokenizeToStringArray": {"callee_method_names": ["StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "String.trim", "String.length", "List<String>.add"], "method_name": "StringUtils.tokenizeToStringArray", "method_implementation": "{\n    if (str == null) {\n        return null;\n    }\n    final StringTokenizer st = new StringTokenizer(str, delimiters);\n    final List<String> tokens = new ArrayList<String>();\n    while (st.hasMoreTokens()) {\n        String token = st.nextToken();\n        if (trimTokens) {\n            token = token.trim();\n        }\n        if (!ignoreEmptyTokens || (token.length() > 0)) {\n            tokens.add(token);\n        }\n    }\n    return StringUtils.toStringArray(tokens);\n}", "repo_id": "1", "comment": "/**\n * Tokenize the given String into a String array via a StringTokenizer.\n * <p>\n * The given delimiters string is supposed to consist of any number of delimiter characters. Each of those characters can be used to\n * separate tokens. A delimiter is always a single character; for multi-character delimiters, consider using\n * <code>delimitedListToStringArray</code>\n *\n * @param str\n *            the String to tokenize\n * @param delimiters\n *            the delimiter characters, assembled as String (each of those characters is individually considered as delimiter)\n * @param trimTokens\n *            trim the tokens via String's <code>trim</code>\n * @param ignoreEmptyTokens\n *            omit empty tokens from the result array (only applies to tokens that are empty after trimming; StringTokenizer will not\n *            consider subsequent delimiters as token in the first place).\n * @return an array of the tokens (<code>null</code> if the input String was <code>null</code>)\n * @see java.util.StringTokenizer\n * @see java.lang.String#trim()\n * @see #delimitedListToStringArray\n */\n", "repo_name": "BatooJPA-master/", "id": 146, "method_signature": "String[] tokenizeToStringArray(String, String, boolean, boolean)"}, "StringUtils.trimAllWhitespace": {"callee_method_names": ["StringBuilder.length", "StringBuilder.charAt", "StringBuilder.deleteCharAt", "StringBuilder.toString"], "method_name": "StringUtils.trimAllWhitespace", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str);\n    int index = 0;\n    while (sb.length() > index) {\n        if (Character.isWhitespace(sb.charAt(index))) {\n            sb.deleteCharAt(index);\n        } else {\n            index++;\n        }\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Trim <i>all</i> whitespace from the given String: leading, trailing, and inbetween characters.\n *\n * @param str\n *            the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "repo_name": "BatooJPA-master/", "id": 149, "method_signature": "String trimAllWhitespace(String)"}, "StringUtils.trimArrayElements": {"callee_method_names": ["String.trim"], "method_name": "StringUtils.trimArrayElements", "method_implementation": "{\n    if (ObjectUtils.isEmpty(array)) {\n        return new String[0];\n    }\n    final String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final String element = array[i];\n        result[i] = (element != null ? element.trim() : null);\n    }\n    return result;\n}", "repo_id": "1", "comment": "/**\n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n *\n * @param array\n *            the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n", "repo_name": "BatooJPA-master/", "id": 150, "method_signature": "String[] trimArrayElements(String[])"}, "StringUtils.trimLeadingCharacter": {"callee_method_names": ["StringBuilder.length", "StringBuilder.charAt", "StringBuilder.deleteCharAt", "StringBuilder.toString"], "method_name": "StringUtils.trimLeadingCharacter", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str);\n    while ((sb.length() > 0) && (sb.charAt(0) == leadingCharacter)) {\n        sb.deleteCharAt(0);\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Trim all occurences of the supplied leading character from the given String.\n *\n * @param str\n *            the String to check\n * @param leadingCharacter\n *            the leading character to be trimmed\n * @return the trimmed String\n */\n", "repo_name": "BatooJPA-master/", "id": 151, "method_signature": "String trimLeadingCharacter(String, char)"}, "StringUtils.trimLeadingWhitespace": {"callee_method_names": ["StringBuilder.length", "StringBuilder.charAt", "StringBuilder.deleteCharAt", "StringBuilder.toString"], "method_name": "StringUtils.trimLeadingWhitespace", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str);\n    while ((sb.length() > 0) && Character.isWhitespace(sb.charAt(0))) {\n        sb.deleteCharAt(0);\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Trim leading whitespace from the given String.\n *\n * @param str\n *            the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "repo_name": "BatooJPA-master/", "id": 152, "method_signature": "String trimLeadingWhitespace(String)"}, "StringUtils.trimTrailingCharacter": {"callee_method_names": ["StringBuilder.length", "StringBuilder.charAt", "StringBuilder.length", "StringBuilder.deleteCharAt", "StringBuilder.length", "StringBuilder.toString"], "method_name": "StringUtils.trimTrailingCharacter", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str);\n    while ((sb.length() > 0) && (sb.charAt(sb.length() - 1) == trailingCharacter)) {\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Trim all occurences of the supplied trailing character from the given String.\n *\n * @param str\n *            the String to check\n * @param trailingCharacter\n *            the trailing character to be trimmed\n * @return the trimmed String\n */\n", "repo_name": "BatooJPA-master/", "id": 153, "method_signature": "String trimTrailingCharacter(String, char)"}, "StringUtils.trimTrailingWhitespace": {"callee_method_names": ["StringBuilder.length", "StringBuilder.charAt", "StringBuilder.length", "StringBuilder.deleteCharAt", "StringBuilder.length", "StringBuilder.toString"], "method_name": "StringUtils.trimTrailingWhitespace", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str);\n    while ((sb.length() > 0) && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Trim trailing whitespace from the given String.\n *\n * @param str\n *            the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "repo_name": "BatooJPA-master/", "id": 154, "method_signature": "String trimTrailingWhitespace(String)"}, "StringUtils.trimWhitespace": {"callee_method_names": ["StringBuilder.length", "StringBuilder.charAt", "StringBuilder.deleteCharAt", "StringBuilder.length", "StringBuilder.charAt", "StringBuilder.length", "StringBuilder.deleteCharAt", "StringBuilder.length", "StringBuilder.toString"], "method_name": "StringUtils.trimWhitespace", "method_implementation": "{\n    if (!StringUtils.hasLength(str)) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str);\n    while ((sb.length() > 0) && Character.isWhitespace(sb.charAt(0))) {\n        sb.deleteCharAt(0);\n    }\n    while ((sb.length() > 0) && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    return sb.toString();\n}", "repo_id": "1", "comment": "/**\n * Trim leading and trailing whitespace from the given String.\n *\n * @param str\n *            the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "repo_name": "BatooJPA-master/", "id": 155, "method_signature": "String trimWhitespace(String)"}, "SubQueryJpqlTest.testAllAnySome": {"callee_method_names": ["Employee.getId", "TypedQuery<Integer>.getSingleResult", "TypedQuery<String>.getResultList"], "method_name": "SubQueryJpqlTest.testAllAnySome", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    final Department rnd = new Department(\"RND\");\n    this.persist(qa);\n    this.persist(rnd);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager rndManager = new Manager(\"Manager2\", rnd, 100000);\n    final Manager qaManager2 = new Manager(\"Manager3\", qa, 80000);\n    this.persist(rndManager);\n    this.persist(qaManager);\n    this.persist(qaManager2);\n    final Employee employee1 = new Employee(\"Employee1\", rndManager, rnd, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", rndManager, rnd, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    final Employee employee3 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee4 = new Employee(\"Employee2\", qaManager, qa, 110000);\n    final Employee employee5 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee6 = new Employee(\"Employee2\", qaManager, qa, 90000);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(employee5);\n    this.persist(employee6);\n    this.commit();\n    final TypedQuery<Integer> q;\n    final TypedQuery<String> q2;\n    q = this.cq(\"select e.id from Employee e where e.salary > all (select m.salary from Manager m where m.department = e.department)\", Integer.class);\n    Assert.assertEquals(employee4.getId(), q.getSingleResult());\n    q2 = this.cq(\"select e.name from Employee e where e.salary > any (select m.salary from Manager m where m.department = e.department)\", String.class);\n    Assert.assertEquals(4, q2.getResultList().size());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2406, "method_signature": "void testAllAnySome()"}, "SubQueryJpqlTest.testEmpty": {"callee_method_names": ["Manager.getId", "TypedQuery<Integer>.getSingleResult", "Manager.getId", "TypedQuery<Integer>.getSingleResult"], "method_name": "SubQueryJpqlTest.testEmpty", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    this.persist(qa);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager qaManager2 = new Manager(\"Manager2\", qa, 100000);\n    this.persist(qaManager);\n    this.persist(qaManager2);\n    final Employee employee1 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", qaManager, qa, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    this.commit();\n    this.close();\n    TypedQuery<Integer> q;\n    q = this.cq(\"select m.id from Manager m where m.employees is empty\", Integer.class);\n    Assert.assertEquals(qaManager2.getId(), q.getSingleResult());\n    q = this.cq(\"select m.id from Manager m where m.employees is not empty\", Integer.class);\n    Assert.assertEquals(qaManager.getId(), q.getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2407, "method_signature": "void testEmpty()"}, "SubQueryJpqlTest.testExists": {"callee_method_ids": [2367, 2367, 2367], "callee_method_names": ["Employee.setName", "Employee.setName", "Employee.setName", "Employee.setName", "Manager.setName", "Manager.setName", "Employee.setManager", "Employee.setManager", "Employee.setManager", "TypedQuery<Integer>.getResultList", "TypedQuery<Integer>.getResultList"], "method_name": "SubQueryJpqlTest.testExists", "method_implementation": "{\n    final Employee employee1 = new Employee();\n    employee1.setName(\"Employee1\");\n    final Employee employee2 = new Employee();\n    employee2.setName(\"Employee2\");\n    final Employee employee3 = new Employee();\n    employee3.setName(\"Employee3\");\n    final Employee employee4 = new Employee();\n    employee4.setName(\"Employee4\");\n    final Manager manager1 = new Manager();\n    manager1.setName(\"Manager1\");\n    final Manager manager2 = new Manager();\n    manager2.setName(\"Manager2\");\n    employee1.setManager(manager1);\n    employee2.setManager(manager1);\n    employee4.setManager(manager2);\n    this.persist(employee1);\n    this.persist(employee2);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(manager1);\n    this.persist(manager2);\n    this.commit();\n    TypedQuery<Integer> q;\n    q = this.cq(\"select e.id from Employee e where exists (select m.id from Manager m where e.manager = m) order by e.id\", Integer.class);\n    Assert.assertEquals(\"[1, 2, 4]\", q.getResultList().toString());\n    q = this.cq(\"select e.id from Employee e where not exists (select m.id from Manager m where e.manager = m)\", Integer.class);\n    Assert.assertEquals(\"[3]\", q.getResultList().toString());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2408, "method_signature": "void testExists()"}, "SubQueryJpqlTest.testMemberOf": {"callee_method_names": ["TypedQuery<Integer>.getSingleResult"], "method_name": "SubQueryJpqlTest.testMemberOf", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    final Department rnd = new Department(\"RND\");\n    this.persist(qa);\n    this.persist(rnd);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager rndManager = new Manager(\"Manager2\", rnd, 100000);\n    this.persist(rndManager);\n    this.persist(qaManager);\n    final Employee employee1 = new Employee(\"Employee1\", rndManager, rnd, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", rndManager, rnd, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    final Employee employee3 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee4 = new Employee(\"Employee2\", qaManager, qa, 110000);\n    final Employee employee5 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee6 = new Employee(\"Employee2\", null, qa, 90000);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(employee5);\n    this.persist(employee6);\n    this.commit();\n    TypedQuery<Integer> q;\n    q = this.cq(\"select m.id from Manager m where :p member of m.employees\", Integer.class).setParameter(\"p\", employee1);\n    Assert.assertEquals((Integer) 3, q.getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2409, "method_signature": "void testMemberOf()"}, "SubQueryJpqlTest.testSize": {"callee_method_ids": [2367, 2367, 2367], "callee_method_names": ["Employee.setName", "Employee.setName", "Employee.setName", "Employee.setName", "Manager.setName", "Manager.setName", "Employee.setManager", "Employee.setManager", "Employee.setManager"], "method_name": "SubQueryJpqlTest.testSize", "method_implementation": "{\n    final Employee employee1 = new Employee();\n    employee1.setName(\"Employee1\");\n    final Employee employee2 = new Employee();\n    employee2.setName(\"Employee2\");\n    final Employee employee3 = new Employee();\n    employee3.setName(\"Employee3\");\n    final Employee employee4 = new Employee();\n    employee4.setName(\"Employee4\");\n    final Manager manager1 = new Manager();\n    manager1.setName(\"Manager1\");\n    final Manager manager2 = new Manager();\n    manager2.setName(\"Manager2\");\n    employee1.setManager(manager1);\n    employee2.setManager(manager1);\n    employee4.setManager(manager2);\n    this.persist(employee1);\n    this.persist(employee2);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(manager1);\n    this.persist(manager2);\n    this.commit();\n    Assert.assertEquals((Integer) 2, this.cq(\"select size(m.employees) from Manager m where size(m.employees) = 2\", Integer.class).getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2410, "method_signature": "void testSize()"}, "SubQueryJpqlTest.testSubQuery": {"callee_method_names": ["Employee.getId", "TypedQuery<Number>.getSingleResult"], "method_name": "SubQueryJpqlTest.testSubQuery", "method_implementation": "{\n    final Department qa = new Department(\"QA\");\n    final Department rnd = new Department(\"RND\");\n    this.persist(qa);\n    this.persist(rnd);\n    final Manager qaManager = new Manager(\"Manager1\", qa, 100000);\n    final Manager rndManager = new Manager(\"Manager2\", rnd, 100000);\n    this.persist(rndManager);\n    this.persist(qaManager);\n    final Employee employee1 = new Employee(\"Employee1\", rndManager, rnd, 90000);\n    final Employee employee2 = new Employee(\"Employee2\", rndManager, rnd, 100000);\n    this.persist(employee1);\n    this.persist(employee2);\n    final Employee employee3 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee4 = new Employee(\"Employee2\", qaManager, qa, 110000);\n    final Employee employee5 = new Employee(\"Employee1\", qaManager, qa, 90000);\n    final Employee employee6 = new Employee(\"Employee2\", qaManager, qa, 90000);\n    this.persist(employee3);\n    this.persist(employee4);\n    this.persist(employee5);\n    this.persist(employee6);\n    this.commit();\n    TypedQuery<Number> q;\n    q = this.cq(\"select e.id from Employee e where e.salary > (select m.salary from Manager m where m.department = e.department)\", Number.class);\n    Assert.assertEquals(employee4.getId(), q.getSingleResult());\n    this.cq(\"select count(e) from Employee e where e.name in (select e.name from Employee e2)\", Number.class).getResultList();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2411, "method_signature": "void testSubQuery()"}, "SubqueryImpl.correlate": {"callee_method_names": [], "method_name": "SubqueryImpl.correlate", "method_implementation": "{\n    if (!this.correlatedJoins.contains(parentSet)) {\n        this.correlatedJoins.add((AbstractFrom<?, ?>) parentSet);\n    }\n    return parentSet;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 725, "method_signature": "SetJoin<X,Y> correlate(SetJoin)"}, "SubqueryImpl.distinct": {"callee_method_names": [], "method_name": "SubqueryImpl.distinct", "method_implementation": "{\n    this.query.distinct(distinct);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 726, "method_signature": "SubqueryImpl<T> distinct(boolean)"}, "SubqueryImpl.getSelection": {"callee_method_names": [], "method_name": "SubqueryImpl.getSelection", "method_implementation": "{\n    return (Expression<T>) this.query.getSelection();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 727, "method_signature": "Expression<T> getSelection()"}, "SubqueryImpl.groupBy": {"callee_method_names": [], "method_name": "SubqueryImpl.groupBy", "method_implementation": "{\n    this.query.groupBy(grouping);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 729, "method_signature": "SubqueryImpl<T> groupBy(List)"}, "SubqueryImpl.having": {"callee_method_names": [], "method_name": "SubqueryImpl.having", "method_implementation": "{\n    this.query.having(restrictions);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 731, "method_signature": "SubqueryImpl<T> having(Predicate[])"}, "SubqueryImpl.select": {"callee_method_names": [], "method_name": "SubqueryImpl.select", "method_implementation": "{\n    this.query.select(expression);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 732, "method_signature": "Subquery<T> select(Expression)"}, "SubqueryImpl.where": {"callee_method_names": [], "method_name": "SubqueryImpl.where", "method_implementation": "{\n    this.query.where(restrictions);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 734, "method_signature": "Subquery<T> where(Predicate[])"}, "SubstringExpression.generateJpqlRestriction": {"callee_method_names": [], "method_name": "SubstringExpression.generateJpqlRestriction", "method_implementation": "{\n    if (this.end == null) {\n        return //\n        \"substring(\" + this.inner.generateJpqlRestriction(query) + \",\" + this.start.generateJpqlRestriction(query) + \")\";\n    }\n    return //\n    \"substring(\" + this.inner.generateJpqlRestriction(query) + \",\" + this.start.generateJpqlRestriction(query) + //\n    \",\" + this.end.generateJpqlRestriction(query) + \")\";\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 614, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "SubstringExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "SubstringExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 615, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "SubstringExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "SubstringExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 616, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "SubstringExpression.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.getJdbcAdaptor"], "method_name": "SubstringExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final String innerFragment = this.inner.getSqlRestrictionFragments(query)[0];\n    final String startFragment = this.start.getSqlRestrictionFragments(query)[0];\n    final String endFragment = this.end != null ? this.end.getSqlRestrictionFragments(query)[0] : null;\n    return new String[] { query.getJdbcAdaptor().applySubStr(innerFragment, startFragment, endFragment) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 617, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "TableElement.generate": {"callee_method_names": [], "method_name": "TableElement.generate", "method_implementation": "{\n    this.catalog = this.getAttribute(ElementConstants.ATTR_CATALOG, ElementConstants.EMPTY);\n    this.schema = this.getAttribute(ElementConstants.ATTR_SCHEMA, ElementConstants.EMPTY);\n    this.name = this.getAttribute(ElementConstants.ATTR_NAME, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1094, "method_signature": "void generate()"}, "TableElement.handleChild": {"callee_method_names": [], "method_name": "TableElement.handleChild", "method_implementation": "{\n    if (child instanceof UniqueConstraintsElement) {\n        this.uniqueConstraints.add((UniqueConstraintMetadata) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1095, "method_signature": "void handleChild(Element)"}, "TableGeneratorElement.generate": {"callee_method_names": [], "method_name": "TableGeneratorElement.generate", "method_implementation": "{\n    super.generate();\n    this.table = this.getAttribute(ElementConstants.ATTR_TABLE, ElementConstants.EMPTY);\n    this.pkColumnName = this.getAttribute(ElementConstants.ATTR_PK_COLUMN_NAME, ElementConstants.EMPTY);\n    this.pkColumnValue = this.getAttribute(ElementConstants.ATTR_PK_COLUMN_VALUE, ElementConstants.EMPTY);\n    this.valueColumnName = this.getAttribute(ElementConstants.ATTR_VALUE_COLUMN_NAME, ElementConstants.EMPTY);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1129, "method_signature": "void generate()"}, "TableGeneratorElement.handleChild": {"callee_method_names": [], "method_name": "TableGeneratorElement.handleChild", "method_implementation": "{\n    if (child instanceof UniqueConstraintsElement) {\n        this.uniqueConstraints.add((UniqueConstraintsElement) child);\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1130, "method_signature": "void handleChild(Element)"}, "TableGeneratorTest.testContains": {"callee_method_names": [], "method_name": "TableGeneratorTest.testContains", "method_implementation": "{\n    final Foo foo = new Foo();\n    final Foo foo2 = new Foo();\n    this.persist(foo);\n    Assert.assertTrue(this.contains(foo));\n    Assert.assertFalse(this.contains(foo2));\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManager#contains(Object)}.\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2154, "method_signature": "void testContains()"}, "TableGeneratorTest.testCreateTables": {"callee_method_names": ["Set<EntityType<?>>.size"], "method_name": "TableGeneratorTest.testCreateTables", "method_implementation": "{\n    final Set<EntityType<?>> entities = this.em().getMetamodel().getEntities();\n    Assert.assertEquals(1, entities.size());\n    final DataSource dataSource = this.em().unwrap(DataSource.class);\n    new QueryRunner(dataSource).query(\"SELECT * FROM Foo\", new NullResultSetHandler());\n}", "repo_id": "1", "comment": "/**\n * Tests {@link EntityManagerFactory#createEntityManager()}\n *\n * @throws SQLException\n *             thrown if SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2155, "method_signature": "void testCreateTables()"}, "TableGeneratorTest.testFind": {"callee_method_names": ["Foo.getId", "Foo.getId", "Foo.getId"], "method_name": "TableGeneratorTest.testFind", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    this.close();\n    final Foo foo2 = this.find(Foo.class, foo.getId());\n    Assert.assertEquals(foo.getId(), foo2.getId());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#find(Class, Object)}\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2156, "method_signature": "void testFind()"}, "TableGeneratorTest.testPersist": {"callee_method_names": [], "method_name": "TableGeneratorTest.testPersist", "method_implementation": "{\n    final Foo foo = new Foo();\n    this.persist(foo);\n    this.commit();\n    Assert.assertEquals(1, new QueryRunner(this.em().unwrap(DataSource.class)).query(\"SELECT COUNT(*) FROM Foo\", new SingleValueHandler<Number>()).intValue());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#persist(Object)}.\n *\n * @throws SQLException\n *             thrown if SQL fails\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2157, "method_signature": "void testPersist()"}, "TableIdQueue.getNextId": {"callee_method_ids": [1156, 1157, 1157], "callee_method_names": ["QueryRunner.query", "QueryRunner.update", "Number.longValue", "QueryRunner.update"], "method_name": "TableIdQueue.getNextId", "method_implementation": "{\n    final QueryRunner runner = new QueryRunner(this.datasource, this.jdbcAdaptor.isPmdBroken());\n    final Number nextId = runner.query(this.getSelectSql(), new SingleValueHandler<Number>(), this.generator.getPkColumnValue());\n    if (nextId == null) {\n        runner.update(this.getInsertSql(), this.generator.getPkColumnValue(), this.generator.getAllocationSize() + 1);\n        this.nextId = 1l;\n    } else {\n        this.nextId = nextId.longValue();\n        this.nextId += this.generator.getAllocationSize();\n        runner.update(this.getUpdateSql(), this.nextId, this.generator.getPkColumnValue());\n    }\n    return this.nextId;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1160, "method_signature": "Long getNextId()"}, "TableIdQueue.getUpdateSql": {"callee_method_names": [], "method_name": "TableIdQueue.getUpdateSql", "method_implementation": "{\n    if (this.updateSql == null) {\n        this.updateSql = //\n        \"UPDATE \" + this.generator.getTable() + \"\\nSET \" + this.generator.getValueColumnName() + //\n        \" = ?\" + \"\\nWHERE \" + this.generator.getPkColumnName() + \" = ?\";\n    }\n    return this.updateSql;\n}", "repo_id": "1", "comment": "/**\n * Returns the query to update the id table.\n *\n * @return the query to update the id table\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1161, "method_signature": "String getUpdateSql()"}, "Test1.test1": {"callee_method_names": ["Service.setParameters", "Service.setName", "Parameter.setName", "Service.getParameters"], "method_name": "Test1.test1", "method_implementation": "{\n    this.begin();\n    final Service service = new Service();\n    service.setParameters(new HashSet<Parameter>());\n    service.setName(\"test\");\n    final Parameter param = new Parameter();\n    param.setName(\"test\");\n    service.getParameters().add(param);\n    this.em().persist(service);\n    this.em().flush();\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Ref: http://stackoverflow.com/questions/12755380/jpa-persisting-a-unidirectional-one-to-many-relationship-fails-with-eclipselin\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2542, "method_signature": "void test1()"}, "Test2.test2": {"callee_method_names": [], "method_name": "Test2.test2", "method_implementation": "{\n    this.begin();\n    this.cq(\"select ent from OpSubject_vr ent where ent.okved_id_mult is null\");\n}", "repo_id": "1", "comment": "/**\n * Ref: http://stackoverflow.com/questions/12795407/jpa-how-to-select-objects-wich-has-no-multiple-attributes\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2536, "method_signature": "void test2()"}, "Test3.test": {"callee_method_names": ["TypedQuery<E1>.setParameter", "TypedQuery<E1>.getResultList"], "method_name": "Test3.test", "method_implementation": "{\n    final TypedQuery<E1> q = this.cq(\"select e1 from E1 e1 where :oem = e1.e2\", E1.class);\n    q.setParameter(\"oem\", new E2());\n    q.getResultList();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2558, "method_signature": "void test()"}, "Test4.test": {"callee_method_names": ["E2.getId", "TypedQuery<E1>.setParameter", "TypedQuery<E1>.getSingleResult", "E1.getE2", "E2.getId", "E1.getE2", "E2.getValue"], "method_name": "Test4.test", "method_implementation": "{\n    E2 e2 = new E2(\"Value\");\n    E1 e1 = new E1(e2);\n    this.persist(e1);\n    this.persist(e2);\n    this.commit();\n    this.close();\n    e2 = this.find(E2.class, e2.getId());\n    this.close();\n    final TypedQuery<E1> q = this.cq(\"select e1 from E1 e1 where e1.e2 = :e2\", E1.class);\n    q.setParameter(\"e2\", e2);\n    e1 = q.getSingleResult();\n    Assert.assertEquals(e1.getE2().getId(), e2.getId());\n    Assert.assertEquals(e1.getE2().getValue(), e2.getValue());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2557, "method_signature": "void test()"}, "TestClassLoader.getResourceAsStream": {"callee_method_names": ["String.equals", "String.equals"], "method_name": "TestClassLoader.getResourceAsStream", "method_implementation": "{\n    if (name.equals(TestClassLoader.FULL_PERSISTENCE_XML)) {\n        name = this.root + \"/\" + TestClassLoader.PERSISTENCE_XML;\n        return super.getResourceAsStream(name);\n    }\n    if (name.equals(TestClassLoader.FULL_ORM_XML)) {\n        name = this.root + \"/\" + TestClassLoader.ORM_XML;\n        return super.getResourceAsStream(name);\n    }\n    return super.getResourceAsStream(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2559, "method_signature": "InputStream getResourceAsStream(String)"}, "TestClassLoader.getResources": {"callee_method_names": ["String.equals", "String.equals"], "method_name": "TestClassLoader.getResources", "method_implementation": "{\n    if (name.equals(TestClassLoader.FULL_PERSISTENCE_XML)) {\n        name = this.root + \"/\" + TestClassLoader.PERSISTENCE_XML;\n        return super.getResources(name);\n    }\n    if (name.equals(TestClassLoader.FULL_ORM_XML)) {\n        name = this.root + \"/\" + TestClassLoader.ORM_XML;\n        return super.getResources(name);\n    }\n    return super.getResources(name);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2560, "method_signature": "Enumeration<URL> getResources(String)"}, "TestTemporalField.testTemporal": {"callee_method_names": ["TemporalFieldEntity.setCalendar", "TemporalFieldEntity.setDate", "Calendar.getTime", "TemporalFieldEntity.getId", "TemporalFieldEntity.getId", "TemporalFieldEntity.getId", "Calendar.getTime", "TemporalFieldEntity.getDate", "TemporalFieldEntity.getCalendar"], "method_name": "TestTemporalField.testTemporal", "method_implementation": "{\n    final Calendar testStartInstant = Calendar.getInstance();\n    final TemporalFieldEntity mainEntity = new TemporalFieldEntity();\n    mainEntity.setCalendar(testStartInstant);\n    mainEntity.setDate(testStartInstant.getTime());\n    persist(mainEntity);\n    this.commit();\n    this.close();\n    final TemporalFieldEntity mainEntityReloaded = find(TemporalFieldEntity.class, mainEntity.getId());\n    assertEquals(mainEntity.getId(), mainEntityReloaded.getId());\n    assertEquals(testStartInstant.getTime(), mainEntityReloaded.getDate());\n    assertEquals(testStartInstant, mainEntityReloaded.getCalendar());\n}", "repo_id": "1", "comment": "/**\n * Test for temporal Calendar and date type\n */\n", "repo_name": "BatooJPA-master/", "id": 2197, "method_signature": "void testTemporal()"}, "ToStringBuilder.appendDetail": {"callee_method_names": ["StringBuffer.append", "Map.entrySet", "int.hasNext", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "int.next", "StringBuffer.append", "Entry.getKey", "StringBuffer.append", "StringBuffer.append", "Entry.getValue", "int.hasNext", "StringBuffer.append", "StringBuffer.append"], "method_name": "ToStringBuilder.appendDetail", "method_implementation": "{\n    final String indent = this.indent();\n    buffer.append(\"{\");\n    try {\n        for (final Iterator i = map.entrySet().iterator(); i.hasNext(); ) {\n            buffer.append(SystemUtils.LINE_SEPARATOR);\n            buffer.append(indent);\n            buffer.append(\"  \");\n            final Entry entry = (Entry) i.next();\n            buffer.append(entry.getKey());\n            buffer.append(\"=\");\n            buffer.append(entry.getValue());\n            if (i.hasNext()) {\n                buffer.append(\",\");\n            }\n        }\n    } finally {\n        ToStringBuilder.indent.set(ToStringBuilder.indent.get().substring(2));\n    }\n    buffer.append(\"}\");\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 59, "method_signature": "void appendDetail(StringBuffer, String, Map)"}, "ToStringBuilder.appendEnd": {"callee_method_names": ["String.length", "String.substring"], "method_name": "ToStringBuilder.appendEnd", "method_implementation": "{\n    final String indent = ToStringBuilder.indent.get();\n    ToStringBuilder.indent.set(indent.length() == 0 ? null : indent.substring(2));\n    super.appendEnd(buffer, object);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 60, "method_signature": "void appendEnd(StringBuffer, Object)"}, "ToStringBuilder.appendFieldStart": {"callee_method_names": ["StringBuffer.append"], "method_name": "ToStringBuilder.appendFieldStart", "method_implementation": "{\n    buffer.append(ToStringBuilder.indent.get());\n    super.appendFieldStart(buffer, fieldName);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 61, "method_signature": "void appendFieldStart(StringBuffer, String)"}, "ToStringBuilder.appendStart": {"callee_method_names": [], "method_name": "ToStringBuilder.appendStart", "method_implementation": "{\n    this.indent();\n    super.appendStart(buffer, object);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 62, "method_signature": "void appendStart(StringBuffer, Object)"}, "ToStringBuilder.excludeFieldNames": {"callee_method_names": [], "method_name": "ToStringBuilder.excludeFieldNames", "method_implementation": "{\n    super.setExcludeFieldNames(fieldNames);\n    return this;\n}", "repo_id": "1", "comment": "/**\n * Sets the field names to exclude.\n *\n * @param fieldNames\n *            The excludeFieldNames to excluding from toString or <code>null</code>.\n * @return <code>this</code>\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 63, "method_signature": "ToStringBuilder excludeFieldNames(String[])"}, "TreeNodeTest.prepareCountries": {"callee_method_names": [], "method_name": "TreeNodeTest.prepareCountries", "method_implementation": "{\n    this.persist(this.generateBinaryTree());\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2195, "method_signature": "void prepareCountries()"}, "TreeNodeTest.testUpdateAndDelete": {"callee_method_names": ["Node.getChildren", "Node.setChildren", "Child3.setParent", "Node.setChildren", "Node.getId", "Node.getMyValue", "Node.getMyValue", "Node.getChildren", "Node.getChildren"], "method_name": "TreeNodeTest.testUpdateAndDelete", "method_implementation": "{\n    final Node root = this.find(Node.class, 1);\n    Node newRoot = new Node(1);\n    this.persist(newRoot);\n    List<Node> children = root.getChildren();\n    root.setChildren(null);\n    for (Node child : children) {\n        child.setParent(newRoot);\n    }\n    newRoot.setChildren(children);\n    this.remove(root);\n    this.commit();\n    this.close();\n    final Node newRoot2 = this.find(Node.class, newRoot.getId());\n    Assert.assertEquals(newRoot2.getMyValue(), newRoot.getMyValue());\n    Assert.assertEquals(newRoot.getChildren().size(), newRoot2.getChildren().size());\n}", "repo_id": "1", "comment": "/**\n * Tests to {@link EntityManager#remove(Object)} root with remove children.\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 2196, "method_signature": "void testUpdateAndDelete()"}, "TrimExpression.generateJpqlRestriction": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append"], "method_name": "TrimExpression.generateJpqlRestriction", "method_implementation": "{\n    final StringBuilder builder = new StringBuilder(\"trim(\");\n    if (this.trimspec != null) {\n        builder.append(this.trimspec.toString().toLowerCase(Locale.ENGLISH)).append(\" \");\n    }\n    if (this.trimChar != null) {\n        builder.append(this.trimChar.generateJpqlRestriction(query)).append(\" \");\n    }\n    if ((this.trimspec != null) || (this.trimChar != null)) {\n        builder.append(\"from \");\n    }\n    return //\n    builder.append(//\n    this.inner.generateJpqlRestriction(query)).append(\")\").toString();\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 660, "method_signature": "String generateJpqlRestriction(BaseQueryImpl)"}, "TrimExpression.generateJpqlSelect": {"callee_method_names": [], "method_name": "TrimExpression.generateJpqlSelect", "method_implementation": "{\n    if (selected && StringUtils.isBlank(this.getAlias())) {\n        return this.generateJpqlRestriction(query) + \" as \" + this.getAlias();\n    }\n    return this.generateJpqlRestriction(query);\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 661, "method_signature": "String generateJpqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "TrimExpression.generateSqlSelect": {"callee_method_names": ["AbstractCriteriaQueryImpl<?>.getAlias"], "method_name": "TrimExpression.generateSqlSelect", "method_implementation": "{\n    this.alias = query.getAlias(this);\n    if (selected) {\n        return this.getSqlRestrictionFragments(query)[0] + \" AS \" + this.alias;\n    }\n    return this.getSqlRestrictionFragments(query)[0];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 662, "method_signature": "String generateSqlSelect(AbstractCriteriaQueryImpl, boolean)"}, "TrimExpression.getSqlRestrictionFragments": {"callee_method_names": ["BaseQueryImpl<?>.getJdbcAdaptor"], "method_name": "TrimExpression.getSqlRestrictionFragments", "method_implementation": "{\n    final String argument = this.inner.getSqlRestrictionFragments(query)[0];\n    return new String[] { query.getJdbcAdaptor().applyTrim(this.trimspec, this.trimChar != null ? this.trimChar.getSqlRestrictionFragments(query)[0] : null, argument) };\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 663, "method_signature": "String[] getSqlRestrictionFragments(BaseQueryImpl)"}, "TupleImpl.get": {"callee_method_names": [], "method_name": "TupleImpl.get", "method_implementation": "{\n    final int index = this.selections.indexOf(tupleElement);\n    if (index == -1) {\n        throw new NullPointerException();\n    }\n    return (X) this.values[index];\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 690, "method_signature": "X get(TupleElement)"}, "TupleImpl.getElements": {"callee_method_names": ["List<TupleElement<?>>.addAll"], "method_name": "TupleImpl.getElements", "method_implementation": "{\n    final List<TupleElement<?>> tuples = Lists.newArrayList();\n    tuples.addAll(this.selections);\n    return tuples;\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 691, "method_signature": "List<TupleElement<?>> getElements()"}, "TypeFactory.getSqlType": {"callee_method_names": ["Class<?>.isArray", "Class<?>.getComponentType", "Class<?>.isArray", "Class<?>.getComponentType", "Class<?>.getComponentType"], "method_name": "TypeFactory.getSqlType", "method_implementation": "{\n    if (isLob) {\n        if (//\n        Character.class.isAssignableFrom(javaType) || //\n        String.class.isAssignableFrom(javaType) || (javaType.isArray() && char.class.isAssignableFrom(javaType.getComponentType()))) {\n            return Types.CLOB;\n        }\n        return Types.BLOB;\n    }\n    if (javaType.isArray()) {\n        if (Character.class.isAssignableFrom(javaType.getComponentType()) || char.class.isAssignableFrom(javaType.getComponentType())) {\n            return Types.CLOB;\n        }\n        return Types.BLOB;\n    }\n    if (Boolean.class.isAssignableFrom(javaType) || boolean.class.isAssignableFrom(javaType)) {\n        return Types.BOOLEAN;\n    }\n    if (String.class.isAssignableFrom(javaType)) {\n        return Types.VARCHAR;\n    }\n    if ((Calendar.class.isAssignableFrom(javaType)) || (Date.class.isAssignableFrom(javaType))) {\n        if (temporal == null) {\n            return Types.TIMESTAMP;\n        }\n        switch(temporal) {\n            case DATE:\n                return Types.DATE;\n            case TIME:\n                return Types.TIME;\n            case TIMESTAMP:\n                return Types.TIMESTAMP;\n        }\n    }\n    if (Enum.class.isAssignableFrom(javaType)) {\n        if ((enumType == null) || (enumType == EnumType.ORDINAL)) {\n            return Types.SMALLINT;\n        }\n        return Types.VARCHAR;\n    }\n    if (Integer.class.isAssignableFrom(javaType) || int.class.isAssignableFrom(javaType)) {\n        return Types.INTEGER;\n    }\n    if (Byte.class.isAssignableFrom(javaType) || byte.class.isAssignableFrom(javaType)) {\n        return Types.TINYINT;\n    }\n    if (Character.class.isAssignableFrom(javaType) || char.class.isAssignableFrom(javaType)) {\n        return Types.CHAR;\n    }\n    if (Short.class.isAssignableFrom(javaType) || short.class.isAssignableFrom(javaType)) {\n        return Types.SMALLINT;\n    }\n    if (Long.class.isAssignableFrom(javaType) || long.class.isAssignableFrom(javaType)) {\n        return Types.BIGINT;\n    }\n    if (Float.class.isAssignableFrom(javaType) || float.class.isAssignableFrom(javaType)) {\n        return Types.FLOAT;\n    }\n    if (Double.class.isAssignableFrom(javaType) || double.class.isAssignableFrom(javaType)) {\n        return Types.DOUBLE;\n    }\n    if (java.sql.Date.class.isAssignableFrom(javaType)) {\n        return Types.DATE;\n    }\n    if (java.sql.Time.class.isAssignableFrom(javaType)) {\n        return Types.TIME;\n    }\n    if (java.sql.Timestamp.class.isAssignableFrom(javaType)) {\n        return Types.TIMESTAMP;\n    }\n    if (BigDecimal.class.isAssignableFrom(javaType) || BigInteger.class.isAssignableFrom(javaType)) {\n        return Types.DECIMAL;\n    }\n    throw new IllegalArgumentException(\"Cannot determine sql type: \" + javaType);\n}", "repo_id": "1", "comment": "/**\n * Returns the SQL type of the java type\n *\n * @param javaType\n *            the java type\n * @param temporal\n *            temporal type of the type\n * @param enumType\n *            enum type of the type\n * @param isLob\n *            if is a lob type\n * @return the corresponding SQL Type\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 1159, "method_signature": "int getSqlType(Class, TemporalType, EnumType, boolean)"}, "UniqueConstraintsElement.handleChild": {"callee_method_names": [], "method_name": "UniqueConstraintsElement.handleChild", "method_implementation": "{\n    if (child instanceof ColumnNameElement) {\n        this.columnNames.add(((ColumnNameElement) child).getName());\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 1123, "method_signature": "void handleChild(Element)"}, "UnsafeFieldAccessor.get": {"callee_method_names": [], "method_name": "UnsafeFieldAccessor.get", "method_implementation": "{\n    if (this.primitiveType == null) {\n        return ReflectHelper.unsafe.getObject(instance, this.fieldOffset);\n    }\n    switch(this.primitiveType) {\n        case BOOLEAN:\n            return Boolean.valueOf(ReflectHelper.unsafe.getBoolean(instance, this.fieldOffset));\n        case INTEGER:\n            return Integer.valueOf(ReflectHelper.unsafe.getInt(instance, this.fieldOffset));\n        case FLOAT:\n            return Float.valueOf(ReflectHelper.unsafe.getFloat(instance, this.fieldOffset));\n        case DOUBLE:\n            return Double.valueOf(ReflectHelper.unsafe.getDouble(instance, this.fieldOffset));\n        case LONG:\n            return Long.valueOf(ReflectHelper.unsafe.getLong(instance, this.fieldOffset));\n        case SHORT:\n            return Short.valueOf(ReflectHelper.unsafe.getShort(instance, this.fieldOffset));\n        case BYTE:\n            return Byte.valueOf(ReflectHelper.unsafe.getByte(instance, this.fieldOffset));\n        default:\n            // CHAR\n            return Character.valueOf(ReflectHelper.unsafe.getChar(instance, this.fieldOffset));\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 0, "method_signature": "Object get(Object)"}, "UnsafeFieldAccessor.getPrimitiveType": {"callee_method_names": ["Class<?>.isPrimitive"], "method_name": "UnsafeFieldAccessor.getPrimitiveType", "method_implementation": "{\n    final Class<?> type = this.field.getType();\n    if (type.isPrimitive()) {\n        for (final PrimitiveType primitiveType : PrimitiveType.values()) {\n            if (primitiveType.clazz == type) {\n                return primitiveType;\n            }\n        }\n    }\n    return null;\n}", "repo_id": "1", "comment": "/**\n * @return\n *\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 1, "method_signature": "PrimitiveType getPrimitiveType()"}, "UnsafeFieldAccessor.set": {"callee_method_names": ["Object.getClass"], "method_name": "UnsafeFieldAccessor.set", "method_implementation": "{\n    if (instance == null) {\n        throw new NullPointerException();\n    }\n    if (this.primitiveType == null) {\n        if ((this.numberType != null) && (value != null) && (this.numberType != value.getClass())) {\n            final Number number = ReflectHelper.convertNumber((Number) value, this.numberType);\n            ReflectHelper.unsafe.putObject(instance, this.fieldOffset, number);\n        } else {\n            ReflectHelper.unsafe.putObject(instance, this.fieldOffset, value);\n        }\n    } else {\n        switch(this.primitiveType) {\n            case BOOLEAN:\n                if (value instanceof Number) {\n                    ReflectHelper.unsafe.putBoolean(instance, this.fieldOffset, ((Number) value).byteValue() == 0 ? false : true);\n                } else {\n                    ReflectHelper.unsafe.putBoolean(instance, this.fieldOffset, (Boolean) value);\n                }\n                break;\n            case INTEGER:\n                ReflectHelper.unsafe.putInt(instance, this.fieldOffset, ((Number) value).intValue());\n                break;\n            case FLOAT:\n                ReflectHelper.unsafe.putFloat(instance, this.fieldOffset, ((Number) value).floatValue());\n                break;\n            case DOUBLE:\n                ReflectHelper.unsafe.putDouble(instance, this.fieldOffset, ((Number) value).doubleValue());\n                break;\n            case LONG:\n                ReflectHelper.unsafe.putLong(instance, this.fieldOffset, ((Number) value).longValue());\n                break;\n            case SHORT:\n                ReflectHelper.unsafe.putShort(instance, this.fieldOffset, ((Number) value).shortValue());\n                break;\n            case BYTE:\n                ReflectHelper.unsafe.putByte(instance, this.fieldOffset, ((Number) value).byteValue());\n                break;\n            default:\n                // CHAR\n                if (value == null) {\n                    ReflectHelper.unsafe.putChar(instance, this.fieldOffset, '\\u0000');\n                } else {\n                    ReflectHelper.unsafe.putChar(instance, this.fieldOffset, (Character) value);\n                }\n                break;\n        }\n    }\n}", "repo_id": "1", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "BatooJPA-master/", "id": 2, "method_signature": "void set(Object, Object)"}, "UpdateJpqlTest.prepareCountries": {"callee_method_names": [], "method_name": "UpdateJpqlTest.prepareCountries", "method_implementation": "{\n    this.begin();\n    this.persist(UpdateJpqlTest.TR);\n    this.persist(UpdateJpqlTest.USA);\n    this.persist(UpdateJpqlTest.UK);\n    this.persist(UpdateJpqlTest.BROKEN);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2412, "method_signature": "void prepareCountries()"}, "UpdateJpqlTest.testDelete": {"callee_method_names": [], "method_name": "UpdateJpqlTest.testDelete", "method_implementation": "{\n    Assert.assertEquals((Long) 4l, this.cq(\"select count(c) from Country c\", Long.class).getSingleResult());\n    this.begin();\n    this.cu(\"delete from Country c where c = :code\").setParameter(\"code\", UpdateJpqlTest.TR).executeUpdate();\n    this.commit();\n    Assert.assertEquals((Long) 3l, this.cq(\"select count(c) from Country c\", Long.class).getSingleResult());\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2413, "method_signature": "void testDelete()"}, "UpdateJpqlTest.testUpdate": {"callee_method_names": [], "method_name": "UpdateJpqlTest.testUpdate", "method_implementation": "{\n    this.begin();\n    this.cu(\"update Country c set c.name = :name where c = :code\").setParameter(\"code\", UpdateJpqlTest.TR).setParameter(\"name\", \"TURKEY\").executeUpdate();\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2414, "method_signature": "void testUpdate()"}, "UpdateJpqlTest.testUpdate2": {"callee_method_names": [], "method_name": "UpdateJpqlTest.testUpdate2", "method_implementation": "{\n    this.begin();\n    this.cu(\"update Country c set name = :name where c = :code\").setParameter(\"code\", UpdateJpqlTest.TR).setParameter(\"name\", \"TURKEY\").executeUpdate();\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2415, "method_signature": "void testUpdate2()"}, "UpdateJpqlTest.testUpdate3": {"callee_method_names": [], "method_name": "UpdateJpqlTest.testUpdate3", "method_implementation": "{\n    this.begin();\n    this.cu(\"update Country c set lastActivity = :date where c = :code\").setParameter(\"code\", UpdateJpqlTest.TR).setParameter(\"date\", new Date()).executeUpdate();\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2416, "method_signature": "void testUpdate3()"}, "ValidationTest.testPersist": {"callee_method_names": ["Foo.getBars"], "method_name": "ValidationTest.testPersist", "method_implementation": "{\n    final Foo foo = new Foo();\n    foo.getBars().add(new Bar());\n    this.persist(foo);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests the validation persist\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2496, "method_signature": "void testPersist()"}, "ValidationTest.testRemove": {"callee_method_names": ["Foo.setValue", "Foo.getId", "Foo.setValue2", "Foo.getId"], "method_name": "ValidationTest.testRemove", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"value\");\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    foo.setValue2(10);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    this.remove(foo);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests the validation persist\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2497, "method_signature": "void testRemove()"}, "ValidationTest.testRemoveOk": {"callee_method_names": ["Foo.setValue", "Bar.setFoo", "Bar.setValue", "Foo.getBars", "Foo.getId"], "method_name": "ValidationTest.testRemoveOk", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"value\");\n    final Bar bar = new Bar();\n    bar.setFoo(foo);\n    bar.setValue(\"value\");\n    foo.getBars().add(bar);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    this.remove(foo);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests the validation persist\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2498, "method_signature": "void testRemoveOk()"}, "ValidationTest.testUpdate": {"callee_method_names": ["Foo.setValue", "Bar.setFoo", "Bar.setValue", "Foo.getBars", "Foo.getId", "Foo.setValue"], "method_name": "ValidationTest.testUpdate", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"value\");\n    final Bar bar = new Bar();\n    bar.setFoo(foo);\n    bar.setValue(\"value\");\n    foo.getBars().add(bar);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    foo.setValue(\"value_\");\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests the validation persist\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2499, "method_signature": "void testUpdate()"}, "ValidationTest.testUpdateOk": {"callee_method_names": ["Foo.setValue", "Bar.setFoo", "Bar.setValue", "Foo.getBars", "Foo.getId", "Foo.setValue", "Foo.setValue2"], "method_name": "ValidationTest.testUpdateOk", "method_implementation": "{\n    Foo foo = new Foo();\n    foo.setValue(\"value\");\n    final Bar bar = new Bar();\n    bar.setFoo(foo);\n    bar.setValue(\"value\");\n    foo.getBars().add(bar);\n    this.persist(foo);\n    this.commit();\n    this.close();\n    this.begin();\n    foo = this.find(Foo.class, foo.getId());\n    foo.setValue(\"value_\");\n    foo.setValue2(1);\n    this.commit();\n}", "repo_id": "1", "comment": "/**\n * Tests the validation persist\n *\n * @since 2.0.0\n */\n", "repo_name": "BatooJPA-master/", "id": 2500, "method_signature": "void testUpdateOk()"}, "ValueConverter.fromJdbc": {"callee_method_names": ["Calendar.setTime", "Calendar.setTime", "Calendar.setTime", "Class<Enum<?>>.getMethod", "Class<Enum<?>>.getMethod", "Method.invoke"], "method_name": "ValueConverter.fromJdbc", "method_implementation": "{\n    if (value == null) {\n        return null;\n    }\n    if (temporalType != null) {\n        if (javaType == Calendar.class) {\n            final Calendar calendarValue = Calendar.getInstance();\n            switch(temporalType) {\n                case DATE:\n                    if (value instanceof java.sql.Date) {\n                        calendarValue.setTime((java.sql.Date) value);\n                        return calendarValue;\n                    }\n                case TIME:\n                    if (value instanceof java.sql.Time) {\n                        calendarValue.setTime((java.sql.Time) value);\n                        return calendarValue;\n                    }\n                case TIMESTAMP:\n                    if (value instanceof java.sql.Timestamp) {\n                        calendarValue.setTime((java.sql.Timestamp) value);\n                        return calendarValue;\n                    }\n            }\n        }\n    }\n    if (enumType != null) {\n        try {\n            final Class<Enum<?>> enumJavaType = (Class<Enum<?>>) javaType;\n            if (enumType == EnumType.ORDINAL && values == null) {\n                values = (Enum<?>[]) enumJavaType.getMethod(\"values\").invoke(null);\n            } else if (enumType == EnumType.STRING && method == null) {\n                method = enumJavaType.getMethod(\"valueOf\", String.class);\n            }\n            if (enumType == EnumType.ORDINAL) {\n                value = values[((Number) value).shortValue()];\n            } else {\n                value = method.invoke(null, value);\n            }\n        } catch (final Exception e) {\n        }\n    }\n    if (lob) {\n        value = readLob(value, javaType);\n    }\n    return value;\n}", "repo_id": "1", "comment": "/**\n * convert jdbc data to entity basic values\n *\n * @param value\n *            jdbc raw value\n * @param javaType\n *            type of value\n * @param temporalType\n *            temporal type\n * @param enumType\n *            enum type\n * @param values\n *            EnumType values array for faster operation, leave it to be null but it will be slow\n * @param method\n *            Method for enum valueOf for faster operation, leave it to be null but it will be slow\n * @param lob\n *            is Lob\n * @return java value\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 1166, "method_signature": "Object fromJdbc(Object, Class, TemporalType, EnumType, Enum<?>[], Method, boolean)"}, "ValueConverter.toJdbc": {"callee_method_names": ["Enum<?>.ordinal", "Enum<?>.name", "ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray"], "method_name": "ValueConverter.toJdbc", "method_implementation": "{\n    if (value == null) {\n        return null;\n    }\n    if (temporalType != null) {\n        switch(temporalType) {\n            case DATE:\n                if (value instanceof java.sql.Date) {\n                    return value;\n                }\n                if (value instanceof Date) {\n                    return new java.sql.Date(((Date) value).getTime());\n                }\n                return new java.sql.Date(((Calendar) value).getTimeInMillis());\n            case TIME:\n                if (value instanceof java.sql.Time) {\n                    return value;\n                }\n                if (value instanceof Date) {\n                    return new java.sql.Time(((Date) value).getTime());\n                }\n                return new java.sql.Time(((Calendar) value).getTimeInMillis());\n            case TIMESTAMP:\n                if (value instanceof java.sql.Timestamp) {\n                    return value;\n                }\n                if (value instanceof Date) {\n                    return new java.sql.Timestamp(((Date) value).getTime());\n                }\n                return new java.sql.Timestamp(((Calendar) value).getTimeInMillis());\n        }\n    }\n    if (Number.class.isAssignableFrom(javaType)) {\n        return ReflectHelper.convertNumber((Number) value, javaType);\n    }\n    if (enumType != null) {\n        final Enum<?> enumValue = (Enum<?>) value;\n        if (enumType == EnumType.ORDINAL) {\n            return enumValue.ordinal();\n        }\n        return enumValue.name();\n    }\n    if (lob) {\n        try {\n            if (javaType == String.class) {\n                return new SerialClob(((String) value).toCharArray());\n            } else if (javaType == char[].class) {\n                return new SerialClob((char[]) value);\n            } else if (javaType == byte[].class) {\n                return new SerialBlob((byte[]) value);\n            } else {\n                final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                final ObjectOutputStream oos = new ObjectOutputStream(os);\n                try {\n                    oos.writeObject(value);\n                } finally {\n                    oos.close();\n                }\n                return new SerialBlob(os.toByteArray());\n            }\n        } catch (final Exception e) {\n            throw new PersistenceException(\"Cannot set parameter\", e);\n        }\n    } else {\n        return value;\n    }\n}", "repo_id": "1", "comment": "/**\n * convert java objects to jdbc friendly\n *\n * @param value\n *            jdbc raw value\n * @param javaType\n *            type of value\n * @param temporalType\n *            temporal type\n * @param enumType\n *            enum type\n * @param lob\n *            is Lob\n * @return jdbc friendly value\n * @since 2.0.1\n */\n", "repo_name": "BatooJPA-master/", "id": 1167, "method_signature": "Object toJdbc(Object, Class, TemporalType, EnumType, boolean)"}}